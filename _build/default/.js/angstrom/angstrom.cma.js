// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_ba_get_1=runtime.caml_ba_get_1,
     caml_int32_float_of_bits=runtime.caml_int32_float_of_bits,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_update_dummy=runtime.caml_update_dummy;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_string_of_jsbytes(": "),
     cst$0=caml_string_of_jsbytes(" > "),
     cst_prompt_input_shrunk=caml_string_of_jsbytes("prompt: input shrunk!"),
     cst_count_while1$0=caml_string_of_jsbytes("count_while1"),
     cst_count_while1=caml_string_of_jsbytes("count_while1"),
     cst_LE_int64=caml_string_of_jsbytes("LE.int64"),
     cst_LE_int32=caml_string_of_jsbytes("LE.int32"),
     cst_LE_int16=caml_string_of_jsbytes("LE.int16"),
     cst_BE_int64=caml_string_of_jsbytes("BE.int64"),
     cst_BE_int32=caml_string_of_jsbytes("BE.int32"),
     cst_BE_int16=caml_string_of_jsbytes("BE.int16"),
     cst_consumed_parser_committed=
      caml_string_of_jsbytes("consumed: parser committed"),
     cst_count_n_0=caml_string_of_jsbytes("count: n < 0"),
     cst_no_more_choices=caml_string_of_jsbytes("no more choices"),
     cst_take_bigstring_n_0=caml_string_of_jsbytes("take_bigstring: n < 0"),
     cst_take_n_0=caml_string_of_jsbytes("take: n < 0"),
     cst_skip=caml_string_of_jsbytes("skip"),
     cst_advance=caml_string_of_jsbytes("advance"),
     cst_end_of_input=caml_string_of_jsbytes("end_of_input"),
     cst_not_enough_input=caml_string_of_jsbytes("not enough input"),
     cst_not_enough_input$0=caml_string_of_jsbytes("not enough input"),
     cst_parse_invalid_argument_ini=
      caml_string_of_jsbytes
       ("parse: invalid argument, initial_buffer_size < 1"),
     cst_end_of_line=caml_string_of_jsbytes("end_of_line"),
     cst$1=caml_string_of_jsbytes("\r\n"),
     Stdlib=global_data.Stdlib,
     Stdlib_String=global_data.Stdlib__String,
     Bigstringaf=global_data.Bigstringaf,
     Assert_failure=global_data.Assert_failure,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Int64=global_data.Stdlib__Int64,
     Stdlib_Int32=global_data.Stdlib__Int32,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Sys=global_data.Stdlib__Sys,
     Angstrom=[0];
    caml_register_global(42,Angstrom,"Angstrom__");
    var Angstrom_More=[0];
    caml_register_global(43,Angstrom_More,"Angstrom__More");
    var
     _a_=[1,caml_string_of_jsbytes("incomplete input")],
     _c_=[0,caml_string_of_jsbytes("lib/input.ml"),59,2],
     _b_=[0,caml_string_of_jsbytes("lib/input.ml"),60,2],
     _k_=[0,caml_string_of_jsbytes("lib/buffering.ml"),79,2],
     _j_=[0,caml_string_of_jsbytes("lib/buffering.ml"),64,2],
     _i_=[0,caml_string_of_jsbytes("lib/buffering.ml"),53,2],
     _h_=[0,caml_string_of_jsbytes("lib/buffering.ml"),54,2],
     _g_=[0,caml_string_of_jsbytes("lib/buffering.ml"),46,2],
     _f_=[0,caml_string_of_jsbytes("lib/buffering.ml"),47,2],
     _e_=[0,caml_string_of_jsbytes("lib/buffering.ml"),7,2],
     _d_=[0,caml_string_of_jsbytes("lib/buffering.ml"),8,2],
     _r_=[1,caml_string_of_jsbytes("string")],
     _q_=
      [0,
       [11,caml_string_of_jsbytes("int8 "),[4,0,0,0,0]],
       caml_string_of_jsbytes("int8 %d")],
     _p_=
      [0,
       [11,caml_string_of_jsbytes("not char "),[1,0]],
       caml_string_of_jsbytes("not char %C")],
     _o_=
      [0,
       [11,caml_string_of_jsbytes("char "),[1,0]],
       caml_string_of_jsbytes("char %C")],
     _n_=
      [0,
       [11,caml_string_of_jsbytes("satisfy: "),[1,0]],
       caml_string_of_jsbytes("satisfy: %C")],
     _m_=
      [0,
       [11,caml_string_of_jsbytes("satisfy: "),[1,0]],
       caml_string_of_jsbytes("satisfy: %C")],
     _l_=[1,caml_string_of_jsbytes("incomplete input")];
    function state_to_option(x)
     {switch(x[0])
       {case 0:return 0;case 1:var v=x[2];return [0,v];default:return 0}}
    function fail_to_string(marks,err)
     {var
       _al_=caml_call2(Stdlib[28],cst,err),
       _am_=caml_call2(Stdlib_String[6],cst$0,marks);
      return caml_call2(Stdlib[28],_am_,_al_)}
    function state_to_result(x)
     {switch(x[0])
       {case 0:return _a_;
        case 1:var v=x[2];return [0,v];
        default:var err=x[3],marks=x[2];return [1,fail_to_string(marks,err)]}}
    var include=[0,state_to_option,fail_to_string,state_to_result];
    caml_register_global(46,include,"Angstrom__Exported_state");
    function create(buffer,off,len,committed_bytes)
     {return [0,committed_bytes,committed_bytes,off,len,buffer]}
    function length(t){return t[2] + t[4] | 0}
    function client_committed_bytes(t){return t[2]}
    function parser_committed_bytes(t){return t[1]}
    function bytes_for_client_to_commit(t){return t[1] - t[2] | 0}
    function parser_uncommitted_bytes(t)
     {var _ak_=bytes_for_client_to_commit(t);return t[4] - _ak_ | 0}
    function invariant(t)
     {var _ah_=length(t),_ai_=parser_uncommitted_bytes(t);
      if((t[1] + _ai_ | 0) !== _ah_)throw [0,Assert_failure,_c_];
      var _aj_=bytes_for_client_to_commit(t);
      if((t[1] - t[2] | 0) === _aj_)return 0;
      throw [0,Assert_failure,_b_]}
    function offset_in_buffer(t,pos){return (t[3] + pos | 0) - t[2] | 0}
    function apply(t,pos,len,f)
     {var off=offset_in_buffer(t,pos);return caml_call3(f,t[5],off,len)}
    function unsafe_get_char(t,pos)
     {var off=offset_in_buffer(t,pos);return caml_ba_get_1(t[5],off)}
    function unsafe_get_int16_le(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[30],t[5],off)}
    function unsafe_get_int32_le(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[36],t[5],off)}
    function unsafe_get_int64_le(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[40],t[5],off)}
    function unsafe_get_int16_be(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[31],t[5],off)}
    function unsafe_get_int32_be(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[37],t[5],off)}
    function unsafe_get_int64_be(t,pos)
     {var off=offset_in_buffer(t,pos);
      return caml_call2(Bigstringaf[41],t[5],off)}
    function count_while(t,pos,f)
     {var
       buffer=t[5],
       off=offset_in_buffer(t,pos),
       i=[0,off],
       limit=t[3] + t[4] | 0;
      for(;;)
       {if(i[1] < limit && caml_call1(f,caml_ba_get_1(buffer,i[1])))
         {i[1]++;continue}
        return i[1] - off | 0}}
    function commit(t,pos){t[1] = pos;return 0}
    var
     Angstrom_Input=
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
    caml_register_global(49,Angstrom_Input,"Angstrom__Input");
    var State=[0];
    function fail_k(input,pos,param,marks,msg)
     {return [3,pos - input[2] | 0,marks,msg]}
    function succeed_k(input,pos,param,v){return [2,pos - input[2] | 0,v]}
    function to_exported_state(param)
     {var param$0=param;
      for(;;)
       switch(param$0[0])
        {case 0:
          var match=param$0[1],continue$0=match[2],committed=match[1];
          return [0,
                  [0,
                   committed,
                   function(bs,off,len,more)
                    {return to_exported_state
                             (caml_call4(continue$0,bs,off,len,more))}]];
         case 1:
          var
           x=param$0[1],
           _ag_=caml_obj_tag(x),
           param$1=
            250 === _ag_?x[1]:246 === _ag_?caml_call1(CamlinternalLazy[2],x):x,
           param$0=param$1;
          continue;
         case 2:var x$0=param$0[2],i=param$0[1];return [1,i,x$0];
         default:
          var s=param$0[3],sl=param$0[2],i$0=param$0[1];return [2,i$0,sl,s]}}
    function parse(p)
     {var input=[0,0,0,0,0,Bigstringaf[2]];
      return to_exported_state(caml_call5(p[1],input,0,1,fail_k,succeed_k))}
    function parse_bigstring(p,input)
     {var input$0=[0,0,0,0,caml_call1(Bigstringaf[6],input),input];
      return state_to_result
              (to_exported_state
                (caml_call5(p[1],input$0,0,0,fail_k,succeed_k)))}
    function return$0(v)
     {return [0,
              function(input,pos,more,fail,succ)
               {return caml_call4(succ,input,pos,more,v)}]}
    function fail(msg)
     {return [0,
              function(input,pos,more,fail,succ)
               {return caml_call5(fail,input,pos,more,0,msg)}]}
    function symbol_bind(p,f)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ$0(input,pos,more,v)
                 {return caml_call5
                          (caml_call1(f,v)[1],input,pos,more,fail,succ)}
                return caml_call5(p[1],input,pos,more,fail,succ$0)}]}
    function symbol_map(p,f)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ$0(input,pos,more,v)
                 {return caml_call4(succ,input,pos,more,caml_call1(f,v))}
                return caml_call5(p[1],input,pos,more,fail,succ$0)}]}
    function symbol(f,m){return symbol_map(m,f)}
    function symbol$0(f,m)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ0(input0,pos0,more0,f)
                 {function succ1(input1,pos1,more1,m)
                   {return caml_call4(succ,input1,pos1,more1,caml_call1(f,m))}
                  return caml_call5(m[1],input0,pos0,more0,fail,succ1)}
                return caml_call5(f[1],input,pos,more,fail,succ0)}]}
    function lift(f,m){return symbol(f,m)}
    function lift2(f,m1,m2)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ1(input1,pos1,more1,m1)
                 {function succ2(input2,pos2,more2,m2)
                   {return caml_call4
                            (succ,input2,pos2,more2,caml_call2(f,m1,m2))}
                  return caml_call5(m2[1],input1,pos1,more1,fail,succ2)}
                return caml_call5(m1[1],input,pos,more,fail,succ1)}]}
    function lift3(f,m1,m2,m3)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ1(input1,pos1,more1,m1)
                 {function succ2(input2,pos2,more2,m2)
                   {function succ3(input3,pos3,more3,m3)
                     {return caml_call4
                              (succ,input3,pos3,more3,caml_call3(f,m1,m2,m3))}
                    return caml_call5(m3[1],input2,pos2,more2,fail,succ3)}
                  return caml_call5(m2[1],input1,pos1,more1,fail,succ2)}
                return caml_call5(m1[1],input,pos,more,fail,succ1)}]}
    function lift4(f,m1,m2,m3,m4)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ1(input1,pos1,more1,m1)
                 {function succ2(input2,pos2,more2,m2)
                   {function succ3(input3,pos3,more3,m3)
                     {function succ4(input4,pos4,more4,m4)
                       {return caml_call4
                                (succ,input4,pos4,more4,caml_call4(f,m1,m2,m3,m4))}
                      return caml_call5(m4[1],input3,pos3,more3,fail,succ4)}
                    return caml_call5(m3[1],input2,pos2,more2,fail,succ3)}
                  return caml_call5(m2[1],input1,pos1,more1,fail,succ2)}
                return caml_call5(m1[1],input,pos,more,fail,succ1)}]}
    function symbol$1(a,b)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ$0(input,pos,more,param)
                 {return caml_call5(b[1],input,pos,more,fail,succ)}
                return caml_call5(a[1],input,pos,more,fail,succ$0)}]}
    function symbol$2(a,b)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ0(input0,pos0,more0,x)
                 {function succ1(input1,pos1,more1,param)
                   {return caml_call4(succ,input1,pos1,more1,x)}
                  return caml_call5(b[1],input0,pos0,more0,fail,succ1)}
                return caml_call5(a[1],input,pos,more,fail,succ0)}]}
    var
     Monad=
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
    function symbol$3(p,mark)
     {return [0,
              function(input,pos,more,fail,succ)
               {function fail$0(input,pos,more,marks,msg)
                 {return caml_call5(fail,input,pos,more,[0,mark,marks],msg)}
                return caml_call5(p[1],input,pos,more,fail$0,succ)}]}
    function symbol$4(p,q)
     {return [0,
              function(input,pos,more,fail,succ)
               {function fail$0(input,pos$0,more$0,marks,msg)
                 {return pos < input[1]
                          ?caml_call5(fail,input,pos$0,more,marks,msg)
                          :caml_call5(q[1],input,pos,more$0,fail,succ)}
                return caml_call5(p[1],input,pos,more,fail$0,succ)}]}
    var
     include$0=[0,symbol$3,symbol$4],
     return$1=Monad[1],
     fail$0=Monad[2],
     symbol_bind$0=Monad[3];
    function symbol_map$0(m,f)
     {return caml_call2
              (symbol_bind$0,
               m,
               function(x){return caml_call1(return$1,caml_call1(f,x))})}
    function symbol$5(f,m){return symbol_map$0(m,f)}
    function symbol$6(f,m)
     {return caml_call2(symbol_bind$0,f,function(f){return symbol_map$0(m,f)})}
    function lift2$0(f,m1,m2){return symbol$6(symbol$5(f,m1),m2)}
    function lift3$0(f,m1,m2,m3)
     {return symbol$6(symbol$6(symbol$5(f,m1),m2),m3)}
    function lift4$0(f,m1,m2,m3,m4)
     {return symbol$6(symbol$6(symbol$6(symbol$5(f,m1),m2),m3),m4)}
    function symbol$7(a,b)
     {return caml_call2(symbol_bind$0,a,function(param){return b})}
    function symbol$8(a,b)
     {return caml_call2
              (symbol_bind$0,
               a,
               function(x){return symbol_map$0(b,function(param){return x})})}
    var
     Monad_use_for_debugging=
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
     Angstrom_Parser=
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       include$0,
       Monad_use_for_debugging];
    caml_register_global(51,Angstrom_Parser,"Angstrom__Parser");
    function of_bigstring(off,len,buf)
     {if(0 > off)throw [0,Assert_failure,_e_];
      if((len - off | 0) <= caml_call1(Bigstringaf[6],buf))
       return [0,buf,off,len];
      throw [0,Assert_failure,_d_]}
    function create$0(len)
     {return of_bigstring(0,0,caml_call1(Bigstringaf[1],len))}
    function writable_space(t)
     {var _af_=t[3];return caml_call1(Bigstringaf[6],t[1]) - _af_ | 0}
    function ensure(t,to_copy)
     {var
       _ad_=t[2] + t[3] | 0,
       _ae_=(caml_call1(Bigstringaf[6],t[1]) - _ad_ | 0) < to_copy?1:0;
      if(! _ae_)return _ae_;
      if(to_copy <= writable_space(t))
       {caml_call5(Bigstringaf[44],t[1],t[2],t[1],0,t[3]);t[2] = 0;return 0}
      var
       old_len=caml_call1(Bigstringaf[6],t[1]),
       new_len=[0,old_len],
       space=writable_space(t);
      for(;;)
       {if(((space + new_len[1] | 0) - old_len | 0) < to_copy)
         {new_len[1] = (3 * new_len[1] | 0) / 2 | 0;continue}
        var new_buf=caml_call1(Bigstringaf[1],new_len[1]);
        caml_call5(Bigstringaf[44],t[1],t[2],new_buf,0,t[3]);
        t[1] = new_buf;
        t[2] = 0;
        return 0}}
    function write_pos(t){return t[2] + t[3] | 0}
    function feed_string(t,off,len,str)
     {if(0 > off)throw [0,Assert_failure,_g_];
      if((len - off | 0) > caml_ml_string_length(str))
       throw [0,Assert_failure,_f_];
      ensure(t,len);
      var _ac_=write_pos(t);
      caml_call5(Bigstringaf[45],str,off,t[1],_ac_,len);
      t[3] = t[3] + len | 0;
      return 0}
    function feed_bigstring(t,off,len,b)
     {if(0 > off)throw [0,Assert_failure,_i_];
      if((len - off | 0) > caml_call1(Bigstringaf[6],b))
       throw [0,Assert_failure,_h_];
      ensure(t,len);
      var _ab_=write_pos(t);
      caml_call5(Bigstringaf[44],b,off,t[1],_ab_,len);
      t[3] = t[3] + len | 0;
      return 0}
    function feed_input(t,param)
     {if(608227697 <= param[1])
       {var b=param[2];
        return feed_bigstring(t,0,caml_call1(Bigstringaf[6],b),b)}
      var s=param[2];
      return feed_string(t,0,caml_ml_string_length(s),s)}
    function shift(t,n)
     {if(n > t[3])throw [0,Assert_failure,_j_];
      t[2] = t[2] + n | 0;
      t[3] = t[3] - n | 0;
      return 0}
    function for_reading(param)
     {var buf=param[1],off=param[2],len=param[3];
      return caml_call3(Bigstringaf[5],buf,off,len)}
    function unconsumed(opt,param)
     {if(opt)var sth=opt[1],shift=sth;else var shift=0;
      var buf=param[1],off=param[2],len=param[3];
      if(shift <= len)return [0,buf,off + shift | 0,len - shift | 0];
      throw [0,Assert_failure,_k_]}
    function of_unconsumed(param)
     {var len=param[3],off=param[2],buf=param[1];return [0,buf,off,len]}
    var
     Angstrom_Buffering=
      [0,
       create$0,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
    caml_register_global(52,Angstrom_Buffering,"Angstrom__Buffering");
    var
     return$2=Monad[1],
     fail$1=Monad[2],
     symbol_bind$1=Monad[3],
     symbol_map$1=Monad[4],
     symbol$9=Monad[5],
     symbol$10=Monad[6],
     lift$0=Monad[7],
     lift2$1=Monad[8],
     lift3$1=Monad[9],
     lift4$1=Monad[10],
     symbol$11=Monad[11],
     symbol$12=Monad[12],
     symbol$13=include$0[1],
     symbol$14=include$0[2];
    function from_unbuffered_state(f,buffering,param)
     {switch(param[0])
       {case 0:var p=param[1];return [0,caml_call1(f,p)];
        case 1:
         var
          v=param[2],
          consumed=param[1],
          unconsumed$0=unconsumed([0,consumed],buffering);
         return [1,unconsumed$0,v];
        default:
         var
          msg=param[3],
          marks=param[2],
          consumed$0=param[1],
          unconsumed$1=unconsumed([0,consumed$0],buffering);
         return [2,unconsumed$1,marks,msg]}}
    function parse$0(opt,p)
     {if(opt)
       var sth=opt[1],initial_buffer_size=sth;
      else
       var initial_buffer_size=4096;
      if(initial_buffer_size < 1)
       caml_call1(Stdlib[2],cst_parse_invalid_argument_ini);
      var buffering=create$0(initial_buffer_size);
      function f(p,input)
       {shift(buffering,p[1]);
        var
         more=typeof input === "number"?0:(feed_input(buffering,input),1),
         for_reading$0=for_reading(buffering),
         _aa_=caml_call1(Bigstringaf[6],for_reading$0);
        return from_unbuffered_state
                (f,buffering,caml_call4(p[2],for_reading$0,0,_aa_,more))}
      return from_unbuffered_state(f,buffering,parse(p))}
    function feed(state,input)
     {switch(state[0])
       {case 0:var k=state[1];return caml_call1(k,input);
        case 1:
         var v=state[2],unconsumed$0=state[1];
         if(typeof input === "number")return state;
         var buffering=of_unconsumed(unconsumed$0);
         feed_input(buffering,input);
         return [1,unconsumed(0,buffering),v];
        default:
         var msg=state[3],marks=state[2],unconsumed$1=state[1];
         if(typeof input === "number")return state;
         var buffering$0=of_unconsumed(unconsumed$1);
         feed_input(buffering$0,input);
         return [2,unconsumed(0,buffering$0),marks,msg]}}
    function state_to_option$0(param)
     {switch(param[0])
       {case 0:return 0;case 1:var v=param[2];return [0,v];default:return 0}}
    function state_to_result$0(param)
     {switch(param[0])
       {case 0:return _l_;
        case 1:var v=param[2];return [0,v];
        default:
         var msg=param[3],marks=param[2];return [1,fail_to_string(marks,msg)]}}
    function state_to_unconsumed(param)
     {if(0 === param[0])return 0;
      var unconsumed=param[1];
      return [0,unconsumed]}
    function prompt(input,pos,fail,succ)
     {var
       parser_uncommitted_bytes$0=parser_uncommitted_bytes(input),
       parser_committed_bytes=input[1];
      function continue$0(input,off,len,more)
       {if(len < parser_uncommitted_bytes$0)
         caml_call1(Stdlib[2],cst_prompt_input_shrunk);
        var
         input$0=
          [0,parser_committed_bytes,parser_committed_bytes,off,len,input];
        return len === parser_uncommitted_bytes$0
                ?more
                  ?prompt(input$0,pos,fail,succ)
                  :caml_call3(fail,input$0,pos,0)
                :caml_call3(succ,input$0,pos,more)}
      return [0,[0,bytes_for_client_to_commit(input),continue$0]]}
    var
     demand_input=
      [0,
       function(input,pos,more,fail,succ)
        {if(! more)
          return caml_call5(fail,input,pos,more,0,cst_not_enough_input$0);
         function succ$0(input,pos,more)
          {return caml_call4(succ,input,pos,more,0)}
         function fail$0(input,pos,more)
          {return caml_call5(fail,input,pos,more,0,cst_not_enough_input)}
         return prompt(input,pos,fail$0,succ$0)}];
    function ensure_suspended(n,input,pos,more,fail,succ)
     {var go=[];
      caml_update_dummy
       (go,
        [0,
         function(input,pos,more,fail,succ)
          {return (pos + n | 0) <= length(input)
                   ?caml_call4(succ,input,pos,more,0)
                   :caml_call5
                     (caml_call2(symbol$11,demand_input,go)[1],
                      input,
                      pos,
                      more,
                      fail,
                      succ)}]);
      return caml_call5
              (caml_call2(symbol$11,demand_input,go)[1],
               input,
               pos,
               more,
               fail,
               succ)}
    function unsafe_apply(len,f)
     {return [0,
              function(input,pos,more,fail,succ)
               {return caml_call4
                        (succ,input,pos + len | 0,more,apply(input,pos,len,f))}]}
    function ensure$0(n,p)
     {return [0,
              function(input,pos,more,fail,succ)
               {if((pos + n | 0) <= length(input))
                 return caml_call5(p[1],input,pos,more,fail,succ);
                function succ$0(input,pos,more,param)
                 {return caml_call5(p[1],input,pos,more,fail,succ)}
                return ensure_suspended(n,input,pos,more,fail,succ$0)}]}
    var
     at_end_of_input=
      [0,
       function(input,pos,more,param,succ)
        {if(pos < length(input))return caml_call4(succ,input,pos,more,0);
         if(! more)return caml_call4(succ,input,pos,more,1);
         function succ$0(input,pos,more)
          {return caml_call4(succ,input,pos,more,0)}
         function fail(input,pos,more)
          {return caml_call4(succ,input,pos,more,1)}
         return prompt(input,pos,fail,succ$0)}],
     end_of_input=
      caml_call2
       (symbol_bind$1,
        at_end_of_input,
        function(param)
         {return param
                  ?caml_call1(return$2,0)
                  :caml_call1(fail$1,cst_end_of_input)});
    function advance(n)
     {if(0 > n)return caml_call1(fail$1,cst_advance);
      var
       p=
        [0,
         function(input,pos,more,fail,succ)
          {return caml_call4(succ,input,pos + n | 0,more,0)}];
      return ensure$0(n,p)}
    var
     pos=
      [0,
       function(input,pos,more,fail,succ)
        {return caml_call4(succ,input,pos,more,pos)}],
     available=
      [0,
       function(input,pos,more,fail,succ)
        {return caml_call4(succ,input,pos,more,length(input) - pos | 0)}],
     commit$0=
      [0,
       function(input,pos,more,fail,succ)
        {commit(input,pos);return caml_call4(succ,input,pos,more,0)}];
    function unsafe_lookahead(p)
     {return [0,
              function(input,pos,more,fail,succ)
               {function succ$0(input,param,more,v)
                 {return caml_call4(succ,input,pos,more,v)}
                return caml_call5(p[1],input,pos,more,fail,succ$0)}]}
    var
     peek_char=
      [0,
       function(input,pos,more,fail,succ)
        {if(pos < length(input))
          return caml_call4
                  (succ,input,pos,more,[0,unsafe_get_char(input,pos)]);
         if(0 === more)return caml_call4(succ,input,pos,more,0);
         function succ$0(input,pos,more)
          {return caml_call4
                   (succ,input,pos,more,[0,unsafe_get_char(input,pos)])}
         function fail$0(input,pos,more)
          {return caml_call4(succ,input,pos,more,0)}
         return prompt(input,pos,fail$0,succ$0)}],
     peek_char_fail=[];
    caml_update_dummy
     (peek_char_fail,
      [0,
       function(input,pos,more,fail,succ)
        {if(pos < length(input))
          return caml_call4(succ,input,pos,more,unsafe_get_char(input,pos));
         function succ$0(input,pos,more,param)
          {return caml_call5(peek_char_fail[1],input,pos,more,fail,succ)}
         return ensure_suspended(1,input,pos,more,fail,succ$0)}]);
    function satisfy(f)
     {return [0,
              function(input,pos,more,fail,succ)
               {if(pos >= length(input))
                 {var
                   succ$0=
                    function(input,pos,more,param)
                     {var c=unsafe_get_char(input,pos);
                      if(caml_call1(f,c))
                       return caml_call4(succ,input,pos + 1 | 0,more,c);
                      var _$_=caml_call4(fail,input,pos,more,0);
                      return caml_call3(Stdlib_Printf[10],_$_,_n_,c)};
                  return ensure_suspended(1,input,pos,more,fail,succ$0)}
                var c=unsafe_get_char(input,pos);
                if(caml_call1(f,c))
                 return caml_call4(succ,input,pos + 1 | 0,more,c);
                var ___=caml_call4(fail,input,pos,more,0);
                return caml_call3(Stdlib_Printf[10],___,_m_,c)}]}
    function char$0(c)
     {var
       p=
        [0,
         function(input,pos,more,fail,succ)
          {return unsafe_get_char(input,pos) === c
                   ?caml_call4(succ,input,pos + 1 | 0,more,c)
                   :caml_call5
                     (fail,input,pos,more,0,caml_call2(Stdlib_Printf[4],_o_,c))}];
      return ensure$0(1,p)}
    function not_char(c)
     {var
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var c$0=unsafe_get_char(input,pos);
           return c !== c$0
                   ?caml_call4(succ,input,pos + 1 | 0,more,c$0)
                   :caml_call5
                     (fail,input,pos,more,0,caml_call2(Stdlib_Printf[4],_p_,c))}];
      return ensure$0(1,p)}
    var
     p=
      [0,
       function(input,pos,more,fail,succ)
        {return caml_call4
                 (succ,input,pos + 1 | 0,more,unsafe_get_char(input,pos))}],
     any_char=ensure$0(1,p);
    function int8(i)
     {var
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var c=unsafe_get_char(input,pos);
           return c === (i & 255)
                   ?caml_call4(succ,input,pos + 1 | 0,more,c)
                   :caml_call5
                     (fail,input,pos,more,0,caml_call2(Stdlib_Printf[4],_q_,i))}];
      return ensure$0(1,p)}
    var
     p$0=
      [0,
       function(input,pos,more,fail,succ)
        {var c=unsafe_get_char(input,pos);
         return caml_call4(succ,input,pos + 1 | 0,more,c)}],
     any_uint8=ensure$0(1,p$0),
     s=Stdlib_Sys[10] - 8 | 0,
     p$1=
      [0,
       function(input,pos,more,fail,succ)
        {var c=unsafe_get_char(input,pos);
         return caml_call4(succ,input,pos + 1 | 0,more,c << s >> s)}],
     any_int8=ensure$0(1,p$1);
    function skip(f)
     {var
       p=
        [0,
         function(input,pos,more,fail,succ)
          {return caml_call1(f,unsafe_get_char(input,pos))
                   ?caml_call4(succ,input,pos + 1 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_skip)}];
      return ensure$0(1,p)}
    function count_while$0(init,f,with_buffer)
     {return [0,
              function(input,pos,more,fail,succ)
               {var
                 len=count_while(input,pos + init | 0,f),
                 input_len=length(input),
                 init$0=init + len | 0;
                if((pos + init$0 | 0) >= input_len && 0 !== more)
                 {var
                   succ$0=
                    function(input,pos,more)
                     {return caml_call5
                              (count_while$0(init$0,f,with_buffer)[1],
                               input,
                               pos,
                               more,
                               fail,
                               succ)},
                   fail$0=
                    function(input,pos,more)
                     {return caml_call4
                              (succ,
                               input,
                               pos + init$0 | 0,
                               more,
                               apply(input,pos,init$0,with_buffer))};
                  return prompt(input,pos,fail$0,succ$0)}
                return caml_call4
                        (succ,
                         input,
                         pos + init$0 | 0,
                         more,
                         apply(input,pos,init$0,with_buffer))}]}
    function count_while1(f,with_buffer)
     {return [0,
              function(input,pos,more,fail,succ)
               {var len=count_while(input,pos,f),input_len=length(input);
                if(1 <= len)
                 {if((pos + len | 0) >= input_len && 0 !== more)
                   {var
                     succ$0=
                      function(input,pos,more)
                       {return caml_call5
                                (count_while$0(len,f,with_buffer)[1],
                                 input,
                                 pos,
                                 more,
                                 fail,
                                 succ)},
                     fail$0=
                      function(input,pos,more)
                       {return caml_call4
                                (succ,
                                 input,
                                 pos + len | 0,
                                 more,
                                 apply(input,pos,len,with_buffer))};
                    return prompt(input,pos,fail$0,succ$0)}
                  return caml_call4
                          (succ,
                           input,
                           pos + len | 0,
                           more,
                           apply(input,pos,len,with_buffer))}
                if(pos >= input_len && 0 !== more)
                 {var
                   succ$1=
                    function(input,pos,more)
                     {return caml_call5
                              (count_while1(f,with_buffer)[1],input,pos,more,fail,succ)},
                   fail$1=
                    function(input,pos,more)
                     {return caml_call5(fail,input,pos,more,0,cst_count_while1$0)};
                  return prompt(input,pos,fail$1,succ$1)}
                return caml_call5(fail,input,pos,more,0,cst_count_while1)}]}
    function string(f,s)
     {var len=caml_ml_string_length(s);
      function f$0(buffer,off,len)
       {var i=[0,0];
        for(;;)
         {if(i[1] < len)
           {var
             _Y_=caml_call1(f,runtime.caml_string_unsafe_get(s,i[1])),
             _Z_=caml_call1(f,caml_ba_get_1(buffer,off + i[1] | 0));
            if(caml_call2(Stdlib_Char[8],_Z_,_Y_)){i[1]++;continue}}
          return len === i[1]
                  ?[0,caml_call3(Bigstringaf[7],buffer,off,len)]
                  :_r_}}
      return ensure$0
              (len,
               [0,
                function(input,pos,more,fail,succ)
                 {var match=apply(input,pos,len,f$0);
                  if(0 === match[0])
                   {var x=match[1];
                    return caml_call4(succ,input,pos + len | 0,more,x)}
                  var e=match[1];
                  return caml_call5(fail,input,pos,more,0,e)}])}
    function string$0(s){return string(function(x){return x},s)}
    function string_ci(s){return string(Stdlib_Char[5],s)}
    function skip_while(f)
     {return count_while$0(0,f,function(param,_X_,_W_){return 0})}
    function take(n)
     {if(0 > n)return caml_call1(fail$1,cst_take_n_0);
      var n$0=caml_call2(Stdlib[17],n,0);
      return ensure$0(n$0,unsafe_apply(n$0,Bigstringaf[7]))}
    function take_bigstring(n)
     {if(0 > n)return caml_call1(fail$1,cst_take_bigstring_n_0);
      var n$0=caml_call2(Stdlib[17],n,0);
      return ensure$0(n$0,unsafe_apply(n$0,Bigstringaf[4]))}
    function take_bigstring_while(f){return count_while$0(0,f,Bigstringaf[4])}
    function take_bigstring_while1(f){return count_while1(f,Bigstringaf[4])}
    function take_bigstring_till(f)
     {return take_bigstring_while(function(c){return 1 - caml_call1(f,c)})}
    function peek_string(n){return unsafe_lookahead(take(n))}
    function take_while(f){return count_while$0(0,f,Bigstringaf[7])}
    function take_while1(f){return count_while1(f,Bigstringaf[7])}
    function take_till(f)
     {return take_while(function(c){return 1 - caml_call1(f,c)})}
    function choice(opt,ps)
     {if(opt)
       var sth=opt[1],failure_msg=sth;
      else
       var failure_msg=cst_no_more_choices;
      var _V_=caml_call1(fail$1,failure_msg);
      return caml_call3(Stdlib_List[26],symbol$14,ps,_V_)}
    function fix_direct(f)
     {var p=[],r=[];
      caml_update_dummy(p,[246,function(_U_){return caml_call1(f,r)}]);
      caml_update_dummy
       (r,
        [0,
         function(buf,pos,more,fail,succ)
          {var
            _S_=caml_obj_tag(p),
            _T_=
             250 === _S_?p[1]:246 === _S_?caml_call1(CamlinternalLazy[2],p):p;
           return caml_call5(_T_[1],buf,pos,more,fail,succ)}]);
      return r}
    function fix_lazy(f)
     {var steps=[0,20],p=[],r=[],max_steps=20;
      caml_update_dummy(p,[246,function(_R_){return caml_call1(f,r)}]);
      caml_update_dummy
       (r,
        [0,
         function(buf,pos,more,fail,succ)
          {steps[1] += -1;
           if(0 <= steps[1])
            {var
              _M_=caml_obj_tag(p),
              _N_=
               250 === _M_
                ?p[1]
                :246 === _M_?caml_call1(CamlinternalLazy[2],p):p;
             return caml_call5(_N_[1],buf,pos,more,fail,succ)}
           steps[1] = max_steps;
           return [1,
                   [246,
                    function(_O_)
                     {var
                       _P_=caml_obj_tag(p),
                       _Q_=
                        250 === _P_
                         ?p[1]
                         :246 === _P_?caml_call1(CamlinternalLazy[2],p):p;
                      return caml_call5(_Q_[1],buf,pos,more,fail,succ)}]]}]);
      return r}
    var
     _s_=Stdlib_Sys[5],
     fix_direct$0=typeof _s_ === "number"?_s_?fix_direct:fix_direct:fix_lazy;
    function option(x,p)
     {return caml_call2(symbol$14,p,caml_call1(return$2,x))}
    function cons(x,xs){return [0,x,xs]}
    function list(ps)
     {if(! ps)return caml_call1(return$2,0);
      var ps$0=ps[2],p=ps[1];
      return caml_call3(lift2$1,cons,p,list(ps$0))}
    function count(n,p)
     {if(0 > n)return caml_call1(fail$1,cst_count_n_0);
      function loop(n)
       {return 0 === n
                ?caml_call1(return$2,0)
                :caml_call3(lift2$1,cons,p,loop(n - 1 | 0))}
      return loop(n)}
    function many(p)
     {return fix_direct$0
              (function(m)
                {var _L_=caml_call1(return$2,0);
                 return caml_call2(symbol$14,caml_call3(lift2$1,cons,p,m),_L_)})}
    function many1(p){return caml_call3(lift2$1,cons,p,many(p))}
    function many_till(p,t)
     {return fix_direct$0
              (function(m)
                {var _K_=caml_call3(lift2$1,cons,p,m);
                 return caml_call2
                         (symbol$14,
                          caml_call2(symbol$11,t,caml_call1(return$2,0)),
                          _K_)})}
    function sep_by1(s,p)
     {return fix_direct$0
              (function(m)
                {var _J_=caml_call1(return$2,0);
                 return caml_call3
                         (lift2$1,
                          cons,
                          p,
                          caml_call2(symbol$14,caml_call2(symbol$11,s,m),_J_))})}
    function sep_by(s,p)
     {var _H_=caml_call1(return$2,0),_I_=caml_call1(return$2,0);
      return caml_call2
              (symbol$14,
               caml_call3
                (lift2$1,
                 cons,
                 p,
                 caml_call2
                  (symbol$14,caml_call2(symbol$11,s,sep_by1(s,p)),_I_)),
               _H_)}
    function skip_many(p)
     {return fix_direct$0
              (function(m)
                {var _G_=caml_call1(return$2,0);
                 return caml_call2(symbol$14,caml_call2(symbol$11,p,m),_G_)})}
    function skip_many1(p){return caml_call2(symbol$11,p,skip_many(p))}
    var
     _t_=caml_call1(return$2,0),
     _u_=caml_call2(symbol$11,string$0(cst$1),_t_),
     _v_=caml_call1(return$2,0),
     end_of_line=
      caml_call2
       (symbol$13,
        caml_call2(symbol$14,caml_call2(symbol$11,char$0(10),_v_),_u_),
        cst_end_of_line);
    function scan(state,f,with_buffer)
     {return [0,
              function(input,pos,more,fail,succ)
               {var state$0=[0,state];
                function _F_(x){return [0,x,state$0[1]]}
                var
                 parser=
                  caml_call2
                   (symbol_map$1,
                    count_while$0
                     (0,
                      function(c)
                       {var match=caml_call2(f,state$0[1],c);
                        if(! match)return 0;
                        var state=match[1];
                        state$0[1] = state;
                        return 1},
                      with_buffer),
                    _F_);
                return caml_call5(parser[1],input,pos,more,fail,succ)}]}
    function scan$0(state,f){return scan(state,f,Bigstringaf[7])}
    function scan_state(state,f)
     {function _C_(param){var state=param[2];return state}
      return caml_call2
              (symbol_map$1,
               scan(state,f,function(param,_E_,_D_){return 0}),
               _C_)}
    function scan_string(state,f)
     {function _A_(_B_){return _B_[1]}
      return caml_call2(symbol_map$1,scan$0(state,f),_A_)}
    function consume_with(p,f)
     {return [0,
              function(input,start,more,fail,succ)
               {var parser_committed_bytes=input[1];
                function succ$0(input,pos,more,param)
                 {if(parser_committed_bytes !== input[1])
                   return caml_call5
                           (fail,input,pos,more,0,cst_consumed_parser_committed);
                  var len=pos - start | 0,consumed=apply(input,start,len,f);
                  return caml_call4(succ,input,pos,more,consumed)}
                return caml_call5(p[1],input,start,more,fail,succ$0)}]}
    function consumed(p){return consume_with(p,Bigstringaf[7])}
    function consumed_bigstring(p){return consume_with(p,Bigstringaf[4])}
    function and(a,b)
     {return caml_call3(lift2$1,function(a,b){return [0,a,b]},a,b)}
    function map(t,f){return caml_call2(symbol_map$1,t,f)}
    function bind(t,f){return caml_call2(symbol_bind$1,t,f)}
    function map2(a,b,f){return caml_call3(lift2$1,f,a,b)}
    function map3(a,b,c,f){return caml_call4(lift3$1,f,a,b,c)}
    function map4(a,b,c,d,f){return caml_call5(lift4$1,f,a,b,c,d)}
    var
     Let_syntax=[0,return$2,map,bind,and,map2,map3,map4],
     Let_syntax$0=[0,return$2,symbol_map$1,symbol_bind$1,Let_syntax];
    function int16(n)
     {var
       bytes=2,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {return unsafe_get_int16_be(input,pos) === (n & 65535)
                   ?caml_call4(succ,input,pos + 2 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_BE_int16)}];
      return ensure$0(bytes,p)}
    function int32(n)
     {var
       bytes=4,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var _z_=unsafe_get_int32_be(input,pos);
           return caml_call2(Stdlib_Int32[17],_z_,n)
                   ?caml_call4(succ,input,pos + 4 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_BE_int32)}];
      return ensure$0(bytes,p)}
    function int64(n)
     {var
       bytes=8,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var _y_=unsafe_get_int64_be(input,pos);
           return caml_call2(Stdlib_Int64[17],_y_,n)
                   ?caml_call4(succ,input,pos + 8 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_BE_int64)}];
      return ensure$0(bytes,p)}
    var
     any_uint16=
      ensure$0
       (2,
        unsafe_apply
         (2,function(bs,off,param){return caml_call2(Bigstringaf[31],bs,off)})),
     any_int16=
      ensure$0
       (2,
        unsafe_apply
         (2,function(bs,off,param){return caml_call2(Bigstringaf[33],bs,off)})),
     any_int32=
      ensure$0
       (4,
        unsafe_apply
         (4,function(bs,off,param){return caml_call2(Bigstringaf[37],bs,off)})),
     any_int64=
      ensure$0
       (8,
        unsafe_apply
         (8,function(bs,off,param){return caml_call2(Bigstringaf[41],bs,off)})),
     any_float=
      ensure$0
       (4,
        unsafe_apply
         (4,
          function(bs,off,param)
           {return caml_int32_float_of_bits
                    (caml_call2(Bigstringaf[37],bs,off))})),
     any_double=
      ensure$0
       (8,
        unsafe_apply
         (8,
          function(bs,off,param)
           {return caml_int64_float_of_bits
                    (caml_call2(Bigstringaf[41],bs,off))}));
    function int16$0(n)
     {var
       bytes=2,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {return unsafe_get_int16_le(input,pos) === (n & 65535)
                   ?caml_call4(succ,input,pos + 2 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_LE_int16)}];
      return ensure$0(bytes,p)}
    function int32$0(n)
     {var
       bytes=4,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var _x_=unsafe_get_int32_le(input,pos);
           return caml_call2(Stdlib_Int32[17],_x_,n)
                   ?caml_call4(succ,input,pos + 4 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_LE_int32)}];
      return ensure$0(bytes,p)}
    function int64$0(n)
     {var
       bytes=8,
       p=
        [0,
         function(input,pos,more,fail,succ)
          {var _w_=unsafe_get_int64_le(input,pos);
           return caml_call2(Stdlib_Int64[17],_w_,n)
                   ?caml_call4(succ,input,pos + 8 | 0,more,0)
                   :caml_call5(fail,input,pos,more,0,cst_LE_int64)}];
      return ensure$0(bytes,p)}
    var
     any_uint16$0=
      ensure$0
       (2,
        unsafe_apply
         (2,function(bs,off,param){return caml_call2(Bigstringaf[30],bs,off)})),
     any_int16$0=
      ensure$0
       (2,
        unsafe_apply
         (2,function(bs,off,param){return caml_call2(Bigstringaf[32],bs,off)})),
     any_int32$0=
      ensure$0
       (4,
        unsafe_apply
         (4,function(bs,off,param){return caml_call2(Bigstringaf[36],bs,off)})),
     any_int64$0=
      ensure$0
       (8,
        unsafe_apply
         (8,function(bs,off,param){return caml_call2(Bigstringaf[40],bs,off)})),
     any_float$0=
      ensure$0
       (4,
        unsafe_apply
         (4,
          function(bs,off,param)
           {return caml_int32_float_of_bits
                    (caml_call2(Bigstringaf[36],bs,off))})),
     any_double$0=
      ensure$0
       (8,
        unsafe_apply
         (8,
          function(bs,off,param)
           {return caml_int64_float_of_bits
                    (caml_call2(Bigstringaf[40],bs,off))}));
    function take$0(n,f)
     {var n$0=caml_call2(Stdlib[17],n,0);
      return ensure$0(n$0,unsafe_apply(n$0,f))}
    function peek(n,f){return unsafe_lookahead(take$0(n,f))}
    function take_while$0(check,f){return count_while$0(0,check,f)}
    function take_while1$0(check,f){return count_while1(check,f)}
    function take_till$0(check,f)
     {return take_while$0(function(c){return 1 - caml_call1(check,c)},f)}
    var Consume=[0];
    function parse_bigstring$0(consume,p,bs)
     {var p$0=consume?caml_call2(symbol$12,p,end_of_input):p;
      return parse_bigstring(p$0,bs)}
    function parse_string(consume,p,s)
     {var len=caml_ml_string_length(s),bs=caml_call1(Bigstringaf[1],len);
      caml_call5(Bigstringaf[45],s,0,bs,0,len);
      return parse_bigstring$0(consume,p,bs)}
    var
     Angstrom$0=
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       and,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix_direct$0,
       symbol$14,
       choice,
       symbol$13,
       commit$0,
       return$2,
       fail$1,
       symbol_bind$1,
       bind,
       symbol_map$1,
       symbol$10,
       symbol$9,
       symbol$11,
       symbol$12,
       lift$0,
       lift2$1,
       lift3$1,
       lift4$1,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map$1,
       symbol_bind$1,
       and,
       [0,take$0,take_while$0,take_while1$0,take_till$0,peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0,parse,state_to_option,state_to_result],
       pos,
       available];
    caml_register_global(59,Angstrom$0,"Angstrom");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RhdGVfdG9fb3B0aW9uIiwieCIsInYiLCJmYWlsX3RvX3N0cmluZyIsIm1hcmtzIiwiZXJyIiwic3RhdGVfdG9fcmVzdWx0IiwiY3JlYXRlIiwiYnVmZmVyIiwib2ZmIiwibGVuIiwiY29tbWl0dGVkX2J5dGVzIiwibGVuZ3RoIiwidCIsImNsaWVudF9jb21taXR0ZWRfYnl0ZXMiLCJwYXJzZXJfY29tbWl0dGVkX2J5dGVzIiwiYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQiLCJwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMiLCJpbnZhcmlhbnQiLCJvZmZzZXRfaW5fYnVmZmVyIiwicG9zIiwiYXBwbHkiLCJmIiwidW5zYWZlX2dldF9jaGFyIiwidW5zYWZlX2dldF9pbnQxNl9sZSIsInVuc2FmZV9nZXRfaW50MzJfbGUiLCJ1bnNhZmVfZ2V0X2ludDY0X2xlIiwidW5zYWZlX2dldF9pbnQxNl9iZSIsInVuc2FmZV9nZXRfaW50MzJfYmUiLCJ1bnNhZmVfZ2V0X2ludDY0X2JlIiwiY291bnRfd2hpbGUiLCJpIiwibGltaXQiLCJjb21taXQiLCJmYWlsX2siLCJpbnB1dCIsIm1zZyIsInN1Y2NlZWRfayIsInRvX2V4cG9ydGVkX3N0YXRlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsImJzIiwibW9yZSIsIngkMCIsInMiLCJzbCIsImkkMCIsInBhcnNlIiwicCIsInBhcnNlX2JpZ3N0cmluZyIsImlucHV0JDAiLCJyZXR1cm4kMCIsImZhaWwiLCJzdWNjIiwic3ltYm9sX2JpbmQiLCJzdWNjJDAiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibSIsInN5bWJvbCQwIiwic3VjYzAiLCJpbnB1dDAiLCJwb3MwIiwibW9yZTAiLCJzdWNjMSIsImlucHV0MSIsInBvczEiLCJtb3JlMSIsImxpZnQiLCJsaWZ0MiIsIm0xIiwibTIiLCJzdWNjMiIsImlucHV0MiIsInBvczIiLCJtb3JlMiIsImxpZnQzIiwibTMiLCJzdWNjMyIsImlucHV0MyIsInBvczMiLCJtb3JlMyIsImxpZnQ0IiwibTQiLCJzdWNjNCIsImlucHV0NCIsInBvczQiLCJtb3JlNCIsInN5bWJvbCQxIiwiYSIsImIiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwibWFyayIsImZhaWwkMCIsInN5bWJvbCQ0IiwicSIsInBvcyQwIiwibW9yZSQwIiwicmV0dXJuJDEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsImxpZnQyJDAiLCJsaWZ0MyQwIiwibGlmdDQkMCIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJvZl9iaWdzdHJpbmciLCJidWYiLCJjcmVhdGUkMCIsIndyaXRhYmxlX3NwYWNlIiwiZW5zdXJlIiwidG9fY29weSIsIm9sZF9sZW4iLCJuZXdfbGVuIiwic3BhY2UiLCJuZXdfYnVmIiwid3JpdGVfcG9zIiwiZmVlZF9zdHJpbmciLCJzdHIiLCJmZWVkX2JpZ3N0cmluZyIsImZlZWRfaW5wdXQiLCJzaGlmdCIsIm4iLCJmb3JfcmVhZGluZyIsInVuY29uc3VtZWQiLCJvcHQiLCJzdGgiLCJvZl91bmNvbnN1bWVkIiwicmV0dXJuJDIiLCJmYWlsJDEiLCJzeW1ib2xfYmluZCQxIiwic3ltYm9sX21hcCQxIiwic3ltYm9sJDkiLCJzeW1ib2wkMTAiLCJsaWZ0JDAiLCJsaWZ0MiQxIiwibGlmdDMkMSIsImxpZnQ0JDEiLCJzeW1ib2wkMTEiLCJzeW1ib2wkMTIiLCJzeW1ib2wkMTMiLCJzeW1ib2wkMTQiLCJmcm9tX3VuYnVmZmVyZWRfc3RhdGUiLCJidWZmZXJpbmciLCJjb25zdW1lZCIsInVuY29uc3VtZWQkMCIsImNvbnN1bWVkJDAiLCJ1bmNvbnN1bWVkJDEiLCJwYXJzZSQwIiwiaW5pdGlhbF9idWZmZXJfc2l6ZSIsImZvcl9yZWFkaW5nJDAiLCJmZWVkIiwic3RhdGUiLCJrIiwiYnVmZmVyaW5nJDAiLCJzdGF0ZV90b19vcHRpb24kMCIsInN0YXRlX3RvX3Jlc3VsdCQwIiwic3RhdGVfdG9fdW5jb25zdW1lZCIsInByb21wdCIsInBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyQwIiwiZGVtYW5kX2lucHV0IiwiZW5zdXJlX3N1c3BlbmRlZCIsImdvIiwidW5zYWZlX2FwcGx5IiwiZW5zdXJlJDAiLCJhdF9lbmRfb2ZfaW5wdXQiLCJlbmRfb2ZfaW5wdXQiLCJhZHZhbmNlIiwiYXZhaWxhYmxlIiwiY29tbWl0JDAiLCJ1bnNhZmVfbG9va2FoZWFkIiwicGVla19jaGFyIiwicGVla19jaGFyX2ZhaWwiLCJzYXRpc2Z5IiwiYyIsImNoYXIkMCIsIm5vdF9jaGFyIiwiYyQwIiwiYW55X2NoYXIiLCJpbnQ4IiwicCQwIiwiYW55X3VpbnQ4IiwicCQxIiwiYW55X2ludDgiLCJza2lwIiwiY291bnRfd2hpbGUkMCIsImluaXQiLCJ3aXRoX2J1ZmZlciIsImlucHV0X2xlbiIsImluaXQkMCIsImNvdW50X3doaWxlMSIsInN1Y2MkMSIsInN0cmluZyIsImYkMCIsImUiLCJzdHJpbmckMCIsInN0cmluZ19jaSIsInNraXBfd2hpbGUiLCJ0YWtlIiwibiQwIiwidGFrZV9iaWdzdHJpbmciLCJ0YWtlX2JpZ3N0cmluZ193aGlsZSIsInRha2VfYmlnc3RyaW5nX3doaWxlMSIsInRha2VfYmlnc3RyaW5nX3RpbGwiLCJwZWVrX3N0cmluZyIsInRha2Vfd2hpbGUiLCJ0YWtlX3doaWxlMSIsInRha2VfdGlsbCIsImNob2ljZSIsInBzIiwiZmFpbHVyZV9tc2ciLCJmaXhfZGlyZWN0IiwiciIsImZpeF9sYXp5Iiwic3RlcHMiLCJtYXhfc3RlcHMiLCJmaXhfZGlyZWN0JDAiLCJvcHRpb24iLCJjb25zIiwieHMiLCJsaXN0IiwicHMkMCIsImNvdW50IiwibG9vcCIsIm1hbnkiLCJtYW55MSIsIm1hbnlfdGlsbCIsInNlcF9ieTEiLCJzZXBfYnkiLCJza2lwX21hbnkiLCJza2lwX21hbnkxIiwiZW5kX29mX2xpbmUiLCJzY2FuIiwic3RhdGUkMCIsInBhcnNlciIsInNjYW4kMCIsInNjYW5fc3RhdGUiLCJzY2FuX3N0cmluZyIsImNvbnN1bWVfd2l0aCIsInN0YXJ0IiwiY29uc3VtZWRfYmlnc3RyaW5nIiwiYW5kIiwibWFwIiwiYmluZCIsIm1hcDIiLCJtYXAzIiwibWFwNCIsImQiLCJpbnQxNiIsImJ5dGVzIiwiaW50MzIiLCJpbnQ2NCIsImFueV91aW50MTYiLCJhbnlfaW50MTYiLCJhbnlfaW50MzIiLCJhbnlfaW50NjQiLCJhbnlfZmxvYXQiLCJhbnlfZG91YmxlIiwiaW50MTYkMCIsImludDMyJDAiLCJpbnQ2NCQwIiwiYW55X3VpbnQxNiQwIiwiYW55X2ludDE2JDAiLCJhbnlfaW50MzIkMCIsImFueV9pbnQ2NCQwIiwiYW55X2Zsb2F0JDAiLCJhbnlfZG91YmxlJDAiLCJ0YWtlJDAiLCJwZWVrIiwidGFrZV93aGlsZSQwIiwiY2hlY2siLCJ0YWtlX3doaWxlMSQwIiwidGFrZV90aWxsJDAiLCJwYXJzZV9iaWdzdHJpbmckMCIsImNvbnN1bWUiLCJwYXJzZV9zdHJpbmciXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYW5nc3Ryb20vZXhwb3J0ZWRfc3RhdGUubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYW5nc3Ryb20vaW5wdXQubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYW5nc3Ryb20vcGFyc2VyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2FuZ3N0cm9tL2J1ZmZlcmluZy5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9hbmdzdHJvbS9hbmdzdHJvbS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBVUlBLGdCQUFnQkM7TUFBSSxPQUFKQTtlQUdGLGdCQUZBLElBQU5DLEVBRFFELEtBQ0YsVUFBTkMsV0FDTSxTQUNJO2FBRWxCQyxlQUFlQyxN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QW9CQUk7UUFLQUM7UUFLQUM7VUY3RkZqSCxNRjFCQS9DLGdCQVFBTTtPSW1OQWM7T0FHQXVKO0lBd2RBO1UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlICdhIHN0YXRlID1cbiAgfCBQYXJ0aWFsIG9mICdhIHBhcnRpYWxcbiAgfCBEb25lICAgIG9mIGludCAqICdhXG4gIHwgRmFpbCAgICBvZiBpbnQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG5hbmQgJ2EgcGFydGlhbCA9XG4gIHsgY29tbWl0dGVkIDogaW50XG4gIDsgY29udGludWUgIDogQmlnc3RyaW5nYWYudCAtPiBvZmY6aW50IC0+IGxlbjppbnQgLT4gTW9yZS50IC0+ICdhIHN0YXRlIH1cblxuXG5sZXQgc3RhdGVfdG9fb3B0aW9uIHggPSBtYXRjaCB4IHdpdGhcbiAgfCBEb25lKF8sIHYpIC0+IFNvbWUgdlxuICB8IEZhaWwgXyAgICAgLT4gTm9uZVxuICB8IFBhcnRpYWwgXyAgLT4gTm9uZVxuXG5sZXQgZmFpbF90b19zdHJpbmcgbWFya3MgZXJyID1cbiAgU3RyaW5nLmNvbmNhdCBcIiA+IFwiIG1hcmtzIF4gXCI6IFwiIF4gZXJyXG5cbmxldCBzdGF0ZV90b19yZXN1bHQgeCA9IG1hdGNoIHggd2l0aFxuICB8IERvbmUoXywgdikgICAgICAgICAgLT4gT2sgdlxuICB8IFBhcnRpYWwgXyAgICAgICAgICAgLT4gRXJyb3IgXCJpbmNvbXBsZXRlIGlucHV0XCJcbiAgfCBGYWlsKF8sIG1hcmtzLCBlcnIpIC0+IEVycm9yIChmYWlsX3RvX3N0cmluZyBtYXJrcyBlcnIpXG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbnR5cGUgdCA9XG4gIHsgbXV0YWJsZSBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIDogaW50XG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyAgICAgICAgIDogaW50XG4gIDsgb2ZmICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgbGVuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50XG4gIDsgYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIDogQmlnc3RyaW5nYWYudFxuICB9XG5cbmxldCBjcmVhdGUgYnVmZmVyIH5vZmYgfmxlbiB+Y29tbWl0dGVkX2J5dGVzID1cbiAgeyBwYXJzZXJfY29tbWl0dGVkX2J5dGVzID0gY29tbWl0dGVkX2J5dGVzXG4gIDsgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyA9IGNvbW1pdHRlZF9ieXRlc1xuICA7IG9mZlxuICA7IGxlblxuICA7IGJ1ZmZlciB9XG5cbmxldCBsZW5ndGggICAgICAgICAgICAgICAgIHQgPSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgKyB0LmxlblxubGV0IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgdCA9IHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xubGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCA9IHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlc1xuXG5sZXQgY29tbWl0dGVkX2J5dGVzX2Rpc2NyZXBhbmN5IHQgPSB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgLSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcbmxldCBieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCAgdCA9IGNvbW1pdHRlZF9ieXRlc19kaXNjcmVwYW5jeSB0XG5cbmxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdCA9IHQubGVuIC0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdFxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCArIHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0ID0gbGVuZ3RoIHQpO1xuICBhc3NlcnQgKHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgdCAtIGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgICB0ID0gYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgdCk7XG47O1xuXG5sZXQgb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyA9XG4gIHQub2ZmICsgcG9zIC0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5cbmxldCBhcHBseSB0IHBvcyBsZW4gfmYgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBmIHQuYnVmZmVyIH5vZmYgfmxlblxuXG5sZXQgdW5zYWZlX2dldF9jaGFyIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MTZfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQzMl9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDY0X2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IGNvdW50X3doaWxlIHQgcG9zIH5mID1cbiAgbGV0IGJ1ZmZlciA9IHQuYnVmZmVyIGluXG4gIGxldCBvZmYgICAgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIGxldCBpICAgICAgPSByZWYgb2ZmIGluXG4gIGxldCBsaW1pdCAgPSB0Lm9mZiArIHQubGVuIGluXG4gIHdoaWxlICFpIDwgbGltaXQgJiYgZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gICFpIC0gb2ZmXG47O1xuXG5sZXQgY29tbWl0IHQgcG9zID1cbiAgdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIDwtIHBvc1xuOztcbiIsIm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgUGFydGlhbCBvZiAnYSBwYXJ0aWFsXG4gICAgfCBMYXp5ICAgIG9mICdhIHQgTGF6eS50XG4gICAgfCBEb25lICAgIG9mIGludCAqICdhXG4gICAgfCBGYWlsICAgIG9mIGludCAqIHN0cmluZyBsaXN0ICogc3RyaW5nXG5cbiAgYW5kICdhIHBhcnRpYWwgPVxuICAgIHsgY29tbWl0dGVkIDogaW50XG4gICAgOyBjb250aW51ZSAgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiBNb3JlLnQgLT4gJ2EgdCB9XG5cbmVuZFxudHlwZSAnYSB3aXRoX3N0YXRlID0gSW5wdXQudCAtPiAgaW50IC0+IE1vcmUudCAtPiAnYVxuXG50eXBlICdhIGZhaWx1cmUgPSAoc3RyaW5nIGxpc3QgLT4gc3RyaW5nIC0+ICdhIFN0YXRlLnQpIHdpdGhfc3RhdGVcbnR5cGUgKCdhLCAncikgc3VjY2VzcyA9ICgnYSAtPiAnciBTdGF0ZS50KSB3aXRoX3N0YXRlXG5cbnR5cGUgJ2EgdCA9XG4gIHsgcnVuIDogJ3IuICgnciBmYWlsdXJlIC0+ICgnYSwgJ3IpIHN1Y2Nlc3MgLT4gJ3IgU3RhdGUudCkgd2l0aF9zdGF0ZSB9XG5cbmxldCBmYWlsX2sgICAgaW5wdXQgcG9zIF8gbWFya3MgbXNnID1cbiAgU3RhdGUuRmFpbChwb3MgLSBJbnB1dC5jbGllbnRfY29tbWl0dGVkX2J5dGVzIGlucHV0LCBtYXJrcywgbXNnKVxubGV0IHN1Y2NlZWRfayBpbnB1dCBwb3MgXyAgICAgICB2ICAgPVxuICBTdGF0ZS5Eb25lKHBvcyAtIElucHV0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgaW5wdXQsIHYpXG5cbmxldCByZWMgdG9fZXhwb3J0ZWRfc3RhdGUgPSBmdW5jdGlvblxuICB8IFN0YXRlLlBhcnRpYWwge2NvbW1pdHRlZDtjb250aW51ZX0gLT5cbiAgICAgRXhwb3J0ZWRfc3RhdGUuUGFydGlhbFxuICAgICAgIHsgY29tbWl0dGVkXG4gICAgICAgOyBjb250aW51ZSA9XG4gICAgICAgICAgIGZ1biBicyB+b2ZmIH5sZW4gbW9yZSAtPlxuICAgICAgICAgICB0b19leHBvcnRlZF9zdGF0ZSAoY29udGludWUgYnMgfm9mZiB+bGVuIG1vcmUpfVxuICB8IFN0YXRlLkRvbmUgKGkseCkgLT4gRXhwb3J0ZWRfc3RhdGUuRG9uZSAoaSx4KVxuICB8IFN0YXRlLkZhaWwgKGksIHNsLCBzKSAtPiBFeHBvcnRlZF9zdGF0ZS5GYWlsIChpLCBzbCwgcylcbiAgfCBTdGF0ZS5MYXp5IHggLT4gdG9fZXhwb3J0ZWRfc3RhdGUgKExhenkuZm9yY2UgeClcblxubGV0IHBhcnNlIHAgPVxuICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgQmlnc3RyaW5nYWYuZW1wdHkgfmNvbW1pdHRlZF9ieXRlczowIH5vZmY6MCB+bGVuOjAgaW5cbiAgdG9fZXhwb3J0ZWRfc3RhdGUgKHAucnVuIGlucHV0IDAgSW5jb21wbGV0ZSBmYWlsX2sgc3VjY2VlZF9rKVxuXG5sZXQgcGFyc2VfYmlnc3RyaW5nIHAgaW5wdXQgPVxuICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgaW5wdXQgfmNvbW1pdHRlZF9ieXRlczowIH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggaW5wdXQpIGluXG4gIEV4cG9ydGVkX3N0YXRlLnN0YXRlX3RvX3Jlc3VsdCAodG9fZXhwb3J0ZWRfc3RhdGUgKHAucnVuIGlucHV0IDAgQ29tcGxldGUgZmFpbF9rIHN1Y2NlZWRfaykpXG5cbm1vZHVsZSBNb25hZCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuIHYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgdlxuICAgIH1cblxuICBsZXQgZmFpbCBtc2cgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgX3N1Y2MgLT5cbiAgICAgIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gbXNnXG4gICAgfVxuXG4gIGxldCAoPj49KSBwIGYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIHYgPSAoZiB2KS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gICAgfVxuXG4gIGxldCAoPj58KSBwIGYgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIHYgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIChmIHYpIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gICAgfVxuXG4gIGxldCAoPCQ+KSBmIG0gPVxuICAgIG0gPj58IGZcblxuICBsZXQgKDwqPikgZiBtID1cbiAgICAoKiBmID4+PSBmdW4gZiAtPiBtID4+fCBmICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzAgaW5wdXQwIHBvczAgbW9yZTAgZiA9XG4gICAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtID0gc3VjYyBpbnB1dDEgcG9zMSBtb3JlMSAoZiBtKSBpblxuICAgICAgICBtLnJ1biBpbnB1dDAgcG9zMCBtb3JlMCBmYWlsIHN1Y2MxXG4gICAgICBpblxuICAgICAgZi5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMCB9XG5cbiAgbGV0IGxpZnQgZiBtID1cbiAgICBmIDwkPiBtXG5cbiAgbGV0IGxpZnQyIGYgbTEgbTIgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID0gc3VjYyBpbnB1dDIgcG9zMiBtb3JlMiAoZiBtMSBtMikgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0IGxpZnQzIGYgbTEgbTIgbTMgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID1cbiAgICAgICAgICBsZXQgc3VjYzMgaW5wdXQzIHBvczMgbW9yZTMgbTMgPVxuICAgICAgICAgICAgc3VjYyBpbnB1dDMgcG9zMyBtb3JlMyAoZiBtMSBtMiBtMykgaW5cbiAgICAgICAgICBtMy5ydW4gaW5wdXQyIHBvczIgbW9yZTIgZmFpbCBzdWNjMyBpblxuICAgICAgICBtMi5ydW4gaW5wdXQxIHBvczEgbW9yZTEgZmFpbCBzdWNjMlxuICAgICAgaW5cbiAgICAgIG0xLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MxIH1cblxuICBsZXQgbGlmdDQgZiBtMSBtMiBtMyBtNCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbTEgPVxuICAgICAgICBsZXQgc3VjYzIgaW5wdXQyIHBvczIgbW9yZTIgbTIgPVxuICAgICAgICAgIGxldCBzdWNjMyBpbnB1dDMgcG9zMyBtb3JlMyBtMyA9XG4gICAgICAgICAgICBsZXQgc3VjYzQgaW5wdXQ0IHBvczQgbW9yZTQgbTQgPVxuICAgICAgICAgICAgICBzdWNjIGlucHV0NCBwb3M0IG1vcmU0IChmIG0xIG0yIG0zIG00KSBpblxuICAgICAgICAgICAgbTQucnVuIGlucHV0MyBwb3MzIG1vcmUzIGZhaWwgc3VjYzQgaW5cbiAgICAgICAgICBtMy5ydW4gaW5wdXQyIHBvczIgbW9yZTIgZmFpbCBzdWNjMyBpblxuICAgICAgICBtMi5ydW4gaW5wdXQxIHBvczEgbW9yZTEgZmFpbCBzdWNjMlxuICAgICAgaW5cbiAgICAgIG0xLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MxIH1cblxuICBsZXQgKCAqPikgYSBiID1cbiAgICAoKiBhID4+PSBmdW4gXyAtPiBiICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgXyA9IGIucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgYS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKDwqICkgYSBiID1cbiAgICAoKiBhID4+PSBmdW4geCAtPiBiID4+fCBmdW4gXyAtPiB4ICopXG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzAgaW5wdXQwIHBvczAgbW9yZTAgeCA9XG4gICAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBfID0gc3VjYyBpbnB1dDEgcG9zMSBtb3JlMSB4IGluXG4gICAgICAgIGIucnVuIGlucHV0MCBwb3MwIG1vcmUwIGZhaWwgc3VjYzFcbiAgICAgIGluXG4gICAgICBhLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MwIH1cbmVuZFxuXG5tb2R1bGUgQ2hvaWNlID0gc3RydWN0XG4gIGxldCAoPD8+KSBwIG1hcmsgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnIG1hcmtzIG1zZyA9XG4gICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgKG1hcms6Om1hcmtzKSBtc2cgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwnIHN1Y2NcbiAgICB9XG5cbiAgbGV0ICg8fD4pIHAgcSA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgbWFya3MgbXNnID1cbiAgICAgICAgKCogVGhlIG9ubHkgdHdvIGNvbnN0cnVjdG9ycyB0aGF0IGludHJvZHVjZSBuZXcgZmFpbHVyZSBjb250aW51YXRpb25zIGFyZVxuICAgICAgICAgKiBbPD8+XSBhbmQgWzx8Pl0uIElmIHRoZSBpbml0aWFsIGlucHV0IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gICAgICAgICAqIG9mIHRoZSBjb21taXR0ZWQgaW5wdXQsIHRoZW4gY2FsbGluZyB0aGUgZmFpbHVyZSBjb250aW51YXRpb24gd2lsbFxuICAgICAgICAgKiBoYXZlIHRoZSBlZmZlY3Qgb2YgdW53aW5kaW5nIGFsbCBjaG9pY2VzIGFuZCBjb2xsZWN0aW5nIG1hcmtzIGFsb25nXG4gICAgICAgICAqIHRoZSB3YXkuICopXG4gICAgICAgIGlmIHBvcyA8IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQnIHRoZW5cbiAgICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUgbWFya3MgbXNnXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBxLnJ1biBpbnB1dCcgcG9zIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCcgc3VjY1xuICAgIH1cbmVuZFxuXG5tb2R1bGUgTW9uYWRfdXNlX2Zvcl9kZWJ1Z2dpbmcgPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IE1vbmFkLnJldHVyblxuICBsZXQgZmFpbCAgID0gTW9uYWQuZmFpbFxuICBsZXQgKD4+PSkgID0gTW9uYWQuKD4+PSlcblxuICBsZXQgKD4+fCkgbSBmID0gbSA+Pj0gZnVuIHggLT4gcmV0dXJuIChmIHgpXG5cbiAgbGV0ICg8JD4pIGYgbSA9IG0gPj58IGZcbiAgbGV0ICg8Kj4pIGYgbSA9IGYgPj49IGZ1biBmIC0+IG0gPj58IGZcblxuICBsZXQgbGlmdCAgPSAoPj58KVxuICBsZXQgbGlmdDIgZiBtMSBtMiAgICAgICA9IGYgPCQ+IG0xIDwqPiBtMlxuICBsZXQgbGlmdDMgZiBtMSBtMiBtMyAgICA9IGYgPCQ+IG0xIDwqPiBtMiA8Kj4gbTNcbiAgbGV0IGxpZnQ0IGYgbTEgbTIgbTMgbTQgPSBmIDwkPiBtMSA8Kj4gbTIgPCo+IG0zIDwqPiBtNFxuXG4gIGxldCAoICo+KSBhIGIgPSBhID4+PSBmdW4gXyAtPiBiXG4gIGxldCAoPCogKSBhIGIgPSBhID4+PSBmdW4geCAtPiBiID4+fCBmdW4gXyAtPiB4XG5lbmRcbiIsInR5cGUgdCA9XG4gIHsgbXV0YWJsZSBidWYgOiBCaWdzdHJpbmdhZi50XG4gIDsgbXV0YWJsZSBvZmYgOiBpbnRcbiAgOyBtdXRhYmxlIGxlbiA6IGludCB9XG5cbmxldCBvZl9iaWdzdHJpbmcgfm9mZiB+bGVuIGJ1ZiA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBidWYgPj0gbGVuIC0gb2ZmKTtcbiAgeyBidWY7IG9mZjsgbGVuIH1cblxubGV0IGNyZWF0ZSBsZW4gPVxuICBvZl9iaWdzdHJpbmcgfm9mZjowIH5sZW46MCAoQmlnc3RyaW5nYWYuY3JlYXRlIGxlbilcblxubGV0IHdyaXRhYmxlX3NwYWNlIHQgPVxuICBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgLSB0LmxlblxuXG5sZXQgdHJhaWxpbmdfc3BhY2UgdCA9XG4gIEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiAtICh0Lm9mZiArIHQubGVuKVxuXG5sZXQgY29tcHJlc3MgdCA9XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IHQuYnVmIH5zcmNfb2ZmOnQub2ZmIHQuYnVmIH5kc3Rfb2ZmOjAgfmxlbjp0LmxlbjtcbiAgdC5vZmYgPC0gMFxuXG5sZXQgZ3JvdyB0IHRvX2NvcHkgPVxuICBsZXQgb2xkX2xlbiA9IEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIGxldCBzcGFjZSA9IHdyaXRhYmxlX3NwYWNlIHQgaW5cbiAgd2hpbGUgc3BhY2UgKyAhbmV3X2xlbiAtIG9sZF9sZW4gPCB0b19jb3B5IGRvXG4gICAgbmV3X2xlbiA6PSAoMyAqICFuZXdfbGVuKSAvIDJcbiAgZG9uZTtcbiAgbGV0IG5ld19idWYgPSBCaWdzdHJpbmdhZi5jcmVhdGUgIW5ld19sZW4gaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgdC5idWYgfnNyY19vZmY6dC5vZmYgbmV3X2J1ZiB+ZHN0X29mZjowIH5sZW46dC5sZW47XG4gIHQuYnVmIDwtIG5ld19idWY7XG4gIHQub2ZmIDwtIDBcblxubGV0IGVuc3VyZSB0IHRvX2NvcHkgPVxuICBpZiB0cmFpbGluZ19zcGFjZSB0IDwgdG9fY29weSB0aGVuXG4gICAgaWYgd3JpdGFibGVfc3BhY2UgdCA+PSB0b19jb3B5XG4gICAgdGhlbiBjb21wcmVzcyB0XG4gICAgZWxzZSBncm93IHQgdG9fY29weVxuXG5sZXQgd3JpdGVfcG9zIHQgPVxuICB0Lm9mZiArIHQubGVuXG5cbmxldCBmZWVkX3N0cmluZyB0IH5vZmYgfmxlbiBzdHIgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChTdHJpbmcubGVuZ3RoIHN0ciA+PSBsZW4gLSBvZmYpO1xuICBlbnN1cmUgdCBsZW47XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIHN0ciB+c3JjX29mZjpvZmYgdC5idWYgfmRzdF9vZmY6KHdyaXRlX3BvcyB0KSB+bGVuO1xuICB0LmxlbiA8LSB0LmxlbiArIGxlblxuXG5sZXQgZmVlZF9iaWdzdHJpbmcgdCB+b2ZmIH5sZW4gYiA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKEJpZ3N0cmluZ2FmLmxlbmd0aCBiID49IGxlbiAtIG9mZik7XG4gIGVuc3VyZSB0IGxlbjtcbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgYiB+c3JjX29mZjpvZmYgdC5idWYgfmRzdF9vZmY6KHdyaXRlX3BvcyB0KSB+bGVuO1xuICB0LmxlbiA8LSB0LmxlbiArIGxlblxuXG5sZXQgZmVlZF9pbnB1dCB0ID0gZnVuY3Rpb25cbiAgfCBgU3RyaW5nICAgIHMgLT4gZmVlZF9zdHJpbmcgICAgdCB+b2ZmOjAgfmxlbjooU3RyaW5nICAgICAubGVuZ3RoIHMpIHNcbiAgfCBgQmlnc3RyaW5nIGIgLT4gZmVlZF9iaWdzdHJpbmcgdCB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGIpIGJcblxubGV0IHNoaWZ0IHQgbiA9XG4gIGFzc2VydCAodC5sZW4gPj0gbik7XG4gIHQub2ZmIDwtIHQub2ZmICsgbjtcbiAgdC5sZW4gPC0gdC5sZW4gLSBuXG5cbmxldCBmb3JfcmVhZGluZyB7IGJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIEJpZ3N0cmluZ2FmLnN1YiB+b2ZmIH5sZW4gYnVmXG5cbm1vZHVsZSBVbmNvbnN1bWVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBidWYgOiBCaWdzdHJpbmdhZi50XG4gICAgOyBvZmYgOiBpbnRcbiAgICA7IGxlbiA6IGludCB9XG5lbmRcblxubGV0IHVuY29uc3VtZWQgPyhzaGlmdD0wKSB7IGJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIGFzc2VydCAobGVuID49IHNoaWZ0KTtcbiAgeyBVbmNvbnN1bWVkLmJ1Zjsgb2ZmID0gb2ZmICsgc2hpZnQ7IGxlbiA9IGxlbiAtIHNoaWZ0IH1cblxubGV0IG9mX3VuY29uc3VtZWQgeyBVbmNvbnN1bWVkLmJ1Zjsgb2ZmOyBsZW4gfSA9XG4gIHsgYnVmOyBvZmY7IGxlbiB9XG5cbnR5cGUgdW5jb25zdW1lZCA9IFVuY29uc3VtZWQudCA9XG4gIHsgYnVmIDogQmlnc3RyaW5nYWYudFxuICA7IG9mZiA6IGludFxuICA7IGxlbiA6IGludCB9XG4iLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTYgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBCaWdhcnJheSA9IHN0cnVjdFxuICAoKiBEbyBub3QgYWNjZXNzIEJpZ2FycmF5IG9wZXJhdGlvbnMgZGlyZWN0bHkuIElmIGFueXRoaW5nJ3MgbmVlZGVkLCByZWZlciB0b1xuICAgKiB0aGUgaW50ZXJuYWwgQmlnc3RyaW5nIG1vZHVsZS4gKilcbmVuZFxuXG50eXBlIGJpZ3N0cmluZyA9IEJpZ3N0cmluZ2FmLnRcblxuXG5tb2R1bGUgVW5idWZmZXJlZCA9IHN0cnVjdFxuICBpbmNsdWRlIFBhcnNlclxuXG4gIGluY2x1ZGUgRXhwb3J0ZWRfc3RhdGVcblxuICB0eXBlIG1vcmUgPSBNb3JlLnQgPVxuICAgIHwgQ29tcGxldGVcbiAgICB8IEluY29tcGxldGVcbmVuZFxuXG5pbmNsdWRlIFVuYnVmZmVyZWRcbmluY2x1ZGUgUGFyc2VyLk1vbmFkXG5pbmNsdWRlIFBhcnNlci5DaG9pY2VcblxubW9kdWxlIEJ1ZmZlcmVkID0gc3RydWN0XG4gIHR5cGUgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkID1cbiAgICB7IGJ1ZiA6IGJpZ3N0cmluZ1xuICAgIDsgb2ZmIDogaW50XG4gICAgOyBsZW4gOiBpbnQgfVxuXG4gIHR5cGUgaW5wdXQgPVxuICAgIFsgYEJpZ3N0cmluZyBvZiBiaWdzdHJpbmdcbiAgICB8IGBTdHJpbmcgICAgb2Ygc3RyaW5nIF1cblxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFBhcnRpYWwgb2YgKFsgaW5wdXQgfCBgRW9mIF0gLT4gJ2Egc3RhdGUpXG4gICAgfCBEb25lICAgIG9mIHVuY29uc3VtZWQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiB1bmNvbnN1bWVkICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuICBsZXQgZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIH5mIGJ1ZmZlcmluZyA9IGZ1bmN0aW9uXG4gICAgfCBVbmJ1ZmZlcmVkLlBhcnRpYWwgcCAgICAgICAgIC0+IFBhcnRpYWwgKGYgcClcbiAgICB8IFVuYnVmZmVyZWQuRG9uZShjb25zdW1lZCwgdikgLT5cbiAgICAgIGxldCB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgfnNoaWZ0OmNvbnN1bWVkIGJ1ZmZlcmluZyBpblxuICAgICAgRG9uZSh1bmNvbnN1bWVkLCB2KVxuICAgIHwgVW5idWZmZXJlZC5GYWlsKGNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgbGV0IHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCB+c2hpZnQ6Y29uc3VtZWQgYnVmZmVyaW5nIGluXG4gICAgICBGYWlsKHVuY29uc3VtZWQsIG1hcmtzLCBtc2cpXG5cbiAgbGV0IHBhcnNlID8oaW5pdGlhbF9idWZmZXJfc2l6ZT0weDEwMDApIHAgPVxuICAgIGlmIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxIHRoZW5cbiAgICAgIGZhaWx3aXRoIFwicGFyc2U6IGludmFsaWQgYXJndW1lbnQsIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxXCI7XG4gICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5jcmVhdGUgaW5pdGlhbF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCByZWMgZiBwIGlucHV0ID1cbiAgICAgIEJ1ZmZlcmluZy5zaGlmdCBidWZmZXJpbmcgcC5jb21taXR0ZWQ7XG4gICAgICBsZXQgbW9yZSA6IE1vcmUudCA9XG4gICAgICAgIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgICAgfCBgRW9mICAgICAgICAgICAgLT4gQ29tcGxldGVcbiAgICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgICAgSW5jb21wbGV0ZVxuICAgICAgaW5cbiAgICAgIGxldCBmb3JfcmVhZGluZyA9IEJ1ZmZlcmluZy5mb3JfcmVhZGluZyBidWZmZXJpbmcgaW5cbiAgICAgIHAuY29udGludWUgZm9yX3JlYWRpbmcgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBmb3JfcmVhZGluZykgbW9yZVxuICAgICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuICAgIGluXG4gICAgVW5idWZmZXJlZC5wYXJzZSBwXG4gICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuXG4gIGxldCBmZWVkIHN0YXRlIGlucHV0ID1cbiAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgfCBQYXJ0aWFsIGsgLT4gayBpbnB1dFxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgfCBgRW9mICAgLT4gc3RhdGVcbiAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcub2ZfdW5jb25zdW1lZCB1bmNvbnN1bWVkIGluXG4gICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgRmFpbChCdWZmZXJpbmcudW5jb25zdW1lZCBidWZmZXJpbmcsIG1hcmtzLCBtc2cpXG4gICAgICBlbmRcbiAgICB8IERvbmUodW5jb25zdW1lZCwgdikgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgIHwgYEVvZiAgIC0+IHN0YXRlXG4gICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLm9mX3VuY29uc3VtZWQgdW5jb25zdW1lZCBpblxuICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgIERvbmUoQnVmZmVyaW5nLnVuY29uc3VtZWQgYnVmZmVyaW5nLCB2KVxuICAgICAgZW5kXG5cbiAgbGV0IHN0YXRlX3RvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgfCBEb25lKF8sIHYpIC0+IFNvbWUgdlxuICAgIHwgUGFydGlhbCBfICAtPiBOb25lXG4gICAgfCBGYWlsIF8gICAgIC0+IE5vbmVcblxuICBsZXQgc3RhdGVfdG9fcmVzdWx0ID0gZnVuY3Rpb25cbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgLT4gRXJyb3IgXCJpbmNvbXBsZXRlIGlucHV0XCJcbiAgICB8IERvbmUoXywgdikgICAgICAgICAgLT4gT2sgdlxuICAgIHwgRmFpbChfLCBtYXJrcywgbXNnKSAtPiBFcnJvciAoVW5idWZmZXJlZC5mYWlsX3RvX3N0cmluZyBtYXJrcyBtc2cpXG5cbiAgbGV0IHN0YXRlX3RvX3VuY29uc3VtZWQgPSBmdW5jdGlvblxuICAgIHwgRG9uZSh1bmNvbnN1bWVkLCBfKVxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBfLCBfKSAtPiBTb21lIHVuY29uc3VtZWRcbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgICAgLT4gTm9uZVxuXG5lbmRcblxuKCoqIEJFR0lOOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCByZWMgcHJvbXB0IGlucHV0IHBvcyBmYWlsIHN1Y2MgPVxuICAoKiBbcHJvbXB0XSBzaG91bGQgb25seSBjYWxsIFtzdWNjXSBpZiBpdCBoYXMgcmVjZWl2ZWQgbW9yZSBpbnB1dC4gSWYgdGhlcmVcbiAgICogaXMgbm8gY2hhbmNlIHRoYXQgdGhlIGlucHV0IHdpbGwgZ3JvdywgaS5lLiwgW21vcmUgPSBDb21wbGV0ZV0sIHRoZW5cbiAgICogW3Byb21wdF0gc2hvdWxkIGNhbGwgW2ZhaWxdLiBPdGhlcndpc2UgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBpbnB1dFxuICAgKiBoYXNuJ3QgZ3Jvd24gYnV0IFttb3JlID0gSW5jb21wbGV0ZV0ganVzdCBwcm9tcHQgYWdhaW4uICopXG4gIGxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgPSBJbnB1dC5wYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgaW5wdXQgaW5cbiAgbGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICA9IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICBpbnB1dCBpblxuICAoKiBUaGUgY29udGludWF0aW9uIHNob3VsZCBub3QgaG9sZCBhbnkgcmVmZXJlbmNlcyB0byBpbnB1dCBhYm92ZS4gKilcbiAgbGV0IGNvbnRpbnVlIGlucHV0IH5vZmYgfmxlbiBtb3JlID1cbiAgICBpZiBsZW4gPCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdGhlblxuICAgICAgZmFpbHdpdGggXCJwcm9tcHQ6IGlucHV0IHNocnVuayFcIjtcbiAgICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgaW5wdXQgfm9mZiB+bGVuIH5jb21taXR0ZWRfYnl0ZXM6cGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpblxuICAgIGlmIGxlbiA9IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0aGVuXG4gICAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgICAgfCBDb21wbGV0ZSAgIC0+IGZhaWwgaW5wdXQgcG9zIE1vcmUuQ29tcGxldGVcbiAgICAgIHwgSW5jb21wbGV0ZSAtPiBwcm9tcHQgaW5wdXQgcG9zIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmVcbiAgaW5cbiAgU3RhdGUuUGFydGlhbCB7IGNvbW1pdHRlZCA9IElucHV0LmJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IGlucHV0OyBjb250aW51ZSB9XG5cbmxldCBkZW1hbmRfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgIHwgQ29tcGxldGUgICAtPiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwibm90IGVub3VnaCBpbnB1dFwiXG4gICAgfCBJbmNvbXBsZXRlIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPSBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwibm90IGVub3VnaCBpbnB1dFwiIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IGVuc3VyZV9zdXNwZW5kZWQgbiBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgPVxuICBsZXQgcmVjIGdvID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJyAtPlxuICAgICAgaWYgcG9zJyArIG4gPD0gSW5wdXQubGVuZ3RoIGlucHV0JyB0aGVuXG4gICAgICAgIHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBlbHNlXG4gICAgICAgIChkZW1hbmRfaW5wdXQgKj4gZ28pLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJ1xuICAgIH1cbiAgaW5cbiAgKGRlbWFuZF9pbnB1dCAqPiBnbykucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuXG5sZXQgdW5zYWZlX2FwcGx5IGxlbiB+ZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmYpXG4gIH1cblxubGV0IHVuc2FmZV9hcHBseV9vcHQgbGVuIH5mID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbWF0Y2ggSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+ZiB3aXRoXG4gICAgfCBFcnJvciBlIC0+IGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gZVxuICAgIHwgT2sgICAgeCAtPiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgeFxuICB9XG5cbmxldCBlbnN1cmUgbiBwID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zICsgbiA8PSBJbnB1dC5sZW5ndGggaW5wdXRcbiAgICB0aGVuIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9IHAucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCBuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG4oKiogRU5EOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCBhdF9lbmRfb2ZfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBmYWxzZVxuICAgIGVsc2UgbWF0Y2ggbW9yZSB3aXRoXG4gICAgfCBDb21wbGV0ZSAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHRydWVcbiAgICB8IEluY29tcGxldGUgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgZmFsc2VcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgdHJ1ZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBlbmRfb2ZfaW5wdXQgPVxuICBhdF9lbmRfb2ZfaW5wdXRcbiAgPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlICAtPiByZXR1cm4gKClcbiAgICB8IGZhbHNlIC0+IGZhaWwgXCJlbmRfb2ZfaW5wdXRcIlxuXG5sZXQgYWR2YW5jZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwiYWR2YW5jZVwiXG4gIGVsc2VcbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+IHN1Y2MgaW5wdXQgKHBvcyArIG4pIG1vcmUgKCkgfVxuICAgIGluXG4gICAgZW5zdXJlIG4gcFxuXG5sZXQgcG9zID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHBvcyB9XG5cbmxldCBhdmFpbGFibGUgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQubGVuZ3RoIGlucHV0IC0gcG9zKVxuICB9XG5cbmxldCBjb21taXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgSW5wdXQuY29tbWl0IGlucHV0IHBvcztcbiAgICBzdWNjIGlucHV0IHBvcyBtb3JlICgpIH1cblxuKCogRG8gbm90IHVzZSB0aGlzIGlmIFtwXSBjb250YWlucyBhIFtjb21taXRdLiAqKVxubGV0IHVuc2FmZV9sb29rYWhlYWQgcCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdWNjJyBpbnB1dCcgXyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zIG1vcmUnIHYgaW5cbiAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IHBlZWtfY2hhciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykpXG4gICAgZWxzZSBpZiBtb3JlID0gQ29tcGxldGUgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0JyBwb3MnKSlcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgTm9uZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbigqIFRoaXMgcGFyc2VyIGlzIHRvbyBpbXBvcnRhbnQgdG8gbm90IGJlIG9wdGltaXplZC4gRG8gYSBjdXN0b20gam9iLiAqKVxubGV0IHJlYyBwZWVrX2NoYXJfZmFpbCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dFxuICAgIHRoZW4gc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBwZWVrX2NoYXJfZmFpbC5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIDEgaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBzYXRpc2Z5IGYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIFByaW50Zi5rc3ByaW50ZiAoZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSkgXCJzYXRpc2Z5OiAlQ1wiIGNcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCcgcG9zJyBpblxuICAgICAgICBpZiBmIGNcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0JyAocG9zJyArIDEpIG1vcmUnIGNcbiAgICAgICAgZWxzZSBQcmludGYua3NwcmludGYgKGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10pIFwic2F0aXNmeTogJUNcIiBjXG4gICAgICBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCAxIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgY2hhciBjID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyA9IGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwiY2hhciAlQ1wiIGMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgbm90X2NoYXIgYyA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjJyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIGlmIGMgPD4gYydcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjJ1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcIm5vdCBjaGFyICVDXCIgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfY2hhciA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSAgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBpbnQ4IGkgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IENoYXIuY29kZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykgaW5cbiAgICAgIGlmIGMgPSBpIGxhbmQgMHhmZlxuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJpbnQ4ICVkXCIgaSkgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfdWludDggPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChDaGFyLmNvZGUgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfaW50OCA9XG4gICgqIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWwjVmFyaWFibGVTaWduRXh0ZW5kUmlza3kgKilcbiAgbGV0IHMgPSBTeXMuaW50X3NpemUgLSA4IGluXG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKChDaGFyLmNvZGUgYyBsc2wgcykgYXNyIHMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgc2tpcCBmID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgZiAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoKVxuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwic2tpcFwiIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgcmVjIGNvdW50X3doaWxlIH5pbml0IH5mIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBsZW4gICAgICAgICA9IElucHV0LmNvdW50X3doaWxlIGlucHV0IChwb3MgKyBpbml0KSB+ZiBpblxuICAgIGxldCBpbnB1dF9sZW4gICA9IElucHV0Lmxlbmd0aCBpbnB1dCBpblxuICAgIGxldCBpbml0JyAgICAgICA9IGluaXQgKyBsZW4gaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBwb3MgKyBpbml0JyA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGluaXQnKSBtb3JlIChJbnB1dC5hcHBseSBpbnB1dCBwb3MgaW5pdCcgfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmluaXQnIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgKHBvcycgKyBpbml0JykgbW9yZScgKElucHV0LmFwcGx5IGlucHV0JyBwb3MnIGluaXQnIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgcmVjIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgbGVuICAgICAgICAgPSBJbnB1dC5jb3VudF93aGlsZSBpbnB1dCBwb3MgfmYgaW5cbiAgICBsZXQgaW5wdXRfbGVuICAgPSBJbnB1dC5sZW5ndGggaW5wdXQgaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBsZW4gPCAxXG4gICAgdGhlblxuICAgICAgaWYgcG9zIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgICAgdGhlbiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiY291bnRfd2hpbGUxXCJcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgICAoY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJjb3VudF93aGlsZTFcIlxuICAgICAgICBpblxuICAgICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gICAgZWxzZSBpZiBwb3MgKyBsZW4gPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmxlbiB+ZiB+d2l0aF9idWZmZXIpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2NcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIChwb3MnICsgbGVuKSBtb3JlJyAoSW5wdXQuYXBwbHkgaW5wdXQnIHBvcycgbGVuIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgc3RyaW5nXyBmIHMgPVxuICAoKiBYWFgoc2VsaW9wb3UpOiBJbmVmZmljaWVudC4gQ291bGQgY2hlY2sgcHJlZml4IGVxdWFsaXR5IHRvIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIGlvLiAqKVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVuc3VyZSAgbGVuICh1bnNhZmVfYXBwbHlfb3B0IGxlbiB+ZjooZnVuIGJ1ZmZlciB+b2ZmIH5sZW4gLT5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgd2hpbGUgIWkgPCBsZW4gJiYgQ2hhci5lcXVhbCAoZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgKG9mZiArICFpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZiAoU3RyaW5nLnVuc2FmZV9nZXQgcyAhaSkpXG4gICAgZG9cbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgbGVuID0gIWlcbiAgICB0aGVuIE9rIChCaWdzdHJpbmdhZi5zdWJzdHJpbmcgYnVmZmVyIH5vZmYgfmxlbilcbiAgICBlbHNlIEVycm9yIFwic3RyaW5nXCIpKVxuXG5sZXQgc3RyaW5nIHMgICAgPSBzdHJpbmdfIChmdW4geCAtPiB4KSBzXG5sZXQgc3RyaW5nX2NpIHMgPSBzdHJpbmdfIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IHNraXBfd2hpbGUgZiA9XG4gIGNvdW50X3doaWxlIH5pbml0OjAgfmYgfndpdGhfYnVmZmVyOihmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuXG5sZXQgdGFrZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwidGFrZTogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLnN1YnN0cmluZylcblxubGV0IHRha2VfYmlnc3RyaW5nIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJ0YWtlX2JpZ3N0cmluZzogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLmNvcHkpXG5cbmxldCB0YWtlX2JpZ3N0cmluZ193aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuY29weVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfd2hpbGUxIGYgPVxuICBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IHRha2VfYmlnc3RyaW5nX3RpbGwgZiA9XG4gIHRha2VfYmlnc3RyaW5nX3doaWxlIChmdW4gYyAtPiBub3QgKGYgYykpXG5cbmxldCBwZWVrX3N0cmluZyBuID1cbiAgdW5zYWZlX2xvb2thaGVhZCAodGFrZSBuKVxuXG5sZXQgdGFrZV93aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCB0YWtlX3doaWxlMSBmID1cbiAgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHRha2VfdGlsbCBmID1cbiAgdGFrZV93aGlsZSAoZnVuIGMgLT4gbm90IChmIGMpKVxuXG5sZXQgY2hvaWNlID8oZmFpbHVyZV9tc2c9XCJubyBtb3JlIGNob2ljZXNcIikgcHMgPVxuICBMaXN0LmZvbGRfcmlnaHQgKDx8PikgcHMgKGZhaWwgZmFpbHVyZV9tc2cpXG5cbmxldCBmaXhfZGlyZWN0IGYgPVxuICBsZXQgcmVjIHAgPSBsYXp5IChmIHIpXG4gIGFuZCByID0geyBydW4gPSBmdW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIH1cbiAgaW5cbiAgclxuXG5sZXQgZml4X2xhenkgZiA9XG4gIGxldCBtYXhfc3RlcHMgPSAyMCBpblxuICBsZXQgc3RlcHMgPSByZWYgbWF4X3N0ZXBzIGluXG4gIGxldCByZWMgcCA9IGxhenkgKGYgcilcbiAgYW5kIHIgPSB7IHJ1biA9IGZ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgZGVjciBzdGVwcztcbiAgICBpZiAhc3RlcHMgPCAwXG4gICAgdGhlbiAoXG4gICAgICBzdGVwcyA6PSBtYXhfc3RlcHM7XG4gICAgICBTdGF0ZS5MYXp5IChsYXp5ICgoTGF6eS5mb3JjZSBwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYykpKVxuICAgIGVsc2VcbiAgICAgIChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjXG4gICAgICAgICAgfVxuICBpblxuICByXG5cbmxldCBmaXggPSBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBOYXRpdmUgLT4gZml4X2RpcmVjdFxuICB8IEJ5dGVjb2RlIC0+IGZpeF9kaXJlY3RcbiAgfCBPdGhlciBfIC0+IGZpeF9sYXp5XG5cbmxldCBvcHRpb24geCBwID1cbiAgcCA8fD4gcmV0dXJuIHhcblxubGV0IGNvbnMgeCB4cyA9IHggOjogeHNcblxubGV0IHJlYyBsaXN0IHBzID1cbiAgbWF0Y2ggcHMgd2l0aFxuICB8IFtdICAgIC0+IHJldHVybiBbXVxuICB8IHA6OnBzIC0+IGxpZnQyIGNvbnMgcCAobGlzdCBwcylcblxubGV0IGNvdW50IG4gcCA9XG4gIGlmIG4gPCAwIFxuICB0aGVuIGZhaWwgXCJjb3VudDogbiA8IDBcIlxuICBlbHNlIFxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gcmV0dXJuIFtdXG4gICAgICB8IG4gLT4gbGlmdDIgY29ucyBwIChsb29wIChuIC0gMSkpXG4gICAgaW5cbiAgICBsb29wIG5cblxubGV0IG1hbnkgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAobGlmdDIgY29ucyBwIG0pIDx8PiByZXR1cm4gW10pXG5cbmxldCBtYW55MSBwID1cbiAgbGlmdDIgY29ucyBwIChtYW55IHApXG5cbmxldCBtYW55X3RpbGwgcCB0ID1cbiAgZml4IChmdW4gbSAtPlxuICAgICh0ICo+IHJldHVybiBbXSkgPHw+IChsaWZ0MiBjb25zIHAgbSkpXG5cbmxldCBzZXBfYnkxIHMgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICBsaWZ0MiBjb25zIHAgKChzICo+IG0pIDx8PiByZXR1cm4gW10pKVxuXG5sZXQgc2VwX2J5IHMgcCA9XG4gIChsaWZ0MiBjb25zIHAgKChzICo+IHNlcF9ieTEgcyBwKSA8fD4gcmV0dXJuIFtdKSkgPHw+IHJldHVybiBbXVxuXG5sZXQgc2tpcF9tYW55IHAgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgKHAgKj4gbSkgPHw+IHJldHVybiAoKSlcblxubGV0IHNraXBfbWFueTEgcCA9XG4gIHAgKj4gc2tpcF9tYW55IHBcblxubGV0IGVuZF9vZl9saW5lID1cbiAgKGNoYXIgJ1xcbicgKj4gcmV0dXJuICgpKSA8fD4gKHN0cmluZyBcIlxcclxcblwiICo+IHJldHVybiAoKSkgPD8+IFwiZW5kX29mX2xpbmVcIlxuXG5sZXQgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgc3RhdGUgPSByZWYgc3RhdGUgaW5cbiAgICBsZXQgcGFyc2VyID1cbiAgICAgIGNvdW50X3doaWxlIH5pbml0OjAgfmY6KGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGYgIXN0YXRlIGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgICAgfCBTb21lIHN0YXRlJyAtPiBzdGF0ZSA6PSBzdGF0ZSc7IHRydWUpXG4gICAgICB+d2l0aF9idWZmZXJcbiAgICAgID4+fCBmdW4geCAtPiB4LCAhc3RhdGVcbiAgICBpblxuICAgIHBhcnNlci5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIH1cblxubGV0IHNjYW4gc3RhdGUgZiA9XG4gIHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xuXG5sZXQgc2Nhbl9zdGF0ZSBzdGF0ZSBmID1cbiAgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXI6KGZ1biBfIH5vZmY6XyB+bGVuOl8gLT4gKCkpXG4gID4+fCBmdW4gKCgpLCBzdGF0ZSkgLT4gc3RhdGVcblxubGV0IHNjYW5fc3RyaW5nIHN0YXRlIGYgPVxuICBzY2FuIHN0YXRlIGYgPj58IGZzdFxuXG5sZXQgY29uc3VtZV93aXRoIHAgZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdGFydCA9IHBvcyBpblxuICAgIGxldCBwYXJzZXJfY29tbWl0dGVkX2J5dGVzID0gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpbnB1dCAgaW5cbiAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgXyA9XG4gICAgICBpZiBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIDw+IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQnXG4gICAgICB0aGVuIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJjb25zdW1lZDogcGFyc2VyIGNvbW1pdHRlZFwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9IHBvcycgLSBzdGFydCBpblxuICAgICAgICBsZXQgY29uc3VtZWQgPSBJbnB1dC5hcHBseSBpbnB1dCcgc3RhcnQgbGVuIH5mIGluXG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgY29uc3VtZWQpXG4gICAgaW5cbiAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gIH1cblxubGV0IGNvbnN1bWVkICAgICAgICAgICBwID0gY29uc3VtZV93aXRoIHAgQmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5sZXQgY29uc3VtZWRfYmlnc3RyaW5nIHAgPSBjb25zdW1lX3dpdGggcCBCaWdzdHJpbmdhZi5jb3B5XG5cbmxldCBib3RoIGEgYiA9IGxpZnQyIChmdW4gYSBiIC0+IGEsIGIpIGEgYlxubGV0IG1hcCB0IH5mID0gdCA+PnwgZlxubGV0IGJpbmQgdCB+ZiA9IHQgPj49IGZcbmxldCBtYXAyIGEgYiB+ZiA9IGxpZnQyIGYgYSBiXG5sZXQgbWFwMyBhIGIgYyB+ZiA9IGxpZnQzIGYgYSBiIGNcbmxldCBtYXA0IGEgYiBjIGQgfmYgPSBsaWZ0NCBmIGEgYiBjIGRcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuICAgIGxldCBtYXAyID0gbWFwMlxuICAgIGxldCBtYXAzID0gbWFwM1xuICAgIGxldCBtYXA0ID0gbWFwNFxuICBlbmRcbmVuZFxuXG5sZXQgKCBsZXQrICkgPSAoID4+fCApXG5sZXQgKCBsZXQqICkgPSAoID4+PSApXG5sZXQgKCBhbmQrICkgPSBib3RoXG5cbm1vZHVsZSBCRSA9IHN0cnVjdFxuICAoKiBYWFgoc2VsaW9wb3UpOiBUaGUgcGF0dGVybiBpbiBib3RoIHRoaXMgbW9kdWxlIGFuZCBbTEVdIGFyZSBhIGNvbXByb21pc2VcbiAgICogYmV0d2VlbiBlZmZpY2llbmN5IGFuZCBjb2RlIHJldXNlLiBCeSBpbmxpbmluZyBbZW5zdXJlXSB5b3UgY2FuIHJlY292ZXJcbiAgICogYWJvdXQgMiBuYW5vc2Vjb25kcyBvbiBhdmVyYWdlLiBUaGF0IG1heSBhZGQgdXAgaW4gY2VydGFpbiBhcHBsaWNhdGlvbnMuXG4gICAqXG4gICAqIFRoaXMgcGF0dGVybiBkb2VzIG5vdCBhbGxvY2F0ZSBpbiB0aGUgZmFzdCAoc3VjY2VzcykgcGF0aC5cbiAgICogKilcbiAgbGV0IGludDE2IG4gPVxuICAgIGxldCBieXRlcyA9IDIgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9pbnQxNl9iZSBpbnB1dCBwb3MgPSAobiBsYW5kIDB4ZmZmZilcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQxNlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDMyIG4gPVxuICAgIGxldCBieXRlcyA9IDQgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50MzIuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50MzJfYmUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50MzJcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQ2NCBuID1cbiAgICBsZXQgYnl0ZXMgPSA4IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDY0LmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDY0X2JlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDY0XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgYW55X3VpbnQxNiA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MTYgID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X3NpZ25fZXh0ZW5kZWRfYmUgIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQzMiAgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDY0ID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9mbG9hdCA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50MzIuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSBicyBvZmYpKSlcblxuICBsZXQgYW55X2RvdWJsZSA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50NjQuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSBicyBvZmYpKSlcbmVuZFxuXG5tb2R1bGUgTEUgPSBzdHJ1Y3RcbiAgbGV0IGludDE2IG4gPVxuICAgIGxldCBieXRlcyA9IDIgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9pbnQxNl9sZSBpbnB1dCBwb3MgPSAobiBsYW5kIDB4ZmZmZilcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQxNlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDMyIG4gPVxuICAgIGxldCBieXRlcyA9IDQgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50MzIuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50MzJfbGUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50MzJcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQ2NCBuID1cbiAgICBsZXQgYnl0ZXMgPSA4IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDY0LmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDY0X2xlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDY0XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuXG4gIGxldCBhbnlfdWludDE2ID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQxNiAgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfc2lnbl9leHRlbmRlZF9sZSAgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDMyICA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50NjQgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2Zsb2F0ID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQzMi5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIGJzIG9mZikpKVxuXG4gIGxldCBhbnlfZG91YmxlID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQ2NC5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2xlIGJzIG9mZikpKVxuZW5kXG5cbm1vZHVsZSBVbnNhZmUgPSBzdHJ1Y3RcbiAgbGV0IHRha2UgbiBmID1cbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmYpXG5cbiAgbGV0IHBlZWsgbiBmID1cbiAgICB1bnNhZmVfbG9va2FoZWFkICh0YWtlIG4gZilcblxuICBsZXQgdGFrZV93aGlsZSBjaGVjayBmID1cbiAgICBjb3VudF93aGlsZSB+aW5pdDowIH5mOmNoZWNrIH53aXRoX2J1ZmZlcjpmXG5cbiAgbGV0IHRha2Vfd2hpbGUxIGNoZWNrIGYgPVxuICAgIGNvdW50X3doaWxlMSB+ZjpjaGVjayB+d2l0aF9idWZmZXI6ZlxuXG4gIGxldCB0YWtlX3RpbGwgY2hlY2sgZiA9XG4gICAgdGFrZV93aGlsZSAoZnVuIGMgLT4gbm90IChjaGVjayBjKSkgZlxuZW5kXG5cbm1vZHVsZSBDb25zdW1lID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBQcmVmaXhcbiAgICB8IEFsbFxuZW5kXG5cbmxldCBwYXJzZV9iaWdzdHJpbmcgfmNvbnN1bWUgcCBicyA9XG4gIGxldCBwID1cbiAgICBtYXRjaCAoY29uc3VtZSA6IENvbnN1bWUudCkgd2l0aFxuICAgIHwgUHJlZml4IC0+IHBcbiAgICB8IEFsbCAtPiBwIDwqIGVuZF9vZl9pbnB1dFxuICBpblxuICBVbmJ1ZmZlcmVkLnBhcnNlX2JpZ3N0cmluZyBwIGJzXG5cbmxldCBwYXJzZV9zdHJpbmcgfmNvbnN1bWUgcCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnMgID0gQmlnc3RyaW5nYWYuY3JlYXRlIGxlbiBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdF9mcm9tX3N0cmluZyBzIH5zcmNfb2ZmOjAgYnMgfmRzdF9vZmY6MCB+bGVuO1xuICBwYXJzZV9iaWdzdHJpbmcgfmNvbnN1bWUgcCBic1xuIl19
