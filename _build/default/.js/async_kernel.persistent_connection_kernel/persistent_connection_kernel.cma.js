// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Persistent_connection_kern=
      caml_string_of_jsbytes
       ("Persistent_connection_kernel__Persistent_connection_kernel_intf"),
     cst_persistent_connection_kern=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_persistent_connection_kern$0=
      caml_string_of_jsbytes
       ("persistent_connection_kernel/src/persistent_connection_kernel_intf.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_persistent_connection_kern$1=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_persistent_connection_kern$2=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_Persistent_connection_kern$0=
      caml_string_of_jsbytes
       ("Persistent_connection_kernel__Persistent_connection_kernel_intf"),
     cst_Persistent_connection_clos=
      caml_string_of_jsbytes("Persistent connection closed"),
     cst_Persistent_connection_kern$1=
      caml_string_of_jsbytes("Persistent_connection_kernel"),
     cst_persistent_connection_kern$3=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_persistent_connection_kern$4=
      caml_string_of_jsbytes
       ("persistent_connection_kernel/src/persistent_connection_kernel.ml"),
     cst$0=caml_string_of_jsbytes(""),
     cst_persistent_connection_kern$5=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_persistent_connection_kern$6=
      caml_string_of_jsbytes("persistent_connection_kernel"),
     cst_Persistent_connection_kern$2=
      caml_string_of_jsbytes("Persistent_connection_kernel"),
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime,
     Async_kernel_Ivar=global_data.Async_kernel__Ivar,
     Async_kernel=global_data.Async_kernel,
     Async_kernel_Deferred=global_data.Async_kernel__Deferred,
     Async_kernel_Time_source=global_data.Async_kernel__Time_source,
     Core_Time_ns=global_data.Core__Time_ns,
     Base_Random=global_data.Base__Random,
     Core=global_data.Core,
     Core_Fn=global_data.Core__Fn,
     Core_Option=global_data.Core__Option,
     Core_Error=global_data.Core__Error,
     Async_kernel_Monitor=global_data.Async_kernel__Monitor,
     Base_Exn=global_data.Base__Exn,
     Core_Sexp=global_data.Core__Sexp,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Core_Or_error=global_data.Core__Or_error;
    global_data.Base__Field;
    var Persistent_connection_kernel=[0];
    caml_register_global
     (56,Persistent_connection_kernel,"Persistent_connection_kernel__");
    caml_call1(Ppx_module_timer_runtime[4],cst_Persistent_connection_kern);
    caml_call1
     (Ppx_bench_lib_Benchmark_accumu[1][1],cst_persistent_connection_kern);
    caml_call1(Expect_test_collector[5][1],cst_persistent_connection_kern$0);
    caml_call2
     (Ppx_inline_test_lib_Runtime[2],cst_persistent_connection_kern$1,cst);
    caml_call1
     (Ppx_inline_test_lib_Runtime[3],cst_persistent_connection_kern$2);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Persistent_connection_kern$0);
    var Persistent_connection_kernel_P=[0];
    caml_register_global
     (61,
      Persistent_connection_kernel_P,
      "Persistent_connection_kernel__Persistent_connection_kernel_intf");
    caml_call1(Ppx_module_timer_runtime[4],cst_Persistent_connection_kern$1);
    caml_call1
     (Ppx_bench_lib_Benchmark_accumu[1][1],cst_persistent_connection_kern$3);
    caml_call1(Expect_test_collector[5][1],cst_persistent_connection_kern$4);
    caml_call2
     (Ppx_inline_test_lib_Runtime[2],cst_persistent_connection_kern$5,cst$0);
    caml_call1
     (Ppx_inline_test_lib_Runtime[3],cst_persistent_connection_kern$6);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Persistent_connection_kern$2);
    var
     _x_=[0,-289386606,0],
     _y_=[0,-289386606,0],
     _z_=[0,990972795,0],
     _v_=[0,-289386606,0],
     _w_=[0,-289386606,0],
     _p_=[0,caml_string_of_jsbytes("Close_started")],
     _q_=[0,caml_string_of_jsbytes("Ok")],
     _i_=[0,caml_string_of_jsbytes("sexp_of_address")],
     _j_=[0,caml_string_of_jsbytes("address_equal")],
     _k_=[0,caml_string_of_jsbytes("don't_reconnect")],
     _l_=[0,caml_string_of_jsbytes("close_finished")],
     _m_=[0,caml_string_of_jsbytes("close_started")],
     _n_=[0,caml_string_of_jsbytes("event_handler")],
     _o_=[0,caml_string_of_jsbytes("next_connect_result")],
     _r_=[0,caml_string_of_jsbytes("conn")],
     _s_=[0,caml_string_of_jsbytes("retry_delay")],
     _t_=[0,caml_string_of_jsbytes("connect")],
     _u_=[0,caml_string_of_jsbytes("get_address")],
     _g_=[0,caml_string_of_jsbytes("on_event")],
     _h_=[0,caml_string_of_jsbytes("server_name")],
     _b_=[0,caml_string_of_jsbytes("Attempting_to_connect")],
     _c_=[0,caml_string_of_jsbytes("Disconnected")],
     _d_=[0,caml_string_of_jsbytes("Obtained_address")],
     _e_=[0,caml_string_of_jsbytes("Failed_to_connect")],
     _f_=[0,caml_string_of_jsbytes("Connected")],
     _a_=[0,caml_string_of_jsbytes("<Conn.t>")],
     Persistent_connection_kernel$0=
      [0,
       function(Conn)
        {var close=Conn[1],is_closed=Conn[2],close_finished=Conn[3];
         function sexp_of_t(param){return _a_}
         function sexp_of_t$0(of_address_001,param)
          {if(typeof param === "number")return 0 === param?_b_:_c_;
           switch(param[0])
            {case 0:
              var
               arg0_002=param[1],
               res0_003=caml_call1(of_address_001,arg0_002);
              return [1,[0,_d_,[0,res0_003,0]]];
             case 1:
              var
               arg0_004=param[1],
               res0_005=caml_call1(Core_Error[6],arg0_004);
              return [1,[0,_e_,[0,res0_005,0]]];
             default:
              var
               arg0_006=param[1],
               res0_007=caml_call1(Sexplib0_Sexp_conv[23],arg0_006);
              return [1,[0,_f_,[0,res0_007,0]]]}}
         function log_level(param)
          {if(typeof param !== "number" && 1 === param[0])return 106380200;
           return 815031438}
         function handle_event(t$0,t)
          {var on_event=t$0[6][2];return caml_call1(on_event,t)}
         function abort_reconnecting_with_no_act(t)
          {caml_call2(Async_kernel_Ivar[14],t[7],0);
           caml_call2(Async_kernel_Ivar[14],t[8],0);
           return caml_call2(Async_kernel_Ivar[14],t[4],-400989606)}
         function current_connection(t)
          {var
            _aT_=caml_call1(Async_kernel_Ivar[18],t[4]),
            match=caml_call1(Async_kernel_Deferred[5],_aT_);
           if(match)
            {var _aU_=match[1];
             if(typeof _aU_ !== "number"){var conn=_aU_[2];return [0,conn]}}
           return 0}
         function close_finished$0(t)
          {return caml_call1(Async_kernel_Ivar[18],t[8])}
         function is_closed$0(t)
          {return caml_call1(Async_kernel_Ivar[17],t[7])}
         var
          _A_=caml_call1(Sexplib0_Sexp_conv[7],cst_Persistent_connection_clos),
          connected_or_failed_to_connect=caml_call1(Core_Or_error[40],_A_);
         function sexp_of_t$1(param)
          {var
            conn_023=param[4],
            next_connect_result_026=param[5],
            don_t_reconnect_034=param[9],
            close_finished_032=param[8],
            close_started_030=param[7],
            event_handler_028=param[6],
            bnds_016=0;
           function _aG_(_aS_){return 0}
           var
            arg_039=caml_call1(Sexplib0_Sexp_conv[24],_aG_),
            bnds_016$0=[0,[1,[0,_i_,[0,arg_039,0]]],bnds_016];
           function _aH_(_aR_){return 0}
           var
            arg_037=caml_call1(Sexplib0_Sexp_conv[24],_aH_),
            bnds_016$1=[0,[1,[0,_j_,[0,arg_037,0]]],bnds_016$0],
            arg_035=
             caml_call2(Async_kernel_Ivar[9],Core[518],don_t_reconnect_034),
            bnds_016$2=[0,[1,[0,_k_,[0,arg_035,0]]],bnds_016$1],
            arg_033=
             caml_call2(Async_kernel_Ivar[9],Core[518],close_finished_032),
            bnds_016$3=[0,[1,[0,_l_,[0,arg_033,0]]],bnds_016$2],
            arg_031=
             caml_call2(Async_kernel_Ivar[9],Core[518],close_started_030),
            bnds_016$4=[0,[1,[0,_m_,[0,arg_031,0]]],bnds_016$3],
            server_name_011=event_handler_028[1],
            bnds_010=0;
           function _aF_(_aQ_){return 0}
           var
            arg_014=caml_call1(Sexplib0_Sexp_conv[24],_aF_),
            bnds_010$0=[0,[1,[0,_g_,[0,arg_014,0]]],bnds_010],
            arg_012=caml_call1(Core[471],server_name_011),
            bnds_010$1=[0,[1,[0,_h_,[0,arg_012,0]]],bnds_010$0],
            arg_029=[1,bnds_010$1],
            bnds_016$5=[0,[1,[0,_n_,[0,arg_029,0]]],bnds_016$4],
            _aI_=caml_call1(Core_Or_error[13],sexp_of_t),
            arg_027=
             caml_call2(Async_kernel_Ivar[9],_aI_,next_connect_result_026),
            bnds_016$6=[0,[1,[0,_o_,[0,arg_027,0]]],bnds_016$5];
           function _aJ_(param)
            {if(typeof param === "number")return _p_;
             var v_025=param[2];
             return [1,[0,_q_,[0,sexp_of_t(v_025),0]]]}
           var
            arg_024=caml_call2(Async_kernel_Ivar[9],_aJ_,conn_023),
            bnds_016$7=[0,[1,[0,_r_,[0,arg_024,0]]],bnds_016$6];
           function _aK_(_aP_){return 0}
           var
            arg_022=caml_call1(Sexplib0_Sexp_conv[24],_aK_),
            bnds_016$8=[0,[1,[0,_s_,[0,arg_022,0]]],bnds_016$7];
           function _aL_(_aO_){return 0}
           var
            arg_020=caml_call1(Sexplib0_Sexp_conv[24],_aL_),
            bnds_016$9=[0,[1,[0,_t_,[0,arg_020,0]]],bnds_016$8];
           function _aM_(_aN_){return 0}
           var
            arg_018=caml_call1(Sexplib0_Sexp_conv[24],_aM_),
            bnds_016$10=[0,[1,[0,_u_,[0,arg_018,0]]],bnds_016$9];
           return [1,bnds_016$10]}
         function close_when_current_connection_(t)
          {return caml_call2(Async_kernel_Ivar[15],t[9],0)}
         function close_finished$1(param){return close_finished$0(param)}
         function is_closed$1(param){return is_closed$0(param)}
         function close$0(t)
          {if(caml_call1(Async_kernel_Ivar[17],t[7]))
            return close_finished$0(t);
           caml_call2(Async_kernel_Ivar[14],t[7],0);
           function _aB_(conn_opt)
            {function _aD_(param)
              {return caml_call2(Async_kernel_Ivar[14],t[8],0)}
             if(typeof conn_opt === "number")
              var _aE_=Async_kernel_Deferred[18];
             else
              var conn=conn_opt[2],_aE_=caml_call1(close,conn);
             return caml_call2(Async_kernel[21],_aE_,_aD_)}
           var _aC_=caml_call1(Async_kernel_Ivar[18],t[4]);
           return caml_call2(Async_kernel[20],_aC_,_aB_)}
         function server_name(t){return t[6][1]}
         function current_connection$0(param)
          {return current_connection(param)}
         function connected_or_failed_to_connect$0(t)
          {if(is_closed$0(t))
            return caml_call1(Async_kernel[19],connected_or_failed_to_connect);
           var match=current_connection(t);
           if(match)
            {var x=match[1];
             if(! caml_call1(is_closed,x))
              return caml_call1(Async_kernel[19],[0,x])}
           var _at_=0;
           function _au_(_aA_){return _aA_}
           var
            _av_=caml_call1(Async_kernel_Ivar[18],t[5]),
            _aw_=[0,caml_call2(Async_kernel[4],_av_,_au_),_at_];
           function _ax_(param){return connected_or_failed_to_connect}
           var
            _ay_=caml_call1(Async_kernel_Ivar[18],t[7]),
            _az_=[0,caml_call2(Async_kernel[4],_ay_,_ax_),_aw_];
           return caml_call1(Async_kernel_Deferred[29],_az_)}
         function connected(t)
          {function loop(param)
            {var
              d=caml_call1(Async_kernel_Ivar[18],t[4]),
              match=caml_call1(Async_kernel_Deferred[5],d);
             if(! match)
              {var
                _as_=
                 function(param)
                  {if(typeof param === "number")
                    return caml_call1(Async_kernel_Deferred[19],0);
                   var conn=param[2];
                   return caml_call1(Async_kernel[19],conn)};
               return caml_call2(Async_kernel[20],d,_as_)}
             var _aq_=match[1];
             if(typeof _aq_ === "number")
              return caml_call1(Async_kernel_Deferred[19],0);
             var conn=_aq_[2];
             if(! caml_call1(is_closed,conn))
              return caml_call1(Async_kernel[19],conn);
             var _ar_=caml_call1(close_finished,conn);
             return caml_call2(Async_kernel[20],_ar_,loop)}
           return loop(0)}
         function create
          (server_name,
           opt,
           retry_delay$0,
           random_state$1,
           time_source$0,
           connect,
           Address,
           get_address)
          {if(opt)
            var sth=opt[1],on_event=sth;
           else
            var on_event=function(param){return Async_kernel_Deferred[18]};
           if(random_state$1)
            var sth$0=random_state$1[1],random_state=sth$0;
           else
            var random_state=[0,389604849,Base_Random[18][1]];
           if(time_source$0)
            var sth$1=time_source$0[1],time_source=sth$1;
           else
            var time_source=caml_call1(Async_kernel_Time_source[10],0);
           var
            event_handler=[0,server_name,on_event],
            _B_=Core[541]?0.1:10.,
            _C_=caml_call1(Core_Time_ns[1][81],_B_),
            default_retry_delay=caml_call1(Core_Fn[1],_C_),
            non_randomized_delay=
             caml_call2(Core_Option[34],retry_delay$0,default_retry_delay);
           if(typeof random_state === "number")
            var retry_delay_span=non_randomized_delay;
           else
            var
             random_state$0=random_state[2],
             retry_delay_span=
              function(param)
               {var
                 span=caml_call1(non_randomized_delay,0),
                 span$0=caml_call1(Core_Time_ns[1][91],span),
                 distance=
                  caml_call2(Base_Random[18][10],random_state$0,span$0 * 0.3),
                 wait=
                  caml_call1(Base_Random[18][16],random_state$0)
                   ?span$0 + distance
                   :span$0 - distance;
                return caml_call1(Core_Time_ns[1][81],wait)};
           function retry_delay(param)
            {var _ap_=caml_call1(retry_delay_span,0);
             return caml_call2(Async_kernel_Time_source[29],time_source,_ap_)}
           var
            _D_=Address[2],
            _E_=Address[1],
            _F_=caml_call1(Async_kernel_Ivar[12],0),
            _G_=caml_call1(Async_kernel_Ivar[12],0),
            _H_=caml_call1(Async_kernel_Ivar[12],0),
            _I_=caml_call1(Async_kernel_Ivar[12],0),
            t=
             [0,
              get_address,
              connect,
              retry_delay,
              caml_call1(Async_kernel_Ivar[12],0),
              _I_,
              event_handler,
              _H_,
              _G_,
              _F_,
              _E_,
              _D_];
           function _J_(param)
            {function _L_(param)
              {var previous_address=[0,0],previous_error=[0,0];
               function _O_(param)
                {if(typeof param === "number")
                  return -400989606 <= param
                          ?(caml_call2(Async_kernel_Ivar[14],t[4],-400989606),
                            caml_call1(Async_kernel[19],_v_))
                          :(abort_reconnecting_with_no_act(t),
                            caml_call1(Async_kernel[19],_w_));
                 var
                  match=param[2],
                  ready_to_retry_connecting=match[2],
                  conn=match[1];
                 caml_call2(Async_kernel_Ivar[14],t[4],[0,17724,conn]);
                 function _af_(param)
                  {function _ah_(param)
                    {t[4] = caml_call1(Async_kernel_Ivar[12],0);
                     function _aj_(param)
                      {function _al_(param)
                        {return caml_call1(Async_kernel_Ivar[17],t[7])
                                 ?(caml_call2(Async_kernel_Ivar[14],t[4],-400989606),_x_)
                                 :caml_call1(Async_kernel_Ivar[17],t[9])
                                   ?(abort_reconnecting_with_no_act(t),_y_)
                                   :_z_}
                       var
                        _am_=[0,caml_call1(Async_kernel_Ivar[18],t[9]),0],
                        _an_=
                         [0,
                          ready_to_retry_connecting,
                          [0,caml_call1(Async_kernel_Ivar[18],t[7]),_am_]],
                        _ao_=caml_call1(Async_kernel_Deferred[23],_an_);
                       return caml_call2(Async_kernel[22][3],_ao_,_al_)}
                     var _ak_=handle_event(t,1);
                     return caml_call2(Async_kernel[20],_ak_,_aj_)}
                   var _ai_=caml_call1(close_finished,conn);
                   return caml_call2(Async_kernel[20],_ai_,_ah_)}
                 var _ag_=handle_event(t,[2,conn]);
                 return caml_call2(Async_kernel[20],_ag_,_af_)}
               function loop(param)
                {if(caml_call1(Async_kernel_Ivar[17],t[7]))
                  return caml_call1(Async_kernel[19],-400989606);
                 if(caml_call1(Async_kernel_Ivar[17],t[9]))
                  return caml_call1(Async_kernel[19],-818917400);
                 var ready_to_retry_connecting=caml_call1(t[3],0);
                 function _S_(connect_result)
                  {caml_call2(Async_kernel_Ivar[14],t[5],connect_result);
                   t[5] = caml_call1(Async_kernel_Ivar[12],0);
                   if(0 === connect_result[0])
                    {var conn=connect_result[1];
                     return caml_call1
                             (Async_kernel[19],
                              [0,17724,[0,conn,ready_to_retry_connecting]])}
                   var err=connect_result[1],_Y_=previous_error[1];
                   if(_Y_)
                    var
                     previous_err=_Y_[1],
                     to_sexp=
                      function(e)
                       {var
                         _ad_=caml_call1(Core_Error[26],e),
                         _ae_=caml_call1(Async_kernel_Monitor[13],_ad_);
                        return caml_call1(Base_Exn[1],_ae_)},
                     _W_=to_sexp(previous_err),
                     _X_=to_sexp(err),
                     same_as_previous_error=caml_call2(Core_Sexp[36],_X_,_W_);
                   else
                    var same_as_previous_error=0;
                   previous_error[1] = [0,err];
                   function _Z_(param)
                    {function _$_(param){return loop(0)}
                     var
                      _aa_=[0,caml_call1(Async_kernel_Ivar[18],t[9]),0],
                      _ab_=
                       [0,
                        ready_to_retry_connecting,
                        [0,caml_call1(Async_kernel_Ivar[18],t[7]),_aa_]],
                      _ac_=caml_call1(Async_kernel_Deferred[23],_ab_);
                     return caml_call2(Async_kernel[20],_ac_,_$_)}
                   var
                    ___=
                     same_as_previous_error
                      ?Async_kernel_Deferred[18]
                      :handle_event(t,[1,err]);
                   return caml_call2(Async_kernel[20],___,_Z_)}
                 function _P_(param)
                  {if(0 !== param[0])
                    {var e=param[1];return caml_call1(Async_kernel[19],[1,e])}
                   var addr=param[1],_T_=previous_address[1];
                   if(_T_)
                    var
                     previous_address$0=_T_[1],
                     same_as_previous_address=
                      caml_call2(t[10],addr,previous_address$0);
                   else
                    var same_as_previous_address=0;
                   previous_address[1] = [0,addr];
                   function _U_(param){return caml_call1(t[2],addr)}
                   var
                    _V_=
                     same_as_previous_address
                      ?Async_kernel_Deferred[18]
                      :handle_event(t,[0,addr]);
                   return caml_call2(Async_kernel[20],_V_,_U_)}
                 var
                  _Q_=caml_call1(t[1],0),
                  _R_=caml_call2(Async_kernel[20],_Q_,_P_);
                 return caml_call2(Async_kernel[22][2],_R_,_S_)}
               var _N_=loop(0);
               return caml_call2(Async_kernel[20],_N_,_O_)}
             var _M_=handle_event(t,0);
             return caml_call2(Async_kernel[20],_M_,_L_)}
           var _K_=caml_call2(Async_kernel_Deferred[31],0,_J_);
           caml_call1(Async_kernel[6],_K_);
           return t}
         return [0,
                 sexp_of_t$1,
                 [0,sexp_of_t$0,log_level],
                 create,
                 connected,
                 connected_or_failed_to_connect$0,
                 current_connection$0,
                 server_name,
                 close$0,
                 is_closed$1,
                 close_finished$1,
                 close_when_current_connection_]}];
    caml_register_global
     (78,Persistent_connection_kernel$0,"Persistent_connection_kernel");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjbG9zZSIsImlzX2Nsb3NlZCIsImNsb3NlX2ZpbmlzaGVkIiwic2V4cF9vZl90Iiwic2V4cF9vZl90JDAiLCJvZl9hZGRyZXNzXzAwMSIsImFyZzBfMDAyIiwicmVzMF8wMDMiLCJhcmcwXzAwNCIsInJlczBfMDA1IiwiYXJnMF8wMDYiLCJyZXMwXzAwNyIsImxvZ19sZXZlbCIsImhhbmRsZV9ldmVudCIsInQkMCIsInQiLCJvbl9ldmVudCIsImFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdCIsImN1cnJlbnRfY29ubmVjdGlvbiIsImNvbm4iLCJjbG9zZV9maW5pc2hlZCQwIiwiaXNfY2xvc2VkJDAiLCJjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QiLCJzZXhwX29mX3QkMSIsInBhcmFtIiwiY29ubl8wMjMiLCJuZXh0X2Nvbm5lY3RfcmVzdWx0XzAyNiIsImRvbl90X3JlY29ubmVjdF8wMzQiLCJjbG9zZV9maW5pc2hlZF8wMzIiLCJjbG9zZV9zdGFydGVkXzAzMCIsImV2ZW50X2hhbmRsZXJfMDI4IiwiYm5kc18wMTYiLCJhcmdfMDM5IiwiYm5kc18wMTYkMCIsImFyZ18wMzciLCJibmRzXzAxNiQxIiwiYXJnXzAzNSIsImJuZHNfMDE2JDIiLCJhcmdfMDMzIiwiYm5kc18wMTYkMyIsImFyZ18wMzEiLCJibmRzXzAxNiQ0Iiwic2VydmVyX25hbWVfMDExIiwiYm5kc18wMTAiLCJhcmdfMDE0IiwiYm5kc18wMTAkMCIsImFyZ18wMTIiLCJibmRzXzAxMCQxIiwiYXJnXzAyOSIsImJuZHNfMDE2JDUiLCJhcmdfMDI3IiwiYm5kc18wMTYkNiIsInZfMDI1IiwiYXJnXzAyNCIsImJuZHNfMDE2JDciLCJhcmdfMDIyIiwiYm5kc18wMTYkOCIsImFyZ18wMjAiLCJibmRzXzAxNiQ5IiwiYXJnXzAxOCIsImJuZHNfMDE2JDEwIiwiY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25fIiwiY2xvc2VfZmluaXNoZWQkMSIsImlzX2Nsb3NlZCQxIiwiY2xvc2UkMCIsImNvbm5fb3B0Iiwic2VydmVyX25hbWUiLCJjdXJyZW50X2Nvbm5lY3Rpb24kMCIsImNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCQwIiwieCIsImNvbm5lY3RlZCIsImxvb3AiLCJkIiwiY3JlYXRlIiwib3B0IiwicmV0cnlfZGVsYXkkMCIsInJhbmRvbV9zdGF0ZSQxIiwidGltZV9zb3VyY2UkMCIsImNvbm5lY3QiLCJBZGRyZXNzIiwiZ2V0X2FkZHJlc3MiLCJzdGgiLCJzdGgkMCIsInJhbmRvbV9zdGF0ZSIsInN0aCQxIiwidGltZV9zb3VyY2UiLCJldmVudF9oYW5kbGVyIiwiZGVmYXVsdF9yZXRyeV9kZWxheSIsIm5vbl9yYW5kb21pemVkX2RlbGF5IiwicmV0cnlfZGVsYXlfc3BhbiIsInJhbmRvbV9zdGF0ZSQwIiwic3BhbiIsInNwYW4kMCIsImRpc3RhbmNlIiwid2FpdCIsInJldHJ5X2RlbGF5IiwicHJldmlvdXNfYWRkcmVzcyIsInByZXZpb3VzX2Vycm9yIiwicmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZyIsImNvbm5lY3RfcmVzdWx0IiwiZXJyIiwicHJldmlvdXNfZXJyIiwidG9fc2V4cCIsImUiLCJzYW1lX2FzX3ByZXZpb3VzX2Vycm9yIiwiYWRkciIsInByZXZpb3VzX2FkZHJlc3MkMCIsInNhbWVfYXNfcHJldmlvdXNfYWRkcmVzcyJdLCJzb3VyY2VzIjpbIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9hc3luY19rZXJuZWwvcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC9wZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsX2ludGYubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYXN5bmNfa2VybmVsL3BlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWwvcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC5tbCJdLCJtYXBwaW5n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Q0ErUW5COztpQkFqQ2ZRO29CQTFTRm5CLFlBa0JJUTtpQkFzU0Y2RDtpQkFGQUg7aUJBREFGO2lCQURBRDtpQkFEQUQ7aUJBREFGO2lCQURBRDtpQkFEQUQ7aUJBSkFEOzs7VSIsInNvdXJjZXNDb250ZW50IjpbIigqKiBBbiBhY3RpdmVseSBtYWludGFpbmVkIGNvbm5lY3Rpb24gdG8gc29tZSBzZXJ2aWNlIHRoYXQgZWFnZXJseSBhbmQgcmVwZWF0ZWRseSBhdHRlbXB0c1xuICAgIHRvIHJlY29ubmVjdCB3aGVuZXZlciB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGlzIGxvc3QsIHVudGlsIGEgbmV3IG9uZSBjYW4gYmVcbiAgICBlc3RhYmxpc2hlZC4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5cblxuKCoqIFRoZSBhZGRyZXNzIG9mIGEgc2VydmljZSB0byB3aGljaCBvbmUgY2FuIGNvbm5lY3QuIEUuZy4gW0hvc3RfYW5kX3BvcnQudF0gaXMgYVxuICAgIHJlYXNvbmFibGUgY2hvaWNlIHdoZW4gbWFraW5nIGEgVENQIGNvbm5lY3Rpb24uXG4qKVxubW9kdWxlIHR5cGUgQWRkcmVzcyA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmcgZXF1YWwsIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgQ2xvc2FibGUgPSBzaWdcbiAgKCoqIGEgY29ubmVjdGlvbiB0eXBlICopXG4gIHR5cGUgdFxuXG4gICgqKiBbY2xvc2UgdF0gY2xvc2VzIHRoZSBjb25uZWN0aW9uLiBUaGUgcmV0dXJuZWQgZGVmZXJyZWQgYmVjb21lcyBkZXRlcm1pbmVkIG9uY2UgYW55XG4gICAgICByZXNvdXJjZXMgbmVlZGVkIHRvIG1haW50YWluIHRoZSBjb25uZWN0aW9uIGhhdmUgYmVlbiByZWxlYXNlZC4gKilcbiAgdmFsIGNsb3NlIDogdCAtPiB1bml0IERlZmVycmVkLnRcblxuICAoKiogW2lzX2Nsb3NlZCB0XSByZXR1cm5zIHRydWUgaWYgW2Nsb3NlXSBoYXMgZXZlciBiZWVuIGNhbGxlZCAoZXZlbiBpZiB0aGUgcmV0dXJuZWRcbiAgICAgIGRlZmVycmVkIGhhcyBub3QgeWV0IGJlZW4gZnVsZmlsbGVkKS5cblxuICAgICAgTm90ZSB0aGF0IHNvbWUgbW9kdWxlcyBpbXBsZW1lbnRpbmcgW0Nsb3NhYmxlXSBtYXkgY2FsbCBjbG9zZSBpbnRlcm5hbGx5IHVwb25cbiAgICAgIG5vdGljaW5nIHRoYXQgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBieSB0aGUgb3RoZXIgc2lkZS4gVGhlIGludGVyZmFjZSBvZiBzdWNoIGFcbiAgICAgIG1vZHVsZSBvdWdodCB0byBzYXkgdGhhdCB0aGlzIGlzIHRoZSBjYXNlLiAqKVxuICB2YWwgaXNfY2xvc2VkIDogdCAtPiBib29sXG5cbiAgKCoqIFtjbG9zZV9maW5pc2hlZCB0XSBiZWNvbWVzIGRldGVybWluZWQgYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdFxuICAgICAgY2FsbCB0byBbY2xvc2VdLiBbY2xvc2VfZmluaXNoZWRdIGRpZmZlcnMgZnJvbSBbY2xvc2VdIGluIHRoYXQgaXQgZG9lcyBub3QgaGF2ZSB0aGVcbiAgICAgIHNpZGUgZWZmZWN0IG9mIGluaXRpYXRpbmcgYSBjbG9zZS4gKilcbiAgdmFsIGNsb3NlX2ZpbmlzaGVkIDogdCAtPiB1bml0IERlZmVycmVkLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICgqKiBBIGNvbm5lY3Rpb24sIHBlcmhhcHMgZW1iZWxsaXNoZWQgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHVwb24gY29ubmVjdGlvbi4gKilcbiAgdHlwZSBjb25uXG5cbiAgbW9kdWxlIEV2ZW50IDogc2lnXG4gICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgIHwgQXR0ZW1wdGluZ190b19jb25uZWN0XG4gICAgICB8IE9idGFpbmVkX2FkZHJlc3Mgb2YgJ2FkZHJlc3NcbiAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3Qgb2YgRXJyb3IudFxuICAgICAgfCBDb25uZWN0ZWQgb2YgY29ublxuICAgICAgfCBEaXNjb25uZWN0ZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdmFsIGxvZ19sZXZlbCA6IF8gdCAtPiBbIGBJbmZvIHwgYERlYnVnIHwgYEVycm9yIF1cbiAgZW5kXG5cbiAgKCoqIFtjcmVhdGUgfnNlcnZlcl9uYW1lIH5vbl9ldmVudCB+cmV0cnlfZGVsYXkgZ2V0X2FkZHJlc3NdIHJldHVybnMgYSBwZXJzaXN0ZW50XG4gICAgICBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdob3NlIGhvc3QgYW5kIHBvcnQgYXJlIG9idGFpbmVkIHZpYSBbZ2V0X2FkZHJlc3NdIGV2ZXJ5IHRpbWVcbiAgICAgIHdlIHRyeSB0byBjb25uZWN0LiBGb3IgZXhhbXBsZSwgW2dldF9hZGRyZXNzXSBtaWdodCBsb29rIHVwIGEgc2VydmVyJ3MgaG9zdCBhbmQgcG9ydFxuICAgICAgaW4gY2F0YWxvZyBhdCBhIHBhcnRpY3VsYXIgcGF0aCB0byB3aGljaCBtdWx0aXBsZSByZWR1bmRhbnQgY29waWVzIG9mIGEgc2VydmljZSBhcmVcbiAgICAgIHB1Ymxpc2hpbmcgdGhlaXIgbG9jYXRpb24uIElmIG9uZSBjb3B5IGRpZXMsIHdlIGdldCB0aGUgYWRkcmVzcyBvZiB0aGUgYW5vdGhlciBvbmVcbiAgICAgIHdoZW4gbG9va2luZyB1cCB0aGUgYWRkcmVzcyBhZnRlcndhcmRzLlxuXG4gICAgICBBbGwgY29ubmVjdGlvbiBldmVudHMgKHNlZSB0aGUgdHlwZSBhYm92ZSkgYXJlIHBhc3NlZCB0byB0aGUgW29uX2V2ZW50XSBjYWxsYmFjaywgaWZcbiAgICAgIGdpdmVuLiBXaGVuIHRoaXMgY2FsbGJhY2sgYmVjb21lcyBkZXRlcm1pbmVkLCB3ZSBtb3ZlIG9uIHRvIHRoZSBuZXh0IHN0ZXAgaW4gb3VyXG4gICAgICBjb25uZWN0aW9uIGF0dGVtcHQgKGUuZy4gd2Ugd29uJ3QgYWN0dWFsbHkgYXR0ZW1wdCB0byBjb25uZWN0IHVudGlsIFtvbl9ldmVudFxuICAgICAgQXR0ZW1wdGluZ190b19jb25uZWN0XSBpcyBmaW5pc2hlZCkuIE5vdGUgdGhhdCBbb25fZXZlbnQgRGlzY29ubmVjdGVkXSB3aWxsIG9ubHkgYmVcbiAgICAgIGNhbGxlZCBvbmNlIFtvbl9ldmVudCAoQ29ubmVjdGVkIGNvbm4pXSBmaW5pc2hlcyBldmVuIGlmIHRoZSBjb25uZWN0aW9uIGdvZXMgZG93blxuICAgICAgZHVyaW5nIHRoYXQgY2FsbGJhY2suXG5cbiAgICAgIFtgRmFpbGVkX3RvX2Nvbm5lY3QgZXJyb3JdIGFuZCBbYE9idGFpbmVkX2FkZHJlc3MgYWRkcl0gZXZlbnRzIGFyZSBvbmx5IHJlcG9ydGVkIGlmXG4gICAgICB0aGV5IGFyZSBkaXN0aW5jdCBmcm9tIHRoZSBtb3N0IHJlY2VudCBldmVudCBvZiB0aGUgc2FtZSB0eXBlIHRoYXQgaGFzIHRha2VuIHBsYWNlXG4gICAgICBzaW5jZSB0aGUgbW9zdCByZWNlbnQgW2BBdHRlbXB0aW5nX3RvX2Nvbm5lY3RdIGV2ZW50LlxuXG4gICAgICBDb25uZWN0aW9uIGlzIGJ5IGRlZmF1bHQgcmV0cmllZCBhZnRlciBbVGltZS5TcGFuLnJhbmRvbWl6ZVxuICAgICAgfnBlcmNlbnQ6KFBlcmNlbnQub2ZfbXVsdCAwLjMpIChyZXRyeV9kZWxheSAoKSldLiBUaGUgZGVmYXVsdCBmb3IgW3JldHJ5X2RlbGF5XSBpc1xuICAgICAgW2NvbnN0IChzZWMgMTAuKV0uIE5vdGUgdGhhdCB3aGF0IHRoaXMgcmV0cnkgZGVsYXkgYWN0dWFsbHkgdGhyb3R0bGVzIGlzIHRoZSBkZWxheVxuICAgICAgYmV0d2VlbiB0d28gY29ubmVjdGlvbiBhdHRlbXB0cywgc28gd2hlbiBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBkaWVzLCBjb25uZWN0aW9uIGlzXG4gICAgICB1c3VhbGx5IGltbWVkaWF0ZWx5IHJldHJpZWQsIGFuZCBpZiB0aGF0IGZhaWxlZCwgd2FpdCBmb3IgYW5vdGhlciByZXRyeSBkZWxheSBhbmRcbiAgICAgIHJldHJ5LlxuXG4gICAgICBUaGUgW3JhbmRvbV9zdGF0ZV0gYW5kIFt0aW1lX3NvdXJjZV0gYXJndW1lbnRzIGFyZSB0aGVyZSB0byBtYWtlIHBlcnNpc3RlbnRcbiAgICAgIGNvbm5lY3Rpb24gY29kZSBtb3JlIGRldGVybWluaXN0aWNhbGx5IHRlc3RhYmxlLiBUaGV5IGRlZmF1bHQgdG9cbiAgICAgIFtgU3RhdGUgUmFuZG9tLlN0YXRlLmRlZmF1bHRdIGFuZCBbVGltZV9zb3VyY2Uud2FsbF9jbG9jayAoKV0sIHJlc3BlY3RpdmVseS5cbiAgICAgIElmIHJhbmRvbV9zdGF0ZSBpcyBzZXQgdG8gW2BOb25fcmFuZG9tXSwgcmV0cnlfZGVsYXkgd2lsbCBiZSB1c2VkIGRpcmVjdGx5LlxuICAqKVxuICB2YWwgY3JlYXRlXG4gICAgOiAgc2VydmVyX25hbWU6c3RyaW5nXG4gICAgLT4gP29uX2V2ZW50OignYWRkcmVzcyBFdmVudC50IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiA/cmV0cnlfZGVsYXk6KHVuaXQgLT4gVGltZV9ucy5TcGFuLnQpXG4gICAgLT4gP3JhbmRvbV9zdGF0ZTpbIGBOb25fcmFuZG9tIHwgYFN0YXRlIG9mIFJhbmRvbS5TdGF0ZS50IF1cbiAgICAtPiA/dGltZV9zb3VyY2U6VGltZV9zb3VyY2UudFxuICAgIC0+IGNvbm5lY3Q6KCdhZGRyZXNzIC0+IGNvbm4gT3JfZXJyb3IudCBEZWZlcnJlZC50KVxuICAgIC0+IGFkZHJlc3M6KG1vZHVsZSBBZGRyZXNzIHdpdGggdHlwZSB0ID0gJ2FkZHJlc3MpXG4gICAgLT4gKHVuaXQgLT4gJ2FkZHJlc3MgT3JfZXJyb3IudCBEZWZlcnJlZC50KVxuICAgIC0+IHRcblxuICAoKiogW2Nvbm5lY3RlZF0gcmV0dXJucyB0aGUgZmlyc3QgYXZhaWxhYmxlIGNvbm5lY3Rpb24gZnJvbSB0aGUgdGltZSBpdCBpcyBjYWxsZWQuIFdoZW5cbiAgICAgIGN1cnJlbnRseSBjb25uZWN0ZWQsIHRoZSByZXR1cm5lZCBkZWZlcnJlZCBpcyBhbHJlYWR5IGRldGVybWluZWQuIElmIFtjbG9zZWRdIGhhc1xuICAgICAgYmVlbiBjYWxsZWQsIHRoZW4gdGhlIHJldHVybmVkIGRlZmVycmVkIGlzIG5ldmVyIGRldGVybWluZWQuICopXG4gIHZhbCBjb25uZWN0ZWQgOiB0IC0+IGNvbm4gRGVmZXJyZWQudFxuXG4gICgqKiBbY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0XSBpcyBpbW1lZGlhdGVseSBkZXRlcm1pbmVkIGFzIFtPayBfXSBpZiBbdF0gaXNcbiAgICAgIGFscmVhZHkgY29ubmVjdGVkLiBPdGhlcndpc2UgaXQgYmVjb21lcyBkZXRlcm1pbmVkIHRoZSBuZXh0IHRpbWUgW3RdIGJlY29tZXNcbiAgICAgIGNvbm5lY3RlZCBvciBmYWlscyB0byBjb25uZWN0IG9yIHdoZW4gW3RdIGlzIGNsb3NlZC4gKilcbiAgdmFsIGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCA6IHQgLT4gY29ubiBPcl9lcnJvci50IERlZmVycmVkLnRcblxuICAoKiogVGhlIGN1cnJlbnQgY29ubmVjdGlvbiwgaWYgYW55LiAqKVxuICB2YWwgY3VycmVudF9jb25uZWN0aW9uIDogdCAtPiBjb25uIG9wdGlvblxuXG4gIHZhbCBzZXJ2ZXJfbmFtZSA6IHQgLT4gc3RyaW5nXG5cbiAgKCoqIFtjbG9zZSB0XSBjbG9zZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBhbmQgc3RvcHMgaXQgZnJvbSB0cnlpbmcgdG8gcmVjb25uZWN0LiBBZnRlclxuICAgICAgdGhlIGRlZmVycmVkIGl0IHJldHVybnMgYmVjb21lcyBkZXRlcm1pbmVkLCB0aGUgbGFzdCBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCBhbmRcbiAgICAgIG5vIG90aGVycyB3aWxsIGJlIGF0dGVtcHRlZC5cblxuICAgICAgTm90ZTogbm8gW2Nsb3NlXSBjYWxscyBhcmUgZXZlciBnZW5lcmF0ZWQgaW50ZXJuYWxseSBpbiByZXNwb25zZSB0byB0aGUgY29ubmVjdGlvblxuICAgICAgYmVpbmcgY2xvc2VkIGJ5IHRoZSBvdGhlciBzaWRlLlxuICAqKVxuICBpbmNsdWRlIENsb3NhYmxlIHdpdGggdHlwZSB0IDo9IHRcblxuICAoKiogW2Nsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCB0XSBjYXVzZXMgdGhlIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0byBub3RcbiAgICAgIHJlY29ubmVjdCBpZiB0aGUgY3VycmVudCBjb25uZWN0aW9uIGNsb3NlcyBvciBpZiBpdCBpcyBub3QgY3VycmVudGx5IGNvbm5lY3RlZC4gSXRcbiAgICAgIGRvZXMgbm90IGNsb3NlIGFueSBhY3RpdmUgY29ubmVjdGlvbi4gKilcbiAgdmFsIGNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCA6IHQgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFBlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWwgPSBzaWdcbiAgbW9kdWxlIHR5cGUgQWRkcmVzcyA9IEFkZHJlc3NcbiAgbW9kdWxlIHR5cGUgQ2xvc2FibGUgPSBDbG9zYWJsZVxuICBtb2R1bGUgdHlwZSBTID0gU1xuXG4gIG1vZHVsZSBNYWtlIChDb25uIDogQ2xvc2FibGUpIDogUyB3aXRoIHR5cGUgY29ubiA9IENvbm4udFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBBc3luY19rZXJuZWxcbm9wZW4hIEFzeW5jX2tlcm5lbF9yZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXG5pbmNsdWRlIFBlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWxfaW50ZlxuXG5tb2R1bGUgTWFrZSAoQ29ubiA6IENsb3NhYmxlKSA9IHN0cnVjdFxuICBtb2R1bGUgQ29ubiA9IHN0cnVjdFxuICAgIGluY2x1ZGUgQ29ublxuXG4gICAgbGV0IHNleHBfb2ZfdCAoXyA6IHQpIDogU2V4cC50ID0gQXRvbSBcIjxDb25uLnQ+XCJcbiAgZW5kXG5cbiAgdHlwZSBjb25uID0gQ29ubi50XG5cbiAgbW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgIHwgQXR0ZW1wdGluZ190b19jb25uZWN0XG4gICAgICB8IE9idGFpbmVkX2FkZHJlc3Mgb2YgJ2FkZHJlc3NcbiAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3Qgb2YgRXJyb3IudFxuICAgICAgfCBDb25uZWN0ZWQgb2YgKGNvbm5bQHNleHAub3BhcXVlXSlcbiAgICAgIHwgRGlzY29ubmVjdGVkXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHR5cGUgJ2FkZHJlc3MgZXZlbnQgPSAnYWRkcmVzcyB0XG5cbiAgICBtb2R1bGUgSGFuZGxlciA9IHN0cnVjdFxuICAgICAgdHlwZSAnYWRkcmVzcyB0ID1cbiAgICAgICAgeyBzZXJ2ZXJfbmFtZSA6IHN0cmluZ1xuICAgICAgICA7IG9uX2V2ZW50IDogJ2FkZHJlc3MgZXZlbnQgLT4gdW5pdCBEZWZlcnJlZC50XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICBsZXQgbG9nX2xldmVsID0gZnVuY3Rpb25cbiAgICAgIHwgQXR0ZW1wdGluZ190b19jb25uZWN0IHwgQ29ubmVjdGVkIF8gfCBEaXNjb25uZWN0ZWQgfCBPYnRhaW5lZF9hZGRyZXNzIF8gLT4gYEluZm9cbiAgICAgIHwgRmFpbGVkX3RvX2Nvbm5lY3QgXyAtPiBgRXJyb3JcbiAgICA7O1xuXG4gICAgbGV0IGhhbmRsZSB0IHsgSGFuZGxlci5zZXJ2ZXJfbmFtZSA9IF87IG9uX2V2ZW50IH0gPSBvbl9ldmVudCB0XG4gIGVuZFxuXG4gICgqIEEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRoYXQgaXMgcG9seW1vcnBoaWMgaW4gdGhlIGFkZHJlc3MgdHlwZS4gIFdlIGhpZGUgYXdheSB0aGlzXG4gICAgIHR5cGUgbGF0ZXIgc2luY2UgaXQgb25seSBhcHBlYXJzIGluIHRoZSB0eXBlIG9mIFtjcmVhdGVdLiAqKVxuICBtb2R1bGUgUG9seSA9IHN0cnVjdFxuICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICB7IGdldF9hZGRyZXNzIDogdW5pdCAtPiAnYWRkcmVzcyBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICAgIDsgY29ubmVjdCA6ICdhZGRyZXNzIC0+IENvbm4udCBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICAgIDsgcmV0cnlfZGVsYXkgOiB1bml0IC0+IHVuaXQgRGVmZXJyZWQudFxuICAgICAgOyBtdXRhYmxlIGNvbm4gOiBbIGBPayBvZiBDb25uLnQgfCBgQ2xvc2Vfc3RhcnRlZCBdIEl2YXIudFxuICAgICAgOyBtdXRhYmxlIG5leHRfY29ubmVjdF9yZXN1bHQgOiBDb25uLnQgT3JfZXJyb3IudCBJdmFyLnRcbiAgICAgIDsgZXZlbnRfaGFuZGxlciA6ICdhZGRyZXNzIEV2ZW50LkhhbmRsZXIudFxuICAgICAgOyBjbG9zZV9zdGFydGVkIDogdW5pdCBJdmFyLnRcbiAgICAgIDsgY2xvc2VfZmluaXNoZWQgOiB1bml0IEl2YXIudFxuICAgICAgOyBkb24ndF9yZWNvbm5lY3QgOiB1bml0IEl2YXIudFxuICAgICAgOyBhZGRyZXNzX2VxdWFsIDogJ2FkZHJlc3MgLT4gJ2FkZHJlc3MgLT4gYm9vbFxuICAgICAgOyBzZXhwX29mX2FkZHJlc3MgOiAnYWRkcmVzcyAtPiBTZXhwLnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgc2VydmVyX25hbWUgdCA9IHQuZXZlbnRfaGFuZGxlci5zZXJ2ZXJfbmFtZVxuICAgIGxldCBoYW5kbGVfZXZlbnQgdCBldmVudCA9IEV2ZW50LmhhbmRsZSBldmVudCB0LmV2ZW50X2hhbmRsZXJcblxuICAgICgqIFRoaXMgZnVuY3Rpb24gZm9jdXNlcyBpbiBvbiB0aGUgdGhlIGVycm9yIGl0c2VsZiwgZGlzY2FyZGluZyBpbmZvcm1hdGlvbiBhYm91dCB3aGljaFxuICAgICAgIG1vbml0b3IgY2F1Z2h0IHRoZSBlcnJvciwgaWYgYW55LlxuXG4gICAgICAgSWYgd2UgZG9uJ3QgZG8gdGhpcywgd2Ugc29tZXRpbWVzIGVuZCB1cCB3aXRoIG5vaXN5IGxvZ3Mgd2hpY2ggcmVwb3J0IHRoZSBzYW1lIGVycm9yXG4gICAgICAgYWdhaW4gYW5kIGFnYWluLCBkaWZmZXJpbmcgb25seSBhcyB0byB3aGF0IG1vbml0b3IgY2F1Z2h0IHRoZW0uICopXG4gICAgbGV0IHNhbWVfZXJyb3IgZTEgZTIgPVxuICAgICAgbGV0IHRvX3NleHAgZSA9IEV4bi5zZXhwX29mX3QgKE1vbml0b3IuZXh0cmFjdF9leG4gKEVycm9yLnRvX2V4biBlKSkgaW5cbiAgICAgIFNleHAuZXF1YWwgKHRvX3NleHAgZTEpICh0b19zZXhwIGUyKVxuICAgIDs7XG5cbiAgICAoKiBDb250aW51ZSB0cnlpbmcgdG8gY29ubmVjdCB1bnRpbCB3ZSBhcmUgYWJsZSB0byBkbyBzbywgaW4gd2hpY2ggY2FzZSB3ZSByZXR1cm4gYm90aFxuICAgICAgIHRoZSBuZXcgY29ubmVjdGlvbiBhbmQgYSBkZWZlcnJlZCB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgb25jZSB3ZSBhcmUgcmVhZHkgZm9yXG4gICAgICAgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQuICopXG4gICAgbGV0IHRyeV9jb25uZWN0aW5nX3VudGlsX3N1Y2Nlc3NmdWwgdCA9XG4gICAgICAoKiBXZSB0YWtlIGNhcmUgbm90IHRvIHNwYW0gbG9ncyB3aXRoIHRoZSBzYW1lIG1lc3NhZ2Ugb3ZlciBhbmQgb3ZlciBieSBjb21wYXJpbmdcbiAgICAgICAgIGVhY2ggbG9nIG1lc3NhZ2UgdGhlIHRoZSBwcmV2aW91cyBvbmUgb2YgdGhlIHNhbWUgdHlwZS4gKilcbiAgICAgIGxldCBwcmV2aW91c19hZGRyZXNzID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCBwcmV2aW91c19lcnJvciA9IHJlZiBOb25lIGluXG4gICAgICBsZXQgY29ubmVjdCAoKSA9XG4gICAgICAgIHQuZ2V0X2FkZHJlc3MgKClcbiAgICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgRXJyb3IgZSAtPiByZXR1cm4gKEVycm9yIGUpXG4gICAgICAgIHwgT2sgYWRkciAtPlxuICAgICAgICAgIGxldCBzYW1lX2FzX3ByZXZpb3VzX2FkZHJlc3MgPVxuICAgICAgICAgICAgbWF0Y2ggIXByZXZpb3VzX2FkZHJlc3Mgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgICAgICB8IFNvbWUgcHJldmlvdXNfYWRkcmVzcyAtPiB0LmFkZHJlc3NfZXF1YWwgYWRkciBwcmV2aW91c19hZGRyZXNzXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmV2aW91c19hZGRyZXNzIDo9IFNvbWUgYWRkcjtcbiAgICAgICAgICAoaWYgc2FtZV9hc19wcmV2aW91c19hZGRyZXNzXG4gICAgICAgICAgIHRoZW4gRGVmZXJyZWQudW5pdFxuICAgICAgICAgICBlbHNlIGhhbmRsZV9ldmVudCB0IChPYnRhaW5lZF9hZGRyZXNzIGFkZHIpKVxuICAgICAgICAgID4+PSBmdW4gKCkgLT4gdC5jb25uZWN0IGFkZHJcbiAgICAgIGluXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgIHRoZW4gcmV0dXJuIGBDbG9zZV9zdGFydGVkXG4gICAgICAgIGVsc2UgaWYgSXZhci5pc19mdWxsIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgIHRoZW4gcmV0dXJuIGBEb24ndF9yZWNvbm5lY3RcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmcgPSB0LnJldHJ5X2RlbGF5ICgpIGluXG4gICAgICAgICAgbGV0JWJpbmQgY29ubmVjdF9yZXN1bHQgPSBjb25uZWN0ICgpIGluXG4gICAgICAgICAgSXZhci5maWxsIHQubmV4dF9jb25uZWN0X3Jlc3VsdCBjb25uZWN0X3Jlc3VsdDtcbiAgICAgICAgICB0Lm5leHRfY29ubmVjdF9yZXN1bHQgPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgICAgICAgbWF0Y2ggY29ubmVjdF9yZXN1bHQgd2l0aFxuICAgICAgICAgIHwgT2sgY29ubiAtPiByZXR1cm4gKGBPayAoY29ubiwgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZykpXG4gICAgICAgICAgfCBFcnJvciBlcnIgLT5cbiAgICAgICAgICAgIGxldCBzYW1lX2FzX3ByZXZpb3VzX2Vycm9yID1cbiAgICAgICAgICAgICAgbWF0Y2ggIXByZXZpb3VzX2Vycm9yIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgICAgICAgIHwgU29tZSBwcmV2aW91c19lcnIgLT4gc2FtZV9lcnJvciBlcnIgcHJldmlvdXNfZXJyXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgcHJldmlvdXNfZXJyb3IgOj0gU29tZSBlcnI7XG4gICAgICAgICAgICAoaWYgc2FtZV9hc19wcmV2aW91c19lcnJvclxuICAgICAgICAgICAgIHRoZW4gRGVmZXJyZWQudW5pdFxuICAgICAgICAgICAgIGVsc2UgaGFuZGxlX2V2ZW50IHQgKEZhaWxlZF90b19jb25uZWN0IGVycikpXG4gICAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgICBEZWZlcnJlZC5hbnlcbiAgICAgICAgICAgICAgWyByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA+Pj0gZnVuICgpIC0+IGxvb3AgKCkpXG4gICAgICBpblxuICAgICAgbG9vcCAoKVxuICAgIDs7XG5cbiAgICBsZXQgYWJvcnRfcmVjb25uZWN0aW5nX3dpdGhfbm9fYWN0aXZlX2Nvbm5lY3Rpb24gdCA9XG4gICAgICBJdmFyLmZpbGwgdC5jbG9zZV9zdGFydGVkICgpO1xuICAgICAgSXZhci5maWxsIHQuY2xvc2VfZmluaXNoZWQgKCk7XG4gICAgICBJdmFyLmZpbGwgdC5jb25uIGBDbG9zZV9zdGFydGVkXG4gICAgOztcblxuICAgIGxldCBjcmVhdGVcbiAgICAgICAgICAodHlwZSBhZGRyZXNzKVxuICAgICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICAgID8ob25fZXZlbnQgPSBmdW4gXyAtPiBEZWZlcnJlZC51bml0KVxuICAgICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICAgID8ocmFuZG9tX3N0YXRlID0gYFN0YXRlIFJhbmRvbS5TdGF0ZS5kZWZhdWx0KVxuICAgICAgICAgID8odGltZV9zb3VyY2UgPSBUaW1lX3NvdXJjZS53YWxsX2Nsb2NrICgpKVxuICAgICAgICAgIH5jb25uZWN0XG4gICAgICAgICAgfmFkZHJlc3M6KG1vZHVsZSBBZGRyZXNzIDogQWRkcmVzcyB3aXRoIHR5cGUgdCA9IGFkZHJlc3MpXG4gICAgICAgICAgZ2V0X2FkZHJlc3NcbiAgICAgID1cbiAgICAgIGxldCBldmVudF9oYW5kbGVyID0geyBFdmVudC5IYW5kbGVyLnNlcnZlcl9uYW1lOyBvbl9ldmVudCB9IGluXG4gICAgICBsZXQgZGVmYXVsdF9yZXRyeV9kZWxheSA9XG4gICAgICAgIEZuLmNvbnN0IChUaW1lX25zLlNwYW4ub2Zfc2VjIChpZiBhbV9ydW5uaW5nX3Rlc3QgdGhlbiAwLjEgZWxzZSAxMC4pKVxuICAgICAgaW5cbiAgICAgIGxldCBub25fcmFuZG9taXplZF9kZWxheSA9IE9wdGlvbi52YWx1ZSByZXRyeV9kZWxheSB+ZGVmYXVsdDpkZWZhdWx0X3JldHJ5X2RlbGF5IGluXG4gICAgICBsZXQgcmV0cnlfZGVsYXlfc3BhbiA9XG4gICAgICAgIG1hdGNoIHJhbmRvbV9zdGF0ZSB3aXRoXG4gICAgICAgIHwgYE5vbl9yYW5kb20gLT4gbm9uX3JhbmRvbWl6ZWRfZGVsYXlcbiAgICAgICAgfCBgU3RhdGUgcmFuZG9tX3N0YXRlIC0+XG4gICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG5vbl9yYW5kb21pemVkX2RlbGF5ICgpIGluXG4gICAgICAgICAgICBsZXQgc3BhbiA9IFRpbWVfbnMuU3Bhbi50b19zZWMgc3BhbiBpblxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gUmFuZG9tLlN0YXRlLmZsb2F0IHJhbmRvbV9zdGF0ZSAoc3BhbiAqLiAwLjMpIGluXG4gICAgICAgICAgICBsZXQgd2FpdCA9XG4gICAgICAgICAgICAgIGlmIFJhbmRvbS5TdGF0ZS5ib29sIHJhbmRvbV9zdGF0ZVxuICAgICAgICAgICAgICB0aGVuIHNwYW4gKy4gZGlzdGFuY2VcbiAgICAgICAgICAgICAgZWxzZSBzcGFuIC0uIGRpc3RhbmNlXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgVGltZV9ucy5TcGFuLm9mX3NlYyB3YWl0XG4gICAgICBpblxuICAgICAgbGV0IHJldHJ5X2RlbGF5ICgpID0gVGltZV9zb3VyY2UuYWZ0ZXIgdGltZV9zb3VyY2UgKHJldHJ5X2RlbGF5X3NwYW4gKCkpIGluXG4gICAgICBsZXQgdCA9XG4gICAgICAgIHsgZXZlbnRfaGFuZGxlclxuICAgICAgICA7IGdldF9hZGRyZXNzXG4gICAgICAgIDsgY29ubmVjdFxuICAgICAgICA7IG5leHRfY29ubmVjdF9yZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IHJldHJ5X2RlbGF5XG4gICAgICAgIDsgY29ubiA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgY2xvc2Vfc3RhcnRlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgY2xvc2VfZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGRvbid0X3JlY29ubmVjdCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICAgIDsgYWRkcmVzc19lcXVhbCA9IEFkZHJlc3MuZXF1YWxcbiAgICAgICAgOyBzZXhwX29mX2FkZHJlc3MgPSBBZGRyZXNzLnNleHBfb2ZfdFxuICAgICAgICB9XG4gICAgICBpblxuICAgICAgKCogdGhpcyBsb29wIGZpbmlzaGVzIG9uY2UgW2Nsb3NlIHRdIGhhcyBiZWVuIGNhbGxlZCwgaW4gd2hpY2ggY2FzZSBpdCBtYWtlcyBzdXJlIHRvXG4gICAgICAgICBsZWF2ZSBbdC5jb25uXSBmaWxsZWQgd2l0aCBbYENsb3NlX3N0YXJ0ZWRdLiAqKVxuICAgICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgIEBAIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAoKSAoZnVuICgpIC0+XG4gICAgICAgIGhhbmRsZV9ldmVudCB0IEF0dGVtcHRpbmdfdG9fY29ubmVjdFxuICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgIHRyeV9jb25uZWN0aW5nX3VudGlsX3N1Y2Nlc3NmdWwgdFxuICAgICAgICA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPlxuICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWQ7XG4gICAgICAgICAgcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYERvbid0X3JlY29ubmVjdCAtPlxuICAgICAgICAgIGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQ7XG4gICAgICAgICAgcmV0dXJuIChgRmluaXNoZWQgKCkpXG4gICAgICAgIHwgYE9rIChjb25uLCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nKSAtPlxuICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gKGBPayBjb25uKTtcbiAgICAgICAgICBoYW5kbGVfZXZlbnQgdCAoQ29ubmVjdGVkIGNvbm4pXG4gICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgIENvbm4uY2xvc2VfZmluaXNoZWQgY29ublxuICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICB0LmNvbm4gPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgICAgICAgaGFuZGxlX2V2ZW50IHQgRGlzY29ubmVjdGVkXG4gICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICgqIHdhaXRzIHVudGlsIFtyZXRyeV9kZWxheSAoKV0gdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSB0aW1lIGp1c3QgYmVmb3JlIHdlIGxhc3RcbiAgICAgICAgICAgICB0cmllZCB0byBjb25uZWN0IHJhdGhlciB0aGFuIHRoZSB0aW1lIHdlIG5vdGljZWQgYmVpbmcgZGlzY29ubmVjdGVkLCBzbyB0aGF0IGlmXG4gICAgICAgICAgICAgYSBsb25nLWxpdmVkIGNvbm5lY3Rpb24gZGllcywgd2Ugd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCBpbW1lZGlhdGVseS4gKilcbiAgICAgICAgICBsZXQlbWFwICgpID1cbiAgICAgICAgICAgIERlZmVycmVkLmFueVxuICAgICAgICAgICAgICBbIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIEl2YXIuZmlsbCB0LmNvbm4gYENsb3NlX3N0YXJ0ZWQ7XG4gICAgICAgICAgICBgRmluaXNoZWQgKCkpXG4gICAgICAgICAgZWxzZSBpZiBJdmFyLmlzX2Z1bGwgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQ7XG4gICAgICAgICAgICBgRmluaXNoZWQgKCkpXG4gICAgICAgICAgZWxzZSBgUmVwZWF0ICgpKTtcbiAgICAgIHRcbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZCB0ID1cbiAgICAgICgqIFRha2UgY2FyZSBub3QgdG8gcmV0dXJuIGEgY29ubmVjdGlvbiB0aGF0IGlzIGtub3duIHRvIGJlIGNsb3NlZCBhdCB0aGUgdGltZVxuICAgICAgICAgW2Nvbm5lY3RlZF0gd2FzIGNhbGxlZC4gIFRoaXMgY291bGQgaGFwcGVuIGluIGNsaWVudCBjb2RlIHRoYXQgYmVoYXZlcyBsaWtlXG4gICAgICAgICB7W1xuICAgICAgICAgICBQZXJzaXN0ZW50X2Nvbm5lY3Rpb24uUnBjLmNvbm5lY3RlZCB0XG4gICAgICAgICAgID4+PSBmdW4gYzEgLT5cbiAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgUnBjLkNvbm5lY3Rpb24uY2xvc2VfZmluaXNoZWQgYzFcbiAgICAgICAgICAgKCogYXQgdGhpcyBwb2ludCB3ZSBhcmUgaW4gYSByYWNlIHdpdGggdGhlIHNhbWUgY2FsbCBpbnNpZGVcbiAgICAgICAgICAgICAgcGVyc2lzdGVudF9jbGllbnQubWwgKilcbiAgICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICBQZXJzaXN0ZW50X2Nvbm5lY3Rpb24uUnBjLmNvbm5lY3RlZCB0XG4gICAgICAgICAgICgqIGRlcGVuZGluZyBvbiBob3cgdGhlIHJhY2UgdHVybnMgb3V0LCB3ZSBkb24ndCB3YW50IHRvIGdldCBhIGNsb3NlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgIGhlcmUgKilcbiAgICAgICAgICAgPj49IGZ1biBjMiAtPlxuICAgICAgICAgICAuLi5cbiAgICAgICAgIF19XG4gICAgICAgICBUaGlzIGRvZXNuJ3QgcmVtb3ZlIHRoZSByYWNlIGNvbmRpdGlvbiwgYnV0IGl0IG1ha2VzIGl0IGxlc3MgbGlrZWx5IHRvIGhhcHBlbi5cbiAgICAgICopXG4gICAgICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgICAgICBsZXQgZCA9IEl2YXIucmVhZCB0LmNvbm4gaW5cbiAgICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayBkIHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgZFxuICAgICAgICAgID4+PSAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgYENsb3NlX3N0YXJ0ZWQgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICAgICAgICAgIHwgYE9rIGNvbm4gLT4gcmV0dXJuIGNvbm4pXG4gICAgICAgIHwgU29tZSBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgICAgICB8IFNvbWUgKGBPayBjb25uKSAtPlxuICAgICAgICAgIGlmIENvbm4uaXNfY2xvc2VkIGNvbm5cbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoKiBnaXZlIHRoZSByZWNvbm5lY3Rpb24gbG9vcCBhIGNoYW5jZSB0byBvdmVyd3JpdGUgdGhlIGl2YXIgKilcbiAgICAgICAgICAgIENvbm4uY2xvc2VfZmluaXNoZWQgY29ubiA+Pj0gbG9vcFxuICAgICAgICAgIGVsc2UgcmV0dXJuIGNvbm5cbiAgICAgIGluXG4gICAgICBsb29wICgpXG4gICAgOztcblxuICAgIGxldCBjdXJyZW50X2Nvbm5lY3Rpb24gdCA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgdC5jb25uKSB3aXRoXG4gICAgICB8IE5vbmUgfCBTb21lIGBDbG9zZV9zdGFydGVkIC0+IE5vbmVcbiAgICAgIHwgU29tZSAoYE9rIGNvbm4pIC0+IFNvbWUgY29ublxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VfZmluaXNoZWQgdCA9IEl2YXIucmVhZCB0LmNsb3NlX2ZpbmlzaGVkXG4gICAgbGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuXG4gICAgbGV0IGNsb3NlIHQgPVxuICAgICAgaWYgSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgdGhlblxuICAgICAgICAoKiBBbm90aGVyIGNhbGwgdG8gY2xvc2UgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4gIFdhaXQgZm9yIGl0IHRvIGZpbmlzaC4gKilcbiAgICAgICAgY2xvc2VfZmluaXNoZWQgdFxuICAgICAgZWxzZSAoXG4gICAgICAgIEl2YXIuZmlsbCB0LmNsb3NlX3N0YXJ0ZWQgKCk7XG4gICAgICAgIEl2YXIucmVhZCB0LmNvbm5cbiAgICAgICAgPj49IGZ1biBjb25uX29wdCAtPlxuICAgICAgICAobWF0Y2ggY29ubl9vcHQgd2l0aFxuICAgICAgICAgfCBgQ2xvc2Vfc3RhcnRlZCAtPiBEZWZlcnJlZC51bml0XG4gICAgICAgICB8IGBPayBjb25uIC0+IENvbm4uY2xvc2UgY29ubilcbiAgICAgICAgPj58IGZ1biAoKSAtPiBJdmFyLmZpbGwgdC5jbG9zZV9maW5pc2hlZCAoKSlcbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZCA9XG4gICAgICBPcl9lcnJvci5lcnJvcl9zIFslbWVzc2FnZSBcIlBlcnNpc3RlbnQgY29ubmVjdGlvbiBjbG9zZWRcIl1cbiAgICA7O1xuXG4gICAgbGV0IGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCB0ID1cbiAgICAgIGlmIGlzX2Nsb3NlZCB0XG4gICAgICB0aGVuIHJldHVybiBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3RfY29ubmVjdGlvbl9jbG9zZWRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBjdXJyZW50X2Nvbm5lY3Rpb24gdCB3aXRoXG4gICAgICAgIHwgU29tZSB4IHdoZW4gbm90IChDb25uLmlzX2Nsb3NlZCB4KSAtPiByZXR1cm4gKE9rIHgpXG4gICAgICAgIHwgU29tZSAoXyA6IENvbm4udCkgfCBOb25lIC0+XG4gICAgICAgICAgRGVmZXJyZWQuY2hvb3NlXG4gICAgICAgICAgICBbIGNob2ljZSAoSXZhci5yZWFkIHQuY2xvc2Vfc3RhcnRlZCkgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdF9jb25uZWN0aW9uX2Nsb3NlZClcbiAgICAgICAgICAgIDsgY2hvaWNlIChJdmFyLnJlYWQgdC5uZXh0X2Nvbm5lY3RfcmVzdWx0KSBGbi5pZFxuICAgICAgICAgICAgXSlcbiAgICA7O1xuXG4gICAgbGV0IGNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCB0ID1cbiAgICAgIEl2YXIuZmlsbF9pZl9lbXB0eSB0LmRvbid0X3JlY29ubmVjdCAoKVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgdCA9IFQgOiAnYWRkcmVzcyBQb2x5LnQgLT4gdCBbQEB1bmJveGVkXVxuXG4gIGxldCBzZXhwX29mX3QgKFQgdCkgPSBQb2x5LnNleHBfb2ZfdCB0LnNleHBfb2ZfYWRkcmVzcyB0XG5cbiAgbGV0IGNsb3NlX3doZW5fY3VycmVudF9jb25uZWN0aW9uX2lzX2Nsb3NlZCAoVCB0KSA9XG4gICAgUG9seS5jbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl9pc19jbG9zZWQgdFxuICA7O1xuXG4gIGxldCBjbG9zZV9maW5pc2hlZCAoVCB0KSA9IFBvbHkuY2xvc2VfZmluaXNoZWQgdFxuICBsZXQgaXNfY2xvc2VkIChUIHQpID0gUG9seS5pc19jbG9zZWQgdFxuICBsZXQgY2xvc2UgKFQgdCkgPSBQb2x5LmNsb3NlIHRcbiAgbGV0IHNlcnZlcl9uYW1lIChUIHQpID0gUG9seS5zZXJ2ZXJfbmFtZSB0XG4gIGxldCBjdXJyZW50X2Nvbm5lY3Rpb24gKFQgdCkgPSBQb2x5LmN1cnJlbnRfY29ubmVjdGlvbiB0XG4gIGxldCBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QgKFQgdCkgPSBQb2x5LmNvbm5lY3RlZF9vcl9mYWlsZWRfdG9fY29ubmVjdCB0XG4gIGxldCBjb25uZWN0ZWQgKFQgdCkgPSBQb2x5LmNvbm5lY3RlZCB0XG5cbiAgbGV0IGNyZWF0ZVxuICAgICAgICB+c2VydmVyX25hbWVcbiAgICAgICAgP29uX2V2ZW50XG4gICAgICAgID9yZXRyeV9kZWxheVxuICAgICAgICA/cmFuZG9tX3N0YXRlXG4gICAgICAgID90aW1lX3NvdXJjZVxuICAgICAgICB+Y29ubmVjdFxuICAgICAgICB+YWRkcmVzc1xuICAgICAgICBnZXRfYWRkcmVzc1xuICAgID1cbiAgICBUXG4gICAgICAoUG9seS5jcmVhdGVcbiAgICAgICAgIH5zZXJ2ZXJfbmFtZVxuICAgICAgICAgP29uX2V2ZW50XG4gICAgICAgICA/cmV0cnlfZGVsYXlcbiAgICAgICAgID9yYW5kb21fc3RhdGVcbiAgICAgICAgID90aW1lX3NvdXJjZVxuICAgICAgICAgfmNvbm5lY3RcbiAgICAgICAgIH5hZGRyZXNzXG4gICAgICAgICBnZXRfYWRkcmVzcylcbiAgOztcbmVuZFxuIl19
