// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_equal=runtime.caml_bytes_equal,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_greaterequal=runtime.caml_bytes_greaterequal,
     caml_bytes_lessequal=runtime.caml_bytes_lessequal,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_classify_float=runtime.caml_classify_float,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_bits_of_float=runtime.caml_int64_bits_of_float,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_div=runtime.caml_int64_div,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_mod=runtime.caml_int64_mod,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_float=runtime.caml_int64_of_float,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_shift_right=runtime.caml_int64_shift_right,
     caml_int64_shift_right_unsigne=runtime.caml_int64_shift_right_unsigned,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_int64_xor=runtime.caml_int64_xor,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_log10_float=runtime.caml_log10_float,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_notequal=runtime.caml_notequal,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_greaterequal=runtime.caml_string_greaterequal,
     caml_string_lessequal=runtime.caml_string_lessequal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     description=caml_string_of_jsbytes("internalhash"),
     cst_unknown_word_size=caml_string_of_jsbytes("unknown word size"),
     cst_pp=caml_string_of_jsbytes(".pp"),
     cst_Base_Exn_Finally=caml_string_of_jsbytes("Base__Exn.Finally"),
     cst_Base_Exn_Reraised=caml_string_of_jsbytes("Base__Exn.Reraised"),
     cst_Base_Exn_Sexp=caml_string_of_jsbytes("Base__Exn.Sexp"),
     module_name=caml_string_of_jsbytes("Base.Exn"),
     cst_use_of_return_from_a_with_=
      caml_string_of_jsbytes
       ("use of [return] from a [with_return] that already returned"),
     cst_Return=caml_string_of_jsbytes("Return"),
     cst_Second$1=caml_string_of_jsbytes("Second"),
     cst_First$1=caml_string_of_jsbytes("First"),
     cst_First=caml_string_of_jsbytes("First"),
     cst_Second=caml_string_of_jsbytes("Second"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_second=caml_string_of_jsbytes("second"),
     cst_First$0=caml_string_of_jsbytes("First"),
     cst_Second$0=caml_string_of_jsbytes("Second"),
     cst_first$0=caml_string_of_jsbytes("first"),
     cst_second$0=caml_string_of_jsbytes("second"),
     error_source_011=caml_string_of_jsbytes("either0.ml.t"),
     cst$0=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes(""),
     cst$1=caml_string_of_jsbytes(":"),
     cst$2=caml_string_of_jsbytes(":"),
     cst_Error$1=caml_string_of_jsbytes("Error"),
     cst_Ok$1=caml_string_of_jsbytes("Ok"),
     cst_Error=caml_string_of_jsbytes("Error"),
     cst_Ok=caml_string_of_jsbytes("Ok"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_ok=caml_string_of_jsbytes("ok"),
     cst_Error$0=caml_string_of_jsbytes("Error"),
     cst_Ok$0=caml_string_of_jsbytes("Ok"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_ok$0=caml_string_of_jsbytes("ok"),
     error_source_005=caml_string_of_jsbytes("result.ml.t"),
     cst_unforced_lazy=caml_string_of_jsbytes("<unforced lazy>"),
     cst_float=caml_string_of_jsbytes("float"),
     cst_int64=caml_string_of_jsbytes("int64"),
     cst_nativeint=caml_string_of_jsbytes("nativeint"),
     cst_int32=caml_string_of_jsbytes("int32"),
     cst_int=caml_string_of_jsbytes("int"),
     cst_initializing_Random_with_a=
      caml_string_of_jsbytes
       ("initializing Random with a nondeterministic seed is forbidden in inline tests"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Greater=caml_string_of_jsbytes("Greater"),
     cst_Less=caml_string_of_jsbytes("Less"),
     cst_equal=caml_string_of_jsbytes("equal"),
     cst_greater=caml_string_of_jsbytes("greater"),
     cst_less=caml_string_of_jsbytes("less"),
     cst_Equal$0=caml_string_of_jsbytes("Equal"),
     cst_Greater$0=caml_string_of_jsbytes("Greater"),
     cst_Less$0=caml_string_of_jsbytes("Less"),
     cst_equal$0=caml_string_of_jsbytes("equal"),
     cst_greater$0=caml_string_of_jsbytes("greater"),
     cst_less$0=caml_string_of_jsbytes("less"),
     all$3=[0,0,[0,1,[0,2,0]]],
     error_source_005$0=caml_string_of_jsbytes("ordering.ml.t"),
     t_sexp_grammar$11=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Less"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Equal"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Greater"),0]],0]]]]],
     cst_List_last=caml_string_of_jsbytes("List.last"),
     cst_List_random_element_exn_em=
      caml_string_of_jsbytes("List.random_element_exn: empty list"),
     cst_List_drop_last_exn_empty_l=
      caml_string_of_jsbytes("List.drop_last_exn: empty list"),
     cst_List_sub=caml_string_of_jsbytes("List.sub"),
     cst_List_reduce_balanced_exn=
      caml_string_of_jsbytes("List.reduce_balanced_exn"),
     cst_List_reduce_exn=caml_string_of_jsbytes("List.reduce_exn"),
     cst_map3_exn=caml_string_of_jsbytes("map3_exn"),
     cst_rev_map3_exn=caml_string_of_jsbytes("rev_map3_exn"),
     cst_map2_exn=caml_string_of_jsbytes("map2_exn"),
     cst_exists2_exn=caml_string_of_jsbytes("exists2_exn"),
     cst_for_all2_exn=caml_string_of_jsbytes("for_all2_exn"),
     cst_fold2_exn=caml_string_of_jsbytes("fold2_exn"),
     cst_rev_map2_exn=caml_string_of_jsbytes("rev_map2_exn"),
     cst_iter2_exn=caml_string_of_jsbytes("iter2_exn"),
     cst_List_range_stride_must_be_=
      caml_string_of_jsbytes("List.range: stride must be non-zero"),
     cst_List_range_stride_function$0=
      caml_string_of_jsbytes
       ("List.range': stride function cannot change direction"),
     cst_List_range_stride_function=
      caml_string_of_jsbytes
       ("List.range': stride function cannot return the same value"),
     error_source_022=caml_string_of_jsbytes("list.ml.Assoc.t"),
     cst_Base_List_Transpose_got_li=
      caml_string_of_jsbytes
       ("Base__List.Transpose_got_lists_of_different_lengths"),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes("; "),
     cst_could_not_construct_info=
      caml_string_of_jsbytes("could not construct info: "),
     cst$3=caml_string_of_jsbytes(": "),
     cst$4=caml_string_of_jsbytes(": "),
     cst$5=caml_string_of_jsbytes(": "),
     cst$6=caml_string_of_jsbytes(": "),
     cst_Backtrace=caml_string_of_jsbytes("\nBacktrace:\n"),
     t_sexp_grammar$14=[0,caml_string_of_jsbytes("Info.t")],
     cst_Base_Info_Exn=caml_string_of_jsbytes("Base__Info.Exn"),
     module_name$0=caml_string_of_jsbytes("Base.Info"),
     t_sexp_grammar$15=[0,caml_string_of_jsbytes("Error.t")],
     module_name$1=caml_string_of_jsbytes("Base.Error"),
     cst_exn$0=caml_string_of_jsbytes("exn"),
     cst_field=caml_string_of_jsbytes("field"),
     cst_problem_with_field=caml_string_of_jsbytes("problem with field"),
     cst$9=caml_string_of_jsbytes(""),
     cst_exn=caml_string_of_jsbytes("exn"),
     cst$10=caml_string_of_jsbytes(""),
     cst_invariant_failed=caml_string_of_jsbytes("invariant failed"),
     cst_unimplemented=caml_string_of_jsbytes("unimplemented"),
     cst_Neg=caml_string_of_jsbytes("Neg"),
     cst_Pos=caml_string_of_jsbytes("Pos"),
     cst_Zero=caml_string_of_jsbytes("Zero"),
     cst_neg=caml_string_of_jsbytes("neg"),
     cst_pos=caml_string_of_jsbytes("pos"),
     cst_zero=caml_string_of_jsbytes("zero"),
     cst_Neg$0=caml_string_of_jsbytes("Neg"),
     cst_Pos$0=caml_string_of_jsbytes("Pos"),
     cst_Zero$0=caml_string_of_jsbytes("Zero"),
     cst_neg$0=caml_string_of_jsbytes("neg"),
     cst_pos$0=caml_string_of_jsbytes("pos"),
     cst_zero$0=caml_string_of_jsbytes("zero"),
     error_source_003=caml_string_of_jsbytes("sign0.ml.t"),
     t_sexp_grammar$17=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Neg"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Zero"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Pos"),0]],0]]]]],
     all$6=[0,0,[0,1,[0,2,0]]],
     module_name$2=caml_string_of_jsbytes("Base.Sign"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$0=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$12=caml_string_of_jsbytes("()"),
     cst$11=caml_string_of_jsbytes("()"),
     cst_Base_Unit_of_string_expect=
      caml_string_of_jsbytes("Base.Unit.of_string: () expected"),
     all$7=[0,0,0],
     module_name$3=caml_string_of_jsbytes("Base.Unit"),
     all$8=
      [0,
       200870407,
       [0,
        -253007807,
        [0,-1055410545,[0,-1056898635,[0,926943384,[0,-839473056,0]]]]]],
     all$9=[0,125585502,[0,-63348021,0]],
     cst$13=caml_string_of_jsbytes(""),
     cst_Option_value_exn=caml_string_of_jsbytes("Option.value_exn"),
     cst_Option_value_exn_None=caml_string_of_jsbytes("Option.value_exn None"),
     cst_Sexpable_Of_stringable_t_o=
      caml_string_of_jsbytes
       ("Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list"),
     cst_Sequence_cycle_list_exn=
      caml_string_of_jsbytes("Sequence.cycle_list_exn"),
     cst_Sequence_drop=caml_string_of_jsbytes("Sequence.drop"),
     cst_Sequence_take=caml_string_of_jsbytes("Sequence.take"),
     cst_Sequence_sub=caml_string_of_jsbytes("Sequence.sub"),
     cst_Sequence_reduce_exn=caml_string_of_jsbytes("Sequence.reduce_exn"),
     cst_Sequence_find_exn=caml_string_of_jsbytes("Sequence.find_exn"),
     cst_Sequence_chunks_exn=caml_string_of_jsbytes("Sequence.chunks_exn"),
     cst_Sequence_tl_exn=caml_string_of_jsbytes("Sequence.tl_exn"),
     cst_hd_exn=caml_string_of_jsbytes("hd_exn"),
     cst_Both$1=caml_string_of_jsbytes("Both"),
     cst_Right$1=caml_string_of_jsbytes("Right"),
     cst_Left$1=caml_string_of_jsbytes("Left"),
     cst_Both=caml_string_of_jsbytes("Both"),
     cst_Left=caml_string_of_jsbytes("Left"),
     cst_Right=caml_string_of_jsbytes("Right"),
     cst_both=caml_string_of_jsbytes("both"),
     cst_left=caml_string_of_jsbytes("left"),
     cst_right=caml_string_of_jsbytes("right"),
     cst_Both$0=caml_string_of_jsbytes("Both"),
     cst_Left$0=caml_string_of_jsbytes("Left"),
     cst_Right$0=caml_string_of_jsbytes("Right"),
     cst_both$0=caml_string_of_jsbytes("both"),
     cst_left$0=caml_string_of_jsbytes("left"),
     cst_right$0=caml_string_of_jsbytes("right"),
     cst_Sequence_nth$0=caml_string_of_jsbytes("Sequence.nth"),
     cst_Sequence_nth=caml_string_of_jsbytes("Sequence.nth"),
     error_source_025=
      caml_string_of_jsbytes("sequence.ml.Merge_with_duplicates_element.t"),
     cst_Array_transpose_exn=caml_string_of_jsbytes("Array.transpose_exn"),
     cst_Array_zip_exn=caml_string_of_jsbytes("Array.zip_exn"),
     cst_Array_random_element_exn_e=
      caml_string_of_jsbytes("Array.random_element_exn: empty array"),
     cst_Array_reduce_exn=caml_string_of_jsbytes("Array.reduce_exn"),
     cst_Array_for_all2_exn=caml_string_of_jsbytes("Array.for_all2_exn"),
     cst_Array_exists2_exn=caml_string_of_jsbytes("Array.exists2_exn"),
     cst_Array_fold2_exn=caml_string_of_jsbytes("Array.fold2_exn"),
     cst_Array_map2_exn=caml_string_of_jsbytes("Array.map2_exn"),
     cst_Array_iter2_exn=caml_string_of_jsbytes("Array.iter2_exn"),
     cst_Obj_array_t_of_length=
      caml_string_of_jsbytes("<Obj_array.t of length "),
     cst_Array_map2_exn$0=caml_string_of_jsbytes("Array.map2_exn"),
     cst_Uniform_array_init=caml_string_of_jsbytes("Uniform_array.init"),
     cst_char=caml_string_of_jsbytes("char"),
     cst_Char_get_hex_digit_exn_not=
      caml_string_of_jsbytes
       ("Char.get_hex_digit_exn: not a hexadecimal digit"),
     module_name$4=caml_string_of_jsbytes("Base.Char"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$1=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$25=caml_string_of_jsbytes(""),
     cst$24=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes(""),
     cst_char$1=caml_string_of_jsbytes("char"),
     cst_pos$2=caml_string_of_jsbytes("pos"),
     cst_escape_char$0=caml_string_of_jsbytes("escape_char"),
     cst_str$0=caml_string_of_jsbytes("str"),
     cst_rindex_from_exn_not_found=
      caml_string_of_jsbytes("rindex_from_exn: not found"),
     cst_rindex_from=caml_string_of_jsbytes("rindex_from"),
     cst_char$0=caml_string_of_jsbytes("char"),
     cst_pos$1=caml_string_of_jsbytes("pos"),
     cst_escape_char=caml_string_of_jsbytes("escape_char"),
     cst_str=caml_string_of_jsbytes("str"),
     cst_index_from_exn_not_found=
      caml_string_of_jsbytes("index_from_exn: not found"),
     cst_index_from=caml_string_of_jsbytes("index_from"),
     cst_is_char_literal=caml_string_of_jsbytes("is_char_literal"),
     cst_is_char_escaped=caml_string_of_jsbytes("is_char_escaped"),
     cst_is_char_escaping=caml_string_of_jsbytes("is_char_escaping"),
     cst_escapeworthy_map=caml_string_of_jsbytes("escapeworthy_map"),
     cst_c_to=caml_string_of_jsbytes("c_to"),
     cst_c_from=caml_string_of_jsbytes("c_from"),
     cst_escapeworthy_map_not_one_t=
      caml_string_of_jsbytes("escapeworthy_map not one-to-one"),
     cst$21=caml_string_of_jsbytes(""),
     cst$22=caml_string_of_jsbytes(""),
     cst$20=caml_string_of_jsbytes(""),
     cst_tr_multi_replacement_is_em=
      caml_string_of_jsbytes("tr_multi replacement is empty string"),
     cst$19=caml_string_of_jsbytes(""),
     cst$18=caml_string_of_jsbytes(""),
     cst$17=caml_string_of_jsbytes(""),
     cst_suffix=caml_string_of_jsbytes("suffix"),
     cst_prefix=caml_string_of_jsbytes("prefix"),
     cst$16=caml_string_of_jsbytes(""),
     cst_drop_suffix=caml_string_of_jsbytes("drop_suffix"),
     cst$15=caml_string_of_jsbytes(""),
     cst_drop_prefix=caml_string_of_jsbytes("drop_prefix"),
     cst_expecting_nonnegative_argu=
      caml_string_of_jsbytes(" expecting nonnegative argument"),
     cst_substring=caml_string_of_jsbytes("substring"),
     cst_Substring_not_found=caml_string_of_jsbytes("Substring not found"),
     cst_String_rindex_from_exn=
      caml_string_of_jsbytes("String.rindex_from_exn"),
     cst_String_index_from_exn=caml_string_of_jsbytes("String.index_from_exn"),
     cst$14=caml_string_of_jsbytes(""),
     cst_max$2=caml_string_of_jsbytes("max"),
     cst_min$2=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$2=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_tr_multi_replacement_is_th=
      caml_string_of_jsbytes("tr_multi: replacement is the empty string"),
     module_name$5=caml_string_of_jsbytes("Base.Bytes"),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes("\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     cst_0x=caml_string_of_jsbytes("-0x"),
     cst_0x$0=caml_string_of_jsbytes("0x"),
     cst_int63=caml_string_of_jsbytes("int63"),
     cst_int64$3=caml_string_of_jsbytes("int64"),
     cst_nativeint$2=caml_string_of_jsbytes("nativeint"),
     cst_int64$2=caml_string_of_jsbytes("int64"),
     cst_int32$3=caml_string_of_jsbytes("int32"),
     cst_nativeint$1=caml_string_of_jsbytes("nativeint"),
     cst_int32$2=caml_string_of_jsbytes("int32"),
     cst_int64$1=caml_string_of_jsbytes("int64"),
     cst_int$3=caml_string_of_jsbytes("int"),
     cst_nativeint$0=caml_string_of_jsbytes("nativeint"),
     cst_int$2=caml_string_of_jsbytes("int"),
     cst_int64$0=caml_string_of_jsbytes("int64"),
     cst_int$1=caml_string_of_jsbytes("int"),
     cst_int32$1=caml_string_of_jsbytes("int32"),
     cst_int32$0=caml_string_of_jsbytes("int32"),
     cst_int$0=caml_string_of_jsbytes("int"),
     overflow_bound_max_int63_on_in=
      runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     overflow_bound_max_int64_value=
      runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     m1=runtime.caml_int64_create_lo_mi_hi(5592405,5592405,21845),
     m2=runtime.caml_int64_create_lo_mi_hi(3355443,3355443,13107),
     m4=runtime.caml_int64_create_lo_mi_hi(986895,986895,3855),
     h01=runtime.caml_int64_create_lo_mi_hi(65793,65793,257),
     mask=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     cst$27=caml_string_of_jsbytes(""),
     cst_Int_ceil_log2_got_invalid_=
      caml_string_of_jsbytes("[Int.ceil_log2] got invalid input"),
     cst$26=caml_string_of_jsbytes(""),
     cst_Int_floor_log2_got_invalid=
      caml_string_of_jsbytes("[Int.floor_log2] got invalid input"),
     cst_max$3=caml_string_of_jsbytes("max"),
     cst_min$3=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$3=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$6=caml_string_of_jsbytes("Base.Int.Hex"),
     module_name$7=caml_string_of_jsbytes("Base.Int"),
     cst_Uchar_t_of_sexp_atom_of_th=
      caml_string_of_jsbytes
       ("Uchar.t_of_sexp: atom of the form U+XXXX needed"),
     cst_Uchar_t_of_sexp_atom_neede=
      caml_string_of_jsbytes("Uchar.t_of_sexp: atom needed"),
     module_name$8=caml_string_of_jsbytes("Base.Uchar"),
     cst$28=caml_string_of_jsbytes(""),
     cst_Type_equal_Id_same_witness=
      caml_string_of_jsbytes
       ("Type_equal.Id.same_witness_exn got different ids"),
     cst_Key=caml_string_of_jsbytes("Key"),
     some_t=[0,0],
     cst_Option_array_get_some_exn_=
      caml_string_of_jsbytes
       ("Option_array.get_some_exn: the element is [None]"),
     cst_stack=caml_string_of_jsbytes("stack"),
     cst_exn$1=caml_string_of_jsbytes("exn"),
     cst_Stack_invariant_failed=
      caml_string_of_jsbytes("Stack.invariant failed"),
     cst_Stack_pop_of_empty_stack=
      caml_string_of_jsbytes("Stack.pop of empty stack"),
     cst_Stack_top_of_empty_stack=
      caml_string_of_jsbytes("Stack.top of empty stack"),
     cst_Base_Sign_or_nan_to_sign_e=
      caml_string_of_jsbytes("Base.Sign_or_nan.to_sign_exn: Nan"),
     cst_Nan=caml_string_of_jsbytes("Nan"),
     cst_Neg$1=caml_string_of_jsbytes("Neg"),
     cst_Pos$1=caml_string_of_jsbytes("Pos"),
     cst_Zero$1=caml_string_of_jsbytes("Zero"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg$1=caml_string_of_jsbytes("neg"),
     cst_pos$3=caml_string_of_jsbytes("pos"),
     cst_zero$1=caml_string_of_jsbytes("zero"),
     cst_Nan$0=caml_string_of_jsbytes("Nan"),
     cst_Neg$2=caml_string_of_jsbytes("Neg"),
     cst_Pos$2=caml_string_of_jsbytes("Pos"),
     cst_Zero$2=caml_string_of_jsbytes("Zero"),
     cst_nan$0=caml_string_of_jsbytes("nan"),
     cst_neg$2=caml_string_of_jsbytes("neg"),
     cst_pos$4=caml_string_of_jsbytes("pos"),
     cst_zero$2=caml_string_of_jsbytes("zero"),
     error_source_003$0=caml_string_of_jsbytes("sign_or_nan.ml.T.t"),
     t_sexp_grammar$25=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Neg"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Zero"),0]],
          [0,
           [1,[0,caml_string_of_jsbytes("Pos"),0]],
           [0,[1,[0,caml_string_of_jsbytes("Nan"),0]],0]]]]]],
     all$14=[0,0,[0,1,[0,2,[0,3,0]]]],
     module_name$9=caml_string_of_jsbytes("Base.Sign_or_nan"),
     cst_Maybe_bound_compare_to_int=
      caml_string_of_jsbytes
       ("Maybe_bound.compare_to_interval_exn: lower bound > upper bound"),
     cst_Above_upper_bound=caml_string_of_jsbytes("Above_upper_bound"),
     cst_Below_lower_bound=caml_string_of_jsbytes("Below_lower_bound"),
     cst_In_range=caml_string_of_jsbytes("In_range"),
     cst_above_upper_bound=caml_string_of_jsbytes("above_upper_bound"),
     cst_below_lower_bound=caml_string_of_jsbytes("below_lower_bound"),
     cst_in_range=caml_string_of_jsbytes("in_range"),
     cst_Above_upper_bound$0=caml_string_of_jsbytes("Above_upper_bound"),
     cst_Below_lower_bound$0=caml_string_of_jsbytes("Below_lower_bound"),
     cst_In_range$0=caml_string_of_jsbytes("In_range"),
     cst_above_upper_bound$0=caml_string_of_jsbytes("above_upper_bound"),
     cst_below_lower_bound$0=caml_string_of_jsbytes("below_lower_bound"),
     cst_in_range$0=caml_string_of_jsbytes("in_range"),
     cst_Excl$1=caml_string_of_jsbytes("Excl"),
     cst_Incl$1=caml_string_of_jsbytes("Incl"),
     cst_Excl=caml_string_of_jsbytes("Excl"),
     cst_Incl=caml_string_of_jsbytes("Incl"),
     cst_Unbounded=caml_string_of_jsbytes("Unbounded"),
     cst_excl=caml_string_of_jsbytes("excl"),
     cst_incl=caml_string_of_jsbytes("incl"),
     cst_unbounded=caml_string_of_jsbytes("unbounded"),
     cst_Excl$0=caml_string_of_jsbytes("Excl"),
     cst_Incl$0=caml_string_of_jsbytes("Incl"),
     cst_Unbounded$0=caml_string_of_jsbytes("Unbounded"),
     cst_excl$0=caml_string_of_jsbytes("excl"),
     cst_incl$0=caml_string_of_jsbytes("incl"),
     cst_unbounded$0=caml_string_of_jsbytes("unbounded"),
     error_source_006=caml_string_of_jsbytes("maybe_bound.ml.t"),
     error_source_027=
      caml_string_of_jsbytes("maybe_bound.ml.interval_comparison"),
     interval_comparison_sexp_gramm=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Below_lower_bound"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("In_range"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Above_upper_bound"),0]],0]]]]],
     cst_Unequal$1=caml_string_of_jsbytes("Unequal"),
     cst_Right$4=caml_string_of_jsbytes("Right"),
     cst_Left$4=caml_string_of_jsbytes("Left"),
     cst_Left$2=caml_string_of_jsbytes("Left"),
     cst_Right$2=caml_string_of_jsbytes("Right"),
     cst_Unequal=caml_string_of_jsbytes("Unequal"),
     cst_Left$3=caml_string_of_jsbytes("Left"),
     cst_Right$3=caml_string_of_jsbytes("Right"),
     cst_Unequal$0=caml_string_of_jsbytes("Unequal"),
     error_source_057=
      caml_string_of_jsbytes("map_intf.ml.Symmetric_diff_element.t"),
     all$16=[0,0,[0,1,0]],
     all$17=[0,0,[0,1,0]],
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_invalid_elements=caml_string_of_jsbytes("invalid_elements"),
     cst_is_not_a_subset_of=caml_string_of_jsbytes(" is not a subset of "),
     cst_Set_t_of_sexp_duplicate_el=
      caml_string_of_jsbytes("Set.t_of_sexp: duplicate element in set"),
     cst_Set_t_of_sexp_list_needed=
      caml_string_of_jsbytes("Set.t_of_sexp: list needed"),
     cst_Set_find_exn_failed_to_fin=
      caml_string_of_jsbytes("Set.find_exn failed to find a matching element"),
     cst_of_sorted_array_duplicated=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_of_sorted_array_elements_a=
      caml_string_of_jsbytes("of_sorted_array: elements are not ordered"),
     cst_of_sorted_array_duplicated$0=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_Base_Set_Tree0_Same=caml_string_of_jsbytes("Base__Set.Tree0.Same"),
     cst_Base_Set_Tree0_Set_min_elt=
      caml_string_of_jsbytes("Base__Set.Tree0.Set_min_elt_exn_of_empty_set"),
     cst_Base_Set_Tree0_Set_max_elt=
      caml_string_of_jsbytes("Base__Set.Tree0.Set_max_elt_exn_of_empty_set"),
     cst_length$1=caml_string_of_jsbytes("length"),
     cst_Queue_init_negative_length=
      caml_string_of_jsbytes("Queue.init: negative length"),
     cst_length$0=caml_string_of_jsbytes("length"),
     cst_Queue_blit_transfer_negati=
      caml_string_of_jsbytes("Queue.blit_transfer: negative length"),
     cst_capacity=caml_string_of_jsbytes("capacity"),
     cst_cannot_have_queue_with_neg=
      caml_string_of_jsbytes("cannot have queue with negative capacity"),
     cst$29=caml_string_of_jsbytes(""),
     cst_mutation_of_queue_during_i=
      caml_string_of_jsbytes("mutation of queue during iteration"),
     cst_length=caml_string_of_jsbytes("length"),
     cst_index=caml_string_of_jsbytes("index"),
     cst_Queue_index_out_of_bounds=
      caml_string_of_jsbytes("Queue index out of bounds"),
     cst_Base_Nothing_of_string_not=
      caml_string_of_jsbytes("Base.Nothing.of_string: not supported"),
     cst_Base_Nothing_t=caml_string_of_jsbytes("Base.Nothing.t"),
     t_sexp_grammar$30=[4,0],
     module_name$10=caml_string_of_jsbytes("Base.Nothing"),
     cst_max$4=caml_string_of_jsbytes("max"),
     cst_min$4=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$4=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$31=caml_string_of_jsbytes(""),
     cst_Nativeint_ceil_log2_got_in=
      caml_string_of_jsbytes("[Nativeint.ceil_log2] got invalid input"),
     cst$30=caml_string_of_jsbytes(""),
     cst_Nativeint_floor_log2_got_i=
      caml_string_of_jsbytes("[Nativeint.floor_log2] got invalid input"),
     module_name$11=caml_string_of_jsbytes("Base.Nativeint.Hex"),
     module_name$12=caml_string_of_jsbytes("Base.Nativeint"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_key$0=caml_string_of_jsbytes("key"),
     cst_Map_map_keys_exn_duplicate=
      caml_string_of_jsbytes("Map.map_keys_exn: duplicate key"),
     cst_Map_t_of_sexp_direct_dupli=
      caml_string_of_jsbytes("Map.t_of_sexp_direct: duplicate key"),
     cst_Map_of_iteri_exn_duplicate=
      caml_string_of_jsbytes("Map.of_iteri_exn: duplicate key"),
     cst_exn_duplicate_key=caml_string_of_jsbytes("_exn: duplicate key"),
     cst_Map_of$0=caml_string_of_jsbytes("Map.of_"),
     cst_or_error_duplicate_key=
      caml_string_of_jsbytes("_or_error: duplicate key"),
     cst_Map_of=caml_string_of_jsbytes("Map.of_"),
     cst_of_increasing_sequence_non=
      caml_string_of_jsbytes("of_increasing_sequence: non-increasing key"),
     cst_Map_singleton_to_tree_exn_=
      caml_string_of_jsbytes("Map.singleton_to_tree_exn: not a singleton"),
     cst_key=caml_string_of_jsbytes("key"),
     cst_Map_add_exn_got_key_alread=
      caml_string_of_jsbytes("[Map.add_exn] got key already present"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_of_sorted_array_duplicated$1=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_of_sorted_array_elements_a$0=
      caml_string_of_jsbytes("of_sorted_array: elements are not ordered"),
     cst_of_sorted_array_duplicated$2=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_Base_Map_Duplicate=caml_string_of_jsbytes("Base__Map.Duplicate"),
     empty$5=[0,0],
     cst_Base_Map_Tree0_Map_min_elt=
      caml_string_of_jsbytes("Base__Map.Tree0.Map_min_elt_exn_of_empty_map"),
     cst_Base_Map_Tree0_Map_max_elt=
      caml_string_of_jsbytes("Base__Map.Tree0.Map_max_elt_exn_of_empty_map"),
     cst_Base_Map_Tree0_Remove_no_o=
      caml_string_of_jsbytes("Base__Map.Tree0.Remove_no_op"),
     cst_Base_Map_Tree0_Change_no_o=
      caml_string_of_jsbytes("Base__Map.Tree0.Change_no_op"),
     name$1=caml_string_of_jsbytes("alist"),
     name$2=caml_string_of_jsbytes("sequence"),
     cst$33=caml_string_of_jsbytes(""),
     cst_Int64_ceil_log2_got_invali=
      caml_string_of_jsbytes("[Int64.ceil_log2] got invalid input"),
     cst$32=caml_string_of_jsbytes(""),
     cst_Int64_floor_log2_got_inval=
      caml_string_of_jsbytes("[Int64.floor_log2] got invalid input"),
     cst_max$5=caml_string_of_jsbytes("max"),
     cst_min$5=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$5=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$13=caml_string_of_jsbytes("Base.Int64.Hex"),
     module_name$14=caml_string_of_jsbytes("Base.Int64"),
     cst_0x$1=caml_string_of_jsbytes("0x"),
     cst_max$6=caml_string_of_jsbytes("max"),
     cst_min$6=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$6=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     mask$0=runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
     module_name$15=caml_string_of_jsbytes("Base.Int63.Hex"),
     module_name$16=caml_string_of_jsbytes("Base.Int63"),
     cst_max$7=caml_string_of_jsbytes("max"),
     cst_min$7=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$7=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_true=caml_string_of_jsbytes("true"),
     all$20=[0,0,[0,1,0]],
     module_name$17=caml_string_of_jsbytes("Base.Bool"),
     cst$35=caml_string_of_jsbytes(""),
     cst_Int32_ceil_log2_got_invali=
      caml_string_of_jsbytes("[Int32.ceil_log2] got invalid input"),
     cst$34=caml_string_of_jsbytes(""),
     cst_Int32_floor_log2_got_inval=
      caml_string_of_jsbytes("[Int32.floor_log2] got invalid input"),
     cst_max$8=caml_string_of_jsbytes("max"),
     cst_min$8=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$8=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$18=caml_string_of_jsbytes("Base.Int32.Hex"),
     module_name$19=caml_string_of_jsbytes("Base.Int32"),
     cst$36=caml_string_of_jsbytes(""),
     cst_Int_floor_log2_got_invalid$0=
      caml_string_of_jsbytes("[Int.floor_log2] got invalid input"),
     cst_neg_overflow=caml_string_of_jsbytes("neg overflow"),
     cst_abs_overflow=caml_string_of_jsbytes("abs overflow"),
     cst_product$0=caml_string_of_jsbytes("product"),
     cst_u$2=caml_string_of_jsbytes("u"),
     cst_t$2=caml_string_of_jsbytes("t"),
     cst_overflow$2=caml_string_of_jsbytes("( / ) overflow"),
     cst_product=caml_string_of_jsbytes("product"),
     cst_u$1=caml_string_of_jsbytes("u"),
     cst_t$1=caml_string_of_jsbytes("t"),
     cst_overflow$1=caml_string_of_jsbytes("( * ) overflow"),
     cst_diff=caml_string_of_jsbytes("diff"),
     cst_u$0=caml_string_of_jsbytes("u"),
     cst_t$0=caml_string_of_jsbytes("t"),
     cst_overflow$0=caml_string_of_jsbytes("( - ) overflow"),
     cst_sum=caml_string_of_jsbytes("sum"),
     cst_u=caml_string_of_jsbytes("u"),
     cst_t=caml_string_of_jsbytes("t"),
     cst_overflow=caml_string_of_jsbytes("( + ) overflow"),
     cst_Avltree_choose_exn_of_empt=
      caml_string_of_jsbytes("[Avltree.choose_exn] of empty hashtbl"),
     cst_Hashtbl_merge_different_ha=
      caml_string_of_jsbytes("Hashtbl.merge: different 'hashable' values"),
     cst_keys=caml_string_of_jsbytes("keys"),
     cst_Hashtbl_create_with_key_du=
      caml_string_of_jsbytes("Hashtbl.create_with_key: duplicate keys"),
     cst_Hashtbl_t_of_sexp_duplicat=
      caml_string_of_jsbytes("Hashtbl.t_of_sexp: duplicate key"),
     cst_Hashtbl_of_alist_exn_dupli=
      caml_string_of_jsbytes("Hashtbl.of_alist_exn: duplicate key"),
     cst_Hashtbl_choose_exn_of_empt=
      caml_string_of_jsbytes("[Hashtbl.choose_exn] of empty hashtbl"),
     cst_Hashtbl_add_exn_got_key_al=
      caml_string_of_jsbytes("Hashtbl.add_exn got key already present"),
     cst_Hashtbl_mutation_not_allow=
      caml_string_of_jsbytes("Hashtbl: mutation not allowed during iteration"),
     cst_Hash_set_t_of_sexp_got_a_d=
      caml_string_of_jsbytes("Hash_set.t_of_sexp got a duplicate element"),
     cst_Hash_set_t_of_sexp_require=
      caml_string_of_jsbytes("Hash_set.t_of_sexp requires a list"),
     cst_element_not_in_set=caml_string_of_jsbytes("element not in set"),
     cst_element_already_exists=
      caml_string_of_jsbytes("element already exists"),
     cst$42=caml_string_of_jsbytes(""),
     cst_Float_sign_exn_of_NAN=caml_string_of_jsbytes("Float.sign_exn of NAN"),
     cst_max$9=caml_string_of_jsbytes("max"),
     cst_min$9=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$9=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_t$3=caml_string_of_jsbytes("t"),
     cst_g=caml_string_of_jsbytes("g"),
     cst_m=caml_string_of_jsbytes("m"),
     cst_k=caml_string_of_jsbytes("k"),
     cst_1f=caml_string_of_jsbytes("%.1f"),
     cst_0=caml_string_of_jsbytes(".0"),
     cst$41=caml_string_of_jsbytes(""),
     cst$40=caml_string_of_jsbytes("-"),
     cst_inf$1=caml_string_of_jsbytes("-inf  "),
     cst_inf$2=caml_string_of_jsbytes("inf  "),
     cst_nan$4=caml_string_of_jsbytes("nan  "),
     cst_sexp=caml_string_of_jsbytes("sexp"),
     cst_sexp_of_float_produced_str=
      caml_string_of_jsbytes("[sexp_of_float] produced strange sexp"),
     cst_inf=caml_string_of_jsbytes("inf"),
     cst_inf$0=caml_string_of_jsbytes("-inf"),
     cst_nan$3=caml_string_of_jsbytes("nan"),
     cst$38=caml_string_of_jsbytes(""),
     cst$39=caml_string_of_jsbytes("."),
     cst_infinite=caml_string_of_jsbytes("infinite"),
     cst_Infinite=caml_string_of_jsbytes("Infinite"),
     cst_Nan$1=caml_string_of_jsbytes("Nan"),
     cst_Normal=caml_string_of_jsbytes("Normal"),
     cst_Subnormal=caml_string_of_jsbytes("Subnormal"),
     cst_Zero$3=caml_string_of_jsbytes("Zero"),
     cst_nan$1=caml_string_of_jsbytes("nan"),
     cst_normal=caml_string_of_jsbytes("normal"),
     cst_subnormal=caml_string_of_jsbytes("subnormal"),
     cst_zero$3=caml_string_of_jsbytes("zero"),
     cst_infinite$0=caml_string_of_jsbytes("infinite"),
     cst_Infinite$0=caml_string_of_jsbytes("Infinite"),
     cst_Nan$2=caml_string_of_jsbytes("Nan"),
     cst_Normal$0=caml_string_of_jsbytes("Normal"),
     cst_Subnormal$0=caml_string_of_jsbytes("Subnormal"),
     cst_Zero$4=caml_string_of_jsbytes("Zero"),
     cst_nan$2=caml_string_of_jsbytes("nan"),
     cst_normal$0=caml_string_of_jsbytes("normal"),
     cst_subnormal$0=caml_string_of_jsbytes("subnormal"),
     cst_zero$4=caml_string_of_jsbytes("zero"),
     cst_15g=caml_string_of_jsbytes("%.15g"),
     cst_17g=caml_string_of_jsbytes("%.17g"),
     cst$37=caml_string_of_jsbytes("."),
     all$21=[0,0,[0,1,[0,2,[0,3,[0,4,0]]]]],
     error_source_006$0=caml_string_of_jsbytes("float.ml.Class.t"),
     t_sexp_grammar$34=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Infinite"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Nan"),0]],
          [0,
           [1,[0,caml_string_of_jsbytes("Normal"),0]],
           [0,
            [1,[0,caml_string_of_jsbytes("Subnormal"),0]],
            [0,[1,[0,caml_string_of_jsbytes("Zero"),0]],0]]]]]]],
     module_name$20=caml_string_of_jsbytes("Base.Float"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     elided_message=caml_string_of_jsbytes("<backtrace elided in test>"),
     Caml=global_data.Caml,
     Stdlib_Uchar=global_data.Stdlib__Uchar,
     include$0=global_data.Shadow_stdlib,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Sys=global_data.Stdlib__Sys,
     Stdlib_ArrayLabels=global_data.Stdlib__ArrayLabels,
     Stdlib=global_data.Stdlib,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_ListLabels=global_data.Stdlib__ListLabels,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Sexplib0_Sexp=global_data.Sexplib0__Sexp,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Stdlib_Format=global_data.Stdlib__Format,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Assert_failure$0=global_data.Assert_failure,
     Stdlib_BytesLabels=global_data.Stdlib__BytesLabels,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Stdlib_StringLabels=global_data.Stdlib__StringLabels,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Stdlib_Int64=global_data.Stdlib__Int64,
     Stdlib_Nativeint=global_data.Stdlib__Nativeint,
     Stdlib_Int32=global_data.Stdlib__Int32,
     Stdlib_Random=global_data.Stdlib__Random,
     Stdlib_MoreLabels=global_data.Stdlib__MoreLabels,
     Stdlib_Obj=global_data.Stdlib__Obj,
     Sexplib0_Sexp_grammar=global_data.Sexplib0__Sexp_grammar,
     Stdlib_Float=global_data.Stdlib__Float,
     Stdlib_Lexing=global_data.Stdlib__Lexing,
     Stdlib_Scanf=global_data.Stdlib__Scanf,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Match_failure$0=global_data.Match_failure,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Base=[0];
    caml_register_global(970,Base,"Base__");
    var
     _c_=
      [0,
       [11,
        caml_string_of_jsbytes("Sys.getenv_exn: environment variable "),
        [2,0,[11,caml_string_of_jsbytes(" is not set"),0]]],
       caml_string_of_jsbytes
        ("Sys.getenv_exn: environment variable %s is not set")],
     _g_=
      [0,
       [11,
        caml_string_of_jsbytes("Char.of_int_exn got integer out of range: "),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("Char.of_int_exn got integer out of range: %d")],
     _r_=
      [0,
       [11,
        caml_string_of_jsbytes("Equal called on the type "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", which is abstract in an implementation."),
          0]]],
       caml_string_of_jsbytes
        ("Equal called on the type %s, which is abstract in an implementation.")],
     _q_=
      [0,
       [11,
        caml_string_of_jsbytes("Compare called on the type "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", which is abstract in an implementation."),
          0]]],
       caml_string_of_jsbytes
        ("Compare called on the type %s, which is abstract in an implementation.")],
     _s_=[0,caml_string_of_jsbytes("W64")],
     _t_=[0,caml_string_of_jsbytes("W32")],
     _u_=[0,caml_string_of_jsbytes("Base.Sexp.pp_hum"),0],
     _I_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Exn.handle_uncaught could not print; exiting anyway\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("Exn.handle_uncaught could not print; exiting anyway\n%!")],
     _H_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Uncaught exception:"),
         [17,
          3,
          [17,
           3,
           [18,
            [1,[0,0,caml_string_of_jsbytes("")]],
            [15,[17,0,[17,0,[17,3,[17,4,0]]]]]]]]]],
       caml_string_of_jsbytes("@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@.")],
     _G_=[0,2],
     _F_=[0,caml_string_of_jsbytes("src/exn.ml"),54,6],
     _C_=[0,caml_string_of_jsbytes("exn.ml.Reraised")],
     _D_=[0,caml_string_of_jsbytes("src/exn.ml"),33,11],
     _z_=[0,caml_string_of_jsbytes("exn.ml.Finally")],
     _A_=[0,caml_string_of_jsbytes("src/exn.ml"),19,11],
     _O_=[0,caml_string_of_jsbytes("_")],
     _Q_=[0,caml_string_of_jsbytes("First")],
     _R_=[0,caml_string_of_jsbytes("Second")],
     _S_=[0,caml_string_of_jsbytes("pos_cnum")],
     _T_=[0,caml_string_of_jsbytes("pos_bol")],
     _U_=[0,caml_string_of_jsbytes("pos_lnum")],
     _V_=[0,caml_string_of_jsbytes("pos_fname")],
     _Y_=[0,0],
     _W_=[0,caml_string_of_jsbytes("Ok")],
     _X_=[0,caml_string_of_jsbytes("Error")],
     _aa_=
      [0,
       [11,caml_string_of_jsbytes("Negative position: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Negative position: %d")],
     _ab_=
      [0,
       [11,caml_string_of_jsbytes("Negative length: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Negative length: %d")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("pos + len past end: "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" + "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" > "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("pos + len past end: %d + %d > %d")],
     _af_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("Random."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": crossed bounds ["),
          [2,0,[11,caml_string_of_jsbytes(" > "),[2,0,[12,93,0]]]]]]],
       caml_string_of_jsbytes("Random.%s: crossed bounds [%s > %s]")],
     _ah_=[0,caml_string_of_jsbytes("Less")],
     _ai_=[0,caml_string_of_jsbytes("Equal")],
     _aj_=[0,caml_string_of_jsbytes("Greater")],
     _aC_=
      [0,
       caml_string_of_jsbytes
        ("list.ml.Transpose_got_lists_of_different_lengths")],
     _aD_=[0,caml_string_of_jsbytes("src/list.ml"),1301,13],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("List.chunks_of: Expected length > 0, got "),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("List.chunks_of: Expected length > 0, got %d")],
     _ay_=[0,caml_string_of_jsbytes("src/list.ml"),1045,12],
     _ax_=[0,caml_string_of_jsbytes("src/list.ml"),933,4],
     _aw_=
      [0,
       [11,caml_string_of_jsbytes("List.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("List.init %d")],
     _av_=[0,caml_string_of_jsbytes("src/list.ml"),661,14],
     _au_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in zip_exn: "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes("length mismatch in zip_exn: %d <> %d")],
     _at_=[0,caml_string_of_jsbytes("src/list.ml"),528,11],
     _ao_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" <> "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(" || "),
              [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d || %d <> %d")],
     _an_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d")],
     _am_=
      [0,
       [11,
        caml_string_of_jsbytes("List.nth_exn "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" called on list of length "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes("List.nth_exn %d called on list of length %d")],
     _ak_=[0,caml_string_of_jsbytes("Ok")],
     _al_=[0,caml_string_of_jsbytes("Unequal_lengths")],
     _ap_=[0,caml_string_of_jsbytes("List.find_map_exn: not found")],
     _aq_=[0,caml_string_of_jsbytes("List.find_exn: not found")],
     _ar_=[0,caml_string_of_jsbytes("List.findi_exn: not found")],
     _as_=[0,caml_string_of_jsbytes("List.find_mapi_exn: not found")],
     _az_=[0,caml_string_of_jsbytes("List.Assoc.find_exn: not found")],
     _aQ_=[0,caml_string_of_jsbytes("src/info.ml"),204,6],
     _aF_=[0,caml_string_of_jsbytes("Could_not_construct")],
     _aG_=[0,caml_string_of_jsbytes("String")],
     _aH_=[0,caml_string_of_jsbytes("Exn")],
     _aI_=[0,caml_string_of_jsbytes("Sexp")],
     _aJ_=[0,caml_string_of_jsbytes("Tag_sexp")],
     _aK_=[0,caml_string_of_jsbytes("Tag_t")],
     _aL_=[0,caml_string_of_jsbytes("Tag_arg")],
     _aM_=[0,caml_string_of_jsbytes("Of_list")],
     _aN_=[0,caml_string_of_jsbytes("With_backtrace")],
     _aO_=
      [0,
       [11,
        caml_string_of_jsbytes("and "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" more info"),0]]],
       caml_string_of_jsbytes("and %d more info")],
     _aS_=[0,caml_string_of_jsbytes("src/or_error.ml"),135,22],
     _aR_=[0,3553398],
     _aT_=[0,caml_string_of_jsbytes("Neg")],
     _aU_=[0,caml_string_of_jsbytes("Zero")],
     _aV_=[0,caml_string_of_jsbytes("Pos")],
     _aX_=[0,caml_string_of_jsbytes("src/comparable.ml"),133,4],
     _aW_=[0,caml_string_of_jsbytes("src/comparable.ml"),47,4],
     _aZ_=[0,caml_string_of_jsbytes("_")],
     _bi_=[0,0],
     _bf_=[0,caml_string_of_jsbytes("Left")],
     _bg_=[0,caml_string_of_jsbytes("Right")],
     _bh_=[0,caml_string_of_jsbytes("Both")],
     _be_=[0,caml_string_of_jsbytes("src/sequence.ml"),259,14],
     _bd_=[0,0,0],
     _a$_=[0,caml_string_of_jsbytes("Done")],
     _ba_=[0,caml_string_of_jsbytes("Skip")],
     _bb_=[0,caml_string_of_jsbytes("Yield")],
     _bp_=[0,caml_string_of_jsbytes("src/array.ml"),858,8],
     _bm_=[0,caml_string_of_jsbytes("Array.find_exn: not found")],
     _bl_=[0,caml_string_of_jsbytes("Array.findi_exn: not found")],
     _bk_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d")],
     _bj_=[0,caml_string_of_jsbytes("src/array.ml"),435,14],
     _bn_=[0,caml_string_of_jsbytes("Array.find_map_exn: not found")],
     _bo_=[0,caml_string_of_jsbytes("Array.find_mapi_exn: not found")],
     _br_=[0,caml_string_of_jsbytes(">"),0],
     _bs_=[0,caml_string_of_jsbytes("")],
     _bq_=[0,caml_string_of_jsbytes("src/obj_array.ml"),11,18],
     _bu_=[0,caml_string_of_jsbytes("src/uniform_array.ml"),164,8],
     _bt_=[0,caml_string_of_jsbytes("src/uniform_array.ml"),71,18],
     _bB_=[0,caml_string_of_jsbytes("src/float0.ml"),170,4],
     _bA_=[0,caml_string_of_jsbytes("src/float0.ml"),174,4],
     _by_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _bz_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _bx_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _bw_=[0,runtime.caml_int64_create_lo_mi_hi(0,0,0)],
     _bv_=
      [0,
       [8,
        [0,0,0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0,0,0],
            0,
            0,
            [11,
             caml_string_of_jsbytes
              (" in float0.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%f %% %f in float0.ml: modulus should be positive")],
     _bP_=
      [0,
       [11,
        caml_string_of_jsbytes("Char.get_digit_exn "),
        [1,[11,caml_string_of_jsbytes(": not a digit"),0]]],
       caml_string_of_jsbytes("Char.get_digit_exn %C: not a digit")],
     _bO_=[0,[1,0],caml_string_of_jsbytes("%C")],
     _bC_=
      [0,
       [11,caml_string_of_jsbytes("Char.of_string: "),[3,0,0]],
       caml_string_of_jsbytes("Char.of_string: %S")],
     _cl_=[0,caml_string_of_jsbytes("src/string.ml"),1587,2],
     _ck_=[0,caml_string_of_jsbytes("src/string.ml"),1573,19],
     _cj_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(": out of bounds"),0]],
       caml_string_of_jsbytes("%s: out of bounds")],
     _ci_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _ch_=
      [0,
       [11,
        caml_string_of_jsbytes("String.chop_suffix_exn "),
        [3,0,[12,32,[3,0,0]]]],
       caml_string_of_jsbytes("String.chop_suffix_exn %S %S")],
     _cg_=
      [0,
       [11,
        caml_string_of_jsbytes("String.chop_prefix_exn "),
        [3,0,[12,32,[3,0,0]]]],
       caml_string_of_jsbytes("String.chop_prefix_exn %S %S")],
     _cf_=[0,caml_string_of_jsbytes("src/string.ml"),765,17],
     _cc_=
      [0,
       [11,caml_string_of_jsbytes("String.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("String.init %d")],
     _b6_=
      [0,
       [11,
        caml_string_of_jsbytes("String.is_substring_at: invalid index "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" for string of length "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes
        ("String.is_substring_at: invalid index %d for string of length %d")],
     _bX_=[0,caml_string_of_jsbytes("kmp_array")],
     _bY_=[0,caml_string_of_jsbytes("case_sensitive")],
     _bZ_=[0,caml_string_of_jsbytes("pattern")],
     _bV_=[0,caml_string_of_jsbytes("case_sensitive")],
     _bW_=[0,caml_string_of_jsbytes("pattern")],
     _bR_=[0,caml_string_of_jsbytes("String.index_exn: not found")],
     _bS_=[0,caml_string_of_jsbytes("String.index_from_exn: not found")],
     _bT_=[0,caml_string_of_jsbytes("String.rindex_exn: not found")],
     _bU_=[0,caml_string_of_jsbytes("String.rindex_from_exn: not found")],
     _cd_=[0,caml_string_of_jsbytes("String.lsplit2_exn: not found")],
     _ce_=[0,caml_string_of_jsbytes("String.rsplit2_exn: not found")],
     _co_=[0,caml_string_of_jsbytes("src/bytes.ml"),128,2],
     _cn_=
      [0,
       [11,caml_string_of_jsbytes("Bytes.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Bytes.init %d")],
     _cm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _cF_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(".of_string: invalid input "),[3,0,0]]],
       caml_string_of_jsbytes("%s.of_string: invalid input %S")],
     _cp_=
      [0,
       [11,
        caml_string_of_jsbytes("conversion from "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" to "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" failed: "),
            [2,0,[11,caml_string_of_jsbytes(" is out of range"),0]]]]]]],
       caml_string_of_jsbytes
        ("conversion from %s to %s failed: %s is out of range")],
     _lB_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),19,9],
     _lA_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),75,9],
     _lz_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),96,9],
     _ly_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),148,9],
     _lx_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),176,9],
     _cI_=
      [0,
       2147483647,
       2147483647,
       46340,
       1290,
       215,
       73,
       35,
       21,
       14,
       10,
       8,
       7,
       5,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
     _lv_=[0,caml_string_of_jsbytes("src/pow_overflow_bounds.ml"),218,9],
     _cJ_=runtime.caml_int64_create_lo_mi_hi(16777215,127,0),
     _cK_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     _cL_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     _lw_=
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
     _cM_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
       runtime.caml_int64_create_lo_mi_hi(16777215,127,0),
       runtime.caml_int64_create_lo_mi_hi(1664510,0,0),
       runtime.caml_int64_create_lo_mi_hi(46340,0,0),
       runtime.caml_int64_create_lo_mi_hi(5404,0,0),
       runtime.caml_int64_create_lo_mi_hi(1290,0,0),
       runtime.caml_int64_create_lo_mi_hi(463,0,0),
       runtime.caml_int64_create_lo_mi_hi(215,0,0),
       runtime.caml_int64_create_lo_mi_hi(118,0,0),
       runtime.caml_int64_create_lo_mi_hi(73,0,0),
       runtime.caml_int64_create_lo_mi_hi(49,0,0),
       runtime.caml_int64_create_lo_mi_hi(35,0,0),
       runtime.caml_int64_create_lo_mi_hi(27,0,0),
       runtime.caml_int64_create_lo_mi_hi(21,0,0),
       runtime.caml_int64_create_lo_mi_hi(17,0,0),
       runtime.caml_int64_create_lo_mi_hi(14,0,0),
       runtime.caml_int64_create_lo_mi_hi(12,0,0),
       runtime.caml_int64_create_lo_mi_hi(10,0,0),
       runtime.caml_int64_create_lo_mi_hi(9,0,0),
       runtime.caml_int64_create_lo_mi_hi(8,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0)],
     _cN_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
       runtime.caml_int64_create_lo_mi_hi(324403,181,0),
       runtime.caml_int64_create_lo_mi_hi(2097151,0,0),
       runtime.caml_int64_create_lo_mi_hi(55108,0,0),
       runtime.caml_int64_create_lo_mi_hi(6208,0,0),
       runtime.caml_int64_create_lo_mi_hi(1448,0,0),
       runtime.caml_int64_create_lo_mi_hi(511,0,0),
       runtime.caml_int64_create_lo_mi_hi(234,0,0),
       runtime.caml_int64_create_lo_mi_hi(127,0,0),
       runtime.caml_int64_create_lo_mi_hi(78,0,0),
       runtime.caml_int64_create_lo_mi_hi(52,0,0),
       runtime.caml_int64_create_lo_mi_hi(38,0,0),
       runtime.caml_int64_create_lo_mi_hi(28,0,0),
       runtime.caml_int64_create_lo_mi_hi(22,0,0),
       runtime.caml_int64_create_lo_mi_hi(18,0,0),
       runtime.caml_int64_create_lo_mi_hi(15,0,0),
       runtime.caml_int64_create_lo_mi_hi(13,0,0),
       runtime.caml_int64_create_lo_mi_hi(11,0,0),
       runtime.caml_int64_create_lo_mi_hi(9,0,0),
       runtime.caml_int64_create_lo_mi_hi(8,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0)],
     _cO_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(1,0,32768),
       runtime.caml_int64_create_lo_mi_hi(1,0,32768),
       runtime.caml_int64_create_lo_mi_hi(16452813,16777034,65535),
       runtime.caml_int64_create_lo_mi_hi(14680065,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16722108,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16771008,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16775768,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16776705,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16776982,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777089,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777138,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777164,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777178,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777188,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777194,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777198,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777201,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777203,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777205,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777207,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777208,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777209,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777209,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777210,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777210,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535)],
     _c1_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" /"),
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: divisor should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s /%% %s in core_int.ml: divisor should be positive")],
     _c0_=
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s %% %s in core_int.ml: modulus should be positive")],
     _cX_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cY_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _cZ_=runtime.caml_int64_create_lo_mi_hi(63,0,0),
     _cR_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cS_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _cW_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _cT_=runtime.caml_int64_create_lo_mi_hi(63,0,0),
     _cU_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cV_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cQ_=
      [0,
       [11,caml_string_of_jsbytes("integer overflow in pow"),0],
       caml_string_of_jsbytes("integer overflow in pow")],
     _cP_=
      [0,
       [11,caml_string_of_jsbytes("exponent can not be negative"),0],
       caml_string_of_jsbytes("exponent can not be negative")],
     _lu_=[0,caml_string_of_jsbytes("src/popcount.ml"),45,9],
     _dm_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" /"),
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: divisor should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s /%% %s in core_int.ml: divisor should be positive")],
     _dl_=
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s %% %s in core_int.ml: modulus should be positive")],
     _c$_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _c__=[0,caml_string_of_jsbytes("src/int.ml"),108,2],
     _c9_=[0,[4,6,0,0,0],caml_string_of_jsbytes("%x")],
     _c8_=[0,[4,6,0,0,0],caml_string_of_jsbytes("%x")],
     _c6_=
      [0,
       [11,
        caml_string_of_jsbytes("Int.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int.of_float: argument (%f) is out of range or NaN")],
     _c5_=
      [0,
       [11,caml_string_of_jsbytes("Int.of_string: "),[3,0,0]],
       caml_string_of_jsbytes("Int.of_string: %S")],
     _dt_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Uchar.to_char_exn got a non latin-1 character: U+"),
        [4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes
        ("Uchar.to_char_exn got a non latin-1 character: U+%04X")],
     _ds_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Uchar.of_int_exn got a invalid Unicode scalar value: "),
        [4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes
        ("Uchar.of_int_exn got a invalid Unicode scalar value: %04X")],
     _dr_=
      [0,
       [11,caml_string_of_jsbytes("Uchar.pred_exn: "),[2,0,0]],
       caml_string_of_jsbytes("Uchar.pred_exn: %s")],
     _dq_=
      [0,
       [11,caml_string_of_jsbytes("Uchar.succ_exn: "),[2,0,0]],
       caml_string_of_jsbytes("Uchar.succ_exn: %s")],
     _do_=
      [0,
       [11,caml_string_of_jsbytes("U+"),[4,8,0,0,0]],
       caml_string_of_jsbytes("U+%X")],
     _dn_=
      [0,
       [11,caml_string_of_jsbytes("U+"),[4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes("U+%04X")],
     _dx_=[0,caml_string_of_jsbytes("witness")],
     _dy_=[0,caml_string_of_jsbytes("name")],
     _dw_=[0,caml_string_of_jsbytes("type_witness")],
     _dv_=[0,0,0],
     _du_=[0,caml_string_of_jsbytes("T")],
     _dY_=[0,caml_string_of_jsbytes("src/stack.ml"),107,14],
     _dK_=[0,caml_string_of_jsbytes("src/stack.ml"),39,4],
     _dJ_=[0,caml_string_of_jsbytes("src/stack.ml"),46,6],
     _dH_=[0,caml_string_of_jsbytes("elts")],
     _dI_=[0,caml_string_of_jsbytes("length")],
     _dZ_=[0,caml_string_of_jsbytes("Neg")],
     _d0_=[0,caml_string_of_jsbytes("Zero")],
     _d1_=[0,caml_string_of_jsbytes("Pos")],
     _d2_=[0,caml_string_of_jsbytes("Nan")],
     _d9_=[0,caml_string_of_jsbytes("Below_lower_bound")],
     _d__=[0,caml_string_of_jsbytes("In_range")],
     _d$_=[0,caml_string_of_jsbytes("Above_upper_bound")],
     _d8_=[0,[1,[0,caml_string_of_jsbytes("Unbounded"),0]],0],
     _d5_=[0,caml_string_of_jsbytes("Unbounded")],
     _d6_=[0,caml_string_of_jsbytes("Incl")],
     _d7_=[0,caml_string_of_jsbytes("Excl")],
     _d4_=[0,0,0],
     _ek_=[0,caml_string_of_jsbytes("Unfinished")],
     _el_=[0,caml_string_of_jsbytes("Finished")],
     _ei_=[0,caml_string_of_jsbytes("Stop")],
     _ej_=[0,caml_string_of_jsbytes("Continue")],
     _eg_=[0,caml_string_of_jsbytes("Left")],
     _eh_=[0,caml_string_of_jsbytes("Right")],
     _ef_=[0,caml_string_of_jsbytes("Both")],
     _ed_=[0,caml_string_of_jsbytes("Unequal")],
     _ee_=[0,caml_string_of_jsbytes("Right")],
     _ec_=[0,caml_string_of_jsbytes("Left")],
     _ea_=[0,caml_string_of_jsbytes("Duplicate")],
     _eb_=[0,caml_string_of_jsbytes("Ok")],
     _eF_=[0,caml_string_of_jsbytes("_")],
     _eE_=[0,0],
     _eD_=[0,caml_string_of_jsbytes("src/set.ml"),1047,8],
     _eB_=[0,0,0],
     _eA_=[0,0,0,0],
     _ey_=
      [0,caml_string_of_jsbytes("set.ml.Tree0.Set_max_elt_exn_of_empty_set")],
     _ez_=[0,caml_string_of_jsbytes("src/set.ml"),309,15],
     _ev_=
      [0,caml_string_of_jsbytes("set.ml.Tree0.Set_min_elt_exn_of_empty_set")],
     _ew_=[0,caml_string_of_jsbytes("src/set.ml"),296,15],
     _em_=[0,caml_string_of_jsbytes("src/set.ml"),199,17],
     _en_=[0,caml_string_of_jsbytes("src/set.ml"),200,18],
     _eo_=[0,caml_string_of_jsbytes("src/set.ml"),206,21],
     _ep_=[0,caml_string_of_jsbytes("src/set.ml"),208,12],
     _eq_=[0,caml_string_of_jsbytes("src/set.ml"),214,17],
     _er_=[0,caml_string_of_jsbytes("src/set.ml"),215,18],
     _es_=[0,caml_string_of_jsbytes("src/set.ml"),221,21],
     _et_=[0,caml_string_of_jsbytes("src/set.ml"),223,12],
     _eC_=[0,caml_string_of_jsbytes("Set.choose_exn: empty set")],
     _eV_=[0,caml_string_of_jsbytes("src/queue.ml"),451,2],
     _eU_=[0,caml_string_of_jsbytes("src/queue.ml"),193,2],
     _eT_=[0,caml_string_of_jsbytes("src/queue.ml"),152,2],
     _eS_=[0,caml_string_of_jsbytes("src/queue.ml"),153,2],
     _eR_=[0,caml_string_of_jsbytes("src/queue.ml"),155,2],
     _eQ_=[0,caml_string_of_jsbytes("src/queue.ml"),156,2],
     _eP_=[0,caml_string_of_jsbytes("src/queue.ml"),157,2],
     _eO_=[0,caml_string_of_jsbytes("src/queue.ml"),158,2],
     _eN_=[0,caml_string_of_jsbytes("src/queue.ml"),159,2],
     _eM_=[0,caml_string_of_jsbytes("src/queue.ml"),165,9],
     _eL_=[0,caml_string_of_jsbytes("_")],
     _eG_=[0,caml_string_of_jsbytes("elts")],
     _eH_=[0,caml_string_of_jsbytes("length")],
     _eI_=[0,caml_string_of_jsbytes("mask")],
     _eJ_=[0,caml_string_of_jsbytes("front")],
     _eK_=[0,caml_string_of_jsbytes("num_mutations")],
     _eW_=[0,caml_string_of_jsbytes("src/nothing.ml"),6,25],
     _e3_=[0,caml_string_of_jsbytes("src/nativeint.ml"),202,2],
     _e2_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _e1_=
      [0,
       [11,
        caml_string_of_jsbytes("Nativeint.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Nativeint.of_float: argument (%f) is out of range or NaN")],
     _eZ_=[0,[6,6,0,0,0],caml_string_of_jsbytes("%nx")],
     _eY_=[0,[6,6,0,0,0],caml_string_of_jsbytes("%nx")],
     _fu_=[0,caml_string_of_jsbytes("_")],
     _ft_=
      [0,
       caml_string_of_jsbytes("Map.Build_increasing.add: non-increasing key")],
     _fs_=[0,0,0],
     _fb_=[0,0,0,0],
     _fp_=[0,0],
     _fr_=[0,caml_string_of_jsbytes("src/map.ml"),1639,6],
     _fq_=[0,0],
     _fo_=[0,[0,0,0],[0,0,0]],
     _fn_=[0,0,0],
     _fm_=[0,0,0],
     _fl_=[0,0,0],
     _fk_=[0,0,0],
     _fj_=[0,0,0],
     _fh_=
      [0,caml_string_of_jsbytes("map.ml.Tree0.Map_max_elt_exn_of_empty_map")],
     _fi_=[0,caml_string_of_jsbytes("src/map.ml"),547,15],
     _fe_=
      [0,caml_string_of_jsbytes("map.ml.Tree0.Map_min_elt_exn_of_empty_map")],
     _ff_=[0,caml_string_of_jsbytes("src/map.ml"),534,15],
     _fc_=[0,caml_string_of_jsbytes("Map.find_exn: not found")],
     _fa_=[1,0],
     _e__=[0,caml_string_of_jsbytes("src/map.ml"),196,18],
     _e$_=[0,caml_string_of_jsbytes("src/map.ml"),210,18],
     _e8_=[0,caml_string_of_jsbytes("map.ml.Duplicate")],
     _e9_=[0,caml_string_of_jsbytes("src/map.ml"),67,11],
     _fA_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fz_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fy_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _fx_=[0,caml_string_of_jsbytes("src/int64.ml"),100,2],
     _fw_=
      [0,
       [11,
        caml_string_of_jsbytes("Int64.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int64.of_float: argument (%f) is out of range or NaN")],
     _fQ_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fP_=[0,caml_string_of_jsbytes("src/int63_emul.ml"),317,2],
     _fN_=
      [0,
       [11,
        caml_string_of_jsbytes("Int63.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int63.of_float: argument (%f) is out of range or NaN")],
     _fM_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _fL_=
      [0,
       [11,caml_string_of_jsbytes("Int63.of_string: invalid input "),[3,0,0]],
       caml_string_of_jsbytes("Int63.of_string: invalid input %S")],
     _fI_=[0,caml_string_of_jsbytes("src/int63_emul.ml"),114,20],
     _fH_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fG_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fF_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fE_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fJ_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _f2_=[0,caml_string_of_jsbytes("src/bool.ml"),56,2],
     _f1_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Bool.of_string: expected true or false but got "),
        [2,0,0]],
       caml_string_of_jsbytes
        ("Bool.of_string: expected true or false but got %s")],
     _f8_=[0,[5,6,0,0,0],caml_string_of_jsbytes("%lx")],
     _f7_=[0,[5,6,0,0,0],caml_string_of_jsbytes("%lx")],
     _f6_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _f5_=[0,caml_string_of_jsbytes("src/int32.ml"),97,4],
     _f4_=
      [0,
       [11,
        caml_string_of_jsbytes("Int32.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int32.of_float: argument (%f) is out of range or NaN")],
     _kL_=[0,caml_string_of_jsbytes("src/int63.ml"),155,9],
     _h5_=[0,caml_string_of_jsbytes("src/avltree.ml"),417,15],
     _h6_=[0,caml_string_of_jsbytes("src/avltree.ml"),436,18],
     _h4_=[0,caml_string_of_jsbytes("src/avltree.ml"),205,9],
     _h3_=[0,caml_string_of_jsbytes("src/avltree.ml"),193,9],
     _h0_=[0,caml_string_of_jsbytes("src/avltree.ml"),129,30],
     _hZ_=[0,caml_string_of_jsbytes("src/avltree.ml"),110,26],
     _h2_=[0,caml_string_of_jsbytes("src/avltree.ml"),163,30],
     _h1_=[0,caml_string_of_jsbytes("src/avltree.ml"),145,26],
     _hY_=[0,caml_string_of_jsbytes("src/avltree.ml"),87,22],
     _hX_=[0,caml_string_of_jsbytes("src/avltree.ml"),66,6],
     _hW_=[0,caml_string_of_jsbytes("src/avltree.ml"),67,6],
     _hV_=[0,caml_string_of_jsbytes("src/avltree.ml"),56,6],
     _hU_=[0,caml_string_of_jsbytes("src/avltree.ml"),50,6],
     _h9_=[0,caml_string_of_jsbytes("src/hashtbl.ml"),575,4],
     _h8_=[0,caml_string_of_jsbytes("Hashtbl.find_exn: not found")],
     _h7_=[0,caml_string_of_jsbytes("src/hashtbl.ml"),323,2],
     _ic_=[0,0],
     _ib_=[0,0],
     _ia_=[0,0],
     _iS_=[0,[8,[0,0,4],0,[0,8],0],caml_string_of_jsbytes("%.8G")],
     _iQ_=
      [0,
       [11,
        caml_string_of_jsbytes("exponent "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" out of range [0, "),[4,0,0,0,[12,93,0]]]]],
       caml_string_of_jsbytes("exponent %d out of range [0, %d]")],
     _iR_=
      [0,
       [11,
        caml_string_of_jsbytes("mantissa "),
        [2,
         0,
         [11,caml_string_of_jsbytes(" out of range [0, "),[2,0,[12,93,0]]]]],
       caml_string_of_jsbytes("mantissa %s out of range [0, %s]")],
     _iP_=[0,caml_string_of_jsbytes("src/float.ml"),859,2],
     _iO_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.round_significant: invalid argument significant_digits:"),
        [4,0,0,0,0]],
       caml_string_of_jsbytes
        ("Float.round_significant: invalid argument significant_digits:%d")],
     _iN_=[0,[8,[0,0,3],0,1,0],caml_string_of_jsbytes("%.*g")],
     _iM_=[0,caml_string_of_jsbytes("p")],
     _iJ_=[0,caml_string_of_jsbytes("src/float.ml"),697,8],
     _iI_=[0,caml_string_of_jsbytes("src/float.ml"),700,8],
     _iE_=[0,caml_string_of_jsbytes("src/float.ml"),707,8],
     _iF_=[0,caml_string_of_jsbytes("src/float.ml"),708,8],
     _iG_=
      [0,[2,0,[4,0,0,0,[2,0,[12,32,0]]]],caml_string_of_jsbytes("%s%d%s ")],
     _iH_=
      [0,[2,0,[4,0,0,0,[2,0,[4,0,0,0,0]]]],caml_string_of_jsbytes("%s%d%s%d")],
     _iD_=[0,caml_string_of_jsbytes("src/float.ml"),684,8],
     _iK_=[0,[2,0,[8,[0,0,1],0,[0,1],0]],caml_string_of_jsbytes("%s%.1e")],
     _iL_=[0,[2,0,[8,[0,0,1],0,[0,1],0]],caml_string_of_jsbytes("%s%.1e")],
     _iA_=
      [0,
       [11,
        caml_string_of_jsbytes("to_string_hum: invalid argument ~decimals="),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("to_string_hum: invalid argument ~decimals=%d")],
     _iB_=[0,[8,[0,1,0],0,1,0],caml_string_of_jsbytes("%+.*f")],
     _iC_=[0,[8,[0,0,0],0,1,0],caml_string_of_jsbytes("%.*f")],
     _iv_=[0,caml_string_of_jsbytes("Infinite")],
     _iw_=[0,caml_string_of_jsbytes("Nan")],
     _ix_=[0,caml_string_of_jsbytes("Normal")],
     _iy_=[0,caml_string_of_jsbytes("Subnormal")],
     _iz_=[0,caml_string_of_jsbytes("Zero")],
     _it_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.int63_round_nearest_portable_alloc_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large")],
     _iu_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.int63_round_nearest_portable_alloc_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN")],
     _ir_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_down_exn: argument (%f) is too large")],
     _is_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_down_exn: argument (%f) is too small or NaN")],
     _ip_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_up_exn: argument (%f) is too large")],
     _iq_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_up_exn: argument (%f) is too small or NaN")],
     _in_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too large")],
     _io_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too small or NaN")],
     _il_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too large")],
     _im_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too small")],
     _ik_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_towards_zero_exn: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_towards_zero_exn: argument (%f) is out of range or NaN")],
     _ii_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_down_exn: argument (%f) is too large")],
     _ij_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_down_exn: argument (%f) is too small or NaN")],
     _ig_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_up_exn: argument (%f) is too large")],
     _ih_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_up_exn: argument (%f) is too small or NaN")],
     _if_=
      [0,
       [11,caml_string_of_jsbytes("Float.of_string "),[2,0,0]],
       caml_string_of_jsbytes("Float.of_string %s")];
    function descending(x,y){return caml_compare(y,x)}
    var
     max=Caml[17],
     min=Caml[16],
     ascending=caml_compare,
     include=[0,ascending,descending,min,max];
    caml_register_global(972,include,"Base__Poly0");
    var
     Exit=include$0[3],
     Not_found=include$0[4],
     max_int=include$0[8],
     min_int=include$0[9],
     infinity=include$0[11],
     neg_infinity=include$0[12],
     nan=include$0[13],
     max_float=include$0[14],
     min_float=include$0[15],
     epsilon_float=include$0[16],
     char_of_int=include$0[18],
     string_of_bool=include$0[19],
     bool_of_string_opt=include$0[20],
     bool_of_string=include$0[21],
     string_of_int=include$0[22],
     int_of_string_opt=include$0[23],
     string_of_float=include$0[24],
     float_of_string_opt=include$0[25],
     stdin=include$0[27],
     stdout=include$0[28],
     stderr=include$0[29],
     print_char=include$0[30],
     print_string=include$0[31],
     print_bytes=include$0[32],
     print_int=include$0[33],
     print_float=include$0[34],
     print_endline=include$0[35],
     print_newline=include$0[36],
     prerr_char=include$0[37],
     prerr_string=include$0[38],
     prerr_bytes=include$0[39],
     prerr_int=include$0[40],
     prerr_float=include$0[41],
     prerr_endline=include$0[42],
     prerr_newline=include$0[43],
     read_line=include$0[44],
     read_int_opt=include$0[45],
     read_int=include$0[46],
     read_float_opt=include$0[47],
     read_float=include$0[48],
     open_out=include$0[49],
     open_out_bin=include$0[50],
     open_out_gen=include$0[51],
     flush=include$0[52],
     flush_all=include$0[53],
     output_char=include$0[54],
     output_string=include$0[55],
     output_bytes=include$0[56],
     output=include$0[57],
     output_substring=include$0[58],
     output_byte=include$0[59],
     output_binary_int=include$0[60],
     output_value=include$0[61],
     seek_out=include$0[62],
     pos_out=include$0[63],
     out_channel_length=include$0[64],
     close_out=include$0[65],
     close_out_noerr=include$0[66],
     set_binary_mode_out=include$0[67],
     open_in=include$0[68],
     open_in_bin=include$0[69],
     open_in_gen=include$0[70],
     input_char=include$0[71],
     input_line=include$0[72],
     input=include$0[73],
     really_input=include$0[74],
     really_input_string=include$0[75],
     input_byte=include$0[76],
     input_binary_int=include$0[77],
     input_value=include$0[78],
     seek_in=include$0[79],
     pos_in=include$0[80],
     in_channel_length=include$0[81],
     close_in=include$0[82],
     close_in_noerr=include$0[83],
     set_binary_mode_in=include$0[84],
     string_of_format=include$0[85],
     symbol=include$0[86],
     exit=include$0[87],
     at_exit=include$0[88],
     valid_float_lexem=include$0[89],
     unsafe_really_input=include$0[90],
     do_at_exit=include$0[91],
     invalid_arg=Caml[1],
     failwith=Caml[2],
     Exit$0=Caml[3],
     Match_failure=Caml[4],
     Assert_failure=Caml[5],
     Invalid_argument=Caml[6],
     Failure=Caml[7],
     Out_of_memory=Caml[9],
     Stack_overflow=Caml[10],
     Sys_error=Caml[11],
     End_of_file=Caml[12],
     Division_by_zero=Caml[13],
     Sys_blocked_io=Caml[14],
     Undefined_recursive_module=Caml[15],
     min$0=Caml[16],
     max$0=Caml[17],
     abs=Caml[18],
     max_int$0=Caml[19],
     min_int$0=Caml[20],
     lnot=Caml[21],
     infinity$0=Caml[22],
     neg_infinity$0=Caml[23],
     nan$0=Caml[24],
     max_float$0=Caml[25],
     min_float$0=Caml[26],
     epsilon_float$0=Caml[27],
     symbol$0=Caml[28],
     char_of_int$0=Caml[29],
     string_of_bool$0=Caml[30],
     bool_of_string_opt$0=Caml[31],
     bool_of_string$0=Caml[32],
     string_of_int$0=Caml[33],
     int_of_string_opt$0=Caml[34],
     string_of_float$0=Caml[35],
     float_of_string_opt$0=Caml[36],
     symbol$1=Caml[37],
     stdin$0=Caml[38],
     stdout$0=Caml[39],
     stderr$0=Caml[40],
     print_char$0=Caml[41],
     print_string$0=Caml[42],
     print_bytes$0=Caml[43],
     print_int$0=Caml[44],
     print_float$0=Caml[45],
     print_endline$0=Caml[46],
     print_newline$0=Caml[47],
     prerr_char$0=Caml[48],
     prerr_string$0=Caml[49],
     prerr_bytes$0=Caml[50],
     prerr_int$0=Caml[51],
     prerr_float$0=Caml[52],
     prerr_endline$0=Caml[53],
     prerr_newline$0=Caml[54],
     read_line$0=Caml[55],
     read_int_opt$0=Caml[56],
     read_int$0=Caml[57],
     read_float_opt$0=Caml[58],
     read_float$0=Caml[59],
     open_out$0=Caml[60],
     open_out_bin$0=Caml[61],
     open_out_gen$0=Caml[62],
     flush$0=Caml[63],
     flush_all$0=Caml[64],
     output_char$0=Caml[65],
     output_string$0=Caml[66],
     output_bytes$0=Caml[67],
     output$0=Caml[68],
     output_substring$0=Caml[69],
     output_byte$0=Caml[70],
     output_binary_int$0=Caml[71],
     output_value$0=Caml[72],
     seek_out$0=Caml[73],
     pos_out$0=Caml[74],
     out_channel_length$0=Caml[75],
     close_out$0=Caml[76],
     close_out_noerr$0=Caml[77],
     set_binary_mode_out$0=Caml[78],
     open_in$0=Caml[79],
     open_in_bin$0=Caml[80],
     open_in_gen$0=Caml[81],
     input_char$0=Caml[82],
     input_line$0=Caml[83],
     input$0=Caml[84],
     really_input$0=Caml[85],
     really_input_string$0=Caml[86],
     input_byte$0=Caml[87],
     input_binary_int$0=Caml[88],
     input_value$0=Caml[89],
     seek_in$0=Caml[90],
     pos_in$0=Caml[91],
     in_channel_length$0=Caml[92],
     close_in$0=Caml[93],
     close_in_noerr$0=Caml[94],
     set_binary_mode_in$0=Caml[95],
     LargeFile=Caml[96],
     string_of_format$0=Caml[97],
     symbol$2=Caml[98],
     exit$0=Caml[99],
     at_exit$0=Caml[100],
     valid_float_lexem$0=Caml[101],
     unsafe_really_input$0=Caml[102],
     do_at_exit$0=Caml[103],
     Not_found$0=Caml[8],
     Caml$0=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min$0,
       max$0,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       Not_found$0];
    function bool_to_int(x){return x}
    function symbol$3(_NC_,_NB_){return _NC_ !== _NB_?1:0}
    var symbol$4=caml_mul;
    function symbol$5(_NA_,_Nz_){return Math.pow(_NA_,_Nz_)}
    function scale(_Ny_,_Nx_){return _Ny_ * _Nx_}
    function symbol$6(_Nw_,_Nv_){return _Nw_ + _Nv_ | 0}
    function add(_Nu_,_Nt_){return _Nu_ + _Nt_}
    function symbol$7(_Ns_,_Nr_){return _Ns_ - _Nr_ | 0}
    function sub(_Nq_,_Np_){return _Nq_ - _Np_}
    var symbol$8=caml_div;
    function symbol$9(_No_,_Nn_){return _No_ / _Nn_}
    var ascending$0=caml_int_compare;
    function descending$0(x,y){return caml_int_compare(y,x)}
    function max$1(x,y){return y <= x?x:y}
    function min$1(x,y){return x <= y?x:y}
    var
     include$1=[0,ascending$0,descending$0,max$1,min$1],
     _a_=include$1[1],
     _b_=include$1[2],
     max$2=include$1[3],
     min$2=include$1[4];
    function symbol$10(x,y){return caml_lessthan(x,y)}
    function symbol$11(x,y){return caml_lessequal(x,y)}
    function symbol$12(x,y){return caml_notequal(x,y)}
    function symbol$13(x,y){return caml_equal(x,y)}
    function symbol$14(x,y){return caml_greaterthan(x,y)}
    function symbol$15(x,y){return caml_greaterequal(x,y)}
    var ascending$1=caml_compare;
    function descending$1(x,y){return caml_compare(y,x)}
    function compare(x,y){return caml_int_compare(x,y)}
    function equal(x,y){return caml_equal(x,y)}
    function max$3(x,y){return caml_greaterequal(x,y)?x:y}
    function min$3(x,y){return caml_lessequal(x,y)?x:y}
    var
     Int32_replace_polymorphic_comp=
      [0,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$3,
       min$3],
     ascending$2=caml_compare;
    function descending$2(x,y){return caml_compare(y,x)}
    function max$4(x,y){return caml_greaterequal(x,y)?x:y}
    function min$4(x,y){return caml_lessequal(x,y)?x:y}
    var include$2=[0,ascending$2,descending$2,max$4,min$4];
    function symbol$16(x,y){return caml_lessthan(x,y)}
    function symbol$17(x,y){return caml_lessequal(x,y)}
    function symbol$18(x,y){return caml_notequal(x,y)}
    function symbol$19(x,y){return caml_equal(x,y)}
    function symbol$20(x,y){return caml_greaterthan(x,y)}
    function symbol$21(x,y){return caml_greaterequal(x,y)}
    var ascending$3=caml_compare;
    function descending$3(x,y){return caml_compare(y,x)}
    function compare$0(x,y){return caml_int_compare(x,y)}
    function equal$0(x,y){return caml_equal(x,y)}
    function max$5(x,y){return caml_greaterequal(x,y)?x:y}
    function min$5(x,y){return caml_lessequal(x,y)?x:y}
    var
     include$3=
      [0,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$5,
       min$5];
    function symbol$22(x,y){return x < y?1:0}
    function symbol$23(x,y){return x <= y?1:0}
    function symbol$24(x,y){return x !== y?1:0}
    function symbol$25(x,y){return x === y?1:0}
    function symbol$26(x,y){return y < x?1:0}
    function symbol$27(x,y){return y <= x?1:0}
    var ascending$4=caml_compare;
    function descending$4(x,y){return caml_compare(y,x)}
    var compare$1=caml_int_compare;
    function equal$1(x,y){return x === y?1:0}
    function max$6(x,y){return y <= x?x:y}
    function min$6(x,y){return x <= y?x:y}
    var
     include$4=
      [0,
       symbol$22,
       symbol$23,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$6,
       min$6];
    function symbol$28(x,y){return x < y?1:0}
    function symbol$29(x,y){return x <= y?1:0}
    function symbol$30(x,y){return x !== y?1:0}
    function symbol$31(x,y){return x === y?1:0}
    function symbol$32(x,y){return y < x?1:0}
    function symbol$33(x,y){return y <= x?1:0}
    var ascending$5=caml_compare;
    function descending$5(x,y){return caml_compare(y,x)}
    var compare$2=caml_int_compare;
    function equal$2(x,y){return x === y?1:0}
    function max$7(x,y){return y <= x?x:y}
    function min$7(x,y){return x <= y?x:y}
    var
     include$5=
      [0,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$7,
       min$7];
    function i(x){return caml_call1(Stdlib_Uchar[10],x)}
    function symbol$34(x,y){var _Nm_=i(y);return i(x) < _Nm_?1:0}
    function symbol$35(x,y){var _Nl_=i(y);return i(x) <= _Nl_?1:0}
    function symbol$36(x,y){var _Nk_=i(y);return i(x) !== _Nk_?1:0}
    function symbol$37(x,y){var _Nj_=i(y);return i(x) === _Nj_?1:0}
    function symbol$38(x,y){var _Ni_=i(y);return _Ni_ < i(x)?1:0}
    function symbol$39(x,y){var _Nh_=i(y);return _Nh_ <= i(x)?1:0}
    function ascending$6(x,y)
     {var _Nf_=i(y),_Ng_=i(x);return caml_call2(include$1[1],_Ng_,_Nf_)}
    function descending$6(x,y)
     {var _Nd_=i(y),_Ne_=i(x);return caml_call2(include$1[2],_Ne_,_Nd_)}
    function compare$3(x,y){var _Nc_=i(y);return caml_int_compare(i(x),_Nc_)}
    function equal$3(x,y){var _Nb_=i(y);return i(x) === _Nb_?1:0}
    function max$8(x,y){return symbol$39(x,y)?x:y}
    function min$8(x,y){return symbol$35(x,y)?x:y}
    var
     include$6=
      [0,
       i,
       symbol$34,
       symbol$35,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$8,
       min$8];
    function symbol$40(x,y){return x < y?1:0}
    function symbol$41(x,y){return x <= y?1:0}
    function symbol$42(x,y){return x != y?1:0}
    function symbol$43(x,y){return x == y?1:0}
    function symbol$44(x,y){return y < x?1:0}
    function symbol$45(x,y){return y <= x?1:0}
    var ascending$7=caml_compare;
    function descending$7(x,y){return caml_compare(y,x)}
    var compare$4=caml_float_compare;
    function equal$4(x,y){return x == y?1:0}
    function max$9(x,y){return y <= x?x:y}
    function min$9(x,y){return x <= y?x:y}
    var
     include$7=
      [0,
       symbol$40,
       symbol$41,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$9,
       min$9];
    function symbol$46(x,y){return runtime.caml_string_lessthan(x,y)}
    function symbol$47(x,y){return caml_string_lessequal(x,y)}
    function symbol$48(x,y){return caml_string_notequal(x,y)}
    function symbol$49(x,y){return caml_string_equal(x,y)}
    function symbol$50(x,y){return runtime.caml_string_greaterthan(x,y)}
    function symbol$51(x,y){return caml_string_greaterequal(x,y)}
    var ascending$8=caml_compare;
    function descending$8(x,y){return caml_compare(y,x)}
    function compare$5(x,y){return caml_string_compare(x,y)}
    function equal$5(x,y){return caml_string_equal(x,y)}
    function max$10(x,y){return caml_string_greaterequal(x,y)?x:y}
    function min$10(x,y){return caml_string_lessequal(x,y)?x:y}
    var
     include$8=
      [0,
       symbol$46,
       symbol$47,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$10,
       min$10];
    function symbol$52(x,y){return runtime.caml_bytes_lessthan(x,y)}
    function symbol$53(x,y){return caml_bytes_lessequal(x,y)}
    function symbol$54(x,y){return runtime.caml_bytes_notequal(x,y)}
    function symbol$55(x,y){return caml_bytes_equal(x,y)}
    function symbol$56(x,y){return runtime.caml_bytes_greaterthan(x,y)}
    function symbol$57(x,y){return caml_bytes_greaterequal(x,y)}
    var ascending$9=caml_compare;
    function descending$9(x,y){return caml_compare(y,x)}
    function compare$6(x,y){return runtime.caml_bytes_compare(x,y)}
    function equal$6(x,y){return caml_bytes_equal(x,y)}
    function max$11(x,y){return caml_bytes_greaterequal(x,y)?x:y}
    function min$11(x,y){return caml_bytes_lessequal(x,y)?x:y}
    var
     include$9=
      [0,
       symbol$52,
       symbol$53,
       symbol$54,
       symbol$55,
       symbol$56,
       symbol$57,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$11,
       min$11],
     symbol$58=Caml$0[36],
     symbol$59=Caml$0[27];
    function neg(_Na_){return - _Na_ | 0}
    function neg$0(_M$_){return - _M$_}
    function asr(_M__,_M9_){return _M__ >> _M9_}
    function land(_M8_,_M7_){return _M8_ & _M7_}
    var lnot$0=Caml$0[20];
    function lor(_M6_,_M5_){return _M6_ | _M5_}
    function lsl(_M4_,_M3_){return _M4_ << _M3_}
    function lsr(_M2_,_M1_){return _M2_ >>> _M1_ | 0}
    function lxor(_M0_,_MZ_){return _M0_ ^ _MZ_}
    var mod=caml_mod,abs$0=Caml$0[17],failwith$0=Caml$0[2];
    function get_key(_MY_){return _MY_[1]}
    var invalid_arg$0=Caml$0[1];
    function get_data(_MX_){return _MX_[2]}
    function phys_equal(_MW_,_MV_){return _MW_ === _MV_?1:0}
    function decr(_MU_){_MU_[1] += -1;return 0}
    function incr(_MT_){_MT_[1]++;return 0}
    var
     float_of_string=caml_float_of_string,
     am_testing=runtime.Base_am_testing(0),
     Base_Import0=
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       scale,
       symbol$6,
       add,
       symbol$7,
       sub,
       symbol$8,
       symbol$9,
       include$1,
       _a_,
       _b_,
       max$2,
       min$2,
       Int32_replace_polymorphic_comp,
       include$2,
       include$3,
       include$4,
       include$5,
       include$6,
       include$7,
       include$8,
       include$9,
       symbol$58,
       symbol$59,
       neg,
       neg$0,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       get_key,
       invalid_arg$0,
       get_data,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
    caml_register_global(975,Base_Import0,"Base__Import0");
    var
     sprintf=Stdlib_Printf[4],
     bprintf=Stdlib_Printf[5],
     ifprintf=Stdlib_Printf[6],
     ksprintf=Stdlib_Printf[10],
     kbprintf=Stdlib_Printf[11];
    function failwithf(fmt)
     {return caml_call2
              (ksprintf,
               function(s,param){return caml_call1(failwith$0,s)},
               fmt)}
    function invalid_argf(fmt)
     {return caml_call2
              (ksprintf,
               function(s,param){return caml_call1(invalid_arg$0,s)},
               fmt)}
    var
     Base_Printf=
      [0,ifprintf,sprintf,bprintf,ksprintf,kbprintf,failwithf,invalid_argf];
    caml_register_global(977,Base_Printf,"Base__Printf");
    var
     backend_type=Stdlib_Sys[5],
     interactive=Stdlib_Sys[3],
     os_type=Stdlib_Sys[4],
     unix=Stdlib_Sys[6],
     win32=Stdlib_Sys[7],
     cygwin=Stdlib_Sys[8],
     word_size_in_bits=Stdlib_Sys[9],
     num_bits=Stdlib_Sys[10],
     big_endian=Stdlib_Sys[11],
     max_length=Stdlib_Sys[12],
     max_length$0=Stdlib_Sys[13],
     runtime_variant=runtime.caml_runtime_variant,
     runtime_parameters=runtime.caml_runtime_parameters,
     argv=caml_sys_argv(0);
    function get_argv(param){return caml_sys_argv(0)}
    var
     ocaml_version=Stdlib_Sys[46],
     enable_runtime_warnings=Stdlib_Sys[49],
     runtime_warnings_enabled=Stdlib_Sys[50];
    function getenv_exn(var$0)
     {try
       {var _MR_=caml_sys_getenv(var$0);return _MR_}
      catch(_MS_)
       {_MS_ = caml_wrap_exception(_MS_);
        if(_MS_ === Caml$0[103])return caml_call2(failwithf(_c_),var$0,0);
        throw _MS_}}
    function getenv(var$0)
     {try
       {var x=caml_sys_getenv(var$0)}
      catch(_MQ_)
       {_MQ_ = caml_wrap_exception(_MQ_);
        if(_MQ_ === Caml$0[103])return 0;
        throw _MQ_}
      return [0,x]}
    var
     Break=Stdlib_Sys[44],
     include$10=
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       num_bits,
       big_endian,
       max_length,
       max_length$0,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
    caml_register_global(979,include$10,"Base__Sys0");
    var Array=[0];
    function create(len,x){return caml_make_vect(len,x)}
    function create_float_uninitialized(len)
     {return runtime.caml_make_float_vect(len)}
    var
     append=Stdlib_ArrayLabels[5],
     blit=Stdlib_ArrayLabels[10],
     concat=Stdlib_ArrayLabels[6],
     copy=Stdlib_ArrayLabels[8],
     fill=Stdlib_ArrayLabels[9],
     init=Stdlib_ArrayLabels[2],
     make_matrix=Stdlib_ArrayLabels[3],
     of_list=Stdlib_ArrayLabels[12],
     sub$0=Stdlib_ArrayLabels[7],
     to_list=Stdlib_ArrayLabels[11];
    function fold(t,init,f)
     {return caml_call3(Stdlib_ArrayLabels[17],f,init,t)}
    function fold_right(t,f,init)
     {return caml_call3(Stdlib_ArrayLabels[19],f,t,init)}
    function iter(t,f){return caml_call2(Stdlib_ArrayLabels[13],f,t)}
    function iteri(t,f){return caml_call2(Stdlib_ArrayLabels[14],f,t)}
    function map(t,f){return caml_call2(Stdlib_ArrayLabels[15],f,t)}
    function mapi(t,f){return caml_call2(Stdlib_ArrayLabels[16],f,t)}
    function stable_sort(t,compare)
     {return caml_call2(Stdlib_ArrayLabels[33],compare,t)}
    function swap(t,i,j)
     {var
       elt_i=caml_check_bound(t,i)[1 + i],
       elt_j=caml_check_bound(t,j)[1 + j];
      t[1 + i] = elt_j;
      t[1 + j] = elt_i;
      return 0}
    var
     include$11=
      [0,
       invalid_argf,
       Array,
       max_length$0,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub$0,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
    caml_register_global(982,include$11,"Base__Array0");
    var _d_=Stdlib_Char[2],_e_=Stdlib_Char[5];
    function to_int(_MP_){return _MP_}
    function unsafe_of_int(_MO_){return _MO_}
    var _f_=Stdlib_Char[6];
    function int_is_ok(i)
     {var _MM_=0 <= i?1:0,_MN_=_MM_?i <= 255?1:0:_MM_;return _MN_}
    var min_value=0,max_value=255;
    function of_int(i){return int_is_ok(i)?[0,i]:0}
    function of_int_exn(i)
     {return int_is_ok(i)?i:caml_call2(failwithf(_g_),i,0)}
    function equal$7(t1,t2){return t1 === t2?1:0}
    var
     include$12=
      [0,
       failwithf,
       _d_,
       _e_,
       to_int,
       unsafe_of_int,
       _f_,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal$7];
    caml_register_global(984,include$12,"Base__Char0");
    var Base_Hash_intf=[0];
    caml_register_global(985,Base_Hash_intf,"Base__Hash_intf");
    var to_string=Caml[33],of_string=caml_int_of_string;
    function to_float(_ML_){return _ML_}
    function of_float(_MK_){return _MK_ | 0}
    var max_value$0=Caml[19],min_value$0=Caml[20];
    function succ(_MJ_){return _MJ_ + 1 | 0}
    var
     include$13=
      [0,to_string,of_string,to_float,of_float,max_value$0,min_value$0,succ];
    caml_register_global(986,include$13,"Base__Int0");
    var
     hd_exn=Stdlib_ListLabels[5],
     length=Stdlib_ListLabels[1],
     rev_append=Stdlib_ListLabels[12],
     tl_exn=Stdlib_ListLabels[6],
     unzip=Stdlib_ListLabels[54];
    function exists(t,f){return caml_call2(Stdlib_ListLabels[33],f,t)}
    function exists2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[35],f,l1,l2)}
    function fold_left(t,init,f)
     {return caml_call3(Stdlib_ListLabels[25],f,init,t)}
    function fold2_ok(l1,l2,init,f)
     {return caml_call4(Stdlib_ListLabels[30],f,init,l1,l2)}
    function for_all(t,f){return caml_call2(Stdlib_ListLabels[32],f,t)}
    function for_all2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[34],f,l1,l2)}
    function iter$0(t,f){return caml_call2(Stdlib_ListLabels[17],f,t)}
    function iter2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[27],f,l1,l2)}
    function nontail_map(t,f){return caml_call2(Stdlib_ListLabels[19],f,t)}
    function nontail_mapi(t,f){return caml_call2(Stdlib_ListLabels[20],f,t)}
    function partition(t,f){return caml_call2(Stdlib_ListLabels[44],f,t)}
    function rev_map(t,f){return caml_call2(Stdlib_ListLabels[21],f,t)}
    function rev_map2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[29],f,l1,l2)}
    function sort(l,compare)
     {return caml_call2(Stdlib_ListLabels[56],compare,l)}
    function stable_sort$0(l,compare)
     {return caml_call2(Stdlib_ListLabels[57],compare,l)}
    function rev(res)
     {if(res)
       {var _MI_=res[2];
        if(_MI_)
         {var rest=_MI_[2],y=_MI_[1],x=res[1];
          return caml_call2(rev_append,rest,[0,y,[0,x,0]])}}
      return res}
    function fold_right$0(l,f,init)
     {if(! l)return init;
      function _MH_(a,b){return caml_call2(f,b,a)}
      return fold_left(rev(l),init,_MH_)}
    var
     include$14=
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold_left,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter$0,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort$0,
       rev,
       fold_right$0];
    caml_register_global(988,include$14,"Base__List0");
    function Folding(Hash)
     {function hash_fold_unit(s,param){return s}
      var _Ma_=Hash[2],_Mb_=Hash[3],_Mc_=Hash[4],_Md_=Hash[5];
      function as_int(f,s,x){return caml_call2(_Ma_,s,caml_call1(f,x))}
      function _Me_(_MG_){return _MG_}
      function hash_fold_int32(_ME_,_MF_){return as_int(_Me_,_ME_,_MF_)}
      function hash_fold_char(_MC_,_MD_){return as_int(to_int,_MC_,_MD_)}
      function _Mf_(param){return param?1:0}
      function hash_fold_bool(_MA_,_MB_){return as_int(_Mf_,_MA_,_MB_)}
      function hash_fold_nativeint(s,x)
       {return caml_call2(_Mb_,s,caml_int64_of_int32(x))}
      function hash_fold_option(hash_fold_elem,s,param)
       {if(! param)return caml_call2(_Ma_,s,0);
        var x=param[1];
        return caml_call2(hash_fold_elem,caml_call2(_Ma_,s,1),x)}
      function hash_fold_list(hash_fold_elem,s$1,list$0)
       {var
         s$2=caml_call2(_Ma_,s$1,caml_call1(length,list$0)),
         s=s$2,
         list=list$0;
        for(;;)
         {if(! list)return s;
          var
           xs=list[2],
           x=list[1],
           s$0=caml_call2(hash_fold_elem,s,x),
           s=s$0,
           list=xs}}
      function hash_fold_lazy_t(hash_fold_elem,s,x)
       {var
         _My_=caml_obj_tag(x),
         _Mz_=
          250 === _My_?x[1]:246 === _My_?caml_call1(CamlinternalLazy[2],x):x;
        return caml_call2(hash_fold_elem,s,_Mz_)}
      function hash_fold_ref_frozen(hash_fold_elem,s,x)
       {return caml_call2(hash_fold_elem,s,x[1])}
      function hash_fold_array_frozen(hash_fold_elem,s$1,array)
       {var s$2=caml_call2(_Ma_,s$1,array.length - 1),s=s$2,i=0;
        for(;;)
         {if(i === array.length - 1)return s;
          var
           e=array[1 + i],
           i$0=i + 1 | 0,
           s$0=caml_call2(hash_fold_elem,s,e),
           s=s$0,
           i=i$0}}
      function hash_nativeint(x)
       {var
         _Mw_=caml_call1(Hash[6],0),
         _Mx_=hash_fold_nativeint(caml_call2(Hash[7],0,_Mw_),x);
        return caml_call1(Hash[8],_Mx_)}
      function hash_int64(x)
       {var
         _Mu_=caml_call1(Hash[6],0),
         _Mv_=caml_call2(_Mb_,caml_call2(Hash[7],0,_Mu_),x);
        return caml_call1(Hash[8],_Mv_)}
      function hash_int32(x)
       {var
         _Ms_=caml_call1(Hash[6],0),
         _Mt_=hash_fold_int32(caml_call2(Hash[7],0,_Ms_),x);
        return caml_call1(Hash[8],_Mt_)}
      function hash_char(x)
       {var
         _Mq_=caml_call1(Hash[6],0),
         _Mr_=hash_fold_char(caml_call2(Hash[7],0,_Mq_),x);
        return caml_call1(Hash[8],_Mr_)}
      function hash_int(x)
       {var
         _Mo_=caml_call1(Hash[6],0),
         _Mp_=caml_call2(_Ma_,caml_call2(Hash[7],0,_Mo_),x);
        return caml_call1(Hash[8],_Mp_)}
      function hash_bool(x)
       {var
         _Mm_=caml_call1(Hash[6],0),
         _Mn_=hash_fold_bool(caml_call2(Hash[7],0,_Mm_),x);
        return caml_call1(Hash[8],_Mn_)}
      function hash_string(x)
       {var
         _Mk_=caml_call1(Hash[6],0),
         _Ml_=caml_call2(_Md_,caml_call2(Hash[7],0,_Mk_),x);
        return caml_call1(Hash[8],_Ml_)}
      function hash_float(x)
       {var
         _Mi_=caml_call1(Hash[6],0),
         _Mj_=caml_call2(_Mc_,caml_call2(Hash[7],0,_Mi_),x);
        return caml_call1(Hash[8],_Mj_)}
      function hash_unit(x)
       {var _Mg_=caml_call1(Hash[6],0),_Mh_=caml_call2(Hash[7],0,_Mg_);
        return caml_call1(Hash[8],_Mh_)}
      return [0,
              hash_fold_nativeint,
              _Mb_,
              hash_fold_int32,
              hash_fold_char,
              _Ma_,
              hash_fold_bool,
              _Md_,
              _Mc_,
              hash_fold_unit,
              hash_fold_option,
              hash_fold_list,
              hash_fold_lazy_t,
              hash_fold_ref_frozen,
              hash_fold_array_frozen,
              hash_nativeint,
              hash_int64,
              hash_int32,
              hash_char,
              hash_int,
              hash_bool,
              hash_string,
              hash_float,
              hash_unit]}
    function F(Hash)
     {var
       description=Hash[1],
       fold_int=Hash[2],
       fold_int64=Hash[3],
       fold_float=Hash[4],
       fold_string=Hash[5],
       alloc=Hash[6],
       reset=Hash[7],
       get_hash_value=Hash[8],
       For_tests=Hash[9];
      function create(seed,param)
       {return caml_call2(reset,seed,caml_call1(alloc,0))}
      function of_fold(hash_fold_t,t)
       {return caml_call1
                (get_hash_value,caml_call2(hash_fold_t,create(0,0),t))}
      var Builtin=Folding(Hash);
      function run(seed,folder,x)
       {var
         _L__=caml_call1(Hash[6],0),
         _L$_=caml_call2(folder,caml_call2(Hash[7],seed,_L__),x);
        return caml_call1(Hash[8],_L$_)}
      return [0,
              description,
              fold_int,
              fold_int64,
              fold_float,
              fold_string,
              alloc,
              reset,
              get_hash_value,
              For_tests,
              create,
              of_fold,
              Builtin,
              run]}
    function alloc(param){return 0}
    function reset(opt,t)
     {if(opt)var sth=opt[1],seed=sth;else var seed=0;return seed}
    var compare_state=caml_int_compare;
    function state_to_string(state){return caml_call1(to_string,state)}
    var For_tests=[0,compare_state,state_to_string];
    function create$0(seed,param){return reset(seed,0)}
    function run(seed,folder,x)
     {return runtime.Base_internalhash_get_hash_value
              (caml_call2(folder,reset(seed,0),x))}
    function of_fold(hash_fold_t,t)
     {return runtime.Base_internalhash_get_hash_value
              (caml_call2(hash_fold_t,create$0(0,0),t))}
    function _h_(_L9_){return runtime.Base_internalhash_get_hash_value(_L9_)}
    function _i_(_L8_,_L7_)
     {return runtime.Base_internalhash_fold_string(_L8_,_L7_)}
    function _j_(_L6_,_L5_)
     {return runtime.Base_internalhash_fold_float(_L6_,_L5_)}
    function _k_(_L4_,_L3_)
     {return runtime.Base_internalhash_fold_int64(_L4_,_L3_)}
    var
     Folding$0=
      Folding
       ([0,
         description,
         function(_L2_,_L1_)
          {return runtime.Base_internalhash_fold_int(_L2_,_L1_)},
         _k_,
         _j_,
         _i_,
         alloc,
         reset,
         _h_,
         For_tests]),
     hash_fold_nativeint=Folding$0[1],
     hash_fold_int64=Folding$0[2],
     hash_fold_int32=Folding$0[3],
     hash_fold_char=Folding$0[4],
     hash_fold_int=Folding$0[5],
     hash_fold_bool=Folding$0[6],
     hash_fold_string=Folding$0[7],
     hash_fold_float=Folding$0[8],
     hash_fold_unit=Folding$0[9],
     hash_fold_option=Folding$0[10],
     hash_fold_list=Folding$0[11],
     hash_fold_lazy_t=Folding$0[12],
     hash_fold_ref_frozen=Folding$0[13],
     hash_fold_array_frozen=Folding$0[14],
     hash_nativeint=Folding$0[15],
     hash_int64=Folding$0[16],
     hash_int32=Folding$0[17],
     hash_string=Folding$0[21];
    function hash_int(t)
     {var
       t$0=caml_call1(lnot$0,t) + (t << 21) | 0,
       t$1=t$0 ^ (t$0 >>> 24 | 0),
       t$2=(t$1 + (t$1 << 3) | 0) + (t$1 << 8) | 0,
       t$3=t$2 ^ (t$2 >>> 14 | 0),
       t$4=(t$3 + (t$3 << 2) | 0) + (t$3 << 4) | 0,
       t$5=t$4 ^ (t$4 >>> 28 | 0);
      return t$5 + (t$5 << 31) | 0}
    function hash_bool(x){return x?1:0}
    function hash_unit(param){return 0}
    var
     _l_=
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       to_int,
       hash_int,
       hash_bool,
       hash_string,
       function(_L0_){return runtime.Base_hash_double(_L0_)},
       hash_unit];
    function _m_(_LZ_){return runtime.Base_internalhash_get_hash_value(_LZ_)}
    function _n_(_LY_,_LX_)
     {return runtime.Base_internalhash_fold_string(_LY_,_LX_)}
    function _o_(_LW_,_LV_)
     {return runtime.Base_internalhash_fold_float(_LW_,_LV_)}
    function _p_(_LU_,_LT_)
     {return runtime.Base_internalhash_fold_int64(_LU_,_LT_)}
    var
     Base_Hash=
      [0,
       F,
       description,
       function(_LS_,_LR_)
        {return runtime.Base_internalhash_fold_int(_LS_,_LR_)},
       _p_,
       _o_,
       _n_,
       alloc,
       reset,
       _m_,
       For_tests,
       create$0,
       of_fold,
       _l_,
       run];
    caml_register_global(990,Base_Hash,"Base__Hash");
    function compare_abstract(type_name,param,_LQ_)
     {return caml_call3(ksprintf,failwith$0,_q_,type_name)}
    function equal_abstract(type_name,param,_LP_)
     {return caml_call3(ksprintf,failwith$0,_r_,type_name)}
    var
     Comparable=[0],
     Equal=[0],
     compare_bool=caml_int_compare,
     compare_char=caml_int_compare,
     compare_float=caml_float_compare,
     compare_int=caml_int_compare,
     compare_int32=caml_int_compare;
    function compare_int64(_LO_,_LN_){return caml_int64_compare(_LO_,_LN_)}
    var
     compare_nativeint=caml_int_compare,
     compare_string=caml_string_compare,
     compare_unit=caml_int_compare;
    function compare_array(compare_elt,a,b)
     {if(a === b)return 0;
      var
       len_a=a.length - 1,
       len_b=b.length - 1,
       ret=caml_int_compare(len_a,len_b);
      if(0 !== ret)return ret;
      var i=0;
      for(;;)
       {if(i === len_a)return 0;
        var l=a[1 + i],r=b[1 + i],res=caml_call2(compare_elt,l,r);
        if(0 !== res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    function compare_list(compare_elt,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(! a$0)return b$0?-1:0;
        if(! b$0)return 1;
        var
         ys=b$0[2],
         y=b$0[1],
         xs=a$0[2],
         x=a$0[1],
         res=caml_call2(compare_elt,x,y);
        if(0 !== res)return res;
        var a$0=xs,b$0=ys}}
    function compare_option(compare_elt,a,b)
     {if(! a)return b?-1:0;
      var _LM_=a[1];
      if(! b)return 1;
      var b$0=b[1];
      return caml_call2(compare_elt,_LM_,b$0)}
    function compare_ref(compare_elt,a,b)
     {return caml_call2(compare_elt,a[1],b[1])}
    function equal_bool(_LL_,_LK_){return _LL_ === _LK_?1:0}
    function equal_char(_LJ_,_LI_){return _LJ_ === _LI_?1:0}
    function equal_int(_LH_,_LG_){return _LH_ === _LG_?1:0}
    var
     equal_int32=caml_equal,
     equal_int64=caml_equal,
     equal_nativeint=caml_equal,
     equal_string=caml_string_equal;
    function equal_unit(_LF_,_LE_){return _LF_ === _LE_?1:0}
    function equal_float(x,y){return caml_float_compare(x,y) === 0?1:0}
    function equal_array(equal_elt,a,b)
     {var _Ly_=a === b?1:0;
      if(_Ly_)
       var _Lz_=_Ly_;
      else
       {var len_a=a.length - 1,len_b=b.length - 1,_LA_=len_a === len_b?1:0;
        if(_LA_)
         {var i=0;
          for(;;)
           {var _LB_=i === len_a?1:0;
            if(_LB_)
             var _LC_=_LB_;
            else
             {var l=a[1 + i],r=b[1 + i],_LD_=caml_call2(equal_elt,l,r);
              if(_LD_){var i$0=i + 1 | 0,i=i$0;continue}
              var _LC_=_LD_}
            return _LC_}}
        var _Lz_=_LA_}
      return _Lz_}
    function equal_list(equal_elt,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(a$0)
         {if(b$0)
           {var
             ys=b$0[2],
             y=b$0[1],
             xs=a$0[2],
             x=a$0[1],
             _Lx_=caml_call2(equal_elt,x,y);
            if(! _Lx_)return _Lx_;
            var a$0=xs,b$0=ys;
            continue}}
        else
         if(! b$0)return 1;
        return 0}}
    function equal_option(equal_elt,a,b)
     {if(a)
       {if(b){var b$0=b[1],a$0=a[1];return caml_call2(equal_elt,a$0,b$0)}}
      else
       if(! b)return 1;
      return 0}
    function equal_ref(equal_elt,a,b){return caml_call2(equal_elt,a[1],b[1])}
    var
     include$15=
      [0,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref],
     Base_Ppx_compare_lib=
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       include$15];
    caml_register_global(991,Base_Ppx_compare_lib,"Base__Ppx_compare_lib");
    var Std=[0],Hashable=[0],Base_Ppx_hash_lib=[0,Std,Hashable];
    caml_register_global(992,Base_Ppx_hash_lib,"Base__Ppx_hash_lib");
    var
     t_of_sexp=Sexplib0_Sexp[1],
     sexp_of_t=Sexplib0_Sexp[2],
     equal$8=Sexplib0_Sexp[3],
     Not_found_s=Sexplib0_Sexp[5],
     Of_sexp_error=Sexplib0_Sexp[6],
     message=Sexplib0_Sexp[7],
     default_indent=Sexplib0_Sexp[8],
     pp_hum=Sexplib0_Sexp[9],
     pp_hum_indent=Sexplib0_Sexp[10],
     pp_mach=Sexplib0_Sexp[11],
     pp=Sexplib0_Sexp[12],
     to_string_hum=Sexplib0_Sexp[13],
     to_string_mach=Sexplib0_Sexp[14],
     to_string$0=Sexplib0_Sexp[15],
     of_float_style=Sexplib0_Sexp[16],
     of_int_style=Sexplib0_Sexp[17],
     Private=Sexplib0_Sexp[18];
    function compare$7(a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(0 === a_001[0])
       {var _Lv_=a_001[1];
        if(0 !== b_002[0])return -1;
        var b_004=b_002[1];
        return caml_call2(include$15[8],_Lv_,b_004)}
      var _Lw_=a_001[1];
      if(0 === b_002[0])return 1;
      var b_006=b_002[1];
      return caml_call3(include$15[11],compare$7,_Lw_,b_006)}
    var
     hash_fold_t=function _Lu_(_Ls_,_Lt_){return _Lu_.fun(_Ls_,_Lt_)},
     hash=function _Lr_(_Lq_){return _Lr_.fun(_Lq_)};
    caml_update_dummy
     (hash_fold_t,
      function(hsv,arg)
       {if(0 === arg[0])
         {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
          return caml_call2(_l_[7],hsv$0,a0)}
        var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
        return caml_call3(_l_[11],hash_fold_t,hsv$1,a0$0)});
    caml_update_dummy
     (hash,
      function(x)
       {var hsv=create$0(0,0);
        return runtime.Base_internalhash_get_hash_value
                (caml_call2(hash_fold_t,hsv,x))});
    var t_sexp_grammar=Sexplib0_Sexp_conv[59],of_string$0=0;
    function invariant(param){return 0}
    var
     Base_Sexp=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal$8,
       compare$7,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       of_string$0];
    caml_register_global(995,Base_Sexp,"Base__Sexp");
    var
     default_string_of_float=Sexplib0_Sexp_conv[1],
     write_old_option_format=Sexplib0_Sexp_conv[2],
     read_old_option_format=Sexplib0_Sexp_conv[3],
     list_map=Sexplib0_Sexp_conv[4],
     sexp_of_t$0=Sexplib0_Sexp_conv[5],
     sexp_of_t$1=Sexplib0_Sexp_conv[6],
     sexp_of_t$2=Sexplib0_Sexp_conv[7],
     sexp_of_bytes=Sexplib0_Sexp_conv[8],
     sexp_of_t$3=Sexplib0_Sexp_conv[9],
     sexp_of_t$4=Sexplib0_Sexp_conv[10],
     sexp_of_t$5=Sexplib0_Sexp_conv[11],
     sexp_of_t$6=Sexplib0_Sexp_conv[12],
     sexp_of_t$7=Sexplib0_Sexp_conv[13],
     sexp_of_t$8=Sexplib0_Sexp_conv[14],
     sexp_of_ref=Sexplib0_Sexp_conv[15],
     sexp_of_t$9=Sexplib0_Sexp_conv[16],
     sexp_of_option=Sexplib0_Sexp_conv[17],
     sexp_of_pair=Sexplib0_Sexp_conv[18],
     sexp_of_triple=Sexplib0_Sexp_conv[19],
     sexp_of_t$10=Sexplib0_Sexp_conv[20],
     sexp_of_array=Sexplib0_Sexp_conv[21],
     sexp_of_hashtbl=Sexplib0_Sexp_conv[22],
     sexp_of_opaque=Sexplib0_Sexp_conv[23],
     sexp_of_fun=Sexplib0_Sexp_conv[24],
     Of_sexp_error$0=Sexplib0_Sexp_conv[25],
     record_check_extra_fields=Sexplib0_Sexp_conv[26],
     of_sexp_error=Sexplib0_Sexp_conv[27],
     of_sexp_error_exn=Sexplib0_Sexp_conv[28],
     t_of_sexp$0=Sexplib0_Sexp_conv[29],
     t_of_sexp$1=Sexplib0_Sexp_conv[30],
     t_of_sexp$2=Sexplib0_Sexp_conv[31],
     bytes_of_sexp=Sexplib0_Sexp_conv[32],
     t_of_sexp$3=Sexplib0_Sexp_conv[33],
     t_of_sexp$4=Sexplib0_Sexp_conv[34],
     t_of_sexp$5=Sexplib0_Sexp_conv[35],
     t_of_sexp$6=Sexplib0_Sexp_conv[36],
     t_of_sexp$7=Sexplib0_Sexp_conv[37],
     t_of_sexp$8=Sexplib0_Sexp_conv[38],
     ref_of_sexp=Sexplib0_Sexp_conv[39],
     t_of_sexp$9=Sexplib0_Sexp_conv[40],
     option_of_sexp=Sexplib0_Sexp_conv[41],
     pair_of_sexp=Sexplib0_Sexp_conv[42],
     triple_of_sexp=Sexplib0_Sexp_conv[43],
     t_of_sexp$10=Sexplib0_Sexp_conv[44],
     array_of_sexp=Sexplib0_Sexp_conv[45],
     hashtbl_of_sexp=Sexplib0_Sexp_conv[46],
     opaque_of_sexp=Sexplib0_Sexp_conv[47],
     fun_of_sexp=Sexplib0_Sexp_conv[48],
     unit_sexp_grammar=Sexplib0_Sexp_conv[49],
     t_sexp_grammar$0=Sexplib0_Sexp_conv[50],
     t_sexp_grammar$1=Sexplib0_Sexp_conv[51],
     bytes_sexp_grammar=Sexplib0_Sexp_conv[52],
     t_sexp_grammar$2=Sexplib0_Sexp_conv[53],
     t_sexp_grammar$3=Sexplib0_Sexp_conv[54],
     t_sexp_grammar$4=Sexplib0_Sexp_conv[55],
     t_sexp_grammar$5=Sexplib0_Sexp_conv[56],
     t_sexp_grammar$6=Sexplib0_Sexp_conv[57],
     t_sexp_grammar$7=Sexplib0_Sexp_conv[58],
     sexp_t_sexp_grammar=Sexplib0_Sexp_conv[59],
     ref_sexp_grammar=Sexplib0_Sexp_conv[60],
     lazy_t_sexp_grammar=Sexplib0_Sexp_conv[61],
     option_sexp_grammar=Sexplib0_Sexp_conv[62],
     list_sexp_grammar=Sexplib0_Sexp_conv[63],
     array_sexp_grammar=Sexplib0_Sexp_conv[64],
     opaque_sexp_grammar=Sexplib0_Sexp_conv[65],
     fun_sexp_grammar=Sexplib0_Sexp_conv[66],
     sexp_of_exn=Sexplib0_Sexp_conv[67],
     printexc_prefer_sexp=Sexplib0_Sexp_conv[68],
     sexp_of_exn_opt=Sexplib0_Sexp_conv[69],
     Exn_converter=Sexplib0_Sexp_conv[70],
     hash_fold_t$0=_l_[1],
     hash_fold_t$1=_l_[2],
     hash_fold_t$2=_l_[3],
     hash_fold_t$3=_l_[4],
     hash_fold_t$4=_l_[5],
     hash_fold_t$5=_l_[6],
     hash_fold_t$6=_l_[7],
     hash_fold_t$7=_l_[8],
     hash_fold_t$8=_l_[9],
     hash_fold_option$0=_l_[10],
     hash_fold_t$9=_l_[11],
     hash_fold_lazy_t$0=_l_[12],
     hash_fold_ref_frozen$0=_l_[13],
     hash_fold_array_frozen$0=_l_[14],
     func=_l_[15],
     func$0=_l_[16],
     func$1=_l_[17],
     func$2=_l_[18],
     func$3=_l_[19],
     func$4=_l_[20],
     func$5=_l_[21],
     specialized_hash=_l_[22],
     func$6=_l_[23],
     compare$8=include$15[1],
     compare$9=include$15[2],
     compare_float$0=include$15[3],
     compare$10=include$15[4],
     compare$11=include$15[5],
     compare$12=include$15[6],
     compare$13=include$15[7],
     compare_string$0=include$15[8],
     compare_unit$0=include$15[9],
     compare_array$0=include$15[10],
     compare_list$0=include$15[11],
     compare_option$0=include$15[12],
     compare_ref$0=include$15[13],
     equal_bool$0=include$15[14],
     equal_char$0=include$15[15],
     equal_float$0=include$15[16],
     equal_int$0=include$15[17],
     equal_int32$0=include$15[18],
     equal_int64$0=include$15[19],
     equal_nativeint$0=include$15[20],
     equal_string$0=include$15[21],
     equal_unit$0=include$15[22],
     equal_array$0=include$15[23],
     equal_list$0=include$15[24],
     equal_option$0=include$15[25],
     equal_ref$0=include$15[26],
     Base_Import=
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       scale,
       symbol$6,
       add,
       symbol$7,
       sub,
       symbol$8,
       symbol$9,
       include$1,
       _a_,
       _b_,
       max$2,
       min$2,
       Int32_replace_polymorphic_comp,
       include$2,
       include$3,
       include$4,
       include$5,
       include$6,
       include$7,
       include$8,
       include$9,
       symbol$58,
       symbol$59,
       neg,
       neg$0,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       get_key,
       invalid_arg$0,
       get_data,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_t$0,
       sexp_of_t$1,
       sexp_of_t$2,
       sexp_of_bytes,
       sexp_of_t$3,
       sexp_of_t$4,
       sexp_of_t$5,
       sexp_of_t$6,
       sexp_of_t$7,
       sexp_of_t$8,
       sexp_of_ref,
       sexp_of_t$9,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_t$10,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error$0,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       t_of_sexp$0,
       t_of_sexp$1,
       t_of_sexp$2,
       bytes_of_sexp,
       t_of_sexp$3,
       t_of_sexp$4,
       t_of_sexp$5,
       t_of_sexp$6,
       t_of_sexp$7,
       t_of_sexp$8,
       ref_of_sexp,
       t_of_sexp$9,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       t_of_sexp$10,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       t_sexp_grammar$0,
       t_sexp_grammar$1,
       bytes_sexp_grammar,
       t_sexp_grammar$2,
       t_sexp_grammar$3,
       t_sexp_grammar$4,
       t_sexp_grammar$5,
       t_sexp_grammar$6,
       t_sexp_grammar$7,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_t$0,
       hash_fold_t$1,
       hash_fold_t$2,
       hash_fold_t$3,
       hash_fold_t$4,
       hash_fold_t$5,
       hash_fold_t$6,
       hash_fold_t$7,
       hash_fold_t$8,
       hash_fold_option$0,
       hash_fold_t$9,
       hash_fold_lazy_t$0,
       hash_fold_ref_frozen$0,
       hash_fold_array_frozen$0,
       func,
       func$0,
       func$1,
       func$2,
       func$3,
       func$4,
       func$5,
       specialized_hash,
       func$6,
       compare$8,
       compare$9,
       compare_float$0,
       compare$10,
       compare$11,
       compare$12,
       compare$13,
       compare_string$0,
       compare_unit$0,
       compare_array$0,
       compare_list$0,
       compare_option$0,
       compare_ref$0,
       equal_bool$0,
       equal_char$0,
       equal_float$0,
       equal_int$0,
       equal_int32$0,
       equal_int64$0,
       equal_nativeint$0,
       equal_string$0,
       equal_unit$0,
       equal_array$0,
       equal_list$0,
       equal_option$0,
       equal_ref$0,
       Not_found_s];
    caml_register_global(996,Base_Import,"Base__Import");
    function sexp_of_t$11(param){return param?_s_:_t_}
    function num_bits$0(param){return param?64:32}
    var
     word_size=
      32 === word_size_in_bits
       ?0
       :64 === word_size_in_bits
         ?1
         :caml_call1(failwith$0,cst_unknown_word_size),
     Base_Word_size=[0,sexp_of_t$11,num_bits$0,word_size];
    caml_register_global(997,Base_Word_size,"Base__Word_size");
    var Base_Formatter=[0];
    caml_register_global(998,Base_Formatter,"Base__Formatter");
    var r=[0,_u_];
    function all(param){return r[1]}
    function register(p){r[1] = [0,p,r[1]];return 0}
    function Register_pp(_Ln_)
     {var _Lo_=_Ln_[1],_Lp_=_Ln_[2];
      register(caml_call2(symbol$59,_Ln_[2],cst_pp));
      return [0,_Lo_,_Lp_]}
    function _v_(_Lm_){return [0,Register_pp(_Lm_)[1]]}
    function _w_(M)
     {var module_name=M[1];
      function pp(formatter,t)
       {var _Ll_=caml_call1(M[2],t);
        return caml_call2(Stdlib_Format[13],formatter,_Ll_)}
      return [0,Register_pp([0,pp,module_name])[1]]}
    var Base_Pretty_printer=[0,all,_w_,_v_,register];
    caml_register_global(1000,Base_Pretty_printer,"Base__Pretty_printer");
    var _x_=Caml$0[98],Finally=[248,cst_Base_Exn_Finally,caml_fresh_oo_id(0)];
    function _y_(param)
     {if(param[1] !== Finally)throw [0,Assert_failure$0,_A_];
      var
       arg1_002=param[3],
       arg0_001=param[2],
       res0_003=caml_call1(sexp_of_exn,arg0_001),
       res1_004=caml_call1(sexp_of_exn,arg1_002);
      return [1,[0,_z_,[0,res0_003,[0,res1_004,0]]]]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Finally,_y_);
    var Reraised=[248,cst_Base_Exn_Reraised,caml_fresh_oo_id(0)];
    function _B_(param)
     {if(param[1] !== Reraised)throw [0,Assert_failure$0,_D_];
      var
       arg1_006=param[3],
       arg0_005=param[2],
       res0_007=caml_call1(sexp_of_t$2,arg0_005),
       res1_008=caml_call1(sexp_of_exn,arg1_006);
      return [1,[0,_C_,[0,res0_007,[0,res1_008,0]]]]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Reraised,_B_);
    var Sexp=[248,cst_Base_Exn_Sexp,caml_fresh_oo_id(0)];
    function _E_(param)
     {if(param[1] !== Sexp)throw [0,Assert_failure$0,_F_];
      var t=param[2];
      return t}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Sexp,_E_);
    function create_s(sexp){return [0,Sexp,sexp]}
    function raise_with_original_backtrace(t,backtrace)
     {runtime.caml_restore_raw_backtrace(t,backtrace);throw t}
    function reraise(exn,str)
     {var exn$0=[0,Reraised,str,exn];
      if(! runtime.Base_caml_exn_is_most_recent_exn(exn))throw exn$0;
      var bt=caml_call1(Stdlib_Printexc[12],0);
      return raise_with_original_backtrace(exn$0,bt)}
    function reraisef(exc,format)
     {return caml_call2
              (ksprintf,function(str,param){return reraise(exc,str)},format)}
    function to_string$1(exc)
     {return caml_call2(to_string_hum,_G_,caml_call1(sexp_of_exn,exc))}
    function to_string_mach$0(exc)
     {return caml_call1(to_string_mach,caml_call1(sexp_of_exn,exc))}
    function protectx(f,x,finally$0)
     {try
       {var res=caml_call1(f,x)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var bt=caml_call1(Stdlib_Printexc[12],0);
        try
         {caml_call1(finally$0,x)}
        catch(final_exn)
         {final_exn = caml_wrap_exception(final_exn);
          return raise_with_original_backtrace([0,Finally,exn,final_exn],bt)}
        return raise_with_original_backtrace(exn,bt)}
      caml_call1(finally$0,x);
      return res}
    function protect(f,finally$0){return protectx(f,0,finally$0)}
    function does_raise(f)
     {try {caml_call1(f,0);var _Lj_=0;return _Lj_}catch(_Lk_){return 1}}
    function pp$0(ppf,t)
     {var match=caml_call1(sexp_of_exn_opt,t);
      if(match){var sexp=match[1];return caml_call2(pp_hum,ppf,sexp)}
      var _Li_=caml_call1(Stdlib_Printexc[1],t);
      return caml_call2(Stdlib_Format[13],ppf,_Li_)}
    var include$16=_v_([0,pp$0,module_name]),pp$1=include$16[1];
    function print_with_backtrace(exc,raw_backtrace)
     {caml_call3(Stdlib_Format[131],_H_,pp$1,exc);
      if(caml_call1(Stdlib_Printexc[8],0))
       caml_call2(Stdlib_Printexc[13],Caml$0[39],raw_backtrace);
      return caml_call1(Caml$0[62],Caml$0[39])}
    function handle_uncaught_aux(do_at_exit,exit,f)
     {try
       {var _Le_=caml_call1(f,0);return _Le_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var raw_backtrace=caml_call1(Stdlib_Printexc[12],0);
        if(do_at_exit)try {caml_call1(Caml$0[102],0)}catch(_Lh_){}
        try
         {print_with_backtrace(exc,raw_backtrace)}
        catch(_Lf_){try {caml_call1(Stdlib_Printf[3],_I_)}catch(_Lg_){}}
        return caml_call1(exit,1)}}
    function handle_uncaught_and_exit(f){return handle_uncaught_aux(1,_x_,f)}
    function handle_uncaught(must_exit,f)
     {var exit=must_exit?_x_:function(_Ld_){return 0};
      return handle_uncaught_aux(must_exit,exit,f)}
    function reraise_uncaught(str,func)
     {try
       {var _Lc_=caml_call1(func,0);return _Lc_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var bt=caml_call1(Stdlib_Printexc[12],0);
        return raise_with_original_backtrace([0,Reraised,str,exn],bt)}}
    function raise_without_backtrace(e)
     {runtime.Base_clear_caml_backtrace_pos(0);throw e}
    function initialize_module(param)
     {return caml_call1(Stdlib_Printexc[16],print_with_backtrace)}
    function clear_backtrace(_Lb_)
     {return runtime.Base_clear_caml_backtrace_pos(_Lb_)}
    var
     Private$0=[0,clear_backtrace],
     Base_Exn=
      [0,
       sexp_of_exn,
       pp$1,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string$1,
       to_string_mach$0,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_La_){return runtime.Base_caml_exn_is_most_recent_exn(_La_)},
       initialize_module,
       Private$0];
    caml_register_global(1003,Base_Exn,"Base__Exn");
    function with_return(f)
     {var Return=[248,cst_Return,caml_fresh_oo_id(0)],is_alive=[0,1];
      function return$0(a)
       {if(1 - is_alive[1])
         caml_call1(failwith$0,cst_use_of_return_from_a_with_);
        return raise_without_backtrace([0,Return,a])}
      try
       {var a$0=caml_call1(f,return$0);is_alive[1] = 0;return a$0}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        is_alive[1] = 0;
        if(exn[1] !== Return)throw exn;
        var a=exn[2];
        return a}}
    function with_return_option(f)
     {return with_return
              (function(return$0)
                {caml_call1(f,function(a){return caml_call1(return$0,[0,a])});
                 return 0})}
    function prepend(param,f)
     {return function(x){return caml_call1(param,caml_call1(f,x))}}
    var Base_With_return=[0,with_return,with_return_option,prepend];
    caml_register_global(1004,Base_With_return,"Base__With_return");
    var Base_Variant=[0];
    caml_register_global(1005,Base_Variant,"Base__Variant");
    var Base_Variantslib=[0];
    caml_register_global(1006,Base_Variantslib,"Base__Variantslib");
    function S_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Monad_infix=X[3],
       bind=X[4],
       return$0=X[5],
       map=X[6],
       join=X[7],
       ignore_m=X[8],
       all=X[9],
       all_unit=X[10],
       Let_syntax=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S2_to_S3(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S_to_S_indexed(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Monad_infix=X[3],
       bind=X[4],
       return$0=X[5],
       map=X[6],
       join=X[7],
       ignore_m=X[8],
       all=X[9],
       all_unit=X[10],
       Let_syntax=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S2_to_S(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit,
              Let_syntax]}
    function S3_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S_indexed_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    var
     Base_Monad_intf=
      [0,S_to_S2,S2_to_S3,S_to_S_indexed,S2_to_S,S3_to_S2,S_indexed_to_S2];
    caml_register_global(1007,Base_Monad_intf,"Base__Monad_intf");
    function Make_general(_K6_)
     {var _K7_=_K6_[1],_K8_=_K6_[3];
      function map_via_bind(ma,f)
       {function _K__(a)
         {var _K$_=caml_call1(f,a);return caml_call1(_K6_[3],_K$_)}
        return caml_call2(_K6_[1],ma,_K__)}
      var _K9_=_K6_[2];
      if(typeof _K9_ === "number")
       var map=map_via_bind;
      else
       var x=_K9_[2],map=x;
      function symbol_bind(t,f){return caml_call2(_K7_,t,f)}
      function symbol_map(t,f){return caml_call2(map,t,f)}
      var
       Monad_infix=[0,symbol_bind,symbol_map],
       symbol_bind$0=Monad_infix[1],
       symbol_map$0=Monad_infix[2],
       symbol_bind$1=Monad_infix[1],
       symbol_map$1=Monad_infix[2];
      function both(a,b)
       {return caml_call2
                (symbol_bind$1,
                 a,
                 function(a)
                  {return caml_call2
                           (symbol_map$1,b,function(b){return [0,a,b]})})}
      var
       Open_on_rhs=[0],
       Let_syntax=[0,_K8_,_K7_,map,both,Open_on_rhs],
       Let_syntax$0=[0,_K8_,symbol_bind$1,symbol_map$1,Let_syntax];
      function join(t)
       {return caml_call2(symbol_bind$0,t,function(t){return t})}
      function ignore_m(t){return caml_call2(map,t,function(param){return 0})}
      function loop(vs,param)
       {if(! param)return caml_call1(_K8_,rev(vs));
        var ts=param[2],t=param[1];
        return caml_call2
                (symbol_bind$0,t,function(v){return loop([0,v,vs],ts)})}
      function all(ts){return loop(0,ts)}
      function all_unit(param)
       {if(! param)return caml_call1(_K8_,0);
        var ts=param[2],t=param[1];
        return caml_call2
                (symbol_bind$0,t,function(param){return all_unit(ts)})}
      return [0,
              _K7_,
              _K8_,
              map_via_bind,
              map,
              Monad_infix,
              symbol_bind$0,
              symbol_map$0,
              Let_syntax$0,
              join,
              ignore_m,
              all,
              all_unit]}
    function Make_indexed(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K5_=Make_general([0,bind,map,return$0]);
      return [0,
              _K5_[6],
              _K5_[7],
              _K5_[8],
              _K5_[5],
              _K5_[1],
              _K5_[2],
              _K5_[4],
              _K5_[9],
              _K5_[10],
              _K5_[11],
              _K5_[12]]}
    function Make3(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K4_=Make_general([0,bind,map,return$0]);
      return [0,
              _K4_[6],
              _K4_[7],
              _K4_[8],
              _K4_[5],
              _K4_[1],
              _K4_[2],
              _K4_[4],
              _K4_[9],
              _K4_[10],
              _K4_[11],
              _K4_[12]]}
    function Make2(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K3_=Make_general([0,bind,map,return$0]);
      return [0,
              _K3_[6],
              _K3_[7],
              _K3_[8],
              _K3_[5],
              _K3_[1],
              _K3_[2],
              _K3_[4],
              _K3_[9],
              _K3_[10],
              _K3_[11],
              _K3_[12]]}
    function Make(M)
     {var
       bind=M[1],
       return$0=M[2],
       map=M[3],
       _K2_=Make_general([0,bind,map,return$0]);
      return [0,
              _K2_[6],
              _K2_[7],
              _K2_[5],
              _K2_[1],
              _K2_[2],
              _K2_[4],
              _K2_[9],
              _K2_[10],
              _K2_[11],
              _K2_[12],
              _K2_[8]]}
    function Of_monad_general(Monad,M)
     {function return$0(a)
       {var _K1_=caml_call1(Monad[3],a);return caml_call1(M[2],_K1_)}
      function bind(t,f)
       {function _KX_(a)
         {var _K0_=caml_call1(f,a);return caml_call1(M[1],_K0_)}
        var _KY_=caml_call1(M[1],t),_KZ_=caml_call2(Monad[1],_KY_,_KX_);
        return caml_call1(M[2],_KZ_)}
      var
       map=
        [0,
         -198771759,
         function(t,f)
          {var _KV_=caml_call1(M[1],t),_KW_=caml_call2(Monad[2],_KV_,f);
           return caml_call1(M[2],_KW_)}];
      return Make_general([0,bind,map,return$0])}
    function bind(a,f){return caml_call1(f,a)}
    function return$0(a){return a}
    var
     map$0=[0,-198771759,function(a,f){return caml_call1(f,a)}],
     include$17=Make([0,bind,return$0,map$0]),
     symbol_bind=include$17[1],
     symbol_map=include$17[2],
     Monad_infix=include$17[3],
     bind$0=include$17[4],
     return$1=include$17[5],
     map$1=include$17[6],
     join=include$17[7],
     ignore_m=include$17[8],
     all$0=include$17[9],
     all_unit=include$17[10],
     Let_syntax=include$17[11],
     Ident=
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$1,
       join,
       ignore_m,
       all$0,
       all_unit,
       Let_syntax];
    function _J_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KU_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KU_[6],
              _KU_[7],
              _KU_[8],
              _KU_[5],
              _KU_[1],
              _KU_[2],
              _KU_[4],
              _KU_[9],
              _KU_[10],
              _KU_[11],
              _KU_[12]]}
    function _K_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KT_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KT_[6],
              _KT_[7],
              _KT_[8],
              _KT_[5],
              _KT_[1],
              _KT_[2],
              _KT_[4],
              _KT_[9],
              _KT_[10],
              _KT_[11],
              _KT_[12]]}
    function _L_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KS_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KS_[6],
              _KS_[7],
              _KS_[8],
              _KS_[5],
              _KS_[1],
              _KS_[2],
              _KS_[4],
              _KS_[9],
              _KS_[10],
              _KS_[11],
              _KS_[12]]}
    var
     Base_Monad=
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad,M)
        {var
          to_monad=M[1],
          of_monad=M[2],
          bind=Monad[4],
          return$0=Monad[5],
          map=Monad[6],
          _KR_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
         return [0,
                 _KR_[6],
                 _KR_[7],
                 _KR_[5],
                 _KR_[1],
                 _KR_[2],
                 _KR_[4],
                 _KR_[9],
                 _KR_[10],
                 _KR_[11],
                 _KR_[12],
                 _KR_[8]]},
       _L_,
       _K_,
       _J_,
       Ident];
    caml_register_global(1008,Base_Monad,"Base__Monad");
    var Base_Applicative_intf=[0];
    caml_register_global(1009,Base_Applicative_intf,"Base__Applicative_intf");
    function S_to_S2$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S2_to_S$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S2_to_S3$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S3_to_S2$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function Make3$0(_KJ_)
     {var _KK_=_KJ_[1],_KL_=_KJ_[2];
      function derived_map(t,f){return caml_call2(_KL_,caml_call1(_KK_,f),t)}
      var _KM_=_KJ_[3];
      if(typeof _KM_ === "number")
       var map=derived_map;
      else
       var x=_KM_[2],map=x;
      function symbol_map(t,f){return caml_call2(map,t,f)}
      function map2(ta,tb,f){return caml_call2(_KL_,caml_call2(map,ta,f),tb)}
      function map3(ta,tb,tc,f)
       {return caml_call2(_KL_,caml_call2(_KL_,caml_call2(map,ta,f),tb),tc)}
      function all(ts)
       {var _KN_=caml_call1(_KK_,0);
        function _KO_(x,xs){return [0,x,xs]}
        return fold_right$0
                (ts,
                 function(_KP_)
                  {return function(_KQ_){return map2(_KP_,_KQ_,_KO_)}},
                 _KN_)}
      function both(ta,tb){return map2(ta,tb,function(a,b){return [0,a,b]})}
      function symbol(u,v)
       {return caml_call2
                (_KL_,
                 caml_call2
                  (_KL_,caml_call1(_KK_,function(param,y){return y}),u),
                 v)}
      function symbol$0(u,v)
       {return caml_call2
                (_KL_,
                 caml_call2
                  (_KL_,caml_call1(_KK_,function(x,param){return x}),u),
                 v)}
      function all_unit(ts){return fold_left(ts,caml_call1(_KK_,0),symbol)}
      return [0,
              _KK_,
              map,
              both,
              _KL_,
              symbol$0,
              symbol,
              symbol_map,
              _KL_,
              map2,
              map3,
              all,
              all_unit,
              [0,_KL_,symbol$0,symbol,symbol_map]]}
    function Make2$0(X)
     {var return$0=X[1],apply=X[2],map=X[3];
      return Make3$0([0,return$0,apply,map])}
    function Make$0(X)
     {var return$0=X[1],apply=X[2],map=X[3];
      return Make2$0([0,return$0,apply,map])}
    function Make_let_syntax3(X,Intf,Impl)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       return$1=X[1],
       map$0=X[2],
       both$0=X[3],
       symbol$2=X[4],
       symbol$3=X[5],
       symbol$4=X[6],
       symbol_map$0=X[7],
       Let_syntax=
        [0,return$1,map$0,both$0,symbol$2,symbol$3,symbol$4,symbol_map$0,Impl],
       Let_syntax$0=
        [0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map,Let_syntax];
      return [0,Let_syntax$0]}
    function Make_let_syntax2(X,Intf,Impl)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7];
      return Make_let_syntax3
              ([0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map],
               Intf,
               Impl)}
    function Make3_using_map2(_Kz_)
     {var _KA_=_Kz_[1],_KB_=_Kz_[2];
      function symbol(tf,ta)
       {return caml_call3(_KB_,tf,ta,function(f,a){return caml_call1(f,a)})}
      function derived_map(t,f){return symbol(caml_call1(_KA_,f),t)}
      var _KC_=_Kz_[3];
      if(typeof _KC_ === "number")
       var map=derived_map;
      else
       var x=_KC_[2],map=x;
      function symbol_map(t,f){return caml_call2(map,t,f)}
      function both(ta,tb)
       {return caml_call3(_KB_,ta,tb,function(a,b){return [0,a,b]})}
      function map3(ta,tb,tc,f)
       {function _KI_(fab,c){return caml_call1(fab,c)}
        return caml_call3(_KB_,caml_call3(_KB_,ta,tb,f),tc,_KI_)}
      function all(ts)
       {var _KD_=caml_call1(_KA_,0);
        function _KE_(x,xs){return [0,x,xs]}
        return fold_right$0
                (ts,
                 function(_KF_)
                  {var _KG_=caml_call1(_KB_,_KF_);
                   return function(_KH_){return caml_call2(_KG_,_KH_,_KE_)}},
                 _KD_)}
      function symbol$0(u,v)
       {return caml_call3(_KB_,u,v,function(param,y){return y})}
      function symbol$1(u,v)
       {return caml_call3(_KB_,u,v,function(x,param){return x})}
      function all_unit(ts){return fold_left(ts,caml_call1(_KA_,0),symbol$0)}
      return [0,
              _KA_,
              map,
              both,
              symbol,
              symbol$1,
              symbol$0,
              symbol_map,
              symbol,
              _KB_,
              map3,
              all,
              all_unit,
              [0,symbol,symbol$1,symbol$0,symbol_map]]}
    function Make2_using_map2(X)
     {var return$0=X[1],map2=X[2],map=X[3];
      return Make3_using_map2([0,return$0,map2,map])}
    function Make_using_map2(X)
     {var return$0=X[1],map2=X[2],map=X[3];
      return Make2_using_map2([0,return$0,map2,map])}
    function Of_monad2(M)
     {var return$0=M[6];
      function apply(mf,mx)
       {function _Ky_(f){return caml_call2(M[7],mx,f)}
        return caml_call2(M[5],mf,_Ky_)}
      var map=[0,-198771759,M[7]];
      return Make2$0([0,return$0,apply,map])}
    function Of_monad(M)
     {var
       symbol_bind=M[1],
       symbol_map=M[2],
       Monad_infix=M[3],
       bind=M[4],
       return$0=M[5],
       map=M[6],
       join=M[7],
       ignore_m=M[8],
       all=M[9],
       all_unit=M[10],
       Let_syntax=M[11];
      return Of_monad2
              ([0,
                symbol_bind,
                symbol_map,
                Let_syntax,
                Monad_infix,
                bind,
                return$0,
                map,
                join,
                ignore_m,
                all,
                all_unit])}
    function Compose(F,G)
     {function return$0(a)
       {var _Kx_=caml_call1(F[1],a);return caml_call1(G[1],_Kx_)}
      function apply(tf,tx)
       {var _Kw_=caml_call2(G[2],tf,F[8]);return caml_call2(G[8],_Kw_,tx)}
      function custom_map(t,f)
       {var _Kt_=F[2];
        function _Ku_(_Kv_){return caml_call2(_Kt_,_Kv_,f)}
        return caml_call2(G[2],t,_Ku_)}
      var
       map=[0,-198771759,custom_map],
       include=Make$0([0,return$0,apply,map]),
       return$1=include[1],
       map$0=include[2],
       both=include[3],
       symbol=include[4],
       symbol$0=include[5],
       symbol$1=include[6],
       symbol_map=include[7],
       apply$0=include[8],
       map2=include[9],
       map3=include[10],
       all=include[11],
       all_unit=include[12],
       Applicative_infix=include[13];
      return [0,
              return$1,
              map$0,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function Pair(F,G)
     {function return$0(a)
       {var _Ks_=caml_call1(G[1],a);return [0,caml_call1(F[1],a),_Ks_]}
      function apply(tf,tx)
       {var _Kr_=caml_call2(G[8],tf[2],tx[2]);
        return [0,caml_call2(F[8],tf[1],tx[1]),_Kr_]}
      function custom_map(t,f)
       {var _Kq_=caml_call2(G[2],t[2],f);
        return [0,caml_call2(F[2],t[1],f),_Kq_]}
      var
       map=[0,-198771759,custom_map],
       include=Make$0([0,return$0,apply,map]),
       return$1=include[1],
       map$0=include[2],
       both=include[3],
       symbol=include[4],
       symbol$0=include[5],
       symbol$1=include[6],
       symbol_map=include[7],
       apply$0=include[8],
       map2=include[9],
       map3=include[10],
       all=include[11],
       all_unit=include[12],
       Applicative_infix=include[13];
      return [0,
              return$1,
              map$0,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function _M_(_Kn_,_Km_,_Kl_)
     {var _Ko_=Make_let_syntax3(_Kn_,_Km_,_Kl_)[1],_Kp_=_Ko_[8];
      return [0,
              [0,
               _Ko_[1],
               _Ko_[4],
               _Ko_[5],
               _Ko_[6],
               _Ko_[7],
               [0,_Kp_[1],_Kp_[2],_Kp_[3],_Kp_[8]]]]}
    function _N_(_Ki_,_Kh_,_Kg_)
     {var _Kj_=Make_let_syntax2(_Ki_,_Kh_,_Kg_)[1],_Kk_=_Kj_[8];
      return [0,
              [0,
               _Kj_[1],
               _Kj_[4],
               _Kj_[5],
               _Kj_[6],
               _Kj_[7],
               [0,_Kk_[1],_Kk_[2],_Kk_[3],_Kk_[8]]]]}
    var
     Base_Applicative=
      [0,
       S2_to_S$0,
       S_to_S2$0,
       S3_to_S2$0,
       S2_to_S3$0,
       Make$0,
       Make2$0,
       Make3$0,
       function(X,Intf,Impl)
        {var
          return$0=X[1],
          map=X[2],
          both=X[3],
          symbol=X[4],
          symbol$0=X[5],
          symbol$1=X[6],
          symbol_map=X[7],
          _Ke_=
           Make_let_syntax2
             ([0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map],
              Intf,
              Impl)
            [1],
          _Kf_=_Ke_[8];
         return [0,
                 [0,
                  _Ke_[1],
                  _Ke_[4],
                  _Ke_[5],
                  _Ke_[6],
                  _Ke_[7],
                  [0,_Kf_[1],_Kf_[2],_Kf_[3],_Kf_[8]]]]},
       _N_,
       _M_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
    caml_register_global(1010,Base_Applicative,"Base__Applicative");
    var
     Primitives=[0],
     blit$0=Stdlib_BytesLabels[11],
     blit_string=Stdlib_BytesLabels[12],
     compare$14=Stdlib_BytesLabels[44],
     copy$0=Stdlib_BytesLabels[4],
     create$1=caml_create_bytes,
     fill$0=Stdlib_BytesLabels[10],
     make=Stdlib_BytesLabels[1],
     map$2=Stdlib_BytesLabels[17],
     mapi$0=Stdlib_BytesLabels[18],
     sub$1=Stdlib_BytesLabels[7],
     unsafe_blit=runtime.caml_blit_bytes,
     to_string$2=Stdlib_BytesLabels[6],
     of_string$1=Stdlib_BytesLabels[5];
    function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[48],s)}
    var
     unsafe_of_string_promise_no_mu=Stdlib_BytesLabels[49],
     include$18=
      [0,
       Primitives,
       max_length,
       blit$0,
       blit_string,
       compare$14,
       copy$0,
       create$1,
       fill$0,
       make,
       map$2,
       mapi$0,
       sub$1,
       unsafe_blit,
       to_string$2,
       of_string$1,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
    caml_register_global(1012,include$18,"Base__Bytes0");
    var Module=[0];
    function make$0(compare,sexp_of_t)
     {var comparator=[0,compare,sexp_of_t];return [0,comparator]}
    function S_to_S1(S){var comparator=S[1];return [0,comparator]}
    function Make1(M){var comparator=[0,M[1],M[2]];return [0,comparator]}
    var compare$15=caml_compare;
    function sexp_of_t$12(param){return _O_}
    var
     include$19=Make1([0,compare$15,sexp_of_t$12]),
     comparator=include$19[1],
     Poly=[0,comparator];
    function Derived(M)
     {function comparator(a)
       {var _Kd_=caml_call1(M[2],a[2]);return [0,caml_call1(M[1],a[1]),_Kd_]}
      return [0,comparator]}
    function Derived2(M)
     {function comparator(a,b)
       {var _Kc_=caml_call2(M[2],a[2],b[2]);
        return [0,caml_call2(M[1],a[1],b[1]),_Kc_]}
      return [0,comparator]}
    function Derived_phantom(M)
     {function comparator(a)
       {var _Kb_=caml_call1(M[2],a[2]);return [0,caml_call1(M[1],a[1]),_Kb_]}
      return [0,comparator]}
    function _P_(M){var comparator=[0,M[1],M[2]];return [0,comparator]}
    var
     Base_Comparator=
      [0,
       make$0,
       Poly,
       Module,
       S_to_S1,
       _P_,
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
    caml_register_global(1013,Base_Comparator,"Base__Comparator");
    var Base_Comparisons=[0];
    caml_register_global(1014,Base_Comparisons,"Base__Comparisons");
    function compare$16(cmp_f,cmp_s,a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(0 === a_001[0])
       {var _J$_=a_001[1];
        if(0 !== b_002[0])return -1;
        var b_004=b_002[1];
        return caml_call2(cmp_f,_J$_,b_004)}
      var _Ka_=a_001[1];
      if(0 === b_002[0])return 1;
      var b_006=b_002[1];
      return caml_call2(cmp_s,_Ka_,b_006)}
    function hash_fold_t$10(hash_fold_f,hash_fold_s,hsv,arg)
     {if(0 === arg[0])
       {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
        return caml_call2(hash_fold_f,hsv$0,a0)}
      var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
      return caml_call2(hash_fold_s,hsv$1,a0$0)}
    function t_of_sexp$11(of_f_007,of_s_008,sexp_013)
     {if(0 === sexp_013[0])
       {var _J7_=sexp_013[1],switch$0=0;
        if(caml_string_notequal(_J7_,cst_First))
         {var switch$1=0;
          if(caml_string_notequal(_J7_,cst_Second))
           if(caml_string_notequal(_J7_,cst_first))
            {if(caml_string_notequal(_J7_,cst_second))
              {switch$0 = 1;switch$1 = 1}}
           else
            switch$1 = 1;
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_011,sexp_013)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_011,sexp_013)}
      else
       {var _J8_=sexp_013[1];
        if(! _J8_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_011,sexp_013);
        var _J9_=_J8_[1];
        if(0 !== _J9_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_011,sexp_013);
        var _J__=_J9_[1],switch$2=0;
        if(caml_string_notequal(_J__,cst_First$0))
         {var switch$3=0;
          if(caml_string_notequal(_J__,cst_Second$0))
           if(caml_string_notequal(_J__,cst_first$0))
            {if(caml_string_notequal(_J__,cst_second$0))
              {switch$2 = 1;switch$3 = 1}}
           else
            switch$3 = 1;
          if(! switch$3)
           {var sexp_args_020=_J8_[2];
            if(sexp_args_020 && ! sexp_args_020[2])
             {var
               arg0_021=sexp_args_020[1],
               res0_022=caml_call1(of_s_008,arg0_021);
              return [1,res0_022]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_011,_J__,sexp_013)}}
        if(! switch$2)
         {var sexp_args_015=_J8_[2];
          if(sexp_args_015 && ! sexp_args_015[2])
           {var
             arg0_016=sexp_args_015[1],
             res0_017=caml_call1(of_f_007,arg0_016);
            return [0,res0_017]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_011,_J__,sexp_013)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_011,sexp_013)}
    function sexp_of_t$13(of_f_025,of_s_026,param)
     {if(0 === param[0])
       {var arg0_027=param[1],res0_028=caml_call1(of_f_025,arg0_027);
        return [1,[0,_Q_,[0,res0_028,0]]]}
      var arg0_029=param[1],res0_030=caml_call1(of_s_026,arg0_029);
      return [1,[0,_R_,[0,res0_030,0]]]}
    function t_sexp_grammar$8(f_sexp_grammar,s_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_First$1,[0,[0,f_sexp_grammar,0]]]],
                [0,[1,[0,cst_Second$1,[0,[0,s_sexp_grammar,0]]]],0]]]]}
    var
     include$20=
      [0,compare$16,hash_fold_t$10,t_of_sexp$11,sexp_of_t$13,t_sexp_grammar$8];
    caml_register_global(1016,include$20,"Base__Either0");
    function opaque_identity(_J6_){return _J6_}
    var For_generated_code=[0,opaque_identity];
    function name(param){return param[2]}
    function get(param,r){return caml_call1(param[4],r)}
    function fset(param,r,v){return caml_call2(param[5],r,v)}
    function setter(param){return param[3]}
    function map$3(field,r,f)
     {var _J5_=caml_call1(f,caml_call1(field[4],r));
      return caml_call2(field[5],r,_J5_)}
    function updater(field)
     {var _J4_=field[3];
      if(! _J4_)return 0;
      var setter=_J4_[1];
      return [0,
              function(r,f)
               {return caml_call2
                        (setter,r,caml_call1(f,caml_call1(field[4],r)))}]}
    var Base_Field=[0,For_generated_code,name,get,fset,setter,map$3,updater];
    caml_register_global(1017,Base_Field,"Base__Field");
    var
     String=[0],
     capitalize=Stdlib_StringLabels[27],
     compare$17=Stdlib_StringLabels[9];
    function copy$1(x){return unsafe_to_string(caml_call1(of_string$1,x))}
    var
     escaped=Stdlib_StringLabels[24],
     lowercase=Stdlib_StringLabels[26],
     make$1=Stdlib_StringLabels[1],
     sub$2=Stdlib_StringLabels[15],
     uncapitalize=Stdlib_StringLabels[28],
     unsafe_blit$0=caml_blit_string,
     uppercase=Stdlib_StringLabels[25];
    function concat$0(opt,l)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$0;
      if(! l)return cst;
      if(l[2])return caml_call2(Stdlib_StringLabels[6],sep,l);
      var x=l[1];
      return x}
    function iter$1(t,f){return caml_call2(Stdlib_StringLabels[29],f,t)}
    var
     include$21=
      [0,
       String,
       max_length,
       symbol$59,
       capitalize,
       compare$17,
       copy$1,
       escaped,
       lowercase,
       make$1,
       sub$2,
       uncapitalize,
       unsafe_blit$0,
       uppercase,
       concat$0,
       iter$1];
    caml_register_global(1019,include$21,"Base__String0");
    function compare$18(a_001,b_002)
     {if(a_001 === b_002)return 0;
      var n=caml_call2(compare_string$0,a_001[1],b_002[1]);
      if(0 !== n)return n;
      var n$0=caml_call2(compare$10,a_001[2],b_002[2]);
      if(0 !== n$0)return n$0;
      var n$1=caml_call2(compare$10,a_001[3],b_002[3]);
      return 0 === n$1?caml_call2(compare$10,a_001[4],b_002[4]):n$1}
    function hash_fold_t$11(hsv,arg)
     {var
       hsv$0=caml_call2(hash_fold_t$6,hsv,arg[1]),
       hsv$1=caml_call2(hash_fold_t$4,hsv$0,arg[2]),
       hsv$2=caml_call2(hash_fold_t$4,hsv$1,arg[3]);
      return caml_call2(hash_fold_t$4,hsv$2,arg[4])}
    function hash$0(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$11(hsv,x))}
    function sexp_of_t$14(param)
     {var
       pos_cnum_010=param[4],
       pos_bol_008=param[3],
       pos_lnum_006=param[2],
       pos_fname_004=param[1],
       arg_011=caml_call1(sexp_of_t$4,pos_cnum_010),
       bnds_003=[0,[1,[0,_S_,[0,arg_011,0]]],0],
       arg_009=caml_call1(sexp_of_t$4,pos_bol_008),
       bnds_003$0=[0,[1,[0,_T_,[0,arg_009,0]]],bnds_003],
       arg_007=caml_call1(sexp_of_t$4,pos_lnum_006),
       bnds_003$1=[0,[1,[0,_U_,[0,arg_007,0]]],bnds_003$0],
       arg_005=caml_call1(sexp_of_t$2,pos_fname_004),
       bnds_003$2=[0,[1,[0,_V_,[0,arg_005,0]]],bnds_003$1];
      return [1,bnds_003$2]}
    var
     T=[0,compare$18,hash_fold_t$11,hash$0,sexp_of_t$14],
     compare$19=T[1],
     hash_fold_t$12=T[2],
     hash$1=T[3],
     include$22=_P_([0,T[1],T[4]]),
     comparator$0=include$22[1];
    function make_location_string(pos_fname,pos_lnum,pos_cnum,pos_bol)
     {var _J3_=[0,cst$1,[0,caml_call1(to_string,pos_cnum - pos_bol | 0),0]];
      return concat$0
              (0,
               [0,pos_fname,[0,cst$2,[0,caml_call1(to_string,pos_lnum),_J3_]]])}
    function to_string$3(param)
     {var
       pos_cnum=param[4],
       pos_bol=param[3],
       pos_lnum=param[2],
       pos_fname=param[1];
      return make_location_string(pos_fname,pos_lnum,pos_cnum,pos_bol)}
    function sexp_of_t$15(t){return [0,to_string$3(t)]}
    var
     include$23=
      [0,
       T,
       compare$19,
       hash_fold_t$12,
       hash$1,
       comparator$0,
       make_location_string,
       to_string$3,
       sexp_of_t$15];
    caml_register_global(1020,include$23,"Base__Source_code_position0");
    var Base_Invariant_intf=[0];
    caml_register_global(1021,Base_Invariant_intf,"Base__Invariant_intf");
    function is_empty(param){return param?0:1}
    function partition_map(t,f)
     {var t$0=t,fst=0,snd=0;
      for(;;)
       {if(! t$0){var _J2_=rev(snd);return [0,rev(fst),_J2_]}
        var t$1=t$0[2],x=t$0[1],match=caml_call1(f,x);
        if(0 === match[0])
         {var y=match[1],fst$0=[0,y,fst],t$0=t$1,fst=fst$0;continue}
        var y$0=match[1],snd$0=[0,y$0,snd],t$0=t$1,snd=snd$0}}
    var
     include$24=
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold_left,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter$0,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort$0,
       rev,
       fold_right$0,
       is_empty,
       partition_map];
    caml_register_global(1022,include$24,"Base__List1");
    function t_of_sexp$12(of_a_001,of_b_002,sexp_007)
     {if(0 === sexp_007[0])
       {var _JY_=sexp_007[1],switch$0=0;
        if(caml_string_notequal(_JY_,cst_Error))
         {var switch$1=0;
          if(caml_string_notequal(_JY_,cst_Ok))
           if(caml_string_notequal(_JY_,cst_error))
            {if(caml_string_notequal(_JY_,cst_ok)){switch$0 = 1;switch$1 = 1}}
           else
            switch$1 = 1;
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_005,sexp_007)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_005,sexp_007)}
      else
       {var _JZ_=sexp_007[1];
        if(! _JZ_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_005,sexp_007);
        var _J0_=_JZ_[1];
        if(0 !== _J0_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_005,sexp_007);
        var _J1_=_J0_[1],switch$2=0;
        if(caml_string_notequal(_J1_,cst_Error$0))
         {var switch$3=0;
          if(caml_string_notequal(_J1_,cst_Ok$0))
           if(caml_string_notequal(_J1_,cst_error$0))
            {if(caml_string_notequal(_J1_,cst_ok$0))
              {switch$2 = 1;switch$3 = 1}}
           else
            switch$3 = 1;
          if(! switch$3)
           {var sexp_args_009=_JZ_[2];
            if(sexp_args_009 && ! sexp_args_009[2])
             {var
               arg0_010=sexp_args_009[1],
               res0_011=caml_call1(of_a_001,arg0_010);
              return [0,res0_011]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_005,_J1_,sexp_007)}}
        if(! switch$2)
         {var sexp_args_014=_JZ_[2];
          if(sexp_args_014 && ! sexp_args_014[2])
           {var
             arg0_015=sexp_args_014[1],
             res0_016=caml_call1(of_b_002,arg0_015);
            return [1,res0_016]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_005,_J1_,sexp_007)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_005,sexp_007)}
    function sexp_of_t$16(of_a_019,of_b_020,param)
     {if(0 === param[0])
       {var arg0_021=param[1],res0_022=caml_call1(of_a_019,arg0_021);
        return [1,[0,_W_,[0,res0_022,0]]]}
      var arg0_023=param[1],res0_024=caml_call1(of_b_020,arg0_023);
      return [1,[0,_X_,[0,res0_024,0]]]}
    function t_sexp_grammar$9(a_sexp_grammar,b_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Ok$1,[0,[0,a_sexp_grammar,0]]]],
                [0,[1,[0,cst_Error$1,[0,[0,b_sexp_grammar,0]]]],0]]]]}
    function compare$20(cmp_a,cmp_b,a_027,b_028)
     {if(a_027 === b_028)return 0;
      if(0 === a_027[0])
       {var _JW_=a_027[1];
        if(0 !== b_028[0])return -1;
        var b_030=b_028[1];
        return caml_call2(cmp_a,_JW_,b_030)}
      var _JX_=a_027[1];
      if(0 === b_028[0])return 1;
      var b_032=b_028[1];
      return caml_call2(cmp_b,_JX_,b_032)}
    function equal$9(cmp_a,cmp_b,a_033,b_034)
     {if(a_033 === b_034)return 1;
      if(0 === a_033[0])
       {var _JU_=a_033[1];
        if(0 !== b_034[0])return 0;
        var b_036=b_034[1];
        return caml_call2(cmp_a,_JU_,b_036)}
      var _JV_=a_033[1];
      if(0 === b_034[0])return 0;
      var b_038=b_034[1];
      return caml_call2(cmp_b,_JV_,b_038)}
    function hash_fold_t$13(hash_fold_a,hash_fold_b,hsv,arg)
     {if(0 === arg[0])
       {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
        return caml_call2(hash_fold_a,hsv$0,a0)}
      var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
      return caml_call2(hash_fold_b,hsv$1,a0$0)}
    function bind$1(x,f)
     {if(0 !== x[0])return x;var x$0=x[1];return caml_call1(f,x$0)}
    var
     map$4=
      [0,
       -198771759,
       function(x,f)
        {if(0 !== x[0])return x;var x$0=x[1];return [0,caml_call1(f,x$0)]}];
    function return$2(x){return [0,x]}
    var
     include$25=Make2([0,bind$1,map$4,return$2]),
     symbol_bind$0=include$25[1],
     symbol_map$0=include$25[2],
     Let_syntax$0=include$25[3],
     include$26=include$25[4],
     bind$2=include$25[5],
     return$3=include$25[6],
     map$5=include$25[7],
     join$0=include$25[8],
     ignore_m$0=include$25[9],
     all$1=include$25[10],
     all_unit$0=include$25[11];
    function invariant$0(check_ok,check_error,t)
     {if(0 === t[0]){var ok=t[1];return caml_call1(check_ok,ok)}
      var error=t[1];
      return caml_call1(check_error,error)}
    function fail(x){return [1,x]}
    function failf(format){return caml_call2(ksprintf,fail,format)}
    function map_error(t,f)
     {if(0 === t[0])return t;var x=t[1];return [1,caml_call1(f,x)]}
    function bind$3(x,f)
     {if(0 === x[0])return x;var e=x[1];return caml_call1(f,e)}
    var map$6=[0,-198771759,map_error];
    function return$4(e){return [1,e]}
    var Error=Make2([0,bind$3,map$6,return$4]);
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function ok(param){if(0 !== param[0])return 0;var x=param[1];return [0,x]}
    function error(param)
     {if(0 === param[0])return 0;var x=param[1];return [0,x]}
    function of_option(opt,error)
     {if(! opt)return [1,error];var x=opt[1];return [0,x]}
    function iter$2(v,f)
     {if(0 !== v[0])return 0;var x=v[1];return caml_call1(f,x)}
    function iter_error(v,f)
     {if(0 === v[0])return 0;var x=v[1];return caml_call1(f,x)}
    function to_either(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}
      var x$0=param[1];
      return [1,x$0]}
    function of_either(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}
      var x$0=param[1];
      return [1,x$0]}
    function ok_if_true(bool,error){return bool?_Y_:[1,error]}
    function try_with(f)
     {try
       {var _JT_=[0,caml_call1(f,0)];return _JT_}
      catch(exn){exn = caml_wrap_exception(exn);return [1,exn]}}
    function ok_exn(param)
     {if(0 === param[0]){var x=param[1];return x}var exn=param[1];throw exn}
    function ok_or_failwith(param)
     {if(0 === param[0]){var x=param[1];return x}
      var str=param[1];
      return caml_call1(failwith$0,str)}
    function combine(t1,t2,ok,err)
     {if(0 === t1[0])
       {var _JR_=t1[1];
        if(0 === t2[0]){var ok2=t2[1];return [0,caml_call2(ok,_JR_,ok2)]}
        var e=t2[1]}
      else
       {var _JS_=t1[1];
        if(0 !== t2[0]){var err2=t2[1];return [1,caml_call2(err,_JS_,err2)]}
        var e=_JS_}
      return [1,e]}
    function combine_errors(l)
     {var match=partition_map(l,to_either),errs=match[2],ok=match[1];
      return errs?[1,errs]:[0,ok]}
    function combine_errors_unit(l)
     {function _JQ_(param){return 0}
      return caml_call2(map$5,combine_errors(l),_JQ_)}
    var
     Base_Result=
      [0,
       t_of_sexp$12,
       sexp_of_t$16,
       t_sexp_grammar$9,
       compare$20,
       equal$9,
       hash_fold_t$13,
       symbol_bind$0,
       symbol_map$0,
       Let_syntax$0,
       include$26,
       bind$2,
       return$3,
       join$0,
       ignore_m$0,
       all$1,
       all_unit$0,
       Error,
       invariant$0,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter$2,
       iter_error,
       map$5,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0,is_ok,is_error]];
    caml_register_global(1023,Base_Result,"Base__Result");
    var
     Continue_or_stop=[0],
     include$27=[0,Continue_or_stop],
     Continue_or_stop$0=include$27[1],
     Base_Container_intf=[0,include$27,Continue_or_stop$0];
    caml_register_global(1024,Base_Container_intf,"Base__Container_intf");
    function iter$3(fold,t,f)
     {return caml_call3(fold,t,0,function(param,a){return caml_call1(f,a)})}
    function count(fold,t,f)
     {return caml_call3
              (fold,t,0,function(n,a){return caml_call1(f,a)?n + 1 | 0:n})}
    function sum(fold,M)
     {return function(t,f)
       {function _JO_(n,a)
         {var _JP_=caml_call1(f,a);return caml_call2(M[2],n,_JP_)}
        return caml_call3(fold,t,M[1],_JO_)}}
    function fold_result(fold,init,f,t)
     {return with_return
              (function(param)
                {return [0,
                         caml_call3
                          (fold,
                           t,
                           init,
                           function(acc,item)
                            {var e=caml_call2(f,acc,item);
                             if(0 !== e[0])return caml_call1(param,e);
                             var x=e[1];
                             return x})]})}
    function fold_until(fold,init,f,finish,t)
     {return with_return
              (function(param)
                {return caml_call1
                         (finish,
                          caml_call3
                           (fold,
                            t,
                            init,
                            function(acc,item)
                             {var match=caml_call2(f,acc,item);
                              if(0 === match[0]){var x=match[1];return x}
                              var x$0=match[1];
                              return caml_call1(param,x$0)}))})}
    function min_elt(fold,t,compare)
     {return caml_call3
              (fold,
               t,
               0,
               function(acc,elt)
                {if(! acc)return [0,elt];
                 var min=acc[1];
                 return 0 < caml_call2(compare,min,elt)?[0,elt]:acc})}
    function max_elt(fold,t,compare)
     {return caml_call3
              (fold,
               t,
               0,
               function(acc,elt)
                {if(! acc)return [0,elt];
                 var max=acc[1];
                 return 0 <= caml_call2(compare,max,elt)?acc:[0,elt]})}
    function length$0(fold,c)
     {return caml_call3(fold,c,0,function(acc,param){return acc + 1 | 0})}
    function is_empty$0(iter,c)
     {return with_return
              (function(r)
                {caml_call2(iter,c,function(param){return caml_call1(r,0)});
                 return 1})}
    function exists$0(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JN_=caml_call1(f,x);return _JN_?caml_call1(r,1):_JN_});
                 return 0})}
    function for_all$0(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JM_=1 - caml_call1(f,x);
                     return _JM_?caml_call1(r,0):_JM_});
                 return 1})}
    function find_map(iter,t,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   t,
                   function(x)
                    {var res=caml_call1(f,x);return res?caml_call1(r,res):0});
                 return 0})}
    function find(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JL_=caml_call1(f,x);
                     return _JL_?caml_call1(r,[0,x]):_JL_});
                 return 0})}
    function to_list$0(fold,c)
     {return rev(caml_call3(fold,c,0,function(acc,x){return [0,x,acc]}))}
    function to_array(length,iter,c)
     {var array=[0,[0]],i=[0,0];
      caml_call2
       (iter,
        c,
        function(x)
         {if(0 === i[1])array[1] = caml_make_vect(caml_call1(length,c),x);
          var _JK_=i[1];
          caml_check_bound(array[1],_JK_)[1 + _JK_] = x;
          return incr(i)});
      return array[1]}
    function Make_gen(T)
     {var _JG_=T[1],_JH_=T[2];
      if(typeof _JH_ === "number")
       var _JI_=function(t,f){return iter$3(_JG_,t,f)};
      else
       var iter=_JH_[2],_JI_=iter;
      var _JJ_=T[3];
      if(typeof _JJ_ === "number")
       var length=function(t){return length$0(_JG_,t)};
      else
       var length$1=_JJ_[2],length=length$1;
      function is_empty(t){return is_empty$0(_JI_,t)}
      function sum$0(m,t){return caml_call1(sum(_JG_,m),t)}
      function count$0(t,f){return count(_JG_,t,f)}
      function exists(t,f){return exists$0(_JI_,t,f)}
      function for_all(t,f){return for_all$0(_JI_,t,f)}
      function find_map$0(t,f){return find_map(_JI_,t,f)}
      function find$0(t,f){return find(_JI_,t,f)}
      function to_list(t){return to_list$0(_JG_,t)}
      function to_array$0(t){return to_array(length,_JI_,t)}
      function min_elt$0(t,compare){return min_elt(_JG_,t,compare)}
      function max_elt$0(t,compare){return max_elt(_JG_,t,compare)}
      function fold_result$0(t,init,f){return fold_result(_JG_,init,f,t)}
      function fold_until$0(t,init,f,finish)
       {return fold_until(_JG_,init,f,finish,t)}
      return [0,
              length,
              is_empty,
              _JI_,
              _JG_,
              fold_result$0,
              fold_until$0,
              exists,
              for_all,
              count$0,
              sum$0,
              find$0,
              find_map$0,
              to_list,
              to_array$0,
              min_elt$0,
              max_elt$0]}
    function _Z_(T)
     {var
       fold=T[2],
       iter=T[3],
       length=T[4],
       include=Make_gen([0,fold,iter,length]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16];
      function mem(t,elt){return caml_call2(exists,t,caml_call1(T[1][1],elt))}
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt]}
    function ___(T)
     {var
       fold=T[1],
       iter=T[2],
       length=T[3],
       include=Make_gen([0,fold,iter,length]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16];
      function mem(t,a,equal){return caml_call2(exists,t,caml_call1(equal,a))}
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt]}
    var
     Base_Container=
      [0,
       iter$3,
       count,
       min_elt,
       max_elt,
       length$0,
       to_list$0,
       sum,
       fold_result,
       fold_until,
       is_empty$0,
       exists$0,
       for_all$0,
       find,
       find_map,
       to_array,
       ___,
       _Z_,
       Make_gen];
    caml_register_global(1025,Base_Container,"Base__Container");
    var
     Undefined=Stdlib_Lazy[1],
     is_val=Stdlib_Lazy[3],
     from_val=Stdlib_Lazy[4],
     from_fun=Stdlib_Lazy[6],
     force_val=Stdlib_Lazy[7];
    function t_sexp_grammar$10(a_sexp_grammar)
     {return caml_call1(lazy_t_sexp_grammar,a_sexp_grammar)}
    function _$_(t,f)
     {return [246,
              function(_JD_)
               {var
                 _JE_=caml_obj_tag(t),
                 _JF_=
                  250 === _JE_
                   ?t[1]
                   :246 === _JE_?caml_call1(CamlinternalLazy[2],t):t;
                return caml_call1(f,_JF_)}]}
    function compare$21(compare_a,t1,t2)
     {if(t1 === t2)return 0;
      var
       _Jz_=caml_obj_tag(t2),
       _JA_=
        250 === _Jz_?t2[1]:246 === _Jz_?caml_call1(CamlinternalLazy[2],t2):t2,
       _JB_=caml_obj_tag(t1),
       _JC_=
        250 === _JB_?t1[1]:246 === _JB_?caml_call1(CamlinternalLazy[2],t1):t1;
      return caml_call2(compare_a,_JC_,_JA_)}
    function equal$10(equal_a,t1,t2)
     {if(t1 === t2)return 1;
      var
       _Jv_=caml_obj_tag(t2),
       _Jw_=
        250 === _Jv_?t2[1]:246 === _Jv_?caml_call1(CamlinternalLazy[2],t2):t2,
       _Jx_=caml_obj_tag(t1),
       _Jy_=
        250 === _Jx_?t1[1]:246 === _Jx_?caml_call1(CamlinternalLazy[2],t1):t1;
      return caml_call2(equal_a,_Jy_,_Jw_)}
    var hash_fold_t$14=_l_[12];
    function return$5(x){return caml_call1(from_val,x)}
    function bind$4(t,f)
     {return [246,
              function(_Jq_)
               {var
                 _Jr_=caml_obj_tag(t),
                 _Js_=
                  250 === _Jr_
                   ?t[1]
                   :246 === _Jr_?caml_call1(CamlinternalLazy[2],t):t,
                 _Jt_=caml_call1(f,_Js_),
                 _Ju_=caml_obj_tag(_Jt_);
                return 250 === _Ju_
                        ?_Jt_[1]
                        :246 === _Ju_?caml_call1(CamlinternalLazy[2],_Jt_):_Jt_}]}
    var
     map$7=[0,-198771759,_$_],
     include$28=Make([0,bind$4,return$5,map$7]),
     symbol_bind$1=include$28[1],
     symbol_map$1=include$28[2],
     Monad_infix$0=include$28[3],
     bind$5=include$28[4],
     return$6=include$28[5],
     map$8=include$28[6],
     join$1=include$28[7],
     ignore_m$1=include$28[8],
     all$2=include$28[9],
     all_unit$1=include$28[10],
     Let_syntax$1=include$28[11];
    function sexp_of_t$17(sexp_of_a,t)
     {if(! caml_call1(is_val,t))
       return caml_call1(sexp_of_t$2,cst_unforced_lazy);
      var
       _Jo_=caml_obj_tag(t),
       _Jp_=250 === _Jo_?t[1]:246 === _Jo_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(sexp_of_a,_Jp_)}
    var
     T_unforcing=[0,sexp_of_t$17],
     Base_Lazy=
      [0,
       compare$21,
       equal$10,
       hash_fold_t$14,
       t_of_sexp$9,
       sexp_of_t$9,
       t_sexp_grammar$10,
       symbol_bind$1,
       symbol_map$1,
       Monad_infix$0,
       bind$5,
       return$6,
       map$8,
       join$1,
       ignore_m$1,
       all$2,
       all_unit$1,
       Let_syntax$1,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
    caml_register_global(1027,Base_Lazy,"Base__Lazy");
    var Base_Info_intf=[0];
    caml_register_global(1028,Base_Info_intf,"Base__Info_intf");
    function slow_check_pos_len_exn(pos,len,total_length)
     {if(pos < 0)caml_call2(invalid_argf(_aa_),pos,0);
      if(len < 0)caml_call2(invalid_argf(_ab_),len,0);
      var _Jn_=(total_length - len | 0) < pos?1:0;
      return _Jn_?caml_call4(invalid_argf(_ac_),pos,len,total_length,0):_Jn_}
    function check_pos_len_exn(pos,len,total_length)
     {var
       stop=pos + len | 0,
       _Jm_=(pos | len | stop | total_length - stop | 0) < 0?1:0;
      return _Jm_?slow_check_pos_len_exn(pos,len,total_length):_Jm_}
    function get_pos_len_exn(opt,len,param,total_length)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)var i=len[1],len$0=i;else var len$0=total_length - pos | 0;
      check_pos_len_exn(pos,len$0,total_length);
      return [0,pos,len$0]}
    var
     Private$1=[0,slow_check_pos_len_exn],
     include$29=[0,get_pos_len_exn,check_pos_len_exn,Private$1];
    caml_register_global(1029,include$29,"Base__Ordered_collection_common0");
    function of_state(_Jl_){return _Jl_}
    var Repr=[0,of_state];
    function assign(t1,t2)
     {var
       _Jh_=caml_obj_tag(t1),
       _Ji_=
        250 === _Jh_?t1[1]:246 === _Jh_?caml_call1(CamlinternalLazy[2],t1):t1,
       t1$0=caml_call1(Repr[1],_Ji_),
       _Jj_=caml_obj_tag(t2),
       _Jk_=
        250 === _Jj_?t2[1]:246 === _Jj_?caml_call1(CamlinternalLazy[2],t2):t2,
       t2$0=caml_call1(Repr[1],_Jk_);
      caml_call5(blit,t2$0[1],0,t1$0[1],0,t1$0[1].length - 1);
      t1$0[2] = t2$0[2];
      return 0}
    function make_default(default$0){return default$0}
    function get_state(state){return state}
    var Base_Random_repr=[0,Repr,assign,make_default,get_state];
    caml_register_global(1030,Base_Random_repr,"Base__Random_repr");
    function forbid_nondeterminism_in_tests(allow_in_tests)
     {if(! am_testing)return am_testing;
      if(allow_in_tests && allow_in_tests[1])return 0;
      return caml_call1(failwith$0,cst_initializing_Random_with_a)}
    function bits(t)
     {var
       _Jf_=caml_obj_tag(t),
       _Jg_=250 === _Jf_?t[1]:246 === _Jf_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(Stdlib_Random[15][4],_Jg_)}
    function bool(t)
     {var
       _Jd_=caml_obj_tag(t),
       _Je_=250 === _Jd_?t[1]:246 === _Jd_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(Stdlib_Random[15][11],_Je_)}
    function int$0(t,x)
     {var
       _Jb_=caml_obj_tag(t),
       _Jc_=250 === _Jb_?t[1]:246 === _Jb_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][5],_Jc_,x)}
    function int32(t,x)
     {var
       _I$_=caml_obj_tag(t),
       _Ja_=250 === _I$_?t[1]:246 === _I$_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][7],_Ja_,x)}
    function int64(t,x)
     {var
       _I9_=caml_obj_tag(t),
       _I__=250 === _I9_?t[1]:246 === _I9_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][9],_I__,x)}
    function nativeint(t,x)
     {var
       _I7_=caml_obj_tag(t),
       _I8_=250 === _I7_?t[1]:246 === _I7_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][8],_I8_,x)}
    function make$2(seed)
     {return caml_call1(from_val,caml_call1(Stdlib_Random[15][1],seed))}
    function copy$2(t)
     {var
       _I5_=caml_obj_tag(t),
       _I6_=250 === _I5_?t[1]:246 === _I5_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(from_val,caml_call1(Stdlib_Random[15][3],_I6_))}
    function char$0(t){return int$0(t,256)}
    function ascii(t){return int$0(t,128)}
    function make_self_init(allow_in_tests,param)
     {forbid_nondeterminism_in_tests(allow_in_tests);
      return caml_call1(from_val,caml_call1(Stdlib_Random[15][2],0))}
    if(am_testing)
     {var t=caml_call1(Stdlib_Random[16],0);
      caml_call1(Stdlib_Random[1],137);
      var _ad_=caml_call1(from_val,t)}
    else
     var
      _ad_=
       [246,
        function(_I2_)
         {var _I3_=make_self_init(0,0),_I4_=caml_obj_tag(_I3_);
          return 250 === _I4_
                  ?_I3_[1]
                  :246 === _I4_?caml_call1(CamlinternalLazy[2],_I3_):_I3_}];
    function int_on_64bits(t,bound)
     {return 1073741823 < bound
              ?caml_int64_to_int32(int64(t,caml_int64_of_int32(bound)))
              :int$0(t,bound)}
    function int_on_32bits(t,bound)
     {return 1073741823 < bound?int32(t,bound):int$0(t,bound)}
    var int$1=word_size?int_on_64bits:int_on_32bits;
    function bits$0(state){return caml_int64_of_int32(bits(state))}
    function full_range_int64(state)
     {var
       _I0_=caml_int64_shift_left(bits$0(state),60),
       _I1_=caml_int64_xor(caml_int64_shift_left(bits$0(state),30),_I0_);
      return caml_int64_xor(bits$0(state),_I1_)}
    function bits$1(state){return bits(state)}
    function full_range_int32(state)
     {var _IZ_=bits$1(state) << 30;return bits$1(state) ^ _IZ_}
    function full_range_int_on_64bits(state)
     {return caml_int64_to_int32(full_range_int64(state))}
    function full_range_int_on_32bits(state){return full_range_int32(state)}
    var
     full_range_int_on_64bits$0=
      word_size?full_range_int_on_64bits:full_range_int_on_32bits;
    function full_range_nativeint_on_64bits(state)
     {return caml_int64_to_int32(full_range_int64(state))}
    function full_range_nativeint_on_32bits(state)
     {return full_range_int32(state)}
    var
     full_range_nativeint=
      word_size?full_range_nativeint_on_64bits:full_range_nativeint_on_32bits;
    function raise_crossed_bounds
     (name,lower_bound,upper_bound,string_of_bound)
     {var
       _IX_=caml_call1(string_of_bound,upper_bound),
       _IY_=caml_call1(string_of_bound,lower_bound);
      return caml_call4(failwithf(_ae_),name,_IY_,_IX_,0)}
    function int_incl(state,lo,hi)
     {if(hi < lo)raise_crossed_bounds(cst_int,lo,hi,to_string);
      var diff=hi - lo | 0;
      if(diff === max_value$0)
       return lo + (full_range_int_on_64bits$0(state) & max_value$0) | 0;
      if(0 <= diff)return lo + int$1(state,diff + 1 | 0) | 0;
      for(;;)
       {var int$0=full_range_int_on_64bits$0(state);
        if(lo <= int$0 && int$0 <= hi)return int$0}}
    function int32_incl(state,lo,hi)
     {if(caml_call2(Int32_replace_polymorphic_comp[5],lo,hi))
       raise_crossed_bounds(cst_int32,lo,hi,Stdlib_Int32[14]);
      var diff=hi - lo | 0;
      if(caml_call2(Int32_replace_polymorphic_comp[4],diff,Stdlib_Int32[9]))
       {var _IW_=Stdlib_Int32[9];
        return lo + (full_range_int32(state) & _IW_) | 0}
      if(caml_call2(Int32_replace_polymorphic_comp[6],diff,0))
       return lo + int32(state,caml_call1(Stdlib_Int32[6],diff)) | 0;
      for(;;)
       {var int$0=full_range_int32(state);
        if
         (caml_call2(Int32_replace_polymorphic_comp[6],int$0,lo)
          &&
          caml_call2(Int32_replace_polymorphic_comp[2],int$0,hi))
         return int$0}}
    function nativeint_incl(state,lo,hi)
     {if(caml_call2(include$3[5],lo,hi))
       raise_crossed_bounds(cst_nativeint,lo,hi,Stdlib_Nativeint[15]);
      var diff=hi - lo | 0;
      if(caml_call2(include$3[4],diff,Stdlib_Nativeint[10]))
       {var _IV_=Stdlib_Nativeint[10];
        return lo + (full_range_nativeint(state) & _IV_) | 0}
      if(caml_call2(include$3[6],diff,0))
       return lo + nativeint(state,caml_call1(Stdlib_Nativeint[6],diff)) | 0;
      for(;;)
       {var int$0=full_range_nativeint(state);
        if
         (caml_call2(include$3[6],int$0,lo)
          &&
          caml_call2(include$3[2],int$0,hi))
         return int$0}}
    function int64_incl(state,lo,hi)
     {if(caml_greaterthan(lo,hi))
       raise_crossed_bounds(cst_int64,lo,hi,Stdlib_Int64[14]);
      var diff=caml_int64_sub(hi,lo);
      if(caml_equal(diff,Stdlib_Int64[9]))
       {var _IU_=Stdlib_Int64[9];
        return caml_int64_add(lo,caml_int64_and(full_range_int64(state),_IU_))}
      if(caml_greaterequal(diff,_af_))
       return caml_int64_add(lo,int64(state,caml_call1(Stdlib_Int64[6],diff)));
      for(;;)
       {var int$0=full_range_int64(state);
        if(caml_greaterequal(int$0,lo) && caml_lessequal(int$0,hi))
         return int$0}}
    function float$0(state,hi)
     {for(;;)
       {var
         r1=bits(state),
         r2=bits(state),
         result=(r1 * 9.31322574615478516e-10 + r2) * 9.31322574615478516e-10;
        if(caml_call2(include$7[1],result,1.))return result * hi}}
    function float_range(state,lo,hi)
     {if(caml_call2(include$7[5],lo,hi))
       raise_crossed_bounds(cst_float,lo,hi,Caml$0[34]);
      return lo + float$0(state,hi - lo)}
    function bits$2(param){return bits(_ad_)}
    function int$2(x){return int$1(_ad_,x)}
    function int32$0(x){return int32(_ad_,x)}
    function nativeint$0(x){return nativeint(_ad_,x)}
    function int64$0(x){return int64(_ad_,x)}
    function float$1(x){return float$0(_ad_,x)}
    function int_incl$0(x,y){return int_incl(_ad_,x,y)}
    function int32_incl$0(x,y){return int32_incl(_ad_,x,y)}
    function nativeint_incl$0(x,y){return nativeint_incl(_ad_,x,y)}
    function int64_incl$0(x,y){return int64_incl(_ad_,x,y)}
    function float_range$0(x,y){return float_range(_ad_,x,y)}
    function bool$0(param){return bool(_ad_)}
    function char$1(param){return char$0(_ad_)}
    function ascii$0(param){return ascii(_ad_)}
    function full_init(seed){return assign(_ad_,make$2(seed))}
    function init$0(seed){return full_init([0,seed])}
    function self_init(allow_in_tests,param)
     {forbid_nondeterminism_in_tests(allow_in_tests);
      return full_init(runtime.caml_sys_random_seed(0))}
    function set_state(s){return assign(_ad_,s)}
    var
     _ag_=
      [0,
       _ad_,
       make$2,
       make_self_init,
       copy$2,
       bits,
       int$1,
       int32,
       nativeint,
       int64,
       float$0,
       int_incl,
       int32_incl,
       nativeint_incl,
       int64_incl,
       float_range,
       bool,
       char$0,
       ascii],
     Base_Random=
      [0,
       init$0,
       full_init,
       self_init,
       bits$2,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       _ag_,
       set_state];
    caml_register_global(1035,Base_Random,"Base__Random");
    function permute(opt,_IS_,len,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(_IS_)var sth$0=_IS_[1],pos=sth$0;else var pos=0;
      var total_length=t.length - 1;
      if(len)var l=len[1],len$0=l;else var len$0=total_length - pos | 0;
      check_pos_len_exn(pos,len$0,total_length);
      var num_swaps=len$0 - 1 | 0;
      if(num_swaps >= 1)
       {var i=num_swaps;
        for(;;)
         {var
           this_i=pos + i | 0,
           random_i=pos + caml_call2(_ag_[6],random_state,i + 1 | 0) | 0;
          swap(t,this_i,random_i);
          var _IT_=i - 1 | 0;
          if(1 !== i){var i=_IT_;continue}
          break}}
      return 0}
    var
     Base_Array_permute=
      [0,
       invalid_argf,
       Array,
       max_length$0,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub$0,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
    caml_register_global(1036,Base_Array_permute,"Base__Array_permute");
    var Base_Equal=[0];
    caml_register_global(1037,Base_Equal,"Base__Equal");
    function const$0(c,param){return c}
    function non(f,x){return 1 - caml_call1(f,x)}
    function forever(f)
     {function forever(param){for(;;)caml_call1(f,0)}
      try
       {var _IR_=forever(0);return _IR_}
      catch(e){e = caml_wrap_exception(e);return e}}
    function compose(f,g,x){return caml_call1(f,caml_call1(g,x))}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function apply_n_times(n,f,x)
     {var n$0=n,x$0=x;
      for(;;)
       {if(0 >= n$0)return x$0;
        var x$1=caml_call1(f,x$0),n$1=n$0 - 1 | 0,n$0=n$1,x$0=x$1}}
    var Base_Fn=[0,const$0,non,forever,apply_n_times,compose,flip];
    caml_register_global(1038,Base_Fn,"Base__Fn");
    var compare$22=caml_int_compare;
    function hash_fold_t$15(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function hash$2(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$15(hsv,x))}
    function t_of_sexp$13(sexp_006)
     {if(0 === sexp_006[0])
       {var _IN_=sexp_006[1],switch$0=0;
        if(caml_string_notequal(_IN_,cst_Equal))
         {var switch$1=0;
          if(caml_string_notequal(_IN_,cst_Greater))
           {var switch$2=0;
            if(caml_string_notequal(_IN_,cst_Less))
             if(caml_string_notequal(_IN_,cst_equal))
              if(caml_string_notequal(_IN_,cst_greater))
               {if(caml_string_notequal(_IN_,cst_less))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 0}
          if(! switch$1)return 2}
        if(! switch$0)return 1}
      else
       {var _IO_=sexp_006[1];
        if(! _IO_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_005$0,sexp_006);
        var _IP_=_IO_[1];
        if(0 !== _IP_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_005$0,sexp_006);
        var _IQ_=_IP_[1],switch$3=0;
        if(caml_string_notequal(_IQ_,cst_Equal$0))
         {var switch$4=0;
          if(caml_string_notequal(_IQ_,cst_Greater$0))
           {var switch$5=0;
            if(caml_string_notequal(_IQ_,cst_Less$0))
             if(caml_string_notequal(_IQ_,cst_equal$0))
              if(caml_string_notequal(_IQ_,cst_greater$0))
               {if(caml_string_notequal(_IQ_,cst_less$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_005$0,sexp_006)}
    function sexp_of_t$18(param)
     {switch(param){case 0:return _ah_;case 1:return _ai_;default:return _aj_}}
    function equal$11(a,b){return 0 === caml_int_compare(a,b)?1:0}
    var Export=[0];
    function of_int$0(n){return 0 <= n?0 === n?1:2:0}
    function to_int$0(param)
     {switch(param){case 0:return -1;case 1:return 0;default:return 1}}
    var
     Base_Ordering=
      [0,
       compare$22,
       hash_fold_t$15,
       hash$2,
       t_of_sexp$13,
       sexp_of_t$18,
       t_sexp_grammar$11,
       all$3,
       equal$11,
       of_int$0,
       to_int$0,
       Export];
    caml_register_global(1039,Base_Ordering,"Base__Ordering");
    var
     Base_Sys=
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       num_bits,
       big_endian,
       max_length,
       max_length$0,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
    caml_register_global(1040,Base_Sys,"Base__Sys");
    function t_sexp_grammar$12(a_sexp_grammar)
     {return caml_call1(list_sexp_grammar,a_sexp_grammar)}
    function compare$23(cmp_a,a_006,b_007)
     {if(a_006 === b_007)return 0;
      if(! a_006)return b_007?1:0;
      var _IM_=a_006[1];
      if(! b_007)return -1;
      var b_009=b_007[1];
      return caml_call2(cmp_a,_IM_,b_009)}
    function sexp_of_t$19(of_a_010,param)
     {if(! param)return _al_;
      var arg0_011=param[1],res0_012=caml_call1(of_a_010,arg0_011);
      return [1,[0,_ak_,[0,res0_012,0]]]}
    var Or_unequal_lengths=[0,compare$23,sexp_of_t$19];
    function invariant$1(f,t){return iter$0(t,f)}
    function of_list$0(t){return t}
    function range(compare,stride,opt,_IK_,start_i,stop_i)
     {if(opt)var sth=opt[1],start=sth;else var start=104758188;
      if(_IK_)var sth$0=_IK_[1],stop=sth$0;else var stop=-160346914;
      var next_i=caml_call1(stride,start_i);
      function order(x,y){return of_int$0(caml_call2(compare,x,y))}
      function raise_stride_cannot_return_sam(param)
       {return caml_call1(invalid_arg$0,cst_List_range_stride_function)}
      var match=order(start_i,next_i);
      switch(match)
       {case 0:var initial_stride_order=847855481;break;
        case 1:
         var initial_stride_order=raise_stride_cannot_return_sam(0);break;
        default:var initial_stride_order=85047514}
      var start_i$0=104758188 <= start?start_i:next_i,i=start_i$0,accum=0;
      for(;;)
       {var i_to_stop_order=order(i,stop_i),switch$0=0;
        switch(i_to_stop_order)
         {case 0:switch$0 = 847855481 <= initial_stride_order?1:2;break;
          case 1:var _IL_=104758188 <= stop?[0,i,accum]:accum;break;
          default:switch$0 = 847855481 <= initial_stride_order?2:1}
        switch(switch$0)
         {case 1:
           var
            next_i$0=caml_call1(stride,i),
            match$0=order(i,next_i$0),
            switch$1=0;
           switch(match$0)
            {case 0:switch$1 = 847855481 <= initial_stride_order?2:1;break;
             case 1:var _IL_=raise_stride_cannot_return_sam(0);break;
             default:switch$1 = 847855481 <= initial_stride_order?1:2}
           switch(switch$1)
            {case 1:
              var
               _IL_=
                caml_call1(invalid_arg$0,cst_List_range_stride_function$0);
              break;
             case 2:var accum$0=[0,i,accum],i=next_i$0,accum=accum$0;continue
             }
           break;
          case 2:var _IL_=accum;break
          }
        return rev(_IL_)}}
    function range$0(opt,_IH_,_IG_,start_i,stop_i)
     {if(opt)var sth=opt[1],stride=sth;else var stride=1;
      if(_IH_)var sth$0=_IH_[1],start=sth$0;else var start=104758188;
      if(_IG_)var sth$1=_IG_[1],stop=sth$1;else var stop=-160346914;
      if(0 === stride)
       caml_call1(invalid_arg$0,cst_List_range_stride_must_be_);
      var _II_=[0,stop],_IJ_=[0,start];
      return range
              (caml_int_compare,
               function(x){return x + stride | 0},
               _IJ_,
               _II_,
               start_i,
               stop_i)}
    function hd(t){if(! t)return 0;var x=t[1];return [0,x]}
    function tl(t){if(! t)return 0;var t$0=t[2];return [0,t$0]}
    function nth(t,n)
     {if(0 > n)return 0;
      var t$0=t,n$0=n;
      for(;;)
       {if(! t$0)return 0;
        var t$1=t$0[2],a=t$0[1];
        if(0 === n$0)return [0,a];
        var n$1=n$0 - 1 | 0,t$0=t$1,n$0=n$1}}
    function nth_exn(t,n)
     {var match=nth(t,n);
      if(match){var a=match[1];return a}
      var _IF_=caml_call1(length,t);
      return caml_call3(invalid_argf(_am_),n,_IF_,0)}
    function unordered_append(l1,l2)
     {if(l1){if(l2)return caml_call2(rev_append,l1,l2);var l=l1}else var l=l2;
      return l}
    function of_lists(a,b)
     {var a$0=a,b$0=b,shared_length=0;
      for(;;)
       {if(a$0)
         {if(b$0)
           {var
             b$1=b$0[2],
             a$1=a$0[2],
             shared_length$0=shared_length + 1 | 0,
             a$0=a$1,
             b$0=b$1,
             shared_length=shared_length$0;
            continue}}
        else
         if(! b$0)return [0,shared_length];
        return [1,shared_length,a$0,b$0]}}
    function check_length2_exn(name,l1,l2)
     {var match=of_lists(l1,l2);
      if(0 === match[0])return 0;
      var
       tail_of_b=match[3],
       tail_of_a=match[2],
       shared_length=match[1],
       _ID_=shared_length + caml_call1(length,tail_of_b) | 0,
       _IE_=shared_length + caml_call1(length,tail_of_a) | 0;
      return caml_call4(invalid_argf(_an_),name,_IE_,_ID_,0)}
    function check_length2(l1,l2,f)
     {var match=of_lists(l1,l2);
      return 0 === match[0]?[0,caml_call2(f,l1,l2)]:0}
    function of_lists$0(a,b,c)
     {var a$0=a,b$0=b,c$0=c,shared_length=0;
      for(;;)
       {if(a$0)
         {if(b$0 && c$0)
           {var
             c$1=c$0[2],
             b$1=b$0[2],
             a$1=a$0[2],
             shared_length$0=shared_length + 1 | 0,
             a$0=a$1,
             b$0=b$1,
             c$0=c$1,
             shared_length=shared_length$0;
            continue}}
        else
         if(! b$0 && ! c$0)return [0,shared_length];
        return [1,shared_length,a$0,b$0,c$0]}}
    function check_length3_exn(name,l1,l2,l3)
     {var match=of_lists$0(l1,l2,l3);
      if(0 === match[0])return 0;
      var
       tail_of_c=match[4],
       tail_of_b=match[3],
       tail_of_a=match[2],
       shared_length=match[1],
       n1=shared_length + caml_call1(length,tail_of_a) | 0,
       n2=shared_length + caml_call1(length,tail_of_b) | 0,
       n3=shared_length + caml_call1(length,tail_of_c) | 0;
      return caml_call6(invalid_argf(_ao_),name,n1,n2,n2,n3,0)}
    function check_length3(l1,l2,l3,f)
     {var match=of_lists$0(l1,l2,l3);
      return 0 === match[0]?[0,caml_call3(f,l1,l2,l3)]:0}
    function iter2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_IB_)
                {return function(_IC_){return iter2_ok(_IB_,_IC_,f)}})}
    function iter2_exn(l1,l2,f)
     {check_length2_exn(cst_iter2_exn,l1,l2);return iter2_ok(l1,l2,f)}
    function rev_map2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_Iz_)
                {return function(_IA_){return rev_map2_ok(_Iz_,_IA_,f)}})}
    function rev_map2_exn(l1,l2,f)
     {check_length2_exn(cst_rev_map2_exn,l1,l2);return rev_map2_ok(l1,l2,f)}
    function fold2(l1,l2,init,f)
     {return check_length2
              (l1,
               l2,
               function(_Ix_)
                {return function(_Iy_){return fold2_ok(_Ix_,_Iy_,init,f)}})}
    function fold2_exn(l1,l2,init,f)
     {check_length2_exn(cst_fold2_exn,l1,l2);return fold2_ok(l1,l2,init,f)}
    function for_all2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_Iv_)
                {return function(_Iw_){return for_all2_ok(_Iv_,_Iw_,f)}})}
    function for_all2_exn(l1,l2,f)
     {check_length2_exn(cst_for_all2_exn,l1,l2);return for_all2_ok(l1,l2,f)}
    function exists2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_It_)
                {return function(_Iu_){return exists2_ok(_It_,_Iu_,f)}})}
    function exists2_exn(l1,l2,f)
     {check_length2_exn(cst_exists2_exn,l1,l2);return exists2_ok(l1,l2,f)}
    function mem(param,a,equal)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var bs=param$0[2],b=param$0[1],_Is_=caml_call2(equal,a,b);
        if(_Is_)return _Is_;
        var param$0=bs}}
    function rev_filter(param,f)
     {var accu=0,param$0=param;
      for(;;)
       {if(! param$0)return accu;
        var l=param$0[2],x=param$0[1];
        if(caml_call1(f,x))
         {var accu$0=[0,x,accu],accu=accu$0,param$0=l;continue}
        var param$0=l}}
    function filter(t,f){return rev(rev_filter(t,f))}
    function find_map$0(param,f)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var l=param$0[2],x=param$0[1],r=caml_call1(f,x);
        if(r)return r;
        var param$0=l}}
    var not_found=[0,Not_found_s,_ap_];
    function find_map_exn(t,f)
     {var match=find_map$0(t,f);
      if(! match)throw not_found;
      var x=match[1];
      return x}
    function find$0(param,f)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var l=param$0[2],x=param$0[1];
        if(caml_call1(f,x))return [0,x];
        var param$0=l}}
    var not_found$0=[0,Not_found_s,_aq_];
    function find_exn(t,f)
     {var t$0=t;
      for(;;)
       {if(! t$0)throw not_found$0;
        var t$1=t$0[2],x=t$0[1];
        if(caml_call1(f,x))return x;
        var t$0=t$1}}
    function findi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var l=t$0[2],x=t$0[1];
        if(caml_call2(f,i,x))return [0,[0,i,x]];
        var i$0=i + 1 | 0,i=i$0,t$0=l}}
    var not_found$1=[0,Not_found_s,_ar_];
    function findi_exn(t,f)
     {var match=findi(t,f);
      if(! match)throw not_found$1;
      var x=match[1];
      return x}
    function find_mapi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var l=t$0[2],x=t$0[1],result=caml_call2(f,i,x);
        if(result)return result;
        var i$0=i + 1 | 0,i=i$0,t$0=l}}
    var not_found$2=[0,Not_found_s,_as_];
    function find_mapi_exn(t,f)
     {var match=find_mapi(t,f);
      if(! match)throw not_found$2;
      var x=match[1];
      return x}
    function for_alli(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 1;
        var tl=t$0[2],hd=t$0[1],_Ir_=caml_call2(f,i,hd);
        if(! _Ir_)return _Ir_;
        var i$0=i + 1 | 0,i=i$0,t$0=tl}}
    function existsi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var tl=t$0[2],hd=t$0[1],_Iq_=caml_call2(f,i,hd);
        if(_Iq_)return _Iq_;
        var i$0=i + 1 | 0,i=i$0,t$0=tl}}
    function to_list$1(t){return t}
    var max_non_tailcall=typeof backend_type === "number"?1000:50;
    function count_append(l1,l2,count)
     {if(! l2)return l1;
      if(! l1)return l2;
      var _Ih_=l1[2],_Ii_=l1[1];
      if(! _Ih_)return [0,_Ii_,l2];
      var _Ij_=_Ih_[2],_Ik_=_Ih_[1];
      if(! _Ij_)return [0,_Ii_,[0,_Ik_,l2]];
      var _Il_=_Ij_[2],_Im_=_Ij_[1];
      if(! _Il_)return [0,_Ii_,[0,_Ik_,[0,_Im_,l2]]];
      var _In_=_Il_[2],_Io_=_Il_[1];
      if(! _In_)return [0,_Ii_,[0,_Ik_,[0,_Im_,[0,_Io_,l2]]]];
      var
       tl=_In_[2],
       x5=_In_[1],
       _Ip_=
        max_non_tailcall < count
         ?caml_call2(rev_append,rev(tl),l2)
         :count_append(tl,l2,count + 1 | 0);
      return [0,_Ii_,[0,_Ik_,[0,_Im_,[0,_Io_,[0,x5,_Ip_]]]]]}
    function append$0(l1,l2){return count_append(l1,l2,0)}
    function count_map(f,l,ctr)
     {if(! l)return 0;
      var _H__=l[2],_H$_=l[1];
      if(! _H__){var f1$3=caml_call1(f,_H$_);return [0,f1$3,0]}
      var _Ia_=_H__[2],_Ib_=_H__[1];
      if(! _Ia_)
       {var f1$2=caml_call1(f,_H$_),f2$2=caml_call1(f,_Ib_);
        return [0,f1$2,[0,f2$2,0]]}
      var _Ic_=_Ia_[2],_Id_=_Ia_[1];
      if(! _Ic_)
       {var
         f1$1=caml_call1(f,_H$_),
         f2$1=caml_call1(f,_Ib_),
         f3$1=caml_call1(f,_Id_);
        return [0,f1$1,[0,f2$1,[0,f3$1,0]]]}
      var _Ie_=_Ic_[2],_If_=_Ic_[1];
      if(! _Ie_)
       {var
         f1$0=caml_call1(f,_H$_),
         f2$0=caml_call1(f,_Ib_),
         f3$0=caml_call1(f,_Id_),
         f4$0=caml_call1(f,_If_);
        return [0,f1$0,[0,f2$0,[0,f3$0,[0,f4$0,0]]]]}
      var
       tl=_Ie_[2],
       x5$0=_Ie_[1],
       f1=caml_call1(f,_H$_),
       f2=caml_call1(f,_Ib_),
       f3=caml_call1(f,_Id_),
       f4=caml_call1(f,_If_),
       f5=caml_call1(f,x5$0);
      if(max_non_tailcall < ctr)
       {var bs=0,xs=tl;
        for(;;)
         {if(xs)
           {var _H2_=xs[2];
            if(_H2_)
             {var _H3_=_H2_[2];
              if(_H3_)
               {var _H4_=_H3_[2];
                if(_H4_)
                 {var _H5_=_H4_[2];
                  if(_H5_)
                   {var _H6_=_H5_[2];
                    if(_H6_)
                     {var _H7_=_H6_[2];
                      if(_H7_)
                       {var _H8_=_H7_[2];
                        if(_H8_)
                         {var _H9_=_H8_[2];
                          if(_H9_)
                           {var
                             xs$0=_H9_[2],
                             x8=_H9_[1],
                             x7=_H8_[1],
                             x6=_H7_[1],
                             x5=_H6_[1],
                             x4=_H5_[1],
                             x3=_H4_[1],
                             x2=_H3_[1],
                             x1=_H2_[1],
                             x0=xs[1],
                             y0$0=caml_call1(f,x0),
                             y1$0=caml_call1(f,x1),
                             y2$0=caml_call1(f,x2),
                             y3$0=caml_call1(f,x3),
                             y4$0=caml_call1(f,x4),
                             y5$0=caml_call1(f,x5),
                             y6$0=caml_call1(f,x6),
                             y7$0=caml_call1(f,x7),
                             y8$0=caml_call1(f,x8),
                             bs$0=[0,[0,y0$0,y1$0,y2$0,y3$0,y4$0,y5$0,y6$0,y7$0,y8$0],bs],
                             bs=bs$0,
                             xs=xs$0;
                            continue}}}}}}}}}
          var ys$1=nontail_map(xs,f),ys=ys$1,param=bs;
          for(;;)
           {if(param)
             {var
               param$0=param[2],
               match=param[1],
               y8=match[9],
               y7=match[8],
               y6=match[7],
               y5=match[6],
               y4=match[5],
               y3=match[4],
               y2=match[3],
               y1=match[2],
               y0=match[1],
               ys$0=
                [0,
                 y0,
                 [0,y1,[0,y2,[0,y3,[0,y4,[0,y5,[0,y6,[0,y7,[0,y8,ys]]]]]]]]],
               ys=ys$0,
               param=param$0;
              continue}
            var _Ig_=ys;
            break}
          break}}
      else
       var _Ig_=count_map(f,tl,ctr + 1 | 0);
      return [0,f1,[0,f2,[0,f3,[0,f4,[0,f5,_Ig_]]]]]}
    function map$9(l,f){return count_map(f,l,0)}
    function folding_map(t,init,f)
     {var acc=[0,init];
      return map$9
              (t,
               function(x)
                {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_map(t,init,f)
     {var
       acc=[0,init],
       result=
        map$9
         (t,
          function(x)
           {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function symbol_map$2(l,f){return map$9(l,f)}
    function map2_ok(l1,l2,f){return rev(rev_map2_ok(l1,l2,f))}
    function map2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_H0_)
                {return function(_H1_){return map2_ok(_H0_,_H1_,f)}})}
    function map2_exn(l1,l2,f)
     {check_length2_exn(cst_map2_exn,l1,l2);return map2_ok(l1,l2,f)}
    function rev_map3_ok(l1,l2,l3,f)
     {var l1$0=l1,l2$0=l2,l3$0=l3,ac=0;
      for(;;)
       {if(l1$0)
         {if(l2$0 && l3$0)
           {var
             l3$1=l3$0[2],
             x3=l3$0[1],
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             ac$0=[0,caml_call3(f,x1,x2,x3),ac],
             l1$0=l1$1,
             l2$0=l2$1,
             l3$0=l3$1,
             ac=ac$0;
            continue}}
        else
         if(! l2$0 && ! l3$0)return ac;
        throw [0,Assert_failure$0,_at_]}}
    function rev_map3(l1,l2,l3,f)
     {return check_length3
              (l1,
               l2,
               l3,
               function(_HX_)
                {return function(_HY_)
                  {return function(_HZ_){return rev_map3_ok(_HX_,_HY_,_HZ_,f)}}})}
    function rev_map3_exn(l1,l2,l3,f)
     {check_length3_exn(cst_rev_map3_exn,l1,l2,l3);
      return rev_map3_ok(l1,l2,l3,f)}
    function map3_ok(l1,l2,l3,f){return rev(rev_map3_ok(l1,l2,l3,f))}
    function map3(l1,l2,l3,f)
     {return check_length3
              (l1,
               l2,
               l3,
               function(_HU_)
                {return function(_HV_)
                  {return function(_HW_){return map3_ok(_HU_,_HV_,_HW_,f)}}})}
    function map3_exn(l1,l2,l3,f)
     {check_length3_exn(cst_map3_exn,l1,l2,l3);return map3_ok(l1,l2,l3,f)}
    function rev_map_append(l1,l2,f)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(! l1$0)return l2$0;
        var t=l1$0[2],h=l1$0[1],l2$1=[0,caml_call1(f,h),l2$0],l1$0=t,l2$0=l2$1}}
    function unzip$0(list)
     {var list$2=rev(list),list$0=list$2,l1=0,l2=0;
      for(;;)
       {if(! list$0)return [0,l1,l2];
        var
         list$1=list$0[2],
         match=list$0[1],
         y=match[2],
         x=match[1],
         l2$0=[0,y,l2],
         l1$0=[0,x,l1],
         list$0=list$1,
         l1=l1$0,
         l2=l2$0}}
    function unzip3(list)
     {var list$2=rev(list),list$0=list$2,l1=0,l2=0,l3=0;
      for(;;)
       {if(! list$0)return [0,l1,l2,l3];
        var
         list$1=list$0[2],
         match=list$0[1],
         z=match[3],
         y=match[2],
         x=match[1],
         l3$0=[0,z,l3],
         l2$0=[0,y,l2],
         l1$0=[0,x,l1],
         list$0=list$1,
         l1=l1$0,
         l2=l2$0,
         l3=l3$0}}
    function zip_exn(l1,l2)
     {try
       {var _HS_=map2_ok(l1,l2,function(a,b){return [0,a,b]});return _HS_}
      catch(_HT_)
       {var _HQ_=caml_call1(length,l2),_HR_=caml_call1(length,l1);
        return caml_call3(invalid_argf(_au_),_HR_,_HQ_,0)}}
    function zip(l1,l2){return map2(l1,l2,function(a,b){return [0,a,b]})}
    function rev_mapi(param,f)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(! param$0)return acc;
        var
         t=param$0[2],
         h=param$0[1],
         acc$0=[0,caml_call2(f,i,h),acc],
         i$0=i + 1 | 0,
         i=i$0,
         acc=acc$0,
         param$0=t}}
    function mapi$1(l,f){return rev(rev_mapi(l,f))}
    function folding_mapi(t,init,f)
     {var acc=[0,init];
      return mapi$1
              (t,
               function(i,x)
                {var
                  match=caml_call3(f,i,acc[1],x),
                  y=match[2],
                  new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_mapi(t,init,f)
     {var
       acc=[0,init],
       result=
        mapi$1
         (t,
          function(i,x)
           {var match=caml_call3(f,i,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function iteri$0(l,f)
     {fold_left(l,0,function(i,x){caml_call2(f,i,x);return i + 1 | 0});
      return 0}
    function foldi(t,init,f)
     {return fold_left
               (t,
                [0,0,init],
                function(param,v)
                 {var acc=param[2],i=param[1];
                  return [0,i + 1 | 0,caml_call3(f,i,acc,v)]})
              [2]}
    function filteri(l,f)
     {return rev
              (foldi
                (l,
                 0,
                 function(pos,acc,x){return caml_call2(f,pos,x)?[0,x,acc]:acc}))}
    function reduce(l,f)
     {if(! l)return 0;var tl=l[2],hd=l[1];return [0,fold_left(tl,hd,f)]}
    function reduce_exn(l,f)
     {var match=reduce(l,f);
      if(! match)return caml_call1(invalid_arg$0,cst_List_reduce_exn);
      var v=match[1];
      return v}
    function reduce_balanced(l,f)
     {function step_accum(num,acc,x)
       {var num$0=num,acc$0=acc,x$0=x;
        for(;;)
         {if(0 === (num$0 & 1))return [0,x$0,acc$0];
          if(! acc$0)throw [0,Assert_failure$0,_av_];
          var
           ys=acc$0[2],
           y=acc$0[1],
           x$1=caml_call2(f,y,x$0),
           num$1=num$0 >> 1,
           num$0=num$1,
           acc$0=ys,
           x$0=x$1}}
      var match=foldi(l,0,step_accum);
      if(! match)return 0;
      var xs=match[2],x=match[1];
      return [0,fold_left(xs,x,function(x,y){return caml_call2(f,y,x)})]}
    function reduce_balanced_exn(l,f)
     {var match=reduce_balanced(l,f);
      if(! match)
       return caml_call1(invalid_arg$0,cst_List_reduce_balanced_exn);
      var v=match[1];
      return v}
    function groupi(l,break$0)
     {var
       groups=
        foldi
         (l,
          0,
          function(i,acc,x)
           {if(! acc)return [0,[0,x,0],0];
            var tl=acc[2],current_group=acc[1];
            return caml_call3(break$0,i,caml_call1(hd_exn,current_group),x)
                    ?[0,[0,x,0],[0,current_group,tl]]
                    :[0,[0,x,current_group],tl]});
      return groups?rev_map(groups,rev):0}
    function group(l,break$0)
     {return groupi(l,function(param,x,y){return caml_call2(break$0,x,y)})}
    function sort_and_group(l,compare)
     {var _HP_=stable_sort$0(l,compare);
      return group
              (_HP_,function(x,y){return 0 !== caml_call2(compare,x,y)?1:0})}
    function bind$6(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(! param$0)return rev(acc);
        var
         tl=param$0[2],
         hd=param$0[1],
         acc$0=caml_call2(rev_append,caml_call1(f,hd),acc),
         acc=acc$0,
         param$0=tl}}
    function concat_mapi(param,f)
     {var cont=0,acc=0,param$0=param;
      for(;;)
       {if(! param$0)return rev(acc);
        var
         tl=param$0[2],
         hd=param$0[1],
         acc$0=caml_call2(rev_append,caml_call2(f,cont,hd),acc),
         cont$0=cont + 1 | 0,
         cont=cont$0,
         acc=acc$0,
         param$0=tl}}
    function merge(l1,l2,compare)
     {var acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(! l1$0)return caml_call2(rev_append,acc,l2$0);
        if(! l2$0)return caml_call2(rev_append,acc,l1$0);
        var t2=l2$0[2],h2=l2$0[1],t1=l1$0[2],h1=l1$0[1];
        if(0 < caml_call2(compare,h1,h2))
         {var acc$0=[0,h2,acc],acc=acc$0,l2$0=t2;continue}
        var acc$1=[0,h1,acc],acc=acc$1,l1$0=t1}}
    function map2$0(a,b,f)
     {return bind$6
              (a,
               function(x)
                {return map$9(b,function(y){return caml_call2(f,x,y)})})}
    function return$7(x){return [0,x,0]}
    function symbol_bind$2(t,f){return bind$6(t,f)}
    var
     map$10=[0,-198771759,map$9],
     Applicative=Make_using_map2([0,return$7,map2$0,map$10]),
     map$11=[0,-198771759,map$9],
     Monad=Make([0,bind$6,return$7,map$11]),
     all$4=Monad[9],
     all_unit$2=Monad[10],
     ignore_m$2=Monad[8],
     join$2=Monad[7],
     apply=Applicative[8],
     both=Applicative[3],
     map3$0=Applicative[10],
     symbol$60=Applicative[4],
     symbol$61=Applicative[6],
     symbol$62=Applicative[5],
     symbol$63=Applicative[4],
     symbol$64=Applicative[6],
     symbol$65=Applicative[5],
     Open_on_rhs=[0],
     Let_syntax$2=[0,return$7,bind$6,map$9,both,Open_on_rhs],
     Let_syntax$3=[0,return$7,symbol_bind$2,symbol_map$2,Let_syntax$2],
     Monad_infix$1=[0,symbol_bind$2,symbol_map$2];
    function last_exn(list)
     {var list$0=list;
      for(;;)
       {if(! list$0)return caml_call1(invalid_arg$0,cst_List_last);
        var _HO_=list$0[1];
        if(! list$0[2])return _HO_;
        var list$1=list$0[2],list$0=list$1}}
    function last(list)
     {var list$0=list;
      for(;;)
       {if(! list$0)return 0;
        var _HN_=list$0[1];
        if(! list$0[2])return [0,_HN_];
        var list$1=list$0[2],list$0=list$1}}
    function is_prefix(list,prefix,equal)
     {var list$0=list,prefix$0=prefix;
      for(;;)
       {if(! prefix$0)return 1;
        var tl=prefix$0[2],hd=prefix$0[1];
        if(! list$0)return 0;
        var tl$0=list$0[2],hd$0=list$0[1],_HM_=caml_call2(equal,hd,hd$0);
        if(! _HM_)return _HM_;
        var list$0=tl$0,prefix$0=tl}}
    function find_consecutive_duplicate(t,equal)
     {if(! t)return 0;
      var t$0=t[2],a1=t[1],a1$0=a1,t$1=t$0;
      for(;;)
       {if(! t$1)return 0;
        var t$2=t$1[2],a2=t$1[1];
        if(caml_call2(equal,a1$0,a2))return [0,[0,a1$0,a2]];
        var a1$0=a2,t$1=t$2}}
    function remove_consecutive_duplicates(opt,list,equal)
     {if(opt)
       var sth=opt[1],which_to_keep=sth;
      else
       var which_to_keep=847656566;
      if(! list)return 0;
      var tl$0=list[2],hd$0=list[1],to_keep=hd$0,accum=0,param=tl$0;
      for(;;)
       {if(! param)return rev([0,to_keep,accum]);
        var tl=param[2],hd=param[1];
        if(caml_call2(equal,hd,to_keep))
         {var
           to_keep$0=847656566 <= which_to_keep?hd:to_keep,
           to_keep=to_keep$0,
           param=tl;
          continue}
        var accum$0=[0,to_keep,accum],to_keep=hd,accum=accum$0,param=tl}}
    function dedup_and_sort(list,compare)
     {if(list && list[2])
       {var
         equal=function(x$0,x){return 0 === caml_call2(compare,x$0,x)?1:0},
         sorted=sort(list,compare);
        return remove_consecutive_duplicates(0,sorted,equal)}
      return list}
    function find_a_dup(l,compare)
     {var l$0=sort(l,compare),l$1=l$0;
      for(;;)
       {if(l$1)
         {var _HL_=l$1[2];
          if(_HL_)
           {var hd2=_HL_[1],hd1=l$1[1];
            if(0 === caml_call2(compare,hd1,hd2))return [0,hd1];
            var l$1=_HL_;
            continue}}
        return 0}}
    function contains_dup(lst,compare)
     {var match=find_a_dup(lst,compare);return match?1:0}
    function find_all_dups(l,compare)
     {function compare$0(a,b){return -1 * caml_call2(compare,a,b) | 0}
      var sorted=sort(l,compare$0);
      if(! sorted)return 0;
      var
       tl$0=sorted[2],
       hd$0=sorted[1],
       sorted$0=tl$0,
       prev=hd$0,
       already_recorded=0,
       acc=0;
      for(;;)
       {if(! sorted$0)return acc;
        var tl=sorted$0[2],hd=sorted$0[1];
        if(0 !== compare$0(prev,hd))
         {var sorted$0=tl,prev=hd,already_recorded=0;continue}
        if(already_recorded)
         {var sorted$0=tl,prev=hd,already_recorded=1;continue}
        var acc$0=[0,hd,acc],sorted$0=tl,prev=hd,already_recorded=1,acc=acc$0}}
    function all_equal(t$0,equal)
     {if(! t$0)return 0;
      var xs$0=t$0[2],x$0=t$0[1],t=xs$0;
      for(;;)
       {if(t)
         {var xs=t[2],x=t[1],_HJ_=caml_call2(equal,x,x$0);
          if(_HJ_){var t=xs;continue}
          var _HK_=_HJ_}
        else
         var _HK_=1;
        return _HK_?[0,x$0]:0}}
    function count$0(t,f){return count(fold_left,t,f)}
    function sum$0(m,t,f){return caml_call2(sum(fold_left,m),t,f)}
    function min_elt$0(t,compare){return min_elt(fold_left,t,compare)}
    function max_elt$0(t,compare){return max_elt(fold_left,t,compare)}
    function counti(t,f)
     {return foldi
              (t,
               0,
               function(idx,count,a)
                {return caml_call2(f,idx,a)?count + 1 | 0:count})}
    function init$1(i,f)
     {if(i < 0)caml_call2(invalid_argf(_aw_),i,0);
      var i$0=i,accum=0;
      for(;;)
       {if(0 > i$0)throw [0,Assert_failure$0,_ax_];
        if(0 === i$0)return accum;
        var
         accum$0=[0,caml_call1(f,i$0 - 1 | 0),accum],
         i$1=i$0 - 1 | 0,
         i$0=i$1,
         accum=accum$0}}
    function rev_filter_map(l,f)
     {var l$0=l,accum=0;
      for(;;)
       {if(! l$0)return accum;
        var tl=l$0[2],hd=l$0[1],match=caml_call1(f,hd);
        if(match)
         {var x=match[1],accum$0=[0,x,accum],l$0=tl,accum=accum$0;continue}
        var l$0=tl}}
    function filter_map(l,f){return rev(rev_filter_map(l,f))}
    function rev_filter_mapi(l,f)
     {var i=0,l$0=l,accum=0;
      for(;;)
       {if(! l$0)return accum;
        var tl=l$0[2],hd=l$0[1],match=caml_call2(f,i,hd);
        if(match)
         {var
           x=match[1],
           accum$0=[0,x,accum],
           i$0=i + 1 | 0,
           i=i$0,
           l$0=tl,
           accum=accum$0;
          continue}
        var i$1=i + 1 | 0,i=i$1,l$0=tl}}
    function filter_mapi(l,f){return rev(rev_filter_mapi(l,f))}
    function filter_opt(l){return filter_map(l,function(_HI_){return _HI_})}
    function partition3_map(t,f)
     {var t$0=t,fst=0,snd=0,trd=0;
      for(;;)
       {if(! t$0)
         {var _HG_=rev(trd),_HH_=rev(snd);return [0,rev(fst),_HH_,_HG_]}
        var t$1=t$0[2],x=t$0[1],match=caml_call1(f,x),_HF_=match[1];
        if(4152137 === _HF_)
         {var y=match[2],snd$0=[0,y,snd],t$0=t$1,snd=snd$0;continue}
        if(4202758 <= _HF_)
         {var y$0=match[2],trd$0=[0,y$0,trd],t$0=t$1,trd=trd$0;continue}
        var y$1=match[2],fst$0=[0,y$1,fst],t$0=t$1,fst=fst$0}}
    function partition_tf(t,f)
     {function f$0(x){return caml_call1(f,x)?[0,x]:[1,x]}
      return partition_map(t,f$0)}
    function partition_result(t){return partition_map(t,to_either)}
    function t_of_sexp$14(of_a_014,of_b_015,x_023)
     {return caml_call2
              (t_of_sexp$10,
               function(sexp_021)
                {if(1 === sexp_021[0])
                  {var _HD_=sexp_021[1];
                   if(_HD_)
                    {var _HE_=_HD_[2];
                     if(_HE_ && ! _HE_[2])
                      {var
                        arg1_018=_HE_[1],
                        arg0_017=_HD_[1],
                        res0_019=caml_call1(of_a_014,arg0_017),
                        res1_020=caml_call1(of_b_015,arg1_018);
                       return [0,res0_019,res1_020]}}}
                 return caml_call3
                         (Sexplib0_Sexp_conv_error[2],error_source_022,2,sexp_021)},
               x_023)}
    function sexp_of_t$20(of_a_024,of_b_025,x_030)
     {return caml_call2
              (sexp_of_t$10,
               function(param)
                {var
                  arg1_027=param[2],
                  arg0_026=param[1],
                  res0_028=caml_call1(of_a_024,arg0_026),
                  res1_029=caml_call1(of_b_025,arg1_027);
                 return [1,[0,res0_028,[0,res1_029,0]]]},
               x_030)}
    function t_sexp_grammar$13(a_sexp_grammar,b_sexp_grammar)
     {return caml_call1
              (list_sexp_grammar,[2,[0,a_sexp_grammar,[0,b_sexp_grammar,0]]])}
    function pair_of_group(list)
     {if(! list)throw [0,Assert_failure$0,_ay_];
      var match=list[1],k=match[1];
      return [0,k,map$9(list,get_data)]}
    function group$0(alist,equal)
     {return map$9
              (group
                (alist,
                 function(param,_HC_)
                  {var y=_HC_[1],x=param[1];return 1 - caml_call2(equal,x,y)}),
               pair_of_group)}
    function sort_and_group$0(alist,compare)
     {return map$9
              (sort_and_group
                (alist,
                 function(param,_HB_)
                  {var y=_HB_[1],x=param[1];return caml_call2(compare,x,y)}),
               pair_of_group)}
    function find$1(t,equal,key)
     {var
       match=
        find$0
         (t,
          function(param)
           {var key$0=param[1];return caml_call2(equal,key,key$0)});
      if(! match)return 0;
      var x=match[1];
      return [0,x[2]]}
    var not_found$3=[0,Not_found_s,_az_];
    function find_exn$0(t,equal,key)
     {var match=find$1(t,equal,key);
      if(! match)throw not_found$3;
      var value=match[1];
      return value}
    function mem$0(t,equal,key)
     {var match=find$1(t,equal,key);return match?1:0}
    function remove(t,equal,key)
     {return filter
              (t,
               function(param)
                {var key$0=param[1];return 1 - caml_call2(equal,key,key$0)})}
    function add$0(t,equal,key,value)
     {return [0,[0,key,value],remove(t,equal,key)]}
    function inverse(t)
     {return map$9
              (t,function(param){var y=param[2],x=param[1];return [0,y,x]})}
    function map$12(t,f)
     {return map$9
              (t,
               function(param)
                {var value=param[2],key=param[1];
                 return [0,key,caml_call1(f,value)]})}
    function sub$3(l,pos,len)
     {var _Hy_=pos < 0?1:0;
      if(_Hy_)
       var _Hz_=_Hy_;
      else
       var
        _HA_=len < 0?1:0,
        _Hz_=_HA_ || ((caml_call1(length,l) - len | 0) < pos?1:0);
      if(_Hz_)caml_call1(invalid_arg$0,cst_List_sub);
      return rev
              (foldi
                (l,
                 0,
                 function(i,acc,el)
                  {if(pos <= i && i < (pos + len | 0))return [0,el,acc];
                   return acc}))}
    function split_n(t_orig,n)
     {if(0 >= n)return [0,0,t_orig];
      var n$0=n,t=t_orig,accum=0;
      for(;;)
       {if(0 === n$0)return [0,rev(accum),t];
        if(! t)return [0,t_orig,0];
        var
         tl=t[2],
         hd=t[1],
         accum$0=[0,hd,accum],
         n$1=n$0 - 1 | 0,
         n$0=n$1,
         t=tl,
         accum=accum$0}}
    function take(t,n)
     {if(0 >= n)return 0;
      var n$0=n,t$0=t,accum=0;
      for(;;)
       {if(0 === n$0)return rev(accum);
        if(! t$0)return t;
        var
         tl=t$0[2],
         hd=t$0[1],
         accum$0=[0,hd,accum],
         n$1=n$0 - 1 | 0,
         n$0=n$1,
         t$0=tl,
         accum=accum$0}}
    function drop(t,n)
     {var t$0=t,n$0=n;
      for(;;)
       {if(t$0)
         {var tl=t$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,t$0=tl,n$0=n$1;continue}}
        return t$0}}
    function chunks_of(l,length)
     {if(length <= 0)caml_call2(invalid_argf(_aA_),length,0);
      var acc=0,l$0=l;
      for(;;)
       {if(! l$0)return rev(acc);
        var
         match=split_n(l$0,length),
         l$1=match[2],
         sublist=match[1],
         acc$0=[0,sublist,acc],
         acc=acc$0,
         l$0=l$1}}
    function split_while(t,f)
     {var acc=0,t$0=t;
      for(;;)
       {if(t$0)
         {var tl=t$0[2],hd=t$0[1];
          if(caml_call1(f,hd)){var acc$0=[0,hd,acc],acc=acc$0,t$0=tl;continue}}
        return [0,rev(acc),t$0]}}
    function take_while(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var tl=param$0[2],hd=param$0[1];
          if(caml_call1(f,hd))
           {var acc$0=[0,hd,acc],acc=acc$0,param$0=tl;continue}}
        return rev(acc)}}
    function drop_while(t,f)
     {var t$0=t;
      for(;;)
       {if(t$0)
         {var tl=t$0[2],hd=t$0[1];if(caml_call1(f,hd)){var t$0=tl;continue}}
        return t$0}}
    function drop_last(t)
     {var match=rev(t);
      if(! match)return 0;
      var lst=match[2];
      return [0,rev(lst)]}
    function drop_last_exn(t)
     {var match=drop_last(t);
      if(! match)return caml_call1(failwith$0,cst_List_drop_last_exn_empty_l);
      var lst=match[1];
      return lst}
    function cartesian_product(list1,list2)
     {if(is_empty(list2))return 0;
      var l1=list1,accum=0;
      for(;;)
       {if(! l1)return rev(accum);
        var
         tl=l1[2],
         hd=l1[1],
         accum$0=
          caml_call2
           (rev_append,
            map$9(list2,function(hd){return function(x){return [0,hd,x]}}(hd)),
            accum),
         l1=tl,
         accum=accum$0}}
    function concat$1(l){return fold_right$0(l,append$0,0)}
    function concat_no_order(l)
     {return fold_left
              (l,0,function(acc,l){return caml_call2(rev_append,l,acc)})}
    function cons(x,l){return [0,x,l]}
    function is_sorted(l,compare)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _Hw_=l$0[2];
          if(_Hw_)
           {var x2=_Hw_[1],x1=l$0[1],_Hx_=caml_call2(compare,x1,x2) <= 0?1:0;
            if(! _Hx_)return _Hx_;
            var l$0=_Hw_;
            continue}}
        return 1}}
    function is_sorted_strictly(l,compare)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _Hu_=l$0[2];
          if(_Hu_)
           {var x2=_Hu_[1],x1=l$0[1],_Hv_=caml_call2(compare,x1,x2) < 0?1:0;
            if(! _Hv_)return _Hv_;
            var l$0=_Hu_;
            continue}}
        return 1}}
    var Infix=[0,append$0];
    function permute$0(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(list)
       {var _Ht_=list[2];
        if(_Ht_)
         {if(_Ht_[2])
           {var arr=caml_call1(of_list,list);
            permute([0,random_state],0,0,arr);
            return caml_call1(to_list,arr)}
          var y=_Ht_[1],x=list[1];
          return caml_call1(_ag_[16],random_state)?[0,y,[0,x,0]]:list}}
      return list}
    function random_element_exn(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(is_empty(list))
       return caml_call1(failwith$0,cst_List_random_element_exn_em);
      var _Hs_=caml_call1(length,list);
      return nth_exn(list,caml_call2(_ag_[6],random_state,_Hs_))}
    function random_element(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      try
       {var _Hq_=[0,random_element_exn([0,random_state],list)];return _Hq_}
      catch(_Hr_){return 0}}
    function compare_list$1(cmp,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(! a$0)return b$0?-1:0;
        if(! b$0)return 1;
        var ys=b$0[2],y=b$0[1],xs=a$0[2],x=a$0[1],n=caml_call2(cmp,x,y);
        if(0 !== n)return n;
        var a$0=xs,b$0=ys}}
    function equal_list$1(equal,t1,t2)
     {var t1$0=t1,t2$0=t2;
      for(;;)
       {if(t1$0)
         {if(t2$0)
           {var
             t2$1=t2$0[2],
             x2=t2$0[1],
             t1$1=t1$0[2],
             x1=t1$0[1],
             _Hp_=caml_call2(equal,x1,x2);
            if(! _Hp_)return _Hp_;
            var t1$0=t1$1,t2$0=t2$1;
            continue}}
        else
         if(! t2$0)return 1;
        return 0}}
    function transpose(t$2)
     {var rows=t$2,columns=0,do_rev=1;
      a:
      for(;;)
       {var t=rows,column_acc=0,trimmed_rows=0,found_empty=0;
        for(;;)
         {if(! t)
           {if(! column_acc && ! trimmed_rows)return [0,rev(columns)];
            if(found_empty)return 0;
            var
             column=do_rev?rev(column_acc):column_acc,
             do_rev$0=1 - do_rev,
             columns$0=[0,column,columns],
             rows=trimmed_rows,
             columns=columns$0,
             do_rev=do_rev$0;
            continue a}
          var _Ho_=t[1];
          if(_Ho_)
           {var
             t$0=t[2],
             xs=_Ho_[2],
             x=_Ho_[1],
             trimmed=[0,xs,trimmed_rows],
             column_acc$0=[0,x,column_acc],
             t=t$0,
             column_acc=column_acc$0,
             trimmed_rows=trimmed;
            continue}
          var t$1=t[2],t=t$1,found_empty=1}}}
    var
     Transpose_got_lists_of_differe=
      [248,cst_Base_List_Transpose_got_li,caml_fresh_oo_id(0)];
    function _aB_(param)
     {if(param[1] !== Transpose_got_lists_of_differe)
       throw [0,Assert_failure$0,_aD_];
      var
       arg0_031=param[2],
       res0_032=caml_call2(sexp_of_t$10,sexp_of_t$4,arg0_031);
      return [1,[0,_aC_,[0,res0_032,0]]]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Transpose_got_lists_of_differe,_aB_);
    function transpose_exn(l)
     {var match=transpose(l);
      if(! match)throw [0,Transpose_got_lists_of_differe,map$9(l,length)];
      var l$0=match[1];
      return l$0}
    function intersperse(t,sep)
     {if(! t)return 0;
      var xs=t[2],x=t[1],_Hn_=0;
      return [0,
              x,
              fold_right$0(xs,function(y,acc){return [0,sep,[0,y,acc]]},_Hn_)]}
    function fold_result$0(t,init,f){return fold_result(fold_left,init,f,t)}
    function fold_until$0(t,init,f)
     {return function(_Hm_){return fold_until(fold_left,init,f,_Hm_,t)}}
    function is_suffix(list,suffix,equal_elt)
     {var
       list_len=caml_call1(length,list),
       suffix_len=caml_call1(length,suffix),
       _Hl_=suffix_len <= list_len?1:0;
      return _Hl_
              ?equal_list$1
                (equal_elt,drop(list,list_len - suffix_len | 0),suffix)
              :_Hl_}
    var
     _aE_=
      [0,
       t_of_sexp$14,
       sexp_of_t$20,
       t_sexp_grammar$13,
       add$0,
       find$1,
       find_exn$0,
       mem$0,
       remove,
       map$12,
       inverse,
       group$0,
       sort_and_group$0],
     Base_List=
      [0,
       compare_list$1,
       hash_fold_t$9,
       t_of_sexp$10,
       sexp_of_t$10,
       t_sexp_grammar$12,
       mem,
       length,
       is_empty,
       iter$0,
       fold_left,
       fold_result$0,
       fold_until$0,
       exists,
       for_all,
       sum$0,
       find$0,
       find_map$0,
       to_list$1,
       of_list,
       min_elt$0,
       max_elt$0,
       invariant$1,
       [0,
        both,
        symbol$60,
        symbol$62,
        symbol$61,
        apply,
        map2$0,
        map3$0,
        [0,symbol$63,symbol$65,symbol$64,symbol_map$2],
        symbol_bind$2,
        symbol_map$2,
        [0,symbol_bind$2,symbol_map$2],
        bind$6,
        return$7,
        map$9,
        join$2,
        ignore_m$2,
        all$4,
        all_unit$2,
        [0,return$7,symbol_bind$2,symbol_map$2,Let_syntax$2]],
       symbol_bind$2,
       symbol_map$2,
       Monad_infix$1,
       bind$6,
       return$7,
       join$2,
       ignore_m$2,
       all$4,
       all_unit$2,
       Let_syntax$3,
       Or_unequal_lengths,
       of_list$0,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort$0,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append$0,
       map$9,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       bind$6,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right$0,
       fold_left,
       unzip$0,
       unzip3,
       zip,
       zip_exn,
       mapi$1,
       rev_mapi,
       iteri$0,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count$0,
       counti,
       range$0,
       range,
       init$1,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       _aE_,
       sub$3,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat$1,
       concat_no_order,
       cons,
       cartesian_product,
       permute$0,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal_list$1,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
    caml_register_global(1041,Base_List,"Base__List");
    function sexp_of_t$21(param)
     {switch(param[0])
       {case 0:
         var arg0_001=param[1],res0_002=caml_call1(sexp_of_t,arg0_001);
         return [1,[0,_aF_,[0,res0_002,0]]];
        case 1:
         var arg0_003=param[1],res0_004=caml_call1(sexp_of_t$2,arg0_003);
         return [1,[0,_aG_,[0,res0_004,0]]];
        case 2:
         var arg0_005=param[1],res0_006=caml_call1(sexp_of_exn,arg0_005);
         return [1,[0,_aH_,[0,res0_006,0]]];
        case 3:
         var arg0_007=param[1],res0_008=caml_call1(sexp_of_t,arg0_007);
         return [1,[0,_aI_,[0,res0_008,0]]];
        case 4:
         var
          arg2_011=param[3],
          arg1_010=param[2],
          arg0_009=param[1],
          res0_012=caml_call1(sexp_of_t$2,arg0_009),
          res1_013=caml_call1(sexp_of_t,arg1_010),
          res2_014=caml_call2(sexp_of_option,sexp_of_t$15,arg2_011);
         return [1,[0,_aJ_,[0,res0_012,[0,res1_013,[0,res2_014,0]]]]];
        case 5:
         var
          arg1_016=param[2],
          arg0_015=param[1],
          res0_017=caml_call1(sexp_of_t$2,arg0_015),
          res1_018=sexp_of_t$21(arg1_016);
         return [1,[0,_aK_,[0,res0_017,[0,res1_018,0]]]];
        case 6:
         var
          arg2_021=param[3],
          arg1_020=param[2],
          arg0_019=param[1],
          res0_022=caml_call1(sexp_of_t$2,arg0_019),
          res1_023=caml_call1(sexp_of_t,arg1_020),
          res2_024=sexp_of_t$21(arg2_021);
         return [1,[0,_aL_,[0,res0_022,[0,res1_023,[0,res2_024,0]]]]];
        case 7:
         var
          arg1_026=param[2],
          arg0_025=param[1],
          res0_027=caml_call2(sexp_of_option,sexp_of_t$4,arg0_025),
          res1_028=caml_call2(sexp_of_t$10,sexp_of_t$21,arg1_026);
         return [1,[0,_aM_,[0,res0_027,[0,res1_028,0]]]];
        default:
         var
          arg1_030=param[2],
          arg0_029=param[1],
          res0_031=sexp_of_t$21(arg0_029),
          res1_032=caml_call1(sexp_of_t$2,arg1_030);
         return [1,[0,_aN_,[0,res0_031,[0,res1_032,0]]]]}}
    function to_strings_hum(t,ac)
     {var t$0=t,ac$0=ac;
      for(;;)
       switch(t$0[0])
        {case 0:
          var sexp=t$0[1];
          return [0,
                  cst_could_not_construct_info,
                  [0,caml_call1(to_string_mach,sexp),ac$0]];
         case 1:var string=t$0[1];return [0,string,ac$0];
         case 2:
          var exn=t$0[1];
          return [0,
                  caml_call1(to_string_mach,caml_call1(sexp_of_exn,exn)),
                  ac$0];
         case 3:
          var sexp$0=t$0[1];return [0,caml_call1(to_string_mach,sexp$0),ac$0];
         case 4:
          var sexp$1=t$0[2],tag=t$0[1];
          return [0,tag,[0,cst$3,[0,caml_call1(to_string_mach,sexp$1),ac$0]]];
         case 5:
          var t$1=t$0[2],tag$0=t$0[1];
          return [0,tag$0,[0,cst$4,to_strings_hum(t$1,ac$0)]];
         case 6:
          var
           t$2=t$0[3],
           sexp$2=t$0[2],
           tag$1=t$0[1],
           _Hi_=[0,cst$5,to_strings_hum(t$2,ac$0)],
           body=[0,caml_call1(to_string_mach,sexp$2),_Hi_];
          return 0 === caml_ml_string_length(tag$1)
                  ?body
                  :[0,tag$1,[0,cst$6,body]];
         case 7:
          var ts=t$0[2],trunc_after=t$0[1];
          if(trunc_after)
           {var max=trunc_after[1],n=caml_call1(length,ts);
            if(n <= max)
             var ts$0=ts;
            else
             var
              _Hk_=[0,[1,caml_call2(sprintf,_aO_,n - max | 0)],0],
              ts$0=caml_call2(symbol$58,take(ts,max),_Hk_);
            var ts$1=ts$0}
          else
           var ts$1=ts;
          var
           _Hj_=
            function(ac,t)
             {var ac$0=is_empty(ac)?ac:[0,cst$7,ac];
              return to_strings_hum(t,ac$0)};
          return fold_left(rev(ts$1),ac$0,_Hj_);
         default:
          var
           backtrace=t$0[2],
           t$3=t$0[1],
           ac$1=[0,cst_Backtrace,[0,backtrace,ac$0]],
           t$0=t$3,
           ac$0=ac$1;
          continue}}
    function to_sexps_hum(t,ac)
     {switch(t[0])
       {case 0:return [0,sexp_of_t$21(t),ac];
        case 1:var string=t[1];return [0,[0,string],ac];
        case 2:var exn=t[1];return [0,caml_call1(sexp_of_exn,exn),ac];
        case 3:var sexp=t[1];return [0,sexp,ac];
        case 4:
         var here=t[3],sexp$0=t[2],tag=t[1];
         if(here)
          var here$0=here[1],_Hg_=[0,sexp_of_t$15(here$0),0];
         else
          var _Hg_=0;
         return [0,[1,[0,[0,tag],[0,sexp$0,_Hg_]]],ac];
        case 5:
         var t$0=t[2],tag$0=t[1];
         return [0,[1,[0,[0,tag$0],to_sexps_hum(t$0,0)]],ac];
        case 6:
         var
          t$1=t[3],
          sexp$1=t[2],
          tag$1=t[1],
          body=[0,sexp$1,to_sexps_hum(t$1,0)];
         return 0 === caml_ml_string_length(tag$1)
                 ?[0,[1,body],ac]
                 :[0,[1,[0,[0,tag$1],body]],ac];
        case 7:
         var ts=t[2],_Hh_=function(ac,t){return to_sexps_hum(t,ac)};
         return fold_left(rev(ts),ac,_Hh_);
        default:
         var backtrace=t[2],t$2=t[1];
         return [0,[1,[0,to_sexp_hum(t$2),[0,[0,backtrace],0]]],ac]}}
    function to_sexp_hum(t)
     {var sexps=to_sexps_hum(t,0);
      if(sexps && ! sexps[2]){var sexp=sexps[1];return sexp}
      return [1,sexps]}
    function protect$0(f)
     {try
       {var _Hf_=caml_call1(f,0);return _Hf_}
      catch(exn)
       {exn = caml_wrap_exception(exn);return [0,caml_call1(sexp_of_exn,exn)]}}
    function to_message(info)
     {return protect$0
              (function(param)
                {var _He_=caml_obj_tag(info);
                 return 250 === _He_
                         ?info[1]
                         :246 === _He_?caml_call1(CamlinternalLazy[2],info):info})}
    function of_message(t){return [250,t]}
    function invariant$2(param){return 0}
    function sexp_of_t$22(t){return to_sexp_hum(to_message(t))}
    function t_of_sexp$15(sexp){return [246,function(_Hd_){return [3,sexp]}]}
    function compare$24(t1,t2)
     {var _Hc_=sexp_of_t$22(t2);return compare$7(sexp_of_t$22(t1),_Hc_)}
    function equal$12(t1,t2)
     {var _Hb_=sexp_of_t$22(t2);
      return caml_call2(equal$8,sexp_of_t$22(t1),_Hb_)}
    function hash_fold_t$16(state,t)
     {return caml_call2(hash_fold_t,state,sexp_of_t$22(t))}
    function hash$3(t){return run(0,hash_fold_t$16,t)}
    function to_string_hum$0(t)
     {var message=to_message(t);
      if(1 !== message[0])
       return caml_call2(to_string_hum,0,to_sexp_hum(message));
      var s=message[1];
      return s}
    function to_string_hum_deprecated(t)
     {var t$0=to_message(t);return concat$0(0,to_strings_hum(t$0,0))}
    function to_string_mach$1(t)
     {return caml_call1(to_string_mach,sexp_of_t$22(t))}
    function of_lazy(l)
     {return [246,
              function(_G__)
               {return protect$0
                        (function(param)
                          {var
                            _G$_=caml_obj_tag(l),
                            _Ha_=
                             250 === _G$_
                              ?l[1]
                              :246 === _G$_?caml_call1(CamlinternalLazy[2],l):l;
                           return [1,_Ha_]})}]}
    function of_lazy_sexp(l)
     {return [246,
              function(_G7_)
               {return protect$0
                        (function(param)
                          {var
                            _G8_=caml_obj_tag(l),
                            _G9_=
                             250 === _G8_
                              ?l[1]
                              :246 === _G8_?caml_call1(CamlinternalLazy[2],l):l;
                           return [3,_G9_]})}]}
    function of_lazy_t(lazy_t){return caml_call1(join$1,lazy_t)}
    function of_string$2(message){return caml_call1(from_val,[1,message])}
    function createf(format){return caml_call2(ksprintf,of_string$2,format)}
    function of_thunk(f)
     {return [246,
              function(_G6_)
               {return protect$0(function(param){return [1,caml_call1(f,0)]})}]}
    function create$2(here,strict,tag,x,sexp_of_x)
     {return strict
              ?[250,[4,tag,caml_call1(sexp_of_x,x),here]]
              :[246,
                function(_G5_)
                 {return protect$0
                          (function(param)
                            {return [4,tag,caml_call1(sexp_of_x,x),here]})}]}
    function create_s$0(sexp){return caml_call1(from_val,[3,sexp])}
    function tag(t,tag)
     {return [246,function(_G4_){return [5,tag,to_message(t)]}]}
    function tag_s_lazy(t,tag)
     {return [246,
              function(_G0_)
               {return protect$0
                        (function(param)
                          {var
                            _G1_=to_message(t),
                            _G2_=caml_obj_tag(tag),
                            _G3_=
                             250 === _G2_
                              ?tag[1]
                              :246 === _G2_?caml_call1(CamlinternalLazy[2],tag):tag;
                           return [6,cst$8,_G3_,_G1_]})}]}
    function tag_s(t,tag){return tag_s_lazy(t,caml_call1(from_val,tag))}
    function tag_arg(t,tag,x,sexp_of_x)
     {return [246,
              function(_GY_)
               {return protect$0
                        (function(param)
                          {var _GZ_=to_message(t);
                           return [6,tag,caml_call1(sexp_of_x,x),_GZ_]})}]}
    function arg(trunc_after,ts)
     {return [246,function(_GX_){return [7,trunc_after,map$9(ts,to_message)]}]}
    var Exn=[248,cst_Base_Info_Exn,caml_fresh_oo_id(0)];
    function _aP_(param)
     {if(param[1] !== Exn)throw [0,Assert_failure$0,_aQ_];
      var t=param[2];
      return sexp_of_t$22(t)}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Exn,_aP_);
    function to_exn(t)
     {if(! caml_call1(is_val,t))return [0,Exn,t];
      var
       _GV_=caml_obj_tag(t),
       _GW_=250 === _GV_?t[1]:246 === _GV_?caml_call1(CamlinternalLazy[2],t):t;
      if(2 !== _GW_[0])return [0,Exn,t];
      var exn=_GW_[1];
      return exn}
    function of_exn(backtrace,exn)
     {if(backtrace)
       {var _GQ_=backtrace[1];
        if(typeof _GQ_ === "number")
         var _GR_=[0,caml_call1(Stdlib_Printexc[6],0)];
        else
         var s=_GQ_[2],_GR_=[0,s];
        var backtrace$0=_GR_}
      else
       var backtrace$0=0;
      if(exn[1] === Exn)
       {var _GS_=exn[2];
        if(! backtrace$0)return _GS_;
        var backtrace$1=backtrace$0[1];
        return [246,function(_GU_){return [8,to_message(_GS_),backtrace$1]}]}
      if(! backtrace$0)return caml_call1(from_val,[2,exn]);
      var backtrace$2=backtrace$0[1];
      return [246,
              function(_GT_)
               {return [8,[3,caml_call1(sexp_of_exn,exn)],backtrace$2]}]}
    function pp$2(ppf,t)
     {var _GP_=to_string_hum$0(t);
      return caml_call2(Stdlib_Format[13],ppf,_GP_)}
    var
     include$30=_v_([0,pp$2,module_name$0]),
     pp$3=include$30[1],
     Internal_repr=[0,sexp_of_t$21,to_message,of_message],
     include$31=
      [0,
       compare$24,
       equal$12,
       hash_fold_t$16,
       hash$3,
       t_of_sexp$15,
       sexp_of_t$22,
       t_sexp_grammar$14,
       invariant$2,
       to_string_hum$0,
       to_string_mach$1,
       to_string_hum_deprecated,
       of_string$2,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create$2,
       create_s$0,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       arg,
       of_exn,
       to_exn,
       pp$3,
       Internal_repr];
    caml_register_global(1042,include$31,"Base__Info");
    function raise(t){throw to_exn(t)}
    function raise_s(sexp){return raise(create_s$0(sexp))}
    function to_info(t){return t}
    function of_info(t){return t}
    var
     include$32=_v_([0,pp$3,module_name$1]),
     pp$4=include$32[1],
     Base_Error=
      [0,
       compare$24,
       equal$12,
       hash_fold_t$16,
       hash$3,
       t_of_sexp$15,
       sexp_of_t$22,
       t_sexp_grammar$15,
       invariant$2,
       to_string_hum$0,
       to_string_mach$1,
       to_string_hum_deprecated,
       of_string$2,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create$2,
       create_s$0,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       arg,
       of_exn,
       to_exn,
       pp$4,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
    caml_register_global(1043,Base_Error,"Base__Error");
    function invariant$3(here,t,sexp_of_t,f)
     {try
       {var _GO_=caml_call1(f,0);return _GO_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var
         _GM_=[0,[0,cst$9,caml_call1(sexp_of_t,t)],0],
         _GN_=[0,[0,cst_exn,caml_call1(sexp_of_exn,exn)],_GM_];
        return raise_s
                (caml_call2
                  (message,
                   cst_invariant_failed,
                   [0,[0,cst$10,sexp_of_t$15(here)],_GN_]))}}
    function check_field(t,f,field)
     {try
       {var _GL_=caml_call1(f,get(field,t));return _GL_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var _GK_=[0,[0,cst_exn$0,caml_call1(sexp_of_exn,exn)],0];
        return raise_s
                (caml_call2
                  (message,
                   cst_problem_with_field,
                   [0,[0,cst_field,caml_call1(sexp_of_t$2,field[2])],_GK_]))}}
    var Base_Invariant=[0,invariant$3,check_field];
    caml_register_global(1044,Base_Invariant,"Base__Invariant");
    function compare$25(cmp_a,a_001,b_002)
     {return compare$20(cmp_a,compare$24,a_001,b_002)}
    function equal$13(cmp_a,a_007,b_008)
     {return equal$9(cmp_a,equal$12,a_007,b_008)}
    function hash_fold_t$17(hash_fold_a,hsv,arg)
     {return hash_fold_t$13(hash_fold_a,hash_fold_t$16,hsv,arg)}
    function t_of_sexp$16(of_a_013,x_015)
     {return t_of_sexp$12(of_a_013,t_of_sexp$15,x_015)}
    function sexp_of_t$23(of_a_016,x_017)
     {return sexp_of_t$16(of_a_016,sexp_of_t$22,x_017)}
    function t_sexp_grammar$16(a_sexp_grammar)
     {return t_sexp_grammar$9(a_sexp_grammar,t_sexp_grammar$15)}
    function invariant$4(invariant_a,t)
     {if(0 !== t[0])return 0;var a=t[1];return caml_call1(invariant_a,a)}
    function apply$0(f,x)
     {function _GJ_(e1,e2){return arg(0,[0,e1,[0,e2,0]])}
      return combine(f,x,function(f,x){return caml_call1(f,x)},_GJ_)}
    var
     map$13=[0,-198771759,map$5],
     include$33=Make$0([0,return$3,apply$0,map$13]),
     return$8=include$33[1],
     map$14=include$33[2],
     both$0=include$33[3],
     symbol$66=include$33[4],
     symbol$67=include$33[5],
     symbol$68=include$33[6],
     symbol_map$3=include$33[7],
     apply$1=include$33[8],
     map2$1=include$33[9],
     map3$1=include$33[10],
     all$5=include$33[11],
     all_unit$3=include$33[12],
     Applicative_infix=include$33[13],
     symbol_bind$3=include$26[1],
     symbol_map$4=include$26[2],
     Open_on_rhs$0=[0];
    function try_with$0(opt,f)
     {if(opt)var sth=opt[1],backtrace=sth;else var backtrace=0;
      try
       {var _GI_=[0,caml_call1(f,0)];return _GI_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var _GH_=backtrace?_aR_:0;
        return [1,of_exn(_GH_,exn)]}}
    function try_with_join(backtrace,f)
     {return caml_call1(join$0,try_with$0(backtrace,f))}
    function ok_exn$0(param)
     {if(0 === param[0]){var x=param[1];return x}
      var err=param[1];
      return raise(err)}
    function of_exn$0(backtrace,exn){return [1,of_exn(backtrace,exn)]}
    function of_exn_result(backtrace,z)
     {if(0 === z[0])return z;var exn=z[1];return of_exn$0(backtrace,exn)}
    function error$0(here,strict,message,a,sexp_of_a)
     {return [1,create$2(here,strict,message,a,sexp_of_a)]}
    function error_s(sexp){return [1,create_s$0(sexp)]}
    function error_string(message){return [1,of_string$2(message)]}
    function errorf(format){return caml_call2(ksprintf,error_string,format)}
    function tag$0(t,tag$0)
     {return map_error(t,function(_GG_){return tag(_GG_,tag$0)})}
    function tag_s$0(t,tag)
     {return map_error(t,function(_GF_){return tag_s(_GF_,tag)})}
    function tag_s_lazy$0(t,tag)
     {return map_error(t,function(_GE_){return tag_s_lazy(_GE_,tag)})}
    function tag_arg$0(t,message,a,sexp_of_a)
     {return map_error(t,function(e){return tag_arg(e,message,a,sexp_of_a)})}
    function unimplemented(s)
     {return error$0(0,0,cst_unimplemented,s,sexp_of_t$2)}
    function combine_errors$0(l)
     {function _GD_(eta){return arg(0,eta)}
      return map_error(combine_errors(l),_GD_)}
    function combine_errors_unit$0(l)
     {function _GC_(param){return 0}
      return caml_call2(map$5,combine_errors$0(l),_GC_)}
    function filter_ok_at_least_one(l)
     {var match=partition_map(l,to_either),errs=match[2],ok=match[1];
      return ok?[0,ok]:[1,arg(0,errs)]}
    function find_ok(l)
     {var match=find_map$0(l,ok);
      if(! match)
       return [1,
               arg
                (0,
                 map$9
                  (l,
                   function(param)
                    {if(0 === param[0])throw [0,Assert_failure$0,_aS_];
                     var err=param[1];
                     return err}))];
      var x=match[1];
      return [0,x]}
    function find_map_ok(l,f)
     {return with_return
              (function(param)
                {return [1,
                         arg
                          (0,
                           map$9
                            (l,
                             function(elt)
                              {var x=caml_call1(f,elt);
                               if(0 === x[0])return caml_call1(param,x);
                               var err=x[1];
                               return err}))]})}
    var
     Base_Or_error=
      [0,
       compare$25,
       equal$13,
       hash_fold_t$17,
       t_of_sexp$16,
       sexp_of_t$23,
       t_sexp_grammar$16,
       both$0,
       symbol$66,
       symbol$67,
       symbol$68,
       apply$1,
       map2$1,
       map3$1,
       Applicative_infix,
       invariant$4,
       symbol_bind$0,
       symbol_map$3,
       include$26,
       bind$2,
       return$8,
       join$0,
       ignore_m$0,
       all$5,
       all_unit$3,
       [0,
        return$8,
        symbol_bind$3,
        symbol_map$4,
        [0,return$8,bind$2,map$14,both$0,Open_on_rhs$0]],
       is_ok,
       is_error,
       try_with$0,
       try_with_join,
       ok,
       ok_exn$0,
       of_exn$0,
       of_exn_result,
       error$0,
       error_s,
       error_string,
       errorf,
       tag$0,
       tag_s$0,
       tag_s_lazy$0,
       tag_arg$0,
       unimplemented,
       map$5,
       iter$2,
       iter_error,
       combine_errors$0,
       combine_errors_unit$0,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
    caml_register_global(1045,Base_Or_error,"Base__Or_error");
    function t_of_sexp$17(sexp_004)
     {if(0 === sexp_004[0])
       {var _Gy_=sexp_004[1],switch$0=0;
        if(caml_string_notequal(_Gy_,cst_Neg))
         {var switch$1=0;
          if(caml_string_notequal(_Gy_,cst_Pos))
           {var switch$2=0;
            if(caml_string_notequal(_Gy_,cst_Zero))
             if(caml_string_notequal(_Gy_,cst_neg))
              if(caml_string_notequal(_Gy_,cst_pos))
               {if(caml_string_notequal(_Gy_,cst_zero))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 1}
          if(! switch$1)return 2}
        if(! switch$0)return 0}
      else
       {var _Gz_=sexp_004[1];
        if(! _Gz_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_003,sexp_004);
        var _GA_=_Gz_[1];
        if(0 !== _GA_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_003,sexp_004);
        var _GB_=_GA_[1],switch$3=0;
        if(caml_string_notequal(_GB_,cst_Neg$0))
         {var switch$4=0;
          if(caml_string_notequal(_GB_,cst_Pos$0))
           {var switch$5=0;
            if(caml_string_notequal(_GB_,cst_Zero$0))
             if(caml_string_notequal(_GB_,cst_neg$0))
              if(caml_string_notequal(_GB_,cst_pos$0))
               {if(caml_string_notequal(_GB_,cst_zero$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_003,sexp_004)}
    function sexp_of_t$24(param)
     {switch(param){case 0:return _aT_;case 1:return _aU_;default:return _aV_}}
    var compare$26=caml_int_compare;
    function hash_fold_t$18(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function symbol$69(x,y){return x < y?1:0}
    function symbol$70(x,y){return x <= y?1:0}
    function symbol$71(x,y){return x !== y?1:0}
    function symbol$72(x,y){return x === y?1:0}
    function symbol$73(x,y){return y < x?1:0}
    function symbol$74(x,y){return y <= x?1:0}
    var ascending$10=caml_compare;
    function descending$10(x,y){return caml_compare(y,x)}
    var compare$27=caml_int_compare;
    function equal$14(x,y){return x === y?1:0}
    function max$12(x,y){return y <= x?x:y}
    function min$12(x,y){return x <= y?x:y}
    var
     Replace_polymorphic_compare=
      [0,
       symbol$69,
       symbol$70,
       symbol$71,
       symbol$72,
       symbol$73,
       symbol$74,
       ascending$10,
       descending$10,
       compare$27,
       equal$14,
       max$12,
       min$12];
    function of_string$3(s){return t_of_sexp$17(caml_call1(sexp_of_t$2,s))}
    function to_string$4(t){return caml_call1(t_of_sexp$2,sexp_of_t$24(t))}
    function to_int$1(param)
     {switch(param){case 0:return -1;case 1:return 0;default:return 1}}
    function sign(n){return 0 <= n?0 === n?1:2:0}
    var
     Base_Sign0=
      [0,
       t_of_sexp$17,
       sexp_of_t$24,
       t_sexp_grammar$17,
       compare$26,
       hash_fold_t$18,
       all$6,
       Replace_polymorphic_compare,
       of_string$3,
       to_string$4,
       to_int$1,
       to_int$1,
       module_name$2,
       sign];
    caml_register_global(1046,Base_Sign0,"Base__Sign0");
    var Base_Comparable_intf=[0];
    caml_register_global(1047,Base_Comparable_intf,"Base__Comparable_intf");
    function geq(cmp,a,b){return 0 <= caml_call2(cmp,a,b)?1:0}
    function leq(cmp,a,b){return caml_call2(cmp,a,b) <= 0?1:0}
    function equal$15(cmp,a,b){return 0 === caml_call2(cmp,a,b)?1:0}
    function min$13(cmp,t$0,t){return leq(cmp,t$0,t)?t$0:t}
    function max$13(cmp,t$0,t){return geq(cmp,t$0,t)?t$0:t}
    function Infix$0(T)
     {function symbol(a,b){return 0 < caml_call2(T[1],a,b)?1:0}
      function symbol$0(a,b){return caml_call2(T[1],a,b) < 0?1:0}
      function symbol$1(a,b){return geq(T[1],a,b)}
      function symbol$2(a,b){return leq(T[1],a,b)}
      function symbol$3(a,b){return equal$15(T[1],a,b)}
      function symbol$4(a,b){return 0 !== caml_call2(T[1],a,b)?1:0}
      return [0,symbol$1,symbol$2,symbol$3,symbol,symbol$0,symbol$4]}
    function Polymorphic_compare(T)
     {var
       include=Infix$0(T),
       symbol=include[1],
       symbol$0=include[2],
       symbol$1=include[3],
       symbol$2=include[4],
       symbol$3=include[5],
       symbol$4=include[6],
       compare=T[1];
      function min(t$0,t){return min$13(compare,t$0,t)}
      function max(t$0,t){return max$13(compare,t$0,t)}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              symbol$1,
              compare,
              min,
              max]}
    function Make_using_comparator(T)
     {var
       sexp_of_t=T[1],
       comparator=T[2],
       compare=comparator[1],
       Replace_polymorphic_compare=Polymorphic_compare([0,compare]),
       symbol=Replace_polymorphic_compare[1],
       symbol$0=Replace_polymorphic_compare[2],
       symbol$1=Replace_polymorphic_compare[3],
       symbol$2=Replace_polymorphic_compare[4],
       symbol$3=Replace_polymorphic_compare[5],
       symbol$4=Replace_polymorphic_compare[6],
       equal=Replace_polymorphic_compare[7],
       compare$0=Replace_polymorphic_compare[8],
       min=Replace_polymorphic_compare[9],
       max=Replace_polymorphic_compare[10];
      function descending(t$0,t){return caml_call2(compare$0,t,t$0)}
      function between(t,low,high)
       {var _Gx_=caml_call2(symbol$0,low,t);
        return _Gx_?caml_call2(symbol$0,t,high):_Gx_}
      function clamp_unchecked(t,min,max)
       {return caml_call2(symbol$3,t,min)?min:caml_call2(symbol$0,t,max)?t:max}
      function clamp_exn(t,min,max)
       {if(caml_call2(symbol$0,min,max))return clamp_unchecked(t,min,max);
        throw [0,Assert_failure$0,_aX_]}
      function clamp(t,min,max)
       {if(! caml_call2(symbol$2,min,max))
         return [0,clamp_unchecked(t,min,max)];
        var _Gw_=[0,[0,cst_max$0,caml_call1(sexp_of_t,max)],0];
        return error_s
                (caml_call2
                  (message,
                   cst_clamp_requires_min_max$0,
                   [0,[0,cst_min$0,caml_call1(sexp_of_t,min)],_Gw_]))}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare$0,
              min,
              max,
              compare$0,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator]}
    function Make$1(T)
     {var sexp_of_t=T[2],include=_P_(T),comparator=include[1];
      return Make_using_comparator([0,sexp_of_t,comparator])}
    function Inherit(C,T)
     {var sexp_of_t=T[1];
      function compare(t$0,t)
       {var _Gu_=caml_call1(T[2],t),_Gv_=caml_call1(T[2],t$0);
        return caml_call2(C[1],_Gv_,_Gu_)}
      return Make$1([0,compare,sexp_of_t])}
    function lexicographic(param,x,y)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var cmps=param$0[2],cmp=param$0[1],res=caml_call2(cmp,x,y);
        if(0 !== res)return res;
        var param$0=cmps}}
    function lift(cmp,f,x,y)
     {var _Gt_=caml_call1(f,y);return caml_call2(cmp,caml_call1(f,x),_Gt_)}
    function reverse(cmp,x,y){return caml_call2(cmp,y,x)}
    function _aY_(_Gq_)
     {var _Gr_=_Gq_[3],_Gs_=_Gq_[1];
      function is_positive(t){return 0 < caml_call2(_Gs_,t,_Gr_)?1:0}
      function is_non_negative(t){return 0 <= caml_call2(_Gs_,t,_Gr_)?1:0}
      function is_negative(t){return caml_call2(_Gs_,t,_Gr_) < 0?1:0}
      function is_non_positive(t){return caml_call2(_Gs_,t,_Gr_) <= 0?1:0}
      function sign$0(t){return sign(caml_call2(_Gs_,t,_Gr_))}
      return [0,
              is_positive,
              is_non_negative,
              is_negative,
              is_non_positive,
              sign$0]}
    var
     Base_Comparable=
      [0,
       lexicographic,
       lift,
       reverse,
       equal$15,
       max$13,
       min$13,
       Infix$0,
       Polymorphic_compare,
       Inherit,
       Make$1,
       Make_using_comparator,
       function(T)
        {var sexp_of_t=T[1];
         function between(t,low,high)
          {var
            _Go_=caml_lessequal(low,t),
            _Gp_=_Go_?caml_lessequal(t,high):_Go_;
           return _Gp_}
         function clamp_unchecked(t,min,max)
          {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
         function clamp_exn(t,min,max)
          {if(caml_lessequal(min,max))return clamp_unchecked(t,min,max);
           throw [0,Assert_failure$0,_aW_]}
         function clamp(t,min,max)
          {if(! caml_greaterthan(min,max))
            return [0,clamp_unchecked(t,min,max)];
           var _Gn_=[0,[0,cst_max,caml_call1(T[1],max)],0];
           return error_s
                   (caml_call2
                     (message,
                      cst_clamp_requires_min_max,
                      [0,[0,cst_min,caml_call1(T[1],min)],_Gn_]))}
         var include=_P_([0,caml_compare,sexp_of_t]),comparator=include[1];
         return [0,
                 caml_greaterequal,
                 caml_lessequal,
                 caml_equal,
                 caml_greaterthan,
                 caml_lessthan,
                 caml_notequal,
                 caml_equal,
                 caml_compare,
                 min,
                 max,
                 ascending,
                 descending,
                 between,
                 clamp_exn,
                 clamp,
                 comparator]},
       _aY_];
    caml_register_global(1048,Base_Comparable,"Base__Comparable");
    function equal$16(a,b)
     {var _Gj_=a === b?1:0;
      if(_Gj_)
       var _Gk_=_Gj_;
      else
       {var _Gl_=a[1] === b[1]?1:0;
        if(_Gl_)
         {var _Gm_=a[2] === b[2]?1:0;
          if(_Gm_)return a[3] === b[3]?1:0;
          var _Gk_=_Gm_}
        else
         var _Gk_=_Gl_}
      return _Gk_}
    var
     hash_param=Stdlib_MoreLabels[1][30],
     hash$4=Stdlib_MoreLabels[1][28],
     poly=[0,hash$4,caml_compare,function(param){return _aZ_}];
    function of_key(Key){return [0,Key[3],Key[1],Key[2]]}
    function to_key(param)
     {var sexp_of_t=param[3],compare=param[2],hash=param[1];
      return [0,compare,sexp_of_t,hash]}
    var
     Hashable$0=[0,equal$16,hash_param,hash$4,poly,of_key,to_key],
     equal$17=Hashable$0[1],
     hash_param$0=Hashable$0[2],
     hash$5=Hashable$0[3],
     hashable=Hashable$0[4],
     of_key$0=Hashable$0[5],
     to_key$0=Hashable$0[6],
     include$34=
      [0,Hashable$0,equal$17,hash_param$0,hash$5,hashable,of_key$0,to_key$0];
    caml_register_global(1050,include$34,"Base__Hashable_intf");
    var
     Base_Hashable=
      [0,equal$17,hashable,of_key$0,to_key$0,hash_param$0,hash$5];
    caml_register_global(1051,Base_Hashable,"Base__Hashable");
    var Base_Stringable=[0];
    caml_register_global(1052,Base_Stringable,"Base__Stringable");
    var Base_Identifiable_intf=[0];
    caml_register_global
     (1053,Base_Identifiable_intf,"Base__Identifiable_intf");
    function _a0_(T)
     {var
       hash_fold_t=T[2],
       hash=T[3],
       t_of_sexp=T[4],
       sexp_of_t=T[5],
       of_string=T[6],
       to_string=T[7],
       _Gi_=Make_using_comparator([0,T[5],T[9]]),
       symbol=_Gi_[1],
       symbol$0=_Gi_[2],
       symbol$1=_Gi_[3],
       symbol$2=_Gi_[4],
       symbol$3=_Gi_[5],
       symbol$4=_Gi_[6],
       equal=_Gi_[7],
       compare=_Gi_[8],
       min=_Gi_[9],
       max=_Gi_[10],
       ascending=_Gi_[11],
       descending=_Gi_[12],
       between=_Gi_[13],
       clamp_exn=_Gi_[14],
       clamp=_Gi_[15],
       comparator=_Gi_[16],
       include=_w_([0,T[8],T[7]]),
       pp=include[1],
       hashable=[0,hash,compare,sexp_of_t];
      return [0,
              hash_fold_t,
              hash,
              t_of_sexp,
              sexp_of_t,
              of_string,
              to_string,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare,
              min,
              max,
              ascending,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator,
              pp,
              hashable]}
    function _a1_(T)
     {var
       hash_fold_t=T[2],
       hash=T[3],
       t_of_sexp=T[4],
       sexp_of_t=T[5],
       of_string=T[6],
       to_string=T[7],
       _Gh_=Make$1([0,T[1],T[5]]),
       symbol=_Gh_[1],
       symbol$0=_Gh_[2],
       symbol$1=_Gh_[3],
       symbol$2=_Gh_[4],
       symbol$3=_Gh_[5],
       symbol$4=_Gh_[6],
       equal=_Gh_[7],
       compare=_Gh_[8],
       min=_Gh_[9],
       max=_Gh_[10],
       ascending=_Gh_[11],
       descending=_Gh_[12],
       between=_Gh_[13],
       clamp_exn=_Gh_[14],
       clamp=_Gh_[15],
       comparator=_Gh_[16],
       include=_w_([0,T[8],T[7]]),
       pp=include[1],
       hashable=[0,hash,compare,sexp_of_t];
      return [0,
              hash_fold_t,
              hash,
              t_of_sexp,
              sexp_of_t,
              of_string,
              to_string,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare,
              min,
              max,
              ascending,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator,
              pp,
              hashable]}
    var Base_Identifiable=[0,_a1_,_a0_];
    caml_register_global(1054,Base_Identifiable,"Base__Identifiable");
    function hash$6(x){return caml_call1(func$6,x)}
    function compare$28(param,_Gg_){return 0}
    function of_string$4(param)
     {return caml_string_notequal(param,cst$11)
              ?caml_call1(failwith$0,cst_Base_Unit_of_string_expect)
              :0}
    function to_string$5(param){return cst$12}
    var
     include$35=
      _a1_
       ([0,
         compare$28,
         hash_fold_t$8,
         hash$6,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$4,
         to_string$5,
         module_name$3]),
     hash_fold_unit$0=include$35[1],
     func$7=include$35[2],
     unit_of_sexp=include$35[3],
     sexp_of_unit=include$35[4],
     of_string$5=include$35[5],
     to_string$6=include$35[6],
     symbol$75=include$35[7],
     symbol$76=include$35[8],
     symbol$77=include$35[9],
     symbol$78=include$35[10],
     symbol$79=include$35[11],
     symbol$80=include$35[12],
     equal_unit$1=include$35[13],
     compare_unit$1=include$35[14],
     min$14=include$35[15],
     max$14=include$35[16],
     ascending$11=include$35[17],
     descending$11=include$35[18],
     between=include$35[19],
     clamp_exn=include$35[20],
     clamp=include$35[21],
     comparator$1=include$35[22],
     pp$5=include$35[23],
     hashable$0=include$35[24];
    function invariant$5(param){return 0}
    var
     Base_Unit=
      [0,
       all$7,
       unit_sexp_grammar,
       hash_fold_unit$0,
       func$7,
       unit_of_sexp,
       sexp_of_unit,
       of_string$5,
       to_string$6,
       symbol$75,
       symbol$76,
       symbol$77,
       symbol$78,
       symbol$79,
       symbol$80,
       equal_unit$1,
       compare_unit$1,
       min$14,
       max$14,
       ascending$11,
       descending$11,
       between,
       clamp_exn,
       clamp,
       comparator$1,
       pp$5,
       hashable$0,
       invariant$5];
    caml_register_global(1055,Base_Unit,"Base__Unit");
    function get_pos_len(pos,len,param,total_length)
     {try
       {var _Gf_=[0,get_pos_len_exn(pos,len,0,total_length)];return _Gf_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var s=exn[2];
        return error_string(s)}}
    var
     Base_Ordered_collection_common=
      [0,get_pos_len_exn,check_pos_len_exn,Private$1,get_pos_len];
    caml_register_global
     (1056,Base_Ordered_collection_common,"Base__Ordered_collection_common");
    function find_first_satisfying(pos,len,t,get,length,pred)
     {var
       match=get_pos_len_exn(pos,len,0,caml_call1(length,t)),
       len$0=match[2],
       pos$0=match[1],
       hi$0=(pos$0 + len$0 | 0) - 1 | 0,
       lo$1=pos$0,
       hi=hi$0;
      for(;;)
       {if(8 < (hi - lo$1 | 0))
         {var mid=lo$1 + ((hi - lo$1 | 0) / 2 | 0) | 0;
          if(caml_call1(pred,caml_call2(get,t,mid))){var hi=mid;continue}
          var lo$2=mid + 1 | 0,lo$1=lo$2;
          continue}
        var lo=lo$1;
        for(;;)
         {if(hi < lo)return 0;
          if(caml_call1(pred,caml_call2(get,t,lo)))return [0,lo];
          var lo$0=lo + 1 | 0,lo=lo$0}}}
    function find_last_satisfying(pos,len,t,pred,get,length)
     {var
       match=get_pos_len_exn(pos,len,0,caml_call1(length,t)),
       len$0=match[2],
       pos$0=match[1];
      if(0 === len$0)return 0;
      var
       match$0=
        find_first_satisfying
         ([0,pos$0],
          [0,len$0],
          t,
          get,
          length,
          function(_Ge_){return non(pred,_Ge_)});
      if(! match$0)return [0,(pos$0 + len$0 | 0) - 1 | 0];
      var i=match$0[1];
      return i === pos$0?0:[0,i - 1 | 0]}
    function binary_search(pos,len,t,length,get,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying
                   (pos,
                    len,
                    t,
                    get,
                    length,
                    function(x){return 0 <= caml_call2(compare,x,v)?1:0})
                 :find_last_satisfying
                   (pos,
                    len,
                    t,
                    function(x){return caml_call2(compare,x,v) < 0?1:0},
                    get,
                    length)
               :-253007807 <= how
                 ?find_last_satisfying
                   (pos,
                    len,
                    t,
                    function(x){return caml_call2(compare,x,v) <= 0?1:0},
                    get,
                    length)
                 :find_first_satisfying
                   (pos,
                    len,
                    t,
                    get,
                    length,
                    function(x){return 0 < caml_call2(compare,x,v)?1:0});
      if(-1055410545 <= how)
       {var
         match=
          find_last_satisfying
           (pos,
            len,
            t,
            function(x){return caml_call2(compare,x,v) <= 0?1:0},
            get,
            length);
        if(match)
         {var x=match[1];
          if(0 === caml_call2(compare,caml_call2(get,t,x),v))return [0,x]}
        return 0}
      var
       match$0=
        find_first_satisfying
         (pos,
          len,
          t,
          get,
          length,
          function(x){return 0 <= caml_call2(compare,x,v)?1:0});
      if(match$0)
       {var x$0=match$0[1];
        if(0 === caml_call2(compare,caml_call2(get,t,x$0),v))return [0,x$0]}
      return 0}
    function binary_search_segmented(pos,len,t,length,get,segment_of,how)
     {function is_left(x)
       {var match=caml_call1(segment_of,x);return 847852583 <= match?1:0}
      function is_right(x){return 1 - is_left(x)}
      return 125585502 <= how
              ?find_last_satisfying(pos,len,t,is_left,get,length)
              :find_first_satisfying(pos,len,t,get,length,is_right)}
    var Base_Binary_search=[0,binary_search,binary_search_segmented];
    caml_register_global(1057,Base_Binary_search,"Base__Binary_search");
    var
     Which_target_by_key=[0,all$8],
     Which_target_by_segment=[0,all$9],
     Base_Binary_searchable_intf=
      [0,Which_target_by_key,Which_target_by_segment];
    caml_register_global
     (1058,Base_Binary_searchable_intf,"Base__Binary_searchable_intf");
    function Make_gen$0(T)
     {var get=T[1],length=T[2];
      function binary_search$0(pos,len,t,compare,how,v)
       {return binary_search(pos,len,t,length,get,compare,how,v)}
      function binary_search_segmented$0(pos,len,t,segment_of,how)
       {return binary_search_segmented(pos,len,t,length,get,segment_of,how)}
      return [0,get,length,binary_search$0,binary_search_segmented$0]}
    function _a2_(T)
     {var get=T[1],length=T[2],_Gd_=Make_gen$0([0,get,length]);
      return [0,_Gd_[3],_Gd_[4]]}
    var
     Base_Binary_searchable=
      [0,
       function(T)
        {var get=T[1],length=T[2],_Gc_=Make_gen$0([0,get,length]);
         return [0,_Gc_[3],_Gc_[4]]},
       _a2_];
    caml_register_global
     (1059,Base_Binary_searchable,"Base__Binary_searchable");
    var Base_Blit_intf=[0];
    caml_register_global(1060,Base_Blit_intf,"Base__Blit_intf");
    function Make_gen$1(Src,Dst)
     {var unsafe_blit=Dst[3];
      function blit(src,src_pos,dst,dst_pos,len)
       {check_pos_len_exn(src_pos,len,caml_call1(Src[1],src));
        check_pos_len_exn(dst_pos,len,caml_call1(Dst[1],dst));
        var _Gb_=0 < len?1:0;
        return _Gb_?caml_call5(unsafe_blit,src,src_pos,dst,dst_pos,len):_Gb_}
      function blito(src,opt,_Ga_,dst,_F$_,param)
       {if(opt)var sth=opt[1],src_pos=sth;else var src_pos=0;
        if(_Ga_)
         var sth$0=_Ga_[1],src_len=sth$0;
        else
         var src_len=caml_call1(Src[1],src) - src_pos | 0;
        if(_F$_)var sth$1=_F$_[1],dst_pos=sth$1;else var dst_pos=0;
        return blit(src,src_pos,dst,dst_pos,src_len)}
      function sub(src,pos,len)
       {check_pos_len_exn(pos,len,caml_call1(Src[1],src));
        var dst=caml_call2(Dst[2],len,src);
        if(0 < len)caml_call5(unsafe_blit,src,pos,dst,0,len);
        return dst}
      function subo(opt,len,src)
       {if(opt)var sth=opt[1],pos=sth;else var pos=0;
        if(len)
         var i=len[1],i$0=i;
        else
         var i$0=caml_call1(Src[1],src) - pos | 0;
        return sub(src,pos,i$0)}
      return [0,unsafe_blit,blit,blito,sub,subo]}
    function Make_to_string(T,To_bytes)
     {function sub(src,pos,len)
       {return unsafe_to_string(caml_call3(To_bytes[4],src,pos,len))}
      function subo(pos,len,src)
       {return unsafe_to_string(caml_call3(To_bytes[5],pos,len,src))}
      return [0,sub,subo]}
    function _a3_(_F9_)
     {var _F__=Make_gen$1([0,_F9_[2]],[0,_F9_[2],_F9_[1],_F9_[3]]);
      return [0,_F__[2],_F__[3],_F__[1],_F__[4],_F__[5]]}
    function _a4_(_F6_)
     {var _F7_=[0,_F6_[2],_F6_[1],_F6_[3]],_F8_=Make_gen$1([0,_F7_[1]],_F7_);
      return [0,_F8_[2],_F8_[3],_F8_[1],_F8_[4],_F8_[5]]}
    function _a5_(Src,Dst)
     {var length=Dst[1];
      function create_like(len,param){return caml_call1(Dst[2],len)}
      var
       unsafe_blit=Dst[3],
       length$0=Src[1],
       _F5_=Make_gen$1([0,length$0],[0,length,create_like,unsafe_blit]);
      return [0,_F5_[2],_F5_[3],_F5_[1],_F5_[4],_F5_[5]]}
    function _a6_(Sequence)
     {function create_like(len,param){return caml_call1(Sequence[2],len)}
      var
       length=Sequence[1],
       unsafe_blit=Sequence[3],
       include=Make_gen$1([0,length],[0,length,create_like,unsafe_blit]),
       unsafe_blit$0=include[1],
       blit=include[2],
       blito=include[3],
       sub=include[4],
       subo=include[5];
      return [0,blit,blito,unsafe_blit$0,sub,subo]}
    var Base_Blit=[0,_a6_,_a5_,Make_to_string,_a4_,_a3_];
    caml_register_global(1061,Base_Blit,"Base__Blit");
    var Base_Either_intf=[0];
    caml_register_global(1062,Base_Either_intf,"Base__Either_intf");
    function t_sexp_grammar$18(a_sexp_grammar)
     {return caml_call1(option_sexp_grammar,a_sexp_grammar)}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function value_map(o,default$0,f)
     {if(! o)return default$0;var x=o[1];return caml_call1(f,x)}
    function iter$4(o,f){if(! o)return 0;var a=o[1];return caml_call1(f,a)}
    function invariant$6(f,t){return iter$4(t,f)}
    function call(x,f){if(! f)return 0;var f$0=f[1];return caml_call1(f$0,x)}
    function value(t,default$0){if(! t)return default$0;var x=t[1];return x}
    function value_exn(here,error,message,t)
     {if(t){var x=t[1];return x}
      if(here)
       {var _F0_=here[1];
        if(error)
         var
          e=error[1],
          _F1_=caml_call2(sexp_of_pair,sexp_of_t$22,sexp_of_t$15),
          _F2_=create$2(0,0,value(message,cst$13),[0,e,_F0_],_F1_);
        else
         if(message)
          var m=message[1],_F2_=create$2(0,0,m,_F0_,sexp_of_t$15);
         else
          var _F2_=create$2(0,0,cst_Option_value_exn,_F0_,sexp_of_t$15);
        var error$0=_F2_}
      else
       if(error)
        {var _F3_=error[1];
         if(message)var m$0=message[1],_F4_=tag(_F3_,m$0);else var _F4_=_F3_;
         var error$0=_F4_}
       else
        if(message)
         var m$1=message[1],error$0=of_string$2(m$1);
        else
         var error$0=of_string$2(cst_Option_value_exn_None);
      return raise(error$0)}
    function value_or_thunk(o,default$0)
     {if(! o)return caml_call1(default$0,0);var x=o[1];return x}
    function to_array$0(t){if(! t)return [0];var x=t[1];return [0,x]}
    function to_list$2(t){if(! t)return 0;var x=t[1];return [0,x,0]}
    function min_elt$1(t,param){return t}
    function max_elt$1(t,param){return t}
    function sum$1(M){return function(t,f){return value_map(t,M[1],f)}}
    function for_all$1(t,f){if(! t)return 1;var x=t[1];return caml_call1(f,x)}
    function exists$1(t,f){if(! t)return 0;var x=t[1];return caml_call1(f,x)}
    function mem$1(t,a,equal)
     {if(! t)return 0;var a$0=t[1];return caml_call2(equal,a,a$0)}
    function length$1(t){return t?1:0}
    function fold$0(t,init,f)
     {if(! t)return init;var x=t[1];return caml_call2(f,init,x)}
    function count$1(t,f)
     {if(! t)return 0;var a=t[1];return caml_call1(f,a)?1:0}
    function find$2(t,f)
     {if(! t)return 0;var x=t[1];return caml_call1(f,x)?t:0}
    function find_map$1(t,f)
     {if(! t)return 0;var a=t[1];return caml_call1(f,a)}
    function equal_option$1(f,t$0,t)
     {if(t$0)
       {if(t){var x=t[1],x$0=t$0[1];return caml_call2(f,x$0,x)}}
      else
       if(! t)return 1;
      return 0}
    function some(x){return [0,x]}
    function first_some(x,y){return x?x:y}
    function some_if(cond,x){return cond?[0,x]:0}
    function merge$0(a,b,f)
     {if(a)
       {if(b){var b$0=b[1],a$0=a[1];return [0,caml_call2(f,a$0,b$0)]}var x=a}
      else
       var x=b;
      return x}
    function filter$0(o,f)
     {if(o){var v=o[1];if(caml_call1(f,v))return o}return 0}
    function try_with$1(f)
     {try {var x=caml_call1(f,0)}catch(_FZ_){return 0}return [0,x]}
    function try_with_join$0(f)
     {try {var x=caml_call1(f,0);return x}catch(_FY_){return 0}}
    function _a7_(t,f){if(! t)return 0;var a=t[1];return [0,caml_call1(f,a)]}
    function apply$2(f,x){if(! f)return 0;var f$0=f[1];return _a7_(x,f$0)}
    function return$9(x){return [0,x]}
    var map$15=[0,-198771759,_a7_];
    function bind$7(o,f){if(! o)return 0;var x=o[1];return caml_call1(f,x)}
    var
     _a8_=Make([0,bind$7,return$9,map$15]),
     symbol_bind$4=_a8_[1],
     Monad_infix$2=_a8_[3],
     bind$8=_a8_[4],
     join$3=_a8_[7],
     ignore_m$3=_a8_[8],
     Let_syntax$4=_a8_[11],
     include$36=Make$0([0,return$9,apply$2,map$15]),
     return$10=include$36[1],
     map$16=include$36[2],
     both$1=include$36[3],
     symbol$81=include$36[4],
     symbol$82=include$36[5],
     symbol$83=include$36[6],
     symbol_map$5=include$36[7],
     apply$3=include$36[8],
     map2$2=include$36[9],
     map3$2=include$36[10],
     all$10=include$36[11],
     all_unit$4=include$36[12],
     Applicative_infix$0=include$36[13];
    function fold_result$1(t,init,f){return fold_result(fold$0,init,f,t)}
    function fold_until$1(t,init,f)
     {return function(_FX_){return fold_until(fold$0,init,f,_FX_,t)}}
    var
     Base_Option=
      [0,
       compare_option$0,
       hash_fold_option$0,
       t_sexp_grammar$18,
       equal_option$1,
       invariant$6,
       option_of_sexp,
       sexp_of_option,
       both$1,
       symbol$81,
       symbol$82,
       symbol$83,
       apply$3,
       map2$2,
       map3$2,
       Applicative_infix$0,
       symbol_bind$4,
       symbol_map$5,
       Monad_infix$2,
       bind$8,
       return$10,
       map$16,
       join$3,
       ignore_m$3,
       all$10,
       all_unit$4,
       Let_syntax$4,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold$0,
       mem$1,
       length$1,
       iter$4,
       exists$1,
       for_all$1,
       find$2,
       find_map$1,
       to_list$2,
       to_array$0,
       call,
       merge$0,
       filter$0,
       try_with$1,
       try_with_join$0,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result$1,
       fold_until$1,
       min_elt$1,
       max_elt$1,
       count$1,
       sum$1];
    caml_register_global(1063,Base_Option,"Base__Option");
    function Of_sexpable(Sexpable,M)
     {function t_of_sexp(sexp)
       {var s=caml_call1(Sexpable[1],sexp);
        try
         {var _FW_=caml_call1(M[2],s);return _FW_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(t)
       {var _FV_=caml_call1(M[1],t);return caml_call1(Sexpable[2],_FV_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable1(Sexpable,M)
     {function t_of_sexp(a_of_sexp,sexp)
       {var s=caml_call2(Sexpable[1],a_of_sexp,sexp);
        try
         {var _FU_=caml_call1(M[2],s);return _FU_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,t)
       {var _FT_=caml_call1(M[1],t);
        return caml_call2(Sexpable[2],sexp_of_a,_FT_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable2(Sexpable,M)
     {function t_of_sexp(a_of_sexp,b_of_sexp,sexp)
       {var s=caml_call3(Sexpable[1],a_of_sexp,b_of_sexp,sexp);
        try
         {var _FS_=caml_call1(M[2],s);return _FS_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,sexp_of_b,t)
       {var _FR_=caml_call1(M[1],t);
        return caml_call3(Sexpable[2],sexp_of_a,sexp_of_b,_FR_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable3(Sexpable,M)
     {function t_of_sexp(a_of_sexp,b_of_sexp,c_of_sexp,sexp)
       {var s=caml_call4(Sexpable[1],a_of_sexp,b_of_sexp,c_of_sexp,sexp);
        try
         {var _FQ_=caml_call1(M[2],s);return _FQ_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,sexp_of_b,sexp_of_c,t)
       {var _FP_=caml_call1(M[1],t);
        return caml_call4(Sexpable[2],sexp_of_a,sexp_of_b,sexp_of_c,_FP_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_stringable(M)
     {function t_of_sexp(sexp)
       {if(0 !== sexp[0])
         return caml_call2(of_sexp_error,cst_Sexpable_Of_stringable_t_o,sexp);
        var s=sexp[1];
        try
         {var _FO_=caml_call1(M[1],s);return _FO_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(t){return [0,caml_call1(M[2],t)]}
      return [0,t_of_sexp,sexp_of_t]}
    var
     Base_Sexpable=
      [0,Of_sexpable,Of_sexpable1,Of_sexpable2,Of_sexpable3,Of_stringable];
    caml_register_global(1064,Base_Sexpable,"Base__Sexpable");
    function swap$0(param)
     {if(0 === param[0]){var x=param[1];return [1,x]}
      var x$0=param[1];
      return [0,x$0]}
    function is_first(param){return 0 === param[0]?1:0}
    function is_second(param){return 0 === param[0]?0:1}
    function value$0(param){var x=param[1];return x}
    function value_map$0(t,first,second)
     {if(0 === t[0]){var x=t[1];return caml_call1(first,x)}
      var x$0=t[1];
      return caml_call1(second,x$0)}
    function map$17(t,first,second)
     {if(0 === t[0]){var x=t[1];return [0,caml_call1(first,x)]}
      var x$0=t[1];
      return [1,caml_call1(second,x$0)]}
    function first(x){return [0,x]}
    function second(x){return [1,x]}
    function equal$18(eq1,eq2,t1,t2)
     {if(0 === t1[0])
       {var _FM_=t1[1];
        if(0 === t2[0]){var y=t2[1];return caml_call2(eq1,_FM_,y)}}
      else
       {var _FN_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return caml_call2(eq2,_FN_,y$0)}}
      return 0}
    function invariant$7(f,s,param)
     {if(0 === param[0]){var x=param[1];return caml_call1(f,x)}
      var y=param[1];
      return caml_call1(s,y)}
    function Make_focused(M)
     {var
       return$0=M[1],
       other=M[2],
       either=M[3],
       combine=M[4],
       bind=M[5],
       map=
        [0,
         -198771759,
         function(t,f)
          {return caml_call2
                   (bind,
                    t,
                    function(x){return caml_call1(return$0,caml_call1(f,x))})}],
       include=Make2([0,bind,map,return$0]),
       symbol_bind=include[1],
       Let_syntax=include[3],
       Monad_infix=include[4],
       bind$0=include[5],
       return$1=include[6],
       join=include[8],
       ignore_m=include[9],
       _FF_=include[7];
      function apply(t1,t2)
       {return caml_call2
                (bind$0,
                 t1,
                 function(f)
                  {return caml_call2
                           (bind$0,
                            t2,
                            function(x){return caml_call1(return$1,caml_call1(f,x))})})}
      var
       map$0=[0,-198771759,_FF_],
       App=Make2$0([0,return$1,apply,map$0]),
       return$2=App[1],
       map$1=App[2],
       both=App[3],
       symbol=App[4],
       symbol$0=App[5],
       symbol$1=App[6],
       symbol_map=App[7],
       apply$0=App[8],
       map2=App[9],
       map3=App[10],
       all=App[11],
       all_unit=App[12],
       Applicative_infix=App[13];
      function other_loop(f,acc,param)
       {if(! param)return caml_call1(other,acc);
        var ts=param[2],t=param[1];
        function _FL_(o){return other_loop(f,caml_call2(f,acc,o),ts)}
        return caml_call3
                (either,t,function(param){return other_loop(f,acc,ts)},_FL_)}
      function return_loop(f,acc,param)
       {if(! param)return caml_call1(return$2,rev(acc));
        var ts=param[2],t=param[1];
        function _FK_(o){return other_loop(f,o,ts)}
        return caml_call3
                (either,
                 t,
                 function(x){return return_loop(f,[0,x,acc],ts)},
                 _FK_)}
      function combine_all(ts,f){return return_loop(f,0,ts)}
      function other_loop$0(f,acc,param)
       {if(! param)return caml_call1(other,acc);
        var ts=param[2],t=param[1];
        function _FJ_(o){return other_loop$0(f,caml_call2(f,acc,o),ts)}
        return caml_call3
                (either,t,function(param){return other_loop$0(f,acc,ts)},_FJ_)}
      function return_loop$0(f,param)
       {if(! param)return caml_call1(return$2,0);
        var ts=param[2],t=param[1];
        function _FI_(o){return other_loop$0(f,o,ts)}
        return caml_call3
                (either,t,function(param){return return_loop$0(f,ts)},_FI_)}
      function combine_all_unit(ts,f){return return_loop$0(f,ts)}
      function to_option(t)
       {return caml_call3(either,t,some,function(param){return 0})}
      function value(t,default$0)
       {function _FG_(param){return default$0}
        return caml_call3(either,t,function(_FH_){return _FH_},_FG_)}
      function with_return$0(f)
       {return with_return
                (function(ret)
                  {return caml_call1
                           (other,caml_call1(f,prepend(ret,return$2)))})}
      return [0,
              other,
              either,
              combine,
              symbol_bind,
              Let_syntax,
              Monad_infix,
              bind$0,
              join,
              ignore_m,
              App,
              return$2,
              map$1,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix,
              combine_all,
              combine_all_unit,
              to_option,
              value,
              with_return$0]}
    function either(t,return$0,other)
     {if(0 === t[0]){var x=t[1];return caml_call1(return$0,x)}
      var y=t[1];
      return caml_call1(other,y)}
    function combine$0(t1,t2,f,other)
     {if(0 === t1[0])
       {var _FD_=t1[1];
        if(0 === t2[0]){var y=t2[1];return [0,caml_call2(f,_FD_,y)]}
        var x=t2[1]}
      else
       {var _FE_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return [1,caml_call2(other,_FE_,y$0)]}
        var x=_FE_}
      return [1,x]}
    function bind$9(t,f)
     {if(0 !== t[0])return t;var x=t[1];return caml_call1(f,x)}
    var First=Make_focused([0,first,second,either,combine$0,bind$9]);
    function either$0(t,return$0,other)
     {if(0 === t[0]){var x=t[1];return caml_call1(other,x)}
      var y=t[1];
      return caml_call1(return$0,y)}
    function combine$1(t1,t2,f,other)
     {if(0 === t1[0])
       {var _FB_=t1[1];
        if(0 === t2[0]){var y=t2[1];return [0,caml_call2(other,_FB_,y)]}
        var x=_FB_}
      else
       {var _FC_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return [1,caml_call2(f,_FC_,y$0)]}
        var x=t2[1]}
      return [0,x]}
    function bind$10(t,f)
     {if(0 === t[0])return t;var x=t[1];return caml_call1(f,x)}
    var
     Second=Make_focused([0,second,first,either$0,combine$1,bind$10]),
     Export$0=[0],
     Base_Either=
      [0,
       compare$16,
       hash_fold_t$10,
       t_of_sexp$11,
       sexp_of_t$13,
       t_sexp_grammar$8,
       invariant$7,
       swap$0,
       value$0,
       value_map$0,
       value_map$0,
       map$17,
       equal$18,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export$0];
    caml_register_global(1065,Base_Either,"Base__Either");
    var Base_Indexed_container_intf=[0];
    caml_register_global
     (1066,Base_Indexed_container_intf,"Base__Indexed_container_intf");
    function iteri$1(fold,t,f)
     {caml_call3(fold,t,0,function(i,x){caml_call2(f,i,x);return i + 1 | 0});
      return 0}
    function foldi$0(fold,t,init,f)
     {var i=[0,0];
      return caml_call3
              (fold,
               t,
               init,
               function(acc,v)
                {var acc$0=caml_call3(f,i[1],acc,v);
                 i[1] = i[1] + 1 | 0;
                 return acc$0})}
    function counti$0(foldi,t,f)
     {return caml_call3
              (foldi,
               t,
               0,
               function(i,n,a){return caml_call2(f,i,a)?n + 1 | 0:n})}
    function existsi$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _FA_=caml_call2(f,i,x);
                     return _FA_?caml_call1(r,1):_FA_});
                 return 0})}
    function for_alli$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _Fz_=1 - caml_call2(f,i,x);
                     return _Fz_?caml_call1(r,0):_Fz_});
                 return 1})}
    function find_mapi$0(iteri,t,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   t,
                   function(i,x)
                    {var res=caml_call2(f,i,x);return res?caml_call1(r,res):0});
                 return 0})}
    function findi$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _Fy_=caml_call2(f,i,x);
                     return _Fy_?caml_call1(r,[0,[0,i,x]]):_Fy_});
                 return 0})}
    function Make_gen$2(T)
     {var
       include=Make_gen([0,T[1],T[2],T[3]]),
       _Fi_=include[4],
       _Fv_=T[4],
       _Ff_=include[1],
       _Fg_=include[2],
       _Fh_=include[3],
       _Fj_=include[5],
       _Fk_=include[6],
       _Fl_=include[7],
       _Fm_=include[8],
       _Fn_=include[9],
       _Fo_=include[10],
       _Fp_=include[11],
       _Fq_=include[12],
       _Fr_=include[13],
       _Fs_=include[14],
       _Ft_=include[15],
       _Fu_=include[16];
      if(typeof _Fv_ === "number")
       var _Fw_=function(t,f){return iteri$1(_Fi_,t,f)};
      else
       var iteri=_Fv_[2],_Fw_=iteri;
      var _Fx_=T[5];
      if(typeof _Fx_ === "number")
       var foldi=function(t,init,f){return foldi$0(_Fi_,t,init,f)};
      else
       var foldi$1=_Fx_[2],foldi=foldi$1;
      function counti(t,f){return counti$0(foldi,t,f)}
      function existsi(t,f){return existsi$0(_Fw_,t,f)}
      function for_alli(t,f){return for_alli$0(_Fw_,t,f)}
      function find_mapi(t,f){return find_mapi$0(_Fw_,t,f)}
      function findi(t,f){return findi$0(_Fw_,t,f)}
      return [0,
              _Ff_,
              _Fg_,
              _Fh_,
              _Fi_,
              _Fj_,
              _Fk_,
              _Fl_,
              _Fm_,
              _Fn_,
              _Fo_,
              _Fp_,
              _Fq_,
              _Fr_,
              _Fs_,
              _Ft_,
              _Fu_,
              foldi,
              _Fw_,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    function _a9_(T)
     {var
       C=_Z_([0,T[1],T[2],T[3],T[4]]),
       mem=C[1],
       fold=T[2],
       iter=T[3],
       length=T[4],
       iteri=T[5],
       foldi=T[6],
       include=Make_gen$2([0,fold,iter,length,iteri,foldi]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16],
       foldi$0=include[17],
       iteri$0=include[18],
       existsi=include[19],
       for_alli=include[20],
       counti=include[21],
       findi=include[22],
       find_mapi=include[23];
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt,
              foldi$0,
              iteri$0,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    function _a__(T)
     {var
       C=___([0,T[1],T[2],T[3]]),
       mem=C[1],
       fold=T[1],
       iter=T[2],
       length=T[3],
       iteri=T[4],
       foldi=T[5],
       include=Make_gen$2([0,fold,iter,length,iteri,foldi]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16],
       foldi$0=include[17],
       iteri$0=include[18],
       existsi=include[19],
       for_alli=include[20],
       counti=include[21],
       findi=include[22],
       find_mapi=include[23];
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt,
              foldi$0,
              iteri$0,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    var
     Base_Indexed_container=
      [0,
       foldi$0,
       iteri$1,
       counti$0,
       existsi$0,
       for_alli$0,
       findi$0,
       find_mapi$0,
       _a__,
       _a9_,
       Make_gen$2];
    caml_register_global
     (1067,Base_Indexed_container,"Base__Indexed_container");
    function sexp_of_t$25(of_a_001,of_s_002,param)
     {if(typeof param === "number")return _a$_;
      if(0 === param[0])
       {var arg0_003=param[1],res0_004=caml_call1(of_s_002,arg0_003);
        return [1,[0,_ba_,[0,res0_004,0]]]}
      var
       arg1_006=param[2],
       arg0_005=param[1],
       res0_007=caml_call1(of_a_001,arg0_005),
       res1_008=caml_call1(of_s_002,arg1_006);
      return [1,[0,_bb_,[0,res0_007,[0,res1_008,0]]]]}
    var Step=[0,sexp_of_t$25];
    function next_step(param)
     {var f=param[2],s=param[1],match=caml_call1(f,s);
      if(typeof match === "number")return 0;
      if(0 === match[0]){var s$0=match[1];return [0,[0,s$0,f]]}
      var s$1=match[2],a=match[1];
      return [1,a,[0,s$1,f]]}
    function delayed_fold_step(s,init,f,finish)
     {function loop(s,next,finish,f,acc)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return caml_call1(finish,acc);
        if(0 === match[0])
         {var s$0=match[1];
          return caml_call3
                  (f,
                   acc,
                   0,
                   function(_Fe_){return loop(s$0,next,finish,f,_Fe_)})}
        var s$1=match[2],a=match[1];
        return caml_call3
                (f,
                 acc,
                 [0,a],
                 function(_Fd_){return loop(s$1,next,finish,f,_Fd_)})}
      var next=s[2],s$0=s[1];
      return loop(s$0,next,finish,f,init)}
    var Expert=[0,next_step,delayed_fold_step];
    function unfold_step(init,f){return [0,init,f]}
    function unfold(init,f)
     {return [0,
              init,
              function(s)
               {var match=caml_call1(f,s);
                if(! match)return 0;
                var match$0=match[1],s$0=match$0[2],a=match$0[1];
                return [1,a,s$0]}]}
    function unfold_with(s,init,f)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,init,s$0],
              function(param)
               {var s=param[2],seed=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,seed,s$0]]}
                var s$1=match[2],a=match[1],match$0=caml_call2(f,seed,a);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var seed$0=match$0[1];return [0,[0,seed$0,s$1]]}
                var seed$1=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,seed$1,s$1]]}]}
    function unfold_with_and_finish
     (s,init,running_step,inner_finished,finishing_step)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,-172306698,[0,init,s$0]],
              function(state)
               {if(301075099 <= state[1])
                 {var
                   state$0=state[2],
                   match=caml_call1(finishing_step,state$0);
                  if(typeof match === "number")return 0;
                  if(0 === match[0])
                   {var state$1=match[1];return [0,[0,301075099,state$1]]}
                  var state$2=match[2],y=match[1];
                  return [1,y,[0,301075099,state$2]]}
                var
                 match$0=state[2],
                 inner_state=match$0[2],
                 state$3=match$0[1],
                 match$1=caml_call1(next,inner_state);
                if(typeof match$1 === "number")
                 return [0,[0,301075099,caml_call1(inner_finished,state$3)]];
                if(0 === match$1[0])
                 {var inner_state$0=match$1[1];
                  return [0,[0,-172306698,[0,state$3,inner_state$0]]]}
                var
                 inner_state$1=match$1[2],
                 x=match$1[1],
                 match$2=caml_call2(running_step,state$3,x);
                if(typeof match$2 === "number")return 0;
                if(0 === match$2[0])
                 {var state$4=match$2[1];
                  return [0,[0,-172306698,[0,state$4,inner_state$1]]]}
                var state$5=match$2[2],y$0=match$2[1];
                return [1,y$0,[0,-172306698,[0,state$5,inner_state$1]]]}]}
    function of_list$1(l)
     {return [0,
              l,
              function(param)
               {if(! param)return 0;var l=param[2],x=param[1];return [1,x,l]}]}
    function fold$1(t,v,f)
     {var next=t[2],seed$1=t[1],seed=seed$1,v$0=v;
      for(;;)
       {var match=caml_call1(next,seed);
        if(typeof match === "number")return v$0;
        if(0 === match[0]){var seed$0=match[1],seed=seed$0;continue}
        var s=match[2],a=match[1],v$1=caml_call2(f,v$0,a),seed=s,v$0=v$1}}
    function to_list_rev(t){return fold$1(t,0,function(l,x){return [0,x,l]})}
    function to_list$3(param)
     {var next=param[2],s=param[1];
      function to_list(s,next,i)
       {var s$0=s;
        for(;;)
         {if(0 === i){var t=[0,s$0,next];return rev(to_list_rev(t))}
          var match=caml_call1(next,s$0);
          if(typeof match === "number")return 0;
          if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
          var s$2=match[2],a=match[1];
          return [0,a,to_list(s$2,next,i - 1 | 0)]}}
      return to_list(s,next,500)}
    function sexp_of_t$26(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,to_list$3(t))}
    function range$1(opt,_Fc_,_Fb_,start_v,stop_v)
     {if(opt)var sth=opt[1],stride=sth;else var stride=1;
      if(_Fc_)var sth$0=_Fc_[1],start=sth$0;else var start=104758188;
      if(_Fb_)var sth$1=_Fb_[1],stop=sth$1;else var stop=-160346914;
      var
       step=
        104758188 <= stop
         ?0 <= stride
           ?function(i){return stop_v < i?0:[1,i,i + stride | 0]}
           :function(i){return i < stop_v?0:[1,i,i + stride | 0]}
         :0 <= stride
           ?function(i){return stop_v <= i?0:[1,i,i + stride | 0]}
           :function(i){return i <= stop_v?0:[1,i,i + stride | 0]},
       init=104758188 <= start?start_v:start_v + stride | 0;
      return [0,init,step]}
    function of_lazy$0(t_lazy)
     {return [0,
              t_lazy,
              function(t_lazy)
               {var
                 _Fa_=caml_obj_tag(t_lazy),
                 match=
                  250 === _Fa_
                   ?t_lazy[1]
                   :246 === _Fa_?caml_call1(CamlinternalLazy[2],t_lazy):t_lazy,
                 next=match[2],
                 s=match[1],
                 match$0=caml_call1(next,s);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s$0=match$0[1],v=[0,s$0,next];return [0,v]}
                var s$1=match$0[2],x=match$0[1],v$0=[0,s$1,next];
                return [1,x,v$0]}]}
    function _bc_(t,f)
     {var next=t[2],seed=t[1];
      return [0,
              seed,
              function(seed)
               {var match=caml_call1(next,seed);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s=match[1];return [0,s]}
                var s$0=match[2],a=match[1];
                return [1,caml_call1(f,a),s$0]}]}
    function mapi$2(t,f)
     {var next=t[2],s=t[1];
      return [0,
              [0,0,s],
              function(param)
               {var s=param[2],i=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var s$1=match[2],a=match[1];
                return [1,caml_call2(f,i,a),[0,i + 1 | 0,s$1]]}]}
    function folding_map$0(t,init,f)
     {return unfold_with
              (t,
               init,
               function(acc,x)
                {var match=caml_call2(f,acc,x),x$0=match[2],acc$0=match[1];
                 return [1,x$0,acc$0]})}
    function folding_mapi$0(t,init,f)
     {return unfold_with
              (t,
               [0,0,init],
               function(param,x)
                {var
                  acc=param[2],
                  i=param[1],
                  match=caml_call3(f,i,acc,x),
                  x$0=match[2],
                  acc$0=match[1];
                 return [1,x$0,[0,i + 1 | 0,acc$0]]})}
    function filter$1(t,f)
     {var next=t[2],seed=t[1];
      return [0,
              seed,
              function(seed)
               {var match=caml_call1(next,seed);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s=match[1];return [0,s]}
                var a=match[1],s$0=match[2];
                if(caml_call1(f,a))return [1,a,s$0];
                var s$1=match[2];
                return [0,s$1]}]}
    function filteri$0(t,f)
     {function _E$_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return _bc_
              (filter$1(mapi$2(t,function(i,s){return [0,i,s]}),_E$_),
               get_data)}
    function length$2(t)
     {var next=t[2],seed=t[1],i=0,s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return i;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],i$0=i + 1 | 0,i=i$0,s=s$1}}
    function to_array$1(t)
     {var
       match=
        fold$1
         (t,
          _bd_,
          function(param,x)
           {var i=param[2],l=param[1];return [0,[0,x,l],i + 1 | 0]}),
       len=match[2],
       l=match[1];
      if(! l)return [0];
      var
       l$0=l[2],
       x=l[1],
       a=caml_make_vect(len,x),
       i$1=len - 2 | 0,
       i=i$1,
       l$1=l$0;
      for(;;)
       {if(l$1)
         {var l$2=l$1[2],x$0=l$1[1];
          caml_check_bound(a,i)[1 + i] = x$0;
          var i$0=i - 1 | 0,i=i$0,l$1=l$2;
          continue}
        if(-1 === i)return a;
        throw [0,Assert_failure$0,_be_]}}
    function find$3(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(caml_call1(f,a))return [0,a];var s$0=match[2]}
        var s=s$0}}
    function find_map$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],a=match[1],some_b=caml_call1(f,a);
        if(some_b)return some_b;
        var s=s$1}}
    function find_mapi$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],a=match[1],some_b=caml_call2(f,i,a);
        if(some_b)return some_b;
        var i$0=i + 1 | 0,s=s$1,i=i$0}}
    function for_all$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(! caml_call1(f,a))return 0;var s$0=match[2]}
        var s=s$0}}
    function for_alli$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var a=match[1];
        if(! caml_call2(f,i,a))return 0;
        var s$1=match[2],i$0=i + 1 | 0,s=s$1,i=i$0}}
    function exists$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(caml_call1(f,a))return 1;var s$0=match[2]}
        var s=s$0}}
    function existsi$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var a=match[1];
        if(caml_call2(f,i,a))return 1;
        var s$1=match[2],i$0=i + 1 | 0,s=s$1,i=i$0}}
    function iter$5(t,f)
     {var next=t[2],seed$1=t[1],seed=seed$1;
      for(;;)
       {var match=caml_call1(next,seed);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var seed$0=match[1],seed=seed$0;continue}
        var s=match[2],a=match[1];
        caml_call1(f,a);
        var seed=s}}
    function is_empty$1(t)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 !== match[0])return 0;
        var s$0=match[1],s=s$0}}
    function mem$2(t,a,equal)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var b=match[1];if(caml_call2(equal,a,b))return 1;var s$0=match[2]}
        var s=s$0}}
    var empty=[0,0,function(param){return 0}];
    function bind$11(t,f)
     {return [0,
              [0,empty,t],
              function(param)
               {var
                 rest=param[2],
                 match=param[1],
                 next=match[2],
                 seed=match[1],
                 match$0=caml_call1(next,seed);
                if(typeof match$0 === "number")
                 {var
                   next$0=rest[2],
                   seed$0=rest[1],
                   match$1=caml_call1(next$0,seed$0);
                  if(typeof match$1 === "number")return 0;
                  if(0 === match$1[0])
                   {var s=match$1[1];return [0,[0,empty,[0,s,next$0]]]}
                  var s$0=match$1[2],a=match$1[1];
                  return [0,[0,caml_call1(f,a),[0,s$0,next$0]]]}
                if(0 === match$0[0])
                 {var s$1=match$0[1];return [0,[0,[0,s$1,next],rest]]}
                var s$2=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,[0,s$2,next],rest]]}]}
    function return$11(x)
     {return [0,
              [0,x],
              function(param)
               {if(! param)return 0;var x=param[1];return [1,x,0]}]}
    var
     map$18=[0,-198771759,_bc_],
     include$37=Make([0,bind$11,return$11,map$18]),
     symbol_bind$5=include$37[1],
     symbol_map$6=include$37[2],
     Monad_infix$3=include$37[3],
     bind$12=include$37[4],
     return$12=include$37[5],
     map$19=include$37[6],
     join$4=include$37[7],
     ignore_m$4=include$37[8],
     all$11=include$37[9],
     all_unit$5=include$37[10],
     Let_syntax$5=include$37[11];
    function nth$0(s,i)
     {if(0 > i)return 0;
      var next=s[2],s$3=s[1],i$0=i,s$0=s$3;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        if(i$0 === 0)return [0,a];
        var i$1=i$0 - 1 | 0,i$0=i$1,s$0=s$2}}
    function nth_exn$0(s,n)
     {if(0 > n)return caml_call1(invalid_arg$0,cst_Sequence_nth$0);
      var match=nth$0(s,n);
      if(! match)return caml_call1(failwith$0,cst_Sequence_nth);
      var x=match[1];
      return x}
    function compare$29(cmp_a,cmp_b,a_011,b_012)
     {if(a_011 === b_012)return 0;
      switch(a_011[0])
       {case 0:
         var _E7_=a_011[1];
         if(0 !== b_012[0])return -1;
         var b_014=b_012[1];
         return caml_call2(cmp_a,_E7_,b_014);
        case 1:
         var _E8_=a_011[1];
         switch(b_012[0])
          {case 0:break;
           case 1:var b_016=b_012[1];return caml_call2(cmp_b,_E8_,b_016);
           default:return -1}
         break;
        default:
         var _E9_=a_011[2],_E__=a_011[1];
         switch(b_012[0])
          {case 0:break;
           case 1:return 1;
           default:
            var b_020=b_012[2],b_018=b_012[1],n=caml_call2(cmp_a,_E__,b_018);
            return 0 === n?caml_call2(cmp_b,_E9_,b_020):n}}
      return 1}
    function hash_fold_t$19(hash_fold_a,hash_fold_b,hsv,arg)
     {switch(arg[0])
       {case 0:
         var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
         return caml_call2(hash_fold_a,hsv$0,a0);
        case 1:
         var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
         return caml_call2(hash_fold_b,hsv$1,a0$0);
        default:
         var
          a1=arg[2],
          a0$1=arg[1],
          hsv$2=runtime.Base_internalhash_fold_int(hsv,2),
          hsv$3=caml_call2(hash_fold_a,hsv$2,a0$1);
         return caml_call2(hash_fold_b,hsv$3,a1)}}
    function t_of_sexp$18(of_a_021,of_b_022,sexp_027)
     {if(0 === sexp_027[0])
       {var _E2_=sexp_027[1],switch$0=0;
        if(caml_string_notequal(_E2_,cst_Both))
         {var switch$1=0;
          if(caml_string_notequal(_E2_,cst_Left))
           {var switch$2=0;
            if(caml_string_notequal(_E2_,cst_Right))
             if(caml_string_notequal(_E2_,cst_both))
              if(caml_string_notequal(_E2_,cst_left))
               {if(caml_string_notequal(_E2_,cst_right))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
      else
       {var _E3_=sexp_027[1];
        if(! _E3_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_025,sexp_027);
        var _E4_=_E3_[1];
        if(0 !== _E4_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_025,sexp_027);
        var _E5_=_E4_[1],switch$3=0;
        if(caml_string_notequal(_E5_,cst_Both$0))
         {var switch$4=0;
          if(caml_string_notequal(_E5_,cst_Left$0))
           {var switch$5=0;
            if(caml_string_notequal(_E5_,cst_Right$0))
             if(caml_string_notequal(_E5_,cst_both$0))
              if(caml_string_notequal(_E5_,cst_left$0))
               {if(caml_string_notequal(_E5_,cst_right$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             {var sexp_args_034=_E3_[2];
              if(sexp_args_034 && ! sexp_args_034[2])
               {var
                 arg0_035=sexp_args_034[1],
                 res0_036=caml_call1(of_b_022,arg0_035);
                return [1,res0_036]}
              return caml_call3
                      (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
          if(! switch$4)
           {var sexp_args_029=_E3_[2];
            if(sexp_args_029 && ! sexp_args_029[2])
             {var
               arg0_030=sexp_args_029[1],
               res0_031=caml_call1(of_a_021,arg0_030);
              return [0,res0_031]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
        if(! switch$3)
         {var sexp_args_039=_E3_[2];
          if(sexp_args_039)
           {var _E6_=sexp_args_039[2];
            if(_E6_ && ! _E6_[2])
             {var
               arg1_041=_E6_[1],
               arg0_040=sexp_args_039[1],
               res0_042=caml_call1(of_a_021,arg0_040),
               res1_043=caml_call1(of_b_022,arg1_041);
              return [2,res0_042,res1_043]}}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_025,sexp_027)}
    function sexp_of_t$27(of_a_046,of_b_047,param)
     {switch(param[0])
       {case 0:
         var arg0_048=param[1],res0_049=caml_call1(of_a_046,arg0_048);
         return [1,[0,_bf_,[0,res0_049,0]]];
        case 1:
         var arg0_050=param[1],res0_051=caml_call1(of_b_047,arg0_050);
         return [1,[0,_bg_,[0,res0_051,0]]];
        default:
         var
          arg1_053=param[2],
          arg0_052=param[1],
          res0_054=caml_call1(of_a_046,arg0_052),
          res1_055=caml_call1(of_b_047,arg1_053);
         return [1,[0,_bh_,[0,res0_054,[0,res1_055,0]]]]}}
    function t_sexp_grammar$19(a_sexp_grammar,b_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Left$1,[0,[0,a_sexp_grammar,0]]]],
                [0,
                 [1,[0,cst_Right$1,[0,[0,b_sexp_grammar,0]]]],
                 [0,
                  [1,
                   [0,cst_Both$1,[0,[0,a_sexp_grammar,[0,b_sexp_grammar,0]]]]],
                  0]]]]]}
    var
     Merge_with_duplicates_element=
      [0,
       compare$29,
       hash_fold_t$19,
       t_of_sexp$18,
       sexp_of_t$27,
       t_sexp_grammar$19];
    function merge_with_duplicates(param,_EW_,compare)
     {var next2=_EW_[2],s2=_EW_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EX_=param[1];
        if(typeof _EX_ === "number")
         {var _EY_=param[2];
          if(typeof _EY_ === "number")return 0;
          if(0 !== _EY_[0])
           {var s2$0=_EY_[2],b=_EY_[1];return [1,[1,b],[0,0,[0,s2$0]]]}}
        else
         {if(0 === _EX_[0])
           {var s2$1=param[2],s1=_EX_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _EZ_=param[2],_E0_=_EX_[2],_E1_=_EX_[1];
          if(typeof _EZ_ === "number")return [1,[0,_E1_],[0,[0,_E0_],0]];
          if(0 !== _EZ_[0])
           {var
             s2$2=_EZ_[2],
             b$0=_EZ_[1],
             comparison=caml_call2(compare,_E1_,b$0);
            return 0 <= comparison
                    ?0 === comparison
                      ?[1,[2,_E1_,b$0],[0,[0,_E0_],[0,s2$2]]]
                      :[1,[1,b$0],[0,_EX_,[0,s2$2]]]
                    :[1,[0,_E1_],[0,[0,_E0_],_EZ_]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_EX_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function merge_deduped_and_sorted(s1,s2,compare)
     {function _EV_(param){var x=param[1];return x}
      return caml_call2(map$19,merge_with_duplicates(s1,s2,compare),_EV_)}
    function merge_sorted(param,_EP_,compare)
     {var next2=_EP_[2],s2=_EP_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EQ_=param[1];
        if(typeof _EQ_ === "number")
         {var _ER_=param[2];
          if(typeof _ER_ === "number")return 0;
          if(0 !== _ER_[0])
           {var s2$0=_ER_[2],b=_ER_[1];return [1,b,[0,0,[0,s2$0]]]}}
        else
         {if(0 === _EQ_[0])
           {var s2$1=param[2],s1=_EQ_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _ES_=param[2],_ET_=_EQ_[2],_EU_=_EQ_[1];
          if(typeof _ES_ === "number")return [1,_EU_,[0,[0,_ET_],0]];
          if(0 !== _ES_[0])
           {var
             s2$2=_ES_[2],
             b$0=_ES_[1],
             comparison=caml_call2(compare,_EU_,b$0);
            return 0 < comparison
                    ?[1,b$0,[0,_EQ_,[0,s2$2]]]
                    :[1,_EU_,[0,[0,_ET_],_ES_]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_EQ_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function hd$0(s)
     {var next=s[2],s$2=s[1],s$0=s$2;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var a=match[1];
        return [0,a]}}
    function hd_exn$0(s)
     {var match=hd$0(s);
      if(! match)return caml_call1(failwith$0,cst_hd_exn);
      var a=match[1];
      return a}
    function tl$0(s)
     {var next=s[2],s$2=s[1],s$0=s$2;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")
         var match$0=0;
        else
         {if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
          var a=match[2],match$0=[0,a]}
        if(! match$0)return 0;
        var s$3=match$0[1];
        return [0,[0,s$3,next]]}}
    function tl_eagerly_exn(s)
     {var match=tl$0(s);
      if(! match)return caml_call1(failwith$0,cst_Sequence_tl_exn);
      var s$0=match[1];
      return s$0}
    function lift_identity(next,s)
     {var match=caml_call1(next,s);
      if(typeof match === "number")return 0;
      if(0 === match[0]){var s$0=match[1];return [0,[0,316735838,s$0]]}
      var s$1=match[2],a=match[1];
      return [1,a,[0,316735838,s$1]]}
    function next(s)
     {var next=s[2],s$3=s[1],s$0=s$3;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        return [0,[0,a,[0,s$2,next]]]}}
    function filter_opt$0(s)
     {var next=s[2],s$0=s[1];
      return [0,
              s$0,
              function(s)
               {var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,s$0]}
                var _EO_=match[1];
                if(_EO_){var s$1=match[2],a=_EO_[1];return [1,a,s$1]}
                var s$2=match[2];
                return [0,s$2]}]}
    function filter_map$0(s,f){return filter_opt$0(caml_call2(map$19,s,f))}
    function filter_mapi$0(s,f)
     {function _EN_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return filter_map$0(mapi$2(s,function(i,s){return [0,i,s]}),_EN_)}
    function split_n$0(s,i)
     {var next=s[2],s$3=s[1],s$0=s$3,i$0=i,accum=0;
      for(;;)
       {if(0 >= i$0)return [0,rev(accum),[0,s$0,next]];
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return [0,rev(accum),empty];
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var
         s$2=match[2],
         a=match[1],
         accum$0=[0,a,accum],
         i$1=i$0 - 1 | 0,
         s$0=s$2,
         i$0=i$1,
         accum=accum$0}}
    function chunks_exn(t,n)
     {return 0 < n
              ?[0,
                t,
                function(t)
                 {var match=split_n$0(t,n),_EM_=match[1];
                  if(! _EM_)return 0;
                  var t$0=match[2];
                  return [1,_EM_,t$0]}]
              :caml_call1(invalid_arg$0,cst_Sequence_chunks_exn)}
    function findi$1(s,f)
     {function _EL_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return find$3(mapi$2(s,function(i,s){return [0,i,s]}),_EL_)}
    function find_exn$1(s,f)
     {var match=find$3(s,f);
      if(! match)return caml_call1(failwith$0,cst_Sequence_find_exn);
      var x=match[1];
      return x}
    function append$1(s1,s2)
     {var next2=s2[2],s2$0=s2[1],next1=s1[2],s1$0=s1[1];
      return [0,
              [0,472258093,s1$0],
              function(param)
               {if(472258093 <= param[1])
                 {var s1=param[2],match=caml_call1(next1,s1);
                  if(typeof match === "number")return [0,[0,-630817751,s2$0]];
                  if(0 === match[0])
                   {var s1$0=match[1];return [0,[0,472258093,s1$0]]}
                  var s1$1=match[2],a=match[1];
                  return [1,a,[0,472258093,s1$1]]}
                var s2=param[2],match$0=caml_call1(next2,s2);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s2$1=match$0[1];return [0,[0,-630817751,s2$1]]}
                var s2$2=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,-630817751,s2$2]]}]}
    function concat_map(s,f){return caml_call2(bind$12,s,f)}
    function concat$2(s){return concat_map(s,function(_EK_){return _EK_})}
    function concat_mapi$0(s,f)
     {function _EJ_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return concat_map(mapi$2(s,function(i,s){return [0,i,s]}),_EJ_)}
    function zip$0(param,_EE_)
     {var next2=_EE_[2],s2=_EE_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EF_=param[1],switch$0=0;
        if(typeof _EF_ === "number")
         switch$0 = 1;
        else
         if(1 === _EF_[0])
          {var _EG_=param[2],_EH_=_EF_[2],_EI_=_EF_[1];
           if(typeof _EG_ !== "number")
            {if(0 === _EG_[0])
              {var match=param[2],s2$0=match[1];
               return [0,[0,_EF_,caml_call1(next2,s2$0)]]}
             var s2$1=_EG_[2],b=_EG_[1];
             return [1,[0,_EI_,b],[0,[0,_EH_],[0,s2$1]]]}}
        if(! switch$0 && typeof param[2] !== "number")
         {var s2=param[2],s1=_EF_[1];return [0,[0,caml_call1(next1,s1),s2]]}
        return 0}
      return [0,[0,[0,s1],[0,s2]],next]}
    function zip_full(param,_Ey_)
     {var next2=_Ey_[2],s2=_Ey_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _Ez_=param[1];
        if(typeof _Ez_ === "number")
         {var _EA_=param[2];
          if(typeof _EA_ === "number")return 0;
          if(0 !== _EA_[0])
           {var s2$0=_EA_[2],b=_EA_[1];
            return [1,[0,-57574468,b],[0,0,caml_call1(next2,s2$0)]]}}
        else
         {if(0 === _Ez_[0])
           {var s2$1=param[2],s1=_Ez_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _EB_=param[2],_EC_=_Ez_[2],_ED_=_Ez_[1];
          if(typeof _EB_ === "number")
           return [1,[0,847852583,_ED_],[0,caml_call1(next1,_EC_),0]];
          if(0 !== _EB_[0])
           {var s2$2=_EB_[2],b$0=_EB_[1];
            return [1,[0,737457313,[0,_ED_,b$0]],[0,[0,_EC_],[0,s2$2]]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_Ez_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function bounded_length(param,at_most)
     {var next=param[2],seed=param[1],i=0,seed$0=seed;
      for(;;)
       {if(at_most < i)return 85047514;
        var match=caml_call1(next,seed$0);
        if(typeof match === "number")return [0,16394,i];
        if(0 === match[0]){var seed$1=match[1],seed$0=seed$1;continue}
        var seed$2=match[2],i$0=i + 1 | 0,i=i$0,seed$0=seed$2}}
    function length_is_bounded_by(opt,max,t)
     {if(opt)var sth=opt[1],min=sth;else var min=-1;
      if(max)
       {var max$0=max[1],match$0=bounded_length(t,max$0);
        if(typeof match$0 !== "number" && 16394 === match$0[1])
         {var len=match$0[2];if(min <= len)return 1}
        return 0}
      var next=t[2],s=t[1],s$0=s,acc=0;
      for(;;)
       {if(min <= acc)return 1;
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],acc$0=acc + 1 | 0,s$0=s$2,acc=acc$0}}
    function iteri$2(s,f)
     {function _Ex_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return iter$5(mapi$2(s,function(i,s){return [0,i,s]}),_Ex_)}
    function foldi$1(s,init,f)
     {function _Ew_(acc,param)
       {var s=param[2],i=param[1];return caml_call3(f,i,acc,s)}
      return fold$1(mapi$2(s,function(i,s){return [0,i,s]}),init,_Ew_)}
    function reduce$0(s,f)
     {var match=next(s);
      if(! match)return 0;
      var match$0=match[1],s$0=match$0[2],a=match$0[1];
      return [0,fold$1(s$0,a,f)]}
    function reduce_exn$0(s,f)
     {var match=reduce$0(s,f);
      if(! match)return caml_call1(failwith$0,cst_Sequence_reduce_exn);
      var res=match[1];
      return res}
    function group$1(param,break$0)
     {var next=param[2],s=param[1];
      return [0,
              [0,[0,0,s]],
              function(param)
               {if(! param)return 0;
                var
                 match=param[1],
                 s=match[2],
                 acc=match[1],
                 match$0=caml_call1(next,s);
                if(typeof match$0 !== "number" && 0 === match$0[0])
                 {var s$2=match$0[1];return [0,[0,[0,acc,s$2]]]}
                if(acc)
                 {if(typeof match$0 === "number")return [1,rev(acc),0];
                  var s$0=match$0[2],cur=match$0[1],prev=acc[1];
                  return caml_call2(break$0,prev,cur)
                          ?[1,rev(acc),[0,[0,[0,cur,0],s$0]]]
                          :[0,[0,[0,[0,cur,acc],s$0]]]}
                if(typeof match$0 === "number")return 0;
                var s$1=match$0[2],cur$0=match$0[1];
                return [0,[0,[0,[0,cur$0,0],s$1]]]}]}
    function find_consecutive_duplicate$0(param,equal)
     {var next=param[2],s=param[1],last_elt=0,s$0=s;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        if(last_elt)
         {var b=last_elt[1];if(caml_call2(equal,a,b))return [0,[0,b,a]]}
        var last_elt$0=[0,a],last_elt=last_elt$0,s$0=s$2}}
    function remove_consecutive_duplicates$0(s,equal)
     {return unfold_with
              (s,
               0,
               function(prev,a)
                {if(prev)
                  {var b=prev[1];if(caml_call2(equal,a,b))return [0,[0,a]]}
                 return [1,a,[0,a]]})}
    function count$2(s,f){return length$2(filter$1(s,f))}
    function counti$1(t,f){return length$2(filteri$0(t,f))}
    function sum$2(m,t,f){return caml_call2(sum(fold$1,m),t,f)}
    function min_elt$2(t,compare){return min_elt(fold$1,t,compare)}
    function max_elt$2(t,compare){return max_elt(fold$1,t,compare)}
    function init$2(n,f)
     {return [0,0,function(i){return n <= i?0:[1,caml_call1(f,i),i + 1 | 0]}]}
    function sub$4(s,pos,len)
     {var _Eu_=pos < 0?1:0,_Ev_=_Eu_ || (len < 0?1:0);
      if(_Ev_)caml_call1(failwith$0,cst_Sequence_sub);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1];
                if(len <= (i - pos | 0))return 0;
                var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var a=match[1],s$1=match[2];
                if(pos <= i)return [1,a,[0,i + 1 | 0,s$1]];
                var s$2=match[2];
                return [0,[0,i + 1 | 0,s$2]]}]}
    function take$0(s,len)
     {if(len < 0)caml_call1(failwith$0,cst_Sequence_take);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1];
                if(len <= i)return 0;
                var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var s$1=match[2],a=match[1];
                return [1,a,[0,i + 1 | 0,s$1]]}]}
    function drop$0(s,len)
     {if(len < 0)caml_call1(failwith$0,cst_Sequence_drop);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var a=match[1],s$1=match[2];
                if(len <= i)return [1,a,[0,i + 1 | 0,s$1]];
                var s$2=match[2];
                return [0,[0,i + 1 | 0,s$2]]}]}
    function take_while$0(s,f)
     {var next=s[2],s$0=s[1];
      return [0,
              s$0,
              function(s)
               {var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,s$0]}
                var a=match[1],s$1=match[2];
                return caml_call1(f,a)?[1,a,s$1]:0}]}
    function drop_while$0(s,f)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,-557110719,s$0],
              function(param)
               {if(316735838 <= param[1])
                 {var s=param[2];return lift_identity(next,s)}
                var s$0=param[2],match=caml_call1(next,s$0);
                if(typeof match === "number")return 0;
                if(0 === match[0])
                 {var s$1=match[1];return [0,[0,-557110719,s$1]]}
                var a=match[1],s$2=match[2];
                if(caml_call1(f,a))return [0,[0,-557110719,s$2]];
                var s$3=match[2];
                return [1,a,[0,316735838,s$3]]}]}
    function shift_right(s,x)
     {var next=s[2],seed=s[1];
      return [0,
              [0,-433944719,[0,seed,x]],
              function(param)
               {if(316735838 <= param[1])
                 {var s=param[2];return lift_identity(next,s)}
                var match=param[2],x=match[2],seed=match[1];
                return [1,x,[0,316735838,seed]]}]}
    function shift_right_with_list(s,l){return append$1(of_list$1(l),s)}
    var Infix$1=[0,append$1];
    function intersperse$0(s,sep)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,815032112,s$0],
              function(param)
               {var _Et_=param[1];
                if(815032112 === _Et_)
                 {var s=param[2],match=caml_call1(next,s);
                  if(typeof match === "number")return 0;
                  if(0 === match[0])
                   {var s$0=match[1];return [0,[0,815032112,s$0]]}
                  var s$1=match[2],a=match[1];
                  return [1,a,[0,951752159,s$1]]}
                if(951752159 > _Et_)
                 {var match$1=param[2],s$5=match$1[2],a$1=match$1[1];
                  return [1,a$1,[0,951752159,s$5]]}
                var s$2=param[2],match$0=caml_call1(next,s$2);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s$3=match$0[1];return [0,[0,951752159,s$3]]}
                var s$4=match$0[2],a$0=match$0[1];
                return [1,sep,[0,-571577571,[0,a$0,s$4]]]}]}
    function repeat(x){return [0,x,function(x){return [1,x,x]}]}
    function cycle_list_exn(xs)
     {if(is_empty(xs))caml_call1(invalid_arg$0,cst_Sequence_cycle_list_exn);
      var s=of_list$1(xs);
      function _Es_(param){return s}
      return concat_map(repeat(0),_Es_)}
    function cartesian_product$0(sa,sb)
     {return concat_map(sa,function(a){return zip$0(repeat(a),sb)})}
    function singleton(x){return caml_call1(return$12,x)}
    function delayed_fold(s,init,f,finish)
     {function _Er_(acc,option,k)
       {if(! option)return caml_call1(k,acc);
        var a=option[1];
        return caml_call3(f,acc,a,k)}
      return caml_call4(Expert[2],s,init,_Er_,finish)}
    function fold_m(bind,return$0,t,init,f)
     {function _Eq_(acc,option,k)
       {if(! option)return caml_call2(bind,caml_call1(return$0,acc),k);
        var a=option[1];
        return caml_call2(bind,caml_call2(f,acc,a),k)}
      return caml_call4(Expert[2],t,init,_Eq_,return$0)}
    function iter_m(bind,return$0,t,f)
     {function _Ep_(param,option,k)
       {if(! option)return caml_call2(bind,caml_call1(return$0,0),k);
        var a=option[1];
        return caml_call2(bind,caml_call1(f,a),k)}
      return caml_call4(Expert[2],t,0,_Ep_,return$0)}
    function fold_until$2(s,acc,f,finish)
     {var next=s[2],s$3=s[1],s$0=s$3,acc$0=acc;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return caml_call1(finish,acc$0);
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1],match$0=caml_call2(f,acc$0,a);
        if(0 === match$0[0])
         {var acc$1=match$0[1],s$0=s$2,acc$0=acc$1;continue}
        var x=match$0[1];
        return x}}
    function fold_result$2(s,acc,f)
     {var next=s[2],s$3=s[1],s$0=s$3,acc$0=acc;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return caml_call1(return$3,acc$0);
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1],e=caml_call2(f,acc$0,a);
        if(0 !== e[0])return e;
        var acc$1=e[1],s$0=s$2,acc$0=acc$1}}
    function force_eagerly(t){return of_list$1(to_list$3(t))}
    function memoize(param)
     {var next=param[2],s=param[1];
      function memoize(s)
       {return [0,
                [246,
                 function(_Eo_)
                  {var s$0=s;
                   for(;;)
                    {var match=caml_call1(next,s$0);
                     if(typeof match === "number")return 0;
                     if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
                     var s$2=match[2],a=match[1];
                     return [1,a,memoize(s$2)]}}]]}
      function _Em_(param)
       {var l=param[1],_En_=caml_obj_tag(l);
        return 250 === _En_
                ?l[1]
                :246 === _En_?caml_call1(CamlinternalLazy[2],l):l}
      return [0,memoize(s),_Em_]}
    function drop_eagerly(s,len)
     {var next=s[2],s$3=s[1],i=0,s$0=s$3;
      for(;;)
       {if(len <= i)return [0,s$0,next];
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return empty;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],i$0=i + 1 | 0,i=i$0,s$0=s$2}}
    function drop_while_option(param,f)
     {var next=param[2],s=param[1],s$0=s;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],x=match[1];
        if(! caml_call1(f,x))return [0,[0,x,[0,s$2,next]]];
        var s$0=s$2}}
    function compare$30(compare_a,t1,t2)
     {return with_return
              (function(r)
                {function _Ej_(param)
                  {var _Ek_=param[1];
                   if(737457313 !== _Ek_)
                    return 847852583 <= _Ek_?caml_call1(r,1):caml_call1(r,-1);
                   var
                    match=param[2],
                    v2=match[2],
                    v1=match[1],
                    c=caml_call2(compare_a,v1,v2),
                    _El_=0 !== c?1:0;
                   return _El_?caml_call1(r,c):_El_}
                 iter$5(zip_full(t1,t2),_Ej_);
                 return 0})}
    function equal$19(equal_a,t1,t2)
     {function _Ei_(param)
       {if(737457313 !== param[1])return 0;
        var match=param[2],a2=match[2],a1=match[1];
        return caml_call2(equal_a,a1,a2)}
      return for_all$2(zip_full(t1,t2),_Ei_)}
    function round_robin(list)
     {function next(param)
       {var done_stack=param[2],todo_stack=param[1];
        if(! todo_stack)
         return is_empty(done_stack)?0:[0,[0,rev(done_stack),0]];
        var
         todo_stack$0=todo_stack[2],
         match=todo_stack[1],
         f=match[2],
         s=match[1],
         match$0=caml_call1(f,s);
        if(typeof match$0 === "number")return [0,[0,todo_stack$0,done_stack]];
        if(0 === match$0[0])
         {var s$0=match$0[1];
          return [0,[0,[0,[0,s$0,f],todo_stack$0],done_stack]]}
        var s$1=match$0[2],x=match$0[1];
        return [1,x,[0,todo_stack$0,[0,[0,s$1,f],done_stack]]]}
      var state=[0,list,0];
      return [0,state,next]}
    function interleave(param)
     {var f1=param[2],s1=param[1];
      function next(param)
       {var s1=param[3],done_stack=param[2],todo_stack=param[1];
        if(todo_stack)
         {var
           todo_stack$0=todo_stack[2],
           match=todo_stack[1],
           f2=match[2],
           s2=match[1],
           match$0=caml_call1(f2,s2);
          if(typeof match$0 === "number")
           return [0,[0,todo_stack$0,done_stack,s1]];
          if(0 === match$0[0])
           {var s2$0=match$0[1];
            return [0,[0,todo_stack$0,[0,[0,s2$0,f2],done_stack],s1]]}
          var s2$1=match$0[2],x=match$0[1];
          return [1,x,[0,todo_stack$0,[0,[0,s2$1,f2],done_stack],s1]]}
        var match$1=caml_call1(f1,s1);
        if(typeof match$1 === "number")
         return done_stack?[0,[0,rev(done_stack),0,s1]]:0;
        if(0 === match$1[0])
         {var s1$0=match$1[1];return [0,[0,rev(done_stack),0,s1$0]]}
        var s1$1=match$1[2],t=match$1[1];
        return [0,[0,rev([0,t,done_stack]),0,s1$1]]}
      var state=[0,0,0,s1];
      return [0,state,next]}
    function interleaved_cartesian_product(s1,s2)
     {return interleave
              (caml_call2
                (map$19,
                 s1,
                 function(x1)
                  {return caml_call2(map$19,s2,function(x2){return [0,x1,x2]})}))}
    function of_seq(seq)
     {return [0,
              seq,
              function(seq)
               {var match=caml_call1(seq,0);
                if(! match)return 0;
                var tl=match[2],hd=match[1];
                return [1,hd,tl]}]}
    function to_seq(param)
     {var next=param[2],state=param[1];
      function loop(state)
       {var state$0=state;
        for(;;)
         {var match=caml_call1(next,state$0);
          if(typeof match === "number")return 0;
          if(0 === match[0]){var state$1=match[1],state$0=state$1;continue}
          var state$2=match[2],hd=match[1];
          return [0,hd,function(param){return loop(state$2)}]}}
      return function(param){return loop(state)}}
    function return$13(x,k){return caml_call1(k,x)}
    function bind$13(m,f,k)
     {return caml_call1
              (m,function(a){var m=caml_call1(f,a);return caml_call1(m,k)})}
    var
     map$20=
      [0,
       -198771759,
       function(m,f,k)
        {return caml_call1
                 (m,function(a){return caml_call1(k,caml_call1(f,a))})}],
     include$38=Make2([0,bind$13,map$20,return$13]),
     symbol_bind$6=include$38[1],
     symbol_map$7=include$38[2],
     Let_syntax$6=include$38[3],
     Monad_infix$4=include$38[4],
     bind$14=include$38[5],
     return$14=include$38[6],
     map$21=include$38[7],
     join$5=include$38[8],
     ignore_m$5=include$38[9],
     all$12=include$38[10],
     all_unit$6=include$38[11];
    function yield$0(e,k){return [0,[1,e,k]]}
    function of_sequence(sequence)
     {return delayed_fold
              (sequence,
               0,
               function(param,x,k,f)
                {return [0,[1,x,function(param){return caml_call2(k,0,f)}]]},
               return$14)}
    function run$0(t)
     {function init(param){return caml_call1(t,function(param){return _bi_})}
      function f(thunk){return caml_call1(thunk,0)[1]}
      return [0,init,f]}
    var
     Base_Sequence=
      [0,
       sexp_of_t$26,
       equal$19,
       compare$30,
       mem$2,
       length$2,
       is_empty$1,
       iter$5,
       fold$1,
       fold_result$2,
       fold_until$2,
       exists$2,
       for_all$2,
       count$2,
       sum$2,
       find$3,
       find_map$2,
       to_list$3,
       to_array$1,
       min_elt$2,
       max_elt$2,
       foldi$1,
       iteri$2,
       existsi$1,
       counti$1,
       findi$1,
       find_mapi$1,
       symbol_bind$5,
       symbol_map$6,
       Monad_infix$3,
       bind$12,
       return$12,
       map$19,
       join$4,
       ignore_m$4,
       all$11,
       all_unit$5,
       Let_syntax$5,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth$0,
       nth_exn$0,
       folding_map$0,
       folding_mapi$0,
       mapi$2,
       filteri$0,
       filter$1,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd$0,
       hd_exn$0,
       tl$0,
       tl_eagerly_exn,
       find_exn$1,
       for_alli$1,
       append$1,
       concat$2,
       concat_map,
       concat_mapi$0,
       interleave,
       round_robin,
       zip$0,
       zip_full,
       reduce_exn$0,
       reduce$0,
       group$1,
       find_consecutive_duplicate$0,
       remove_consecutive_duplicates$0,
       range$1,
       init$2,
       filter_map$0,
       filter_mapi$0,
       filter_opt$0,
       sub$4,
       take$0,
       drop$0,
       drop_eagerly,
       take_while$0,
       drop_while$0,
       drop_while_option,
       split_n$0,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop$0,
       Infix$1,
       cartesian_product$0,
       interleaved_cartesian_product,
       intersperse$0,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list$1,
       of_lazy$0,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$6,
        symbol_map$7,
        Let_syntax$6,
        Monad_infix$4,
        bind$14,
        return$14,
        map$21,
        join$5,
        ignore_m$5,
        all$12,
        all_unit$6,
        yield$0,
        of_sequence,
        run$0],
       Expert];
    caml_register_global(1068,Base_Sequence,"Base__Sequence");
    function t_sexp_grammar$20(a_sexp_grammar)
     {return caml_call1(array_sexp_grammar,a_sexp_grammar)}
    function get$0(_Eh_,_Eg_){return caml_check_bound(_Eh_,_Eg_)[1 + _Eg_]}
    function set(_Ef_,_Ee_,_Ed_)
     {caml_check_bound(_Ef_,_Ee_)[1 + _Ee_] = _Ed_;return 0}
    function swap$1(arr,i,j)
     {var tmp=get$0(arr,i);set(arr,i,get$0(arr,j));return set(arr,j,tmp)}
    function sort$0(arr,compare,left,right)
     {var _Eb_=left + 1 | 0;
      if(right >= _Eb_)
       {var pos=_Eb_;
        a:
        for(;;)
         {var v=get$0(arr,pos),i=pos;
          for(;;)
           {var i_next=i - 1 | 0;
            if(left <= i_next && 0 < caml_call2(compare,get$0(arr,i_next),v))
             {set(arr,i,get$0(arr,i_next));var i=i_next;continue}
            set(arr,i,v);
            var _Ec_=pos + 1 | 0;
            if(right !== pos){var pos=_Ec_;continue a}
            break}
          break}}
      return 0}
    var Insertion_sort=[0,sort$0];
    function heapify(arr,compare,root,left,right)
     {var root$0=root;
      for(;;)
       {var
         relative_root=root$0 - left | 0,
         left_child=((2 * relative_root | 0) + left | 0) + 1 | 0,
         right_child=((2 * relative_root | 0) + left | 0) + 2 | 0,
         switch$0=0;
        if(left_child <= right)
         {var _D__=get$0(arr,root$0);
          if(0 < caml_call2(compare,get$0(arr,left_child),_D__))
           {var largest=left_child;switch$0 = 1}}
        if(! switch$0)var largest=root$0;
        var switch$1=0;
        if(right_child <= right)
         {var _D$_=get$0(arr,largest);
          if(0 < caml_call2(compare,get$0(arr,right_child),_D$_))
           {var largest$0=right_child;switch$1 = 1}}
        if(! switch$1)var largest$0=largest;
        var _Ea_=largest$0 !== root$0?1:0;
        if(! _Ea_)return _Ea_;
        swap$1(arr,root$0,largest$0);
        var root$0=largest$0}}
    function sort$1(arr,compare,left,right)
     {var _D6_=(left + right | 0) / 2 | 0;
      if(_D6_ >= left)
       {var i=_D6_;
        for(;;)
         {heapify(arr,compare,i,left,right);
          var _D7_=i - 1 | 0;
          if(left !== i){var i=_D7_;continue}
          break}}
      var _D8_=left + 1 | 0;
      if(right >= _D8_)
       {var i$0=right;
        for(;;)
         {swap$1(arr,left,i$0);
          heapify(arr,compare,left,left,i$0 - 1 | 0);
          var _D9_=i$0 - 1 | 0;
          if(_D8_ !== i$0){var i$0=_D9_;continue}
          break}}
      return 0}
    var Heap_sort=[0,sort$1];
    function five_element_sort(arr,compare,m1,m2,m3,m4,m5)
     {function compare_and_swap(i,j)
       {var
         _D4_=get$0(arr,j),
         _D5_=0 < caml_call2(compare,get$0(arr,i),_D4_)?1:0;
        return _D5_?swap$1(arr,i,j):_D5_}
      compare_and_swap(m1,m2);
      compare_and_swap(m4,m5);
      compare_and_swap(m1,m3);
      compare_and_swap(m2,m3);
      compare_and_swap(m1,m4);
      compare_and_swap(m3,m4);
      compare_and_swap(m2,m5);
      compare_and_swap(m2,m3);
      return compare_and_swap(m4,m5)}
    function intro_sort(arr,max_depth,compare,left,r$3)
     {var max_depth$0=max_depth,left$0=left;
      a:
      for(;;)
       {var len=(r$3 - left$0 | 0) + 1 | 0;
        if(32 >= len)
         return caml_call4(Insertion_sort[1],arr,compare,left$0,r$3);
        if(0 > max_depth$0)
         return caml_call4(Heap_sort[1],arr,compare,left$0,r$3);
        var
         max_depth$1=max_depth$0 - 1 | 0,
         sixth=(r$3 - left$0 | 0) / 6 | 0,
         m1=left$0 + sixth | 0,
         m2=m1 + sixth | 0,
         m3=m2 + sixth | 0,
         m4=m3 + sixth | 0,
         m5=m4 + sixth | 0;
        five_element_sort(arr,compare,m1,m2,m3,m4,m5);
        var
         m2_val=get$0(arr,m2),
         m3_val=get$0(arr,m3),
         m4_val=get$0(arr,m4),
         match=
          0 === caml_call2(compare,m2_val,m3_val)
           ?[0,m2_val,m3_val,1]
           :0 === caml_call2(compare,m3_val,m4_val)
             ?[0,m3_val,m4_val,1]
             :[0,m2_val,m4_val,0],
         middle_sorted=match[3],
         pivot2=match[2],
         pivot1=match[1],
         l$0=left$0,
         p$1=left$0,
         r$2=r$3;
        b:
        for(;;)
         {if(r$2 < p$1)
           {intro_sort(arr,max_depth$1,compare,left$0,l$0 - 1 | 0);
            if(1 - middle_sorted)intro_sort(arr,max_depth$1,compare,l$0,r$2);
            var left$1=r$2 + 1 | 0,max_depth$0=max_depth$1,left$0=left$1;
            continue a}
          var pv=get$0(arr,p$1);
          if(0 > caml_call2(compare,pv,pivot1))
           {swap$1(arr,p$1,l$0);
            var p$0=p$1 + 1 | 0,l=l$0 + 1 | 0,l$0=l,p$1=p$0;
            continue}
          if(0 >= caml_call2(compare,pv,pivot2))
           {var p=p$1 + 1 | 0,p$1=p;continue}
          var r=r$2;
          for(;;)
           {if(p$1 < r && 0 < caml_call2(compare,get$0(arr,r),pivot2))
             {var r$0=r - 1 | 0,r=r$0;continue}
            swap$1(arr,r,p$1);
            var r$1=r - 1 | 0,r$2=r$1;
            continue b}}}}
    function sort$2(arr,compare,left,right)
     {return intro_sort(arr,32,compare,left,right)}
    var Intro_sort=[0,sort$2,five_element_sort];
    function sort$3(pos,len,arr,compare)
     {var
       match=get_pos_len_exn(pos,len,0,arr.length - 1),
       len$0=match[2],
       pos$0=match[1];
      return caml_call4
              (Intro_sort[1],arr,compare,pos$0,(pos$0 + len$0 | 0) - 1 | 0)}
    function to_array$2(t){return t}
    function is_empty$2(t){return 0 === t.length - 1?1:0}
    function is_sorted$0(t,compare)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 < i[1] && result[1])
         {var elt_i=t[1 + i[1]],elt_i_minus_1=t[1 + (i[1] - 1 | 0)];
          if(0 < caml_call2(compare,elt_i_minus_1,elt_i))result[1] = 0;
          decr(i);
          continue}
        return result[1]}}
    function is_sorted_strictly$0(t,compare)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 < i[1] && result[1])
         {var elt_i=t[1 + i[1]],elt_i_minus_1=t[1 + (i[1] - 1 | 0)];
          if(0 <= caml_call2(compare,elt_i_minus_1,elt_i))result[1] = 0;
          decr(i);
          continue}
        return result[1]}}
    function merge$1(a1,a2,compare)
     {var l1=a1.length - 1,l2=a2.length - 1;
      if(0 === l1)return caml_call1(copy,a2);
      if(0 === l2)return caml_call1(copy,a1);
      if(0 <= caml_call2(compare,a2[1],a1[1 + (l1 - 1 | 0)]))
       return caml_call2(append,a1,a2);
      if(0 < caml_call2(compare,a1[1],a2[1 + (l2 - 1 | 0)]))
       return caml_call2(append,a2,a1);
      var
       len=l1 + l2 | 0,
       merged=caml_make_vect(len,a1[1]),
       a1_index=[0,0],
       a2_index=[0,0],
       _D2_=len - 1 | 0,
       _D1_=0;
      if(_D2_ >= 0)
       {var i=_D1_;
        for(;;)
         {var
           use_a1=
            l1 === a1_index[1]
             ?0
             :l2 === a2_index[1]
               ?1
               :caml_call2(compare,a1[1 + a1_index[1]],a2[1 + a2_index[1]])
                 <=
                 0
                 ?1
                 :0;
          if(use_a1)
           {merged[1 + i] = a1[1 + a1_index[1]];
            a1_index[1] = a1_index[1] + 1 | 0}
          else
           {merged[1 + i] = a2[1 + a2_index[1]];
            a2_index[1] = a2_index[1] + 1 | 0}
          var _D3_=i + 1 | 0;
          if(_D2_ !== i){var i=_D3_;continue}
          break}}
      return merged}
    function copy_matrix(_D0_){return map(_D0_,copy)}
    function folding_map$1(t,init,f)
     {var acc=[0,init];
      return map
              (t,
               function(x)
                {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_map$0(t,init,f)
     {var
       acc=[0,init],
       result=
        map
         (t,
          function(x)
           {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function fold_result$3(t,init,f){return fold_result(fold,init,f,t)}
    function fold_until$3(t,init,f)
     {return function(_DZ_){return fold_until(fold,init,f,_DZ_,t)}}
    function count$3(t,f){return count(fold,t,f)}
    function sum$3(m,t,f){return caml_call2(sum(fold,m),t,f)}
    function min_elt$3(t,compare){return min_elt(fold,t,compare)}
    function max_elt$3(t,compare){return max_elt(fold,t,compare)}
    function foldi$2(t,init,f)
     {var acc=[0,init],_DX_=t.length - 1 - 1 | 0,_DW_=0;
      if(_DX_ >= 0)
       {var i=_DW_;
        for(;;)
         {acc[1] = caml_call3(f,i,acc[1],t[1 + i]);
          var _DY_=i + 1 | 0;
          if(_DX_ !== i){var i=_DY_;continue}
          break}}
      return acc[1]}
    function folding_mapi$1(t,init,f)
     {var acc=[0,init];
      return mapi
              (t,
               function(i,x)
                {var
                  match=caml_call3(f,i,acc[1],x),
                  y=match[2],
                  new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_mapi$0(t,init,f)
     {var
       acc=[0,init],
       result=
        mapi
         (t,
          function(i,x)
           {var match=caml_call3(f,i,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function counti$2(t,f)
     {return foldi$2
              (t,
               0,
               function(idx,count,a)
                {return caml_call2(f,idx,a)?count + 1 | 0:count})}
    function concat_map$0(t,f)
     {return caml_call1(concat,caml_call1(to_list,map(t,f)))}
    function concat_mapi$1(t,f)
     {return caml_call1(concat,caml_call1(to_list,mapi(t,f)))}
    function rev_inplace(t)
     {var i=[0,0],j=[0,t.length - 1 - 1 | 0];
      for(;;){if(i[1] >= j[1])return 0;swap(t,i[1],j[1]);incr(i);decr(j)}}
    function rev$0(t){var t$0=caml_call1(copy,t);rev_inplace(t$0);return t$0}
    function of_list_rev(l)
     {if(! l)return [0];
      var
       l$0=l[2],
       a=l[1],
       len=1 + caml_call1(length,l$0) | 0,
       t=caml_make_vect(len,a),
       r=[0,l$0],
       _DT_=len - 2 | 0;
      if(_DT_ >= 0)
       {var i=_DT_;
        for(;;)
         {var _DU_=r[1];
          if(! _DU_)throw [0,Assert_failure$0,_bj_];
          var l$1=_DU_[2],a$0=_DU_[1];
          caml_check_bound(t,i)[1 + i] = a$0;
          r[1] = l$1;
          var _DV_=i - 1 | 0;
          if(0 !== i){var i=_DV_;continue}
          break}}
      return t}
    function of_list_map(xs,f)
     {if(! xs)return [0];
      var
       tl=xs[2],
       hd=xs[1],
       _DS_=caml_call1(f,hd),
       a=caml_make_vect(1 + caml_call1(length,tl) | 0,_DS_),
       i=1,
       param=tl;
      for(;;)
       {if(! param)return a;
        var tl$0=param[2],hd$0=param[1];
        a[1 + i] = caml_call1(f,hd$0);
        var i$0=i + 1 | 0,i=i$0,param=tl$0}}
    function of_list_mapi(xs,f)
     {if(! xs)return [0];
      var
       tl=xs[2],
       hd=xs[1],
       _DR_=caml_call2(f,0,hd),
       a=caml_make_vect(1 + caml_call1(length,tl) | 0,_DR_),
       i=1,
       param=tl;
      for(;;)
       {if(! param)return a;
        var tl$0=param[2],hd$0=param[1];
        a[1 + i] = caml_call2(f,i,hd$0);
        var i$0=i + 1 | 0,i=i$0,param=tl$0}}
    function of_list_rev_map(xs,f)
     {var t=of_list_map(xs,f);rev_inplace(t);return t}
    function of_list_rev_mapi(xs,f)
     {var t=of_list_mapi(xs,f);rev_inplace(t);return t}
    function filter_mapi$1(t,f)
     {var r=[0,[0]],k=[0,0],_DP_=t.length - 1 - 1 | 0,_DO_=0;
      if(_DP_ >= 0)
       {var i=_DO_;
        for(;;)
         {var match=caml_call2(f,i,t[1 + i]);
          if(match)
           {var a=match[1];
            if(0 === k[1])r[1] = caml_make_vect(t.length - 1,a);
            r[1][1 + k[1]] = a;
            incr(k)}
          var _DQ_=i + 1 | 0;
          if(_DP_ !== i){var i=_DQ_;continue}
          break}}
      return k[1] === t.length - 1
              ?r[1]
              :0 < k[1]?caml_call3(sub$0,r[1],0,k[1]):[0]}
    function filter_map$1(t,f)
     {return filter_mapi$1(t,function(i,a){return caml_call1(f,a)})}
    function filter_opt$1(t)
     {return filter_map$1(t,function(_DN_){return _DN_})}
    function check_length2_exn$0(name,t1,t2)
     {var n1=t1.length - 1,n2=t2.length - 1,_DM_=n1 !== n2?1:0;
      return _DM_?caml_call4(invalid_argf(_bk_),name,n1,n2,0):_DM_}
    function iter2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_iter2_exn,t1,t2);
      return iteri(t1,function(i,x1){return caml_call2(f,x1,t2[1 + i])})}
    function map2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_map2_exn,t1,t2);
      return caml_call2
              (init,
               t1.length - 1,
               function(i){return caml_call2(f,t1[1 + i],t2[1 + i])})}
    function fold2_exn$0(t1,t2,init,f)
     {check_length2_exn$0(cst_Array_fold2_exn,t1,t2);
      return foldi$2
              (t1,init,function(i,ac,x){return caml_call3(f,ac,x,t2[1 + i])})}
    function filter$2(t,f)
     {return filter_map$1(t,function(x){return caml_call1(f,x)?[0,x]:0})}
    function filteri$1(t,f)
     {return filter_mapi$1(t,function(i,x){return caml_call2(f,i,x)?[0,x]:0})}
    function exists$3(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call1(f,t[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function existsi$2(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call2(f,i[1],t[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function mem$3(t,a,equal){return exists$3(t,caml_call1(equal,a))}
    function for_all$3(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call1(f,t[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function for_alli$2(t,f)
     {var length=t.length - 1,i=[0,length - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call2(f,i[1],t[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function exists2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_exists2_exn,t1,t2);
      var i=[0,t1.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call2(f,t1[1 + i[1]],t2[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function for_all2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_for_all2_exn,t1,t2);
      var i=[0,t1.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call2(f,t1[1 + i[1]],t2[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function equal_array$1(equal,t1,t2)
     {var _DL_=t1.length - 1 === t2.length - 1?1:0;
      return _DL_?for_all2_exn$0(t1,t2,equal):_DL_}
    function map_inplace(t,f)
     {var _DJ_=t.length - 1 - 1 | 0,_DI_=0;
      if(_DJ_ >= 0)
       {var i=_DI_;
        for(;;)
         {t[1 + i] = caml_call1(f,t[1 + i]);
          var _DK_=i + 1 | 0;
          if(_DJ_ !== i){var i=_DK_;continue}
          break}}
      return 0}
    function findi_internal(t,f,if_found,if_not_found)
     {var length=t.length - 1;
      if(0 === length)return caml_call1(if_not_found,0);
      var i=[0,0],found=[0,0],value_found=[0,t[1]];
      for(;;)
       {if(! found[1] && i[1] < length)
         {var value=t[1 + i[1]];
          if(caml_call2(f,i[1],value))
           {value_found[1] = value;found[1] = 1}
          else
           incr(i);
          continue}
        return found[1]
                ?caml_call2(if_found,i[1],value_found[1])
                :caml_call1(if_not_found,0)}}
    function findi$2(t,f)
     {function _DH_(param){return 0}
      return findi_internal
              (t,f,function(i,value){return [0,[0,i,value]]},_DH_)}
    function findi_exn$0(t,f)
     {function _DG_(param){throw [0,Not_found_s,_bl_]}
      return findi_internal(t,f,function(i,value){return [0,i,value]},_DG_)}
    function find_exn$2(t,f)
     {function _DE_(param){throw [0,Not_found_s,_bm_]}
      function _DF_(param,value){return value}
      return findi_internal(t,function(i,x){return caml_call1(f,x)},_DF_,_DE_)}
    function find$4(t,f)
     {function _DD_(param){var x=param[2];return x}
      return caml_call2
              (map$16,findi$2(t,function(i,x){return caml_call1(f,x)}),_DD_)}
    function find_map$3(t,f)
     {var length=t.length - 1;
      if(0 === length)return 0;
      var i=[0,0],value_found=[0,0];
      for(;;)
       {if(is_none(value_found[1]) && i[1] < length)
         {var value=t[1 + i[1]];
          value_found[1] = caml_call1(f,value);
          incr(i);
          continue}
        return value_found[1]}}
    var not_found$4=[0,Not_found_s,_bn_];
    function find_map_exn$0(t,f)
     {var match=find_map$3(t,f);
      if(! match)throw not_found$4;
      var x=match[1];
      return x}
    function find_mapi$2(t,f)
     {var length=t.length - 1;
      if(0 === length)return 0;
      var i=[0,0],value_found=[0,0];
      for(;;)
       {if(is_none(value_found[1]) && i[1] < length)
         {var value=t[1 + i[1]];
          value_found[1] = caml_call2(f,i[1],value);
          incr(i);
          continue}
        return value_found[1]}}
    var not_found$5=[0,Not_found_s,_bo_];
    function find_mapi_exn$0(t,f)
     {var match=find_mapi$2(t,f);
      if(! match)throw not_found$5;
      var x=match[1];
      return x}
    function find_consecutive_duplicate$1(t,equal)
     {var n=t.length - 1;
      if(1 >= n)return 0;
      var result=[0,0],i=[0,1],prev=[0,t[1]];
      for(;;)
       {if(i[1] >= n)return result[1];
        var cur=t[1 + i[1]];
        if(caml_call2(equal,cur,prev[1]))
         {result[1] = [0,[0,prev[1],cur]];i[1] = n}
        else
         {prev[1] = cur;incr(i)}}}
    function reduce$1(t,f)
     {if(0 === t.length - 1)return 0;
      var r=[0,t[1]],_DB_=t.length - 1 - 1 | 0,_DA_=1;
      if(_DB_ >= 1)
       {var i=_DA_;
        for(;;)
         {r[1] = caml_call2(f,r[1],t[1 + i]);
          var _DC_=i + 1 | 0;
          if(_DB_ !== i){var i=_DC_;continue}
          break}}
      return [0,r[1]]}
    function reduce_exn$1(t,f)
     {var match=reduce$1(t,f);
      if(! match)return caml_call1(invalid_arg$0,cst_Array_reduce_exn);
      var v=match[1];
      return v}
    function random_element_exn$0(opt,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(is_empty$2(t))
       return caml_call1(failwith$0,cst_Array_random_element_exn_e);
      var _Dz_=caml_call2(_ag_[6],random_state,t.length - 1);
      return caml_check_bound(t,_Dz_)[1 + _Dz_]}
    function random_element$0(opt,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      try
       {var _Dx_=[0,random_element_exn$0([0,random_state],t)];return _Dx_}
      catch(_Dy_){return 0}}
    function zip$1(t1,t2)
     {return t1.length - 1 !== t2.length - 1
              ?0
              :[0,map2_exn$0(t1,t2,function(x1,x2){return [0,x1,x2]})]}
    function zip_exn$0(t1,t2)
     {return t1.length - 1 !== t2.length - 1
              ?caml_call1(failwith$0,cst_Array_zip_exn)
              :map2_exn$0(t1,t2,function(x1,x2){return [0,x1,x2]})}
    function unzip$1(t)
     {var n=t.length - 1;
      if(0 === n)return [0,[0],[0]];
      var
       match=caml_check_bound(t,0)[1],
       y=match[2],
       x=match[1],
       res1=caml_make_vect(n,x),
       res2=caml_make_vect(n,y),
       _Dv_=n - 1 | 0,
       _Du_=1;
      if(_Dv_ >= 1)
       {var i=_Du_;
        for(;;)
         {var
           match$0=caml_check_bound(t,i)[1 + i],
           y$0=match$0[2],
           x$0=match$0[1];
          caml_check_bound(res1,i)[1 + i] = x$0;
          caml_check_bound(res2,i)[1 + i] = y$0;
          var _Dw_=i + 1 | 0;
          if(_Dv_ !== i){var i=_Dw_;continue}
          break}}
      return [0,res1,res2]}
    function sorted_copy(t,compare)
     {var t1=caml_call1(copy,t);sort$3(0,0,t1,compare);return t1}
    function partitioni_tf(t,f)
     {var
       both=mapi(t,function(i,x){return caml_call2(f,i,x)?[0,x]:[1,x]}),
       trues=
        filter_map$1
         (both,
          function(param)
           {if(0 !== param[0])return 0;var x=param[1];return [0,x]}),
       falses=
        filter_map$1
         (both,
          function(param)
           {if(0 === param[0])return 0;var x=param[1];return [0,x]});
      return [0,trues,falses]}
    function partition_tf$0(t,f)
     {return partitioni_tf(t,function(i,x){return caml_call1(f,x)})}
    function last$0(t)
     {var _Dt_=t.length - 1 - 1 | 0;return caml_check_bound(t,_Dt_)[1 + _Dt_]}
    function to_sequence_mutable(t)
     {return [0,
              0,
              function(i)
               {return t.length - 1 <= i
                        ?0
                        :[1,caml_check_bound(t,i)[1 + i],i + 1 | 0]}]}
    function to_sequence(t){return to_sequence_mutable(caml_call1(copy,t))}
    function cartesian_product$1(t1,t2)
     {if(! is_empty$2(t1) && ! is_empty$2(t2))
       {var
         n1=t1.length - 1,
         n2=t2.length - 1,
         _Dj_=caml_check_bound(t2,0)[1],
         t=caml_make_vect(caml_mul(n1,n2),[0,caml_check_bound(t1,0)[1],_Dj_]),
         r=[0,0],
         _Dl_=n1 - 1 | 0,
         _Dk_=0;
        if(_Dl_ >= 0)
         {var i1=_Dk_;
          for(;;)
           {var _Dn_=n2 - 1 | 0,_Dm_=0;
            if(_Dn_ >= 0)
             {var i2=_Dm_;
              for(;;)
               {var
                 _Dp_=caml_check_bound(t2,i2)[1 + i2],
                 _Dq_=[0,caml_check_bound(t1,i1)[1 + i1],_Dp_],
                 _Dr_=r[1];
                caml_check_bound(t,_Dr_)[1 + _Dr_] = _Dq_;
                incr(r);
                var _Ds_=i2 + 1 | 0;
                if(_Dn_ !== i2){var i2=_Ds_;continue}
                break}}
            var _Do_=i1 + 1 | 0;
            if(_Dl_ !== i1){var i1=_Do_;continue}
            break}}
        return t}
      return [0]}
    function transpose$0(tt)
     {if(0 === tt.length - 1)return [0,[0]];
      var width=tt.length - 1,depth=caml_check_bound(tt,0)[1].length - 1;
      return exists$3(tt,function(t){return t.length - 1 !== depth?1:0})
              ?0
              :[0,
                caml_call2
                 (init,
                  depth,
                  function(d)
                   {return caml_call2
                            (init,
                             width,
                             function(w)
                              {return caml_check_bound(caml_check_bound(tt,w)[1 + w],d)
                                       [1 + d]})})]}
    function transpose_exn$0(tt)
     {var match=transpose$0(tt);
      if(! match)return caml_call1(invalid_arg$0,cst_Array_transpose_exn);
      var tt$0=match[1];
      return tt$0}
    function get$1(_Di_,_Dh_){return caml_check_bound(_Di_,_Dh_)[1 + _Dh_]}
    function length$3(_Dg_){return _Dg_.length - 1}
    var
     include$39=_a2_([0,get$1,length$3]),
     binary_search$0=include$39[1],
     binary_search_segmented$0=include$39[2];
    function length$4(_Df_){return _Df_.length - 1}
    function create_like(len,t)
     {if(0 === len)return [0];
      if(0 < t.length - 1)return caml_make_vect(len,caml_check_bound(t,0)[1]);
      throw [0,Assert_failure$0,_bp_]}
    var
     unsafe_blit$1=runtime.caml_array_blit,
     include$40=_a4_([0,create_like,length$4,unsafe_blit$1]),
     blit$1=include$40[1],
     blito=include$40[2],
     unsafe_blit$2=include$40[3],
     sub$5=include$40[4],
     subo=include$40[5];
    function invariant$8(invariant_a,t){return iter(t,invariant_a)}
    var
     Base_Array=
      [0,
       compare_array$0,
       array_of_sexp,
       sexp_of_array,
       t_sexp_grammar$20,
       binary_search$0,
       binary_search_segmented$0,
       mem$3,
       is_empty$2,
       iter,
       fold,
       fold_result$3,
       fold_until$3,
       exists$3,
       for_all$3,
       count$3,
       sum$3,
       find$4,
       find_map$3,
       to_list,
       to_array$2,
       min_elt$3,
       max_elt$3,
       invariant$8,
       max_length$0,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit$1,
       blito,
       unsafe_blit$2,
       sub$5,
       subo,
       of_list,
       map,
       folding_map$1,
       folding_mapi$1,
       fold_map$0,
       fold_mapi$0,
       iteri,
       mapi,
       foldi$2,
       fold_right,
       sort$3,
       stable_sort,
       is_sorted$0,
       is_sorted_strictly$0,
       merge$1,
       concat_map$0,
       concat_mapi$1,
       partition_tf$0,
       partitioni_tf,
       cartesian_product$1,
       transpose$0,
       transpose_exn$0,
       filter_opt$1,
       filter_map$1,
       filter_mapi$1,
       for_alli$2,
       existsi$2,
       counti$2,
       iter2_exn$0,
       map2_exn$0,
       fold2_exn$0,
       for_all2_exn$0,
       exists2_exn$0,
       filter$2,
       filteri$1,
       swap,
       rev_inplace,
       rev$0,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn$2,
       find_map_exn$0,
       findi$2,
       findi_exn$0,
       find_mapi$2,
       find_mapi_exn$0,
       find_consecutive_duplicate$1,
       reduce$1,
       reduce_exn$1,
       permute,
       random_element$0,
       random_element_exn$0,
       zip$1,
       zip_exn$0,
       unzip$1,
       sorted_copy,
       last$0,
       equal_array$1,
       to_sequence,
       to_sequence_mutable,
       [0,[0,Insertion_sort,Heap_sort,Intro_sort]]];
    caml_register_global(1069,Base_Array,"Base__Array");
    function invariant$9(t)
     {var _De_=Stdlib_Obj[15];
      if(caml_obj_tag(t) !== _De_)return 0;
      throw [0,Assert_failure$0,_bq_]}
    function length$5(_Dd_){return _Dd_.length - 1}
    function sexp_of_t$28(t)
     {return [0,
              concat$0
               (_bs_,
                [0,
                 cst_Obj_array_t_of_length,
                 [0,caml_call1(to_string,t.length - 1),_br_]])]}
    function create_zero(len){return caml_make_vect(len,0)}
    var empty$0=[0];
    function get$2(t,i){return caml_check_bound(t,i)[1 + i]}
    function unsafe_get(t,i){return t[1 + i]}
    function unsafe_set_with_caml_modify(t,i,obj){t[1 + i] = obj;return 0}
    function set_with_caml_modify(t,i,obj)
     {caml_check_bound(t,i)[1 + i] = obj;return 0}
    function unsafe_set_int_assuming_curren(t,i,int$0)
     {t[1 + i] = int$0;return 0}
    function set$0(t,i,obj)
     {var old_obj=get$2(t,i);
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      var _Dc_=1 - (old_obj === obj?1:0);
      return _Dc_?unsafe_set_with_caml_modify(t,i,obj):_Dc_}
    function unsafe_set(t,i,obj)
     {var old_obj=t[1 + i];
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      var _Db_=1 - (old_obj === obj?1:0);
      return _Db_?unsafe_set_with_caml_modify(t,i,obj):_Db_}
    function unsafe_set_omit_phys_equal_che(t,i,obj)
     {var old_obj=t[1 + i];
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      return unsafe_set_with_caml_modify(t,i,obj)}
    function swap$2(t,i,j)
     {var a=get$2(t,i),b=get$2(t,j);
      unsafe_set(t,i,b);
      return unsafe_set(t,j,a)}
    function create$3(len,x)
     {var _C9_=Stdlib_Obj[14];
      if(caml_obj_tag(x) !== _C9_)return caml_make_vect(len,x);
      var t=caml_make_vect(len,0),_C$_=len - 1 | 0,_C__=0;
      if(_C$_ >= 0)
       {var i=_C__;
        for(;;)
         {unsafe_set_with_caml_modify(t,i,x);
          var _Da_=i + 1 | 0;
          if(_C$_ !== i){var i=_Da_;continue}
          break}}
      return t}
    function singleton$0(obj){return create$3(1,obj)}
    function unsafe_set_assuming_currently_(t,i,obj)
     {return typeof obj === "number"
              ?unsafe_set_int_assuming_curren(t,i,obj)
              :unsafe_set_with_caml_modify(t,i,obj)}
    function unsafe_set_int(t,i,int$0)
     {var old_obj=t[1 + i];
      return typeof old_obj === "number"
              ?unsafe_set_int_assuming_curren(t,i,int$0)
              :unsafe_set_with_caml_modify(t,i,int$0)}
    function unsafe_clear_if_pointer(t,i)
     {var old_obj=t[1 + i],_C8_=1 - (typeof old_obj === "number"?1:0);
      return _C8_?unsafe_set_with_caml_modify(t,i,0):_C8_}
    function unsafe_blit$3(src,src_pos,dst,dst_pos,len)
     {if(dst_pos < src_pos)
       {var _C4_=len - 1 | 0,_C3_=0;
        if(_C4_ >= 0)
         {var i=_C3_;
          for(;;)
           {unsafe_set(dst,dst_pos + i | 0,src[1 + (src_pos + i | 0)]);
            var _C5_=i + 1 | 0;
            if(_C4_ !== i){var i=_C5_;continue}
            break}}
        return 0}
      var _C6_=len - 1 | 0;
      if(_C6_ >= 0)
       {var i$0=_C6_;
        for(;;)
         {unsafe_set(dst,dst_pos + i$0 | 0,src[1 + (src_pos + i$0 | 0)]);
          var _C7_=i$0 - 1 | 0;
          if(0 !== i$0){var i$0=_C7_;continue}
          break}}
      return 0}
    var
     include$41=_a6_([0,length$5,create_zero,unsafe_blit$3]),
     blit$2=include$41[1],
     blito$0=include$41[2],
     unsafe_blit$4=include$41[3],
     sub$6=include$41[4],
     subo$0=include$41[5];
    function copy$3(src)
     {var dst=caml_make_vect(src.length - 1,0);
      caml_call6(blito$0,src,0,0,dst,0,0);
      return dst}
    var
     Base_Obj_array=
      [0,
       sexp_of_t$28,
       blit$2,
       blito$0,
       unsafe_blit$4,
       sub$6,
       subo$0,
       invariant$9,
       create$3,
       create_zero,
       copy$3,
       singleton$0,
       empty$0,
       length$5,
       get$2,
       unsafe_get,
       set$0,
       unsafe_set,
       swap$2,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
    caml_register_global(1071,Base_Obj_array,"Base__Obj_array");
    function unsafe_create_uninitialized(len){return caml_make_vect(len,0)}
    function create_obj_array(len){return caml_make_vect(len,0)}
    function create$4(len,x){return create$3(len,x)}
    function singleton$1(x){return singleton$0(x)}
    function swap$3(t,i,j){return swap$2(t,i,j)}
    function get$3(arr,i){return get$2(arr,i)}
    function set$1(arr,i,x){return set$0(arr,i,x)}
    function unsafe_get$0(arr,i){return arr[1 + i]}
    function unsafe_set$0(arr,i,x){return unsafe_set(arr,i,x)}
    function unsafe_set_int$0(arr,i,x){return unsafe_set_int(arr,i,x)}
    function unsafe_set_int_assuming_curren$0(arr,i,x)
     {return unsafe_set_int_assuming_curren(arr,i,x)}
    function unsafe_set_assuming_currently_$0(arr,i,x)
     {return unsafe_set_assuming_currently_(arr,i,x)}
    function unsafe_set_omit_phys_equal_che$0(t,i,x)
     {return unsafe_set_omit_phys_equal_che(t,i,x)}
    function unsafe_set_with_caml_modify$0(t,i,x)
     {return unsafe_set_with_caml_modify(t,i,x)}
    function set_with_caml_modify$0(t,i,x){return set_with_caml_modify(t,i,x)}
    function invariant$10(t)
     {var _C2_=Stdlib_Obj[15];
      if(caml_obj_tag(t) !== _C2_)return 0;
      throw [0,Assert_failure$0,_bt_]}
    function init$3(l,f)
     {if(0 > l)return caml_call1(invalid_arg$0,cst_Uniform_array_init);
      var res=caml_make_vect(l,0),_C0_=l - 1 | 0,_CZ_=0;
      if(_C0_ >= 0)
       {var i=_CZ_;
        for(;;)
         {unsafe_set$0(res,i,caml_call1(f,i));
          var _C1_=i + 1 | 0;
          if(_C0_ !== i){var i=_C1_;continue}
          break}}
      return res}
    function of_array(arr)
     {return init$3(arr.length - 1,function(_CY_){return arr[1 + _CY_]})}
    function map$22(a,f)
     {return init$3(a.length - 1,function(i){return caml_call1(f,a[1 + i])})}
    function mapi$3(a,f)
     {return init$3(a.length - 1,function(i){return caml_call2(f,i,a[1 + i])})}
    function iter$6(a,f)
     {var _CW_=a.length - 1 - 1 | 0,_CV_=0;
      if(_CW_ >= 0)
       {var i=_CV_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _CX_=i + 1 | 0;
          if(_CW_ !== i){var i=_CX_;continue}
          break}}
      return 0}
    function iteri$3(a,f)
     {var _CT_=a.length - 1 - 1 | 0,_CS_=0;
      if(_CT_ >= 0)
       {var i=_CS_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _CU_=i + 1 | 0;
          if(_CT_ !== i){var i=_CU_;continue}
          break}}
      return 0}
    function foldi$3(a,init,f)
     {var acc=[0,init],_CQ_=a.length - 1 - 1 | 0,_CP_=0;
      if(_CQ_ >= 0)
       {var i=_CP_;
        for(;;)
         {acc[1] = caml_call3(f,i,acc[1],a[1 + i]);
          var _CR_=i + 1 | 0;
          if(_CQ_ !== i){var i=_CR_;continue}
          break}}
      return acc[1]}
    function to_list$4(t)
     {return init$1(t.length - 1,function(_CO_){return get$3(t,_CO_)})}
    function of_list$2(l)
     {var len=caml_call1(length,l),res=caml_make_vect(len,0);
      iteri$0(l,function(i,x){return set$1(res,i,x)});
      return res}
    function to_array$3(t)
     {return caml_call2(init,t.length - 1,function(i){return t[1 + i]})}
    function exists$4(t,f)
     {var i$1=t.length - 1 - 1 | 0,i=i$1;
      for(;;)
       {if(0 > i)return 0;
        var _CN_=caml_call1(f,t[1 + i]);
        if(_CN_)return _CN_;
        var i$0=i - 1 | 0,i=i$0}}
    function for_all$4(t,f)
     {var i$1=t.length - 1 - 1 | 0,i=i$1;
      for(;;)
       {if(0 > i)return 1;
        var _CM_=caml_call1(f,t[1 + i]);
        if(! _CM_)return _CM_;
        var i$0=i - 1 | 0,i=i$0}}
    function map2_exn$1(t1,t2,f)
     {var len=t1.length - 1;
      if(t2.length - 1 !== len)caml_call1(invalid_arg$0,cst_Array_map2_exn$0);
      return init$3(len,function(i){return caml_call2(f,t1[1 + i],t2[1 + i])})}
    function t_sexp_grammar$21(grammar)
     {var _CL_=t_sexp_grammar$20(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_CL_)}
    var
     include$90=
      Of_sexpable1([0,array_of_sexp,sexp_of_array],[0,to_array$3,of_array]),
     t_of_sexp$19=include$90[1],
     sexp_of_t$29=include$90[2];
    function create_like$0(len,t)
     {if(0 === len)return empty$0;
      if(0 < t.length - 1)return create$4(len,get$3(t,0));
      throw [0,Assert_failure$0,_bu_]}
    var
     include$42=_a4_([0,create_like$0,length$5,unsafe_blit$4]),
     blit$3=include$42[1],
     blito$1=include$42[2],
     unsafe_blit$5=include$42[3],
     sub$7=include$42[4],
     subo$1=include$42[5];
    function fold$2(t,init,f)
     {var r=[0,init],_CJ_=t.length - 1 - 1 | 0,_CI_=0;
      if(_CJ_ >= 0)
       {var i=_CI_;
        for(;;)
         {r[1] = caml_call2(f,r[1],t[1 + i]);
          var _CK_=i + 1 | 0;
          if(_CJ_ !== i){var i=_CK_;continue}
          break}}
      return r[1]}
    function min_elt$4(t,compare){return min_elt(fold$2,t,compare)}
    function max_elt$4(t,compare){return max_elt(fold$2,t,compare)}
    function compare$31(compare_elt,a,b)
     {if(a === b)return 0;
      var
       len_a=a.length - 1,
       len_b=b.length - 1,
       ret=caml_int_compare(len_a,len_b);
      if(0 !== ret)return ret;
      var i=0;
      for(;;)
       {if(i === len_a)return 0;
        var l=a[1 + i],r=b[1 + i],res=caml_call2(compare_elt,l,r);
        if(0 !== res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    var
     Base_Uniform_array=
      [0,
       t_of_sexp$19,
       sexp_of_t$29,
       t_sexp_grammar$21,
       compare$31,
       invariant$10,
       empty$0,
       create$4,
       singleton$1,
       init$3,
       length$5,
       get$3,
       unsafe_get$0,
       set$1,
       unsafe_set$0,
       swap$3,
       unsafe_set_omit_phys_equal_che$0,
       unsafe_set_with_caml_modify$0,
       set_with_caml_modify$0,
       map$22,
       mapi$3,
       iter$6,
       iteri$3,
       foldi$3,
       of_array,
       to_array$3,
       of_list$2,
       to_list$4,
       blit$3,
       blito$1,
       unsafe_blit$5,
       sub$7,
       subo$1,
       copy$3,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_$0,
       unsafe_set_int_assuming_curren$0,
       unsafe_set_int$0,
       unsafe_clear_if_pointer,
       exists$4,
       for_all$4,
       map2_exn$1,
       min_elt$4,
       max_elt$4];
    caml_register_global(1073,Base_Uniform_array,"Base__Uniform_array");
    var
     succ$0=Stdlib_Uchar[5],
     pred=Stdlib_Uchar[6],
     is_valid=Stdlib_Uchar[7],
     is_char=Stdlib_Uchar[11],
     unsafe_to_char=Stdlib_Uchar[14],
     unsafe_of_int$0=Stdlib_Uchar[9],
     of_int$1=Stdlib_Uchar[8],
     to_int$2=Stdlib_Uchar[10],
     of_char=Stdlib_Uchar[12],
     compare$32=Stdlib_Uchar[16],
     equal$20=Stdlib_Uchar[15],
     min_value$1=Stdlib_Uchar[1],
     max_value$1=Stdlib_Uchar[2],
     include$43=
      [0,
       succ$0,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int$0,
       of_int$1,
       to_int$2,
       of_char,
       compare$32,
       equal$20,
       min_value$1,
       max_value$1];
    caml_register_global(1074,include$43,"Base__Uchar0");
    var Base_Floatable=[0];
    caml_register_global(1075,Base_Floatable,"Base__Floatable");
    function ceil(_CH_){return Math.ceil(_CH_)}
    function floor(_CG_){return Math.floor(_CG_)}
    function mod_float(_CF_,_CE_){return _CF_ % _CE_}
    var
     modf=runtime.caml_modf_float,
     float_of_string$0=caml_float_of_string,
     nan$1=Caml$0[23],
     infinity$1=Caml$0[21],
     neg_infinity$1=Caml$0[22],
     max_finite_value=Caml$0[24],
     epsilon_float$1=Caml$0[26],
     classify_float=caml_classify_float;
    function abs_float(_CD_){return Math.abs(_CD_)}
    var is_integer=Stdlib_Float[16];
    function symbol$84(_CC_,_CB_){return Math.pow(_CC_,_CB_)}
    function symbol$85(a,b)
     {if(caml_call2(include$7[1],b,0.))caml_call3(invalid_argf(_bv_),a,b,0);
      var m=a % b;
      return caml_call2(include$7[1],m,0.)?m + b:m}
    var frexp=runtime.caml_frexp_float,ldexp=runtime.caml_ldexp_float;
    function is_nan(x){return caml_call2(include$7[3],x,x)}
    function to_int64_preserve_order(t)
     {return is_nan(t)
              ?0
              :caml_call2(include$7[4],t,0.)
                ?_bw_
                :caml_call2(include$7[5],t,0.)
                  ?[0,caml_int64_bits_of_float(t)]
                  :[0,caml_int64_neg(caml_int64_bits_of_float(- t))]}
    function to_int64_preserve_order_exn(x)
     {return value_exn(0,0,0,to_int64_preserve_order(x))}
    function of_int64_preserve_order(x)
     {return caml_greaterequal(x,_bx_)
              ?caml_int64_float_of_bits(x)
              :- caml_int64_float_of_bits(caml_int64_neg(x))}
    function one_ulp(dir,t)
     {var match=to_int64_preserve_order(t);
      if(! match)return Caml$0[23];
      var x=match[1],_CA_=759637122 <= dir?_by_:_bz_;
      return of_int64_preserve_order(caml_int64_add(x,_CA_))}
    function upper_bound_for_int(num_bits)
     {var exp=num_bits - 1 | 0;return one_ulp(759637122,Math.pow(2.,exp))}
    function is_x_minus_one_exact(x)
     {return 1
             -
             caml_equal
              (caml_int64_bits_of_float(x),caml_int64_bits_of_float(x - 1.))}
    function lower_bound_for_int(num_bits)
     {var exp=num_bits - 1 | 0,min_int_as_float=- Math.pow(2.,exp);
      if(53 <= (num_bits - 1 | 0))
       {if(is_x_minus_one_exact(min_int_as_float))
         throw [0,Assert_failure$0,_bA_];
        return min_int_as_float}
      if(is_x_minus_one_exact(min_int_as_float))
       return one_ulp(19067,min_int_as_float - 1.);
      throw [0,Assert_failure$0,_bB_]}
    function clamp_unchecked(t,min,max)
     {return caml_call2(include$7[1],t,min)
              ?min
              :caml_call2(include$7[1],max,t)?max:t}
    function box(f){return f + 0.}
    var
     symbol$86=include$7[1],
     symbol$87=include$7[2],
     symbol$88=include$7[3],
     symbol$89=include$7[4],
     symbol$90=include$7[5],
     symbol$91=include$7[6],
     ascending$12=include$7[7],
     descending$12=include$7[8],
     compare$33=include$7[9],
     equal$21=include$7[10],
     max$15=include$7[11],
     min$15=include$7[12],
     include$44=
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string$0,
       nan$1,
       infinity$1,
       neg_infinity$1,
       max_finite_value,
       epsilon_float$1,
       classify_float,
       abs_float,
       is_integer,
       symbol$84,
       symbol$85,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$86,
       symbol$87,
       symbol$88,
       symbol$89,
       symbol$90,
       symbol$91,
       ascending$12,
       descending$12,
       compare$33,
       equal$21,
       max$15,
       min$15];
    caml_register_global(1077,include$44,"Base__Float0");
    function hash$7(x){return caml_call1(func$2,x)}
    function to_string$7(t){return caml_call2(make$1,1,t)}
    function of_string$6(s)
     {var match=caml_ml_string_length(s);
      return 1 === match?caml_string_get(s,0):caml_call2(failwithf(_bC_),s,0)}
    var
     include$45=
      _a1_
       ([0,
         compare$9,
         hash_fold_t$3,
         hash$7,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$6,
         to_string$7,
         module_name$4]),
     _bD_=include$45[1],
     _bE_=include$45[2],
     _bF_=include$45[3],
     _bG_=include$45[4],
     _bH_=include$45[5],
     _bI_=include$45[6],
     _bJ_=include$45[19],
     _bK_=include$45[20],
     _bL_=include$45[21],
     _bM_=include$45[22],
     _bN_=include$45[24];
    function pp$6(fmt,c){return caml_call3(Stdlib_Format[129],fmt,_bO_,c)}
    function invariant$11(param){return 0}
    var all$13=caml_call1(to_list,caml_call2(init,256,unsafe_of_int));
    function is_lowercase(param){return 25 < param - 97 >>> 0?0:1}
    function is_uppercase(param){return 25 < param - 65 >>> 0?0:1}
    function is_print(param){return 94 < param - 32 >>> 0?0:1}
    function is_whitespace(param)
     {var switch$0=0;
      if(14 <= param)
       {if(32 === param)switch$0 = 1}
      else
       if(9 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_digit(param){return 9 < param - 48 >>> 0?0:1}
    function is_alpha(param)
     {var switch$0=0;
      if(91 <= param)
       {if(25 >= param - 97 >>> 0)switch$0 = 1}
      else
       if(65 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_alphanum(param)
     {var _Cz_=param - 48 | 0,switch$0=0;
      if(42 < _Cz_ >>> 0)
       {if(25 >= _Cz_ - 49 >>> 0)switch$0 = 1}
      else
       if(6 < _Cz_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function get_digit_exn(t)
     {return is_digit(t)?t - 48 | 0:caml_call2(failwithf(_bP_),t,0)}
    function get_digit(t){return is_digit(t)?[0,t - 48 | 0]:0}
    function is_hex_digit(param)
     {var _Cy_=param - 48 | 0,switch$0=0;
      if(22 < _Cy_ >>> 0)
       {if(5 >= _Cy_ - 49 >>> 0)switch$0 = 1}
      else
       if(6 < _Cy_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function is_hex_digit_lower(param)
     {var switch$0=0;
      if(58 <= param)
       {if(5 >= param - 97 >>> 0)switch$0 = 1}
      else
       if(48 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_hex_digit_upper(param)
     {var switch$0=0;
      if(58 <= param)
       {if(5 >= param - 65 >>> 0)switch$0 = 1}
      else
       if(48 <= param)switch$0 = 1;
      return switch$0?1:0}
    function get_hex_digit_exn(t)
     {if(65 <= t)
       {if(97 <= t)
         {if(103 > t)return (t - 97 | 0) + 10 | 0}
        else
         if(71 > t)return (t - 65 | 0) + 10 | 0}
      else
       if(9 >= t - 48 >>> 0)return t - 48 | 0;
      return raise_s
              (caml_call2
                (message,
                 cst_Char_get_hex_digit_exn_not,
                 [0,[0,cst_char,caml_call1(_bG_,t)],0]))}
    function get_hex_digit(t)
     {return is_hex_digit(t)?[0,get_hex_digit_exn(t)]:0}
    var
     symbol$92=include$5[6],
     symbol$93=include$5[2],
     symbol$94=include$5[4],
     symbol$95=include$5[5],
     symbol$96=include$5[1],
     symbol$97=include$5[3],
     O=[0,symbol$92,symbol$93,symbol$94,symbol$95,symbol$96,symbol$97];
    function compare$34(c1,c2)
     {var _Cw_=caml_call1(_e_,c2),_Cx_=caml_call1(_e_,c1);
      return caml_call2(include$5[9],_Cx_,_Cw_)}
    function hash_fold_t$20(state,t)
     {return caml_call2(hash_fold_t$3,state,caml_call1(_e_,t))}
    function hash$8(t){return run(0,hash_fold_t$20,t)}
    var
     include$46=Make$1([0,compare$34,sexp_of_t$3]),
     symbol$98=include$46[1],
     symbol$99=include$46[2],
     symbol$100=include$46[3],
     symbol$101=include$46[4],
     symbol$102=include$46[5],
     symbol$103=include$46[6],
     equal$22=include$46[7],
     compare$35=include$46[8],
     min$16=include$46[9],
     max$16=include$46[10],
     ascending$13=include$46[11],
     descending$13=include$46[12],
     between$0=include$46[13],
     clamp_exn$0=include$46[14],
     clamp$0=include$46[15],
     comparator$2=include$46[16],
     symbol$104=include$5[1],
     symbol$105=include$5[2],
     symbol$106=include$5[3],
     symbol$107=include$5[4],
     symbol$108=include$5[5],
     symbol$109=include$5[6],
     ascending$14=include$5[7],
     descending$14=include$5[8],
     compare_char$0=include$5[9],
     equal_char$1=include$5[10],
     max$17=include$5[11],
     min$17=include$5[12],
     _bQ_=
      [0,
       hash_fold_t$20,
       hash$8,
       t_of_sexp$3,
       sexp_of_t$3,
       t_sexp_grammar$2,
       symbol$98,
       symbol$99,
       symbol$100,
       symbol$101,
       symbol$102,
       symbol$103,
       equal$22,
       compare$35,
       min$16,
       max$16,
       ascending$13,
       descending$13,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$2],
     Base_Char=
      [0,
       all$13,
       t_sexp_grammar$2,
       _bD_,
       _bE_,
       _bF_,
       _bG_,
       _bH_,
       _bI_,
       symbol$109,
       symbol$105,
       symbol$107,
       symbol$108,
       symbol$104,
       symbol$106,
       equal_char$1,
       compare_char$0,
       min$17,
       max$17,
       ascending$14,
       descending$14,
       _bJ_,
       _bK_,
       _bL_,
       _bM_,
       pp$6,
       _bN_,
       invariant$11,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       _d_,
       _e_,
       _f_,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       _bQ_];
    caml_register_global(1078,Base_Char,"Base__Char");
    var Enumerable=[0],Base_Ppx_enumerate_lib=[0,Enumerable];
    caml_register_global
     (1079,Base_Ppx_enumerate_lib,"Base__Ppx_enumerate_lib");
    function tr_create_map(target,replacement)
     {var tr_map=caml_create_bytes(256),i$3=0;
      for(;;)
       {caml_bytes_unsafe_set(tr_map,i$3,of_int_exn(i$3));
        var _Cv_=i$3 + 1 | 0;
        if(255 !== i$3){var i$3=_Cv_;continue}
        var
         _Co_=
          caml_call2
           (include$1[4],
            caml_ml_string_length(target),
            caml_ml_string_length(replacement))
          -
          1
          |
          0,
         _Cn_=0;
        if(_Co_ >= 0)
         {var i$2=_Cn_;
          for(;;)
           {var index$0=caml_string_unsafe_get(target,i$2);
            caml_bytes_unsafe_set
             (tr_map,index$0,caml_string_unsafe_get(replacement,i$2));
            var _Cu_=i$2 + 1 | 0;
            if(_Co_ !== i$2){var i$2=_Cu_;continue}
            break}}
        var
         last_replacement=
          caml_string_unsafe_get
           (replacement,caml_ml_string_length(replacement) - 1 | 0),
         _Cp_=
          caml_call2
           (include$1[4],
            caml_ml_string_length(target),
            caml_ml_string_length(replacement)),
         _Cq_=caml_ml_string_length(target) - 1 | 0;
        if(_Cq_ >= _Cp_)
         {var i$1=_Cp_;
          for(;;)
           {var index=caml_string_unsafe_get(target,i$1);
            caml_bytes_unsafe_set(tr_map,index,last_replacement);
            var _Ct_=i$1 + 1 | 0;
            if(_Cq_ !== i$1){var i$1=_Ct_;continue}
            break}}
        var first_target=caml_string_get(target,0);
        if
         (!
          caml_call2
           (symbol$106,
            caml_bytes_unsafe_get(tr_map,first_target),
            first_target))
         {var i=0;
          for(;;)
           {if(256 === i)
             var _Cs_=0;
            else
             {var _Cr_=of_int_exn(i);
              if
               (! caml_call2(symbol$106,caml_bytes_unsafe_get(tr_map,i),_Cr_))
               {var i$0=i + 1 | 0,i=i$0;continue}
              var _Cs_=1}
            if(! _Cs_)return 0;
            break}}
        return [0,unsafe_to_string(tr_map)]}}
    var Base_Bytes_tr=[0,tr_create_map];
    caml_register_global(1080,Base_Bytes_tr,"Base__Bytes_tr");
    function stage(_Cm_){return _Cm_}
    function unstage(_Cl_){return _Cl_}
    var Base_Staged=[0,stage,unstage];
    caml_register_global(1081,Base_Staged,"Base__Staged");
    function hash$9(x){return caml_call1(func$5,x)}
    var
     hashable$1=[0,hash$9,compare$17,sexp_of_t$2],
     include$47=_P_([0,compare$17,sexp_of_t$2]),
     comparator$3=include$47[1];
    function invariant$12(param){return 0}
    function sub$8(src,pos,len)
     {if(0 === pos && len === caml_ml_string_length(src))return src;
      check_pos_len_exn(pos,len,caml_ml_string_length(src));
      if(0 === len)return cst$14;
      var dst=caml_create_bytes(len);
      caml_blit_string(src,pos,dst,0,len);
      return unsafe_to_string(dst)}
    function subo$2(opt,len,src)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var i=len[1],i$0=i;
      else
       var i$0=caml_ml_string_length(src) - pos | 0;
      return sub$8(src,pos,i$0)}
    function contains(opt,len,t,char$0)
     {if(opt)var sth=opt[1],pos$1=sth;else var pos$1=0;
      var
       total_length=caml_ml_string_length(t),
       len$0=value(len,total_length - pos$1 | 0);
      check_pos_len_exn(pos$1,len$0,total_length);
      var end=pos$1 + len$0 | 0,pos=pos$1;
      for(;;)
       {var _Ci_=pos < end?1:0;
        if(_Ci_)
         {var
           _Cj_=
            caml_call2(equal_char$1,caml_string_unsafe_get(t,pos),char$0);
          if(! _Cj_){var pos$0=pos + 1 | 0,pos=pos$0;continue}
          var _Ck_=_Cj_}
        else
         var _Ck_=_Ci_;
        return _Ck_}}
    function is_empty$3(t){return 0 === caml_ml_string_length(t)?1:0}
    function index_from_exn_internal(string,pos,len,not_found,char$0)
     {var pos$0=pos;
      for(;;)
       {if(len <= pos$0)throw not_found;
        if
         (caml_call2(equal_char$1,caml_string_unsafe_get(string,pos$0),char$0))
         return pos$0;
        var pos$1=pos$0 + 1 | 0,pos$0=pos$1}}
    function index_exn_internal(t,not_found,char$0)
     {return index_from_exn_internal
              (t,0,caml_ml_string_length(t),not_found,char$0)}
    var not_found$6=[0,Not_found_s,_bR_];
    function index_exn(t,char$0)
     {return index_exn_internal(t,not_found$6,char$0)}
    var not_found$7=[0,Not_found_s,_bS_];
    function index_from_exn(t,pos,char$0)
     {var len=caml_ml_string_length(t);
      if(0 <= pos && len >= pos)
       return index_from_exn_internal(t,pos,len,not_found$7,char$0);
      return caml_call1(invalid_arg$0,cst_String_index_from_exn)}
    function rindex_from_exn_internal(string,pos,len,not_found,char$0)
     {var pos$0=pos;
      for(;;)
       {if(0 > pos$0)throw not_found;
        if
         (caml_call2(equal_char$1,caml_string_unsafe_get(string,pos$0),char$0))
         return pos$0;
        var pos$1=pos$0 - 1 | 0,pos$0=pos$1}}
    function rindex_exn_internal(t,not_found,char$0)
     {var len=caml_ml_string_length(t);
      return rindex_from_exn_internal(t,len - 1 | 0,len,not_found,char$0)}
    var not_found$8=[0,Not_found_s,_bT_];
    function rindex_exn(t,char$0)
     {return rindex_exn_internal(t,not_found$8,char$0)}
    var not_found$9=[0,Not_found_s,_bU_];
    function rindex_from_exn(t,pos,char$0)
     {var len=caml_ml_string_length(t);
      if(-1 <= pos && len > pos)
       return rindex_from_exn_internal(t,pos,len,not_found$9,char$0);
      return caml_call1(invalid_arg$0,cst_String_rindex_from_exn)}
    function index(t,char$0)
     {try
       {var _Cg_=[0,index_exn(t,char$0)];return _Cg_}
      catch(_Ch_)
       {_Ch_ = caml_wrap_exception(_Ch_);
        if(_Ch_[1] !== Not_found_s && _Ch_ !== Caml$0[103])throw _Ch_;
        return 0}}
    function rindex(t,char$0)
     {try
       {var _Ce_=[0,rindex_exn(t,char$0)];return _Ce_}
      catch(_Cf_)
       {_Cf_ = caml_wrap_exception(_Cf_);
        if(_Cf_[1] !== Not_found_s && _Cf_ !== Caml$0[103])throw _Cf_;
        return 0}}
    function index_from(t,pos,char$0)
     {try
       {var _Cc_=[0,index_from_exn(t,pos,char$0)];return _Cc_}
      catch(_Cd_)
       {_Cd_ = caml_wrap_exception(_Cd_);
        if(_Cd_[1] !== Not_found_s && _Cd_ !== Caml$0[103])throw _Cd_;
        return 0}}
    function rindex_from(t,pos,char$0)
     {try
       {var _Ca_=[0,rindex_from_exn(t,pos,char$0)];return _Ca_}
      catch(_Cb_)
       {_Cb_ = caml_wrap_exception(_Cb_);
        if(_Cb_[1] !== Not_found_s && _Cb_ !== Caml$0[103])throw _Cb_;
        return 0}}
    function sexp_of_t$30(param)
     {var
       case_sensitive=param[2],
       pattern=param[1],
       _B$_=[0,[1,[0,_bV_,[0,caml_call1(sexp_of_t$1,case_sensitive),0]]],0];
      return [1,[0,[1,[0,_bW_,[0,caml_call1(sexp_of_t$2,pattern),0]]],_B$_]]}
    function pattern(t){return t[1]}
    function case_sensitive(t){return t[2]}
    function kmp_internal_loop
     (matched_chars,next_text_char,pattern,kmp_array,char_equal)
     {var matched_chars$0=[0,matched_chars];
      for(;;)
       {if
         (0
          <
          matched_chars$0[1]
          &&
          !
          caml_call2
           (char_equal,
            next_text_char,
            caml_string_unsafe_get(pattern,matched_chars$0[1])))
         {matched_chars$0[1] = kmp_array[1 + (matched_chars$0[1] - 1 | 0)];
          continue}
        if
         (caml_call2
           (char_equal,
            next_text_char,
            caml_string_unsafe_get(pattern,matched_chars$0[1])))
         matched_chars$0[1] = matched_chars$0[1] + 1 | 0;
        return matched_chars$0[1]}}
    function get_char_equal(case_sensitive)
     {return case_sensitive?equal_char$1:_bQ_[12]}
    function create$5(pattern,case_sensitive)
     {var n=caml_ml_string_length(pattern),kmp_array=caml_make_vect(n,-1);
      if(0 < n)
       {var char_equal=get_char_equal(case_sensitive);
        kmp_array[1] = 0;
        var matched_chars=[0,0],_B9_=n - 1 | 0,_B8_=1;
        if(_B9_ >= 1)
         {var i=_B8_;
          for(;;)
           {matched_chars[1]
            =
            kmp_internal_loop
             (matched_chars[1],
              caml_string_unsafe_get(pattern,i),
              pattern,
              kmp_array,
              char_equal);
            kmp_array[1 + i] = matched_chars[1];
            var _B__=i + 1 | 0;
            if(_B9_ !== i){var i=_B__;continue}
            break}}}
      return [0,pattern,case_sensitive,kmp_array]}
    function index_internal(opt,param)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      var kmp_array=param[3],case_sensitive=param[2],pattern=param[1];
      return function(text)
       {if
         (0
          <=
          pos
          &&
          (caml_ml_string_length(text) - caml_ml_string_length(pattern) | 0)
          >=
          pos)
         {var
           char_equal=get_char_equal(case_sensitive),
           j=[0,pos],
           matched_chars=[0,0],
           k=caml_ml_string_length(pattern),
           n=caml_ml_string_length(text);
          for(;;)
           {if(j[1] < n && matched_chars[1] < k)
             {var next_text_char=caml_string_unsafe_get(text,j[1]);
              matched_chars[1]
              =
              kmp_internal_loop
               (matched_chars[1],next_text_char,pattern,kmp_array,char_equal);
              j[1] = j[1] + 1 | 0;
              continue}
            return matched_chars[1] === k?j[1] - k | 0:-1}}
        return -1}}
    function matches(t,str)
     {return 0 <= caml_call1(index_internal(0,t),str)?1:0}
    function index$0(pos,t,in$0)
     {var p=caml_call1(index_internal(pos,t),in$0);return 0 <= p?[0,p]:0}
    function index_exn$0(pos,t,in$0)
     {var p=caml_call1(index_internal(pos,t),in$0);
      return 0 <= p
              ?p
              :raise_s
                (caml_call2
                  (message,
                   cst_Substring_not_found,
                   [0,[0,cst_substring,caml_call1(sexp_of_t$2,t[1])],0]))}
    function index_all(param,may_overlap,text)
     {var kmp_array=param[3],case_sensitive=param[2],pattern=param[1];
      if(0 === caml_ml_string_length(pattern))
       return init$1
               (1 + caml_ml_string_length(text) | 0,
                function(_B7_){return _B7_});
      var
       char_equal=get_char_equal(case_sensitive),
       matched_chars=[0,0],
       k=caml_ml_string_length(pattern),
       n=caml_ml_string_length(text),
       found=[0,0],
       _B5_=0;
      if(n >= 0)
       {var j=_B5_;
        for(;;)
         {if(matched_chars[1] === k)
           {found[1] = [0,j - k | 0,found[1]];
            matched_chars[1] = may_overlap?kmp_array[1 + (k - 1 | 0)]:0}
          if(j < n)
           {var next_text_char=caml_string_unsafe_get(text,j);
            matched_chars[1]
            =
            kmp_internal_loop
             (matched_chars[1],next_text_char,pattern,kmp_array,char_equal)}
          var _B6_=j + 1 | 0;
          if(n !== j){var j=_B6_;continue}
          break}}
      return rev(found[1])}
    function replace_first(pos,t,s,with$0)
     {var match=index$0(pos,t,s);
      if(! match)return s;
      var
       i=match[1],
       len_s=caml_ml_string_length(s),
       len_t=caml_ml_string_length(t[1]),
       len_with=caml_ml_string_length(with$0),
       dst=caml_create_bytes((len_s + len_with | 0) - len_t | 0);
      caml_call5(blit_string,s,0,dst,0,i);
      caml_call5(blit_string,with$0,0,dst,i,len_with);
      caml_call5
       (blit_string,
        s,
        i + len_t | 0,
        dst,
        i + len_with | 0,
        (len_s - i | 0) - len_t | 0);
      return unsafe_to_string(dst)}
    function replace_all(t,s,with$0)
     {var matches=index_all(t,0,s);
      if(! matches)return s;
      var
       len_s=caml_ml_string_length(s),
       len_t=caml_ml_string_length(t[1]),
       len_with=caml_ml_string_length(with$0),
       num_matches=caml_call1(length,matches),
       dst=
        caml_create_bytes
         (len_s + caml_mul(len_with - len_t | 0,num_matches) | 0),
       next_dst_pos=[0,0],
       next_src_pos=[0,0];
      iter$0
       (matches,
        function(i)
         {var len=i - next_src_pos[1] | 0;
          caml_call5(blit_string,s,next_src_pos[1],dst,next_dst_pos[1],len);
          caml_call5
           (blit_string,with$0,0,dst,next_dst_pos[1] + len | 0,len_with);
          next_dst_pos[1] = (next_dst_pos[1] + len | 0) + len_with | 0;
          next_src_pos[1] = (next_src_pos[1] + len | 0) + len_t | 0;
          return 0});
      caml_call5
       (blit_string,
        s,
        next_src_pos[1],
        dst,
        next_dst_pos[1],
        len_s - next_src_pos[1] | 0);
      return unsafe_to_string(dst)}
    function split_on(t,s)
     {var pattern_len=caml_ml_string_length(t[1]),matches=index_all(t,0,s);
      function _B4_(i,j)
       {return sub$8(s,i + pattern_len | 0,(j - i | 0) - pattern_len | 0)}
      return map2_exn
              ([0,- pattern_len | 0,matches],
               caml_call2(symbol$58,matches,[0,caml_ml_string_length(s),0]),
               _B4_)}
    function equal$23(a_002,b_003)
     {if(a_002 === b_003)return 1;
      var _B1_=caml_call2(equal_string$0,a_002[1],b_003[1]);
      if(_B1_)
       {var _B2_=caml_call2(equal_bool$0,a_002[2],b_003[2]);
        if(_B2_)
         return caml_call3(equal_array$0,equal_int$0,a_002[3],b_003[3]);
        var _B3_=_B2_}
      else
       var _B3_=_B1_;
      return _B3_}
    function sexp_of_t$31(param)
     {var
       kmp_array_011=param[3],
       case_sensitive_009=param[2],
       pattern_007=param[1],
       arg_012=caml_call2(sexp_of_array,sexp_of_t$4,kmp_array_011),
       bnds_006=[0,[1,[0,_bX_,[0,arg_012,0]]],0],
       arg_010=caml_call1(sexp_of_t$1,case_sensitive_009),
       bnds_006$0=[0,[1,[0,_bY_,[0,arg_010,0]]],bnds_006],
       arg_008=caml_call1(sexp_of_t$2,pattern_007),
       bnds_006$1=[0,[1,[0,_bZ_,[0,arg_008,0]]],bnds_006$0];
      return [1,bnds_006$1]}
    function representation(_B0_){return _B0_}
    var Private$2=[0,equal$23,sexp_of_t$31,representation];
    function substr_index_gen(case_sensitive,pos,t,pattern)
     {return index$0(pos,create$5(pattern,case_sensitive),t)}
    function substr_index_exn_gen(case_sensitive,pos,t,pattern)
     {return index_exn$0(pos,create$5(pattern,case_sensitive),t)}
    function substr_index_all_gen(case_sensitive,t,may_overlap,pattern)
     {return index_all(create$5(pattern,case_sensitive),may_overlap,t)}
    function substr_replace_first_gen(case_sensitive,pos,t,pattern)
     {var _BY_=create$5(pattern,case_sensitive);
      return function(_BZ_){return replace_first(pos,_BY_,t,_BZ_)}}
    function substr_replace_all_gen(case_sensitive,t,pattern)
     {var _BW_=create$5(pattern,case_sensitive);
      return function(_BX_){return replace_all(_BW_,t,_BX_)}}
    function is_substring_gen(case_sensitive,t,substring)
     {return is_some(substr_index_gen(case_sensitive,0,t,substring))}
    var _b0_=1;
    function substr_index(_BT_,_BU_,_BV_)
     {return substr_index_gen(_b0_,_BT_,_BU_,_BV_)}
    var _b1_=1;
    function substr_index_exn(_BQ_,_BR_,_BS_)
     {return substr_index_exn_gen(_b1_,_BQ_,_BR_,_BS_)}
    var _b2_=1;
    function substr_index_all(_BN_,_BO_,_BP_)
     {return substr_index_all_gen(_b2_,_BN_,_BO_,_BP_)}
    var _b3_=1;
    function substr_replace_first(_BK_,_BL_,_BM_)
     {return substr_replace_first_gen(_b3_,_BK_,_BL_,_BM_)}
    var _b4_=1;
    function substr_replace_all(_BI_,_BJ_)
     {return substr_replace_all_gen(_b4_,_BI_,_BJ_)}
    var _b5_=1;
    function is_substring(_BG_,_BH_){return is_substring_gen(_b5_,_BG_,_BH_)}
    function is_substring_at_gen(str,str_pos$1,sub,char_equal)
     {var
       str_len=caml_ml_string_length(str),
       sub_len=caml_ml_string_length(sub),
       _BD_=str_pos$1 < 0?1:0,
       _BE_=_BD_ || (str_len < str_pos$1?1:0);
      if(_BE_)caml_call3(invalid_argf(_b6_),str_pos$1,str_len,0);
      var _BF_=(str_pos$1 + sub_len | 0) <= str_len?1:0;
      if(! _BF_)return _BF_;
      var str_pos=str_pos$1,sub_pos=0;
      for(;;)
       {if(sub_pos === sub_len)return 1;
        if
         (!
          caml_call2
           (char_equal,
            caml_string_unsafe_get(str,str_pos),
            caml_string_unsafe_get(sub,sub_pos)))
         return 0;
        var
         sub_pos$0=sub_pos + 1 | 0,
         str_pos$0=str_pos + 1 | 0,
         str_pos=str_pos$0,
         sub_pos=sub_pos$0}}
    function is_suffix_gen(string,suffix,char_equal)
     {var
       string_len=caml_ml_string_length(string),
       suffix_len=caml_ml_string_length(suffix),
       _BC_=suffix_len <= string_len?1:0;
      return _BC_
              ?is_substring_at_gen
                (string,string_len - suffix_len | 0,suffix,char_equal)
              :_BC_}
    function is_prefix_gen(string,prefix,char_equal)
     {var
       string_len=caml_ml_string_length(string),
       prefix_len=caml_ml_string_length(prefix),
       _BB_=prefix_len <= string_len?1:0;
      return _BB_?is_substring_at_gen(string,0,prefix,char_equal):_BB_}
    function compare$36(string1,string2)
     {if(string1 === string2)return 0;
      var
       len2=caml_ml_string_length(string2),
       len1=caml_ml_string_length(string1),
       pos=0;
      for(;;)
       {if(pos === len1)return pos === len2?0:-1;
        if(pos === len2)return 1;
        var
         c2=caml_string_unsafe_get(string2,pos),
         c1=caml_string_unsafe_get(string1,pos),
         _BA_=caml_call1(_e_,c2),
         c=caml_call2(compare_char$0,caml_call1(_e_,c1),_BA_);
        if(0 !== c)return c;
        var pos$0=pos + 1 | 0,pos=pos$0}}
    function hash_fold_t$21(state,t)
     {var
       len=caml_ml_string_length(t),
       state$0=[0,caml_call2(hash_fold_t$4,state,len)],
       _Bx_=len - 1 | 0,
       _Bw_=0;
      if(_Bx_ >= 0)
       {var pos=_Bw_;
        for(;;)
         {var _By_=caml_call1(_e_,caml_string_unsafe_get(t,pos));
          state$0[1] = caml_call2(hash_fold_t$3,state$0[1],_By_);
          var _Bz_=pos + 1 | 0;
          if(_Bx_ !== pos){var pos=_Bz_;continue}
          break}}
      return state$0[1]}
    function hash$10(t){return run(0,hash_fold_t$21,t)}
    function is_suffix$0(s,suffix){return is_suffix_gen(s,suffix,_bQ_[12])}
    function is_prefix$0(s,prefix){return is_prefix_gen(s,prefix,_bQ_[12])}
    var _b7_=0;
    function substr_index$0(_Bt_,_Bu_,_Bv_)
     {return substr_index_gen(_b7_,_Bt_,_Bu_,_Bv_)}
    var _b8_=0;
    function substr_index_exn$0(_Bq_,_Br_,_Bs_)
     {return substr_index_exn_gen(_b8_,_Bq_,_Br_,_Bs_)}
    var _b9_=0;
    function substr_index_all$0(_Bn_,_Bo_,_Bp_)
     {return substr_index_all_gen(_b9_,_Bn_,_Bo_,_Bp_)}
    var _b__=0;
    function substr_replace_first$0(_Bk_,_Bl_,_Bm_)
     {return substr_replace_first_gen(_b__,_Bk_,_Bl_,_Bm_)}
    var _b$_=0;
    function substr_replace_all$0(_Bi_,_Bj_)
     {return substr_replace_all_gen(_b$_,_Bi_,_Bj_)}
    var _ca_=0;
    function is_substring$0(_Bg_,_Bh_)
     {return is_substring_gen(_ca_,_Bg_,_Bh_)}
    var _cb_=_bQ_[12];
    function is_substring_at(_Bd_)
     {return function(_Be_)
       {return function(_Bf_){return is_substring_at_gen(_Bd_,_Be_,_Bf_,_cb_)}}}
    var
     include$48=Make$1([0,compare$36,sexp_of_t$2]),
     symbol$110=include$48[1],
     symbol$111=include$48[2],
     symbol$112=include$48[3],
     symbol$113=include$48[4],
     symbol$114=include$48[5],
     symbol$115=include$48[6],
     equal$24=include$48[7],
     compare$37=include$48[8],
     min$18=include$48[9],
     max$18=include$48[10],
     ascending$15=include$48[11],
     descending$15=include$48[12],
     between$1=include$48[13],
     clamp_exn$1=include$48[14],
     clamp$1=include$48[15],
     comparator$4=include$48[16];
    function of_string$7(_Bc_){return _Bc_}
    function to_string$8(_Bb_){return _Bb_}
    function init$4(n,f)
     {if(n < 0)caml_call2(invalid_argf(_cc_),n,0);
      var t=caml_create_bytes(n),_A$_=n - 1 | 0,_A__=0;
      if(_A$_ >= 0)
       {var i=_A__;
        for(;;)
         {caml_bytes_set(t,i,caml_call1(f,i));
          var _Ba_=i + 1 | 0;
          if(_A$_ !== i){var i=_Ba_;continue}
          break}}
      return unsafe_to_string(t)}
    function to_list$5(s)
     {var i$1=caml_ml_string_length(s) - 1 | 0,acc=0,i=i$1;
      for(;;)
       {if(0 > i)return acc;
        var i$0=i - 1 | 0,acc$0=[0,caml_string_get(s,i),acc],acc=acc$0,i=i$0}}
    function to_list_rev$0(s)
     {var len=caml_ml_string_length(s),acc=0,i=0;
      for(;;)
       {if(i === len)return acc;
        var i$0=i + 1 | 0,acc$0=[0,caml_string_get(s,i),acc],acc=acc$0,i=i$0}}
    function rev$1(t)
     {var
       len=caml_ml_string_length(t),
       res=caml_create_bytes(len),
       _A8_=len - 1 | 0,
       _A7_=0;
      if(_A8_ >= 0)
       {var i=_A7_;
        for(;;)
         {caml_bytes_unsafe_set
           (res,i,caml_string_unsafe_get(t,(len - 1 | 0) - i | 0));
          var _A9_=i + 1 | 0;
          if(_A8_ !== i){var i=_A9_;continue}
          break}}
      return unsafe_to_string(res)}
    var not_found$10=[0,Not_found_s,_cd_];
    function lsplit2_exn(line,delim)
     {var
       pos=index_exn_internal(line,not_found$10,delim),
       _A6_=
        sub$8
         (line,pos + 1 | 0,(caml_ml_string_length(line) - pos | 0) - 1 | 0);
      return [0,sub$8(line,0,pos),_A6_]}
    var not_found$11=[0,Not_found_s,_ce_];
    function rsplit2_exn(line,delim)
     {var
       pos=rindex_exn_internal(line,not_found$11,delim),
       _A5_=
        sub$8
         (line,pos + 1 | 0,(caml_ml_string_length(line) - pos | 0) - 1 | 0);
      return [0,sub$8(line,0,pos),_A5_]}
    function lsplit2(line,on)
     {try
       {var _A3_=[0,lsplit2_exn(line,on)];return _A3_}
      catch(_A4_)
       {_A4_ = caml_wrap_exception(_A4_);
        if(_A4_[1] !== Not_found_s && _A4_ !== Caml$0[103])throw _A4_;
        return 0}}
    function rsplit2(line,on)
     {try
       {var _A1_=[0,rsplit2_exn(line,on)];return _A1_}
      catch(_A2_)
       {_A2_ = caml_wrap_exception(_A2_);
        if(_A2_[1] !== Not_found_s && _A2_ !== Caml$0[103])throw _A2_;
        return 0}}
    function char_list_mem(l,c)
     {var l$0=l;
      for(;;)
       {if(! l$0)return 0;
        var tl=l$0[2],hd=l$0[1],_A0_=caml_call2(equal_char$1,hd,c);
        if(_A0_)return _A0_;
        var l$0=tl}}
    function split_gen(str,on)
     {if(552554919 <= on[1])
       var l=on[2],is_delim=function(c){return char_list_mem(l,c)};
      else
       var
        c=on[2],
        is_delim=function(c$0){return caml_call2(equal_char$1,c$0,c)};
      var
       last_pos=caml_ml_string_length(str),
       pos$2=last_pos - 1 | 0,
       acc=0,
       last_pos$0=last_pos,
       pos=pos$2;
      for(;;)
       {if(-1 === pos)return [0,sub$8(str,0,last_pos$0),acc];
        if(is_delim(caml_string_get(str,pos)))
         {var
           pos1=pos + 1 | 0,
           sub_str=sub$8(str,pos1,last_pos$0 - pos1 | 0),
           pos$0=pos - 1 | 0,
           acc$0=[0,sub_str,acc],
           acc=acc$0,
           last_pos$0=pos,
           pos=pos$0;
          continue}
        var pos$1=pos - 1 | 0,pos=pos$1}}
    function split(str,on){return split_gen(str,[0,-1044422954,on])}
    function split_on_chars(str,chars)
     {return split_gen(str,[0,552554919,chars])}
    function back_up_at_newline(t,pos,eol)
     {var switch$0=0;
      if
       (0
        <
        pos[1]
        &&
        caml_call2(equal_char$1,caml_string_get(t,pos[1] - 1 | 0),13))
       {var _AZ_=2;switch$0 = 1}
      if(! switch$0)var _AZ_=1;
      pos[1] = pos[1] - _AZ_ | 0;
      eol[1] = pos[1] + 1 | 0;
      return 0}
    function split_lines(t)
     {var n=caml_ml_string_length(t);
      if(0 === n)return 0;
      var pos=[0,n - 1 | 0],eol=[0,n],ac=[0,0];
      if(caml_call2(equal_char$1,caml_string_get(t,pos[1]),10))
       back_up_at_newline(t,pos,eol);
      for(;;)
       {if(0 > pos[1]){var _AY_=ac[1];return [0,sub$8(t,0,eol[1]),_AY_]}
        if(caml_call2(symbol$106,caml_string_get(t,pos[1]),10))
         {decr(pos);continue}
        var start=pos[1] + 1 | 0,_AX_=ac[1];
        ac[1] = [0,sub$8(t,start,eol[1] - start | 0),_AX_];
        back_up_at_newline(t,pos,eol)}}
    function is_suffix$1(s,suffix)
     {return is_suffix_gen(s,suffix,equal_char$1)}
    function is_prefix$1(s,prefix)
     {return is_prefix_gen(s,prefix,equal_char$1)}
    function is_substring_at$0(s,pos,substring)
     {return is_substring_at_gen(s,pos,substring,equal_char$1)}
    function wrap_sub_n(t,n,name,pos,len,on_error)
     {if(0 > n)
       return caml_call1
               (invalid_arg$0,
                caml_call2(symbol$59,name,cst_expecting_nonnegative_argu));
      try {var _AV_=sub$8(t,pos,len);return _AV_}catch(_AW_){return on_error}}
    function drop_prefix(t,n)
     {return wrap_sub_n
              (t,n,cst_drop_prefix,n,caml_ml_string_length(t) - n | 0,cst$15)}
    function drop_suffix(t,n)
     {return wrap_sub_n
              (t,n,cst_drop_suffix,0,caml_ml_string_length(t) - n | 0,cst$16)}
    function prefix(t,n){return wrap_sub_n(t,n,cst_prefix,0,n,t)}
    function suffix(t,n)
     {return wrap_sub_n(t,n,cst_suffix,caml_ml_string_length(t) - n | 0,n,t)}
    function lfindi(opt,t,f)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      var n=caml_ml_string_length(t),i=pos;
      for(;;)
       {if(i === n)return 0;
        if(caml_call2(f,i,caml_string_get(t,i)))return [0,i];
        var i$0=i + 1 | 0,i=i$0}}
    function find$5(t,f)
     {var match=lfindi(0,t,function(param,c){return caml_call1(f,c)});
      if(! match)return 0;
      var i=match[1];
      return [0,caml_string_get(t,i)]}
    function find_map$4(t,f)
     {var n=caml_ml_string_length(t),i=0;
      for(;;)
       {if(i === n)return 0;
        var res=caml_call1(f,caml_string_get(t,i));
        if(res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    function rfindi(pos,t,f)
     {if(pos)
       var pos$0=pos[1],pos$1=pos$0;
      else
       var pos$1=caml_ml_string_length(t) - 1 | 0;
      var i=pos$1;
      for(;;)
       {if(0 > i)return 0;
        if(caml_call2(f,i,caml_string_get(t,i)))return [0,i];
        var i$0=i - 1 | 0,i=i$0}}
    function last_non_drop(drop,t)
     {return rfindi(0,t,function(param,c){return 1 - caml_call1(drop,c)})}
    function rstrip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=last_non_drop(drop,t);
      if(! match)return cst$17;
      var i=match[1];
      return i === (caml_ml_string_length(t) - 1 | 0)?t:prefix(t,i + 1 | 0)}
    function first_non_drop(drop,t)
     {return lfindi(0,t,function(param,c){return 1 - caml_call1(drop,c)})}
    function lstrip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=first_non_drop(drop,t);
      if(! match)return cst$18;
      var _AU_=match[1];
      return 0 === _AU_?t:drop_prefix(t,_AU_)}
    function strip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var length=caml_ml_string_length(t);
      if(0 !== length)
       {var switch$0=0;
        if
         (caml_call1(drop,caml_string_get(t,0))
          ||
          caml_call1(drop,caml_string_get(t,length - 1 | 0)))
         switch$0 = 1;
        if(switch$0)
         {var match=first_non_drop(drop,t);
          if(! match)return cst$19;
          var first=match[1],match$0=last_non_drop(drop,t);
          if(! match$0)throw [0,Assert_failure$0,_cf_];
          var last=match$0[1];
          return sub$8(t,first,(last - first | 0) + 1 | 0)}}
      return t}
    function mapi$4(t,f)
     {var
       l=caml_ml_string_length(t),
       t$0=caml_create_bytes(l),
       _AS_=l - 1 | 0,
       _AR_=0;
      if(_AS_ >= 0)
       {var i=_AR_;
        for(;;)
         {caml_bytes_unsafe_set(t$0,i,caml_call2(f,i,caml_string_get(t,i)));
          var _AT_=i + 1 | 0;
          if(_AS_ !== i){var i=_AT_;continue}
          break}}
      return unsafe_to_string(t$0)}
    function map$23(t,f)
     {var
       l=caml_ml_string_length(t),
       t$0=caml_create_bytes(l),
       _AP_=l - 1 | 0,
       _AO_=0;
      if(_AP_ >= 0)
       {var i=_AO_;
        for(;;)
         {caml_bytes_unsafe_set(t$0,i,caml_call1(f,caml_string_get(t,i)));
          var _AQ_=i + 1 | 0;
          if(_AP_ !== i){var i=_AQ_;continue}
          break}}
      return unsafe_to_string(t$0)}
    function to_array$4(s)
     {return caml_call2
              (init,
               caml_ml_string_length(s),
               function(i){return caml_string_get(s,i)})}
    function exists$5(s,f)
     {var len=caml_ml_string_length(s),i=0;
      for(;;)
       {var _AL_=i < len?1:0;
        if(_AL_)
         {var _AM_=caml_call1(f,caml_string_get(s,i));
          if(! _AM_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AN_=_AM_}
        else
         var _AN_=_AL_;
        return _AN_}}
    function for_all$5(s,f)
     {var len=caml_ml_string_length(s),i=0;
      for(;;)
       {var _AI_=i === len?1:0;
        if(_AI_)
         var _AJ_=_AI_;
        else
         {var _AK_=caml_call1(f,caml_string_get(s,i));
          if(_AK_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AJ_=_AK_}
        return _AJ_}}
    function fold$3(t,init,f)
     {var len=caml_ml_string_length(t),i=0,ac=init;
      for(;;)
       {if(i === len)return ac;
        var
         ac$0=caml_call2(f,ac,caml_string_get(t,i)),
         i$0=i + 1 | 0,
         i=i$0,
         ac=ac$0}}
    function foldi$4(t,init,f)
     {var len=caml_ml_string_length(t),i=0,ac=init;
      for(;;)
       {if(i === len)return ac;
        var
         ac$0=caml_call3(f,i,ac,caml_string_get(t,i)),
         i$0=i + 1 | 0,
         i=i$0,
         ac=ac$0}}
    function iteri$4(t,f)
     {var _AG_=caml_ml_string_length(t) - 1 | 0,_AF_=0;
      if(_AG_ >= 0)
       {var i=_AF_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(t,i));
          var _AH_=i + 1 | 0;
          if(_AG_ !== i){var i=_AH_;continue}
          break}}
      return 0}
    function count$4(t,f){return count(fold$3,t,f)}
    function sum$4(m,t,f){return caml_call2(sum(fold$3,m),t,f)}
    function min_elt$5(t)
     {return function(_AE_){return min_elt(fold$3,t,_AE_)}}
    function max_elt$5(t)
     {return function(_AD_){return max_elt(fold$3,t,_AD_)}}
    function fold_result$4(t,init,f){return fold_result(fold$3,init,f,t)}
    function fold_until$4(t,init,f)
     {return function(_AC_){return fold_until(fold$3,init,f,_AC_,t)}}
    function find_mapi$3(t,f){return find_mapi$0(iteri$4,t,f)}
    function findi$3(t,f){return findi$0(iteri$4,t,f)}
    function counti$3(t,f){return counti$0(foldi$4,t,f)}
    function for_alli$3(t,f){return for_alli$0(iteri$4,t,f)}
    function existsi$3(t,f){return existsi$0(iteri$4,t,f)}
    function mem$4(t,c)
     {var len=caml_ml_string_length(t),i=0;
      for(;;)
       {var _Az_=i < len?1:0;
        if(_Az_)
         {var _AA_=caml_call2(equal_char$1,c,caml_string_unsafe_get(t,i));
          if(! _AA_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AB_=_AA_}
        else
         var _AB_=_Az_;
        return _AB_}}
    function tr(target,replacement,s)
     {return caml_call2(equal_char$1,target,replacement)
              ?s
              :mem$4(s,target)
                ?map$23
                  (s,
                   function(c)
                    {return caml_call2(equal_char$1,c,target)?replacement:c})
                :s}
    function tr_multi(target,replacement)
     {if(is_empty$3(target))return function(_Ay_){return _Ay_};
      if(is_empty$3(replacement))
       return caml_call1(invalid_arg$0,cst_tr_multi_replacement_is_em);
      var match=tr_create_map(target,replacement);
      if(! match)return function(_Ax_){return _Ax_};
      var tr_map=match[1];
      return function(s)
       {return exists$5
                 (s,
                  function(c)
                   {return caml_call2
                            (symbol$106,c,caml_string_unsafe_get(tr_map,c))})
                ?map$23
                  (s,function(c){return caml_string_unsafe_get(tr_map,c)})
                :s}}
    function concat_array(sep,ar){return concat$0(sep,caml_call1(to_list,ar))}
    function concat_map$1(sep,s,f)
     {return concat_array(sep,map(to_array$4(s),f))}
    function filter$3(t,f)
     {var n=caml_ml_string_length(t),i=[0,0];
      for(;;)
       {if(i[1] < n && caml_call1(f,caml_string_get(t,i[1])))
         {incr(i);continue}
        if(i[1] === n)return t;
        var out=caml_create_bytes(n - 1 | 0);
        caml_call5(blit_string,t,0,out,0,i[1]);
        var out_pos=[0,i[1]];
        incr(i);
        for(;;)
         {if(i[1] >= n)
           {var out$0=unsafe_to_string(out);
            return out_pos[1] === (n - 1 | 0)?out$0:sub$8(out$0,0,out_pos[1])}
          var c=caml_string_get(t,i[1]);
          if(caml_call1(f,c)){caml_bytes_set(out,out_pos[1],c);incr(out_pos)}
          incr(i)}}}
    function filteri$2(t,f)
     {var n=caml_ml_string_length(t),i=[0,0];
      for(;;)
       {if(i[1] < n)
         {var _Aw_=caml_string_get(t,i[1]);
          if(caml_call2(f,i[1],_Aw_)){incr(i);continue}}
        if(i[1] === n)return t;
        var out=caml_create_bytes(n - 1 | 0);
        caml_call5(blit_string,t,0,out,0,i[1]);
        var out_pos=[0,i[1]];
        incr(i);
        for(;;)
         {if(i[1] >= n)
           {var out$0=unsafe_to_string(out);
            return out_pos[1] === (n - 1 | 0)?out$0:sub$8(out$0,0,out_pos[1])}
          var c=caml_string_get(t,i[1]);
          if(caml_call2(f,i[1],c))
           {caml_bytes_set(out,out_pos[1],c);incr(out_pos)}
          incr(i)}}}
    function chop_prefix(s,prefix)
     {return is_prefix$1(s,prefix)
              ?[0,drop_prefix(s,caml_ml_string_length(prefix))]
              :0}
    function chop_prefix_if_exists(s,prefix)
     {return is_prefix$1(s,prefix)
              ?drop_prefix(s,caml_ml_string_length(prefix))
              :s}
    function chop_prefix_exn(s,prefix)
     {var match=chop_prefix(s,prefix);
      if(! match)return caml_call3(invalid_argf(_cg_),s,prefix,0);
      var str=match[1];
      return str}
    function chop_suffix(s,suffix)
     {return is_suffix$1(s,suffix)
              ?[0,drop_suffix(s,caml_ml_string_length(suffix))]
              :0}
    function chop_suffix_if_exists(s,suffix)
     {return is_suffix$1(s,suffix)
              ?drop_suffix(s,caml_ml_string_length(suffix))
              :s}
    function chop_suffix_exn(s,suffix)
     {var match=chop_suffix(s,suffix);
      if(! match)return caml_call3(invalid_argf(_ch_),s,suffix,0);
      var str=match[1];
      return str}
    function shorter(a,b)
     {return caml_ml_string_length(a) <= caml_ml_string_length(b)?a:b}
    function shortest(list)
     {if(! list)return cst$20;
      var rest=list[2],first=list[1];
      return fold_left(rest,first,shorter)}
    function pos_from_left(param,i){return i}
    function pos_from_right(t,i)
     {return (caml_ml_string_length(t) - i | 0) - 1 | 0}
    function common_generic2_length_loop(a,b,get_pos,max_len,len_so_far)
     {var len_so_far$0=len_so_far;
      for(;;)
       {if(max_len <= len_so_far$0)return max_len;
        var _Av_=caml_string_unsafe_get(b,caml_call2(get_pos,b,len_so_far$0));
        if
         (!
          caml_call2
           (equal_char$1,
            caml_string_unsafe_get(a,caml_call2(get_pos,a,len_so_far$0)),
            _Av_))
         return len_so_far$0;
        var len_so_far$1=len_so_far$0 + 1 | 0,len_so_far$0=len_so_far$1}}
    function common_generic2_length(a,b,get_pos)
     {var
       max_len=
        caml_call2(min$2,caml_ml_string_length(a),caml_ml_string_length(b));
      return common_generic2_length_loop(a,b,get_pos,max_len,0)}
    function common_generic_length_loop(first,list,get_pos,max_len)
     {var first$0=first,list$0=list,max_len$0=max_len;
      for(;;)
       {if(! list$0)return max_len$0;
        var
         rest=list$0[2],
         second=list$0[1],
         max_len$1=
          common_generic2_length_loop(first$0,second,get_pos,max_len$0,0),
         first$0=second,
         list$0=rest,
         max_len$0=max_len$1}}
    function common_generic_length(list,get_pos)
     {if(! list)return 0;
      var
       rest=list[2],
       first=list[1],
       max_len=caml_ml_string_length(shortest(list));
      return common_generic_length_loop(first,rest,get_pos,max_len)}
    function common_generic2(a,b,get_pos,take)
     {var len=common_generic2_length(a,b,get_pos);
      return caml_call2(take,shorter(a,b),len)}
    function common_generic(list,get_pos,take)
     {if(! list)return cst$22;
      var
       rest=list[2],
       first=list[1],
       s=shortest(list),
       max_len=caml_ml_string_length(s);
      if(0 === max_len)return cst$21;
      var len=common_generic_length_loop(first,rest,get_pos,max_len);
      return caml_call2(take,s,len)}
    function common_prefix(list)
     {return common_generic(list,pos_from_left,prefix)}
    function common_suffix(list)
     {return common_generic(list,pos_from_right,suffix)}
    function common_prefix2(a,b)
     {return common_generic2(a,b,pos_from_left,prefix)}
    function common_suffix2(a,b)
     {return common_generic2(a,b,pos_from_right,suffix)}
    function common_prefix_length(list)
     {return common_generic_length(list,pos_from_left)}
    function common_suffix_length(list)
     {return common_generic_length(list,pos_from_right)}
    function common_prefix2_length(a,b)
     {return common_generic2_length(a,b,pos_from_left)}
    function common_suffix2_length(a,b)
     {return common_generic2_length(a,b,pos_from_right)}
    function pp$7(ppf,string)
     {return caml_call3(Stdlib_Format[129],ppf,_ci_,string)}
    function of_char$0(c){return caml_call2(make$1,1,c)}
    function of_char_list(l)
     {var t=caml_create_bytes(caml_call1(length,l));
      iteri$0(l,function(i,c){return caml_bytes_set(t,i,c)});
      return unsafe_to_string(t)}
    function build_and_validate_escapeworth(escapeworthy_map,escape_char,func)
     {var
       escapeworthy_map$0=
        caml_call3(_aE_[7],escapeworthy_map,equal_char$1,escape_char)
         ?escapeworthy_map
         :[0,[0,escape_char,escape_char],escapeworthy_map],
       arr=caml_make_vect(256,-1),
       vals=caml_make_vect(256,0),
       param=escapeworthy_map$0;
      for(;;)
       {if(! param)return [0,arr];
        var l=param[2],match=param[1],c_to=match[2],c_from=match[1];
        if(919809722 <= func)var v=c_from,k=c_to;else var v=c_to,k=c_from;
        if
         (-1
          ===
          caml_check_bound(arr,k)[1 + k]
          &&
          !
          caml_check_bound(vals,v)[1 + v])
         {caml_check_bound(arr,k)[1 + k] = v;
          caml_check_bound(vals,v)[1 + v] = 1;
          var param=l;
          continue}
        var
         _At_=
          [0,
           [0,
            cst_escapeworthy_map,
            caml_call2
             (sexp_of_t$10,
              caml_call2(sexp_of_pair,sexp_of_t$3,sexp_of_t$3),
              escapeworthy_map$0)],
           0],
         _Au_=[0,[0,cst_c_to,caml_call1(sexp_of_t$3,c_to)],_At_];
        return error_s
                (caml_call2
                  (message,
                   cst_escapeworthy_map_not_one_t,
                   [0,[0,cst_c_from,caml_call1(sexp_of_t$3,c_from)],_Au_]))}}
    function escape_gen(escapeworthy_map,escape_char)
     {var
       x=
        build_and_validate_escapeworth(escapeworthy_map,escape_char,258914209);
      if(0 !== x[0])return x;
      var escapeworthy=x[1];
      return [0,
              function(src)
               {var
                 to_escape_len=[0,0],
                 param=
                  foldi$4
                   (src,
                    0,
                    function(i,acc,c)
                     {var n=caml_check_bound(escapeworthy,c)[1 + c];
                      return -1 === n?acc:(incr(to_escape_len),[0,[0,i,n],acc])});
                if(! param)return src;
                var
                 last_idx=caml_ml_string_length(src),
                 last_dst_pos=last_idx + to_escape_len[1] | 0,
                 dst=caml_create_bytes(last_dst_pos),
                 last_idx$0=last_idx,
                 last_dst_pos$0=last_dst_pos,
                 param$0=param;
                for(;;)
                 {if(param$0)
                   {var
                     to_escape=param$0[2],
                     match=param$0[1],
                     escaped_char=match[2],
                     idx=match[1],
                     len=(last_idx$0 - idx | 0) - 1 | 0,
                     dst_pos=last_dst_pos$0 - len | 0;
                    caml_call5(blit_string,src,idx + 1 | 0,dst,dst_pos,len);
                    var last_dst_pos$1=dst_pos - 2 | 0;
                    caml_bytes_set(dst,last_dst_pos$1,escape_char);
                    caml_bytes_set(dst,last_dst_pos$1 + 1 | 0,escaped_char);
                    var
                     last_idx$0=idx,
                     last_dst_pos$0=last_dst_pos$1,
                     param$0=to_escape;
                    continue}
                  caml_call5(blit_string,src,0,dst,0,last_idx$0);
                  return unsafe_to_string(dst)}}]}
    function escape_gen_exn(escapeworthy_map,escape_char)
     {return ok_exn$0(escape_gen(escapeworthy_map,escape_char))}
    function escape(escapeworthy,escape_char)
     {var
       _As_=dedup_and_sort(escapeworthy,compare_char$0),
       escapeworthy_map=map$9(_As_,function(c){return [0,c,c]});
      return escape_gen_exn(escapeworthy_map,escape_char)}
    function unescape_gen(escapeworthy_map,escape_char)
     {var
       x=
        build_and_validate_escapeworth(escapeworthy_map,escape_char,919809722);
      if(0 !== x[0])return x;
      var escapeworthy=x[1];
      return [0,
              function(src)
               {var i=0,status=-512962225,acc=0;
                for(;;)
                 {if(caml_ml_string_length(src) > i)
                   {var
                     status$0=
                      -512962225 <= status
                       ?caml_call2(equal_char$1,caml_string_get(src,i),escape_char)
                         ?-767030498
                         :-512962225
                       :-244189789,
                     acc$0=-512962225 <= status$0?acc:[0,i,acc],
                     i$0=i + 1 | 0,
                     i=i$0,
                     status=status$0,
                     acc=acc$0;
                    continue}
                  if(! acc)return src;
                  var
                   to_unescape=acc[2],
                   idx=acc[1],
                   dst=
                    caml_create_bytes
                     (caml_ml_string_length(src) - caml_call1(length,acc) | 0),
                   loop=
                    function(last_idx,last_dst_pos,param)
                     {var
                       last_idx$0=last_idx,
                       last_dst_pos$0=last_dst_pos,
                       param$0=param;
                      for(;;)
                       {if(! param$0)
                         return caml_call5(blit_string,src,0,dst,0,last_idx$0);
                        var
                         to_unescape=param$0[2],
                         idx=param$0[1],
                         len=(last_idx$0 - idx | 0) - 2 | 0,
                         dst_pos=last_dst_pos$0 - len | 0;
                        caml_call5(blit_string,src,idx + 2 | 0,dst,dst_pos,len);
                        var
                         dst_pos$0=dst_pos - 1 | 0,
                         _Aq_=caml_string_get(src,idx + 1 | 0),
                         n=caml_check_bound(escapeworthy,_Aq_)[1 + _Aq_],
                         _Ar_=-1 === n?caml_string_get(src,idx + 1 | 0):n;
                        caml_bytes_set(dst,dst_pos$0,_Ar_);
                        var
                         last_idx$0=idx,
                         last_dst_pos$0=dst_pos$0,
                         param$0=to_unescape}};
                  if(idx < (caml_ml_string_length(src) - 1 | 0))
                   loop
                    (caml_ml_string_length(src),caml_ml_bytes_length(dst),acc);
                  else
                   loop
                    (caml_ml_string_length(src) - 1 | 0,
                     caml_ml_bytes_length(dst),
                     to_unescape);
                  return unsafe_to_string(dst)}}]}
    function unescape_gen_exn(escapeworthy_map,escape_char)
     {return ok_exn$0(unescape_gen(escapeworthy_map,escape_char))}
    function unescape(escape_char){return unescape_gen_exn(0,escape_char)}
    function preceding_escape_chars(str,escape_char,pos)
     {var p$1=pos - 1 | 0,p=p$1,cnt=0;
      for(;;)
       {if
         (0
          <=
          p
          &&
          !
          caml_call2(symbol$106,caml_string_get(str,p),escape_char))
         {var cnt$0=cnt + 1 | 0,p$0=p - 1 | 0,p=p$0,cnt=cnt$0;continue}
        return cnt}}
    function update_escape_status(str,escape_char,i,param)
     {return -512962225 <= param
              ?caml_call2(equal_char$1,caml_string_get(str,i),escape_char)
                ?-767030498
                :-512962225
              :-244189789}
    function escape_status(str,escape_char,pos)
     {var
       odd=1 === (preceding_escape_chars(str,escape_char,pos) % 2 | 0)?1:0,
       match=caml_call2(equal_char$1,caml_string_get(str,pos),escape_char);
      return odd?-244189789:match?-767030498:-512962225}
    function check_bound(str,pos,function_name)
     {var
       _Ao_=caml_ml_string_length(str) <= pos?1:0,
       _Ap_=_Ao_ || (pos < 0?1:0);
      return _Ap_?caml_call2(invalid_argf(_cj_),function_name,0):_Ap_}
    function is_char_escaping(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_escaping);
      var match=escape_status(str,escape_char,pos);
      return -512962225 <= match?0:1}
    function is_char_escaped(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_escaped);
      var match=escape_status(str,escape_char,pos);
      return -244189789 <= match?1:0}
    function is_char_literal(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_literal);
      var match=escape_status(str,escape_char,pos);
      return -512962225 === match?1:0}
    function index_from$0(str,escape_char,pos,char$0)
     {check_bound(str,pos,cst_index_from);
      var status$1=escape_status(str,escape_char,pos),i=pos,status=status$1;
      for(;;)
       {if(pos <= i)
         {var _An_=-512962225 === status?1:0;
          if(_An_ && caml_call2(equal_char$1,caml_string_get(str,i),char$0))
           return [0,i]}
        var i$0=i + 1 | 0;
        if(caml_ml_string_length(str) <= i$0)return 0;
        var
         status$0=update_escape_status(str,escape_char,i$0,status),
         i=i$0,
         status=status$0}}
    function index_from_exn$0(str,escape_char,pos,char$0)
     {var match=index_from$0(str,escape_char,pos,char$0);
      if(match){var pos$0=match[1];return pos$0}
      var
       _Ak_=[0,[0,cst_char$0,caml_call1(sexp_of_t$3,char$0)],0],
       _Al_=[0,[0,cst_pos$1,caml_call1(sexp_of_t$4,pos)],_Ak_],
       _Am_=[0,[0,cst_escape_char,caml_call1(sexp_of_t$3,escape_char)],_Al_];
      return raise_s
              (caml_call2
                (message,
                 cst_index_from_exn_not_found,
                 [0,[0,cst_str,caml_call1(sexp_of_t$2,str)],_Am_]))}
    function index$1(str,escape_char,char$0)
     {return index_from$0(str,escape_char,0,char$0)}
    function index_exn$1(str,escape_char,char$0)
     {return index_from_exn$0(str,escape_char,0,char$0)}
    function rindex_from$0(str,escape_char,pos,char$0)
     {check_bound(str,pos,cst_rindex_from);
      if(caml_call2(equal_char$1,char$0,escape_char))return 0;
      var pos$0=pos;
      for(;;)
       {if(0 > pos$0)return 0;
        var escape_chars=preceding_escape_chars(str,escape_char,pos$0);
        if
         (0
          ===
          (escape_chars % 2 | 0)
          &&
          caml_call2(equal_char$1,caml_string_get(str,pos$0),char$0))
         return [0,pos$0];
        var pos$1=(pos$0 - escape_chars | 0) - 1 | 0,pos$0=pos$1}}
    function rindex_from_exn$0(str,escape_char,pos,char$0)
     {var match=rindex_from$0(str,escape_char,pos,char$0);
      if(match){var pos$0=match[1];return pos$0}
      var
       _Ah_=[0,[0,cst_char$1,caml_call1(sexp_of_t$3,char$0)],0],
       _Ai_=[0,[0,cst_pos$2,caml_call1(sexp_of_t$4,pos)],_Ah_],
       _Aj_=[0,[0,cst_escape_char$0,caml_call1(sexp_of_t$3,escape_char)],_Ai_];
      return raise_s
              (caml_call2
                (message,
                 cst_rindex_from_exn_not_found,
                 [0,[0,cst_str$0,caml_call1(sexp_of_t$2,str)],_Aj_]))}
    function rindex$0(str,escape_char,char$0)
     {return is_empty$3(str)
              ?0
              :rindex_from$0
                (str,escape_char,caml_ml_string_length(str) - 1 | 0,char$0)}
    function rindex_exn$0(str,escape_char,char$0)
     {return rindex_from_exn$0
              (str,escape_char,caml_ml_string_length(str) - 1 | 0,char$0)}
    function split_gen$0(str,escape_char,on)
     {if(552554919 <= on[1])
       var l=on[2],is_delim=function(c){return char_list_mem(l,c)};
      else
       var
        c=on[2],
        is_delim=function(c$0){return caml_call2(equal_char$1,c$0,c)};
      var
       len=caml_ml_string_length(str),
       acc=0,
       status=-512962225,
       last_pos=0,
       pos=0;
      for(;;)
       {if(pos === len)
         return rev([0,sub$8(str,last_pos,len - last_pos | 0),acc]);
        var
         status$0=update_escape_status(str,escape_char,pos,status),
         _Ag_=-512962225 === status$0?1:0;
        if(_Ag_ && is_delim(caml_string_get(str,pos)))
         {var
           sub_str=sub$8(str,last_pos,pos - last_pos | 0),
           pos$0=pos + 1 | 0,
           last_pos$0=pos + 1 | 0,
           acc$0=[0,sub_str,acc],
           acc=acc$0,
           status=status$0,
           last_pos=last_pos$0,
           pos=pos$0;
          continue}
        var pos$1=pos + 1 | 0,status=status$0,pos=pos$1}}
    function split$0(str,on)
     {var _Ae_=[0,-1044422954,on];
      return function(_Af_){return split_gen$0(str,_Af_,_Ae_)}}
    function split_on_chars$0(str,chars)
     {var _Ac_=[0,552554919,chars];
      return function(_Ad_){return split_gen$0(str,_Ad_,_Ac_)}}
    function split_at(str,pos)
     {var
       _Ab_=
        sub$8(str,pos + 1 | 0,(caml_ml_string_length(str) - pos | 0) - 1 | 0);
      return [0,sub$8(str,0,pos),_Ab_]}
    function lsplit2$0(str,on,escape_char)
     {function _Aa_(x){return split_at(str,x)}
      return caml_call2(map$16,index$1(str,escape_char,on),_Aa_)}
    function rsplit2$0(str,on,escape_char)
     {function _z$_(x){return split_at(str,x)}
      return caml_call2(map$16,rindex$0(str,escape_char,on),_z$_)}
    function lsplit2_exn$0(str,on,escape_char)
     {return split_at(str,index_exn$1(str,escape_char,on))}
    function rsplit2_exn$0(str,on,escape_char)
     {return split_at(str,rindex_exn$0(str,escape_char,on))}
    function last_non_drop_literal(drop,escape_char,t)
     {return rfindi
              (0,
               t,
               function(i,c)
                {var _z8_=1 - caml_call1(drop,c);
                 if(_z8_)
                  var _z9_=_z8_;
                 else
                  {var _z__=is_char_escaping(t,escape_char,i);
                   if(! _z__)return is_char_escaped(t,escape_char,i);
                   var _z9_=_z__}
                 return _z9_})}
    function first_non_drop_literal(drop,escape_char,t)
     {return lfindi
              (0,
               t,
               function(i,c)
                {var _z5_=1 - caml_call1(drop,c);
                 if(_z5_)
                  var _z6_=_z5_;
                 else
                  {var _z7_=is_char_escaping(t,escape_char,i);
                   if(! _z7_)return is_char_escaped(t,escape_char,i);
                   var _z6_=_z7_}
                 return _z6_})}
    function rstrip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=last_non_drop_literal(drop,escape_char,t);
      if(! match)return cst$23;
      var i=match[1];
      return i === (caml_ml_string_length(t) - 1 | 0)?t:prefix(t,i + 1 | 0)}
    function lstrip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=first_non_drop_literal(drop,escape_char,t);
      if(! match)return cst$24;
      var _z4_=match[1];
      return 0 === _z4_?t:drop_prefix(t,_z4_)}
    function strip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var length=caml_ml_string_length(t);
      if(0 !== length)
       {var switch$0=0;
        if
         (caml_call1(drop,caml_string_get(t,0))
          ||
          caml_call1(drop,caml_string_get(t,length - 1 | 0)))
         switch$0 = 1;
        if(switch$0)
         {var match=first_non_drop_literal(drop,escape_char,t);
          if(! match)return cst$25;
          var
           first=match[1],
           match$0=last_non_drop_literal(drop,escape_char,t);
          if(! match$0)throw [0,Assert_failure$0,_ck_];
          var last=match$0[1];
          return sub$8(t,first,(last - first | 0) + 1 | 0)}}
      return t}
    function between$2(t,low,high)
     {var _z3_=caml_call2(include$8[2],low,t);
      return _z3_?caml_call2(include$8[2],t,high):_z3_}
    function clamp_unchecked$0(t,min,max)
     {return caml_call2(include$8[1],t,min)
              ?min
              :caml_call2(include$8[2],t,max)?t:max}
    function clamp_exn$2(t,min,max)
     {if(caml_call2(include$8[2],min,max))return clamp_unchecked$0(t,min,max);
      throw [0,Assert_failure$0,_cl_]}
    function clamp$2(t,min,max)
     {if(! caml_call2(include$8[5],min,max))
       return [0,clamp_unchecked$0(t,min,max)];
      var _z2_=[0,[0,cst_max$1,caml_call1(sexp_of_t$2,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$1,
                 [0,[0,cst_min$1,caml_call1(sexp_of_t$2,min)],_z2_]))}
    function create$6(opt,pattern)
     {if(opt)var sth=opt[1],case_sensitive=sth;else var case_sensitive=1;
      return create$5(pattern,case_sensitive)}
    var
     symbol$116=include$8[1],
     symbol$117=include$8[2],
     symbol$118=include$8[3],
     symbol$119=include$8[4],
     symbol$120=include$8[5],
     symbol$121=include$8[6],
     ascending$16=include$8[7],
     descending$16=include$8[8],
     compare_string$1=include$8[9],
     equal_string$1=include$8[10],
     max$19=include$8[11],
     min$19=include$8[12],
     Base_String=
      [0,
       t_sexp_grammar$1,
       sub$8,
       subo$2,
       mem$4,
       is_empty$3,
       iter$1,
       fold$3,
       fold_result$4,
       fold_until$4,
       exists$5,
       for_all$5,
       count$4,
       sum$4,
       find$5,
       find_map$4,
       to_list$5,
       to_array$4,
       min_elt$5,
       max_elt$5,
       iteri$4,
       existsi$3,
       for_alli$3,
       counti$3,
       findi$3,
       find_mapi$3,
       hash_fold_t$6,
       t_of_sexp$2,
       sexp_of_t$2,
       of_string$7,
       to_string$8,
       symbol$121,
       symbol$117,
       symbol$119,
       symbol$120,
       symbol$116,
       symbol$118,
       compare_string$1,
       min$19,
       max$19,
       ascending$16,
       descending$16,
       between$2,
       clamp_exn$2,
       clamp$2,
       comparator$3,
       pp$7,
       hashable$1,
       invariant$12,
       max_length,
       make$1,
       copy$1,
       init$4,
       symbol$59,
       concat$0,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$21,
        hash$10,
        t_of_sexp$2,
        sexp_of_t$2,
        t_sexp_grammar$1,
        symbol$110,
        symbol$111,
        symbol$112,
        symbol$113,
        symbol$114,
        symbol$115,
        equal$24,
        compare$37,
        min$18,
        max$18,
        ascending$15,
        descending$15,
        between$1,
        clamp_exn$1,
        clamp$1,
        comparator$4,
        is_suffix$0,
        is_prefix$0,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$30,
        create$6,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private$2],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev$0,
       rev$1,
       is_suffix$1,
       is_prefix$1,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map$23,
       mapi$4,
       foldi$4,
       concat_map$1,
       filter$3,
       filteri$2,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal_string$1,
       of_char$0,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
    caml_register_global(1082,Base_String,"Base__String");
    function pp$8(fmt,t)
     {var _z1_=caml_call1(to_string$2,t);
      return caml_call3(Stdlib_Format[129],fmt,_cm_,_z1_)}
    var
     create$7=caml_create_bytes,
     To_bytes=_a6_([0,caml_ml_bytes_length,create$7,unsafe_blit]),
     blit$4=To_bytes[1],
     blito$2=To_bytes[2],
     unsafe_blit$6=To_bytes[3],
     sub$9=To_bytes[4],
     subo$3=To_bytes[5],
     comparator$5=_P_([0,compare$14,sexp_of_bytes])[1],
     include$49=_v_([0,pp$8,module_name$5]),
     pp$9=include$49[1],
     To_string=Make_to_string([0],To_bytes),
     create$8=caml_create_bytes,
     length$6=caml_ml_bytes_length,
     unsafe_blit$7=caml_blit_string,
     length$7=caml_ml_string_length,
     From_string=_a5_([0,length$7],[0,length$6,create$8,unsafe_blit$7]);
    function invariant$13(param){return 0}
    function init$5(n,f)
     {if(n < 0)caml_call2(invalid_argf(_cn_),n,0);
      var t=caml_create_bytes(n),_zZ_=n - 1 | 0,_zY_=0;
      if(_zZ_ >= 0)
       {var i=_zY_;
        for(;;)
         {caml_bytes_unsafe_set(t,i,caml_call1(f,i));
          var _z0_=i + 1 | 0;
          if(_zZ_ !== i){var i=_z0_;continue}
          break}}
      return t}
    function of_char_list$0(l)
     {var t=caml_create_bytes(caml_call1(length,l));
      iteri$0(l,function(i,c){return caml_bytes_set(t,i,c)});
      return t}
    function to_list$6(t)
     {var i$1=caml_ml_bytes_length(t) - 1 | 0,i=i$1,acc=0;
      for(;;)
       {if(0 > i)return acc;
        var
         acc$0=[0,caml_bytes_unsafe_get(t,i),acc],
         i$0=i - 1 | 0,
         i=i$0,
         acc=acc$0}}
    function to_array$5(t)
     {return caml_call2
              (init,
               caml_ml_bytes_length(t),
               function(i){return caml_bytes_unsafe_get(t,i)})}
    function map$24(t,f){return caml_call2(map$2,f,t)}
    function mapi$5(t,f){return caml_call2(mapi$0,f,t)}
    function fold$4(t,init,f)
     {var len=caml_ml_bytes_length(t),pos=0,acc=init;
      for(;;)
       {if(pos === len)return acc;
        var
         acc$0=caml_call2(f,acc,caml_bytes_unsafe_get(t,pos)),
         pos$0=pos + 1 | 0,
         pos=pos$0,
         acc=acc$0}}
    function foldi$5(t,init,f)
     {var len=caml_ml_bytes_length(t),pos=0,acc=init;
      for(;;)
       {if(pos === len)return acc;
        var
         acc$0=caml_call3(f,pos,acc,caml_bytes_unsafe_get(t,pos)),
         pos$0=pos + 1 | 0,
         pos=pos$0,
         acc=acc$0}}
    function tr$0(target,replacement,s)
     {var _zW_=caml_ml_bytes_length(s) - 1 | 0,_zV_=0;
      if(_zW_ >= 0)
       {var i=_zV_;
        for(;;)
         {if(caml_call2(equal_char$1,caml_bytes_unsafe_get(s,i),target))
           caml_bytes_unsafe_set(s,i,replacement);
          var _zX_=i + 1 | 0;
          if(_zW_ !== i){var i=_zX_;continue}
          break}}
      return 0}
    function tr_multi$0(target,replacement)
     {if(0 === caml_ml_string_length(target))return function(_zU_){return 0};
      if(0 === caml_ml_string_length(replacement))
       return caml_call1(invalid_arg$0,cst_tr_multi_replacement_is_th);
      var match=tr_create_map(target,replacement);
      if(! match)return function(_zT_){return 0};
      var tr_map=match[1];
      return function(s)
       {var _zR_=caml_ml_bytes_length(s) - 1 | 0,_zQ_=0;
        if(_zR_ >= 0)
         {var i=_zQ_;
          for(;;)
           {caml_bytes_unsafe_set
             (s,i,caml_string_unsafe_get(tr_map,caml_bytes_unsafe_get(s,i)));
            var _zS_=i + 1 | 0;
            if(_zR_ !== i){var i=_zS_;continue}
            break}}
        return 0}}
    function between$3(t,low,high)
     {var _zP_=caml_call2(include$9[2],low,t);
      return _zP_?caml_call2(include$9[2],t,high):_zP_}
    function clamp_unchecked$1(t,min,max)
     {return caml_call2(include$9[1],t,min)
              ?min
              :caml_call2(include$9[2],t,max)?t:max}
    function clamp_exn$3(t,min,max)
     {if(caml_call2(include$9[2],min,max))return clamp_unchecked$1(t,min,max);
      throw [0,Assert_failure$0,_co_]}
    function clamp$3(t,min,max)
     {if(! caml_call2(include$9[5],min,max))
       return [0,clamp_unchecked$1(t,min,max)];
      var _zO_=[0,[0,cst_max$2,caml_call1(sexp_of_bytes,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$2,
                 [0,[0,cst_min$2,caml_call1(sexp_of_bytes,min)],_zO_]))}
    function contains$0(pos,len,t,char$0)
     {var
       match=get_pos_len_exn(pos,len,0,caml_ml_bytes_length(t)),
       len$0=match[2],
       pos$0=match[1],
       last=pos$0 + len$0 | 0,
       i=pos$0;
      for(;;)
       {var _zL_=i < last?1:0;
        if(_zL_)
         {var _zM_=caml_call2(equal_char$1,caml_bytes_get(t,i),char$0);
          if(! _zM_){var i$0=i + 1 | 0,i=i$0;continue}
          var _zN_=_zM_}
        else
         var _zN_=_zL_;
        return _zN_}}
    var
     symbol$122=include$9[1],
     symbol$123=include$9[2],
     symbol$124=include$9[3],
     symbol$125=include$9[4],
     symbol$126=include$9[5],
     symbol$127=include$9[6],
     ascending$17=include$9[7],
     descending$17=include$9[8],
     compare_bytes=include$9[9],
     equal_bytes=include$9[10],
     max$20=include$9[11],
     min$20=include$9[12],
     Base_Bytes=
      [0,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       blit$4,
       blito$2,
       unsafe_blit$6,
       sub$9,
       subo$3,
       symbol$127,
       symbol$123,
       symbol$125,
       symbol$126,
       symbol$122,
       symbol$124,
       equal_bytes,
       compare_bytes,
       min$20,
       max$20,
       ascending$17,
       descending$17,
       between$3,
       clamp_exn$3,
       clamp$3,
       comparator$5,
       of_string$1,
       to_string$2,
       pp$9,
       invariant$13,
       To_string,
       From_string,
       create$1,
       make,
       map$24,
       mapi$5,
       copy$0,
       init$5,
       of_char_list$0,
       caml_bytes_get,
       caml_bytes_set,
       fill$0,
       tr$0,
       tr_multi$0,
       to_list$6,
       to_array$5,
       fold$4,
       foldi$5,
       contains$0,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
    caml_register_global(1083,Base_Bytes,"Base__Bytes");
    function parse_hex(lexbuf)
     {var ocaml_lex_state=0;
      for(;;)
       {var
         ocaml_lex_state$0=
          caml_call3
           (Stdlib_Lexing[20],ocaml_lex_tables,ocaml_lex_state,lexbuf);
        if(0 === ocaml_lex_state$0)
         {var
           body=
            caml_call3(Stdlib_Lexing[16],lexbuf,lexbuf[5] + 3 | 0,lexbuf[6]);
          return [0,body]}
        if(1 === ocaml_lex_state$0)
         {var
           body$0=
            caml_call3(Stdlib_Lexing[16],lexbuf,lexbuf[5] + 2 | 0,lexbuf[6]);
          return [1,body$0]}
        caml_call1(lexbuf[1],lexbuf);
        var ocaml_lex_state=ocaml_lex_state$0}}
    var Base_Hex_lexer=[0,parse_hex];
    caml_register_global(1085,Base_Hex_lexer,"Base__Hex_lexer");
    function convert_failure(x,a,b,to_string)
     {var _zK_=caml_call1(to_string,x);
      return caml_call4(failwithf(_cp_),a,b,_zK_,0)}
    var
     num_bits_nativeint=num_bits$0(word_size),
     num_bits_int32=32,
     num_bits_int64=64;
    if(63 !== num_bits && 31 !== num_bits && 32 !== num_bits)
     throw [0,Assert_failure$0,_lB_];
    var
     _cq_=Stdlib_Int32[10],
     _cr_=Stdlib_Int32[9],
     _cy_=Stdlib_Int64[14],
     _cz_=Stdlib_Nativeint[15],
     _cs_=Stdlib_Int64[10],
     _ct_=Stdlib_Int64[9],
     _cu_=Stdlib_Nativeint[11],
     _cv_=Stdlib_Nativeint[10],
     _cw_=Caml$0[32],
     _cx_=Stdlib_Int32[14];
    function int32_to_int_trunc(_zJ_){return _zJ_}
    function int_to_int32_trunc(_zI_){return _zI_}
    var
     _cA_=
      num_bits <= 32
       ?function(param){return 1}
       :function(x)
         {var
           _zG_=caml_call2(compare$10,_cq_,x) <= 0?1:0,
           _zH_=_zG_?caml_call2(compare$10,x,_cr_) <= 0?1:0:_zG_;
          return _zH_},
     _cB_=
      32 <= num_bits
       ?function(param){return 1}
       :function(x)
         {var
           _zE_=caml_call2(compare$11,min_value$0,x) <= 0?1:0,
           _zF_=_zE_?caml_call2(compare$11,x,max_value$0) <= 0?1:0:_zE_;
          return _zF_};
    function int_to_int32(x){return _cA_(x)?[0,x]:0}
    function int32_to_int(x){return _cB_(x)?[0,x]:0}
    function int_to_int32_exn(x)
     {return _cA_(x)?x:convert_failure(x,cst_int$0,cst_int32$0,_cw_)}
    function int32_to_int_exn(x)
     {return _cB_(x)?x:convert_failure(x,cst_int32$1,cst_int$1,_cx_)}
    if(num_bits >= 64)throw [0,Assert_failure$0,_lA_];
    var
     int_to_int64=caml_int64_of_int32,
     int64_to_int_trunc=caml_int64_to_int32,
     min$21=caml_int64_of_int32(min_value$0),
     max$21=caml_int64_of_int32(max_value$0);
    function int64_is_representable_as_int(x)
     {var
       _zC_=caml_call2(compare$12,min$21,x) <= 0?1:0,
       _zD_=_zC_?caml_call2(compare$12,x,max$21) <= 0?1:0:_zC_;
      return _zD_}
    function int64_to_int(x)
     {return int64_is_representable_as_int(x)?[0,caml_int64_to_int32(x)]:0}
    function int64_to_int_exn(x)
     {return int64_is_representable_as_int(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$0,cst_int$2,_cy_)}
    if(num_bits > num_bits_nativeint)throw [0,Assert_failure$0,_lz_];
    function int_to_nativeint(_zB_){return _zB_}
    function nativeint_to_int_trunc(_zA_){return _zA_}
    var
     _cC_=
      num_bits_nativeint <= num_bits
       ?function(param){return 1}
       :function(x)
         {var
           _zy_=caml_call2(compare$13,min_value$0,x) <= 0?1:0,
           _zz_=_zy_?caml_call2(compare$13,x,max_value$0) <= 0?1:0:_zy_;
          return _zz_};
    function nativeint_to_int(x){return _cC_(x)?[0,x]:0}
    function nativeint_to_int_exn(x)
     {return _cC_(x)?x:convert_failure(x,cst_nativeint$0,cst_int$3,_cz_)}
    var
     int32_to_int64=caml_int64_of_int32,
     int64_to_int32_trunc=caml_int64_to_int32,
     min$22=caml_int64_of_int32(_cq_),
     max$22=caml_int64_of_int32(_cr_);
    function int64_is_representable_as_int3(x)
     {var
       _zw_=caml_call2(compare$12,min$22,x) <= 0?1:0,
       _zx_=_zw_?caml_call2(compare$12,x,max$22) <= 0?1:0:_zw_;
      return _zx_}
    function int64_to_int32(x)
     {return int64_is_representable_as_int3(x)?[0,caml_int64_to_int32(x)]:0}
    function int64_to_int32_exn(x)
     {return int64_is_representable_as_int3(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$1,cst_int32$2,_cy_)}
    if(32 > num_bits_nativeint)throw [0,Assert_failure$0,_ly_];
    function int32_to_nativeint(_zv_){return _zv_}
    function nativeint_to_int32_trunc(_zu_){return _zu_}
    var
     _cD_=
      num_bits_nativeint <= 32
       ?function(param){return 1}
       :function(x)
         {var
           _zs_=caml_call2(compare$13,_cq_,x) <= 0?1:0,
           _zt_=_zs_?caml_call2(compare$13,x,_cr_) <= 0?1:0:_zs_;
          return _zt_};
    function nativeint_to_int32(x){return _cD_(x)?[0,x]:0}
    function nativeint_to_int32_exn(x)
     {return _cD_(x)?x:convert_failure(x,cst_nativeint$1,cst_int32$3,_cz_)}
    if(num_bits_nativeint > 64)throw [0,Assert_failure$0,_lx_];
    var
     int64_to_nativeint_trunc=caml_int64_to_int32,
     nativeint_to_int64=caml_int64_of_int32;
    if(64 <= num_bits_nativeint)
     var _cE_=function(param){return 1};
    else
     var
      min$38=caml_int64_of_int32(_cu_),
      max$39=caml_int64_of_int32(_cv_),
      _cE_=
       function(x)
        {var
          _zq_=caml_call2(compare$12,min$38,x) <= 0?1:0,
          _zr_=_zq_?caml_call2(compare$12,x,max$39) <= 0?1:0:_zq_;
         return _zr_};
    function to_nativeint(x){return _cE_(x)?[0,caml_int64_to_int32(x)]:0}
    function to_nativeint_exn(x)
     {return _cE_(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$2,cst_nativeint$2,_cy_)}
    var
     min$23=caml_int64_shift_right(_cs_,1),
     max$23=caml_int64_shift_right(_ct_,1);
    function int64_is_representable_as_int6(x)
     {var
       _zo_=caml_call2(compare$12,min$23,x) <= 0?1:0,
       _zp_=_zo_?caml_call2(compare$12,x,max$23) <= 0?1:0:_zo_;
      return _zp_}
    function int64_fit_on_int63_exn(x)
     {return int64_is_representable_as_int6(x)
              ?0
              :convert_failure(x,cst_int64$3,cst_int63,_cy_)}
    function insert_delimiter_every(input,delimiter,chars_per_delimiter)
     {var input_length=caml_ml_string_length(input);
      if(input_length <= chars_per_delimiter)return input;
      var match=caml_string_get(input,0),switch$0=0;
      if(43 !== match && 45 !== match){var has_sign=0;switch$0 = 1}
      if(! switch$0)var has_sign=1;
      var
       num_digits=has_sign?input_length - 1 | 0:input_length,
       num_delimiters=caml_div(num_digits - 1 | 0,chars_per_delimiter),
       output_length=input_length + num_delimiters | 0,
       output=caml_create_bytes(output_length),
       input_pos=[0,input_length - 1 | 0],
       output_pos=[0,output_length - 1 | 0],
       num_chars_until_delimiter=[0,chars_per_delimiter],
       first_digit_pos=has_sign?1:0;
      for(;;)
       {if(first_digit_pos > input_pos[1])
         {if(has_sign)caml_bytes_set(output,0,caml_string_get(input,0));
          return unsafe_to_string(output)}
        if(0 === num_chars_until_delimiter[1])
         {caml_bytes_set(output,output_pos[1],delimiter);
          decr(output_pos);
          num_chars_until_delimiter[1] = chars_per_delimiter}
        var _zn_=caml_string_get(input,input_pos[1]);
        caml_bytes_set(output,output_pos[1],_zn_);
        decr(input_pos);
        decr(output_pos);
        decr(num_chars_until_delimiter)}}
    function insert_delimiter(input,delimiter)
     {return insert_delimiter_every(input,delimiter,3)}
    function insert_underscores(input){return insert_delimiter(input,95)}
    function _cG_(I)
     {var compare=I[1],hash_fold_t=I[2],func=I[3];
      function hash(x){return caml_call1(func,x)}
      var chars_per_delimiter=4;
      function to_string(delimiter,t)
       {if(delimiter)
         var
          delimiter$0=delimiter[1],
          make_suffix=
           function(t)
            {return insert_delimiter_every
                     (caml_call1(I[4],t),delimiter$0,chars_per_delimiter)};
        else
         var make_suffix=I[4];
        return caml_call2(I[7],t,I[6])
                ?caml_call2
                  (symbol$59,
                   cst_0x,
                   caml_call1(make_suffix,caml_call1(I[8],t)))
                :caml_call2(symbol$59,cst_0x$0,caml_call1(make_suffix,t))}
      function to_string$0(t){return to_string(0,t)}
      function to_string_hum(opt,t)
       {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
        return to_string([0,delimiter],t)}
      function invalid(str)
       {var _zm_=I[9];return caml_call3(failwithf(_cF_),_zm_,str,0)}
      function of_string_with_delimiter(str)
       {var
         _zl_=
          filter$3(str,function(c){return caml_call2(symbol$106,c,95)});
        return caml_call1(I[5],_zl_)}
      function of_string(str)
       {var
         lex=caml_call2(Stdlib_Lexing[3],0,str),
         result=try_with$1(function(param){return parse_hex(lex)});
        if(lex[6] !== lex[3])return invalid(str);
        if(! result)return invalid(str);
        var _zj_=result[1];
        if(0 === _zj_[0])
         {var body=_zj_[1],_zk_=of_string_with_delimiter(body);
          return caml_call1(I[8],_zk_)}
        var body$0=_zj_[1];
        return of_string_with_delimiter(body$0)}
      var
       t_sexp_grammar=caml_call1(Sexplib0_Sexp_grammar[1],t_sexp_grammar$1),
       include=Of_stringable([0,of_string,to_string$0]),
       t_of_sexp=include[1],
       sexp_of_t=include[2];
      return [0,
              [0,
               t_of_sexp,
               sexp_of_t,
               t_sexp_grammar,
               compare,
               hash_fold_t,
               hash,
               of_string,
               to_string$0,
               to_string_hum]]}
    function _cH_(I)
     {var chars_per_delimiter=3;
      function to_string_hum(opt,t)
       {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
        return insert_delimiter_every
                (caml_call1(I[1],t),delimiter,chars_per_delimiter)}
      function sexp_of_t(t)
       {var
         s=caml_call1(I[1],t),
         s$0=
          1009018843 <= of_int_style[1]
           ?s
           :insert_delimiter_every(s,95,chars_per_delimiter);
        return [0,s$0]}
      return [0,to_string_hum,sexp_of_t]}
    var
     Base_Int_conversions=
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       to_nativeint,
       to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       _cH_,
       _cG_,
       of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
    caml_register_global(1086,Base_Int_conversions,"Base__Int_conversions");
    var Base_Intable=[0];
    caml_register_global(1087,Base_Intable,"Base__Intable");
    var Base_Int_intf=[0];
    caml_register_global(1088,Base_Int_intf,"Base__Int_intf");
    var
     int32_positive_overflow_bounds=_cI_.slice(),
     switcher=num_bits - 31 | 0,
     overflow_bound_max_int32_value=2147483647,
     overflow_bound_max_int_value=2147483647;
    if(1 < switcher >>> 0)
     {if(32 !== switcher)throw [0,Assert_failure$0,_lv_];
      var
       int_positive_overflow_bounds=
        [0,
         caml_int64_to_int32(_cL_),
         caml_int64_to_int32(_cK_),
         caml_int64_to_int32(_cJ_),
         1664510,
         46340,
         5404,
         1290,
         463,
         215,
         118,
         73,
         49,
         35,
         27,
         21,
         17,
         14,
         12,
         10,
         9,
         8,
         7,
         7,
         6,
         5,
         5,
         5,
         4,
         4,
         4,
         4,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         1,
         1]}
    else
     var
      int_positive_overflow_bounds=
       switcher
        ?map(int32_positive_overflow_bounds,function(_zi_){return _zi_})
        :_lw_.slice();
    var
     int63_on_int64_positive_overfl=_cM_.slice(),
     int64_positive_overflow_bounds=_cN_.slice(),
     int64_negative_overflow_bounds=_cO_.slice(),
     Base_Pow_overflow_bounds=
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
    caml_register_global
     (1089,Base_Pow_overflow_bounds,"Base__Pow_overflow_bounds");
    function negative_exponent(param){return caml_call1(invalid_argf(_cP_),0)}
    function overflow(param){return caml_call1(invalid_argf(_cQ_),0)}
    function int_pow(base,exponent)
     {if(exponent < 0)negative_exponent(0);
      var _ze_=1 < caml_call1(abs$0,base)?1:0;
      if(_ze_)
       {var _zf_=63 < exponent?1:0;
        if(_zf_)
         var _zg_=_zf_;
        else
         var
          _zh_=
           caml_check_bound(int_positive_overflow_bounds,exponent)
            [1 + exponent],
          _zg_=_zh_ < caml_call1(abs$0,base)?1:0}
      else
       var _zg_=_ze_;
      if(_zg_)overflow(0);
      return runtime.Base_int_math_int_pow_stub(base,exponent)}
    var abs$1=Stdlib_Int64[8];
    function int64_pow(base,exponent)
     {if(caml_lessthan(exponent,_cR_))negative_exponent(0);
      var
       _y7_=caml_greaterthan(base,_cS_),
       _y8_=_y7_ || caml_lessthan(base,_cW_);
      if(_y8_)
       {var _y9_=caml_greaterthan(exponent,_cT_);
        if(_y9_)
         var _y__=_y9_;
        else
         {var _y$_=caml_greaterequal(base,_cU_);
          if(_y$_)
           var
            _za_=caml_int64_to_int32(exponent),
            _zb_=
             caml_greaterthan
              (base,
               caml_check_bound(int64_positive_overflow_bounds,_za_)[1 + _za_]);
          else
           var _zb_=_y$_;
          if(_zb_)
           var _y__=_zb_;
          else
           {var _zc_=caml_lessthan(base,_cV_);
            if(_zc_)
             var
              _zd_=caml_int64_to_int32(exponent),
              _y__=
               caml_lessthan
                (base,
                 caml_check_bound(int64_negative_overflow_bounds,_zd_)
                  [1 + _zd_]);
            else
             var _y__=_zc_}}}
      else
       var _y__=_y8_;
      if(_y__)overflow(0);
      return runtime.Base_int_math_int64_pow_stub(base,exponent)}
    function int63_pow_on_int64(base,exponent)
     {if(caml_lessthan(exponent,_cX_))negative_exponent(0);
      var _y2_=caml_greaterthan(caml_call1(abs$1,base),_cY_);
      if(_y2_)
       {var _y3_=caml_greaterthan(exponent,_cZ_);
        if(_y3_)
         var _y4_=_y3_;
        else
         var
          _y5_=caml_int64_to_int32(exponent),
          _y6_=caml_check_bound(int63_on_int64_positive_overfl,_y5_)[1 + _y5_],
          _y4_=caml_greaterthan(caml_call1(abs$1,base),_y6_)}
      else
       var _y4_=_y2_;
      if(_y4_)overflow(0);
      return runtime.Base_int_math_int64_pow_stub(base,exponent)}
    var Private$3=[0,int_pow,int64_pow,int63_pow_on_int64];
    function _c2_(X)
     {function symbol(x,y)
       {if(caml_call2(X[11],y,X[18]))
         {var _y0_=caml_call1(X[4],y),_y1_=caml_call1(X[4],x);
          caml_call3(invalid_argf(_c0_),_y1_,_y0_,0)}
        var rval=caml_call2(X[20],x,y);
        return caml_call2(X[14],rval,X[18])?caml_call2(X[5],rval,y):rval}
      var one=caml_call1(X[19],1);
      function symbol$0(x,y)
       {if(caml_call2(X[11],y,X[18]))
         {var _yW_=caml_call1(X[4],y),_yX_=caml_call1(X[4],x);
          caml_call3(invalid_argf(_c1_),_yX_,_yW_,0)}
        if(! caml_call2(X[14],x,X[18]))return caml_call2(X[8],x,y);
        var _yY_=caml_call2(X[5],x,one),_yZ_=caml_call2(X[8],_yY_,y);
        return caml_call2(X[6],_yZ_,one)}
      function symbol$1(x,y)
       {var _yV_=caml_call1(X[2],y);return caml_call1(X[2],x) / _yV_}
      function round_down(i,modulus)
       {var _yU_=symbol(i,modulus);return caml_call2(X[6],i,_yU_)}
      function round_up(i,modulus)
       {var remainder=symbol(i,modulus);
        if(caml_call2(X[12],remainder,X[18]))return i;
        var _yT_=caml_call2(X[5],i,modulus);
        return caml_call2(X[6],_yT_,remainder)}
      function round_towards_zero(i,to_multiple_of)
       {return caml_call2(X[12],i,X[18])
                ?X[18]
                :caml_call2(X[13],i,X[18])
                  ?round_down(i,to_multiple_of)
                  :round_up(i,to_multiple_of)}
      function round_nearest(i,modulus)
       {var
         remainder=symbol(i,modulus),
         modulus_minus_remainder=caml_call2(X[6],modulus,remainder);
        return caml_call2(X[11],modulus_minus_remainder,remainder)
                ?caml_call2(X[5],i,modulus_minus_remainder)
                :caml_call2(X[6],i,remainder)}
      function round(opt,i,to_multiple_of)
       {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
        return 857423934 <= dir
                ?1003109192 <= dir
                  ?round_towards_zero(i,to_multiple_of)
                  :round_nearest(i,to_multiple_of)
                :759637122 <= dir
                  ?round_down(i,to_multiple_of)
                  :round_up(i,to_multiple_of)}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              round,
              round_towards_zero,
              round_down,
              round_up,
              round_nearest]}
    var Base_Int_math=[0,_c2_,Private$3];
    caml_register_global(1090,Base_Int_math,"Base__Int_math");
    function int64_popcount(x)
     {var
       x$0=
        caml_int64_sub
         (x,caml_int64_and(caml_int64_shift_right_unsigne(x,1),m1)),
       x$1=
        caml_int64_add
         (caml_int64_and(x$0,m2),
          caml_int64_and(caml_int64_shift_right_unsigne(x$0,2),m2)),
       x$2=
        caml_int64_and
         (caml_int64_add(x$1,caml_int64_shift_right_unsigne(x$1,4)),m4);
      return caml_int64_to_int32
              (caml_int64_shift_right_unsigne(caml_int64_mul(x$2,h01),56))}
    function int32_popcount(x)
     {return int64_popcount(caml_int64_and(caml_int64_of_int32(x),mask))}
    var _c3_=Stdlib_Nativeint[9];
    if(32 === _c3_)
     var popcount=function(x){return int32_popcount(x)};
    else
     {if(64 !== _c3_)throw [0,Assert_failure$0,_lu_];
      var popcount=function(x){return int64_popcount(caml_int64_of_int32(x))}}
    function popcount$0(_yS_){return runtime.Base_int_math_int_popcount(_yS_)}
    var Base_Popcount=[0,popcount$0,int32_popcount,int64_popcount,popcount];
    caml_register_global(1091,Base_Popcount,"Base__Popcount");
    var
     _c4_=
      _a1_
       ([0,
         compare$26,
         hash_fold_t$18,
         to_int$1,
         t_of_sexp$17,
         sexp_of_t$24,
         of_string$3,
         to_string$4,
         module_name$2]),
     hash_fold_t$22=_c4_[1],
     hash$11=_c4_[2],
     t_of_sexp$20=_c4_[3],
     sexp_of_t$32=_c4_[4],
     of_string$8=_c4_[5],
     to_string$9=_c4_[6],
     between$4=_c4_[19],
     clamp_exn$4=_c4_[20],
     clamp$4=_c4_[21],
     comparator$6=_c4_[22],
     pp$10=_c4_[23],
     hashable$2=_c4_[24];
    function to_float$0(param)
     {switch(param){case 0:return -1.;case 1:return 0.;default:return 1.}}
    function flip$0(param)
     {switch(param){case 0:return 2;case 1:return 1;default:return 0}}
    function symbol$128(t$0,t)
     {var _yR_=to_int$1(t);return sign(caml_mul(to_int$1(t$0),_yR_))}
    var
     symbol$129=Replace_polymorphic_compare[1],
     symbol$130=Replace_polymorphic_compare[2],
     symbol$131=Replace_polymorphic_compare[3],
     symbol$132=Replace_polymorphic_compare[4],
     symbol$133=Replace_polymorphic_compare[5],
     symbol$134=Replace_polymorphic_compare[6],
     ascending$18=Replace_polymorphic_compare[7],
     descending$18=Replace_polymorphic_compare[8],
     compare$38=Replace_polymorphic_compare[9],
     equal$25=Replace_polymorphic_compare[10],
     max$24=Replace_polymorphic_compare[11],
     min$24=Replace_polymorphic_compare[12],
     Base_Sign=
      [0,
       all$6,
       t_sexp_grammar$17,
       hash_fold_t$22,
       hash$11,
       t_of_sexp$20,
       sexp_of_t$32,
       of_string$8,
       to_string$9,
       symbol$134,
       symbol$130,
       symbol$132,
       symbol$133,
       symbol$129,
       symbol$131,
       equal$25,
       compare$38,
       min$24,
       max$24,
       ascending$18,
       descending$18,
       between$4,
       clamp_exn$4,
       clamp$4,
       comparator$6,
       pp$10,
       hashable$2,
       sign,
       to_int$1,
       to_float$0,
       flip$0,
       symbol$128];
    caml_register_global(1092,Base_Sign,"Base__Sign");
    function func$8(x){return caml_call1(func$3,x)}
    var
     hashable$3=[0,func$8,caml_int_compare,sexp_of_t$4],
     compare$39=caml_int_compare;
    function of_string$9(s)
     {try
       {var _yP_=caml_int_of_string(s);return _yP_}
      catch(_yQ_){return caml_call2(failwithf(_c5_),s,0)}}
    var
     float_lower_bound=lower_bound_for_int(num_bits),
     float_upper_bound=upper_bound_for_int(num_bits);
    function of_int$2(_yO_){return _yO_}
    function of_float_unchecked(_yN_){return _yN_ | 0}
    function to_int$3(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound)
        &&
        caml_call2(include$7[2],f,float_upper_bound))
       return f | 0;
      return caml_call2(invalid_argf(_c6_),f + 0.,0)}
    var
     comparator$7=_P_([0,compare$39,sexp_of_t$4])[1],
     _c7_=_aY_([0,compare$39,sexp_of_t$4,0]),
     is_positive=_c7_[1],
     is_non_negative=_c7_[2],
     is_negative=_c7_[3],
     is_non_positive=_c7_[4],
     include$50=_cH_([0,to_string]),
     to_string_hum$1=include$50[1],
     sexp_of_t$33=include$50[2],
     zero=0,
     one=1,
     minus_one=-1;
    function hash$12(x){return caml_call1(func$3,x)}
    function symbol$135(_yM_,_yL_){return _yM_ < _yL_?1:0}
    function to_string$10(i){return caml_call2(sprintf,_c8_,i)}
    function of_string$10(s)
     {function _yJ_(_yK_){return _yK_}
      return caml_call3(Stdlib_Scanf[4],s,_c9_,_yJ_)}
    var
     include$51=
      _cG_
       ([0,
         compare$10,
         hash_fold_t$4,
         hash$12,
         to_string$10,
         of_string$10,
         zero,
         symbol$135,
         neg,
         module_name$6]),
     Hex=include$51[1],
     include$52=_w_([0,module_name$7,to_string]),
     pp$11=include$52[1];
    function invariant$14(param){return 0}
    function between$5(t,low,high)
     {var _yH_=low <= t?1:0,_yI_=_yH_?t <= high?1:0:_yH_;return _yI_}
    function clamp_unchecked$2(t,min,max){return t < min?min:t <= max?t:max}
    function clamp_exn$5(t,min,max)
     {if(min <= max)return clamp_unchecked$2(t,min,max);
      throw [0,Assert_failure$0,_c__]}
    function clamp$5(t,min,max)
     {if(max >= min)return [0,clamp_unchecked$2(t,min,max)];
      var _yG_=[0,[0,cst_max$3,caml_call1(sexp_of_t$4,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$3,
                 [0,[0,cst_min$3,caml_call1(sexp_of_t$4,min)],_yG_]))}
    function pred$0(i){return i - 1 | 0}
    function succ$1(i){return i + 1 | 0}
    function to_int_exn(i){return i}
    function of_int$3(i){return i}
    var
     max_value$2=Caml$0[18],
     min_value$2=Caml$0[19],
     max_value_30_bits=1073741823;
    function abs$2(x){return caml_call1(abs$0,x)}
    var rem=caml_mod;
    function incr$0(_yF_){_yF_[1]++;return 0}
    function decr$0(_yE_){_yE_[1] += -1;return 0}
    function shift_right$0(a,b){return a >> b}
    function shift_right_logical(a,b){return a >>> b | 0}
    function shift_left(a,b){return a << b}
    function bit_not(a){return caml_call1(lnot$0,a)}
    function bit_or(a,b){return a | b}
    function bit_and(a,b){return a & b}
    function bit_xor(a,b){return a ^ b}
    var pow=Private$3[1];
    function symbol$136(b,e){return caml_call2(pow,b,e)}
    function non_positive_argument(param)
     {return caml_call1(invalid_argf(_c$_),0)}
    function ceil_pow2(x)
     {if(x <= 0)non_positive_argument(0);
      var
       x$0=x - 1 | 0,
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0,
       x$6=x$5 | x$5 >>> 32 | 0;
      return x$6 + 1 | 0}
    function floor_pow2(x)
     {if(x <= 0)non_positive_argument(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0,
       x$5=x$4 | x$4 >>> 32 | 0;
      return x$5 - (x$5 >>> 1 | 0) | 0}
    function is_pow2(x)
     {if(x <= 0)non_positive_argument(0);return 0 === (x & (x - 1 | 0))?1:0}
    function floor_log2(i)
     {if(i <= 0)
       raise_s
        (caml_call2
          (message,
           cst_Int_floor_log2_got_invalid,
           [0,[0,cst$26,caml_call1(sexp_of_t$4,i)],0]));
      return (num_bits - 1 | 0) - runtime.Base_int_math_int_clz(i) | 0}
    function ceil_log2(i)
     {if(i <= 0)
       raise_s
        (caml_call2
          (message,
           cst_Int_ceil_log2_got_invalid_,
           [0,[0,cst$27,caml_call1(sexp_of_t$4,i)],0]));
      return 1 === i?0:num_bits - runtime.Base_int_math_int_clz(i - 1 | 0) | 0}
    function _da_(_yD_){return - _yD_ | 0}
    function _db_(_yC_,_yB_){return _yC_ !== _yB_?1:0}
    function _dc_(_yA_,_yz_){return _yA_ < _yz_?1:0}
    function _dd_(_yy_,_yx_){return _yx_ < _yy_?1:0}
    function _de_(_yw_,_yv_){return _yw_ === _yv_?1:0}
    function _df_(_yu_,_yt_){return _yu_ <= _yt_?1:0}
    function _dg_(_ys_,_yr_){return _yr_ <= _ys_?1:0}
    function _dh_(_yq_){return - _yq_ | 0}
    var _di_=caml_div,_dj_=caml_mul;
    function _dk_(_yp_,_yo_){return _yp_ - _yo_ | 0}
    var
     F$0=
      _c2_
       ([0,
         to_int$3,
         of_int$2,
         of_string$9,
         to_string,
         function(_yn_,_ym_){return _yn_ + _ym_ | 0},
         _dk_,
         _dj_,
         _di_,
         _dh_,
         _dg_,
         _df_,
         _de_,
         _dd_,
         _dc_,
         _db_,
         abs$2,
         _da_,
         zero,
         of_int$3,
         rem]),
     round=F$0[4],
     round_towards_zero=F$0[5],
     round_down=F$0[6],
     round_up=F$0[7],
     round_nearest=F$0[8];
    function symbol$137(x,y)
     {if(y <= 0)
       {var _yk_=caml_call1(to_string,y),_yl_=caml_call1(to_string,x);
        caml_call3(invalid_argf(_dl_),_yl_,_yk_,0)}
      var rval=caml_mod(x,y);
      return rval < 0?rval + y | 0:rval}
    function symbol$138(x,y)
     {if(y <= 0)
       {var _yi_=caml_call1(to_string,y),_yj_=caml_call1(to_string,x);
        caml_call3(invalid_argf(_dm_),_yj_,_yi_,0)}
      return x < 0?caml_div(x + 1 | 0,y) - 1 | 0:caml_div(x,y)}
    function symbol$139(x,y){return x / y}
    var
     ascending$19=include$1[1],
     descending$19=include$1[2],
     max$25=include$1[3],
     min$25=include$1[4],
     Private$4=[0,[0,F$0[1],F$0[2],F$0[3]]],
     O$0=[0,symbol$136,lnot$0,abs$2,zero,symbol$137,symbol$138,symbol$139];
    function ctz(_yh_){return runtime.Base_int_math_int_ctz(_yh_)}
    function clz(_yg_){return runtime.Base_int_math_int_clz(_yg_)}
    var compare_int$0=caml_int_compare;
    function equal_int$1(_yf_,_ye_){return _yf_ === _ye_?1:0}
    var
     include$53=
      [0,
       t_sexp_grammar$3,
       to_int$3,
       of_int$2,
       of_int$3,
       to_int_exn,
       hash_fold_t$4,
       func$8,
       t_of_sexp$4,
       sexp_of_t$33,
       of_string$9,
       to_string,
       equal_int$1,
       compare_int$0,
       min$25,
       max$25,
       ascending$19,
       descending$19,
       between$5,
       clamp_exn$5,
       clamp$5,
       comparator$7,
       pp$11,
       hashable$3,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant$14,
       Hex,
       to_string_hum$1,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ$1,
       pred$0,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount$0,
       shift_left,
       shift_right$0,
       decr$0,
       incr$0,
       int32_to_int_exn,
       int_to_int32_exn,
       int64_to_int_exn,
       int_to_int64,
       nativeint_to_int_exn,
       int_to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value$2,
       min_value$2,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       O$0,
       symbol$136,
       lnot$0,
       abs$2,
       zero,
       symbol$137,
       symbol$138,
       symbol$139,
       max_value_30_bits,
       of_int$3,
       to_int_exn,
       int32_to_int,
       int_to_int32,
       int64_to_int,
       nativeint_to_int,
       int_to_nativeint,
       Private$4];
    caml_register_global(1094,include$53,"Base__Int");
    function hash_fold_t$23(state,t)
     {return runtime.Base_internalhash_fold_int(state,caml_call1(to_int$2,t))}
    function hash$13(t){return run(0,hash_fold_t$23,t)}
    function to_string$11(t)
     {return caml_call2(sprintf,_dn_,caml_call1(to_int$2,t))}
    function sexp_of_t$34(t){return [0,to_string$11(t)]}
    function t_of_sexp$21(sexp)
     {if(0 !== sexp[0])
       return caml_call2(of_sexp_error,cst_Uchar_t_of_sexp_atom_neede,sexp);
      var s=sexp[1];
      try
       {var
         _yb_=function(i){return caml_call1(of_int$1,i)},
         _yc_=caml_call3(Stdlib_Scanf[4],s,_do_,_yb_);
        return _yc_}
      catch(_yd_)
       {return caml_call2(of_sexp_error,cst_Uchar_t_of_sexp_atom_of_th,sexp)}}
    var
     t_sexp_grammar$22=caml_call1(Sexplib0_Sexp_grammar[1],t_sexp_grammar$1),
     pp$12=_w_([0,module_name$8,to_string$11])[1],
     _dp_=Make$1([0,compare$32,sexp_of_t$34]),
     between$6=_dp_[13],
     clamp_exn$6=_dp_[14],
     clamp$6=_dp_[15],
     comparator$8=_dp_[16];
    function invariant$15(param){return 0}
    function succ_exn(c)
     {try
       {var _ya_=caml_call1(succ$0,c);return _ya_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var msg=exn[2];
        return caml_call2(failwithf(_dq_),msg,0)}}
    function succ$2(c)
     {try
       {var _x__=[0,caml_call1(succ$0,c)];return _x__}
      catch(_x$_)
       {_x$_ = caml_wrap_exception(_x$_);
        if(_x$_[1] === Stdlib[6])return 0;
        throw _x$_}}
    function pred_exn(c)
     {try
       {var _x9_=caml_call1(pred,c);return _x9_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var msg=exn[2];
        return caml_call2(failwithf(_dr_),msg,0)}}
    function pred$1(c)
     {try
       {var _x7_=[0,caml_call1(pred,c)];return _x7_}
      catch(_x8_)
       {_x8_ = caml_wrap_exception(_x8_);
        if(_x8_[1] === Stdlib[6])return 0;
        throw _x8_}}
    function of_scalar(i)
     {return caml_call1(is_valid,i)?[0,caml_call1(unsafe_of_int$0,i)]:0}
    function of_scalar_exn(i)
     {return caml_call1(is_valid,i)
              ?caml_call1(unsafe_of_int$0,i)
              :caml_call2(failwithf(_ds_),i,0)}
    function to_scalar(t){return caml_call1(to_int$2,t)}
    function to_char(c)
     {return caml_call1(is_char,c)?[0,caml_call1(unsafe_to_char,c)]:0}
    function to_char_exn(c)
     {if(caml_call1(is_char,c))return caml_call1(unsafe_to_char,c);
      var _x6_=caml_call1(to_int$2,c);
      return caml_call2(failwithf(_dt_),_x6_,0)}
    function utf8_byte_length(uchar)
     {var codepoint=to_scalar(uchar);
      return 128 <= codepoint?2048 <= codepoint?65536 <= codepoint?4:3:2:1}
    var
     symbol$140=include$6[2],
     symbol$141=include$6[3],
     symbol$142=include$6[4],
     symbol$143=include$6[5],
     symbol$144=include$6[6],
     symbol$145=include$6[7],
     ascending$20=include$6[8],
     descending$20=include$6[9],
     compare$40=include$6[10],
     equal$26=include$6[11],
     max$26=include$6[12],
     min$26=include$6[13],
     Base_Uchar=
      [0,
       hash_fold_t$23,
       hash$13,
       t_of_sexp$21,
       sexp_of_t$34,
       t_sexp_grammar$22,
       symbol$145,
       symbol$141,
       symbol$143,
       symbol$144,
       symbol$140,
       symbol$142,
       equal$26,
       compare$40,
       min$26,
       max$26,
       ascending$20,
       descending$20,
       between$6,
       clamp_exn$6,
       clamp$6,
       comparator$8,
       pp$12,
       invariant$15,
       succ$2,
       succ_exn,
       pred$1,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value$1,
       max_value$1];
    caml_register_global(1095,Base_Uchar,"Base__Uchar");
    function sexp_of_t$35(of_a_001,of_b_002,param){return _du_}
    var refl=0;
    function sym(param){return 0}
    function trans(param,_x5_){return 0}
    function conv(param,a){return a}
    function Lift(X){function lift(param){return 0}return [0,lift]}
    function Lift2(X){function lift(param,_x4_){return 0}return [0,lift]}
    function Lift3(X){function lift(param,_x3_,_x2_){return 0}return [0,lift]}
    function detuple2(param){return _dv_}
    function tuple2(param,_x1_){return 0}
    function Composition_preserves_injectiv(M1,M2)
     {function strip(e)
       {var _x0_=caml_call1(M2[1],e);return caml_call1(M1[1],_x0_)}
      return [0,strip]}
    function sexp_of_t$36(param,_xZ_)
     {var name=_xZ_[2],witness=_xZ_[1];
      if(am_testing)return [0,name];
      var
       _xY_=caml_call1(Stdlib_Obj[22][1],witness[1]),
       v_005=caml_call1(Stdlib_Obj[22][3],_xY_);
      return [1,
              [0,
               [1,[0,_dy_,[0,[0,name],0]]],
               [0,
                [1,
                 [0,
                  _dx_,
                  [0,[1,[0,_dw_,[0,caml_call1(sexp_of_t$4,v_005),0]]],0]]],
                0]]]}
    function to_sexp(t){return t[3]}
    function name$0(t){return t[2]}
    function create$9(name,to_sexp)
     {var Key=[248,cst_Key,caml_fresh_oo_id(0)];
      return [0,[0,Key],name,to_sexp]}
    function uid(t)
     {var _xX_=caml_call1(Stdlib_Obj[22][1],t[1][1]);
      return caml_call1(Stdlib_Obj[22][3],_xX_)}
    function hash$14(t){return uid(t)}
    function hash_fold_t$24(s,t){return caml_call2(hash_fold_t$4,s,uid(t))}
    function same_witness(t1,t2){return t1[1][1] === t2[1][1]?some_t:0}
    function same(t1,t2){return is_some(same_witness(t1,t2))}
    function same_witness_exn(t1,t2)
     {var match=same_witness(t1,t2);
      if(match){var w=match[1];return w}
      var _xS_=0,_xT_=[0,t1,t2];
      function _xU_(_xW_){return sexp_of_t$36(sexp_of_opaque,_xW_)}
      return raise_s
              (caml_call2
                (message,
                 cst_Type_equal_Id_same_witness,
                 [0,
                  [0,
                   cst$28,
                   caml_call3
                    (sexp_of_pair,
                     function(_xV_){return sexp_of_t$36(sexp_of_opaque,_xV_)},
                     _xU_,
                     _xT_)],
                  _xS_]))}
    function _dz_(_xR_,_xQ_){return _xR_ !== _xQ_?1:0}
    function _dA_(_xP_,_xO_){return _xP_ < _xO_?1:0}
    function _dB_(_xN_,_xM_){return _xM_ < _xN_?1:0}
    function _dC_(_xL_,_xK_){return _xL_ === _xK_?1:0}
    function _dD_(_xJ_,_xI_){return _xJ_ <= _xI_?1:0}
    var
     Base_Type_equal=
      [0,
       sexp_of_t$35,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$36,
        [0,
         hash_fold_t$4,
         func$8,
         t_of_sexp$4,
         sexp_of_t$33,
         function(_xH_,_xG_){return _xG_ <= _xH_?1:0},
         _dD_,
         _dC_,
         _dB_,
         _dA_,
         _dz_,
         equal_int$1,
         compare_int$0,
         min$25,
         max$25,
         ascending$19,
         descending$19,
         between$5,
         clamp_exn$5,
         clamp$5,
         comparator$7],
        uid,
        create$9,
        hash$14,
        name$0,
        to_sexp,
        hash_fold_t$24,
        same,
        same_witness,
        same_witness_exn]];
    caml_register_global(1096,Base_Type_equal,"Base__Type_equal");
    var Base_T=[0];
    caml_register_global(1097,Base_T,"Base__T");
    var Base_Stack_intf=[0];
    caml_register_global(1098,Base_Stack_intf,"Base__Stack_intf");
    var
     none_substitute=runtime.caml_obj_block(Stdlib_Obj[12],1),
     none=24791911;
    function is_none$0(x){return x === 24791911?1:0}
    function is_some$0(x){return 1 - (x === 24791911?1:0)}
    function some$0(x){return x === 24791911?none_substitute:x}
    function value_unsafe(x){return x === none_substitute?none:x}
    function value_exn$0(x)
     {return is_some$0(x)
              ?value_unsafe(x)
              :caml_call1(failwith$0,cst_Option_array_get_some_exn_)}
    function of_sexpable(param)
     {if(! param)return none;var x=param[1];return some$0(x)}
    function to_sexpable(x){return is_some$0(x)?[0,value_unsafe(x)]:0}
    var
     include$91=
      Of_sexpable1
       ([0,option_of_sexp,sexp_of_option],[0,to_sexpable,of_sexpable]),
     t_of_sexp$22=include$91[1],
     sexp_of_t$37=include$91[2];
    function t_of_sexp$23(of_a_001,x_003)
     {return caml_call2(t_of_sexp$19,caml_call1(t_of_sexp$22,of_a_001),x_003)}
    function sexp_of_t$38(of_a_004,x_005)
     {return caml_call2(sexp_of_t$29,caml_call1(sexp_of_t$37,of_a_004),x_005)}
    function t_sexp_grammar$23(a_sexp_grammar)
     {var _xF_=t_sexp_grammar$18(a_sexp_grammar);
      return t_sexp_grammar$21(caml_call1(Sexplib0_Sexp_grammar[1],_xF_))}
    function create$10(len){return create$4(len,none)}
    function init$6(n,f)
     {return init$3(n,function(i){return of_sexpable(caml_call1(f,i))})}
    function init_some(n,f)
     {return init$3(n,function(i){return some$0(caml_call1(f,i))})}
    function get$4(t,i){return to_sexpable(get$3(t,i))}
    function get_some_exn(t,i){return value_exn$0(get$3(t,i))}
    function is_none$1(t,i){return get$3(t,i) === 24791911?1:0}
    function is_some$1(t,i){return is_some$0(get$3(t,i))}
    function set$2(t,i,x){return set$1(t,i,of_sexpable(x))}
    function set_some(t,i,x){return set$1(t,i,some$0(x))}
    function set_none(t,i){return set$1(t,i,none)}
    function swap$4(t,i,j){return swap$3(t,i,j)}
    function unsafe_get$1(t,i){return to_sexpable(t[1 + i])}
    function unsafe_get_some_exn(t,i){return value_exn$0(t[1 + i])}
    function unsafe_get_some_assuming_some(t,i){return value_unsafe(t[1 + i])}
    function unsafe_is_some(t,i){return is_some$0(t[1 + i])}
    function unsafe_set$1(t,i,x){return unsafe_set$0(t,i,of_sexpable(x))}
    function unsafe_set_some(t,i,x){return unsafe_set$0(t,i,some$0(x))}
    function unsafe_set_none(t,i){return unsafe_set$0(t,i,none)}
    function clear(t)
     {var _xD_=t.length - 1 - 1 | 0,_xC_=0;
      if(_xD_ >= 0)
       {var i=_xC_;
        for(;;)
         {unsafe_set_none(t,i);
          var _xE_=i + 1 | 0;
          if(_xD_ !== i){var i=_xE_;continue}
          break}}
      return 0}
    function _dE_(input,f)
     {var _xA_=input.length - 1 - 1 | 0,_xz_=0;
      if(_xA_ >= 0)
       {var i=_xz_;
        for(;;)
         {caml_call2(f,i,unsafe_get$1(input,i));
          var _xB_=i + 1 | 0;
          if(_xA_ !== i){var i=_xB_;continue}
          break}}
      return 0}
    function _dF_(input,f)
     {return _dE_(input,function(param,x){return caml_call1(f,x)})}
    function _dG_(input,init,f)
     {var acc=[0,init];
      _dE_
       (input,function(i,elem){acc[1] = caml_call3(f,i,acc[1],elem);return 0});
      return acc[1]}
    function fold$5(input,init,f)
     {return _dG_
              (input,init,function(param,acc,x){return caml_call2(f,acc,x)})}
    var
     foldi$6=[0,-198771759,_dG_],
     iter$7=[0,-198771759,_dF_],
     iteri$5=[0,-198771759,_dE_],
     length$8=[0,-198771759,length$5],
     include$54=Make_gen$2([0,fold$5,iter$7,length$8,iteri$5,foldi$6]),
     length$9=include$54[1],
     is_empty$4=include$54[2],
     iter$8=include$54[3],
     fold$6=include$54[4],
     fold_result$5=include$54[5],
     fold_until$5=include$54[6],
     exists$6=include$54[7],
     for_all$6=include$54[8],
     count$5=include$54[9],
     sum$5=include$54[10],
     find$6=include$54[11],
     find_map$5=include$54[12],
     to_list$7=include$54[13],
     min_elt$6=include$54[15],
     max_elt$6=include$54[16],
     foldi$7=include$54[17],
     iteri$6=include$54[18],
     existsi$4=include$54[19],
     for_alli$4=include$54[20],
     counti$4=include$54[21],
     findi$4=include$54[22],
     find_mapi$4=include$54[23];
    function map$25(input,f)
     {var output=create$10(caml_call1(length$9,input));
      caml_call2
       (iteri$6,
        input,
        function(i,elem){return unsafe_set$1(output,i,caml_call1(f,elem))});
      return output}
    function map_some(input,f)
     {var
       len=caml_call1(length$9,input),
       output=create$10(len),
       _xx_=len - 1 | 0,
       _xw_=0;
      if(_xx_ >= 0)
       {var i=_xw_;
        for(;;)
         {var t=input[1 + i];
          if(is_some$0(t))
           {var x=value_unsafe(t);unsafe_set_some(output,i,caml_call1(f,x))}
          var _xy_=i + 1 | 0;
          if(_xx_ !== i){var i=_xy_;continue}
          break}}
      return output}
    function of_array$0(array)
     {return init$6(array.length - 1,function(i){return array[1 + i]})}
    function of_array_some(array)
     {return init_some(array.length - 1,function(i){return array[1 + i]})}
    function to_array$6(t)
     {function _xv_(i){return unsafe_get$1(t,i)}
      return caml_call2(init,caml_call1(length$9,t),_xv_)}
    function create_like$1(len,param){return create$10(len)}
    var
     include$55=_a3_([0,create_like$1,length$9,unsafe_blit$5]),
     blit$5=include$55[1],
     blito$3=include$55[2],
     unsafe_blit$8=include$55[3],
     sub$10=include$55[4],
     subo$4=include$55[5],
     Base_Option_array=
      [0,
       t_of_sexp$23,
       sexp_of_t$38,
       t_sexp_grammar$23,
       empty$0,
       create$10,
       length$9,
       is_empty$4,
       iter$8,
       fold$6,
       fold_result$5,
       fold_until$5,
       exists$6,
       for_all$6,
       count$5,
       sum$5,
       find$6,
       find_map$5,
       to_list$7,
       min_elt$6,
       max_elt$6,
       foldi$7,
       iteri$6,
       existsi$4,
       for_alli$4,
       counti$4,
       findi$4,
       find_mapi$4,
       init_some,
       init$6,
       of_array$0,
       of_array_some,
       to_array$6,
       get$4,
       get_some_exn,
       is_none$1,
       is_some$1,
       unsafe_get$1,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set$2,
       set_some,
       set_none,
       swap$4,
       clear,
       map$25,
       map_some,
       unsafe_set$1,
       unsafe_set_some,
       unsafe_set_none,
       blit$5,
       blito$3,
       unsafe_blit$8,
       sub$10,
       subo$4,
       copy$3,
       [0,
        [0,
         t_of_sexp$22,
         sexp_of_t$37,
         none,
         some$0,
         is_none$0,
         is_some$0,
         value_exn$0,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
    caml_register_global(1099,Base_Option_array,"Base__Option_array");
    function capacity(t){return caml_call1(length$9,t[2])}
    function invariant$16(invariant_a,t)
     {var length=t[1],elts=t[2];
      try
       {if(0 <= length && length <= caml_call1(length$9,elts))
         {var _xq_=length - 1 | 0,_xp_=0;
          if(_xq_ >= 0)
           {var i$0=_xp_;
            for(;;)
             {caml_call1(invariant_a,get_some_exn(elts,i$0));
              var _xu_=i$0 + 1 | 0;
              if(_xq_ !== i$0){var i$0=_xu_;continue}
              break}}
          var _xr_=caml_call1(length$9,elts) - 1 | 0;
          if(_xr_ >= length)
           {var i=length;
            for(;;)
             {if(is_some$1(elts,i))throw [0,Assert_failure$0,_dJ_];
              var _xt_=i + 1 | 0;
              if(_xr_ !== i){var i=_xt_;continue}
              break}}
          var _xs_=0;
          return _xs_}
        throw [0,Assert_failure$0,_dK_]}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var
         _xn_=0,
         _xo_=
          [0,
           [0,
            cst_stack,
            function(param)
              {var
                length_003=param[1],
                elts_005=param[2],
                arg_006=sexp_of_t$38(sexp_of_opaque,elts_005),
                bnds_002=[0,[1,[0,_dH_,[0,arg_006,0]]],0],
                arg_004=caml_call1(sexp_of_t$4,length_003),
                bnds_002$0=[0,[1,[0,_dI_,[0,arg_004,0]]],bnds_002];
               return [1,bnds_002$0]}
             (t)],
           _xn_];
        return raise_s
                (caml_call2
                  (message,
                   cst_Stack_invariant_failed,
                   [0,[0,cst_exn$1,caml_call1(sexp_of_exn,exn)],_xo_]))}}
    function create$11(param){return [0,0,empty$0]}
    function length$10(t){return t[1]}
    function is_empty$5(t){return 0 === t[1]?1:0}
    function fold$7(t,init,f)
     {var r=[0,init],_xk_=t[1] - 1 | 0;
      if(_xk_ >= 0)
       {var i=_xk_;
        for(;;)
         {var _xl_=get_some_exn(t[2],i);
          r[1] = caml_call2(f,r[1],_xl_);
          var _xm_=i - 1 | 0;
          if(0 !== i){var i=_xm_;continue}
          break}}
      return r[1]}
    function iter$9(t,f)
     {var _xi_=t[1] - 1 | 0;
      if(_xi_ >= 0)
       {var i=_xi_;
        for(;;)
         {caml_call1(f,get_some_exn(t[2],i));
          var _xj_=i - 1 | 0;
          if(0 !== i){var i=_xj_;continue}
          break}}
      return 0}
    var
     iter$10=[0,-198771759,iter$9],
     length$11=[0,-198771759,length$10],
     C=___([0,fold$7,iter$10,length$11]),
     _dS_=C[14],
     _dL_=C[1],
     _dM_=C[8],
     _dN_=C[9],
     _dO_=C[10],
     _dP_=C[11],
     _dQ_=C[12],
     _dR_=C[13],
     _dT_=C[15],
     _dU_=C[16],
     _dV_=C[17],
     _dW_=C[6],
     _dX_=C[7];
    function of_list$3(l)
     {if(is_empty(l))return create$11(0);
      var
       length$0=caml_call1(length,l),
       elts=create$10(2 * length$0 | 0),
       r=[0,l],
       _xf_=length$0 - 1 | 0;
      if(_xf_ >= 0)
       {var i=_xf_;
        for(;;)
         {var _xg_=r[1];
          if(! _xg_)throw [0,Assert_failure$0,_dY_];
          var l$0=_xg_[2],a=_xg_[1];
          set_some(elts,i,a);
          r[1] = l$0;
          var _xh_=i - 1 | 0;
          if(0 !== i){var i=_xh_;continue}
          break}}
      return [0,length$0,elts]}
    function sexp_of_t$39(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,caml_call1(_dS_,t))}
    function t_of_sexp$24(a_of_sexp,sexp)
     {return of_list$3(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function t_sexp_grammar$24(grammar)
     {var _xe_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_xe_)}
    function resize(t,size)
     {var arr=create$10(size);
      caml_call5(blit$5,t[2],0,arr,0,t[1]);
      t[2] = arr;
      return 0}
    function set_capacity(t,new_capacity)
     {var
       new_capacity$0=caml_call2(max$2,new_capacity,t[1]),
       _xd_=new_capacity$0 !== capacity(t)?1:0;
      return _xd_?resize(t,new_capacity$0):_xd_}
    function push(t,a)
     {var _xc_=caml_call1(length$9,t[2]);
      if(t[1] === _xc_)resize(t,2 * (t[1] + 1 | 0) | 0);
      set_some(t[2],t[1],a);
      t[1] = t[1] + 1 | 0;
      return 0}
    function pop_nonempty(t)
     {var i=t[1] - 1 | 0,result=get_some_exn(t[2],i);
      set_none(t[2],i);
      t[1] = i;
      return result}
    var pop_error=of_string$2(cst_Stack_pop_of_empty_stack);
    function pop(t){return is_empty$5(t)?0:[0,pop_nonempty(t)]}
    function pop_exn(t){return is_empty$5(t)?raise(pop_error):pop_nonempty(t)}
    function top_nonempty(t){return get_some_exn(t[2],t[1] - 1 | 0)}
    var top_error=of_string$2(cst_Stack_top_of_empty_stack);
    function top(t){return is_empty$5(t)?0:[0,top_nonempty(t)]}
    function top_exn(t){return is_empty$5(t)?raise(top_error):top_nonempty(t)}
    function copy$4(param)
     {var length=param[1],elts=param[2];return [0,length,copy$3(elts)]}
    function clear$0(t)
     {var _w9_=0 < t[1]?1:0;
      if(_w9_)
       {var _w$_=t[1] - 1 | 0,_w__=0;
        if(_w$_ >= 0)
         {var i=_w__;
          for(;;)
           {set_none(t[2],i);
            var _xb_=i + 1 | 0;
            if(_w$_ !== i){var i=_xb_;continue}
            break}}
        t[1] = 0;
        var _xa_=0}
      else
       var _xa_=_w9_;
      return _xa_}
    function until_empty(t,f)
     {for(;;)
       {var _w8_=0 < t[1]?1:0;
        if(! _w8_)return _w8_;
        caml_call1(f,pop_nonempty(t))}}
    function singleton$2(x){var t=create$11(0);push(t,x);return t}
    var
     Base_Stack=
      [0,
       t_of_sexp$24,
       sexp_of_t$39,
       t_sexp_grammar$24,
       invariant$16,
       _dL_,
       length$10,
       is_empty$5,
       iter$9,
       fold$7,
       _dW_,
       _dX_,
       _dM_,
       _dN_,
       _dO_,
       _dP_,
       _dQ_,
       _dR_,
       _dS_,
       _dT_,
       _dU_,
       _dV_,
       of_list$3,
       create$11,
       singleton$2,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear$0,
       copy$4,
       until_empty,
       capacity,
       set_capacity];
    caml_register_global(1100,Base_Stack,"Base__Stack");
    function hash$15(param)
     {var
       pos_cnum=param[4],
       pos_bol=param[3],
       pos_lnum=param[2],
       pos_fname=param[1],
       _w5_=func$8(pos_cnum),
       _w6_=func$8(pos_bol),
       _w7_=func$8(pos_lnum);
      return runtime.Base_hash_string(pos_fname) ^ _w7_ ^ _w6_ ^ _w5_}
    var
     include$56=Make_using_comparator([0,sexp_of_t$15,comparator$0]),
     symbol$146=include$56[1],
     symbol$147=include$56[2],
     symbol$148=include$56[3],
     symbol$149=include$56[4],
     symbol$150=include$56[5],
     symbol$151=include$56[6],
     equal$27=include$56[7],
     compare$41=include$56[8],
     min$27=include$56[9],
     max$27=include$56[10],
     ascending$21=include$56[11],
     descending$21=include$56[12],
     between$7=include$56[13],
     clamp_exn$7=include$56[14],
     clamp$7=include$56[15],
     comparator$9=include$56[16];
    function of_pos(param)
     {var pos_cnum=param[3],pos_lnum=param[2],pos_fname=param[1];
      return [0,pos_fname,pos_lnum,0,pos_cnum]}
    var
     Base_Source_code_position=
      [0,
       hash_fold_t$12,
       hash$15,
       sexp_of_t$15,
       symbol$146,
       symbol$147,
       symbol$148,
       symbol$149,
       symbol$150,
       symbol$151,
       equal$27,
       compare$41,
       min$27,
       max$27,
       ascending$21,
       descending$21,
       between$7,
       clamp_exn$7,
       clamp$7,
       comparator$9,
       to_string$3,
       of_pos];
    caml_register_global
     (1101,Base_Source_code_position,"Base__Source_code_position");
    function t_of_sexp$25(sexp_004)
     {if(0 === sexp_004[0])
       {var _w1_=sexp_004[1],switch$0=0;
        if(caml_string_notequal(_w1_,cst_Nan))
         {var switch$1=0;
          if(caml_string_notequal(_w1_,cst_Neg$1))
           {var switch$2=0;
            if(caml_string_notequal(_w1_,cst_Pos$1))
             {var switch$3=0;
              if(caml_string_notequal(_w1_,cst_Zero$1))
               if(caml_string_notequal(_w1_,cst_nan))
                if(caml_string_notequal(_w1_,cst_neg$1))
                 if(caml_string_notequal(_w1_,cst_pos$3))
                  {if(caml_string_notequal(_w1_,cst_zero$1))
                    {switch$0 = 1;switch$1 = 1;switch$2 = 1;switch$3 = 1}}
                 else
                  switch$3 = 1;
                else
                 {switch$2 = 1;switch$3 = 1}
               else
                {switch$1 = 1;switch$2 = 1;switch$3 = 1}
              if(! switch$3)return 1}
            if(! switch$2)return 2}
          if(! switch$1)return 0}
        if(! switch$0)return 3}
      else
       {var _w2_=sexp_004[1];
        if(! _w2_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_003$0,sexp_004);
        var _w3_=_w2_[1];
        if(0 !== _w3_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_003$0,sexp_004);
        var _w4_=_w3_[1],switch$4=0;
        if(caml_string_notequal(_w4_,cst_Nan$0))
         {var switch$5=0;
          if(caml_string_notequal(_w4_,cst_Neg$2))
           {var switch$6=0;
            if(caml_string_notequal(_w4_,cst_Pos$2))
             {var switch$7=0;
              if(caml_string_notequal(_w4_,cst_Zero$2))
               if(caml_string_notequal(_w4_,cst_nan$0))
                if(caml_string_notequal(_w4_,cst_neg$2))
                 if(caml_string_notequal(_w4_,cst_pos$4))
                  {if(caml_string_notequal(_w4_,cst_zero$2))
                    {switch$4 = 1;switch$5 = 1;switch$6 = 1;switch$7 = 1}}
                 else
                  switch$7 = 1;
                else
                 {switch$6 = 1;switch$7 = 1}
               else
                {switch$5 = 1;switch$6 = 1;switch$7 = 1}
              if(! switch$7)
               return caml_call2
                       (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
            if(! switch$6)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
          if(! switch$5)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
        if(! switch$4)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_003$0,sexp_004)}
    function sexp_of_t$40(param)
     {switch(param)
       {case 0:return _dZ_;
        case 1:return _d0_;
        case 2:return _d1_;
        default:return _d2_}}
    var compare$42=caml_int_compare;
    function hash_fold_t$25(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        case 2:return runtime.Base_internalhash_fold_int(hsv,2);
        default:return runtime.Base_internalhash_fold_int(hsv,3)}}
    function hash$16(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$25(hsv,x))}
    function of_string$11(s){return t_of_sexp$25(caml_call1(sexp_of_t$2,s))}
    function to_string$12(t){return caml_call1(t_of_sexp$2,sexp_of_t$40(t))}
    function symbol$152(x,y){return x < y?1:0}
    function symbol$153(x,y){return x <= y?1:0}
    function symbol$154(x,y){return x !== y?1:0}
    function symbol$155(x,y){return x === y?1:0}
    function symbol$156(x,y){return y < x?1:0}
    function symbol$157(x,y){return y <= x?1:0}
    var ascending$22=caml_compare;
    function descending$22(x,y){return caml_compare(y,x)}
    var compare$43=caml_int_compare;
    function equal$28(x,y){return x === y?1:0}
    function max$28(x,y){return y <= x?x:y}
    function min$28(x,y){return x <= y?x:y}
    var
     _d3_=
      _a1_
       ([0,
         compare$42,
         hash_fold_t$25,
         hash$16,
         t_of_sexp$25,
         sexp_of_t$40,
         of_string$11,
         to_string$12,
         module_name$9]),
     hash_fold_t$26=_d3_[1],
     hash$17=_d3_[2],
     t_of_sexp$26=_d3_[3],
     sexp_of_t$41=_d3_[4],
     of_string$12=_d3_[5],
     to_string$13=_d3_[6],
     between$8=_d3_[19],
     clamp_exn$8=_d3_[20],
     clamp$8=_d3_[21],
     comparator$10=_d3_[22],
     pp$13=_d3_[23],
     hashable$4=_d3_[24];
    function of_sign(param)
     {switch(param){case 0:return 0;case 1:return 1;default:return 2}}
    function to_sign_exn(param)
     {switch(param)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        default:
         return caml_call1(invalid_arg$0,cst_Base_Sign_or_nan_to_sign_e)}}
    function of_int$4(n){return of_sign(sign(n))}
    function to_int_exn$0(t){return to_int$1(to_sign_exn(t))}
    function flip$1(param)
     {switch(param)
       {case 0:return 2;case 1:return 1;case 2:return 0;default:return 3}}
    function symbol$158(t$0,t)
     {if(3 > t$0 && 3 > t)
       {var _w0_=to_sign_exn(t);
        return of_sign(symbol$128(to_sign_exn(t$0),_w0_))}
      return 3}
    var
     Base_Sign_or_nan=
      [0,
       all$14,
       t_sexp_grammar$25,
       hash_fold_t$26,
       hash$17,
       t_of_sexp$26,
       sexp_of_t$41,
       of_string$12,
       to_string$13,
       symbol$157,
       symbol$153,
       symbol$155,
       symbol$156,
       symbol$152,
       symbol$154,
       equal$28,
       compare$43,
       min$28,
       max$28,
       ascending$22,
       descending$22,
       between$8,
       clamp_exn$8,
       clamp$8,
       comparator$10,
       pp$13,
       hashable$4,
       of_int$4,
       to_int_exn$0,
       of_sign,
       to_sign_exn,
       flip$1,
       symbol$158];
    caml_register_global(1102,Base_Sign_or_nan,"Base__Sign_or_nan");
    var
     include$57=Make$1([0,compare$7,sexp_of_t]),
     symbol$159=include$57[1],
     symbol$160=include$57[2],
     symbol$161=include$57[3],
     symbol$162=include$57[4],
     symbol$163=include$57[5],
     symbol$164=include$57[6],
     equal$29=include$57[7],
     compare$44=include$57[8],
     min$29=include$57[9],
     max$29=include$57[10],
     ascending$23=include$57[11],
     descending$23=include$57[12],
     between$9=include$57[13],
     clamp_exn$9=include$57[14],
     clamp$9=include$57[15],
     comparator$11=include$57[16],
     include$58=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string$0,
       symbol$159,
       symbol$160,
       symbol$161,
       symbol$162,
       symbol$163,
       symbol$164,
       equal$29,
       compare$44,
       min$29,
       max$29,
       ascending$23,
       descending$23,
       between$9,
       clamp_exn$9,
       clamp$9,
       comparator$11];
    caml_register_global(1103,include$58,"Base__Sexp_with_comparable");
    var Base_Hasher=[0];
    caml_register_global(1104,Base_Hasher,"Base__Hasher");
    function all$15(all_of_a)
     {var l=all_of_a,acc=0;
      for(;;)
       {if(l)
         {var
           l$0=l[2],
           enumerate_002=l[1],
           acc$0=[0,[1,enumerate_002],acc],
           l=l$0,
           acc=acc$0;
          continue}
        var l$1=all_of_a,acc$1=0,_wZ_=append$0(rev(acc),_d4_);
        for(;;)
         {if(! l$1)return append$0(rev(acc$1),_wZ_);
          var
           l$2=l$1[2],
           enumerate_001=l$1[1],
           acc$2=[0,[0,enumerate_001],acc$1],
           l$1=l$2,
           acc$1=acc$2}}}
    function t_of_sexp$27(of_a_003,sexp_008)
     {if(0 === sexp_008[0])
       {var _wV_=sexp_008[1],switch$0=0;
        if(caml_string_notequal(_wV_,cst_Excl))
         {var switch$1=0;
          if(caml_string_notequal(_wV_,cst_Incl))
           {var switch$2=0;
            if(caml_string_notequal(_wV_,cst_Unbounded))
             if(caml_string_notequal(_wV_,cst_excl))
              if(caml_string_notequal(_wV_,cst_incl))
               {if(caml_string_notequal(_wV_,cst_unbounded))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 0}
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_006,sexp_008)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_006,sexp_008)}
      else
       {var _wW_=sexp_008[1];
        if(! _wW_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_006,sexp_008);
        var _wX_=_wW_[1];
        if(0 !== _wX_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_006,sexp_008);
        var _wY_=_wX_[1],switch$3=0;
        if(caml_string_notequal(_wY_,cst_Excl$0))
         {var switch$4=0;
          if(caml_string_notequal(_wY_,cst_Incl$0))
           {var switch$5=0;
            if(caml_string_notequal(_wY_,cst_Unbounded$0))
             if(caml_string_notequal(_wY_,cst_excl$0))
              if(caml_string_notequal(_wY_,cst_incl$0))
               {if(caml_string_notequal(_wY_,cst_unbounded$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_006,sexp_008)}
          if(! switch$4)
           {var sexp_args_010=_wW_[2];
            if(sexp_args_010 && ! sexp_args_010[2])
             {var
               arg0_011=sexp_args_010[1],
               res0_012=caml_call1(of_a_003,arg0_011);
              return [0,res0_012]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_006,_wY_,sexp_008)}}
        if(! switch$3)
         {var sexp_args_015=_wW_[2];
          if(sexp_args_015 && ! sexp_args_015[2])
           {var
             arg0_016=sexp_args_015[1],
             res0_017=caml_call1(of_a_003,arg0_016);
            return [1,res0_017]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_006,_wY_,sexp_008)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_006,sexp_008)}
    function sexp_of_t$42(of_a_019,param)
     {if(typeof param === "number")return _d5_;
      if(0 === param[0])
       {var arg0_020=param[1],res0_021=caml_call1(of_a_019,arg0_020);
        return [1,[0,_d6_,[0,res0_021,0]]]}
      var arg0_022=param[1],res0_023=caml_call1(of_a_019,arg0_022);
      return [1,[0,_d7_,[0,res0_023,0]]]}
    function t_sexp_grammar$26(a_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Incl$1,[0,[0,a_sexp_grammar,0]]]],
                [0,[1,[0,cst_Excl$1,[0,[0,a_sexp_grammar,0]]]],_d8_]]]]}
    function interval_comparison_of_sexp(sexp_028)
     {if(0 === sexp_028[0])
       {var _wR_=sexp_028[1],switch$0=0;
        if(caml_string_notequal(_wR_,cst_Above_upper_bound))
         {var switch$1=0;
          if(caml_string_notequal(_wR_,cst_Below_lower_bound))
           {var switch$2=0;
            if(caml_string_notequal(_wR_,cst_In_range))
             if(caml_string_notequal(_wR_,cst_above_upper_bound))
              if(caml_string_notequal(_wR_,cst_below_lower_bound))
               {if(caml_string_notequal(_wR_,cst_in_range))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 1}
          if(! switch$1)return 0}
        if(! switch$0)return 2}
      else
       {var _wS_=sexp_028[1];
        if(! _wS_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_027,sexp_028);
        var _wT_=_wS_[1];
        if(0 !== _wT_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_027,sexp_028);
        var _wU_=_wT_[1],switch$3=0;
        if(caml_string_notequal(_wU_,cst_Above_upper_bound$0))
         {var switch$4=0;
          if(caml_string_notequal(_wU_,cst_Below_lower_bound$0))
           {var switch$5=0;
            if(caml_string_notequal(_wU_,cst_In_range$0))
             if(caml_string_notequal(_wU_,cst_above_upper_bound$0))
              if(caml_string_notequal(_wU_,cst_below_lower_bound$0))
               {if(caml_string_notequal(_wU_,cst_in_range$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_027,sexp_028)}
    function sexp_of_interval_comparison(param)
     {switch(param){case 0:return _d9_;case 1:return _d__;default:return _d$_}}
    var compare_interval_comparison=caml_int_compare;
    function hash_fold_interval_comparison(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function hash_interval_comparison(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value
              (hash_fold_interval_comparison(hsv,x))}
    function map$26(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var incl=t[1];return [0,caml_call1(f,incl)]}
      var excl=t[1];
      return [1,caml_call1(f,excl)]}
    function is_lower_bound(t,a,compare)
     {if(typeof t === "number")return 1;
      if(0 === t[0]){var incl=t[1];return caml_call2(compare,incl,a) <= 0?1:0}
      var excl=t[1];
      return caml_call2(compare,excl,a) < 0?1:0}
    function is_upper_bound(t,a,compare)
     {if(typeof t === "number")return 1;
      if(0 === t[0]){var incl=t[1];return caml_call2(compare,a,incl) <= 0?1:0}
      var excl=t[1];
      return caml_call2(compare,a,excl) < 0?1:0}
    function bounds_crossed(lower,upper,compare)
     {if(typeof lower === "number")return 0;
      var lower$0=lower[1];
      if(typeof upper === "number")return 0;
      var upper$0=upper[1];
      return 0 < caml_call2(compare,lower$0,upper$0)?1:0}
    function compare_to_interval_exn(lower,upper,a,compare)
     {if(bounds_crossed(lower,upper,compare))
       caml_call1(failwith$0,cst_Maybe_bound_compare_to_int);
      return is_lower_bound(lower,a,compare)
              ?is_upper_bound(upper,a,compare)?1:2
              :0}
    function interval_contains_exn(lower,upper,a,compare)
     {var match=compare_to_interval_exn(lower,upper,a,compare);
      return 1 === match?1:0}
    var
     Base_Maybe_bound=
      [0,
       all$15,
       t_of_sexp$27,
       sexp_of_t$42,
       t_sexp_grammar$26,
       map$26,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
    caml_register_global(1105,Base_Maybe_bound,"Base__Maybe_bound");
    function compare$45(cmp_a,a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(typeof a_001 === "number")
       {if(-1024851605 === b_002)return 0}
      else
       if(typeof b_002 !== "number" && 17724 === b_002[1])
        {var right_004=b_002[2],left_003=a_001[2];
         return caml_call2(cmp_a,left_003,right_004)}
      return caml_compare(a_001,b_002)}
    function equal$30(cmp_a,a_005,b_006)
     {if(a_005 === b_006)return 1;
      if(typeof a_005 === "number")
       {if(-1024851605 === b_006)return 1}
      else
       if(typeof b_006 !== "number" && 17724 === b_006[1])
        {var right_008=b_006[2],left_007=a_005[2];
         return caml_call2(cmp_a,left_007,right_008)}
      return caml_equal(a_005,b_006)}
    function sexp_of_t$43(of_a_009,param)
     {if(typeof param === "number")return _ea_;
      var v_010=param[2];
      return [1,[0,_eb_,[0,caml_call1(of_a_009,v_010),0]]]}
    var
     Or_duplicate=[0,compare$45,equal$30,sexp_of_t$43],
     Without_comparator=[0],
     With_comparator=[0],
     With_first_class_module=[0];
    function compare$46(cmp_k,cmp_v,a_011,b_012)
     {var
       t_014=a_011[2],
       t_013=a_011[1],
       t_016=b_012[2],
       t_015=b_012[1],
       n=caml_call2(cmp_k,t_013,t_015);
      if(0 !== n)return n;
      if(t_014 === t_016)return 0;
      var _wQ_=t_014[1];
      if(847852583 === _wQ_)
       {if(typeof t_016 !== "number" && 847852583 === t_016[1])
         {var right_018=t_016[2],left_017=t_014[2];
          return caml_call2(cmp_v,left_017,right_018)}}
      else
       if(1013247643 <= _wQ_)
        {if(typeof t_016 !== "number" && 1013247643 === t_016[1])
          {var
            right_022=t_016[2],
            left_021=t_014[2],
            t_024=left_021[2],
            t_023=left_021[1],
            t_026=right_022[2],
            t_025=right_022[1],
            n$0=caml_call2(cmp_v,t_023,t_025);
           return 0 === n$0?caml_call2(cmp_v,t_024,t_026):n$0}}
       else
        if(typeof t_016 !== "number" && -57574468 === t_016[1])
         {var right_020=t_016[2],left_019=t_014[2];
          return caml_call2(cmp_v,left_019,right_020)}
      return caml_compare(t_014,t_016)}
    function equal$31(cmp_k,cmp_v,a_027,b_028)
     {var
       t_030=a_027[2],
       t_029=a_027[1],
       t_032=b_028[2],
       t_031=b_028[1],
       _wM_=caml_call2(cmp_k,t_029,t_031);
      if(_wM_)
       {if(t_030 === t_032)return 1;
        var _wN_=t_030[1];
        if(847852583 === _wN_)
         {if(typeof t_032 !== "number" && 847852583 === t_032[1])
           {var right_034=t_032[2],left_033=t_030[2];
            return caml_call2(cmp_v,left_033,right_034)}}
        else
         if(1013247643 <= _wN_)
          {if(typeof t_032 !== "number" && 1013247643 === t_032[1])
            {var
              right_038=t_032[2],
              left_037=t_030[2],
              t_040=left_037[2],
              t_039=left_037[1],
              t_042=right_038[2],
              t_041=right_038[1],
              _wP_=caml_call2(cmp_v,t_039,t_041);
             return _wP_?caml_call2(cmp_v,t_040,t_042):_wP_}}
         else
          if(typeof t_032 !== "number" && -57574468 === t_032[1])
           {var right_036=t_032[2],left_035=t_030[2];
            return caml_call2(cmp_v,left_035,right_036)}
        var _wO_=caml_equal(t_030,t_032)}
      else
       var _wO_=_wM_;
      return _wO_}
    function t_of_sexp$28(of_k_043,of_v_044,sexp_071)
     {if(1 === sexp_071[0])
       {var _wx_=sexp_071[1];
        if(_wx_)
         {var _wy_=_wx_[2];
          if(_wy_ && ! _wy_[2])
           {var
             arg1_068=_wy_[1],
             arg0_067=_wx_[1],
             res0_069=caml_call1(of_k_043,arg0_067);
            try
             {if(0 === arg1_068[0])
               var
                atom_047=arg1_068[1],
                _wz_=
                 caml_string_notequal(atom_047,cst_Left$2)
                  ?caml_string_notequal(atom_047,cst_Right$2)
                    ?caml_string_notequal(atom_047,cst_Unequal)
                      ?caml_call1(Sexplib0_Sexp_conv_error[19],0)
                      :caml_call2
                        (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068)
                    :caml_call2
                      (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068)
                  :caml_call2
                    (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068),
                _wA_=_wz_;
              else
               {var _wB_=arg1_068[1];
                if(_wB_)
                 {var _wC_=_wB_[1];
                  if(0 === _wC_[0])
                   {var sexp_args_050=_wB_[2],atom_047$0=_wC_[1];
                    if(caml_string_notequal(atom_047$0,cst_Left$3))
                     if(caml_string_notequal(atom_047$0,cst_Right$3))
                      if(caml_string_notequal(atom_047$0,cst_Unequal$0))
                       var _wD_=caml_call1(Sexplib0_Sexp_conv_error[19],0);
                      else
                       {var switch$0=0;
                        if(sexp_args_050 && ! sexp_args_050[2])
                         {var arg0_058=sexp_args_050[1],switch$1=0;
                          if(1 === arg0_058[0])
                           {var _wH_=arg0_058[1];
                            if(_wH_)
                             {var _wI_=_wH_[2];
                              if(_wI_ && ! _wI_[2])
                               {var
                                 arg1_053=_wI_[1],
                                 arg0_052=_wH_[1],
                                 res0_054=caml_call1(of_v_044,arg0_052),
                                 res1_055=caml_call1(of_v_044,arg1_053),
                                 res0_059=[0,res0_054,res1_055];
                                switch$1 = 1}}}
                          if(! switch$1)
                           var
                            res0_059=
                             caml_call3
                              (Sexplib0_Sexp_conv_error[2],error_source_057,2,arg0_058);
                          var _wG_=[0,1013247643,res0_059];
                          switch$0 = 1}
                        if(! switch$0)
                         var
                          _wG_=
                           caml_call3
                            (Sexplib0_Sexp_conv_error[22],
                             error_source_057,
                             atom_047$0,
                             arg1_068);
                        var _wD_=_wG_}
                     else
                      {var switch$2=0;
                       if(sexp_args_050 && ! sexp_args_050[2])
                        {var
                          arg0_061=sexp_args_050[1],
                          res0_062=caml_call1(of_v_044,arg0_061),
                          _wJ_=[0,-57574468,res0_062];
                         switch$2 = 1}
                       if(! switch$2)
                        var
                         _wJ_=
                          caml_call3
                           (Sexplib0_Sexp_conv_error[22],
                            error_source_057,
                            atom_047$0,
                            arg1_068);
                       var _wD_=_wJ_}
                    else
                     {var switch$3=0;
                      if(sexp_args_050 && ! sexp_args_050[2])
                       {var
                         arg0_064=sexp_args_050[1],
                         res0_065=caml_call1(of_v_044,arg0_064),
                         _wK_=[0,847852583,res0_065];
                        switch$3 = 1}
                      if(! switch$3)
                       var
                        _wK_=
                         caml_call3
                          (Sexplib0_Sexp_conv_error[22],
                           error_source_057,
                           atom_047$0,
                           arg1_068);
                      var _wD_=_wK_}
                    var _wE_=_wD_}
                  else
                   var
                    _wE_=
                     caml_call2
                      (Sexplib0_Sexp_conv_error[24],error_source_057,arg1_068);
                  var _wF_=_wE_}
                else
                 var
                  _wF_=
                   caml_call2
                    (Sexplib0_Sexp_conv_error[25],error_source_057,arg1_068);
                var _wA_=_wF_}
              var res1_070=_wA_}
            catch(_wL_)
             {_wL_ = caml_wrap_exception(_wL_);
              if(_wL_ !== Sexplib0_Sexp_conv_error[18])throw _wL_;
              var
               res1_070=
                caml_call2
                 (Sexplib0_Sexp_conv_error[20],error_source_057,arg1_068)}
            return [0,res0_069,res1_070]}}}
      return caml_call3
              (Sexplib0_Sexp_conv_error[2],error_source_057,2,sexp_071)}
    function sexp_of_t$44(of_k_072,of_v_073,param)
     {var
       arg1_082=param[2],
       arg0_081=param[1],
       res0_083=caml_call1(of_k_072,arg0_081),
       _ww_=arg1_082[1];
      if(847852583 === _ww_)
       var
        v_074=arg1_082[2],
        res1_084=[1,[0,_ec_,[0,caml_call1(of_v_073,v_074),0]]];
      else
       if(1013247643 <= _ww_)
        var
         v_076=arg1_082[2],
         arg1_078=v_076[2],
         arg0_077=v_076[1],
         res0_079=caml_call1(of_v_073,arg0_077),
         res1_080=caml_call1(of_v_073,arg1_078),
         res1_084=[1,[0,_ed_,[0,[1,[0,res0_079,[0,res1_080,0]]],0]]];
       else
        var
         v_075=arg1_082[2],
         res1_084=[1,[0,_ee_,[0,caml_call1(of_v_073,v_075),0]]];
      return [1,[0,res0_083,[0,res1_084,0]]]}
    function t_sexp_grammar$27(k_sexp_grammar,v_sexp_grammar)
     {return [2,
              [0,
               k_sexp_grammar,
               [0,
                [3,
                 [0,
                  1,
                  [0,
                   [1,[0,cst_Left$4,[0,[0,v_sexp_grammar,0]]]],
                   [0,
                    [1,[0,cst_Right$4,[0,[0,v_sexp_grammar,0]]]],
                    [0,
                     [1,
                      [0,
                       cst_Unequal$1,
                       [0,[0,[2,[0,v_sexp_grammar,[0,v_sexp_grammar,0]]],0]]]],
                     0]]]]],
                0]]]}
    var
     Symmetric_diff_element=
      [0,compare$46,equal$31,t_of_sexp$28,sexp_of_t$44,t_sexp_grammar$27];
    function compare$47(cmp_left,cmp_right,a_085,b_086)
     {if(a_085 === b_086)return 0;
      var _wv_=a_085[1];
      if(737457313 === _wv_)
       {if(typeof b_086 !== "number" && 737457313 === b_086[1])
         {var
           right_092=b_086[2],
           left_091=a_085[2],
           t_094=left_091[2],
           t_093=left_091[1],
           t_096=right_092[2],
           t_095=right_092[1],
           n=caml_call2(cmp_left,t_093,t_095);
          return 0 === n?caml_call2(cmp_right,t_094,t_096):n}}
      else
       if(847852583 <= _wv_)
        {if(typeof b_086 !== "number" && 847852583 === b_086[1])
          {var right_088=b_086[2],left_087=a_085[2];
           return caml_call2(cmp_left,left_087,right_088)}}
       else
        if(typeof b_086 !== "number" && -57574468 === b_086[1])
         {var right_090=b_086[2],left_089=a_085[2];
          return caml_call2(cmp_right,left_089,right_090)}
      return caml_compare(a_085,b_086)}
    function equal$32(cmp_left,cmp_right,a_097,b_098)
     {if(a_097 === b_098)return 1;
      var _wt_=a_097[1];
      if(737457313 === _wt_)
       {if(typeof b_098 !== "number" && 737457313 === b_098[1])
         {var
           right_104=b_098[2],
           left_103=a_097[2],
           t_106=left_103[2],
           t_105=left_103[1],
           t_108=right_104[2],
           t_107=right_104[1],
           _wu_=caml_call2(cmp_left,t_105,t_107);
          return _wu_?caml_call2(cmp_right,t_106,t_108):_wu_}}
      else
       if(847852583 <= _wt_)
        {if(typeof b_098 !== "number" && 847852583 === b_098[1])
          {var right_100=b_098[2],left_099=a_097[2];
           return caml_call2(cmp_left,left_099,right_100)}}
       else
        if(typeof b_098 !== "number" && -57574468 === b_098[1])
         {var right_102=b_098[2],left_101=a_097[2];
          return caml_call2(cmp_right,left_101,right_102)}
      return caml_equal(a_097,b_098)}
    function sexp_of_t$45(of_left_109,of_right_110,param)
     {var _ws_=param[1];
      if(737457313 === _ws_)
       {var
         v_113=param[2],
         arg1_115=v_113[2],
         arg0_114=v_113[1],
         res0_116=caml_call1(of_left_109,arg0_114),
         res1_117=caml_call1(of_right_110,arg1_115);
        return [1,[0,_ef_,[0,[1,[0,res0_116,[0,res1_117,0]]],0]]]}
      if(847852583 <= _ws_)
       {var v_111=param[2];
        return [1,[0,_eg_,[0,caml_call1(of_left_109,v_111),0]]]}
      var v_112=param[2];
      return [1,[0,_eh_,[0,caml_call1(of_right_110,v_112),0]]]}
    var
     include$59=[0,compare$47,equal$32,sexp_of_t$45],
     compare$48=caml_int_compare;
    function equal$33(_wr_,_wq_){return _wr_ === _wq_?1:0}
    function sexp_of_t$46(param){return param?_ei_:_ej_}
    var
     Continue_or_stop$1=[0,compare$48,all$16,equal$33,sexp_of_t$46],
     compare$49=caml_int_compare;
    function equal$34(_wp_,_wo_){return _wp_ === _wo_?1:0}
    function sexp_of_t$47(param){return param?_ek_:_el_}
    var include$60=[0,compare$49,all$17,equal$34,sexp_of_t$47];
    function Check_accessors(T,Tree,Key,Cmp,Options,symbol){return [0]}
    function Check_accessors1(M){return [0]}
    function Check_accessors2(M){return [0]}
    function Check_accessors3(M){return [0]}
    function Check_accessors3_with_comparat(M){return [0]}
    function Check_creators(T,Tree,Key,Cmp,Options,symbol){return [0]}
    function Check_creators1(M){return [0]}
    function Check_creators2(M){return [0]}
    function Check_creators3_with_comparato(M){return [0]}
    var
     include$61=
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       include$59,
       Continue_or_stop$1,
       include$60,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
    caml_register_global(1106,include$61,"Base__Map_intf");
    function Check_accessors$0(T,Tree,Elt,Named,Cmp,Options,symbol)
     {return [0]}
    function Check_accessors0(M){return [0]}
    function Check_accessors1$0(M){return [0]}
    function Check_accessors2$0(M){return [0]}
    function Check_accessors2_with_comparat(M){return [0]}
    function Check_creators$0(T,Tree,Elt,Cmp,Options,symbol){return [0]}
    function Check_creators0(M){return [0]}
    function Check_creators1$0(M){return [0]}
    function Check_creators2$0(M){return [0]}
    function Check_creators2_with_comparato(M){return [0]}
    var
     Base_Set_intf=
      [0,
       Check_accessors$0,
       Check_accessors0,
       Check_accessors1$0,
       Check_accessors2$0,
       Check_accessors2_with_comparat,
       Check_creators$0,
       Check_creators0,
       Check_creators1$0,
       Check_creators2$0,
       Check_creators2_with_comparato];
    caml_register_global(1107,Base_Set_intf,"Base__Set_intf");
    function height(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var h=param[4];
      return h}
    function length$12(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var s=param[5];
      return s}
    function in_range(lower,upper,compare_elt,v)
     {if(lower)
       var lower$0=lower[1],_wm_=caml_call2(compare_elt,lower$0,v) < 0?1:0;
      else
       var _wm_=1;
      if(_wm_)
       {if(upper)
         {var upper$0=upper[1];
          return caml_call2(compare_elt,v,upper$0) < 0?1:0}
        var _wn_=1}
      else
       var _wn_=_wm_;
      return _wn_}
    function loop(lower,upper,compare_elt,t)
     {var lower$0=lower,t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0])
         {var v=t$0[1];return in_range(lower$0,upper,compare_elt,v)}
        var
         n=t$0[5],
         h=t$0[4],
         r=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         hl=height(l),
         hr=height(r),
         _wf_=caml_call1(abs$0,hl - hr | 0) <= 2?1:0;
        if(_wf_)
         {var _wg_=h === (caml_call2(max$2,hl,hr) + 1 | 0)?1:0;
          if(_wg_)
           {var
             _wh_=length$12(r),
             _wi_=n === ((length$12(l) + _wh_ | 0) + 1 | 0)?1:0;
            if(_wi_)
             {var _wj_=in_range(lower$0,upper,compare_elt,v$0);
              if(_wj_)
               {var _wk_=loop(lower$0,[0,v$0],compare_elt,l);
                if(_wk_){var lower$1=[0,v$0],lower$0=lower$1,t$0=r;continue}
                var _wl_=_wk_}
              else
               var _wl_=_wj_}
            else
             var _wl_=_wi_}
          else
           var _wl_=_wg_}
        else
         var _wl_=_wf_;
        return _wl_}}
    function invariants(t,compare_elt){return loop(0,0,compare_elt,t)}
    function is_empty$6(param){return typeof param === "number"?1:0}
    function create$12(l,v,r)
     {if(typeof l === "number")
       var hl=0;
      else
       if(0 === l[0])var hl=1;else var h$1=l[4],hl=h$1;
      if(typeof r === "number")
       var hr=0;
      else
       if(0 === r[0])var hr=1;else var h$0=r[4],hr=h$0;
      var h=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      if(1 === h)return [0,v];
      if(typeof l === "number")
       var sl=0;
      else
       if(0 === l[0])var sl=1;else var s$0=l[5],sl=s$0;
      if(typeof r === "number")
       var sr=0;
      else
       if(0 === r[0])var sr=1;else var s=r[5],sr=s;
      return [1,l,v,r,h,(sl + sr | 0) + 1 | 0]}
    function of_increasing_iterator_uncheck(len,f)
     {function loop(n,f,i)
       {if(3 >= n >>> 0)
         switch(n)
          {case 0:return 0;
           case 1:var k$0=caml_call1(f,i);return [0,k$0];
           case 2:
            var kl=caml_call1(f,i),k$1=caml_call1(f,i + 1 | 0);
            return create$12([0,kl],k$1,0);
           default:
            var
             kl$0=caml_call1(f,i),
             k$2=caml_call1(f,i + 1 | 0),
             kr=caml_call1(f,i + 2 | 0);
            return create$12([0,kl$0],k$2,[0,kr])}
        var
         left_length=n >>> 1 | 0,
         right_length=(n - left_length | 0) - 1 | 0,
         left=loop(left_length,f,i),
         k=caml_call1(f,i + left_length | 0),
         right=loop(right_length,f,(i + left_length | 0) + 1 | 0);
        return create$12(left,k,right)}
      return loop(len,f,0)}
    function of_sorted_array_unchecked(array,compare_elt)
     {var array_length=array.length - 1,switch$0=0;
      if(2 <= array_length)
       {var _wd_=caml_check_bound(array,1)[2];
        if(0 <= caml_call2(compare_elt,caml_check_bound(array,0)[1],_wd_))
         {var
           next=
            function(i)
             {var _we_=(array_length - 1 | 0) - i | 0;
              return caml_check_bound(array,_we_)[1 + _we_]};
          switch$0 = 1}}
      if(! switch$0)
       var next=function(i){return caml_check_bound(array,i)[1 + i]};
      return of_increasing_iterator_uncheck(array_length,next)}
    function of_sorted_array(array,compare_elt)
     {var len=array.length - 1;
      if(1 !== len && len)
       return with_return
               (function(r)
                 {var
                   _v9_=caml_check_bound(array,1)[2],
                   i=caml_call2(compare_elt,caml_check_bound(array,0)[1],_v9_),
                   increasing=
                    0 === i
                     ?caml_call1(r,error_string(cst_of_sorted_array_duplicated))
                     :i < 0?1:0,
                   _v$_=array.length - 1 - 2 | 0,
                   _v__=1;
                  if(_v$_ >= 1)
                   {var i$0=_v__;
                    for(;;)
                     {var
                       _wa_=i$0 + 1 | 0,
                       _wb_=caml_check_bound(array,_wa_)[1 + _wa_],
                       i$1=
                        caml_call2
                         (compare_elt,caml_check_bound(array,i$0)[1 + i$0],_wb_);
                      if(0 === i$1)
                       caml_call1(r,error_string(cst_of_sorted_array_duplicated$0));
                      else
                       if((i$1 < 0?1:0) !== increasing)
                        caml_call1(r,error_string(cst_of_sorted_array_elements_a));
                      var _wc_=i$0 + 1 | 0;
                      if(_v$_ !== i$0){var i$0=_wc_;continue}
                      break}}
                  return [0,of_sorted_array_unchecked(array,compare_elt)]});
      return [0,of_sorted_array_unchecked(array,compare_elt)]}
    function bal(l,v,r)
     {if(typeof l === "number")
       var hl=0;
      else
       if(0 === l[0])var hl=1;else var h$1=l[4],hl=h$1;
      if(typeof r === "number")
       var hr=0;
      else
       if(0 === r[0])var hr=1;else var h$0=r[4],hr=h$0;
      if((hr + 2 | 0) < hl)
       {if(typeof l === "number")throw [0,Assert_failure$0,_em_];
        if(0 === l[0])throw [0,Assert_failure$0,_en_];
        var lr=l[3],lv=l[2],ll=l[1],_v3_=height(lr);
        if(_v3_ <= height(ll))return create$12(ll,lv,create$12(lr,v,r));
        if(typeof lr === "number")throw [0,Assert_failure$0,_eo_];
        if(0 !== lr[0])
         {var lrr=lr[3],lrv$0=lr[2],lrl=lr[1],_v5_=create$12(lrr,v,r);
          return create$12(create$12(ll,lv,lrl),lrv$0,_v5_)}
        var lrv=lr[1];
        if(! is_empty$6(ll))throw [0,Assert_failure$0,_ep_];
        var _v4_=create$12(0,v,r);
        return create$12(create$12(ll,lv,0),lrv,_v4_)}
      if((hl + 2 | 0) < hr)
       {if(typeof r === "number")throw [0,Assert_failure$0,_eq_];
        if(0 === r[0])throw [0,Assert_failure$0,_er_];
        var rr=r[3],rv=r[2],rl=r[1],_v6_=height(rl);
        if(_v6_ <= height(rr))return create$12(create$12(l,v,rl),rv,rr);
        if(typeof rl === "number")throw [0,Assert_failure$0,_es_];
        if(0 !== rl[0])
         {var rlr=rl[3],rlv$0=rl[2],rll=rl[1],_v8_=create$12(rlr,rv,rr);
          return create$12(create$12(l,v,rll),rlv$0,_v8_)}
        var rlv=rl[1];
        if(! is_empty$6(rr))throw [0,Assert_failure$0,_et_];
        var _v7_=create$12(0,rv,rr);
        return create$12(create$12(l,v,0),rlv,_v7_)}
      var h=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      if(typeof l === "number")
       var sl=0;
      else
       if(0 === l[0])var sl=1;else var s$0=l[5],sl=s$0;
      if(typeof r === "number")
       var sr=0;
      else
       if(0 === r[0])var sr=1;else var s=r[5],sr=s;
      return 1 === h?[0,v]:[1,l,v,r,h,(sl + sr | 0) + 1 | 0]}
    var Same=[248,cst_Base_Set_Tree0_Same,caml_fresh_oo_id(0)];
    function add$1(t,x,compare_elt)
     {function aux(param)
       {if(typeof param === "number")return [0,x];
        if(0 === param[0])
         {var v=param[1],c=caml_call2(compare_elt,x,v);
          if(0 === c)throw Same;
          return 0 <= c?create$12(0,v,[0,x]):create$12([0,x],v,0)}
        var
         r=param[3],
         v$0=param[2],
         l=param[1],
         c$0=caml_call2(compare_elt,x,v$0);
        if(0 === c$0)throw Same;
        return 0 <= c$0?bal(l,v$0,aux(r)):bal(aux(l),v$0,r)}
      try
       {var _v1_=aux(t);return _v1_}
      catch(_v2_)
       {_v2_ = caml_wrap_exception(_v2_);if(_v2_ === Same)return t;throw _v2_}}
    function join$6(l,v,r,compare_elt)
     {if(typeof l === "number")return add$1(r,v,compare_elt);
      if(1 === l[0])
       {var _vX_=l[4],_vY_=l[3],_vZ_=l[2],_v0_=l[1];
        if(typeof r !== "number")
         {if(0 === r[0])
           {var rv=r[1];return add$1(add$1(l,v,compare_elt),rv,compare_elt)}
          var rh=r[4],rr=r[3],rv$0=r[2],rl=r[1];
          return (rh + 2 | 0) < _vX_
                  ?bal(_v0_,_vZ_,join$6(_vY_,v,r,compare_elt))
                  :(_vX_ + 2 | 0) < rh
                    ?bal(join$6(l,v,rl,compare_elt),rv$0,rr)
                    :create$12(l,v,r)}}
      if(typeof r === "number")return add$1(l,v,compare_elt);
      var lv=l[1];
      return add$1(add$1(r,v,compare_elt),lv,compare_elt)}
    function min_elt$7(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         var v=param$0[1];
        else
         {var _vW_=param$0[1];
          if(typeof _vW_ !== "number"){var param$0=_vW_;continue}
          var v=param$0[2]}
        return [0,v]}}
    var
     Set_min_elt_exn_of_empty_set=
      [248,cst_Base_Set_Tree0_Set_min_elt,caml_fresh_oo_id(0)];
    function _eu_(param)
     {if(param === Set_min_elt_exn_of_empty_set)return _ev_;
      throw [0,Assert_failure$0,_ew_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Set_min_elt_exn_of_empty_set,_eu_);
    var
     Set_max_elt_exn_of_empty_set=
      [248,cst_Base_Set_Tree0_Set_max_elt,caml_fresh_oo_id(0)];
    function _ex_(param)
     {if(param === Set_max_elt_exn_of_empty_set)return _ey_;
      throw [0,Assert_failure$0,_ez_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Set_max_elt_exn_of_empty_set,_ex_);
    function min_elt_exn(t)
     {var match=min_elt$7(t);
      if(! match)throw Set_min_elt_exn_of_empty_set;
      var v=match[1];
      return v}
    function fold_until$6(t,init,f,finish)
     {function fold_until_helper(f,t,acc)
       {var t$0=t,acc$0=acc;
        for(;;)
         {if(typeof t$0 === "number")return [0,acc$0];
          if(0 === t$0[0]){var value=t$0[1];return caml_call2(f,acc$0,value)}
          var
           right=t$0[3],
           value$0=t$0[2],
           left=t$0[1],
           x=fold_until_helper(f,left,acc$0);
          if(0 !== x[0])return x;
          var acc$1=x[1],x$0=caml_call2(f,acc$1,value$0);
          if(0 !== x$0[0])return x$0;
          var acc$2=x$0[1],t$0=right,acc$0=acc$2}}
      var match=fold_until_helper(f,t,init);
      if(0 === match[0]){var x=match[1];return caml_call1(finish,x)}
      var x$0=match[1];
      return x$0}
    function max_elt$7(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         var v=param$0[1];
        else
         {if(typeof param$0[3] !== "number")
           {var param$1=param$0[3],param$0=param$1;continue}
          var v=param$0[2]}
        return [0,v]}}
    function max_elt_exn(t)
     {var match=max_elt$7(t);
      if(! match)throw Set_max_elt_exn_of_empty_set;
      var v=match[1];
      return v}
    function remove_min_elt(param)
     {if(typeof param === "number")
       return caml_call1(invalid_arg$0,cst_Set_remove_min_elt);
      if(0 === param[0])return 0;
      var _vV_=param[1];
      if(typeof _vV_ === "number"){var r=param[3];return r}
      var r$0=param[3],v=param[2];
      return bal(remove_min_elt(_vV_),v,r$0)}
    function merge$2(t1,t2)
     {if(typeof t1 === "number")return t2;
      if(typeof t2 === "number")return t1;
      var _vU_=remove_min_elt(t2);
      return bal(t1,min_elt_exn(t2),_vU_)}
    function concat$3(t1,t2,compare_elt)
     {if(typeof t1 === "number")
       var t=t2;
      else
       {if(typeof t2 !== "number")
         {var _vT_=remove_min_elt(t2);
          return join$6(t1,min_elt_exn(t2),_vT_,compare_elt)}
        var t=t1}
      return t}
    function split$1(t,x,compare_elt)
     {function split(t)
       {if(typeof t === "number")return _eA_;
        if(0 === t[0])
         {var v=t[1],c=caml_call2(compare_elt,x,v);
          return 0 === c?[0,0,[0,v],0]:0 <= c?[0,[0,v],0,0]:[0,0,0,[0,v]]}
        var r=t[3],v$0=t[2],l=t[1],c$0=caml_call2(compare_elt,x,v$0);
        if(0 === c$0)return [0,l,[0,v$0],r];
        if(0 <= c$0)
         {var match=split(r),rr=match[3],maybe_elt=match[2],lr=match[1];
          return [0,join$6(l,v$0,lr,compare_elt),maybe_elt,rr]}
        var
         match$0=split(l),
         rl=match$0[3],
         maybe_elt$0=match$0[2],
         ll=match$0[1];
        return [0,ll,maybe_elt$0,join$6(rl,v$0,r,compare_elt)]}
      return split(t)}
    var already_seen=0;
    function mem$5(t,x,compare_elt)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[1],c=caml_call2(compare_elt,x,v);return 0 === c?1:0}
        var
         r=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c$0=caml_call2(compare_elt,x,v$0),
         _vS_=0 === c$0?1:0;
        if(_vS_)return _vS_;
        var t$1=0 <= c$0?r:l,t$0=t$1}}
    function remove$0(t,x,compare_elt)
     {function aux(t)
       {if(typeof t === "number")throw Same;
        if(0 !== t[0])
         {var r=t[3],v$0=t[2],l=t[1],c=caml_call2(compare_elt,x,v$0);
          return 0 === c
                  ?merge$2(l,r)
                  :0 <= c?bal(l,v$0,aux(r)):bal(aux(l),v$0,r)}
        var v=t[1];
        if(0 === caml_call2(compare_elt,x,v))return 0;
        throw Same}
      try
       {var _vQ_=aux(t);return _vQ_}
      catch(_vR_)
       {_vR_ = caml_wrap_exception(_vR_);if(_vR_ === Same)return t;throw _vR_}}
    function remove_index(t,i,param)
     {function aux(t,i)
       {if(typeof t === "number")throw Same;
        if(0 !== t[0])
         {var
           r=t[3],
           v=t[2],
           l=t[1],
           l_size=length$12(l),
           c=caml_int_compare(i,l_size);
          return 0 === c
                  ?merge$2(l,r)
                  :0 <= c
                    ?bal(l,v,aux(r,(i - l_size | 0) - 1 | 0))
                    :bal(aux(l,i),v,r)}
        if(0 === i)return 0;
        throw Same}
      try
       {var _vO_=aux(t,i);return _vO_}
      catch(_vP_)
       {_vP_ = caml_wrap_exception(_vP_);if(_vP_ === Same)return t;throw _vP_}}
    function union(s1,s2,compare_elt)
     {function union(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(s1$0 === s2$0)return s1$0;
          var switch$0=0;
          if(typeof s1$0 === "number")
           {var t=s2$0;switch$0 = 1}
          else
           if(1 === s1$0[0])
            {var _vI_=s1$0[4],_vK_=s1$0[2],_vJ_=s1$0[3],_vL_=s1$0[1];
             if(typeof s2$0 !== "number")
              {if(0 === s2$0[0])
                {var v2=s2$0[1],s2$1=[1,0,v2,0,1,1],s2$0=s2$1;continue}
               var h2=s2$0[4],r2=s2$0[3],v2$0=s2$0[2],l2=s2$0[1];
               if(h2 <= _vI_)
                {if(1 === h2)return add$1(s1$0,v2$0,compare_elt);
                 var
                  match=split$1(s2$0,_vK_,compare_elt),
                  r2$0=match[3],
                  l2$0=match[1],
                  _vM_=union(_vJ_,r2$0);
                 return join$6(union(_vL_,l2$0),_vK_,_vM_,compare_elt)}
               if(1 === _vI_)return add$1(s2$0,_vK_,compare_elt);
               var
                match$0=split$1(s1$0,v2$0,compare_elt),
                r1=match$0[3],
                l1=match$0[1],
                _vN_=union(r1,r2);
               return join$6(union(l1,l2),v2$0,_vN_,compare_elt)}}
          if(! switch$0)
           {if(typeof s2$0 !== "number")
             {var v1=s1$0[1],s1$1=[1,0,v1,0,1,1],s1$0=s1$1;continue}
            var t=s1$0}
          return t}}
      return union(s1,s2)}
    function union_list(comparator,to_tree,xs)
     {var compare_elt=comparator[1];
      return fold_left
              (xs,
               already_seen,
               function(ac,x)
                {return union(ac,caml_call1(to_tree,x),compare_elt)})}
    function inter(s1,s2,compare_elt)
     {function inter(s1,s2)
       {if(s1 === s2)return s1;
        if(typeof s1 !== "number" && typeof s2 !== "number")
         {var switch$0=0;
          if(typeof s1 !== "number" && 0 !== s1[0])
           {if(typeof s2 !== "number" && 0 !== s2[0])
             {var
               r1=s1[3],
               v1=s1[2],
               l1=s1[1],
               _vD_=split$1(s2,v1,compare_elt),
               _vE_=_vD_[2],
               _vF_=_vD_[1];
              if(_vE_)
               {var r2=_vD_[3],v1$0=_vE_[1],_vG_=inter(r1,r2);
                return join$6(inter(l1,_vF_),v1$0,_vG_,compare_elt)}
              var r2$0=_vD_[3],_vH_=inter(r1,r2$0);
              return concat$3(inter(l1,_vF_),_vH_,compare_elt)}
            var other_set=s1,singleton=s2,elt=s2[1];
            switch$0 = 1}
          if(! switch$0)var other_set=s2,singleton=s1,elt=s1[1];
          return mem$5(other_set,elt,compare_elt)?singleton:0}
        return 0}
      return inter(s1,s2)}
    function diff(s1,s2,compare_elt)
     {function diff(s1,s2)
       {var s1$0=s1;
        for(;;)
         {if(s1$0 === s2)return 0;
          if(typeof s1$0 === "number")return 0;
          if(typeof s2 === "number")return s1$0;
          if(typeof s1$0 !== "number" && 0 !== s1$0[0])
           {var
             r1=s1$0[3],
             v1$0=s1$0[2],
             l1=s1$0[1],
             _vz_=split$1(s2,v1$0,compare_elt),
             _vA_=_vz_[1];
            if(_vz_[2])
             {var r2=_vz_[3],_vB_=diff(r1,r2);
              return concat$3(diff(l1,_vA_),_vB_,compare_elt)}
            var r2$0=_vz_[3],_vC_=diff(r1,r2$0);
            return join$6(diff(l1,_vA_),v1$0,_vC_,compare_elt)}
          var v1=s1$0[1],s1$1=[1,0,v1,0,1,1],s1$0=s1$1}}
      return diff(s1,s2)}
    function cons$0(s,e)
     {var s$0=s,e$0=e;
      for(;;)
       {if(typeof s$0 === "number")return e$0;
        if(0 === s$0[0]){var v=s$0[1];return [0,v,0,e$0]}
        var r=s$0[3],v$0=s$0[2],s$1=s$0[1],e$1=[0,v$0,r,e$0],s$0=s$1,e$0=e$1}}
    function cons_right(s,e)
     {var s$0=s,e$0=e;
      for(;;)
       {if(typeof s$0 === "number")return e$0;
        if(0 === s$0[0]){var v=s$0[1];return [0,v,0,e$0]}
        var s$1=s$0[3],v$0=s$0[2],l=s$0[1],e$1=[0,v$0,l,e$0],s$0=s$1,e$0=e$1}}
    function of_set(s){return cons$0(s,0)}
    function iter$11(f,param)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var enum$0=param$0[3],tree=param$0[2],a=param$0[1];
        caml_call1(f,a);
        var param$1=cons$0(tree,enum$0),param$0=param$1}}
    function symmetric_diff(t1,t2,compare_elt)
     {function step(state)
       {var _vs_=state[1];
        if(! _vs_)
         {var _vy_=state[2];
          if(! _vy_)return 0;
          var enum$0=_vy_[3],tree=_vy_[2],elt=_vy_[1];
          return [1,[1,elt],[0,0,cons$0(tree,enum$0)]]}
        var _vt_=state[2],_vu_=_vs_[3],_vv_=_vs_[2],_vw_=_vs_[1];
        if(! _vt_)return [1,[0,_vw_],[0,cons$0(_vv_,_vu_),0]];
        var
         enum2=_vt_[3],
         tree2=_vt_[2],
         a2=_vt_[1],
         compare_result=caml_call2(compare_elt,_vw_,a2);
        if(0 !== compare_result)
         return 0 <= compare_result
                 ?[1,[1,a2],[0,_vs_,cons$0(tree2,enum2)]]
                 :[1,[0,_vw_],[0,cons$0(_vv_,_vu_),_vt_]];
        if(_vv_ === tree2)
         var next_state=[0,_vu_,enum2];
        else
         var _vx_=cons$0(tree2,enum2),next_state=[0,cons$0(_vv_,_vu_),_vx_];
        return [0,next_state]}
      var _vr_=of_set(t2);
      return [0,[0,of_set(t1),_vr_],step]}
    function to_sequence$0
     (comparator,opt,greater_or_equal_to,less_or_equal_to,t$4)
     {if(opt)var sth=opt[1],order=sth;else var order=608542111;
      function inclusive_bound(side,t,bound)
       {var
         compare_elt=comparator[1],
         match=split$1(t,bound,compare_elt),
         r=match[3],
         maybe=match[2],
         l=match[1],
         t$0=caml_call1(side,[0,l,r]);
        if(! maybe)return t$0;
        var elt=maybe[1];
        return add$1(t$0,elt,compare_elt)}
      if(608542111 <= order)
       {var
         t$5=
          fold$0
           (less_or_equal_to,
            t$4,
            function(_vp_,_vq_){return inclusive_bound(get_key,_vp_,_vq_)}),
         next=
          function(enum$0)
           {if(! enum$0)return 0;
            var e=enum$0[3],t=enum$0[2],k=enum$0[1];
            return [1,k,cons$0(t,e)]};
        if(greater_or_equal_to)
         {var key=greater_or_equal_to[1],t=t$5,e=0,_vl_=comparator[1];
          for(;;)
           {if(typeof t !== "number")
             {if(0 === t[0]){var v=t[1],t$0=[1,0,v,0,1,1],t=t$0;continue}
              var l=t[1],r=t[3],v$0=t[2];
              if(0 <= caml_call2(_vl_,v$0,key))
               {var r$0=t[3],v$1=t[2],e$0=[0,v$1,r$0,e],t=l,e=e$0;continue}
              var t=r;
              continue}
            var init=e;
            break}}
        else
         var init=of_set(t$5);
        return [0,init,next]}
      var
       t$6=
        fold$0
         (greater_or_equal_to,
          t$4,
          function(_vn_,_vo_){return inclusive_bound(get_data,_vn_,_vo_)});
      function next$0(enum$0)
       {if(! enum$0)return 0;
        var e=enum$0[3],t=enum$0[2],k=enum$0[1];
        return [1,k,cons_right(t,e)]}
      if(less_or_equal_to)
       {var key$0=less_or_equal_to[1],t$1=t$6,e$1=0,_vm_=comparator[1];
        for(;;)
         {if(typeof t$1 !== "number")
           {if(0 === t$1[0])
             {var v$2=t$1[1],t$2=[1,0,v$2,0,1,1],t$1=t$2;continue}
            var l$0=t$1[1],v$3=t$1[2];
            if(0 < caml_call2(_vm_,v$3,key$0)){var t$1=l$0;continue}
            var t$3=t$1[3],v$4=t$1[2],e$2=[0,v$4,l$0,e$1],t$1=t$3,e$1=e$2;
            continue}
          var init$0=e$1;
          break}}
      else
       var init$0=cons_right(t$6,0);
      return [0,init$0,next$0]}
    function find_first_satisfying$0(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))
         {var x=find_first_satisfying$0(l,f);return x?x:[0,v$0]}
        var t$0=r}}
    function find_last_satisfying$0(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))
         {var x=find_last_satisfying$0(r,f);return x?x:[0,v$0]}
        var t$0=l}}
    function binary_search$1(t,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying$0
                   (t,function(x){return 0 <= caml_call2(compare,x,v)?1:0})
                 :find_last_satisfying$0
                   (t,function(x){return caml_call2(compare,x,v) < 0?1:0})
               :-253007807 <= how
                 ?find_last_satisfying$0
                   (t,function(x){return caml_call2(compare,x,v) <= 0?1:0})
                 :find_first_satisfying$0
                   (t,function(x){return 0 < caml_call2(compare,x,v)?1:0});
      if(-1055410545 <= how)
       {var
         elt=
          find_last_satisfying$0
           (t,function(x){return caml_call2(compare,x,v) <= 0?1:0});
        if(elt){var x=elt[1];if(0 === caml_call2(compare,x,v))return elt}
        return 0}
      var
       elt$0=
        find_first_satisfying$0
         (t,function(x){return 0 <= caml_call2(compare,x,v)?1:0});
      if(elt$0)
       {var x$0=elt$0[1];if(0 === caml_call2(compare,x$0,v))return elt$0}
      return 0}
    function binary_search_segmented$1(t,segment_of,how)
     {function is_left(x)
       {var match=caml_call1(segment_of,x);return 847852583 <= match?1:0}
      function is_right(x){return 1 - is_left(x)}
      return 125585502 <= how
              ?find_last_satisfying$0(t,is_left)
              :find_first_satisfying$0(t,is_right)}
    function merge_to_sequence
     (comparator,opt,greater_or_equal_to,less_or_equal_to,t$0,t)
     {if(opt)var sth=opt[1],order=sth;else var order=608542111;
      if(608542111 <= order)
       var _vg_=comparator[1];
      else
       var
        _vi_=comparator[1],
        _vg_=function(_vj_,_vk_){return flip(_vi_,_vj_,_vk_)};
      var
       _vh_=
        to_sequence$0
         (comparator,[0,order],greater_or_equal_to,less_or_equal_to,t);
      return merge_with_duplicates
              (to_sequence$0
                (comparator,
                 [0,order],
                 greater_or_equal_to,
                 less_or_equal_to,
                 t$0),
               _vh_,
               _vg_)}
    function compare$50(compare_elt,s1,s2)
     {var e2$2=of_set(s2),e1$2=of_set(s1),e1=e1$2,e2=e2$2;
      for(;;)
       {if(! e1)return e2?-1:0;
        if(! e2)return 1;
        var
         e2$0=e2[3],
         r2=e2[2],
         v2=e2[1],
         e1$0=e1[3],
         r1=e1[2],
         v1=e1[1],
         c=caml_call2(compare_elt,v1,v2);
        if(0 !== c)return c;
        if(r1 === r2){var e1=e1$0,e2=e2$0;continue}
        var e2$1=cons$0(r2,e2$0),e1$1=cons$0(r1,e1$0),e1=e1$1,e2=e2$1}}
    function iter2$0(s1,s2,compare_elt)
     {var t2=of_set(s2),t1=of_set(s1);
      return function(f)
       {var t1$0=t1,t2$0=t2;
        for(;;)
         {if(! t1$0)
           return t2$0
                   ?iter$11
                     (function(a){return caml_call1(f,[0,-57574468,a])},t2$0)
                   :0;
          if(! t2$0)
           return iter$11
                   (function(a){return caml_call1(f,[0,847852583,a])},t1$0);
          var
           enum2=t2$0[3],
           tree2=t2$0[2],
           a2=t2$0[1],
           enum1=t1$0[3],
           tree1=t1$0[2],
           a1=t1$0[1],
           compare_result=caml_call2(compare_elt,a1,a2);
          if(0 === compare_result)
           {caml_call1(f,[0,737457313,[0,a1,a2]]);
            var
             t2$1=cons$0(tree2,enum2),
             t1$1=cons$0(tree1,enum1),
             t1$0=t1$1,
             t2$0=t2$1;
            continue}
          if(0 <= compare_result)
           {caml_call1(f,[0,-57574468,a2]);
            var t2$2=cons$0(tree2,enum2),t2$0=t2$2;
            continue}
          caml_call1(f,[0,847852583,a1]);
          var t1$2=cons$0(tree1,enum1),t1$0=t1$2}}}
    function equal$35(s1,s2,compare_elt)
     {return 0 === compare$50(compare_elt,s1,s2)?1:0}
    function is_subset(s1,s2,compare_elt)
     {function is_subset(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(typeof s1$0 === "number")return 1;
          if(1 === s1$0[0])
           {var _u__=s1$0[3],_u$_=s1$0[2],_va_=s1$0[1];
            if(typeof s2$0 !== "number")
             {if(0 === s2$0[0])
               {var v2=s2$0[1];
                if(typeof _va_ === "number" && typeof _u__ === "number")
                 return 0 === caml_call2(compare_elt,_u$_,v2)?1:0;
                return 0}
              var
               r2=s2$0[3],
               v2$0=s2$0[2],
               l2=s2$0[1],
               c=caml_call2(compare_elt,_u$_,v2$0);
              if(0 !== c)
               {if(0 <= c)
                 {var _ve_=is_subset([1,0,_u$_,_u__,0,0],r2);
                  if(! _ve_)return _ve_;
                  var s1$0=_va_;
                  continue}
                var _vf_=is_subset([1,_va_,_u$_,0,0,0],l2);
                if(! _vf_)return _vf_;
                var s1$0=_u__;
                continue}
              var _vb_=s1$0 === s2$0?1:0;
              if(_vb_)
               var _vc_=_vb_;
              else
               {var _vd_=is_subset(_va_,l2);
                if(_vd_){var s1$0=_u__,s2$0=r2;continue}
                var _vc_=_vd_}
              return _vc_}}
          if(typeof s2$0 === "number")return 0;
          var v1=s1$0[1];
          return mem$5(s2$0,v1,compare_elt)}}
      return is_subset(s1,s2)}
    function are_disjoint(s1,s2,compare_elt)
     {var s1$0=s1,s2$0=s2;
      for(;;)
       {if(typeof s1$0 !== "number" && typeof s2$0 !== "number")
         {var switch$0=0;
          if(typeof s1$0 !== "number" && 0 !== s1$0[0])
           {if(typeof s2$0 !== "number" && 0 !== s2$0[0])
             {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
              if(s1$0 === s2$0)return 0;
              var _u7_=split$1(s2$0,v1,compare_elt),_u8_=_u7_[1];
              if(_u7_[2])return 0;
              var r2=_u7_[3],_u9_=are_disjoint(l1,_u8_,compare_elt);
              if(! _u9_)return _u9_;
              var s1$0=r1,s2$0=r2;
              continue}
            var other_set=s1$0,elt=s2$0[1];
            switch$0 = 1}
          if(! switch$0)var other_set=s2$0,elt=s1$0[1];
          return 1 - mem$5(other_set,elt,compare_elt)}
        return 1}}
    function iter$12(t,f)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return 0;
          if(0 === param$0[0]){var v=param$0[1];return caml_call1(f,v)}
          var r=param$0[3],v$0=param$0[2],l=param$0[1];
          iter(l);
          caml_call1(f,v$0);
          var param$0=r}}
      return iter(t)}
    function fold$8(s,accu,f)
     {var s$0=s,accu$0=accu;
      for(;;)
       {if(typeof s$0 === "number")return accu$0;
        if(0 === s$0[0]){var v=s$0[1];return caml_call2(f,accu$0,v)}
        var
         r=s$0[3],
         v$0=s$0[2],
         l=s$0[1],
         accu$1=caml_call2(f,fold$8(l,accu$0,f),v$0),
         s$0=r,
         accu$0=accu$1}}
    function count$6(t,f){return count(fold$8,t,f)}
    function sum$6(m,t,f){return caml_call2(sum(fold$8,m),t,f)}
    function fold_right$1(s,accu,f)
     {var s$0=s,accu$0=accu;
      for(;;)
       {if(typeof s$0 === "number")return accu$0;
        if(0 === s$0[0]){var v=s$0[1];return caml_call2(f,v,accu$0)}
        var
         r=s$0[3],
         v$0=s$0[2],
         l=s$0[1],
         accu$1=caml_call2(f,v$0,fold_right$1(r,accu$0,f)),
         s$0=l,
         accu$0=accu$1}}
    function for_all$7(t,p)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(p,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],_u4_=caml_call1(p,v$0);
        if(_u4_)
         {var _u5_=for_all$7(l,p);if(_u5_){var t$0=r;continue}var _u6_=_u5_}
        else
         var _u6_=_u4_;
        return _u6_}}
    function exists$7(t,p)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(p,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],_u1_=caml_call1(p,v$0);
        if(_u1_)
         var _u2_=_u1_;
        else
         {var _u3_=exists$7(l,p);if(! _u3_){var t$0=r;continue}var _u2_=_u3_}
        return _u2_}}
    function filter$4(s,p,compare_elt)
     {function filt(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1];
            return caml_call1(p,v)?add$1(accu$0,v,compare_elt):accu$0}
          var
           r=param$0[3],
           v$0=param$0[2],
           l=param$0[1],
           _u0_=caml_call1(p,v$0)?add$1(accu$0,v$0,compare_elt):accu$0,
           accu$1=filt(_u0_,l),
           accu$0=accu$1,
           param$0=r}}
      return filt(0,s)}
    function filter_map$2(s,p,compare_elt)
     {function filt(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1],match=caml_call1(p,v);
            if(! match)return accu$0;
            var v$0=match[1];
            return add$1(accu$0,v$0,compare_elt)}
          var
           r=param$0[3],
           v$1=param$0[2],
           l=param$0[1],
           match$0=caml_call1(p,v$1);
          if(match$0)
           var v$2=match$0[1],_uZ_=add$1(accu$0,v$2,compare_elt);
          else
           var _uZ_=accu$0;
          var accu$1=filt(_uZ_,l),accu$0=accu$1,param$0=r}}
      return filt(0,s)}
    function partition_tf$1(s,p,compare_elt)
     {function part(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {var _uW_=accu$0[2],_uX_=accu$0[1];
          if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1];
            return caml_call1(p,v)
                    ?[0,add$1(_uX_,v,compare_elt),_uW_]
                    :[0,_uX_,add$1(_uW_,v,compare_elt)]}
          var
           r=param$0[3],
           v$0=param$0[2],
           l=param$0[1],
           _uY_=
            caml_call1(p,v$0)
             ?[0,add$1(_uX_,v$0,compare_elt),_uW_]
             :[0,_uX_,add$1(_uW_,v$0,compare_elt)],
           accu$1=part(_uY_,l),
           accu$0=accu$1,
           param$0=r}}
      return part(_eB_,s)}
    function elements_aux(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return accu$0;
        if(0 === param$0[0]){var v=param$0[1];return [0,v,accu$0]}
        var
         r=param$0[3],
         v$0=param$0[2],
         l=param$0[1],
         accu$1=[0,v$0,elements_aux(accu$0,r)],
         accu$0=accu$1,
         param$0=l}}
    function elements(s){return elements_aux(0,s)}
    function choose(t)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var v=t[1];return [0,v]}
      var v$0=t[2];
      return [0,v$0]}
    var not_found$12=[0,Not_found_s,_eC_];
    function choose_exn(t)
     {var match=choose(t);
      if(! match)throw not_found$12;
      var v=match[1];
      return v}
    function of_list$4(lst,compare_elt)
     {return fold_left
              (lst,already_seen,function(t,x){return add$1(t,x,compare_elt)})}
    function of_sequence$0(sequence,compare_elt)
     {return fold$1
              (sequence,
               already_seen,
               function(t,x){return add$1(t,x,compare_elt)})}
    function to_list$8(s){return elements(s)}
    function of_array$1(a,compare_elt)
     {return fold(a,already_seen,function(t,x){return add$1(t,x,compare_elt)})}
    function to_array$7(param)
     {if(typeof param === "number")return [0];
      if(0 === param[0]){var v=param[1];return [0,v]}
      var
       s=param[5],
       r=param[3],
       v$0=param[2],
       l=param[1],
       res=caml_make_vect(s,v$0),
       pos_ref=[0,0];
      function loop(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return 0;
          if(0 === param$0[0])
           {var v=param$0[1],_uU_=pos_ref[1];
            caml_check_bound(res,_uU_)[1 + _uU_] = v;
            return incr(pos_ref)}
          var r=param$0[3],v$0=param$0[2],l=param$0[1];
          loop(l);
          var _uV_=pos_ref[1];
          caml_check_bound(res,_uV_)[1 + _uV_] = v$0;
          incr(pos_ref);
          var param$0=r}}
      loop(l);
      incr(pos_ref);
      loop(r);
      return res}
    function map$27(t,f,compare_elt)
     {return fold$8
              (t,
               already_seen,
               function(t,x){return add$1(t,caml_call1(f,x),compare_elt)})}
    function group_by(set,equiv,compare_elt)
     {var set$0=set,equiv_classes=0;
      for(;;)
       {if(is_empty$6(set$0))return equiv_classes;
        var
         x=choose_exn(set$0),
         match=
          partition_tf$1
           (set$0,
            function(x)
              {return function(elt)
                {var _uT_=x === elt?1:0;
                 return _uT_?_uT_:caml_call2(equiv,x,elt)}}
             (x),
            compare_elt),
         set$1=match[2],
         equiv_x=match[1],
         equiv_classes$0=[0,equiv_x,equiv_classes],
         set$0=set$1,
         equiv_classes=equiv_classes$0}}
    function find$7(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))return [0,v$0];
        var r$0=find$7(l,f);
        if(r$0)return r$0;
        var t$0=r}}
    function find_map$6(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],r$0=caml_call1(f,v$0);
        if(r$0)return r$0;
        var r$1=find_map$6(l,f);
        if(r$1)return r$1;
        var t$0=r}}
    function find_exn$3(t,f)
     {var match=find$7(t,f);
      if(! match)return caml_call1(failwith$0,cst_Set_find_exn_failed_to_fin);
      var e=match[1];
      return e}
    function nth$1(t,i)
     {var t$0=t,i$0=i;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return 0 === i$0?[0,v]:0}
        var s=t$0[5],r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(s <= i$0)return 0;
        var l_size=length$12(l),c=caml_int_compare(i$0,l_size);
        if(0 > c){var t$0=l;continue}
        if(0 === c)return [0,v$0];
        var i$1=(i$0 - l_size | 0) - 1 | 0,t$0=r,i$0=i$1}}
    function stable_dedup_list(xs,compare_elt)
     {var xs$0=xs,leftovers=0,already_seen$0=already_seen;
      for(;;)
       {if(! xs$0)return rev(leftovers);
        var tl=xs$0[2],hd=xs$0[1];
        if(mem$5(already_seen$0,hd,compare_elt)){var xs$0=tl;continue}
        var
         already_seen$1=add$1(already_seen$0,hd,compare_elt),
         leftovers$0=[0,hd,leftovers],
         xs$0=tl,
         leftovers=leftovers$0,
         already_seen$0=already_seen$1}}
    function t_of_sexp_direct(a_of_sexp,sexp,compare_elt)
     {if(0 === sexp[0])
       return caml_call2(of_sexp_error,cst_Set_t_of_sexp_list_needed,sexp);
      var
       lst=sexp[1],
       elt_lst=map$9(lst,a_of_sexp),
       set=of_list$4(elt_lst,compare_elt),
       _uS_=caml_call1(length,lst);
      if(length$12(set) === _uS_)return set;
      var set$0=[0,already_seen];
      iter2_exn
       (lst,
        elt_lst,
        function(el_sexp,el)
         {return mem$5(set$0[1],el,compare_elt)
                  ?caml_call2
                    (of_sexp_error,cst_Set_t_of_sexp_duplicate_el,el_sexp)
                  :(set$0[1] = add$1(set$0[1],el,compare_elt),0)});
      throw [0,Assert_failure$0,_eD_]}
    function sexp_of_t$48(sexp_of_a,t)
     {return [1,
              fold_right$1
               (t,0,function(el,acc){return [0,caml_call1(sexp_of_a,el),acc]})]}
    function is_subset$0(subset,superset,sexp_of_elt,compare_elt)
     {var invalid_elements=diff(subset[1],superset[1],compare_elt);
      if(is_empty$6(invalid_elements))return _eE_;
      var
       invalid_elements_sexp=sexp_of_t$48(sexp_of_elt,invalid_elements),
       _uR_=caml_call2(symbol$59,cst_is_not_a_subset_of,superset[2]);
      return error_s
              (caml_call2
                (message,
                 caml_call2(symbol$59,subset[2],_uR_),
                 [0,[0,cst_invalid_elements,invalid_elements_sexp],0]))}
    function like(param,tree)
     {var comparator=param[1];return [0,comparator,tree]}
    function compare_elt(t){return t[1][1]}
    function comparator$12(t){return t[1]}
    function invariants$0(t)
     {var _uQ_=compare_elt(t);return invariants(t[2],_uQ_)}
    function length$13(t){return length$12(t[2])}
    function is_empty$7(t){return is_empty$6(t[2])}
    function elements$0(t){return elements(t[2])}
    function min_elt$8(t){return min_elt$7(t[2])}
    function min_elt_exn$0(t){return min_elt_exn(t[2])}
    function max_elt$8(t){return max_elt$7(t[2])}
    function max_elt_exn$0(t){return max_elt_exn(t[2])}
    function choose$0(t){return choose(t[2])}
    function choose_exn$0(t){return choose_exn(t[2])}
    function to_list$9(t){return to_list$8(t[2])}
    function to_array$8(t){return to_array$7(t[2])}
    function fold$9(t,init,f){return fold$8(t[2],init,f)}
    function fold_until$7(t,init,f)
     {var _uO_=t[2];
      return function(_uP_){return fold_until$6(_uO_,init,f,_uP_)}}
    function fold_right$2(t,init,f){return fold_right$1(t[2],init,f)}
    function fold_result$6(t,init,f){return fold_result(fold$9,init,f,t)}
    function iter$13(t,f){return iter$12(t[2],f)}
    function iter2$1(a,b,f)
     {var _uN_=compare_elt(a);return caml_call1(iter2$0(a[2],b[2],_uN_),f)}
    function exists$8(t,f){return exists$7(t[2],f)}
    function for_all$8(t,f){return for_all$7(t[2],f)}
    function count$7(t,f){return count$6(t[2],f)}
    function sum$7(m,t,f){return sum$6(m,t[2],f)}
    function find$8(t,f){return find$7(t[2],f)}
    function find_exn$4(t,f){return find_exn$3(t[2],f)}
    function find_map$7(t,f){return find_map$6(t[2],f)}
    function mem$6(t,a){var _uM_=compare_elt(t);return mem$5(t[2],a,_uM_)}
    function filter$5(t,f)
     {var _uL_=compare_elt(t);return like(t,filter$4(t[2],f,_uL_))}
    function add$2(t,a)
     {var _uK_=compare_elt(t);return like(t,add$1(t[2],a,_uK_))}
    function remove$1(t,a)
     {var _uJ_=compare_elt(t);return like(t,remove$0(t[2],a,_uJ_))}
    function union$0(t1,t2)
     {var _uI_=compare_elt(t1);return like(t1,union(t1[2],t2[2],_uI_))}
    function inter$0(t1,t2)
     {var _uH_=compare_elt(t1);return like(t1,inter(t1[2],t2[2],_uH_))}
    function diff$0(t1,t2)
     {var _uG_=compare_elt(t1);return like(t1,diff(t1[2],t2[2],_uG_))}
    function symmetric_diff$0(t1,t2)
     {var _uF_=compare_elt(t1);return symmetric_diff(t1[2],t2[2],_uF_)}
    function compare_direct(t1,t2)
     {var _uD_=t2[2],_uE_=t1[2];return compare$50(compare_elt(t1),_uE_,_uD_)}
    function equal$36(t1,t2)
     {var _uC_=compare_elt(t1);return equal$35(t1[2],t2[2],_uC_)}
    function is_subset$1(t,of)
     {var _uB_=compare_elt(t);return is_subset(t[2],of[2],_uB_)}
    function are_disjoint$0(t1,t2)
     {var _uA_=compare_elt(t1);return are_disjoint(t1[2],t2[2],_uA_)}
    function to_named_tree(param)
     {var name=param[2],set=param[1];return [0,set[2],name]}
    function is_subset$2(subset,superset)
     {var
       _ux_=compare_elt(subset[1]),
       _uy_=subset[1][1][2],
       _uz_=to_named_tree(superset);
      return is_subset$0(to_named_tree(subset),_uz_,_uy_,_ux_)}
    function equal$37(t1,t2)
     {var _uw_=[0,is_subset$2(t2,t1),0];
      return combine_errors_unit$0([0,is_subset$2(t1,t2),_uw_])}
    function partition_tf$2(t,f)
     {var
       _uu_=compare_elt(t),
       match=partition_tf$1(t[2],f,_uu_),
       tree_f=match[2],
       tree_t=match[1],
       _uv_=like(t,tree_f);
      return [0,like(t,tree_t),_uv_]}
    function split$2(t,a)
     {var
       _us_=compare_elt(t),
       match=split$1(t[2],a,_us_),
       tree2=match[3],
       b=match[2],
       tree1=match[1],
       _ut_=like(t,tree2);
      return [0,like(t,tree1),b,_ut_]}
    function group_by$0(t,equiv)
     {function _up_(_ur_){return like(t,_ur_)}
      var _uq_=compare_elt(t);
      return map$9(group_by(t[2],equiv,_uq_),_up_)}
    function nth$2(t,i){return nth$1(t[2],i)}
    function remove_index$0(t,i)
     {var _uo_=compare_elt(t);return like(t,remove_index(t[2],i,_uo_))}
    function sexp_of_t$49(sexp_of_a,param,t)
     {return sexp_of_t$48(sexp_of_a,t[2])}
    function to_sequence$1(order,greater_or_equal_to,less_or_equal_to,t)
     {return to_sequence$0
              (t[1],order,greater_or_equal_to,less_or_equal_to,t[2])}
    function binary_search$2(t,compare,how,v)
     {return binary_search$1(t[2],compare,how,v)}
    function binary_search_segmented$2(t,segment_of,how)
     {return binary_search_segmented$1(t[2],segment_of,how)}
    function merge_to_sequence$0
     (order,greater_or_equal_to,less_or_equal_to,t$0,t)
     {return merge_to_sequence
              (t$0[1],order,greater_or_equal_to,less_or_equal_to,t$0[2],t[2])}
    function hash_fold_direct(hash_fold_key,state,t)
     {var _un_=t[2];
      return fold$8
              (_un_,
               caml_call2(hash_fold_t$4,state,length$12(_un_)),
               hash_fold_key)}
    function compare$51(param,_um_,t1,t2){return compare_direct(t1,t2)}
    function t_of_sexp_direct$0(comparator,a_of_sexp,sexp)
     {return t_of_sexp_direct(a_of_sexp,sexp,comparator[1])}
    function empty$1(param){return already_seen}
    function singleton$3(param,e){return [0,e]}
    function length$14(t){return length$12(t)}
    function invariants$1(comparator,t){return invariants(t,comparator[1])}
    function is_empty$8(t){return is_empty$6(t)}
    function elements$1(t){return elements(t)}
    function min_elt$9(t){return min_elt$7(t)}
    function min_elt_exn$1(t){return min_elt_exn(t)}
    function max_elt$9(t){return max_elt$7(t)}
    function max_elt_exn$1(t){return max_elt_exn(t)}
    function choose$1(t){return choose(t)}
    function choose_exn$1(t){return choose_exn(t)}
    function to_list$10(t){return to_list$8(t)}
    function to_array$9(t){return to_array$7(t)}
    function iter$14(t,f){return iter$12(t,f)}
    function exists$9(t,f){return exists$7(t,f)}
    function for_all$9(t,f){return for_all$7(t,f)}
    function count$8(t,f){return count$6(t,f)}
    function sum$8(m,t,f){return sum$6(m,t,f)}
    function find$9(t,f){return find$7(t,f)}
    function find_exn$5(t,f){return find_exn$3(t,f)}
    function find_map$8(t,f){return find_map$6(t,f)}
    function fold$10(t,init,f){return fold$8(t,init,f)}
    function fold_until$8(t,init,f)
     {return function(_ul_){return fold_until$6(t,init,f,_ul_)}}
    function fold_right$3(t,init,f){return fold_right$1(t,init,f)}
    function map$28(comparator,t,f){return map$27(t,f,comparator[1])}
    function filter$6(comparator,t,f){return filter$4(t,f,comparator[1])}
    function filter_map$3(comparator,t,f)
     {return filter_map$2(t,f,comparator[1])}
    function partition_tf$3(comparator,t,f)
     {return partition_tf$1(t,f,comparator[1])}
    function iter2$2(comparator,a,b,f)
     {return caml_call1(iter2$0(a,b,comparator[1]),f)}
    function mem$7(comparator,t,a){return mem$5(t,a,comparator[1])}
    function add$3(comparator,t,a){return add$1(t,a,comparator[1])}
    function remove$2(comparator,t,a){return remove$0(t,a,comparator[1])}
    function union$1(comparator,t1,t2){return union(t1,t2,comparator[1])}
    function inter$1(comparator,t1,t2){return inter(t1,t2,comparator[1])}
    function diff$1(comparator,t1,t2){return diff(t1,t2,comparator[1])}
    function symmetric_diff$1(comparator,t1,t2)
     {return symmetric_diff(t1,t2,comparator[1])}
    function compare_direct$0(comparator,t1,t2)
     {return compare$50(comparator[1],t1,t2)}
    function equal$38(comparator,t1,t2){return equal$35(t1,t2,comparator[1])}
    function is_subset$3(comparator,t,of)
     {return is_subset(t,of,comparator[1])}
    function are_disjoint$1(comparator,t1,t2)
     {return are_disjoint(t1,t2,comparator[1])}
    function of_list$5(comparator,l){return of_list$4(l,comparator[1])}
    function of_sequence$1(comparator,s)
     {return of_sequence$0(s,comparator[1])}
    function of_array$2(comparator,a){return of_array$1(a,comparator[1])}
    function of_sorted_array_unchecked$0(comparator,a)
     {return of_sorted_array_unchecked(a,comparator[1])}
    function of_increasing_iterator_uncheck$0(param,len,f)
     {return of_increasing_iterator_uncheck(len,f)}
    function of_sorted_array$0(comparator,a)
     {return of_sorted_array(a,comparator[1])}
    function union_list$0(comparator,l)
     {return union_list(comparator,function(_uk_){return _uk_},l)}
    function stable_dedup_list$0(comparator,xs)
     {return stable_dedup_list(xs,comparator[1])}
    function group_by$1(comparator,t,equiv)
     {return group_by(t,equiv,comparator[1])}
    function split$3(comparator,t,a){return split$1(t,a,comparator[1])}
    function nth$3(t,i){return nth$1(t,i)}
    function remove_index$1(comparator,t,i)
     {return remove_index(t,i,comparator[1])}
    function sexp_of_t$50(sexp_of_a,param,t){return sexp_of_t$48(sexp_of_a,t)}
    function to_tree(t){return t}
    function of_tree(param,t){return t}
    function to_sequence$2
     (comparator,order,greater_or_equal_to,less_or_equal_to,t)
     {return to_sequence$0
              (comparator,order,greater_or_equal_to,less_or_equal_to,t)}
    function binary_search$3(param,t,compare,how,v)
     {return binary_search$1(t,compare,how,v)}
    function binary_search_segmented$3(param,t,segment_of,how)
     {return binary_search_segmented$1(t,segment_of,how)}
    function merge_to_sequence$1
     (comparator,order,greater_or_equal_to,less_or_equal_to,t$0,t)
     {return merge_to_sequence
              (comparator,order,greater_or_equal_to,less_or_equal_to,t$0,t)}
    function fold_result$7(t,init,f){return fold_result(fold$10,init,f,t)}
    function is_subset$4(comparator,t1,t2)
     {return is_subset$0(t1,t2,comparator[2],comparator[1])}
    function equal$39(comparator,t1,t2)
     {var
       _ui_=comparator[1],
       _uj_=comparator[2],
       _uh_=[0,is_subset$0(t2,t1,_uj_,_ui_),0];
      return combine_errors_unit$0([0,is_subset$0(t1,t2,_uj_,_ui_),_uh_])}
    var Named=[0,is_subset$4,equal$39];
    function to_tree$0(t){return t[2]}
    function of_tree$0(comparator,tree){return [0,comparator,tree]}
    function t_of_sexp_direct$1(comparator,a_of_sexp,sexp)
     {return [0,comparator,t_of_sexp_direct(a_of_sexp,sexp,comparator[1])]}
    function empty$2(comparator){return [0,comparator,already_seen]}
    function Empty_without_value_restrictio(Elt)
     {var empty=[0,Elt[1],already_seen];return [0,empty]}
    function singleton$4(comparator,e){return [0,comparator,[0,e]]}
    function union_list$1(comparator,l)
     {return [0,comparator,union_list(comparator,to_tree$0,l)]}
    function of_sorted_array_unchecked$1(comparator,array)
     {var tree=of_sorted_array_unchecked(array,comparator[1]);
      return [0,comparator,tree]}
    function of_increasing_iterator_uncheck$1(comparator,len,f)
     {return [0,comparator,of_increasing_iterator_uncheck(len,f)]}
    function of_sorted_array$1(comparator,array)
     {function _uf_(tree){return [0,comparator,tree]}
      var _ug_=of_sorted_array(array,comparator[1]);
      return caml_call2(include$26[2],_ug_,_uf_)}
    function of_list$6(comparator,l)
     {return [0,comparator,of_list$4(l,comparator[1])]}
    function of_sequence$2(comparator,s)
     {return [0,comparator,of_sequence$0(s,comparator[1])]}
    function of_array$3(comparator,a)
     {return [0,comparator,of_array$1(a,comparator[1])]}
    function stable_dedup_list$1(comparator,xs)
     {return stable_dedup_list(xs,comparator[1])}
    function map$29(comparator,t,f)
     {return [0,comparator,map$27(t[2],f,comparator[1])]}
    function filter_map$4(comparator,t,f)
     {return [0,comparator,filter_map$2(t[2],f,comparator[1])]}
    function comparator_s(t){var comparator=t[1];return [0,comparator]}
    function empty$3(m){return empty$2(m[1])}
    function singleton$5(m,a){return singleton$4(m[1],a)}
    function union_list$2(m,a){return union_list$1(m[1],a)}
    function of_sorted_array_unchecked$2(m,a)
     {return of_sorted_array_unchecked$1(m[1],a)}
    function of_increasing_iterator_uncheck$2(m,len,f)
     {return of_increasing_iterator_uncheck$1(m[1],len,f)}
    function of_sorted_array$2(m,a){return of_sorted_array$1(m[1],a)}
    function of_list$7(m,a){return of_list$6(m[1],a)}
    function of_sequence$3(m,a){return of_sequence$2(m[1],a)}
    function of_array$4(m,a){return of_array$3(m[1],a)}
    function stable_dedup_list$2(m,a){return stable_dedup_list$1(m[1],a)}
    function map$30(m,a,f){return map$29(m[1],a,f)}
    function filter_map$5(m,a,f){return filter_map$4(m[1],a,f)}
    function M(Elt){return [0]}
    function sexp_of_m_t(Elt)
     {return function(t)
       {function _ue_(param){return _eF_}return sexp_of_t$49(Elt[1],_ue_,t)}}
    function m_t_of_sexp(Elt)
     {return function(sexp){return t_of_sexp_direct$1(Elt[2],Elt[1],sexp)}}
    function m_t_sexp_grammar(Elt)
     {var _ud_=caml_call1(list_sexp_grammar,Elt[1]);
      return caml_call1(Sexplib0_Sexp_grammar[1],_ud_)}
    function compare_m_t(param,t1,t2){return compare_direct(t1,t2)}
    function equal_m_t(param,t1,t2){return equal$36(t1,t2)}
    function hash_fold_m_t(Elt)
     {return function(state)
       {var _ub_=Elt[1];
        return function(_uc_){return hash_fold_direct(_ub_,state,_uc_)}}}
    function hash_m_t(folder,t)
     {var _ua_=create$0(0,0),state=caml_call2(hash_fold_m_t(folder),_ua_,t);
      return runtime.Base_internalhash_get_hash_value(state)}
    var
     comparator$13=Poly[1],
     include$62=Empty_without_value_restrictio(Poly),
     empty$4=include$62[1];
    function singleton$6(a){return singleton$4(comparator$13,a)}
    function union_list$3(a){return union_list$1(comparator$13,a)}
    function of_sorted_array_unchecked$3(a)
     {return of_sorted_array_unchecked$1(comparator$13,a)}
    function of_increasing_iterator_uncheck$3(len,f)
     {return of_increasing_iterator_uncheck$1(comparator$13,len,f)}
    function of_sorted_array$3(a){return of_sorted_array$1(comparator$13,a)}
    function of_list$8(a){return of_list$6(comparator$13,a)}
    function of_sequence$4(a){return of_sequence$2(comparator$13,a)}
    function of_array$5(a){return of_array$3(comparator$13,a)}
    function stable_dedup_list$3(a)
     {return stable_dedup_list$1(comparator$13,a)}
    function map$31(a,f){return map$29(comparator$13,a,f)}
    function filter_map$6(a,f){return filter_map$4(comparator$13,a,f)}
    function of_tree$1(tree){return [0,comparator$13,tree]}
    function to_tree$1(t){return t[2]}
    var
     Base_Set=
      [0,
       compare$51,
       invariants$0,
       comparator_s,
       comparator$12,
       empty$3,
       singleton$5,
       length$13,
       is_empty$7,
       mem$6,
       add$2,
       remove$1,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$36,
       exists$8,
       for_all$8,
       count$7,
       sum$7,
       find$8,
       find_map$7,
       find_exn$4,
       nth$2,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0,is_subset$2,equal$37],
       of_list$7,
       of_sequence$3,
       of_array$4,
       to_list$9,
       to_array$8,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$30,
       filter_map$5,
       filter$5,
       fold$9,
       fold_result$6,
       fold_until$7,
       fold_right$2,
       iter$13,
       iter2$1,
       partition_tf$2,
       elements$0,
       min_elt$8,
       min_elt_exn$0,
       max_elt$8,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$2,
       group_by$0,
       to_sequence$1,
       binary_search$2,
       binary_search_segmented$2,
       [0,
        Merge_with_duplicates_element[1],
        Merge_with_duplicates_element[3],
        Merge_with_duplicates_element[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$13,
        is_empty$7,
        iter$13,
        fold$9,
        fold_result$6,
        exists$8,
        for_all$8,
        count$7,
        sum$7,
        find$8,
        find_map$7,
        to_list$9,
        to_array$8,
        invariants$0,
        mem$6,
        add$2,
        remove$1,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$36,
        is_subset$1,
        are_disjoint$0,
        [0,is_subset$2,equal$37],
        fold_until$7,
        fold_right$2,
        iter2$1,
        filter$5,
        partition_tf$2,
        elements$0,
        min_elt$8,
        min_elt_exn$0,
        max_elt$8,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$2,
        group_by$0,
        find_exn$4,
        nth$2,
        remove_index$0,
        to_tree$1,
        to_sequence$1,
        binary_search$2,
        binary_search_segmented$2,
        merge_to_sequence$0,
        empty$4,
        singleton$6,
        union_list$3,
        of_list$8,
        of_sequence$4,
        of_array$5,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$31,
        filter_map$6,
        of_tree$1],
       [0,
        sexp_of_t$49,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$50,
         t_of_sexp_direct$0,
         Named,
         length$14,
         is_empty$8,
         iter$14,
         fold$10,
         fold_result$7,
         exists$9,
         for_all$9,
         count$8,
         sum$8,
         find$9,
         find_map$8,
         to_list$10,
         to_array$9,
         invariants$1,
         mem$7,
         add$3,
         remove$2,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$38,
         is_subset$3,
         are_disjoint$1,
         fold_until$8,
         fold_right$3,
         iter2$2,
         filter$6,
         partition_tf$3,
         elements$1,
         min_elt$9,
         min_elt_exn$1,
         max_elt$9,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$3,
         group_by$1,
         find_exn$5,
         nth$3,
         remove_index$1,
         to_tree,
         to_sequence$2,
         binary_search$3,
         binary_search_segmented$3,
         merge_to_sequence$1,
         empty$1,
         singleton$3,
         union_list$0,
         of_list$5,
         of_sequence$1,
         of_array$2,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$28,
         filter_map$3,
         of_tree,
         already_seen],
        length$13,
        is_empty$7,
        iter$13,
        fold$9,
        fold_result$6,
        exists$8,
        for_all$8,
        count$7,
        sum$7,
        find$8,
        find_map$7,
        to_list$9,
        to_array$8,
        invariants$0,
        mem$6,
        add$2,
        remove$1,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$36,
        is_subset$1,
        are_disjoint$0,
        [0,is_subset$2,equal$37],
        fold_until$7,
        fold_right$2,
        iter2$1,
        filter$5,
        partition_tf$2,
        elements$0,
        min_elt$8,
        min_elt_exn$0,
        max_elt$8,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$2,
        group_by$0,
        find_exn$4,
        nth$2,
        remove_index$0,
        to_tree$0,
        to_sequence$1,
        binary_search$2,
        binary_search_segmented$2,
        merge_to_sequence$0,
        empty$2,
        singleton$4,
        union_list$1,
        of_list$6,
        of_sequence$2,
        of_array$3,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$29,
        filter_map$4,
        of_tree$0,
        comparator$12,
        hash_fold_direct,
        Empty_without_value_restrictio]];
    caml_register_global(1108,Base_Set,"Base__Set");
    function t_sexp_grammar$28(a_sexp_grammar)
     {return caml_call1(ref_sexp_grammar,a_sexp_grammar)}
    function swap$5(t1,t2){var tmp=t1[1];t1[1] = t2[1];t2[1] = tmp;return 0}
    function replace(t,f){t[1] = caml_call1(f,t[1]);return 0}
    function set_temporarily(t,a,f)
     {var restore_to=t[1];
      t[1] = a;
      return protect(f,function(param){t[1] = restore_to;return 0})}
    function set$3(param){var a=param[2],r=param[1];r[1] = a;return 0}
    function sets(ts){return iter$0(ts,set$3)}
    function snapshot(param){var r=param[1];return [0,r,r[1]]}
    function sets_temporarily(and_values,f)
     {var restore_to=map$9(and_values,snapshot);
      sets(and_values);
      return protect(f,function(param){return sets(restore_to)})}
    var
     Base_Ref=
      [0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp,
       sexp_of_ref,
       t_sexp_grammar$28,
       swap$5,
       replace,
       set_temporarily,
       [0,set$3,sets,snapshot],
       sets_temporarily];
    caml_register_global(1109,Base_Ref,"Base__Ref");
    var Base_Queue_intf=[0];
    caml_register_global(1110,Base_Queue_intf,"Base__Queue_intf");
    function inc_num_mutations(t){t[1] = t[1] + 1 | 0;return 0}
    function capacity$0(t){return t[3] + 1 | 0}
    function elts_index(t,i){return (t[2] + i | 0) & t[3]}
    function unsafe_get$2(t,i)
     {var _t$_=elts_index(t,i);return unsafe_get_some_exn(t[5],_t$_)}
    function unsafe_set$2(t,i,a)
     {var _t__=elts_index(t,i);return unsafe_set_some(t[5],_t__,a)}
    function check_index_exn(t,i)
     {var _t7_=i < 0?1:0,_t8_=_t7_ || (t[4] <= i?1:0);
      if(! _t8_)return _t8_;
      var _t9_=[0,[0,cst_length,caml_call1(sexp_of_t$33,t[4])],0];
      return raise_s
              (caml_call2
                (message,
                 cst_Queue_index_out_of_bounds,
                 [0,[0,cst_index,caml_call1(sexp_of_t$33,i)],_t9_]))}
    function get$5(t,i){check_index_exn(t,i);return unsafe_get$2(t,i)}
    function set$4(t,i,a)
     {check_index_exn(t,i);inc_num_mutations(t);return unsafe_set$2(t,i,a)}
    function is_empty$9(t){return 0 === t[4]?1:0}
    function length$15(param){var length=param[4];return length}
    function ensure_no_mutation(t,num_mutations)
     {var _t5_=t[1] !== num_mutations?1:0;
      if(! _t5_)return _t5_;
      var _t6_=0;
      function of_a_001(param){return _eL_}
      var
       num_mutations_003=t[1],
       front_005=t[2],
       mask_007=t[3],
       length_009=t[4],
       elts_011=t[5],
       arg_012=sexp_of_t$38(of_a_001,elts_011),
       bnds_002=[0,[1,[0,_eG_,[0,arg_012,0]]],0],
       arg_010=caml_call1(sexp_of_t$4,length_009),
       bnds_002$0=[0,[1,[0,_eH_,[0,arg_010,0]]],bnds_002],
       arg_008=caml_call1(sexp_of_t$4,mask_007),
       bnds_002$1=[0,[1,[0,_eI_,[0,arg_008,0]]],bnds_002$0],
       arg_006=caml_call1(sexp_of_t$4,front_005),
       bnds_002$2=[0,[1,[0,_eJ_,[0,arg_006,0]]],bnds_002$1],
       arg_004=caml_call1(sexp_of_t$4,num_mutations_003),
       bnds_002$3=[0,[1,[0,_eK_,[0,arg_004,0]]],bnds_002$2];
      return raise_s
              (caml_call2
                (message,
                 cst_mutation_of_queue_during_i,
                 [0,[0,cst$29,[1,bnds_002$3]],_t6_]))}
    function compare$52(compare_elt,t1,t2)
     {if(t1 === t2)return 0;
      var pos=0,_t1_=t2[1],_t2_=t1[1],_t3_=t2[4],_t4_=t1[4];
      for(;;)
       {var match=pos === _t3_?1:0;
        if(pos === _t4_)return match?0:-1;
        if(match)return 1;
        var
         _t0_=unsafe_get$2(t2,pos),
         x=caml_call2(compare_elt,unsafe_get$2(t1,pos),_t0_);
        ensure_no_mutation(t1,_t2_);
        ensure_no_mutation(t2,_t1_);
        if(0 !== x)return x;
        var pos$0=pos + 1 | 0,pos=pos$0}}
    function equal$40(equal_elt,t1,t2)
     {var _tV_=t1 === t2?1:0;
      if(_tV_)
       var _tW_=_tV_;
      else
       {var len1=t1[4],len2=t2[4],_tX_=len1 === len2?1:0;
        if(_tX_)
         {var pos=0,_tY_=t2[1],_tZ_=t1[1];
          for(;;)
           {var _tS_=pos === len1?1:0;
            if(_tS_)
             var _tT_=_tS_;
            else
             {var
               _tU_=unsafe_get$2(t2,pos),
               b=caml_call2(equal_elt,unsafe_get$2(t1,pos),_tU_);
              ensure_no_mutation(t1,_tZ_);
              ensure_no_mutation(t2,_tY_);
              if(b){var pos$0=pos + 1 | 0,pos=pos$0;continue}
              var _tT_=b}
            return _tT_}}
        var _tW_=_tX_}
      return _tW_}
    function invariant$17(invariant_a,t)
     {var num_mutations=t[1],front=t[2],length=t[4],elts=t[5];
      if(0 > front)throw [0,Assert_failure$0,_eT_];
      if(front >= capacity$0(t))throw [0,Assert_failure$0,_eS_];
      var capacity=capacity$0(t);
      if(capacity !== caml_call1(length$9,elts))
       throw [0,Assert_failure$0,_eR_];
      if(1 > capacity)throw [0,Assert_failure$0,_eQ_];
      if(! is_pow2(capacity))throw [0,Assert_failure$0,_eP_];
      if(0 > length)throw [0,Assert_failure$0,_eO_];
      if(length > capacity)throw [0,Assert_failure$0,_eN_];
      var _tQ_=capacity - 1 | 0,_tP_=0;
      if(_tQ_ >= 0)
       {var i=_tP_;
        for(;;)
         {if(i < t[4])
           {caml_call1(invariant_a,unsafe_get$2(t,i));
            ensure_no_mutation(t,num_mutations)}
          else
           {var _tO_=elts_index(t,i);
            if(unsafe_is_some(t[5],_tO_))throw [0,Assert_failure$0,_eM_]}
          var _tR_=i + 1 | 0;
          if(_tQ_ !== i){var i=_tR_;continue}
          break}}
      return 0}
    function create$13(capacity,param)
     {if(capacity)
       var
        capacity$0=capacity[1],
        _tN_=
         0 <= capacity$0
          ?0 === capacity$0?1:ceil_pow2(capacity$0)
          :raise_s
            (caml_call2
              (message,
               cst_cannot_have_queue_with_neg,
               [0,[0,cst_capacity,caml_call1(sexp_of_t$33,capacity$0)],0])),
        capacity$1=_tN_;
      else
       var capacity$1=1;
      return [0,0,0,capacity$1 - 1 | 0,0,create$10(capacity$1)]}
    function blit_to_array(src,dst)
     {var _tK_=caml_call1(length$9,dst);
      if(src[4] > _tK_)throw [0,Assert_failure$0,_eU_];
      var
       _tL_=src[2],
       _tM_=capacity$0(src) - _tL_ | 0,
       front_len=caml_call2(min$25,src[4],_tM_),
       rest_len=src[4] - front_len | 0;
      caml_call5(blit$5,src[5],src[2],dst,0,front_len);
      return caml_call5(blit$5,src[5],0,dst,front_len,rest_len)}
    function set_capacity$0(t,desired_capacity)
     {inc_num_mutations(t);
      var
       new_capacity=
        ceil_pow2(caml_call2(max$2,1,caml_call2(max$2,desired_capacity,t[4]))),
       _tI_=new_capacity !== capacity$0(t)?1:0;
      if(_tI_)
       {var dst=create$10(new_capacity);
        blit_to_array(t,dst);
        t[2] = 0;
        t[3] = new_capacity - 1 | 0;
        t[5] = dst;
        var _tJ_=0}
      else
       var _tJ_=_tI_;
      return _tJ_}
    function enqueue(t,a)
     {inc_num_mutations(t);
      var _tH_=capacity$0(t);
      if(t[4] === _tH_)set_capacity$0(t,2 * t[4] | 0);
      unsafe_set$2(t,t[4],a);
      t[4] = t[4] + 1 | 0;
      return 0}
    function dequeue_nonempty(t)
     {inc_num_mutations(t);
      var elts=t[5],front=t[2],res=get_some_exn(elts,front);
      set_none(elts,front);
      t[2] = elts_index(t,1);
      t[4] = t[4] - 1 | 0;
      return res}
    function dequeue_exn(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return dequeue_nonempty(t)}
    function dequeue(t){return is_empty$9(t)?0:[0,dequeue_nonempty(t)]}
    function front_nonempty(t){return unsafe_get_some_exn(t[5],t[2])}
    function last_nonempty(t){return unsafe_get$2(t,t[4] - 1 | 0)}
    function peek(t){return is_empty$9(t)?0:[0,front_nonempty(t)]}
    function peek_exn(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return front_nonempty(t)}
    function last$1(t){return is_empty$9(t)?0:[0,last_nonempty(t)]}
    function last_exn$0(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return last_nonempty(t)}
    function clear$1(t)
     {inc_num_mutations(t);
      var _tC_=0 < t[4]?1:0;
      if(_tC_)
       {var _tE_=t[4] - 1 | 0,_tD_=0;
        if(_tE_ >= 0)
         {var i=_tD_;
          for(;;)
           {var _tB_=elts_index(t,i);
            unsafe_set_none(t[5],_tB_);
            var _tG_=i + 1 | 0;
            if(_tE_ !== i){var i=_tG_;continue}
            break}}
        t[4] = 0;
        t[2] = 0;
        var _tF_=0}
      else
       var _tF_=_tC_;
      return _tF_}
    function blit_transfer(src,dst,len,param)
     {inc_num_mutations(src);
      inc_num_mutations(dst);
      if(len)
       {var len$0=len[1];
        if(len$0 < 0)
         raise_s
          (caml_call2
            (message,
             cst_Queue_blit_transfer_negati,
             [0,[0,cst_length$0,caml_call1(sexp_of_t$33,len$0)],0]));
        var len$1=caml_call2(min$2,len$0,src[4])}
      else
       var len$1=src[4];
      var _tu_=0 < len$1?1:0;
      if(_tu_)
       {var _tv_=dst[4] + len$1 | 0;
        set_capacity$0(dst,caml_call2(max$2,capacity$0(dst),_tv_));
        var dst_start=dst[2] + dst[4] | 0,_tx_=len$1 - 1 | 0,_tw_=0;
        if(_tx_ >= 0)
         {var i=_tw_;
          for(;;)
           {var
             src_i=(src[2] + i | 0) & src[3],
             dst_i=(dst_start + i | 0) & dst[3],
             _tz_=unsafe_get_some_exn(src[5],src_i);
            unsafe_set_some(dst[5],dst_i,_tz_);
            unsafe_set_none(src[5],src_i);
            var _tA_=i + 1 | 0;
            if(_tx_ !== i){var i=_tA_;continue}
            break}}
        dst[4] = dst[4] + len$1 | 0;
        src[2] = (src[2] + len$1 | 0) & src[3];
        src[4] = src[4] - len$1 | 0;
        var _ty_=0}
      else
       var _ty_=_tu_;
      return _ty_}
    function enqueue_all(t,l)
     {var _ts_=caml_call1(length,l),_tt_=t[4] + _ts_ | 0;
      set_capacity$0(t,caml_call2(max$25,capacity$0(t),_tt_));
      return iter$0(l,function(x){return enqueue(t,x)})}
    function fold$11(t,init,f)
     {if(0 === t[4])return init;
      var num_mutations=t[1],r=[0,init],_tp_=t[4] - 1 | 0,_to_=0;
      if(_tp_ >= 0)
       {var i=_to_;
        for(;;)
         {var _tq_=unsafe_get$2(t,i);
          r[1] = caml_call2(f,r[1],_tq_);
          ensure_no_mutation(t,num_mutations);
          var _tr_=i + 1 | 0;
          if(_tp_ !== i){var i=_tr_;continue}
          break}}
      return r[1]}
    function foldi$8(t,init,f)
     {var i=[0,0];
      return fold$11
              (t,
               init,
               function(acc,a)
                {var acc$0=caml_call3(f,i[1],acc,a);
                 i[1] = i[1] + 1 | 0;
                 return acc$0})}
    function iter$15(t,f)
     {var num_mutations=t[1],_tm_=t[4] - 1 | 0,_tl_=0;
      if(_tm_ >= 0)
       {var i=_tl_;
        for(;;)
         {caml_call1(f,unsafe_get$2(t,i));
          ensure_no_mutation(t,num_mutations);
          var _tn_=i + 1 | 0;
          if(_tm_ !== i){var i=_tn_;continue}
          break}}
      return 0}
    function iteri$7(t,f)
     {var num_mutations=t[1],_tj_=t[4] - 1 | 0,_ti_=0;
      if(_tj_ >= 0)
       {var i=_ti_;
        for(;;)
         {caml_call2(f,i,unsafe_get$2(t,i));
          ensure_no_mutation(t,num_mutations);
          var _tk_=i + 1 | 0;
          if(_tj_ !== i){var i=_tk_;continue}
          break}}
      return 0}
    function to_list$11(t)
     {var result=[0,0],_tf_=t[4] - 1 | 0;
      if(_tf_ >= 0)
       {var i=_tf_;
        for(;;)
         {var _tg_=result[1];
          result[1] = [0,unsafe_get$2(t,i),_tg_];
          var _th_=i - 1 | 0;
          if(0 !== i){var i=_th_;continue}
          break}}
      return result[1]}
    var
     iter$16=[0,-198771759,iter$15],
     length$16=[0,-198771759,length$15],
     foldi$9=[0,-198771759,foldi$8],
     iteri$8=[0,-198771759,iteri$7],
     C$0=_a__([0,fold$11,iter$16,length$16,iteri$8,foldi$9]),
     count$9=C$0[10],
     exists$10=C$0[8],
     find$10=C$0[12],
     find_map$9=C$0[13],
     fold_result$8=C$0[6],
     fold_until$9=C$0[7],
     for_all$10=C$0[9],
     max_elt$10=C$0[17],
     mem$8=C$0[1],
     min_elt$10=C$0[16],
     sum$9=C$0[11],
     counti$5=C$0[22],
     existsi$5=C$0[20],
     find_mapi$5=C$0[24],
     findi$5=C$0[23],
     for_alli$5=C$0[21];
    function concat_map$2(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {function _te_(b){return enqueue(t_result,b)}
          return iter$0(caml_call1(f,a),_te_)});
      return t_result}
    function concat_mapi$2(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {function _td_(b){return enqueue(t_result,b)}
          return iter$0(caml_call2(f,i,a),_td_)});
      return t_result}
    function filter_map$7(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {var match=caml_call1(f,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue(t_result,b)});
      return t_result}
    function filter_mapi$2(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {var match=caml_call2(f,i,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue(t_result,b)});
      return t_result}
    function filter$7(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {var _tc_=caml_call1(f,a);return _tc_?enqueue(t_result,a):_tc_});
      return t_result}
    function filteri$3(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {var _tb_=caml_call2(f,i,a);return _tb_?enqueue(t_result,a):_tb_});
      return t_result}
    function filter_inplace(t,f)
     {var t2=filter$7(t,f);clear$1(t);return blit_transfer(t2,t,0,0)}
    function filteri_inplace(t,f)
     {var t2=filteri$3(t,f);clear$1(t);return blit_transfer(t2,t,0,0)}
    function copy$5(src)
     {var dst=create$13([0,src[4]],0);
      blit_to_array(src,dst[5]);
      dst[4] = src[4];
      return dst}
    function of_list$9(l)
     {var t=create$13([0,caml_call1(length,l)],0);
      iter$0(l,function(x){return enqueue(t,x)});
      return t}
    function init$7(len,f)
     {if(len < 0)
       raise_s
        (caml_call2
          (message,
           cst_Queue_init_negative_length,
           [0,[0,cst_length$1,caml_call1(sexp_of_t$33,len)],0]));
      var t=create$13([0,len],0);
      if(len > caml_call1(length$9,t[5]))throw [0,Assert_failure$0,_eV_];
      var _s__=len - 1 | 0,_s9_=0;
      if(_s__ >= 0)
       {var i=_s9_;
        for(;;)
         {var _s$_=caml_call1(f,i);
          unsafe_set_some(t[5],i,_s$_);
          var _ta_=i + 1 | 0;
          if(_s__ !== i){var i=_ta_;continue}
          break}}
      t[4] = len;
      return t}
    function of_array$6(a)
     {return init$7(a.length - 1,function(_s8_){return a[1 + _s8_]})}
    function to_array$10(t)
     {function _s7_(i){return unsafe_get$2(t,i)}
      return caml_call2(init,t[4],_s7_)}
    function map$32(ta,f)
     {var num_mutations=ta[1],tb=create$13([0,ta[4]],0);
      tb[4] = ta[4];
      var _s5_=ta[4] - 1 | 0,_s4_=0;
      if(_s5_ >= 0)
       {var i=_s4_;
        for(;;)
         {var b=caml_call1(f,unsafe_get$2(ta,i));
          ensure_no_mutation(ta,num_mutations);
          unsafe_set_some(tb[5],i,b);
          var _s6_=i + 1 | 0;
          if(_s5_ !== i){var i=_s6_;continue}
          break}}
      return tb}
    function mapi$6(t,f)
     {var i=[0,0];
      return map$32
              (t,
               function(a)
                {var result=caml_call2(f,i[1],a);
                 i[1] = i[1] + 1 | 0;
                 return result})}
    function singleton$7(x){var t=create$13(0,0);enqueue(t,x);return t}
    function sexp_of_t$51(sexp_of_a,t)
     {var _s3_=to_list$11(t);
      return caml_call1(caml_call1(sexp_of_t$10,sexp_of_a),_s3_)}
    function t_of_sexp$29(a_of_sexp,sexp)
     {return of_list$9(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function t_sexp_grammar$29(grammar)
     {var _s2_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_s2_)}
    var
     Base_Queue=
      [0,
       compare$52,
       t_of_sexp$29,
       sexp_of_t$51,
       t_sexp_grammar$29,
       mem$8,
       length$15,
       is_empty$9,
       iter$15,
       fold$11,
       fold_result$8,
       fold_until$9,
       exists$10,
       for_all$10,
       count$9,
       sum$9,
       find$10,
       find_map$9,
       to_list$11,
       to_array$10,
       min_elt$10,
       max_elt$10,
       foldi$8,
       iteri$7,
       existsi$5,
       for_alli$5,
       counti$5,
       findi$5,
       find_mapi$5,
       singleton$7,
       of_list$9,
       of_array$6,
       init$7,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear$1,
       copy$5,
       map$32,
       mapi$6,
       concat_map$2,
       concat_mapi$2,
       filter_map$7,
       filter_mapi$2,
       filter$7,
       filteri$3,
       filter_inplace,
       filteri_inplace,
       equal$40,
       invariant$17,
       create$13,
       last$1,
       last_exn$0,
       blit_transfer,
       get$5,
       set$4,
       capacity$0,
       set_capacity$0];
    caml_register_global(1112,Base_Queue,"Base__Queue");
    function to_string$14(param){throw [0,Match_failure$0,_eW_]}
    var all$18=0;
    function hash_fold_t$27(param,t){return to_string$14(t)}
    function compare$53(a,param){return to_string$14(a)}
    function t_of_sexp$30(sexp)
     {return caml_call2(Sexplib0_Sexp_conv_error[26],cst_Base_Nothing_t,sexp)}
    function of_string$13(param)
     {return caml_call1(failwith$0,cst_Base_Nothing_of_string_not)}
    var
     include$63=
      _a1_
       ([0,
         compare$53,
         hash_fold_t$27,
         to_string$14,
         t_of_sexp$30,
         to_string$14,
         of_string$13,
         to_string$14,
         module_name$10]),
     hash_fold_t$28=include$63[1],
     hash$18=include$63[2],
     t_of_sexp$31=include$63[3],
     sexp_of_t$52=include$63[4],
     of_string$14=include$63[5],
     to_string$15=include$63[6],
     symbol$165=include$63[7],
     symbol$166=include$63[8],
     symbol$167=include$63[9],
     symbol$168=include$63[10],
     symbol$169=include$63[11],
     symbol$170=include$63[12],
     equal$41=include$63[13],
     compare$54=include$63[14],
     min$30=include$63[15],
     max$30=include$63[16],
     ascending$24=include$63[17],
     descending$24=include$63[18],
     between$10=include$63[19],
     clamp_exn$10=include$63[20],
     clamp$10=include$63[21],
     comparator$14=include$63[22],
     pp$14=include$63[23],
     hashable$5=include$63[24],
     Base_Nothing=
      [0,
       all$18,
       t_sexp_grammar$30,
       to_string$14,
       hash_fold_t$28,
       hash$18,
       t_of_sexp$31,
       sexp_of_t$52,
       of_string$14,
       to_string$15,
       symbol$165,
       symbol$166,
       symbol$167,
       symbol$168,
       symbol$169,
       symbol$170,
       equal$41,
       compare$54,
       min$30,
       max$30,
       ascending$24,
       descending$24,
       between$10,
       clamp_exn$10,
       clamp$10,
       comparator$14,
       pp$14,
       hashable$5];
    caml_register_global(1114,Base_Nothing,"Base__Nothing");
    var compare$55=include$3[9];
    function func$9(x){return caml_call1(func,x)}
    var
     hashable$6=[0,func$9,compare$55,sexp_of_t$8],
     compare$56=include$3[9],
     to_string$16=Stdlib_Nativeint[15],
     of_string$15=caml_int_of_string,
     comparator$15=_P_([0,compare$56,sexp_of_t$8])[1],
     zero$0=Stdlib_Nativeint[1],
     _eX_=_aY_([0,compare$56,sexp_of_t$8,zero$0]),
     is_positive$0=_eX_[1],
     is_non_negative$0=_eX_[2],
     is_negative$0=_eX_[3],
     is_non_positive$0=_eX_[4],
     sign$0=_eX_[5],
     include$64=_cH_([0,to_string$16]),
     to_string_hum$2=include$64[1],
     sexp_of_t$53=include$64[2];
    function hash$19(x){return caml_call1(func,x)}
    var zero$1=Stdlib_Nativeint[1];
    function neg$1(_s1_){return - _s1_ | 0}
    var symbol$171=include$3[1];
    function to_string$17(i){return caml_call2(sprintf,_eY_,i)}
    function of_string$16(s)
     {function _sZ_(_s0_){return _s0_}
      return caml_call3(Stdlib_Scanf[4],s,_eZ_,_sZ_)}
    var
     include$65=
      _cG_
       ([0,
         compare$13,
         hash_fold_t$0,
         hash$19,
         to_string$17,
         of_string$16,
         zero$1,
         symbol$171,
         neg$1,
         module_name$11]),
     Hex$0=include$65[1],
     include$66=_w_([0,module_name$12,to_string$16]),
     _e0_=include$66[1];
    function invariant$18(param){return 0}
    var
     num_bits$1=num_bits$0(word_size),
     float_lower_bound$0=lower_bound_for_int(num_bits$1),
     float_upper_bound$0=upper_bound_for_int(num_bits$1);
    function lsr$0(_sY_,_sX_){return _sY_ >>> _sX_ | 0}
    function asr$0(_sW_,_sV_){return _sW_ >> _sV_}
    function lsl$0(_sU_,_sT_){return _sU_ << _sT_}
    var lnot$1=Stdlib_Nativeint[12];
    function lxor$0(_sS_,_sR_){return _sS_ ^ _sR_}
    function lor$0(_sQ_,_sP_){return _sQ_ | _sP_}
    function land$0(_sO_,_sN_){return _sO_ & _sN_}
    var
     min_value$3=Stdlib_Nativeint[11],
     max_value$3=Stdlib_Nativeint[10],
     abs$3=Stdlib_Nativeint[8],
     pred$2=Stdlib_Nativeint[7],
     succ$3=Stdlib_Nativeint[6],
     rem$0=caml_mod;
    function neg$2(_sM_){return - _sM_ | 0}
    var
     minus_one$0=Stdlib_Nativeint[3],
     one$0=Stdlib_Nativeint[2],
     zero$2=Stdlib_Nativeint[1];
    function to_float$1(_sL_){return _sL_}
    function of_float_unchecked$0(_sK_){return _sK_ | 0}
    function of_float$0(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$0)
        &&
        caml_call2(include$7[2],f,float_upper_bound$0))
       return f | 0;
      return caml_call2(invalid_argf(_e1_),f + 0.,0)}
    function non_positive_argument$0(param)
     {return caml_call1(invalid_argf(_e2_),0)}
    function ceil_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var
       x$0=caml_call1(Stdlib_Nativeint[7],x),
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0,
       x$6=x$5 | x$5 >>> 32 | 0;
      return caml_call1(Stdlib_Nativeint[6],x$6)}
    function floor_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0,
       x$5=x$4 | x$4 >>> 32 | 0;
      return x$5 - (x$5 >>> 1 | 0) | 0}
    function is_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var _sJ_=x & caml_call1(Stdlib_Nativeint[7],x);
      return caml_call2(include$3[4],_sJ_,0)}
    function floor_log2$0(i)
     {if(caml_lessequal(i,Stdlib_Nativeint[1]))
       raise_s
        (caml_call2
          (message,
           cst_Nativeint_floor_log2_got_i,
           [0,[0,cst$30,caml_call1(sexp_of_t$8,i)],0]));
      return (num_bits$1 - 1 | 0) - runtime.Base_int_math_nativeint_clz(i) | 0}
    function ceil_log2$0(i)
     {if(caml_lessequal(i,Stdlib_Nativeint[1]))
       raise_s
        (caml_call2
          (message,
           cst_Nativeint_ceil_log2_got_in,
           [0,[0,cst$31,caml_call1(sexp_of_t$8,i)],0]));
      return caml_call2(Stdlib_Nativeint[18],i,Stdlib_Nativeint[2])
              ?0
              :num_bits$1
               -
               runtime.Base_int_math_nativeint_clz
                (caml_call1(Stdlib_Nativeint[7],i))
               |
               0}
    function between$11(t,low,high)
     {var _sI_=caml_call2(include$3[2],low,t);
      return _sI_?caml_call2(include$3[2],t,high):_sI_}
    function clamp_unchecked$3(t,min,max)
     {return caml_call2(include$3[1],t,min)
              ?min
              :caml_call2(include$3[2],t,max)?t:max}
    function clamp_exn$11(t,min,max)
     {if(caml_call2(include$3[2],min,max))return clamp_unchecked$3(t,min,max);
      throw [0,Assert_failure$0,_e3_]}
    function clamp$11(t,min,max)
     {if(! caml_call2(include$3[5],min,max))
       return [0,clamp_unchecked$3(t,min,max)];
      var _sH_=[0,[0,cst_max$4,caml_call1(sexp_of_t$8,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$4,
                 [0,[0,cst_min$4,caml_call1(sexp_of_t$8,min)],_sH_]))}
    var symbol$172=caml_div,symbol$173=caml_mul;
    function symbol$174(_sG_,_sF_){return _sG_ - _sF_ | 0}
    function symbol$175(_sE_,_sD_){return _sE_ + _sD_ | 0}
    function incr$1(r){r[1] = r[1] + one$0 | 0;return 0}
    function decr$1(r){r[1] = r[1] - one$0 | 0;return 0}
    function of_nativeint(t){return t}
    function to_nativeint$0(t){return t}
    function pow$0(b,e)
     {var _sB_=nativeint_to_int_exn(e),_sC_=nativeint_to_int_exn(b);
      return caml_call2(Private$3[1],_sC_,_sB_)}
    function symbol$176(b,e){return pow$0(b,e)}
    var
     symbol$177=include$3[3],
     symbol$178=include$3[1],
     symbol$179=include$3[5],
     symbol$180=include$3[4],
     symbol$181=include$3[2],
     symbol$182=include$3[6],
     include$67=
      _c2_
       ([0,
         of_float$0,
         to_float$1,
         of_string$15,
         to_string$16,
         symbol$175,
         symbol$174,
         symbol$173,
         symbol$172,
         neg$2,
         symbol$182,
         symbol$181,
         symbol$180,
         symbol$179,
         symbol$178,
         symbol$177,
         abs$3,
         neg$2,
         zero$2,
         int_to_nativeint,
         rem$0]),
     symbol$183=include$67[1],
     symbol$184=include$67[2],
     symbol$185=include$67[3],
     round$0=include$67[4],
     round_towards_zero$0=include$67[5],
     round_down$0=include$67[6],
     round_up$0=include$67[7],
     round_nearest$0=include$67[8],
     symbol$186=include$3[1],
     symbol$187=include$3[2],
     symbol$188=include$3[3],
     symbol$189=include$3[4],
     symbol$190=include$3[5],
     symbol$191=include$3[6],
     ascending$25=include$3[7],
     descending$25=include$3[8],
     compare_nativeint$0=include$3[9],
     equal_nativeint$1=include$3[10],
     max$31=include$3[11],
     min$31=include$3[12],
     _e4_=caml_int32_bswap,
     _e5_=
      [0,
       symbol$175,
       symbol$174,
       symbol$173,
       symbol$172,
       neg$2,
       symbol$176,
       symbol$182,
       symbol$181,
       symbol$180,
       symbol$179,
       symbol$178,
       symbol$177,
       abs$3,
       neg$2,
       zero$2,
       symbol$183,
       symbol$184,
       symbol$185,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       lsl$0,
       asr$0,
       lsr$0];
    function _e6_(_sA_){return runtime.Base_int_math_nativeint_ctz(_sA_)}
    var
     Base_Nativeint=
      [0,
       t_sexp_grammar$7,
       of_float$0,
       to_float$1,
       int_to_nativeint,
       nativeint_to_int_exn,
       hash_fold_t$0,
       func$9,
       t_of_sexp$8,
       sexp_of_t$53,
       of_string$15,
       to_string$16,
       symbol$191,
       symbol$187,
       symbol$189,
       symbol$190,
       symbol$186,
       symbol$188,
       equal_nativeint$1,
       compare_nativeint$0,
       min$31,
       max$31,
       ascending$25,
       descending$25,
       between$11,
       clamp_exn$11,
       clamp$11,
       comparator$15,
       _e0_,
       hashable$6,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$18,
       Hex$0,
       to_string_hum$2,
       zero$2,
       one$0,
       minus_one$0,
       symbol$175,
       symbol$174,
       symbol$173,
       symbol$176,
       neg$2,
       neg$2,
       symbol$184,
       symbol$183,
       symbol$172,
       rem$0,
       symbol$185,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       lsl$0,
       asr$0,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$3,
       succ$3,
       pred$2,
       pow$0,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       popcount,
       lsl$0,
       asr$0,
       decr$1,
       incr$1,
       int32_to_nativeint,
       nativeint_to_int32_exn,
       to_nativeint_exn,
       nativeint_to_int64,
       of_nativeint,
       to_nativeint$0,
       of_float_unchecked$0,
       num_bits$1,
       max_value$3,
       min_value$3,
       lsr$0,
       lsr$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       floor_log2$0,
       is_pow2$0,
       function(_sz_){return runtime.Base_int_math_nativeint_clz(_sz_)},
       _e6_,
       _e5_,
       int_to_nativeint,
       nativeint_to_int,
       int32_to_nativeint,
       nativeint_to_int32,
       of_nativeint,
       to_nativeint$0,
       to_nativeint,
       nativeint_to_int_trunc,
       nativeint_to_int32_trunc,
       int64_to_nativeint_trunc,
       _e4_];
    caml_register_global(1115,Base_Nativeint,"Base__Nativeint");
    var
     compare$57=include$60[1],
     all$19=include$60[2],
     equal$42=include$60[3],
     sexp_of_t$54=include$60[4];
    function of_continue_or_stop(_sy_){return _sy_}
    function to_continue_or_stop(_sx_){return _sx_}
    var
     Finished_or_unfinished=
      [0,
       compare$57,
       all$19,
       equal$42,
       sexp_of_t$54,
       of_continue_or_stop,
       to_continue_or_stop],
     compare$58=include$59[1],
     equal$43=include$59[2],
     sexp_of_t$55=include$59[3];
    function left(param)
     {var _sw_=param[1];
      if(737457313 === _sw_)
       var left=param[2][1];
      else
       {if(847852583 > _sw_)return 0;var left=param[2]}
      return [0,left]}
    function right(param)
     {var _sv_=param[1];
      if(737457313 === _sv_)
       var right=param[2][2];
      else
       {if(847852583 <= _sv_)return 0;var right=param[2]}
      return [0,right]}
    function left_value(t,default$0)
     {var _su_=t[1];
      if(737457313 === _su_)
       var left=t[2][1];
      else
       {if(847852583 > _su_)return default$0;var left=t[2]}
      return left}
    function right_value(t,default$0)
     {var _st_=t[1];
      if(737457313 === _st_)
       var right=t[2][2];
      else
       {if(847852583 <= _st_)return default$0;var right=t[2]}
      return right}
    function values(t,left_default,right_default)
     {var _ss_=t[1];
      if(737457313 === _ss_)
       {var match=t[2],right=match[2],left=match[1];return [0,left,right]}
      if(847852583 <= _ss_){var left$0=t[2];return [0,left$0,right_default]}
      var right$0=t[2];
      return [0,left_default,right$0]}
    var
     Merge_element=
      [0,
       compare$58,
       equal$43,
       sexp_of_t$55,
       left,
       right,
       left_value,
       right_value,
       values],
     Duplicate=[248,cst_Base_Map_Duplicate,caml_fresh_oo_id(0)];
    function _e7_(param)
     {if(param === Duplicate)return _e8_;throw [0,Assert_failure$0,_e9_]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Duplicate,_e7_);
    function height$0(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var h=param[5];
      return h}
    function in_range$0(lower,upper,compare_key,k)
     {if(lower)
       var lower$0=lower[1],_sq_=caml_call2(compare_key,lower$0,k) < 0?1:0;
      else
       var _sq_=1;
      if(_sq_)
       {if(upper)
         {var upper$0=upper[1];
          return caml_call2(compare_key,k,upper$0) < 0?1:0}
        var _sr_=1}
      else
       var _sr_=_sq_;
      return _sr_}
    function loop$0(lower,upper,compare_key,t)
     {var lower$0=lower,t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0])
         {var k=t$0[1];return in_range$0(lower$0,upper,compare_key,k)}
        var
         h=t$0[5],
         r=t$0[4],
         k$0=t$0[2],
         l=t$0[1],
         hl=height$0(l),
         hr=height$0(r),
         _sl_=caml_call1(abs$0,hl - hr | 0) <= 2?1:0;
        if(_sl_)
         {var _sm_=h === (caml_call2(max$2,hl,hr) + 1 | 0)?1:0;
          if(_sm_)
           {var _sn_=in_range$0(lower$0,upper,compare_key,k$0);
            if(_sn_)
             {var _so_=loop$0(lower$0,[0,k$0],compare_key,l);
              if(_so_){var lower$1=[0,k$0],lower$0=lower$1,t$0=r;continue}
              var _sp_=_so_}
            else
             var _sp_=_sn_}
          else
           var _sp_=_sm_}
        else
         var _sp_=_sl_;
        return _sp_}}
    function invariants$2(t,compare_key){return loop$0(0,0,compare_key,t)}
    function create$14(l,x,d,r)
     {var hl=height$0(l),hr=height$0(r);
      if(0 === hl && 0 === hr)return [0,x,d];
      var _sk_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      return [1,l,x,d,r,_sk_]}
    function of_increasing_iterator_uncheck$4(len,f)
     {function loop(n,f,i)
       {if(3 >= n >>> 0)
         switch(n)
          {case 0:return 0;
           case 1:
            var match$0=caml_call1(f,i),v$0=match$0[2],k$0=match$0[1];
            return [0,k$0,v$0];
           case 2:
            var
             match$1=caml_call1(f,i),
             vl=match$1[2],
             kl=match$1[1],
             match$2=caml_call1(f,i + 1 | 0),
             v$1=match$2[2],
             k$1=match$2[1];
            return [1,[0,kl,vl],k$1,v$1,0,2];
           default:
            var
             match$3=caml_call1(f,i),
             vl$0=match$3[2],
             kl$0=match$3[1],
             match$4=caml_call1(f,i + 1 | 0),
             v$2=match$4[2],
             k$2=match$4[1],
             match$5=caml_call1(f,i + 2 | 0),
             vr=match$5[2],
             kr=match$5[1];
            return [1,[0,kl$0,vl$0],k$2,v$2,[0,kr,vr],2]}
        var
         left_length=n >>> 1 | 0,
         right_length=(n - left_length | 0) - 1 | 0,
         left=loop(left_length,f,i),
         match=caml_call1(f,i + left_length | 0),
         v=match[2],
         k=match[1],
         right=loop(right_length,f,(i + left_length | 0) + 1 | 0);
        return create$14(left,k,v,right)}
      return loop(len,f,0)}
    function of_sorted_array_unchecked$4(array,compare_key)
     {var array_length=array.length - 1,switch$0=0;
      if(2 <= array_length)
       {var
         match=caml_check_bound(array,0)[1],
         k0=match[1],
         match$0=caml_check_bound(array,1)[2],
         k1=match$0[1];
        if(caml_call2(compare_key,k0,k1) >= 0)
         {var
           next=
            function(i)
             {var _sj_=(array_length - 1 | 0) - i | 0;
              return caml_check_bound(array,_sj_)[1 + _sj_]};
          switch$0 = 1}}
      if(! switch$0)
       var next=function(i){return caml_check_bound(array,i)[1 + i]};
      return [0,
              of_increasing_iterator_uncheck$4(array_length,next),
              array_length]}
    function of_sorted_array$4(array,compare_key)
     {var len=array.length - 1;
      if(1 !== len && len)
       return with_return
               (function(r)
                 {var
                   _sd_=caml_check_bound(array,1)[2][1],
                   i=
                    caml_call2(compare_key,caml_check_bound(array,0)[1][1],_sd_),
                   increasing=
                    0 === i
                     ?caml_call1
                       (r,error_string(cst_of_sorted_array_duplicated$1))
                     :i < 0?1:0,
                   _sf_=array.length - 1 - 2 | 0,
                   _se_=1;
                  if(_sf_ >= 1)
                   {var i$0=_se_;
                    for(;;)
                     {var
                       _sg_=i$0 + 1 | 0,
                       _sh_=caml_check_bound(array,_sg_)[1 + _sg_][1],
                       i$1=
                        caml_call2
                         (compare_key,caml_check_bound(array,i$0)[1 + i$0][1],_sh_);
                      if(0 === i$1)
                       caml_call1(r,error_string(cst_of_sorted_array_duplicated$2));
                      else
                       if((i$1 < 0?1:0) !== increasing)
                        caml_call1(r,error_string(cst_of_sorted_array_elements_a$0));
                      var _si_=i$0 + 1 | 0;
                      if(_sf_ !== i$0){var i$0=_si_;continue}
                      break}}
                  return [0,of_sorted_array_unchecked$4(array,compare_key)]});
      return [0,of_sorted_array_unchecked$4(array,compare_key)]}
    function bal$0(l,x,d,r)
     {var hl=height$0(l),hr=height$0(r);
      if((hr + 2 | 0) < hl)
       {if(typeof l === "number")return caml_call1(invalid_arg$0,cst_Map_bal);
        if(0 === l[0])throw [0,Assert_failure$0,_e__];
        var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_r9_=height$0(lr);
        if(_r9_ <= height$0(ll))
         return create$14(ll,lv,ld,create$14(lr,x,d,r));
        if(typeof lr === "number")
         return caml_call1(invalid_arg$0,cst_Map_bal$0);
        if(0 === lr[0])
         {var lrd=lr[2],lrv=lr[1],_r__=create$14(0,x,d,r);
          return create$14(create$14(ll,lv,ld,0),lrv,lrd,_r__)}
        var
         lrr=lr[4],
         lrd$0=lr[3],
         lrv$0=lr[2],
         lrl=lr[1],
         _r$_=create$14(lrr,x,d,r);
        return create$14(create$14(ll,lv,ld,lrl),lrv$0,lrd$0,_r$_)}
      if((hl + 2 | 0) >= hr)return create$14(l,x,d,r);
      if(typeof r === "number")return caml_call1(invalid_arg$0,cst_Map_bal$1);
      if(0 === r[0])throw [0,Assert_failure$0,_e$_];
      var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_sa_=height$0(rl);
      if(_sa_ <= height$0(rr))return create$14(create$14(l,x,d,rl),rv,rd,rr);
      if(typeof rl === "number")
       return caml_call1(invalid_arg$0,cst_Map_bal$2);
      if(0 === rl[0])
       {var rld=rl[2],rlv=rl[1],_sb_=create$14(0,rv,rd,rr);
        return create$14(create$14(l,x,d,0),rlv,rld,_sb_)}
      var
       rlr=rl[4],
       rld$0=rl[3],
       rlv$0=rl[2],
       rll=rl[1],
       _sc_=create$14(rlr,rv,rd,rr);
      return create$14(create$14(l,x,d,rll),rlv$0,rld$0,_sc_)}
    var empty_without_value_restrictio=0;
    function is_empty$10(param){return typeof param === "number"?1:0}
    function raise_key_already_present(key,sexp_of_key)
     {return raise_s
              (caml_call2
                (message,
                 cst_Map_add_exn_got_key_alread,
                 [0,[0,cst_key,caml_call1(sexp_of_key,key)],0]))}
    function find_and_add_or_set
     (t,length,x,data,compare_key,sexp_of_key,add_or_set)
     {if(typeof t === "number")return [0,[0,x,data],length + 1 | 0];
      if(0 === t[0])
       {var d=t[2],v=t[1],c=caml_call2(compare_key,x,v);
        if(0 === c)
         switch(add_or_set)
          {case 0:return raise_without_backtrace(Duplicate);
           case 1:return raise_key_already_present(x,sexp_of_key);
           default:return [0,[0,x,data],length]}
        return 0 <= c
                ?[0,[1,0,v,d,[0,x,data],2],length + 1 | 0]
                :[0,[1,[0,x,data],v,d,0,2],length + 1 | 0]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       c$0=caml_call2(compare_key,x,v$0);
      if(0 === c$0)
       switch(add_or_set)
        {case 0:return raise_without_backtrace(Duplicate);
         case 1:return raise_key_already_present(x,sexp_of_key);
         default:return [0,[1,l,x,data,r,h],length]}
      if(0 <= c$0)
       {var
         match=
          find_and_add_or_set
           (r,length,x,data,compare_key,sexp_of_key,add_or_set),
         length$0=match[2],
         r$0=match[1];
        return [0,bal$0(l,v$0,d$0,r$0),length$0]}
      var
       match$0=
        find_and_add_or_set
         (l,length,x,data,compare_key,sexp_of_key,add_or_set),
       length$1=match$0[2],
       l$0=match$0[1];
      return [0,bal$0(l$0,v$0,d$0,r),length$1]}
    function add_exn(t,length,key,data,compare_key,sexp_of_key)
     {return find_and_add_or_set(t,length,key,data,compare_key,sexp_of_key,1)}
    function add_exn_internal(t,length,key,data,compare_key,sexp_of_key)
     {return find_and_add_or_set(t,length,key,data,compare_key,sexp_of_key,0)}
    function set$5(t,length,key,data,compare_key)
     {var _r8_=2;
      return find_and_add_or_set
              (t,
               length,
               key,
               data,
               compare_key,
               function(param){return _fa_},
               _r8_)}
    function set$6(t,key,data,compare_key)
     {return set$5(t,0,key,data,compare_key)[1]}
    function singleton_to_tree_exn(param)
     {if(typeof param[1] !== "number")
       return caml_call1(failwith$0,cst_Map_singleton_to_tree_exn_);
      var data=param[3],key=param[2];
      return [0,key,data]}
    function collapse(l,r){return create$14(l[1],l[2],l[3],r)}
    function join$7(l,r)
     {var _r6_=r[3],_r7_=r[2];return [0,collapse(l,r[1]),_r7_,_r6_]}
    function go(t,x)
     {switch(t[0])
       {case 0:return [1,t,x];
        case 1:var y=t[2],t$0=t[1];return [2,t$0,y,x];
        default:
         var y$0=t[3],z=t[2],t$1=t[1];return [1,go(t$1,join$7(z,y$0)),x]}}
    function add_unchecked(t,key,data){return go(t,[0,0,key,data])}
    function go$0(t,r)
     {var t$0=t,r$0=r;
      for(;;)
       switch(t$0[0])
        {case 0:return r$0;
         case 1:
          var l=t$0[2],t$1=t$0[1],r$1=collapse(l,r$0),t$0=t$1,r$0=r$1;
          continue;
         default:
          var
           l$0=t$0[3],
           ll=t$0[2],
           t$2=t$0[1],
           r$2=collapse(join$7(ll,l$0),r$0),
           t$0=t$2,
           r$0=r$2;
          continue}}
    function to_tree_unchecked(param)
     {switch(param[0])
       {case 0:return 0;
        case 1:
         var r=param[2],t=param[1];return go$0(t,singleton_to_tree_exn(r));
        default:
         var r$0=param[3],l=param[2],t$0=param[1];
         return go$0([1,t$0,l],singleton_to_tree_exn(r$0))}}
    function max_key(param)
     {switch(param[0])
       {case 0:return 0;case 1:var r=param[2];break;default:var r=param[3]}
      return [0,r[2]]}
    function of_increasing_sequence(seq,compare_key)
     {return with_return
              (function(param)
                {var
                  match=
                   fold$1
                    (seq,
                     [0,empty$5,0],
                     function(param$0,_r5_)
                      {var
                        data=_r5_[2],
                        key=_r5_[1],
                        length=param$0[2],
                        builder=param$0[1],
                        match=max_key(builder);
                       if(match)
                        {var prev_key=match[1];
                         if(0 <= caml_call2(compare_key,prev_key,key))
                          return caml_call1
                                  (param,error_string(cst_of_increasing_sequence_non))}
                       return [0,add_unchecked(builder,key,data),length + 1 | 0]}),
                  length=match[2],
                  builder=match[1];
                 return [0,[0,to_tree_unchecked(builder),length]]})}
    function join$8(l,k,d,r,compare_key)
     {if(typeof l === "number")return set$6(r,k,d,compare_key);
      if(1 === l[0])
       {var _r0_=l[5],_r1_=l[4],_r2_=l[3],_r3_=l[2],_r4_=l[1];
        if(typeof r !== "number")
         {if(0 === r[0])
           {var rd=r[2],rk=r[1];
            return set$6(set$6(l,k,d,compare_key),rk,rd,compare_key)}
          var rh=r[5],rr=r[4],rd$0=r[3],rk$0=r[2],rl=r[1];
          return (rh + 3 | 0) < _r0_
                  ?bal$0(_r4_,_r3_,_r2_,join$8(_r1_,k,d,r,compare_key))
                  :(_r0_ + 3 | 0) < rh
                    ?bal$0(join$8(l,k,d,rl,compare_key),rk$0,rd$0,rr)
                    :bal$0(l,k,d,r)}}
      if(typeof r === "number")return set$6(l,k,d,compare_key);
      var ld=l[2],lk=l[1];
      return set$6(set$6(r,k,d,compare_key),lk,ld,compare_key)}
    function split$4(t,x,compare_key)
     {if(typeof t === "number")return _fb_;
      if(0 === t[0])
       {var d=t[2],k=t[1],cmp=caml_call2(compare_key,x,k);
        return 0 === cmp?[0,0,[0,[0,k,d]],0]:0 <= cmp?[0,t,0,0]:[0,0,0,t]}
      var r=t[4],d$0=t[3],k$0=t[2],l=t[1],cmp$0=caml_call2(compare_key,x,k$0);
      if(0 === cmp$0)return [0,l,[0,[0,k$0,d$0]],r];
      if(0 <= cmp$0)
       {var
         match=split$4(r,x,compare_key),
         rr=match[3],
         maybe=match[2],
         rl=match[1];
        return [0,join$8(l,k$0,d$0,rl,compare_key),maybe,rr]}
      var
       match$0=split$4(l,x,compare_key),
       lr=match$0[3],
       maybe$0=match$0[2],
       ll=match$0[1];
      return [0,ll,maybe$0,join$8(lr,k$0,d$0,r,compare_key)]}
    function split_and_reinsert_boundary(t,into,x,compare_key)
     {var
       match=split$4(t,x,compare_key),
       right=match[3],
       boundary_opt=match[2],
       left=match[1];
      if(! boundary_opt)return [0,left,right];
      var match$0=boundary_opt[1],data=match$0[2],key=match$0[1];
      function insert_into(tree){return set$5(tree,0,key,data,compare_key)[1]}
      return 847852583 <= into
              ?[0,insert_into(left),right]
              :[0,left,insert_into(right)]}
    function split_range(t,lower_bound,upper_bound,compare_key)
     {if(bounds_crossed(lower_bound,upper_bound,compare_key))
       return [0,
               empty_without_value_restrictio,
               empty_without_value_restrictio,
               empty_without_value_restrictio];
      if(typeof lower_bound === "number")
       var mid_and_right=t,left=empty_without_value_restrictio;
      else
       if(0 === lower_bound[0])
        var
         lb$1=lower_bound[1],
         _rY_=split_and_reinsert_boundary(t,-57574468,lb$1,compare_key),
         mid_and_right=_rY_[2],
         left=_rY_[1];
       else
        var
         lb$2=lower_bound[1],
         _rZ_=split_and_reinsert_boundary(t,847852583,lb$2,compare_key),
         mid_and_right$0=_rZ_[2],
         left$0=_rZ_[1],
         mid_and_right=mid_and_right$0,
         left=left$0;
      if(typeof upper_bound === "number")
       var right=empty_without_value_restrictio,mid=mid_and_right;
      else
       if(0 === upper_bound[0])
        var
         lb=upper_bound[1],
         _rW_=
          split_and_reinsert_boundary(mid_and_right,847852583,lb,compare_key),
         right=_rW_[2],
         mid=_rW_[1];
       else
        var
         lb$0=upper_bound[1],
         _rX_=
          split_and_reinsert_boundary
           (mid_and_right,-57574468,lb$0,compare_key),
         right$0=_rX_[2],
         mid$0=_rX_[1],
         right=right$0,
         mid=mid$0;
      return [0,left,mid,right]}
    function find$11(t,x,compare_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];
          return 0 === caml_call2(compare_key,x,v)?[0,d]:0}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c=caml_call2(compare_key,x,v$0);
        if(0 === c)return [0,d$0];
        var t$1=0 <= c?r:l,t$0=t$1}}
    function add_multi(t,length,key,data,compare_key)
     {var data$0=[0,data,value(find$11(t,key,compare_key),0)];
      return set$5(t,length,key,data$0,compare_key)}
    function find_multi(t,x,compare_key)
     {var match=find$11(t,x,compare_key);
      if(! match)return 0;
      var l=match[1];
      return l}
    function if_not_found(key,sexp_of_key)
     {throw [0,Not_found_s,[1,[0,_fc_,[0,caml_call1(sexp_of_key,key),0]]]]}
    function find_exn$6(t,x,compare_key,sexp_of_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return if_not_found(x,sexp_of_key);
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];
          return 0 === caml_call2(compare_key,x,v)
                  ?d
                  :if_not_found(x,sexp_of_key)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c=caml_call2(compare_key,x,v$0);
        if(0 === c)return d$0;
        var t$1=0 <= c?r:l,t$0=t$1}}
    function mem$9(t,x,compare_key){return is_some(find$11(t,x,compare_key))}
    function min_elt$11(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0]){var d=param$0[2],k=param$0[1];return [0,[0,k,d]]}
        var _rV_=param$0[1];
        if(typeof _rV_ === "number")
         {var d$0=param$0[3],k$0=param$0[2];return [0,[0,k$0,d$0]]}
        var param$0=_rV_}}
    var
     Map_min_elt_exn_of_empty_map=
      [248,cst_Base_Map_Tree0_Map_min_elt,caml_fresh_oo_id(0)];
    function _fd_(param)
     {if(param === Map_min_elt_exn_of_empty_map)return _fe_;
      throw [0,Assert_failure$0,_ff_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Map_min_elt_exn_of_empty_map,_fd_);
    var
     Map_max_elt_exn_of_empty_map=
      [248,cst_Base_Map_Tree0_Map_max_elt,caml_fresh_oo_id(0)];
    function _fg_(param)
     {if(param === Map_max_elt_exn_of_empty_map)return _fh_;
      throw [0,Assert_failure$0,_fi_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Map_max_elt_exn_of_empty_map,_fg_);
    function min_elt_exn$2(t)
     {var match=min_elt$11(t);
      if(! match)throw Map_min_elt_exn_of_empty_map;
      var v=match[1];
      return v}
    function max_elt$11(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0]){var d=param$0[2],k=param$0[1];return [0,[0,k,d]]}
        if(typeof param$0[4] === "number")
         {var d$0=param$0[3],k$0=param$0[2];return [0,[0,k$0,d$0]]}
        var param$1=param$0[4],param$0=param$1}}
    function max_elt_exn$2(t)
     {var match=max_elt$11(t);
      if(! match)throw Map_max_elt_exn_of_empty_map;
      var v=match[1];
      return v}
    function remove_min_elt$0(t)
     {if(typeof t === "number")
       return caml_call1(invalid_arg$0,cst_Map_remove_min_elt);
      if(0 === t[0])return 0;
      var _rU_=t[1];
      if(typeof _rU_ === "number"){var r=t[4];return r}
      var r$0=t[4],d=t[3],x=t[2];
      return bal$0(remove_min_elt$0(_rU_),x,d,r$0)}
    function append$2(lower_part,upper_part,compare_key)
     {var match=max_elt$11(lower_part),match$0=min_elt$11(upper_part);
      if(! match)return [0,17724,upper_part];
      if(! match$0)return [0,17724,lower_part];
      var
       _rT_=match$0[1],
       v=_rT_[2],
       min_upper=_rT_[1],
       match$1=match[1],
       max_lower=match$1[1];
      if(0 <= caml_call2(compare_key,max_lower,min_upper))return 838882908;
      var upper_part_without_min=remove_min_elt$0(upper_part);
      return [0,
              17724,
              join$8
               (lower_part,min_upper,v,upper_part_without_min,compare_key)]}
    function go$1(t,min,max,init,f,compare_key)
     {var t$0=t,init$0=init;
      for(;;)
       {if(typeof t$0 === "number")return init$0;
        if(0 === t$0[0])
         {var d=t$0[2],k=t$0[1];
          if
           (0
            <=
            caml_call2(compare_key,k,min)
            &&
            0
            >=
            caml_call2(compare_key,k,max))
           return caml_call3(f,k,d,init$0);
          return init$0}
        var
         r=t$0[4],
         d$0=t$0[3],
         k$0=t$0[2],
         l=t$0[1],
         c_min=caml_call2(compare_key,k$0,min);
        if(0 > c_min){var t$0=r;continue}
        if(0 === c_min)
         {var init$1=caml_call3(f,k$0,d$0,init$0),t$0=r,init$0=init$1;
          continue}
        var
         z=go$1(l,min,max,init$0,f,compare_key),
         c_max=caml_call2(compare_key,k$0,max);
        if(0 < c_max)return z;
        var init$2=caml_call3(f,k$0,d$0,z);
        if(0 === c_max)return init$2;
        var t$0=r,init$0=init$2}}
    function fold_range_inclusive(t,min,max,init,f,compare_key)
     {return 0 < caml_call2(compare_key,min,max)
              ?init
              :go$1(t,min,max,init,f,compare_key)}
    function range_to_alist(t,min,max,compare_key)
     {return rev
              (fold_range_inclusive
                (t,
                 min,
                 max,
                 0,
                 function(key,data,l){return [0,[0,key,data],l]},
                 compare_key))}
    function concat_unchecked(t1,t2)
     {if(typeof t1 === "number")return t2;
      if(typeof t2 === "number")return t1;
      var match=min_elt_exn$2(t2),d=match[2],x=match[1];
      return bal$0(t1,x,d,remove_min_elt$0(t2))}
    var Remove_no_op=[248,cst_Base_Map_Tree0_Remove_no_o,caml_fresh_oo_id(0)];
    function remove$3(t,x,length,compare_key)
     {function remove_loop(t,x,length,compare_key)
       {if(typeof t === "number")return raise_without_backtrace(Remove_no_op);
        if(0 === t[0])
         {var v=t[1];
          return 0 === caml_call2(compare_key,x,v)
                  ?[0,0,length - 1 | 0]
                  :raise_without_backtrace(Remove_no_op)}
        var r=t[4],d=t[3],v$0=t[2],l=t[1],c=caml_call2(compare_key,x,v$0);
        if(0 === c)return [0,concat_unchecked(l,r),length - 1 | 0];
        if(0 <= c)
         {var
           match=remove_loop(r,x,length,compare_key),
           length$0=match[2],
           r$0=match[1];
          return [0,bal$0(l,v$0,d,r$0),length$0]}
        var
         match$0=remove_loop(l,x,length,compare_key),
         length$1=match$0[2],
         l$0=match$0[1];
        return [0,bal$0(l$0,v$0,d,r),length$1]}
      try
       {var _rR_=remove_loop(t,x,length,compare_key);return _rR_}
      catch(_rS_)
       {_rS_ = caml_wrap_exception(_rS_);
        if(_rS_ === Remove_no_op)return [0,t,length];
        throw _rS_}}
    var Change_no_op=[248,cst_Base_Map_Tree0_Change_no_o,caml_fresh_oo_id(0)];
    function change(t,key,f,length,compare_key)
     {function change_core(t,key,f)
       {if(typeof t === "number")
         {var match=caml_call1(f,0);
          if(! match)throw Change_no_op;
          var data=match[1];
          return [0,[0,key,data],length + 1 | 0]}
        if(0 === t[0])
         {var d=t[2],v=t[1],c=caml_call2(compare_key,key,v);
          if(0 === c)
           {var match$0=caml_call1(f,[0,d]);
            if(! match$0)return [0,0,length - 1 | 0];
            var d$0=match$0[1];
            return [0,[0,v,d$0],length]}
          if(0 <= c)
           {var match$1=change_core(0,key,f),length$0=match$1[2],r=match$1[1];
            return [0,bal$0(0,v,d,r),length$0]}
          var match$2=change_core(0,key,f),length$1=match$2[2],l=match$2[1];
          return [0,bal$0(l,v,d,0),length$1]}
        var
         h=t[5],
         r$0=t[4],
         d$1=t[3],
         v$0=t[2],
         l$0=t[1],
         c$0=caml_call2(compare_key,key,v$0);
        if(0 === c$0)
         {var match$3=caml_call1(f,[0,d$1]);
          if(! match$3)return [0,concat_unchecked(l$0,r$0),length - 1 | 0];
          var data$0=match$3[1];
          return [0,[1,l$0,key,data$0,r$0,h],length]}
        if(0 <= c$0)
         {var
           match$4=change_core(r$0,key,f),
           length$2=match$4[2],
           r$1=match$4[1];
          return [0,bal$0(l$0,v$0,d$1,r$1),length$2]}
        var match$5=change_core(l$0,key,f),length$3=match$5[2],l$1=match$5[1];
        return [0,bal$0(l$1,v$0,d$1,r$0),length$3]}
      try
       {var _rP_=change_core(t,key,f);return _rP_}
      catch(_rQ_)
       {_rQ_ = caml_wrap_exception(_rQ_);
        if(_rQ_ === Change_no_op)return [0,t,length];
        throw _rQ_}}
    function update(t,key,f,length,compare_key)
     {function update_core(t,key,f)
       {if(typeof t === "number")
         {var data=caml_call1(f,0);return [0,[0,key,data],length + 1 | 0]}
        if(0 === t[0])
         {var d=t[2],v=t[1],c=caml_call2(compare_key,key,v);
          if(0 === c){var d$0=caml_call1(f,[0,d]);return [0,[0,v,d$0],length]}
          if(0 <= c)
           {var match=update_core(0,key,f),length$0=match[2],r=match[1];
            return [0,bal$0(0,v,d,r),length$0]}
          var match$0=update_core(0,key,f),length$1=match$0[2],l=match$0[1];
          return [0,bal$0(l,v,d,0),length$1]}
        var
         h=t[5],
         r$0=t[4],
         d$1=t[3],
         v$0=t[2],
         l$0=t[1],
         c$0=caml_call2(compare_key,key,v$0);
        if(0 === c$0)
         {var data$0=caml_call1(f,[0,d$1]);
          return [0,[1,l$0,key,data$0,r$0,h],length]}
        if(0 <= c$0)
         {var
           match$1=update_core(r$0,key,f),
           length$2=match$1[2],
           r$1=match$1[1];
          return [0,bal$0(l$0,v$0,d$1,r$1),length$2]}
        var match$2=update_core(l$0,key,f),length$3=match$2[2],l$1=match$2[1];
        return [0,bal$0(l$1,v$0,d$1,r$0),length$3]}
      return update_core(t,key,f)}
    function remove_multi(t,key,length,compare_key)
     {return change
              (t,
               key,
               function(param)
                {if(param)
                  {var _rN_=param[1];
                   if(_rN_){var _rO_=_rN_[2];if(_rO_)return [0,_rO_]}}
                 return 0},
               length,
               compare_key)}
    function iter_keys(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)}
        var r=t$0[4],v$0=t$0[2],l=t$0[1];
        iter_keys(l,f);
        caml_call1(f,v$0);
        var t$0=r}}
    function iter$17(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2];return caml_call1(f,d)}
        var r=t$0[4],d$0=t$0[3],l=t$0[1];
        iter$17(l,f);
        caml_call1(f,d$0);
        var t$0=r}}
    function iteri$9(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return caml_call2(f,v,d)}
        var r=t$0[4],d$0=t$0[3],v$0=t$0[2],l=t$0[1];
        iteri$9(l,f);
        caml_call2(f,v$0,d$0);
        var t$0=r}}
    function iteri_until_loop(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return caml_call2(f,v,d)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         match=iteri_until_loop(l,f);
        if(match)return 1;
        var match$0=caml_call2(f,v$0,d$0);
        if(match$0)return 1;
        var t$0=r}}
    function iteri_until(t,f)
     {var _rM_=iteri_until_loop(t,f);
      return caml_call1(Finished_or_unfinished[5],_rM_)}
    function map$33(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var d=t[2],v=t[1];return [0,v,caml_call1(f,d)]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       l$0=map$33(l,f),
       d$1=caml_call1(f,d$0),
       r$0=map$33(r,f);
      return [1,l$0,v$0,d$1,r$0,h]}
    function mapi$7(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var d=t[2],v=t[1];return [0,v,caml_call2(f,v,d)]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       l$0=mapi$7(l,f),
       d$1=caml_call2(f,v$0,d$0),
       r$0=mapi$7(r,f);
      return [1,l$0,v$0,d$1,r$0,h]}
    function fold$12(t,accu,f)
     {var t$0=t,accu$0=accu;
      for(;;)
       {if(typeof t$0 === "number")return accu$0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,accu$0)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         accu$1=caml_call3(f,v$0,d$0,fold$12(l,accu$0,f)),
         t$0=r,
         accu$0=accu$1}}
    function fold_until$10(t,init,f,finish)
     {function fold_until_loop(t,acc,f)
       {var t$0=t,acc$0=acc;
        for(;;)
         {if(typeof t$0 === "number")return [0,acc$0];
          if(0 === t$0[0])
           {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,acc$0)}
          var
           r=t$0[4],
           d$0=t$0[3],
           v$0=t$0[2],
           l=t$0[1],
           match=fold_until_loop(l,acc$0,f);
          if(0 !== match[0]){var final$1=match[1];return [1,final$1]}
          var acc$1=match[1],match$0=caml_call3(f,v$0,d$0,acc$1);
          if(0 === match$0[0])
           {var acc$2=match$0[1],t$0=r,acc$0=acc$2;continue}
          var final$0=match$0[1];
          return [1,final$0]}}
      var match=fold_until_loop(t,init,f);
      if(0 === match[0]){var acc=match[1];return caml_call1(finish,acc)}
      var stop=match[1];
      return stop}
    function fold_right$4(t,accu,f)
     {var t$0=t,accu$0=accu;
      for(;;)
       {if(typeof t$0 === "number")return accu$0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,accu$0)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         accu$1=caml_call3(f,v$0,d$0,fold_right$4(r,accu$0,f)),
         t$0=l,
         accu$0=accu$1}}
    function filter_keys(t,f,compare_key)
     {return fold$12
              (t,
               _fj_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call1(f,key)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filter$8(t,f,compare_key)
     {return fold$12
              (t,
               _fk_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call1(f,data)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filteri$4(t,f,compare_key)
     {return fold$12
              (t,
               _fl_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call2(f,key,data)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filter_map$8(t,f,compare_key)
     {return fold$12
              (t,
               _fm_,
               function(key,data,param)
                {var length=param[2],accu=param[1],match=caml_call1(f,data);
                 if(! match)return [0,accu,length];
                 var b=match[1];
                 return set$5(accu,length,key,b,compare_key)})}
    function filter_mapi$3(t,f,compare_key)
     {return fold$12
              (t,
               _fn_,
               function(key,data,param)
                {var
                  length=param[2],
                  accu=param[1],
                  match=caml_call2(f,key,data);
                 if(! match)return [0,accu,length];
                 var b=match[1];
                 return set$5(accu,length,key,b,compare_key)})}
    function partition_mapi(t,f,compare_key)
     {return fold$12
              (t,
               _fo_,
               function(key,data,param)
                {var
                  pair2=param[2],
                  pair1=param[1],
                  match=caml_call2(f,key,data);
                 if(0 === match[0])
                  {var x=match[1],length=pair1[2],t=pair1[1];
                   return [0,set$5(t,length,key,x,compare_key),pair2]}
                 var y=match[1],length$0=pair2[2],t$0=pair2[1];
                 return [0,pair1,set$5(t$0,length$0,key,y,compare_key)]})}
    function partition_map$0(t,f,compare_key)
     {return partition_mapi
              (t,function(param,data){return caml_call1(f,data)},compare_key)}
    function partitioni_tf$0(t,f,compare_key)
     {return partition_mapi
              (t,
               function(key,data)
                {return caml_call2(f,key,data)?[0,data]:[1,data]},
               compare_key)}
    function partition_tf$4(t,f,compare_key)
     {return partition_mapi
              (t,
               function(param,data)
                {return caml_call1(f,data)?[0,data]:[1,data]},
               compare_key)}
    function cons$1(t,e)
     {var t$0=t,e$0=e;
      for(;;)
       {if(typeof t$0 === "number")return e$0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return [0,v,d,0,e$0]}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         t$1=t$0[1],
         e$1=[0,v$0,d$0,r,e$0],
         t$0=t$1,
         e$0=e$1}}
    function cons_right$0(t,e)
     {var t$0=t,e$0=e;
      for(;;)
       {if(typeof t$0 === "number")return e$0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return [0,v,d,0,e$0]}
        var
         t$1=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         e$1=[0,v$0,d$0,l,e$0],
         t$0=t$1,
         e$0=e$1}}
    function of_tree$2(tree){return cons$1(tree,0)}
    function fold$13(init,f,param)
     {var init$0=init,param$0=param;
      for(;;)
       {if(! param$0)return init$0;
        var
         enum$0=param$0[4],
         tree=param$0[3],
         data=param$0[2],
         key=param$0[1],
         init$1=caml_call3(f,key,data,init$0),
         param$1=cons$1(tree,enum$0),
         init$0=init$1,
         param$0=param$1}}
    function fold2$0(compare_key,t1,t2,curr,f)
     {var t1$0=t1,t2$0=t2,curr$0=curr;
      for(;;)
       {if(! t1$0)
         return t2$0
                 ?fold$13
                   (curr$0,
                    function(key,data,acc)
                     {return caml_call3(f,key,[0,-57574468,data],acc)},
                    t2$0)
                 :curr$0;
        if(! t2$0)
         return fold$13
                 (curr$0,
                  function(key,data,acc)
                   {return caml_call3(f,key,[0,847852583,data],acc)},
                  t1$0);
        var
         enum2=t2$0[4],
         tree2=t2$0[3],
         v2=t2$0[2],
         k2=t2$0[1],
         enum1=t1$0[4],
         tree1=t1$0[3],
         v1=t1$0[2],
         k1=t1$0[1],
         compare_result=caml_call2(compare_key,k1,k2);
        if(0 === compare_result)
         {var
           curr$1=caml_call3(f,k1,[0,737457313,[0,v1,v2]],curr$0),
           t2$1=cons$1(tree2,enum2),
           t1$1=cons$1(tree1,enum1),
           t1$0=t1$1,
           t2$0=t2$1,
           curr$0=curr$1;
          continue}
        if(0 <= compare_result)
         {var
           curr$2=caml_call3(f,k2,[0,-57574468,v2],curr$0),
           t2$2=cons$1(tree2,enum2),
           t2$0=t2$2,
           curr$0=curr$2;
          continue}
        var
         curr$3=caml_call3(f,k1,[0,847852583,v1],curr$0),
         t1$2=cons$1(tree1,enum1),
         t1$0=t1$2,
         curr$0=curr$3}}
    function symmetric_diff$2(t1,t2,compare_key,data_equal)
     {function step(state)
       {var _rE_=state[1];
        if(! _rE_)
         {var _rL_=state[2];
          if(! _rL_)return 0;
          var enum$0=_rL_[4],tree=_rL_[3],data=_rL_[2],key=_rL_[1];
          return [1,[0,key,[0,-57574468,data]],[0,0,cons$1(tree,enum$0)]]}
        var _rF_=state[2],_rG_=_rE_[4],_rH_=_rE_[3],_rI_=_rE_[2],_rJ_=_rE_[1];
        if(! _rF_)
         return [1,[0,_rJ_,[0,847852583,_rI_]],[0,cons$1(_rH_,_rG_),0]];
        var
         enum2=_rF_[4],
         tree2=_rF_[3],
         v2=_rF_[2],
         k2=_rF_[1],
         compare_result=caml_call2(compare_key,_rJ_,k2);
        if(0 !== compare_result)
         return 0 <= compare_result
                 ?[1,[0,k2,[0,-57574468,v2]],[0,_rE_,cons$1(tree2,enum2)]]
                 :[1,[0,_rJ_,[0,847852583,_rI_]],[0,cons$1(_rH_,_rG_),_rF_]];
        if(_rH_ === tree2)
         var next_state=[0,_rG_,enum2];
        else
         var _rK_=cons$1(tree2,enum2),next_state=[0,cons$1(_rH_,_rG_),_rK_];
        return caml_call2(data_equal,_rI_,v2)
                ?[0,next_state]
                :[1,[0,_rJ_,[0,1013247643,[0,_rI_,v2]]],next_state]}
      var _rD_=of_tree$2(t2);
      return [0,[0,of_tree$2(t1),_rD_],step]}
    function to_sequence$3
     (comparator,opt,keys_greater_or_equal_to,keys_less_or_equal_to,t$4)
     {if(opt)var sth=opt[1],order=sth;else var order=-542431297;
      function inclusive_bound(side,t,bound)
       {var
         compare_key=comparator[1],
         match=split$4(t,bound,compare_key),
         r=match[3],
         maybe=match[2],
         l=match[1],
         t$0=caml_call1(side,[0,l,r]);
        if(! maybe)return t$0;
        var match$0=maybe[1],data=match$0[2],key=match$0[1];
        return set$6(t$0,key,data,compare_key)}
      if(511974747 <= order)
       {var
         t$5=
          fold$0
           (keys_greater_or_equal_to,
            t$4,
            function(_rB_,_rC_){return inclusive_bound(get_data,_rB_,_rC_)}),
         next$0=
          function(enum$0)
           {if(! enum$0)return 0;
            var e=enum$0[4],t=enum$0[3],v=enum$0[2],k=enum$0[1];
            return [1,[0,k,v],cons_right$0(t,e)]};
        if(keys_less_or_equal_to)
         {var key$0=keys_less_or_equal_to[1],t$1=t$5,e$1=0,_ry_=comparator[1];
          for(;;)
           {if(typeof t$1 !== "number")
             {if(0 === t$1[0])
               {var d$1=t$1[2],v$2=t$1[1],t$2=[1,0,v$2,d$1,0,1],t$1=t$2;
                continue}
              var l$0=t$1[1],v$3=t$1[2];
              if(0 < caml_call2(_ry_,v$3,key$0)){var t$1=l$0;continue}
              var
               t$3=t$1[4],
               d$2=t$1[3],
               v$4=t$1[2],
               e$2=[0,v$4,d$2,l$0,e$1],
               t$1=t$3,
               e$1=e$2;
              continue}
            var init$0=e$1;
            break}}
        else
         var init$0=cons_right$0(t$5,0);
        return [0,init$0,next$0]}
      var
       t$6=
        fold$0
         (keys_less_or_equal_to,
          t$4,
          function(_rz_,_rA_){return inclusive_bound(get_key,_rz_,_rA_)});
      function next(enum$0)
       {if(! enum$0)return 0;
        var e=enum$0[4],t=enum$0[3],v=enum$0[2],k=enum$0[1];
        return [1,[0,k,v],cons$1(t,e)]}
      if(keys_greater_or_equal_to)
       {var key=keys_greater_or_equal_to[1],t=t$6,e=0,_rx_=comparator[1];
        for(;;)
         {if(typeof t !== "number")
           {if(0 === t[0]){var d=t[2],v=t[1],t$0=[1,0,v,d,0,1],t=t$0;continue}
            var l=t[1],r=t[4],v$0=t[2];
            if(0 <= caml_call2(_rx_,v$0,key))
             {var r$0=t[4],d$0=t[3],v$1=t[2],e$0=[0,v$1,d$0,r$0,e],t=l,e=e$0;
              continue}
            var t=r;
            continue}
          var init=e;
          break}}
      else
       var init=of_tree$2(t$6);
      return [0,init,next]}
    function compare$59(compare_key,compare_data,t1$1,t2$1)
     {var t2$2=of_tree$2(t2$1),t1$2=of_tree$2(t1$1),t1=t1$2,t2=t2$2;
      for(;;)
       {if(! t1)return t2?-1:0;
        if(! t2)return 1;
        var
         e2=t2[4],
         r2=t2[3],
         d2=t2[2],
         v2=t2[1],
         e1=t1[4],
         r1=t1[3],
         d1=t1[2],
         v1=t1[1],
         c=caml_call2(compare_key,v1,v2);
        if(0 !== c)return c;
        var c$0=caml_call2(compare_data,d1,d2);
        if(0 !== c$0)return c$0;
        if(r1 === r2){var t1=e1,t2=e2;continue}
        var t2$0=cons$1(r2,e2),t1$0=cons$1(r1,e1),t1=t1$0,t2=t2$0}}
    function equal$44(compare_key,compare_data,t1$1,t2$1)
     {var t2$2=of_tree$2(t2$1),t1$2=of_tree$2(t1$1),t1=t1$2,t2=t2$2;
      for(;;)
       {if(t1)
         {if(t2)
           {var
             e2=t2[4],
             r2=t2[3],
             d2=t2[2],
             v2=t2[1],
             e1=t1[4],
             r1=t1[3],
             d1=t1[2],
             v1=t1[1],
             _ru_=0 === caml_call2(compare_key,v1,v2)?1:0;
            if(_ru_)
             {var _rv_=caml_call2(compare_data,d1,d2);
              if(_rv_)
               {if(r1 === r2){var t1=e1,t2=e2;continue}
                var t2$0=cons$1(r2,e2),t1$0=cons$1(r1,e1),t1=t1$0,t2=t2$0;
                continue}
              var _rw_=_rv_}
            else
             var _rw_=_ru_;
            return _rw_}}
        else
         if(! t2)return 1;
        return 0}}
    function iter2$3(t1,t2,f,compare_key)
     {function _rs_(key,data,param){return caml_call2(f,key,data)}
      var _rt_=of_tree$2(t2);
      return fold2$0(compare_key,of_tree$2(t1),_rt_,0,_rs_)}
    function fold2$1(t1,t2,init,f,compare_key)
     {var _rr_=of_tree$2(t2);
      return fold2$0(compare_key,of_tree$2(t1),_rr_,init,f)}
    function fold_symmetric_diff(t1,t2,compare_key,data_equal,init,f)
     {function add(acc,k,v){return caml_call2(f,acc,[0,k,[0,-57574468,v]])}
      function remove(acc,k,v){return caml_call2(f,acc,[0,k,[0,847852583,v]])}
      function delta(acc,k,v$0,v)
       {return caml_call2(data_equal,v$0,v)
                ?acc
                :caml_call2(f,acc,[0,k,[0,1013247643,[0,v$0,v]]])}
      function loop(t$0,t,acc$3)
       {var t$2=t$0,t$1=t,acc$4=acc$3;
        for(;;)
         {if(t$2 === t$1)return acc$4;
          var switch$0=0;
          if(typeof t$2 === "number")
           return fold$12
                   (t$1,acc$4,function(key,data,acc){return add(acc,key,data)});
          if(0 === t$2[0])
           {var _rl_=t$2[2],_rm_=t$2[1];
            if(typeof t$1 === "number")
             switch$0 = 1;
            else
             if(0 === t$1[0])
              {var v=t$1[2],k=t$1[1],x=caml_call2(compare_key,_rm_,k);
               if(0 === x)return delta(acc$4,_rm_,_rl_,v);
               if(0 <= x)
                {var acc$5=add(acc$4,k,v);return remove(acc$5,_rm_,_rl_)}
               var acc$6=remove(acc$4,_rm_,_rl_);
               return add(acc$6,k,v)}}
          else
           {var _rp_=t$2[2],_rn_=t$2[4],_ro_=t$2[3],_rq_=t$2[1];
            if(typeof t$1 === "number")
             switch$0 = 1;
            else
             if(0 !== t$1[0])
              {var l=t$1[1],r=t$1[4],v$0=t$1[3],k$0=t$1[2];
               if(0 === caml_call2(compare_key,_rp_,k$0))
                {var
                  acc$7=loop(_rq_,l,acc$4),
                  acc$8=delta(acc$7,_rp_,_ro_,v$0),
                  t$2=_rn_,
                  t$1=r,
                  acc$4=acc$8;
                 continue}}}
          if(switch$0)
           return fold$12
                   (t$2,
                    acc$4,
                    function(key,data,acc){return remove(acc,key,data)});
          var
           add$0=
            function(acc,k,v){return caml_call2(f,acc,[0,k,[0,-57574468,v]])},
           remove$0=
            function(acc,k,v){return caml_call2(f,acc,[0,k,[0,847852583,v]])},
           right$2=of_tree$2(t$1),
           left$2=of_tree$2(t$2),
           left=left$2,
           right=right$2,
           acc=acc$4;
          for(;;)
           {if(! left)
             return fold$13
                     (acc,
                      function(key,data,acc){return add$0(acc,key,data)},
                      right);
            if(! right)
             return fold$13
                     (acc,
                      function(key,data,acc){return remove$0(acc,key,data)},
                      left);
            var
             enum2=right[4],
             tree2=right[3],
             v2=right[2],
             k2=right[1],
             enum1=left[4],
             tree1=left[3],
             v1=left[2],
             k1=left[1],
             compare_result=caml_call2(compare_key,k1,k2);
            if(0 === compare_result)
             {var
               acc$0=
                caml_call2(data_equal,v1,v2)
                 ?acc
                 :caml_call2(f,acc,[0,k1,[0,1013247643,[0,v1,v2]]]);
              if(tree1 === tree2)
               {var left=enum1,right=enum2,acc=acc$0;continue}
              var
               right$0=cons$1(tree2,enum2),
               left$0=cons$1(tree1,enum1),
               left=left$0,
               right=right$0,
               acc=acc$0;
              continue}
            if(0 <= compare_result)
             {var
               acc$1=add$0(acc,k2,v2),
               right$1=cons$1(tree2,enum2),
               right=right$1,
               acc=acc$1;
              continue}
            var
             acc$2=remove$0(acc,k1,v1),
             left$1=cons$1(tree1,enum1),
             left=left$1,
             acc=acc$2}}}
      return loop(t1,t2,init)}
    function length$17(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var r=param[4],l=param[1],_rk_=length$17(r);
      return (length$17(l) + _rk_ | 0) + 1 | 0}
    function keys(t)
     {return fold_right$4(t,0,function(key,param,list){return [0,key,list]})}
    function data(t)
     {return fold_right$4(t,0,function(param,data,list){return [0,data,list]})}
    function Of_foldable(M)
     {function of_foldable_fold(foldable,init,f,compare_key)
       {function _ri_(param,_rj_)
         {var
           data=_rj_[2],
           key=_rj_[1],
           length=param[2],
           accum=param[1],
           match=find$11(accum,key,compare_key);
          if(match)var prev=match[1],prev_data=prev;else var prev_data=init;
          var data$0=caml_call2(f,prev_data,data);
          return set$5(accum,length,key,data$0,compare_key)}
        return caml_call3
                (M[2],foldable,[0,empty_without_value_restrictio,0],_ri_)}
      function of_foldable_reduce(foldable,f,compare_key)
       {function _rg_(param,_rh_)
         {var
           data=_rh_[2],
           key=_rh_[1],
           length=param[2],
           accum=param[1],
           match=find$11(accum,key,compare_key);
          if(match)
           var prev=match[1],new_data=caml_call2(f,prev,data);
          else
           var new_data=data;
          return set$5(accum,length,key,new_data,compare_key)}
        return caml_call3
                (M[2],foldable,[0,empty_without_value_restrictio,0],_rg_)}
      function of_foldable(foldable,compare_key)
       {return with_return
                (function(r)
                  {function _re_(param,_rf_)
                    {var
                      data=_rf_[2],
                      key=_rf_[1],
                      length=param[2],
                      t=param[1],
                      acc=set$5(t,length,key,data,compare_key),
                      length$0=acc[2];
                     return length === length$0
                             ?caml_call1(r,[0,-1048878709,key])
                             :acc}
                   var
                    map=
                     caml_call3
                      (M[2],foldable,[0,empty_without_value_restrictio,0],_re_);
                   return [0,17724,map]})}
      function of_foldable_or_error(foldable,comparator)
       {var match=of_foldable(foldable,comparator[1]);
        if(17724 <= match[1]){var x=match[2];return [0,x]}
        var key=match[2],_rd_=comparator[2];
        return error$0
                (0,
                 0,
                 caml_call2
                  (symbol$59,
                   cst_Map_of,
                   caml_call2(symbol$59,M[1],cst_or_error_duplicate_key)),
                 key,
                 _rd_)}
      function of_foldable_exn(foldable,comparator)
       {var match=of_foldable(foldable,comparator[1]);
        if(17724 <= match[1]){var x=match[2];return x}
        var key=match[2],_rc_=comparator[2];
        return raise
                (create$2
                  (0,
                   0,
                   caml_call2
                    (symbol$59,
                     cst_Map_of$0,
                     caml_call2(symbol$59,M[1],cst_exn_duplicate_key)),
                   key,
                   _rc_))}
      return [0,
              of_foldable_fold,
              of_foldable_reduce,
              of_foldable,
              of_foldable_or_error,
              of_foldable_exn]}
    var
     Of_alist=Of_foldable([0,name$1,fold_left]),
     of_alist_fold=Of_alist[1],
     of_alist_reduce=Of_alist[2],
     of_alist=Of_alist[3],
     of_alist_or_error=Of_alist[4],
     of_alist_exn=Of_alist[5];
    function of_foldable_multi(foldable,fold,compare_key)
     {var alist=caml_call3(fold,foldable,0,function(l,x){return [0,x,l]});
      return caml_call4
              (of_alist_fold,
               alist,
               0,
               function(l,x){return [0,x,l]},
               compare_key)}
    function of_alist_multi(alist,compare_key)
     {return of_foldable_multi(alist,fold_left,compare_key)}
    var
     Of_sequence=Of_foldable([0,name$2,fold$1]),
     of_sequence_fold=Of_sequence[1],
     of_sequence_reduce=Of_sequence[2],
     of_sequence$5=Of_sequence[3],
     of_sequence_or_error=Of_sequence[4],
     of_sequence_exn=Of_sequence[5];
    function of_sequence_multi(sequence,compare_key)
     {return of_foldable_multi(sequence,fold$1,compare_key)}
    function for_all$11(t,f)
     {return with_return
              (function(r)
                {iter$17
                  (t,
                   function(data)
                    {var _rb_=1 - caml_call1(f,data);
                     return _rb_?caml_call1(r,0):_rb_});
                 return 1})}
    function for_alli$6(t,f)
     {return with_return
              (function(r)
                {iteri$9
                  (t,
                   function(key,data)
                    {var _ra_=1 - caml_call2(f,key,data);
                     return _ra_?caml_call1(r,0):_ra_});
                 return 1})}
    function exists$11(t,f)
     {return with_return
              (function(r)
                {iter$17
                  (t,
                   function(data)
                    {var _q$_=caml_call1(f,data);
                     return _q$_?caml_call1(r,1):_q$_});
                 return 0})}
    function existsi$6(t,f)
     {return with_return
              (function(r)
                {iteri$9
                  (t,
                   function(key,data)
                    {var _q__=caml_call2(f,key,data);
                     return _q__?caml_call1(r,1):_q__});
                 return 0})}
    function count$10(t,f)
     {return fold$12
              (t,
               0,
               function(param,data,acc)
                {return caml_call1(f,data)?acc + 1 | 0:acc})}
    function counti$6(t,f)
     {return fold$12
              (t,
               0,
               function(key,data,acc)
                {return caml_call2(f,key,data)?acc + 1 | 0:acc})}
    function to_alist(opt,t)
     {if(opt)var sth=opt[1],key_order=sth;else var key_order=608542111;
      return 608542111 <= key_order
              ?fold_right$4
                (t,0,function(key,data,x){return [0,[0,key,data],x]})
              :fold$12(t,0,function(key,data,x){return [0,[0,key,data],x]})}
    function merge$3(t1,t2,f,compare_key)
     {var
       _q9_=length$17(t2),
       elts=caml_make_vect(length$17(t1) + _q9_ | 0,0),
       i=[0,0];
      iter2$3
       (t1,
        t2,
        function(key,values)
         {var match=caml_call2(f,key,values);
          if(! match)return 0;
          var value=match[1];
          set$1(elts,i[1],[0,key,value]);
          return incr(i)},
        compare_key);
      var len=i[1];
      function get(i){return get$3(elts,i)}
      var tree=of_increasing_iterator_uncheck$4(len,get);
      return [0,tree,len]}
    function merge_large_first
     (length_large,t_large,t_small,call,combine,compare_key)
     {return fold$12
              (t_small,
               [0,t_large,length_large],
               function(key,data,param)
                {var length=param[2],t=param[1];
                 return update
                         (t,
                          key,
                          function(param)
                           {if(! param)return data;
                            var data$0=param[1];
                            return caml_call4(call,combine,key,data$0,data)},
                          length,
                          compare_key)})}
    function call$0(f,key,x,y){return caml_call3(f,key,x,y)}
    function swap$6(f,key,x,y){return caml_call3(f,key,y,x)}
    function merge_skewed(t1,t2,length1,length2,combine,compare_key)
     {return length2 <= length1
              ?merge_large_first(length1,t1,t2,call$0,combine,compare_key)
              :merge_large_first(length2,t2,t1,swap$6,combine,compare_key)}
    function repackage(marker,k,v){return marker?[0,[0,k,v]]:0}
    function closest_key(t$0,dir,k$1,compare_key)
     {var t=t$0,found_marker=0,found_key=0,found_value=0;
      for(;;)
       {if(typeof t === "number")
         return repackage(found_marker,found_key,found_value);
        if(0 === t[0])
         {var
           v=t[2],
           k=t[1],
           c=caml_call2(compare_key,k,k$1),
           _q8_=
            521507869 <= dir
             ?927731004 <= dir?c <= 0?1:0:0 <= c?1:0
             :-640801497 <= dir?c < 0?1:0:0 < c?1:0;
          return _q8_
                  ?[0,[0,k,v]]
                  :repackage(found_marker,found_key,found_value)}
        var
         r=t[4],
         v$0=t[3],
         k$0=t[2],
         l=t[1],
         c$0=caml_call2(compare_key,k$0,k$1);
        if(0 === c$0)
         return -640801497 === dir
                 ?is_empty$10(l)
                   ?repackage(found_marker,found_key,found_value)
                   :max_elt$11(l)
                 :-779285465 <= dir
                   ?[0,[0,k$0,v$0]]
                   :is_empty$10(r)
                     ?repackage(found_marker,found_key,found_value)
                     :min_elt$11(r);
        if(-640801497 !== dir && 927731004 > dir)
         {if(0 < c$0)
           {var t=l,found_marker=1,found_key=k$0,found_value=v$0;continue}
          var t=r;
          continue}
        if(0 <= c$0){var t=l;continue}
        var t=r,found_marker=1,found_key=k$0,found_value=v$0}}
    function rank(t,k,compare_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var k$0=t$0[1];return 0 === caml_call2(compare_key,k$0,k)?_fp_:0}
        var r=t$0[4],k$1=t$0[2],l=t$0[1],c=caml_call2(compare_key,k$1,k);
        if(0 === c)return [0,length$17(l)];
        if(0 < c){var t$0=l;continue}
        var _q7_=function(rank){return (rank + 1 | 0) + length$17(l) | 0};
        return caml_call2(map$16,rank(r,k,compare_key),_q7_)}}
    function nth$4(num_to_search,param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         {var v=param$0[2],k=param$0[1];
          return 0 === num_to_search[1]?[0,[0,k,v]]:(decr(num_to_search),0)}
        var
         r=param$0[4],
         v$0=param$0[3],
         k$0=param$0[2],
         l=param$0[1],
         some=nth$4(num_to_search,l);
        if(some)return some;
        if(0 === num_to_search[1])return [0,[0,k$0,v$0]];
        decr(num_to_search);
        var param$0=r}}
    function nth$5(t,n){return nth$4([0,n],t)}
    function find_first_satisfying$1(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[2],k=t$0[1];return caml_call2(f,k,v)?[0,[0,k,v]]:0}
        var r=t$0[4],v$0=t$0[3],k$0=t$0[2],l=t$0[1];
        if(caml_call2(f,k$0,v$0))
         {var x=find_first_satisfying$1(l,f);return x?x:[0,[0,k$0,v$0]]}
        var t$0=r}}
    function find_last_satisfying$1(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[2],k=t$0[1];return caml_call2(f,k,v)?[0,[0,k,v]]:0}
        var r=t$0[4],v$0=t$0[3],k$0=t$0[2],l=t$0[1];
        if(caml_call2(f,k$0,v$0))
         {var x=find_last_satisfying$1(r,f);return x?x:[0,[0,k$0,v$0]]}
        var t$0=l}}
    function binary_search$4(t,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying$1
                   (t,
                    function(key,data)
                     {return 0 <= caml_call3(compare,key,data,v)?1:0})
                 :find_last_satisfying$1
                   (t,
                    function(key,data)
                     {return caml_call3(compare,key,data,v) < 0?1:0})
               :-253007807 <= how
                 ?find_last_satisfying$1
                   (t,
                    function(key,data)
                     {return caml_call3(compare,key,data,v) <= 0?1:0})
                 :find_first_satisfying$1
                   (t,
                    function(key,data)
                     {return 0 < caml_call3(compare,key,data,v)?1:0});
      if(-1055410545 <= how)
       {var
         pair=
          find_last_satisfying$1
           (t,
            function(key,data){return caml_call3(compare,key,data,v) <= 0?1:0});
        if(pair)
         {var match=pair[1],data=match[2],key=match[1];
          if(0 === caml_call3(compare,key,data,v))return pair}
        return 0}
      var
       pair$0=
        find_first_satisfying$1
         (t,
          function(key,data){return 0 <= caml_call3(compare,key,data,v)?1:0});
      if(pair$0)
       {var match$0=pair$0[1],data$0=match$0[2],key$0=match$0[1];
        if(0 === caml_call3(compare,key$0,data$0,v))return pair$0}
      return 0}
    function binary_search_segmented$4(t,segment_of,how)
     {function is_left(key,data)
       {var match=caml_call2(segment_of,key,data);
        return 847852583 <= match?1:0}
      function is_right(key,data){return 1 - is_left(key,data)}
      return 125585502 <= how
              ?find_last_satisfying$1(t,is_left)
              :find_first_satisfying$1(t,is_right)}
    function binary_search_one_sided_bound
     (t,maybe_bound,compare,if_exclusive,if_inclusive)
     {function find_bound(t,how,bound,compare)
       {var match=binary_search$4(t,compare,how,bound);
        if(! match)return 0;
        var match$0=match[1],bound$0=match$0[1];
        return [0,[0,bound$0]]}
      if(typeof maybe_bound === "number")return _fq_;
      if(0 === maybe_bound[0])
       {var bound=maybe_bound[1];
        return find_bound(t,if_inclusive,bound,compare)}
      var bound$0=maybe_bound[1];
      return find_bound(t,if_exclusive,bound$0,compare)}
    function binary_search_two_sided_bounds(t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_one_sided_bound
         (t,lower_bound,compare,-839473056,926943384);
      if(! match)return 0;
      var
       lower_bound$0=match[1],
       match$0=
        binary_search_one_sided_bound
         (t,upper_bound,compare,200870407,-253007807);
      if(! match$0)return 0;
      var upper_bound$0=match$0[1];
      return [0,[0,lower_bound$0,upper_bound$0]]}
    function of_iteri(iteri,compare_key)
     {var acc=[0,0,[0,empty_without_value_restrictio,0]];
      caml_call1
       (iteri,
        function(key,data)
         {var
           match=acc[2],
           length=match[2],
           map=match[1],
           pair=set$5(map,length,key,data,compare_key),
           length$0=pair[2];
          if(length === length$0 && is_none(acc[1]))
           {acc[1] = [0,key];return 0}
          acc[2] = pair;
          return 0});
      var _q6_=acc[1];
      if(! _q6_)return [0,17724,acc[2]];
      var key=_q6_[1];
      return [0,-1048878709,key]}
    function of_iteri_exn(iteri,comparator)
     {var match=of_iteri(iteri,comparator[1]);
      if(17724 <= match[1]){var v=match[2];return v}
      var key=match[2];
      return raise
              (create$2(0,0,cst_Map_of_iteri_exn_duplicate,key,comparator[2]))}
    function t_of_sexp_direct$2(key_of_sexp,value_of_sexp,sexp,comparator)
     {var
       alist=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,key_of_sexp,value_of_sexp),
          sexp),
       compare_key=comparator[1],
       match=caml_call2(of_alist,alist,compare_key);
      if(17724 <= match[1]){var v=match[2];return v}
      var k=match[2];
      function _q0_(_q5_){return _q5_}
      var
       alist_sexps=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,function(_q4_){return _q4_},_q0_),
          sexp),
       found_first_k=[0,0];
      iter2_ok
       (alist,
        alist_sexps,
        function(param,_q1_)
         {var
           k2_sexp=_q1_[1],
           k2=param[1],
           _q2_=0 === caml_call2(compare_key,k,k2)?1:0;
          if(_q2_)
           {if(found_first_k[1])
             return caml_call2
                     (of_sexp_error,cst_Map_t_of_sexp_direct_dupli,k2_sexp);
            found_first_k[1] = 1;
            var _q3_=0}
          else
           var _q3_=_q2_;
          return _q3_});
      throw [0,Assert_failure$0,_fr_]}
    function sexp_of_t$56(sexp_of_key,sexp_of_value,t)
     {function f(key,data,acc)
       {var _qZ_=[0,caml_call1(sexp_of_value,data),0];
        return [0,[1,[0,caml_call1(sexp_of_key,key),_qZ_]],acc]}
      return [1,fold_right$4(t,0,f)]}
    function combine_errors$1(t,compare_key,sexp_of_key)
     {var
       _qY_=partition_map$0(t,to_either,compare_key),
       match=_qY_[2],
       error_tree=match[1],
       oks=_qY_[1];
      return is_empty$10(error_tree)
              ?[0,oks]
              :error_s(sexp_of_t$56(sexp_of_key,sexp_of_t$22,error_tree))}
    function map_keys(t1,f,param)
     {var sexp_of_key=param[2],compare_key=param[1];
      return with_return
              (function(param)
                {return [0,
                         17724,
                         fold$12
                          (t1,
                           [0,empty_without_value_restrictio,0],
                           function(key,data,param$0)
                            {var
                              length=param$0[2],
                              t2=param$0[1],
                              key$0=caml_call1(f,key);
                             try
                              {var
                                _qW_=
                                 add_exn_internal
                                  (t2,length,key$0,data,compare_key,sexp_of_key);
                               return _qW_}
                             catch(_qX_)
                              {_qX_ = caml_wrap_exception(_qX_);
                               if(_qX_ === Duplicate)
                                return caml_call1(param,[0,-1048878709,key$0]);
                               throw _qX_}})]})}
    function map_keys_exn(t,f,comparator)
     {var match=map_keys(t,f,comparator);
      if(17724 <= match[1]){var result=match[2];return result}
      var key=match[2],sexp_of_key=comparator[2];
      return raise_s
              (caml_call2
                (message,
                 cst_Map_map_keys_exn_duplicate,
                 [0,[0,cst_key$0,caml_call1(sexp_of_key,key)],0]))}
    function compare_key(t){return t[1][1]}
    function like$0(param,_qV_)
     {var length=_qV_[2],tree=_qV_[1],comparator=param[1];
      return [0,comparator,tree,length]}
    function like2(x,param)
     {var z=param[2],y=param[1],_qU_=like$0(x,z);return [0,like$0(x,y),_qU_]}
    function like_maybe_no_op(old_t,param)
     {var length=param[2],tree=param[1],old_tree=old_t[2],comparator=old_t[1];
      return old_tree === tree?old_t:[0,comparator,tree,length]}
    function with_same_length(param,tree)
     {var length=param[3],comparator=param[1];
      return [0,comparator,tree,length]}
    function of_tree$3(comparator,tree)
     {return [0,comparator,tree,length$17(tree)]}
    function comparator$16(t){return t[1]}
    function to_tree$2(t){return t[2]}
    function invariants$3(t)
     {var _qQ_=compare_key(t),_qR_=invariants$2(t[2],_qQ_);
      if(_qR_)
       var _qS_=t[3],_qT_=length$17(t[2]) === _qS_?1:0;
      else
       var _qT_=_qR_;
      return _qT_}
    function is_empty$11(t){return is_empty$10(t[2])}
    function length$18(t){return t[3]}
    function set$7(t,key,data)
     {var _qP_=compare_key(t);return like$0(t,set$5(t[2],t[3],key,data,_qP_))}
    function add_exn$0(t,key,data)
     {var _qN_=t[1][2],_qO_=compare_key(t);
      return like$0(t,add_exn(t[2],t[3],key,data,_qO_,_qN_))}
    function add_exn_internal$0(t,key,data)
     {var _qL_=t[1][2],_qM_=compare_key(t);
      return like$0(t,add_exn_internal(t[2],t[3],key,data,_qM_,_qL_))}
    function add$4(t,key,data)
     {try
       {var result=add_exn_internal$0(t,key,data)}
      catch(_qK_)
       {_qK_ = caml_wrap_exception(_qK_);
        if(_qK_ === Duplicate)return -1024851605;
        throw _qK_}
      return [0,17724,result]}
    function add_multi$0(t,key,data)
     {var _qJ_=compare_key(t);
      return like$0(t,add_multi(t[2],t[3],key,data,_qJ_))}
    function remove_multi$0(t,key)
     {var _qI_=compare_key(t);
      return like$0(t,remove_multi(t[2],key,t[3],_qI_))}
    function find_multi$0(t,key)
     {var _qH_=compare_key(t);return find_multi(t[2],key,_qH_)}
    function change$0(t,key,f)
     {var _qG_=compare_key(t);return like$0(t,change(t[2],key,f,t[3],_qG_))}
    function update$0(t,key,f)
     {var _qF_=compare_key(t);return like$0(t,update(t[2],key,f,t[3],_qF_))}
    function find_exn$7(t,key)
     {var _qD_=t[1][2],_qE_=compare_key(t);
      return find_exn$6(t[2],key,_qE_,_qD_)}
    function find$12(t,key)
     {var _qC_=compare_key(t);return find$11(t[2],key,_qC_)}
    function remove$4(t,key)
     {var _qB_=compare_key(t);
      return like_maybe_no_op(t,remove$3(t[2],key,t[3],_qB_))}
    function mem$10(t,key)
     {var _qA_=compare_key(t);return mem$9(t[2],key,_qA_)}
    function iter_keys$0(t,f){return iter_keys(t[2],f)}
    function iter$18(t,f){return iter$17(t[2],f)}
    function iteri$10(t,f){return iteri$9(t[2],f)}
    function iteri_until$0(t,f){return iteri_until(t[2],f)}
    function iter2$4(t1,t2,f)
     {var _qz_=compare_key(t1);return iter2$3(t1[2],t2[2],f,_qz_)}
    function map$34(t,f){return with_same_length(t,map$33(t[2],f))}
    function mapi$8(t,f){return with_same_length(t,mapi$7(t[2],f))}
    function fold$14(t,init,f){return fold$12(t[2],init,f)}
    function fold_until$11(t,init,f)
     {var _qx_=t[2];
      return function(_qy_){return fold_until$10(_qx_,init,f,_qy_)}}
    function fold_right$5(t,init,f){return fold_right$4(t[2],init,f)}
    function fold2$2(t1,t2,init,f)
     {var _qw_=compare_key(t1);return fold2$1(t1[2],t2[2],init,f,_qw_)}
    function filter_keys$0(t,f)
     {var _qv_=compare_key(t);return like$0(t,filter_keys(t[2],f,_qv_))}
    function filter$9(t,f)
     {var _qu_=compare_key(t);return like$0(t,filter$8(t[2],f,_qu_))}
    function filteri$5(t,f)
     {var _qt_=compare_key(t);return like$0(t,filteri$4(t[2],f,_qt_))}
    function filter_map$9(t,f)
     {var _qs_=compare_key(t);return like$0(t,filter_map$8(t[2],f,_qs_))}
    function filter_mapi$4(t,f)
     {var _qr_=compare_key(t);return like$0(t,filter_mapi$3(t[2],f,_qr_))}
    function partition_mapi$0(t,f)
     {var _qq_=compare_key(t);return like2(t,partition_mapi(t[2],f,_qq_))}
    function partition_map$1(t,f)
     {var _qp_=compare_key(t);return like2(t,partition_map$0(t[2],f,_qp_))}
    function partitioni_tf$1(t,f)
     {var _qo_=compare_key(t);return like2(t,partitioni_tf$0(t[2],f,_qo_))}
    function partition_tf$5(t,f)
     {var _qn_=compare_key(t);return like2(t,partition_tf$4(t[2],f,_qn_))}
    function combine_errors$2(t)
     {function _qj_(_qm_){return like$0(t,_qm_)}
      var _qk_=t[1][2],_ql_=compare_key(t);
      return caml_call2(map$5,combine_errors$1(t[2],_ql_,_qk_),_qj_)}
    function compare_direct$1(compare_data,t1,t2)
     {var _qh_=t2[2],_qi_=t1[2];
      return compare$59(compare_key(t1),compare_data,_qi_,_qh_)}
    function equal$45(compare_data,t1,t2)
     {var _qf_=t2[2],_qg_=t1[2];
      return equal$44(compare_key(t1),compare_data,_qg_,_qf_)}
    function keys$0(t){return keys(t[2])}
    function data$0(t){return data(t[2])}
    function to_alist$0(key_order,t){return to_alist(key_order,t[2])}
    function symmetric_diff$3(t1,t2,data_equal)
     {var _qe_=compare_key(t1);
      return symmetric_diff$2(t1[2],t2[2],_qe_,data_equal)}
    function fold_symmetric_diff$0(t1,t2,data_equal,init,f)
     {var _qd_=compare_key(t1);
      return fold_symmetric_diff(t1[2],t2[2],_qd_,data_equal,init,f)}
    function merge$4(t1,t2,f)
     {var _qc_=compare_key(t1);return like$0(t1,merge$3(t1[2],t2[2],f,_qc_))}
    function merge_skewed$0(t1,t2,combine)
     {var
       _qa_=compare_key(t1),
       _qb_=merge_skewed(t1[2],t2[2],t1[3],t2[3],combine,_qa_),
       t1$0=t2[3] <= t1[3]?t1:t2;
      return like_maybe_no_op(t1$0,_qb_)}
    function min_elt$12(t){return min_elt$11(t[2])}
    function min_elt_exn$3(t){return min_elt_exn$2(t[2])}
    function max_elt$12(t){return max_elt$11(t[2])}
    function max_elt_exn$3(t){return max_elt_exn$2(t[2])}
    function for_all$12(t,f){return for_all$11(t[2],f)}
    function for_alli$7(t,f){return for_alli$6(t[2],f)}
    function exists$12(t,f){return exists$11(t[2],f)}
    function existsi$7(t,f){return existsi$6(t[2],f)}
    function count$11(t,f){return count$10(t[2],f)}
    function counti$7(t,f){return counti$6(t[2],f)}
    function split$5(t,k)
     {var
       _p__=compare_key(t),
       match=split$4(t[2],k,_p__),
       r=match[3],
       maybe=match[2],
       l=match[1],
       comparator=t[1],
       both_len=is_some(maybe)?t[3] - 1 | 0:t[3],
       _p$_=height$0(r);
      if(height$0(l) < _p$_)
       {var l$0=of_tree$3(comparator,l);
        return [0,l$0,maybe,[0,comparator,r,both_len - l$0[3] | 0]]}
      var r$0=of_tree$3(comparator,r);
      return [0,[0,comparator,l,both_len - r$0[3] | 0],maybe,r$0]}
    function subrange(t,lower_bound,upper_bound)
     {var
       _p7_=compare_key(t),
       match=split_range(t[2],lower_bound,upper_bound,_p7_),
       right=match[3],
       mid=match[2],
       left=match[1],
       h_l=height$0(left),
       h_r=height$0(right),
       outer_joined_height=h_l === h_r?h_l + 1 | 0:caml_call2(max$2,h_l,h_r);
      if(outer_joined_height >= height$0(mid))return of_tree$3(t[1],mid);
      var
       _p8_=length$17(right),
       _p9_=length$17(left) + _p8_ | 0,
       mid_length=t[3] - _p9_ | 0;
      return [0,t[1],mid,mid_length]}
    function append$3(lower_part,upper_part)
     {var
       _p6_=compare_key(lower_part),
       match=append$2(lower_part[2],upper_part[2],_p6_);
      if(typeof match === "number")return 838882908;
      var tree=match[2];
      return [0,
              17724,
              [0,lower_part[1],tree,lower_part[3] + upper_part[3] | 0]]}
    function fold_range_inclusive$0(t,min,max,init,f)
     {var _p5_=compare_key(t);
      return fold_range_inclusive(t[2],min,max,init,f,_p5_)}
    function range_to_alist$0(t,min,max)
     {var _p4_=compare_key(t);return range_to_alist(t[2],min,max,_p4_)}
    function closest_key$0(t,dir,key)
     {var _p3_=compare_key(t);return closest_key(t[2],dir,key,_p3_)}
    function nth$6(t,n){return nth$5(t[2],n)}
    function nth_exn$1(t,n){return value_exn(0,0,0,nth$6(t,n))}
    function rank$0(t,key){var _p2_=compare_key(t);return rank(t[2],key,_p2_)}
    function sexp_of_t$57(sexp_of_k,sexp_of_v,param,t)
     {return sexp_of_t$56(sexp_of_k,sexp_of_v,t[2])}
    function to_sequence$4
     (order,keys_greater_or_equal_to,keys_less_or_equal_to,t)
     {return to_sequence$3
              (t[1],order,keys_greater_or_equal_to,keys_less_or_equal_to,t[2])}
    function binary_search$5(t,compare,how,v)
     {return binary_search$4(t[2],compare,how,v)}
    function binary_search_segmented$5(t,segment_of,how)
     {return binary_search_segmented$4(t[2],segment_of,how)}
    function hash_fold_direct$0(hash_fold_key,hash_fold_data,state,t)
     {var _p1_=t[2];
      function _p0_(key,data,state)
       {return caml_call2
                (hash_fold_data,caml_call2(hash_fold_key,state,key),data)}
      return fold$12
              (_p1_,caml_call2(hash_fold_t$4,state,length$17(_p1_)),_p0_)}
    function binary_search_subrange(t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_two_sided_bounds(t[2],compare,lower_bound,upper_bound);
      if(! match)return like_maybe_no_op(t,_fs_);
      var match$0=match[1],upper_bound$0=match$0[2],lower_bound$0=match$0[1];
      return subrange(t,lower_bound$0,upper_bound$0)}
    function empty$6(param){return empty_without_value_restrictio}
    function of_tree$4(param,tree){return tree}
    function singleton$8(param,k,v){return [0,k,v]}
    function of_sorted_array_unchecked$5(comparator,array)
     {return of_sorted_array_unchecked$4(array,comparator[1])[1]}
    function of_sorted_array$5(comparator,array)
     {return caml_call2(map$5,of_sorted_array$4(array,comparator[1]),get_key)}
    function of_alist$0(comparator,alist)
     {var d=caml_call2(of_alist,alist,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_alist_or_error$0(comparator,alist)
     {return caml_call2
              (map$5,caml_call2(of_alist_or_error,alist,comparator),get_key)}
    function of_alist_exn$0(comparator,alist)
     {return caml_call2(of_alist_exn,alist,comparator)[1]}
    function of_alist_multi$0(comparator,alist)
     {return of_alist_multi(alist,comparator[1])[1]}
    function of_alist_fold$0(comparator,alist,init,f)
     {return caml_call4(of_alist_fold,alist,init,f,comparator[1])[1]}
    function of_alist_reduce$0(comparator,alist,f)
     {return caml_call3(of_alist_reduce,alist,f,comparator[1])[1]}
    function of_iteri$0(comparator,iteri)
     {var d=of_iteri(iteri,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_iteri_exn$0(comparator,iteri)
     {return of_iteri_exn(iteri,comparator)[1]}
    function of_increasing_iterator_uncheck$5(required_by_intf,len,f)
     {return of_increasing_iterator_uncheck$4(len,f)}
    function of_increasing_sequence$0(comparator,seq)
     {return caml_call2
              (map$5,of_increasing_sequence(seq,comparator[1]),get_key)}
    function of_sequence$6(comparator,seq)
     {var d=caml_call2(of_sequence$5,seq,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_sequence_or_error$0(comparator,seq)
     {return caml_call2
              (map$5,caml_call2(of_sequence_or_error,seq,comparator),get_key)}
    function of_sequence_exn$0(comparator,seq)
     {return caml_call2(of_sequence_exn,seq,comparator)[1]}
    function of_sequence_multi$0(comparator,seq)
     {return of_sequence_multi(seq,comparator[1])[1]}
    function of_sequence_fold$0(comparator,seq,init,f)
     {return caml_call4(of_sequence_fold,seq,init,f,comparator[1])[1]}
    function of_sequence_reduce$0(comparator,seq,f)
     {return caml_call3(of_sequence_reduce,seq,f,comparator[1])[1]}
    function to_tree$3(t){return t}
    function invariants$4(comparator,t){return invariants$2(t,comparator[1])}
    function is_empty$12(t){return is_empty$10(t)}
    function length$19(t){return length$17(t)}
    function set$8(comparator,t,key,data)
     {return set$5(t,0,key,data,comparator[1])[1]}
    function add_exn$1(comparator,t,key,data)
     {return add_exn(t,0,key,data,comparator[1],comparator[2])[1]}
    function add$5(comparator,t,key,data)
     {try
       {var _pY_=[0,17724,add_exn$1(comparator,t,key,data)];return _pY_}
      catch(_pZ_){return -1024851605}}
    function add_multi$1(comparator,t,key,data)
     {return add_multi(t,0,key,data,comparator[1])[1]}
    function remove_multi$1(comparator,t,key)
     {return remove_multi(t,key,0,comparator[1])[1]}
    function find_multi$1(comparator,t,key)
     {return find_multi(t,key,comparator[1])}
    function change$1(comparator,t,key,f)
     {return change(t,key,f,0,comparator[1])[1]}
    function update$1(comparator,t,key,f)
     {return change$1
              (comparator,t,key,function(data){return [0,caml_call1(f,data)]})}
    function find_exn$8(comparator,t,key)
     {return find_exn$6(t,key,comparator[1],comparator[2])}
    function find$13(comparator,t,key){return find$11(t,key,comparator[1])}
    function remove$5(comparator,t,key)
     {return remove$3(t,key,0,comparator[1])[1]}
    function mem$11(comparator,t,key){return mem$9(t,key,comparator[1])}
    function iter_keys$1(t,f){return iter_keys(t,f)}
    function iter$19(t,f){return iter$17(t,f)}
    function iteri$11(t,f){return iteri$9(t,f)}
    function iteri_until$1(t,f){return iteri_until(t,f)}
    function iter2$5(comparator,t1,t2,f)
     {return iter2$3(t1,t2,f,comparator[1])}
    function map$35(t,f){return map$33(t,f)}
    function mapi$9(t,f){return mapi$7(t,f)}
    function fold$15(t,init,f){return fold$12(t,init,f)}
    function fold_until$12(t,init,f,finish)
     {return fold_until$10(t,init,f,finish)}
    function fold_right$6(t,init,f){return fold_right$4(t,init,f)}
    function fold2$3(comparator,t1,t2,init,f)
     {return fold2$1(t1,t2,init,f,comparator[1])}
    function filter_keys$1(comparator,t,f)
     {return filter_keys(t,f,comparator[1])[1]}
    function filter$10(comparator,t,f){return filter$8(t,f,comparator[1])[1]}
    function filteri$6(comparator,t,f){return filteri$4(t,f,comparator[1])[1]}
    function filter_map$10(comparator,t,f)
     {return filter_map$8(t,f,comparator[1])[1]}
    function filter_mapi$5(comparator,t,f)
     {return filter_mapi$3(t,f,comparator[1])[1]}
    function partition_mapi$1(comparator,t,f)
     {var
       _pX_=partition_mapi(t,f,comparator[1]),
       b=_pX_[2][1],
       match=_pX_[1],
       a=match[1];
      return [0,a,b]}
    function partition_map$2(comparator,t,f)
     {var
       _pW_=partition_map$0(t,f,comparator[1]),
       b=_pW_[2][1],
       match=_pW_[1],
       a=match[1];
      return [0,a,b]}
    function partitioni_tf$2(comparator,t,f)
     {var
       _pV_=partitioni_tf$0(t,f,comparator[1]),
       b=_pV_[2][1],
       match=_pV_[1],
       a=match[1];
      return [0,a,b]}
    function partition_tf$6(comparator,t,f)
     {var
       _pU_=partition_tf$4(t,f,comparator[1]),
       b=_pU_[2][1],
       match=_pU_[1],
       a=match[1];
      return [0,a,b]}
    function combine_errors$3(comparator,t)
     {return caml_call2
              (map$5,combine_errors$1(t,comparator[1],comparator[2]),get_key)}
    function compare_direct$2(comparator,compare_data,t1,t2)
     {return compare$59(comparator[1],compare_data,t1,t2)}
    function equal$46(comparator,compare_data,t1,t2)
     {return equal$44(comparator[1],compare_data,t1,t2)}
    function keys$1(t){return keys(t)}
    function data$1(t){return data(t)}
    function to_alist$1(key_order,t){return to_alist(key_order,t)}
    function symmetric_diff$4(comparator,t1,t2,data_equal)
     {return symmetric_diff$2(t1,t2,comparator[1],data_equal)}
    function fold_symmetric_diff$1(comparator,t1,t2,data_equal,init,f)
     {return fold_symmetric_diff(t1,t2,comparator[1],data_equal,init,f)}
    function merge$5(comparator,t1,t2,f)
     {return merge$3(t1,t2,f,comparator[1])[1]}
    function merge_skewed$1(comparator,t1,t2,combine)
     {var _pS_=comparator[1],_pT_=length$19(t2);
      return merge_skewed(t1,t2,length$19(t1),_pT_,combine,_pS_)[1]}
    function min_elt$13(t){return min_elt$11(t)}
    function min_elt_exn$4(t){return min_elt_exn$2(t)}
    function max_elt$13(t){return max_elt$11(t)}
    function max_elt_exn$4(t){return max_elt_exn$2(t)}
    function for_all$13(t,f){return for_all$11(t,f)}
    function for_alli$8(t,f){return for_alli$6(t,f)}
    function exists$13(t,f){return exists$11(t,f)}
    function existsi$8(t,f){return existsi$6(t,f)}
    function count$12(t,f){return count$10(t,f)}
    function counti$8(t,f){return counti$6(t,f)}
    function split$6(comparator,t,k){return split$4(t,k,comparator[1])}
    function append$4(comparator,lower_part,upper_part)
     {return append$2(lower_part,upper_part,comparator[1])}
    function subrange$0(comparator,t,lower_bound,upper_bound)
     {var
       match=split_range(t,lower_bound,upper_bound,comparator[1]),
       ret=match[2];
      return ret}
    function fold_range_inclusive$1(comparator,t,min,max,init,f)
     {return fold_range_inclusive(t,min,max,init,f,comparator[1])}
    function range_to_alist$1(comparator,t,min,max)
     {return range_to_alist(t,min,max,comparator[1])}
    function closest_key$1(comparator,t,dir,key)
     {return closest_key(t,dir,key,comparator[1])}
    function nth$7(t,n){return nth$5(t,n)}
    function nth_exn$2(t,n){return value_exn(0,0,0,nth$7(t,n))}
    function rank$1(comparator,t,key){return rank(t,key,comparator[1])}
    function sexp_of_t$58(sexp_of_k,sexp_of_v,param,t)
     {return sexp_of_t$56(sexp_of_k,sexp_of_v,t)}
    function t_of_sexp_direct$3(comparator,k_of_sexp,v_of_sexp,sexp)
     {return t_of_sexp_direct$2(k_of_sexp,v_of_sexp,sexp,comparator)[1]}
    function to_sequence$5
     (comparator,order,keys_greater_or_equal_to,keys_less_or_equal_to,t)
     {return to_sequence$3
              (comparator,
               order,
               keys_greater_or_equal_to,
               keys_less_or_equal_to,
               t)}
    function binary_search$6(param,t,compare,how,v)
     {return binary_search$4(t,compare,how,v)}
    function binary_search_segmented$6(param,t,segment_of,how)
     {return binary_search_segmented$4(t,segment_of,how)}
    function binary_search_subrange$0
     (comparator,t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_two_sided_bounds(t,compare,lower_bound,upper_bound);
      if(! match)return 0;
      var match$0=match[1],upper_bound$0=match$0[2],lower_bound$0=match$0[1];
      return subrange$0(comparator,t,lower_bound$0,upper_bound$0)}
    function map_keys$0(comparator,t,f)
     {var dup=map_keys(t,f,comparator);
      if(17724 > dup[1])return dup;
      var match=dup[2],t$0=match[1];
      return [0,17724,t$0]}
    function map_keys_exn$0(comparator,t,f)
     {return map_keys_exn(t,f,comparator)[1]}
    function add_exn$2(t,comparator,key,data)
     {var match=max_key(t);
      if(match)
       {var prev_key=match[1];
        if(0 <= caml_call2(comparator[1],prev_key,key))return raise_s(_ft_)}
      return add_unchecked(t,key,data)}
    function to_tree$4(t){return to_tree_unchecked(t)}
    var Build_increasing=[0,empty$5,add_exn$2,to_tree$4];
    function empty$7(comparator)
     {return [0,comparator,empty_without_value_restrictio,0]}
    function singleton$9(comparator,k,v){return [0,comparator,[0,k,v],1]}
    function of_tree0(comparator,param)
     {var length=param[2],tree=param[1];return [0,comparator,tree,length]}
    function of_tree$5(comparator,tree)
     {return of_tree0(comparator,[0,tree,length$17(tree)])}
    function of_sorted_array_unchecked$6(comparator,array)
     {return of_tree0
              (comparator,of_sorted_array_unchecked$4(array,comparator[1]))}
    function of_sorted_array$6(comparator,array)
     {function _pR_(tree){return of_tree0(comparator,tree)}
      return caml_call2(map$5,of_sorted_array$4(array,comparator[1]),_pR_)}
    function of_alist$1(comparator,alist)
     {var z=caml_call2(of_alist,alist,comparator[1]);
      if(17724 > z[1])return z;
      var match=z[2],length=match[2],tree=match[1];
      return [0,17724,[0,comparator,tree,length]]}
    function of_alist_or_error$1(comparator,alist)
     {function _pQ_(tree){return of_tree0(comparator,tree)}
      return caml_call2
              (map$5,caml_call2(of_alist_or_error,alist,comparator),_pQ_)}
    function of_alist_exn$1(comparator,alist)
     {return of_tree0(comparator,caml_call2(of_alist_exn,alist,comparator))}
    function of_alist_multi$1(comparator,alist)
     {return of_tree0(comparator,of_alist_multi(alist,comparator[1]))}
    function of_alist_fold$1(comparator,alist,init,f)
     {return of_tree0
              (comparator,
               caml_call4(of_alist_fold,alist,init,f,comparator[1]))}
    function of_alist_reduce$1(comparator,alist,f)
     {return of_tree0
              (comparator,caml_call3(of_alist_reduce,alist,f,comparator[1]))}
    function of_iteri$1(comparator,iteri)
     {var z=of_iteri(iteri,comparator[1]);
      if(17724 > z[1])return z;
      var tree_length=z[2];
      return [0,17724,of_tree0(comparator,tree_length)]}
    function of_iteri_exn$1(comparator,iteri)
     {return of_tree0(comparator,of_iteri_exn(iteri,comparator))}
    function of_increasing_iterator_uncheck$6(comparator,len,f)
     {return of_tree0
              (comparator,[0,of_increasing_iterator_uncheck$4(len,f),len])}
    function of_increasing_sequence$1(comparator,seq)
     {function _pO_(_pP_){return of_tree0(comparator,_pP_)}
      return caml_call2(map$5,of_increasing_sequence(seq,comparator[1]),_pO_)}
    function of_sequence$7(comparator,seq)
     {var z=caml_call2(of_sequence$5,seq,comparator[1]);
      if(17724 > z[1])return z;
      var match=z[2],length=match[2],tree=match[1];
      return [0,17724,[0,comparator,tree,length]]}
    function of_sequence_or_error$1(comparator,seq)
     {function _pN_(tree){return of_tree0(comparator,tree)}
      return caml_call2
              (map$5,caml_call2(of_sequence_or_error,seq,comparator),_pN_)}
    function of_sequence_exn$1(comparator,seq)
     {return of_tree0(comparator,caml_call2(of_sequence_exn,seq,comparator))}
    function of_sequence_multi$1(comparator,seq)
     {return of_tree0(comparator,of_sequence_multi(seq,comparator[1]))}
    function of_sequence_fold$1(comparator,seq,init,f)
     {return of_tree0
              (comparator,
               caml_call4(of_sequence_fold,seq,init,f,comparator[1]))}
    function of_sequence_reduce$1(comparator,seq,f)
     {return of_tree0
              (comparator,caml_call3(of_sequence_reduce,seq,f,comparator[1]))}
    function t_of_sexp_direct$4(comparator,k_of_sexp,v_of_sexp,sexp)
     {return of_tree0
              (comparator,
               t_of_sexp_direct$2(k_of_sexp,v_of_sexp,sexp,comparator))}
    function map_keys$1(comparator,t,f)
     {var dup=map_keys(t[2],f,comparator);
      if(17724 > dup[1])return dup;
      var pair=dup[2];
      return [0,17724,of_tree0(comparator,pair)]}
    function map_keys_exn$1(comparator,t,f)
     {return of_tree0(comparator,map_keys_exn(t[2],f,comparator))}
    function Empty_without_value_restrictio$0(K)
     {var empty=[0,K[1],empty_without_value_restrictio,0];return [0,empty]}
    function comparator_s$0(t){var comparator=t[1];return [0,comparator]}
    function of_tree$6(M){return function(tree){return of_tree$3(M[1],tree)}}
    function empty$8(m){return empty$7(m[1])}
    function singleton$10(m,a)
     {var _pL_=m[1];return function(_pM_){return singleton$9(_pL_,a,_pM_)}}
    function of_alist$2(m,a){return of_alist$1(m[1],a)}
    function of_alist_or_error$2(m,a){return of_alist_or_error$1(m[1],a)}
    function of_alist_exn$2(m,a){return of_alist_exn$1(m[1],a)}
    function of_alist_multi$2(m,a){return of_alist_multi$1(m[1],a)}
    function of_alist_fold$2(m,a,init,f)
     {return of_alist_fold$1(m[1],a,init,f)}
    function of_alist_reduce$2(m,a,f){return of_alist_reduce$1(m[1],a,f)}
    function of_sorted_array_unchecked$7(m,a)
     {return of_sorted_array_unchecked$6(m[1],a)}
    function of_sorted_array$7(m,a){return of_sorted_array$6(m[1],a)}
    function of_iteri$2(m,iteri){return of_iteri$1(m[1],iteri)}
    function of_iteri_exn$2(m,iteri){return of_iteri_exn$1(m[1],iteri)}
    function of_increasing_iterator_uncheck$7(m,len,f)
     {return of_increasing_iterator_uncheck$6(m[1],len,f)}
    function of_increasing_sequence$2(m,seq)
     {return of_increasing_sequence$1(m[1],seq)}
    function of_sequence$8(m,s){return of_sequence$7(m[1],s)}
    function of_sequence_or_error$2(m,s)
     {return of_sequence_or_error$1(m[1],s)}
    function of_sequence_exn$2(m,s){return of_sequence_exn$1(m[1],s)}
    function of_sequence_multi$2(m,s){return of_sequence_multi$1(m[1],s)}
    function of_sequence_fold$2(m,s,init,f)
     {return of_sequence_fold$1(m[1],s,init,f)}
    function of_sequence_reduce$2(m,s,f)
     {return of_sequence_reduce$1(m[1],s,f)}
    function map_keys$2(m,t,f){return map_keys$1(m[1],t,f)}
    function map_keys_exn$2(m,t,f){return map_keys_exn$1(m[1],t,f)}
    function M$0(K){return [0]}
    function sexp_of_m_t$0(K)
     {return function(sexp_of_v,t)
       {function _pK_(param){return _fu_}
        return sexp_of_t$57(K[1],sexp_of_v,_pK_,t)}}
    function m_t_of_sexp$0(K)
     {return function(v_of_sexp,sexp)
       {return t_of_sexp_direct$4(K[2],K[1],v_of_sexp,sexp)}}
    function m_t_sexp_grammar$0(K)
     {return function(v_grammar){return [2,[1,[2,[0,K[1],[0,v_grammar,0]]]]]}}
    function compare_m_t$0(param,compare_v,t1,t2)
     {return compare_direct$1(compare_v,t1,t2)}
    function equal_m_t$0(param,equal_v,t1,t2){return equal$45(equal_v,t1,t2)}
    function hash_fold_m_t$0(K)
     {return function(hash_fold_v,state)
       {var _pI_=K[1];
        return function(_pJ_)
         {return hash_fold_direct$0(_pI_,hash_fold_v,state,_pJ_)}}}
    var comparator$17=Poly[1];
    function of_tree$7(tree){return [0,comparator$17,tree,length$17(tree)]}
    var
     include$68=Empty_without_value_restrictio$0(Poly),
     empty$9=include$68[1];
    function singleton$11(a)
     {return function(_pH_){return singleton$9(comparator$17,a,_pH_)}}
    function of_alist$3(a){return of_alist$1(comparator$17,a)}
    function of_alist_or_error$3(a)
     {return of_alist_or_error$1(comparator$17,a)}
    function of_alist_exn$3(a){return of_alist_exn$1(comparator$17,a)}
    function of_alist_multi$3(a){return of_alist_multi$1(comparator$17,a)}
    function of_alist_fold$3(a,init,f)
     {return of_alist_fold$1(comparator$17,a,init,f)}
    function of_alist_reduce$3(a,f)
     {return of_alist_reduce$1(comparator$17,a,f)}
    function of_sorted_array_unchecked$8(a)
     {return of_sorted_array_unchecked$6(comparator$17,a)}
    function of_sorted_array$8(a){return of_sorted_array$6(comparator$17,a)}
    function of_iteri$3(iteri){return of_iteri$1(comparator$17,iteri)}
    function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$17,iteri)}
    function of_increasing_iterator_uncheck$8(len,f)
     {return of_increasing_iterator_uncheck$6(comparator$17,len,f)}
    function of_increasing_sequence$3(seq)
     {return of_increasing_sequence$1(comparator$17,seq)}
    function of_sequence$9(s){return of_sequence$7(comparator$17,s)}
    function of_sequence_or_error$3(s)
     {return of_sequence_or_error$1(comparator$17,s)}
    function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$17,s)}
    function of_sequence_multi$3(s)
     {return of_sequence_multi$1(comparator$17,s)}
    function of_sequence_fold$3(s,init,f)
     {return of_sequence_fold$1(comparator$17,s,init,f)}
    function of_sequence_reduce$3(s,f)
     {return of_sequence_reduce$1(comparator$17,s,f)}
    function map_keys$3(t,f){return map_keys$1(comparator$17,t,f)}
    function map_keys_exn$3(t,f){return map_keys_exn$1(comparator$17,t,f)}
    var
     Base_Map=
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$3,
       comparator_s$0,
       comparator$16,
       empty$8,
       singleton$10,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$7,
       of_sorted_array_unchecked$7,
       of_increasing_iterator_uncheck$7,
       of_increasing_sequence$2,
       of_sequence$8,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$11,
       length$18,
       set$7,
       add$4,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$12,
       find_exn$7,
       remove$4,
       mem$10,
       iter_keys$0,
       iter$18,
       iteri$10,
       iteri_until$0,
       iter2$4,
       map$34,
       mapi$8,
       map_keys$2,
       map_keys_exn$2,
       fold$14,
       fold_until$11,
       fold_right$5,
       fold2$2,
       filter_keys$0,
       filter$9,
       filteri$5,
       filter_map$9,
       filter_mapi$4,
       partition_mapi$0,
       partition_map$1,
       partitioni_tf$1,
       partition_tf$5,
       combine_errors$2,
       compare_direct$1,
       hash_fold_direct$0,
       equal$45,
       keys$0,
       data$0,
       to_alist$0,
       merge$4,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$3,
       fold_symmetric_diff$0,
       min_elt$12,
       min_elt_exn$3,
       max_elt$12,
       max_elt_exn$3,
       for_all$12,
       for_alli$7,
       exists$12,
       existsi$7,
       count$11,
       counti$7,
       split$5,
       append$3,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$6,
       nth_exn$1,
       rank$0,
       to_sequence$4,
       binary_search$5,
       binary_search_segmented$5,
       binary_search_subrange,
       M$0,
       sexp_of_m_t$0,
       m_t_of_sexp$0,
       m_t_sexp_grammar$0,
       compare_m_t$0,
       equal_m_t$0,
       hash_fold_m_t$0,
       [0,
        sexp_of_t$57,
        t_of_sexp_direct$4,
        [0,
         sexp_of_t$58,
         t_of_sexp_direct$3,
         empty$6,
         singleton$8,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$5,
         of_sorted_array_unchecked$5,
         of_increasing_iterator_uncheck$5,
         of_increasing_sequence$0,
         of_sequence$6,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$4,
         invariants$4,
         is_empty$12,
         length$19,
         add$5,
         add_exn$1,
         set$8,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$13,
         find_exn$8,
         remove$5,
         mem$11,
         iter_keys$1,
         iter$19,
         iteri$11,
         iteri_until$1,
         iter2$5,
         map$35,
         mapi$9,
         fold$15,
         fold_until$12,
         fold_right$6,
         fold2$3,
         filter_keys$1,
         filter$10,
         filteri$6,
         filter_map$10,
         filter_mapi$5,
         partition_mapi$1,
         partition_map$2,
         partitioni_tf$2,
         partition_tf$6,
         combine_errors$3,
         compare_direct$2,
         equal$46,
         keys$1,
         data$1,
         to_alist$1,
         merge$5,
         merge_skewed$1,
         symmetric_diff$4,
         fold_symmetric_diff$1,
         min_elt$13,
         min_elt_exn$4,
         max_elt$13,
         max_elt_exn$4,
         for_all$13,
         for_alli$8,
         exists$13,
         existsi$8,
         count$12,
         counti$8,
         split$6,
         append$4,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$7,
         nth_exn$2,
         rank$1,
         to_tree$3,
         to_sequence$5,
         binary_search$6,
         binary_search_segmented$6,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$3,
        is_empty$11,
        length$18,
        add$4,
        add_exn$0,
        set$7,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$12,
        find_exn$7,
        remove$4,
        mem$10,
        iter_keys$0,
        iter$18,
        iteri$10,
        iteri_until$0,
        iter2$4,
        map$34,
        mapi$8,
        fold$14,
        fold_until$11,
        fold_right$5,
        fold2$2,
        filter_keys$0,
        filter$9,
        filteri$5,
        filter_map$9,
        filter_mapi$4,
        partition_mapi$0,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$5,
        combine_errors$2,
        compare_direct$1,
        equal$45,
        keys$0,
        data$0,
        to_alist$0,
        merge$4,
        merge_skewed$0,
        symmetric_diff$3,
        fold_symmetric_diff$0,
        min_elt$12,
        min_elt_exn$3,
        max_elt$12,
        max_elt_exn$3,
        for_all$12,
        for_alli$7,
        exists$12,
        existsi$7,
        count$11,
        counti$7,
        split$5,
        append$3,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$6,
        nth_exn$1,
        rank$0,
        to_tree$2,
        to_sequence$4,
        binary_search$5,
        binary_search_segmented$5,
        binary_search_subrange,
        empty$7,
        singleton$9,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$6,
        of_sorted_array_unchecked$6,
        of_increasing_iterator_uncheck$6,
        of_increasing_sequence$1,
        of_sequence$7,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$5,
        comparator$16,
        hash_fold_direct$0,
        Empty_without_value_restrictio$0],
       [0,
        empty$9,
        singleton$11,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$8,
        of_sorted_array_unchecked$8,
        of_increasing_iterator_uncheck$8,
        of_increasing_sequence$3,
        of_sequence$9,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$7,
        invariants$3,
        is_empty$11,
        length$18,
        add$4,
        add_exn$0,
        set$7,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$12,
        find_exn$7,
        remove$4,
        mem$10,
        iter_keys$0,
        iter$18,
        iteri$10,
        iteri_until$0,
        iter2$4,
        map$34,
        mapi$8,
        fold$14,
        fold_until$11,
        fold_right$5,
        fold2$2,
        filter_keys$0,
        filter$9,
        filteri$5,
        filter_map$9,
        filter_mapi$4,
        partition_mapi$0,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$5,
        combine_errors$2,
        compare_direct$1,
        equal$45,
        keys$0,
        data$0,
        to_alist$0,
        merge$4,
        merge_skewed$0,
        symmetric_diff$3,
        fold_symmetric_diff$0,
        min_elt$12,
        min_elt_exn$3,
        max_elt$12,
        max_elt_exn$3,
        for_all$12,
        for_alli$7,
        exists$12,
        existsi$7,
        count$11,
        counti$7,
        split$5,
        append$3,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$6,
        nth_exn$1,
        rank$0,
        to_tree$2,
        to_sequence$4,
        binary_search$5,
        binary_search_segmented$5,
        binary_search_subrange],
       of_tree$6,
       to_tree$2];
    caml_register_global(1116,Base_Map,"Base__Map");
    var
     create$15=Stdlib_Queue[2],
     clear$2=Stdlib_Queue[11],
     copy$6=Stdlib_Queue[12],
     is_empty$13=Stdlib_Queue[13],
     length$20=Stdlib_Queue[14],
     peek_exn$0=Stdlib_Queue[8],
     dequeue_exn$0=Stdlib_Queue[7],
     push$0=Stdlib_Queue[4],
     transfer=Stdlib_Queue[17];
    function iter$20(t,f){return caml_call2(Stdlib_Queue[15],f,t)}
    function fold$16(t,init,f){return caml_call3(Stdlib_Queue[16],f,init,t)}
    var
     include$69=
      [0,
       create$15,
       clear$2,
       copy$6,
       is_empty$13,
       length$20,
       peek_exn$0,
       dequeue_exn$0,
       push$0,
       transfer,
       iter$20,
       fold$16];
    caml_register_global(1117,include$69,"Base__Linked_queue0");
    function enqueue$0(t,x){return caml_call2(push$0,x,t)}
    function dequeue$0(t)
     {return caml_call1(is_empty$13,t)?0:[0,caml_call1(dequeue_exn$0,t)]}
    function peek$0(t)
     {return caml_call1(is_empty$13,t)?0:[0,caml_call1(peek_exn$0,t)]}
    var
     iter$21=[0,-198771759,iter$20],
     length$21=[0,-198771759,length$20],
     C$1=_a__([0,fold$16,iter$21,length$21,-304398144,-304398144]),
     count$13=C$1[10],
     exists$14=C$1[8],
     find$14=C$1[12],
     find_map$10=C$1[13],
     fold_result$9=C$1[6],
     fold_until$13=C$1[7],
     for_all$14=C$1[9],
     max_elt$14=C$1[17],
     mem$12=C$1[1],
     min_elt$14=C$1[16],
     sum$10=C$1[11],
     to_list$12=C$1[14],
     counti$9=C$1[22],
     existsi$9=C$1[20],
     find_mapi$6=C$1[24],
     findi$6=C$1[23],
     foldi$10=C$1[18],
     for_alli$9=C$1[21],
     iteri$12=C$1[19];
    function transfer$0(src,dst){return caml_call2(transfer,src,dst)}
    function concat_map$3(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {function _pG_(b){return enqueue$0(res,b)}
          return iter$0(caml_call1(f,a),_pG_)});
      return res}
    function concat_mapi$3(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {function _pF_(b){return enqueue$0(res,b)}
          return iter$0(caml_call2(f,i,a),_pF_)});
      return res}
    function filter_map$11(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {var match=caml_call1(f,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue$0(res,b)});
      return res}
    function filter_mapi$6(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {var match=caml_call2(f,i,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue$0(res,b)});
      return res}
    function filter$11(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {var _pE_=caml_call1(f,a);return _pE_?enqueue$0(res,a):_pE_});
      return res}
    function filteri$7(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {var _pD_=caml_call2(f,i,a);return _pD_?enqueue$0(res,a):_pD_});
      return res}
    function map$36(t,f)
     {var res=caml_call1(create$15,0);
      iter$20(t,function(a){return enqueue$0(res,caml_call1(f,a))});
      return res}
    function mapi$10(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,t,function(i,a){return enqueue$0(res,caml_call2(f,i,a))});
      return res}
    function filter_inplace$0(q,f)
     {var q$0=filter$11(q,f);caml_call1(clear$2,q);return transfer$0(q$0,q)}
    function filteri_inplace$0(q,f)
     {var q$0=filteri$7(q,f);caml_call1(clear$2,q);return transfer$0(q$0,q)}
    function enqueue_all$0(t,list)
     {return iter$0(list,function(x){return enqueue$0(t,x)})}
    function of_list$10(list)
     {var t=caml_call1(create$15,0);
      iter$0(list,function(x){return enqueue$0(t,x)});
      return t}
    function of_array$7(array)
     {var t=caml_call1(create$15,0);
      iter(array,function(x){return enqueue$0(t,x)});
      return t}
    function init$8(len,f)
     {var t=caml_call1(create$15,0),_pB_=len - 1 | 0,_pA_=0;
      if(_pB_ >= 0)
       {var i=_pA_;
        for(;;)
         {enqueue$0(t,caml_call1(f,i));
          var _pC_=i + 1 | 0;
          if(_pB_ !== i){var i=_pC_;continue}
          break}}
      return t}
    function to_array$11(t)
     {var len=caml_call1(length$20,t);
      if(0 === len)return [0];
      var arr=caml_make_vect(len,caml_call1(peek_exn$0,t)),i=[0,0];
      iter$20
       (t,
        function(v)
         {var _pz_=i[1];
          caml_check_bound(arr,_pz_)[1 + _pz_] = v;
          return incr(i)});
      return arr}
    function t_of_sexp$32(a_of_sexp,sexp)
     {return of_list$10(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function sexp_of_t$59(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,caml_call1(to_list$12,t))}
    function t_sexp_grammar$31(grammar)
     {var _py_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_py_)}
    function singleton$12(a)
     {var t=caml_call1(create$15,0);enqueue$0(t,a);return t}
    var
     Base_Linked_queue=
      [0,
       t_of_sexp$32,
       sexp_of_t$59,
       t_sexp_grammar$31,
       mem$12,
       length$20,
       is_empty$13,
       iter$20,
       fold$16,
       fold_result$9,
       fold_until$13,
       exists$14,
       for_all$14,
       count$13,
       sum$10,
       find$14,
       find_map$10,
       to_list$12,
       to_array$11,
       min_elt$14,
       max_elt$14,
       foldi$10,
       iteri$12,
       existsi$9,
       for_alli$9,
       counti$9,
       findi$6,
       find_mapi$6,
       singleton$12,
       of_list$10,
       of_array$7,
       init$8,
       enqueue$0,
       enqueue_all$0,
       dequeue$0,
       dequeue_exn$0,
       peek$0,
       peek_exn$0,
       clear$2,
       copy$6,
       map$36,
       mapi$10,
       concat_map$3,
       concat_mapi$3,
       filter_map$11,
       filter_mapi$6,
       filter$11,
       filteri$7,
       filter_inplace$0,
       filteri_inplace$0,
       create$15,
       transfer$0];
    caml_register_global(1118,Base_Linked_queue,"Base__Linked_queue");
    function func$10(x){return caml_call1(func$0,x)}
    var hashable$7=[0,func$10,Stdlib_Int64[15],sexp_of_t$7];
    function compare$60(_px_,_pw_){return caml_int64_compare(_px_,_pw_)}
    var
     to_string$18=Stdlib_Int64[14],
     of_string$17=caml_int64_of_string,
     include$70=_P_([0,compare$60,sexp_of_t$7]),
     _fv_=include$70[1],
     float_lower_bound$1=lower_bound_for_int(64),
     float_upper_bound$1=upper_bound_for_int(64),
     float_of_bits=caml_int64_float_of_bits,
     bits_of_float=caml_int64_bits_of_float,
     shift_right_logical$0=caml_int64_shift_right_unsigne,
     shift_right$1=caml_int64_shift_right,
     shift_left$0=caml_int64_shift_left,
     lnot$2=Stdlib_Int64[11],
     bit_xor$0=caml_int64_xor,
     bit_or$0=caml_int64_or,
     bit_and$0=caml_int64_and,
     min_value$4=Stdlib_Int64[10],
     max_value$4=Stdlib_Int64[9],
     abs$4=Stdlib_Int64[8],
     pred$3=Stdlib_Int64[7],
     succ$4=Stdlib_Int64[6],
     pow$1=Private$3[2],
     rem$1=caml_int64_mod,
     neg$3=caml_int64_neg,
     minus_one$1=Stdlib_Int64[3],
     one$1=Stdlib_Int64[2],
     zero$3=Stdlib_Int64[1],
     to_float$2=caml_int64_to_float,
     of_float_unchecked$1=caml_int64_of_float,
     num_bits$2=64;
    function of_float$1(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$1)
        &&
        caml_call2(include$7[2],f,float_upper_bound$1))
       return caml_int64_of_float(f);
      return caml_call2(invalid_argf(_fw_),f + 0.,0)}
    function symbol$192(b,e){return caml_call2(pow$1,b,e)}
    function bswap16(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),48)}
    function bswap32(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),32)}
    function bswap48(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),16)}
    var
     include$71=_aY_([0,compare$60,sexp_of_t$7,zero$3]),
     is_positive$1=include$71[1],
     is_non_negative$1=include$71[2],
     is_negative$1=include$71[3],
     is_non_positive$1=include$71[4],
     sign$1=include$71[5];
    function invariant$19(param){return 0}
    function between$12(t,low,high)
     {var _pu_=caml_lessequal(low,t),_pv_=_pu_?caml_lessequal(t,high):_pu_;
      return _pv_}
    function clamp_unchecked$4(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$12(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$4(t,min,max);
      throw [0,Assert_failure$0,_fx_]}
    function clamp$12(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$4(t,min,max)];
      var _pt_=[0,[0,cst_max$5,caml_call1(sexp_of_t$7,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$5,
                 [0,[0,cst_min$5,caml_call1(sexp_of_t$7,min)],_pt_]))}
    function incr$2(r){r[1] = caml_int64_add(r[1],one$1);return 0}
    function decr$2(r){r[1] = caml_int64_sub(r[1],one$1);return 0}
    function of_int64_exn(_ps_){return _ps_}
    function to_int64(t){return t}
    var of_int_exn$0=caml_int64_of_int32,of_int32_exn=caml_int64_of_int32;
    function non_positive_argument$1(param)
     {return caml_call1(invalid_argf(_fy_),0)}
    function ceil_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var
       x$0=caml_call1(Stdlib_Int64[7],x),
       x$1=caml_int64_or(x$0,caml_int64_shift_right_unsigne(x$0,1)),
       x$2=caml_int64_or(x$1,caml_int64_shift_right_unsigne(x$1,2)),
       x$3=caml_int64_or(x$2,caml_int64_shift_right_unsigne(x$2,4)),
       x$4=caml_int64_or(x$3,caml_int64_shift_right_unsigne(x$3,8)),
       x$5=caml_int64_or(x$4,caml_int64_shift_right_unsigne(x$4,16)),
       x$6=caml_int64_or(x$5,caml_int64_shift_right_unsigne(x$5,32));
      return caml_call1(Stdlib_Int64[6],x$6)}
    function floor_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var
       x$0=caml_int64_or(x,caml_int64_shift_right_unsigne(x,1)),
       x$1=caml_int64_or(x$0,caml_int64_shift_right_unsigne(x$0,2)),
       x$2=caml_int64_or(x$1,caml_int64_shift_right_unsigne(x$1,4)),
       x$3=caml_int64_or(x$2,caml_int64_shift_right_unsigne(x$2,8)),
       x$4=caml_int64_or(x$3,caml_int64_shift_right_unsigne(x$3,16)),
       x$5=caml_int64_or(x$4,caml_int64_shift_right_unsigne(x$4,32));
      return caml_int64_sub(x$5,caml_int64_shift_right_unsigne(x$5,1))}
    function is_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var _pr_=Stdlib_Int64[1];
      return caml_equal(caml_int64_and(x,caml_call1(Stdlib_Int64[7],x)),_pr_)}
    function floor_log2$1(i)
     {if(caml_lessequal(i,Stdlib_Int64[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int64_floor_log2_got_inval,
           [0,[0,cst$32,caml_call1(sexp_of_t$7,i)],0]));
      return 63 - runtime.Base_int_math_int64_clz(i) | 0}
    function ceil_log2$1(i)
     {if(caml_lessequal(i,Stdlib_Int64[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int64_ceil_log2_got_invali,
           [0,[0,cst$33,caml_call1(sexp_of_t$7,i)],0]));
      return caml_call2(Stdlib_Int64[17],i,Stdlib_Int64[2])
              ?0
              :64
               -
               runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7],i))
               |
               0}
    var
     include$72=_cH_([0,to_string$18]),
     to_string_hum$3=include$72[1],
     sexp_of_int64=include$72[2];
    function hash$20(x){return caml_call1(func$0,x)}
    var symbol$193=caml_lessthan;
    function to_string$19(i){return caml_call2(sprintf,_fz_,i)}
    function of_string$18(s)
     {function _pp_(_pq_){return _pq_}
      return caml_call3(Stdlib_Scanf[4],s,_fA_,_pp_)}
    var
     include$73=
      _cG_
       ([0,
         compare$12,
         hash_fold_t$1,
         hash$20,
         to_string$19,
         of_string$18,
         zero$3,
         symbol$193,
         neg$3,
         module_name$13]),
     Hex$1=include$73[1],
     pp$15=_w_([0,module_name$14,to_string$18])[1],
     include$74=
      _c2_
       ([0,
         of_float$1,
         to_float$2,
         of_string$17,
         to_string$18,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         caml_int64_div,
         caml_int64_neg,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         abs$4,
         caml_int64_neg,
         zero$3,
         of_int_exn$0,
         rem$1]),
     symbol$194=include$74[1],
     symbol$195=include$74[2],
     symbol$196=include$74[3],
     round$1=include$74[4],
     round_towards_zero$1=include$74[5],
     round_down$1=include$74[6],
     round_up$1=include$74[7],
     round_nearest$1=include$74[8],
     ascending$26=include$2[1],
     descending$26=include$2[2],
     max$32=include$2[3],
     min$32=include$2[4],
     _fB_=[0,symbol$192,lnot$2,abs$4,zero$3,symbol$194,symbol$195,symbol$196];
    function _fC_(_po_){return runtime.Base_int_math_int64_ctz(_po_)}
    function _fD_(_pn_){return runtime.Base_int_math_int64_clz(_pn_)}
    function compare_int64$0(_pm_,_pl_){return caml_int64_compare(_pm_,_pl_)}
    var
     equal_int64$1=caml_equal,
     Base_Int64=
      [0,
       t_sexp_grammar$6,
       of_float$1,
       to_float$2,
       of_int_exn$0,
       int64_to_int_exn,
       hash_fold_t$1,
       func$10,
       t_of_sexp$7,
       sexp_of_int64,
       of_string$17,
       to_string$18,
       equal_int64$1,
       compare_int64$0,
       min$32,
       max$32,
       ascending$26,
       descending$26,
       between$12,
       clamp_exn$12,
       clamp$12,
       _fv_,
       pp$15,
       hashable$7,
       is_positive$1,
       is_non_negative$1,
       is_negative$1,
       is_non_positive$1,
       sign$1,
       invariant$19,
       Hex$1,
       to_string_hum$3,
       one$1,
       minus_one$1,
       rem$1,
       round$1,
       round_towards_zero$1,
       round_down$1,
       round_up$1,
       round_nearest$1,
       succ$4,
       pred$3,
       pow$1,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       lnot$2,
       int64_popcount,
       shift_left$0,
       shift_right$1,
       decr$2,
       incr$2,
       of_int32_exn,
       int64_to_int32_exn,
       of_int64_exn,
       to_int64,
       nativeint_to_int64,
       to_nativeint_exn,
       of_float_unchecked$1,
       num_bits$2,
       max_value$4,
       min_value$4,
       shift_right_logical$0,
       ceil_pow2$1,
       floor_pow2$1,
       ceil_log2$1,
       floor_log2$1,
       is_pow2$1,
       _fD_,
       _fC_,
       _fB_,
       symbol$192,
       lnot$2,
       abs$4,
       zero$3,
       symbol$194,
       symbol$195,
       symbol$196,
       int64_to_int,
       int64_to_int32,
       nativeint_to_int64,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
    caml_register_global(1119,Base_Int64,"Base__Int64");
    var
     include$75=_P_([0,compare$12,sexp_of_t$7]),
     comparator$18=include$75[1];
    function wrap_exn(x)
     {int64_fit_on_int63_exn(x);return caml_int64_mul(x,_fE_)}
    function wrap_modulo(x){return caml_int64_mul(x,_fG_)}
    function unwrap(x){return caml_int64_shift_right(x,1)}
    function m(x){return caml_int64_and(x,mask$0)}
    function invariant$20(t)
     {if(caml_equal(m(t),t))return 0;throw [0,Assert_failure$0,_fI_]}
    function symbol$197(x,y){return caml_int64_add(x,y)}
    function symbol$198(x,y){return caml_int64_sub(x,y)}
    function neg$4(x){return caml_int64_neg(x)}
    function abs$5(x){return caml_call1(Stdlib_Int64[8],x)}
    var one$2=wrap_exn(_fJ_);
    function succ$5(a){return caml_int64_add(a,one$2)}
    function pred$4(a){return caml_int64_sub(a,one$2)}
    var min_value$5=m(Stdlib_Int64[10]),max_value$5=m(Stdlib_Int64[9]);
    function lnot$3(x){return m(caml_call1(Stdlib_Int64[11],x))}
    var land$1=caml_int64_and,lxor$1=caml_int64_xor,lor$1=caml_int64_or;
    function lsl$1(x,i){return caml_int64_shift_left(x,i)}
    function asr$1(x,i){return m(caml_int64_shift_right(x,i))}
    function lsr$1(x,i){return m(caml_int64_shift_right_unsigne(x,i))}
    var _fK_=Private$3[3];
    function pow$2(a,b)
     {return caml_int64_mul
              (caml_call2
                (_fK_,caml_int64_shift_right(a,1),caml_int64_shift_right(b,1)),
               _fH_)}
    function symbol$199(a,b)
     {return caml_int64_mul(a,caml_int64_shift_right(b,1))}
    function symbol$200(a,b){return wrap_modulo(caml_int64_div(a,b))}
    function rem$2(a,b){return caml_int64_mod(a,b)}
    function popcount$1(x){return int64_popcount(x)}
    function to_int64$0(t){return caml_int64_shift_right(t,1)}
    function of_int64(t)
     {return int64_is_representable_as_int6(t)?[0,caml_int64_mul(t,_fF_)]:0}
    function of_int64_exn$0(t){return wrap_exn(t)}
    function of_int64_trunc(t){return wrap_modulo(t)}
    function t_of_sexp$33(x){return wrap_exn(caml_call1(t_of_sexp$7,x))}
    function sexp_of_t$60(x)
     {return caml_call1(sexp_of_t$7,caml_int64_shift_right(x,1))}
    function compare$61(x,y){return caml_call2(compare$12,x,y)}
    function is_pow2$2(x){return is_pow2$1(caml_int64_shift_right(x,1))}
    function clz$0(x){return runtime.Base_int_math_int64_clz(x)}
    function ctz$0(x)
     {return runtime.Base_int_math_int64_ctz(caml_int64_shift_right(x,1))}
    function floor_pow2$2(x)
     {return wrap_exn(floor_pow2$1(caml_int64_shift_right(x,1)))}
    function ceil_pow2$2(x)
     {return wrap_exn(floor_pow2$1(caml_int64_shift_right(x,1)))}
    function floor_log2$2(x){return floor_log2$1(caml_int64_shift_right(x,1))}
    function ceil_log2$2(x){return ceil_log2$1(caml_int64_shift_right(x,1))}
    function func$11(x){return caml_call1(Stdlib_MoreLabels[1][28],x)}
    var hashable$8=[0,func$11,compare$61,sexp_of_t$60];
    function invalid_str(x){return caml_call2(failwithf(_fL_),x,0)}
    function sign_and_signedness(x)
     {var len=caml_ml_string_length(x);
      if(0 < len)
       {var match=caml_string_get(x,0),switcher=match - 43 | 0,switch$0=0;
        if(2 < switcher >>> 0)
         switch$0 = 1;
        else
         switch(switcher)
          {case 0:var sign=4003188,pos=1;break;
           case 1:switch$0 = 1;break;
           default:var sign=3901488,pos=1}
        if(switch$0)var sign=4003188,pos=0}
      else
       var sign=4003188,pos=0;
      if((pos + 2 | 0) >= len)return [0,sign,1];
      var c1=caml_string_get(x,pos),c2=caml_string_get(x,pos + 1 | 0);
      return 48 === c1?9 < c2 - 48 >>> 0?[0,sign,0]:[0,sign,1]:[0,sign,1]}
    function to_string$20(x)
     {return caml_call1(Stdlib_Int64[14],caml_int64_shift_right(x,1))}
    function of_string$19(str)
     {try
       {var match=sign_and_signedness(str),signedness=match[2],sign=match[1];
        if(signedness)
         var _pj_=of_int64_exn$0(caml_int64_of_string(str));
        else
         {var
           pos_str=
            4003188 <= sign
             ?str
             :sub$8(str,1,caml_ml_string_length(str) - 1 | 0),
           int64=caml_int64_of_string(pos_str);
          if(caml_lessthan(int64,_fM_))invalid_str(str);
          var
           int63=wrap_modulo(int64),
           int63$0=4003188 <= sign?int63:caml_int64_neg(int63),
           _pj_=int63$0}
        return _pj_}
      catch(_pk_){return invalid_str(str)}}
    function bswap16$0(t)
     {return wrap_modulo(bswap16(caml_int64_shift_right(t,1)))}
    function bswap32$0(t)
     {return wrap_modulo(bswap32(caml_int64_shift_right(t,1)))}
    function bswap48$0(t)
     {return wrap_modulo(bswap48(caml_int64_shift_right(t,1)))}
    var
     float_lower_bound$2=lower_bound_for_int(63),
     float_upper_bound$2=upper_bound_for_int(63),
     minus_one$2=wrap_exn(Stdlib_Int64[3]),
     one$3=wrap_exn(Stdlib_Int64[2]),
     zero$4=wrap_exn(Stdlib_Int64[1]),
     num_bits$3=63;
    function to_float$3(x)
     {return caml_int64_to_float(caml_int64_shift_right(x,1))}
    function of_float_unchecked$2(x)
     {return wrap_modulo(caml_int64_of_float(x))}
    function of_float$2(t)
     {if
       (caml_call2(include$7[6],t,float_lower_bound$2)
        &&
        caml_call2(include$7[2],t,float_upper_bound$2))
       return wrap_modulo(caml_int64_of_float(t));
      return caml_call2(invalid_argf(_fN_),t + 0.,0)}
    var
     _fO_=_aY_([0,compare$61,sexp_of_t$60,zero$4]),
     is_positive$2=_fO_[1],
     is_non_negative$2=_fO_[2],
     is_negative$2=_fO_[3],
     is_non_positive$2=_fO_[4],
     sign$2=_fO_[5];
    function between$13(t,low,high)
     {var _ph_=caml_lessequal(low,t),_pi_=_ph_?caml_lessequal(t,high):_ph_;
      return _pi_}
    function clamp_unchecked$5(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$13(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$5(t,min,max);
      throw [0,Assert_failure$0,_fP_]}
    function clamp$13(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$5(t,min,max)];
      var _pg_=[0,[0,cst_max$6,sexp_of_t$60(max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$6,
                 [0,[0,cst_min$6,sexp_of_t$60(min)],_pg_]))}
    function symbol$201(b,e){return pow$2(b,e)}
    function incr$3(r){r[1] = caml_int64_add(r[1],one$3);return 0}
    function decr$3(r){r[1] = caml_int64_sub(r[1],one$3);return 0}
    function of_int$5(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_int_exn$1(x){return of_int$5(x)}
    function to_int$4(x){return int64_to_int(caml_int64_shift_right(x,1))}
    function to_int_exn$1(x)
     {return int64_to_int_exn(caml_int64_shift_right(x,1))}
    function to_int_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    function of_int32(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_int32_exn$0(x){return of_int32(x)}
    function to_int32(x){return int64_to_int32(caml_int64_shift_right(x,1))}
    function to_int32_exn(x)
     {return int64_to_int32_exn(caml_int64_shift_right(x,1))}
    function to_int32_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    function of_nativeint$0(x){return of_int64(caml_int64_of_int32(x))}
    function of_nativeint_exn(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_nativeint_trunc(x)
     {return of_int64_trunc(caml_int64_of_int32(x))}
    function to_nativeint$1(x)
     {return to_nativeint(caml_int64_shift_right(x,1))}
    function to_nativeint_exn$0(x)
     {return to_nativeint_exn(caml_int64_shift_right(x,1))}
    function to_nativeint_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    var
     include$76=_cH_([0,to_string$20]),
     to_string_hum$4=include$76[1],
     sexp_of_t$61=include$76[2];
    function hash$21(x){return func$11(x)}
    var symbol$202=caml_lessthan;
    function to_string$21(i)
     {return caml_call2(sprintf,_fQ_,caml_int64_shift_right_unsigne(i,1))}
    function of_string$20(s)
     {return of_string$19(caml_call2(symbol$59,cst_0x$1,s))}
    var
     include$77=
      _cG_
       ([0,
         compare$61,
         hash_fold_t$1,
         hash$21,
         to_string$21,
         of_string$20,
         zero$4,
         symbol$202,
         neg$4,
         module_name$15]),
     Hex$2=include$77[1];
    function to_string$22(x){return to_string$20(x)}
    var
     pp$16=_w_([0,module_name$16,to_string$22])[1],
     symbol$203=caml_notequal,
     symbol$204=caml_lessthan,
     symbol$205=caml_greaterthan,
     symbol$206=caml_equal,
     symbol$207=caml_lessequal,
     symbol$208=caml_greaterequal,
     include$78=
      _c2_
       ([0,
         of_float$2,
         to_float$3,
         of_string$19,
         to_string$20,
         symbol$197,
         symbol$198,
         symbol$199,
         symbol$200,
         neg$4,
         symbol$208,
         symbol$207,
         symbol$206,
         symbol$205,
         symbol$204,
         symbol$203,
         abs$5,
         neg$4,
         zero$4,
         of_int_exn$1,
         rem$2]),
     symbol$209=include$78[1],
     symbol$210=include$78[2],
     symbol$211=include$78[3],
     round$2=include$78[4],
     round_towards_zero$2=include$78[5],
     round_down$2=include$78[6],
     round_up$2=include$78[7],
     round_nearest$2=include$78[8],
     Repr$0=[0],
     ascending$27=include$2[1],
     descending$27=include$2[2],
     max$33=include$2[3],
     min$33=include$2[4],
     _fS_=
      [0,
       symbol$197,
       symbol$198,
       symbol$199,
       symbol$200,
       neg$4,
       symbol$201,
       symbol$208,
       symbol$207,
       symbol$206,
       symbol$205,
       symbol$204,
       symbol$203,
       abs$5,
       neg$4,
       zero$4,
       symbol$209,
       symbol$210,
       symbol$211,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       lsl$1,
       asr$1,
       lsr$1],
     repr=1,
     _fR_=[0,wrap_exn,unwrap];
    function _fT_(_pf_,_pe_){return caml_int64_compare(_pf_,_pe_)}
    var
     _fU_=caml_equal,
     _fV_=caml_notequal,
     _fW_=caml_lessthan,
     _fX_=caml_greaterthan,
     _fY_=caml_equal,
     _fZ_=caml_lessequal,
     _f0_=caml_greaterequal,
     Base_Int63_emul=
      [0,
       t_sexp_grammar$6,
       of_float$2,
       to_float$3,
       of_int_exn$1,
       to_int_exn$1,
       hash_fold_t$1,
       func$11,
       t_of_sexp$33,
       sexp_of_t$61,
       of_string$19,
       to_string$20,
       _f0_,
       _fZ_,
       _fY_,
       _fX_,
       _fW_,
       _fV_,
       _fU_,
       _fT_,
       min$33,
       max$33,
       ascending$27,
       descending$27,
       between$13,
       clamp_exn$13,
       clamp$13,
       comparator$18,
       pp$16,
       hashable$8,
       is_positive$2,
       is_non_negative$2,
       is_negative$2,
       is_non_positive$2,
       sign$2,
       invariant$20,
       Hex$2,
       to_string_hum$4,
       zero$4,
       one$3,
       minus_one$2,
       symbol$197,
       symbol$198,
       symbol$199,
       symbol$201,
       neg$4,
       neg$4,
       symbol$210,
       symbol$209,
       symbol$200,
       rem$2,
       symbol$211,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       lsl$1,
       asr$1,
       round$2,
       round_towards_zero$2,
       round_down$2,
       round_up$2,
       round_nearest$2,
       abs$5,
       succ$5,
       pred$4,
       pow$2,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       popcount$1,
       lsl$1,
       asr$1,
       decr$3,
       incr$3,
       of_int32_exn$0,
       to_int32_exn,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn,
       to_nativeint_exn$0,
       of_float_unchecked$2,
       num_bits$3,
       max_value$5,
       min_value$5,
       lsr$1,
       lsr$1,
       ceil_pow2$2,
       floor_pow2$2,
       ceil_log2$2,
       floor_log2$2,
       is_pow2$2,
       clz$0,
       ctz$0,
       _fS_,
       of_int$5,
       to_int$4,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint$0,
       to_nativeint$1,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16$0,
       bswap32$0,
       bswap48$0,
       _fR_,
       Repr$0,
       repr];
    caml_register_global(1120,Base_Int63_emul,"Base__Int63_emul");
    function hash$22(x){return caml_call1(func$4,x)}
    var hashable$9=[0,hash$22,compare$8,sexp_of_t$1];
    function of_string$21(s)
     {return caml_string_notequal(s,cst_false)
              ?caml_string_notequal(s,cst_true)
                ?caml_call2(invalid_argf(_f1_),s,0)
                :1
              :0}
    var
     to_string$23=Caml$0[29],
     include$79=_P_([0,compare$8,sexp_of_t$1]),
     comparator$19=include$79[1],
     include$80=_w_([0,module_name$17,to_string$23]),
     pp$17=include$80[1];
    function invariant$21(param){return 0}
    function between$14(t,low,high)
     {var _pd_=caml_call2(include$4[2],low,t);
      return _pd_?caml_call2(include$4[2],t,high):_pd_}
    function clamp_unchecked$6(t,min,max)
     {return caml_call2(include$4[1],t,min)
              ?min
              :caml_call2(include$4[2],t,max)?t:max}
    function clamp_exn$14(t,min,max)
     {if(caml_call2(include$4[2],min,max))return clamp_unchecked$6(t,min,max);
      throw [0,Assert_failure$0,_f2_]}
    function clamp$14(t,min,max)
     {if(! caml_call2(include$4[5],min,max))
       return [0,clamp_unchecked$6(t,min,max)];
      var _pc_=[0,[0,cst_max$7,caml_call1(sexp_of_t$1,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$7,
                 [0,[0,cst_min$7,caml_call1(sexp_of_t$1,min)],_pc_]))}
    function to_int$5(x){return x}
    function symbol$212(a,b){return a | b}
    function symbol$213(a,b){return a & b}
    var
     symbol$214=include$4[1],
     symbol$215=include$4[2],
     symbol$216=include$4[3],
     symbol$217=include$4[4],
     symbol$218=include$4[5],
     symbol$219=include$4[6],
     ascending$28=include$4[7],
     descending$28=include$4[8],
     compare_bool$0=include$4[9],
     equal_bool$1=include$4[10],
     max$34=include$4[11],
     min$34=include$4[12],
     Base_Bool=
      [0,
       all$20,
       t_sexp_grammar$0,
       hash_fold_t$5,
       hash$22,
       t_of_sexp$1,
       sexp_of_t$1,
       of_string$21,
       to_string$23,
       symbol$219,
       symbol$215,
       symbol$217,
       symbol$218,
       symbol$214,
       symbol$216,
       equal_bool$1,
       compare_bool$0,
       min$34,
       max$34,
       ascending$28,
       descending$28,
       between$14,
       clamp_exn$14,
       clamp$14,
       comparator$19,
       pp$17,
       hashable$9,
       invariant$21,
       to_int$5,
       [0,symbol$213,symbol$212]];
    caml_register_global(1121,Base_Bool,"Base__Bool");
    function func$12(x){return caml_call1(func$1,x)}
    var hashable$10=[0,func$12,Stdlib_Int32[15],sexp_of_t$6];
    function compare_int32$0(x,y){return caml_call2(Stdlib_Int32[15],x,y)}
    var
     to_string$24=Stdlib_Int32[14],
     of_string$22=caml_int_of_string,
     include$81=_P_([0,compare_int32$0,sexp_of_t$6]),
     _f3_=include$81[1],
     float_lower_bound$3=lower_bound_for_int(32),
     float_upper_bound$3=upper_bound_for_int(32),
     float_of_bits$0=runtime.caml_int32_float_of_bits,
     bits_of_float$0=runtime.caml_int32_bits_of_float,
     num_bits$4=32;
    function lsr$2(_pb_,_pa_){return _pb_ >>> _pa_ | 0}
    function asr$2(_o$_,_o__){return _o$_ >> _o__}
    function lsl$2(_o9_,_o8_){return _o9_ << _o8_}
    var lnot$4=Stdlib_Int32[11];
    function lxor$2(_o7_,_o6_){return _o7_ ^ _o6_}
    function lor$2(_o5_,_o4_){return _o5_ | _o4_}
    function land$2(_o3_,_o2_){return _o3_ & _o2_}
    var
     min_value$6=Stdlib_Int32[10],
     max_value$6=Stdlib_Int32[9],
     abs$6=Stdlib_Int32[8],
     pred$5=Stdlib_Int32[7],
     succ$6=Stdlib_Int32[6],
     rem$3=caml_mod;
    function neg$5(_o1_){return - _o1_ | 0}
    var
     minus_one$3=Stdlib_Int32[3],
     one$4=Stdlib_Int32[2],
     zero$5=Stdlib_Int32[1];
    function to_float$4(_o0_){return _o0_}
    function of_float_unchecked$3(_oZ_){return _oZ_ | 0}
    function of_float$3(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$3)
        &&
        caml_call2(include$7[2],f,float_upper_bound$3))
       return f | 0;
      return caml_call2(invalid_argf(_f4_),f + 0.,0)}
    var
     include$82=_aY_([0,compare_int32$0,sexp_of_t$6,zero$5]),
     is_positive$3=include$82[1],
     is_non_negative$3=include$82[2],
     is_negative$3=include$82[3],
     is_non_positive$3=include$82[4],
     sign$3=include$82[5];
    function symbol$220(x,y){return caml_greaterequal(x,y)}
    function symbol$221(x,y){return caml_lessequal(x,y)}
    function symbol$222(x,y){return caml_equal(x,y)}
    function symbol$223(x,y){return caml_greaterthan(x,y)}
    function symbol$224(x,y){return caml_lessthan(x,y)}
    function symbol$225(x,y){return caml_notequal(x,y)}
    function descending$29(x,y){return compare_int32$0(y,x)}
    function min$35(x,y){return caml_lessthan(x,y)?x:y}
    function max$35(x,y){return caml_greaterthan(x,y)?x:y}
    var equal_int32$1=caml_equal;
    function between$15(t,low,high)
     {var _oY_=caml_lessequal(low,t);return _oY_?caml_lessequal(t,high):_oY_}
    function clamp_unchecked$7(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$15(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$7(t,min,max);
      throw [0,Assert_failure$0,_f5_]}
    function clamp$15(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$7(t,min,max)];
      var _oX_=[0,[0,cst_max$8,caml_call1(sexp_of_t$6,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$8,
                 [0,[0,cst_min$8,caml_call1(sexp_of_t$6,min)],_oX_]))}
    function invariant$22(param){return 0}
    var symbol$226=caml_div,symbol$227=caml_mul;
    function symbol$228(_oW_,_oV_){return _oW_ - _oV_ | 0}
    function symbol$229(_oU_,_oT_){return _oU_ + _oT_ | 0}
    function incr$4(r){r[1] = r[1] + one$4 | 0;return 0}
    function decr$4(r){r[1] = r[1] - one$4 | 0;return 0}
    function of_int32$0(t){return t}
    function to_int32$0(t){return t}
    function pow$3(b,e)
     {var _oR_=int32_to_int_exn(e),_oS_=int32_to_int_exn(b);
      return int_to_int32_exn(caml_call2(Private$3[1],_oS_,_oR_))}
    function symbol$230(b,e){return pow$3(b,e)}
    function bswap16$1(x){return caml_int32_bswap(x) >>> 16 | 0}
    function non_positive_argument$2(param)
     {return caml_call1(invalid_argf(_f6_),0)}
    function ceil_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var
       x$0=caml_call1(Stdlib_Int32[7],x),
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0;
      return caml_call1(Stdlib_Int32[6],x$5)}
    function floor_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0;
      return x$4 - (x$4 >>> 1 | 0) | 0}
    function is_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var _oP_=Stdlib_Int32[1],_oQ_=x & caml_call1(Stdlib_Int32[7],x);
      return caml_call2(Int32_replace_polymorphic_comp[4],_oQ_,_oP_)}
    function floor_log2$3(i)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],i,Stdlib_Int32[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int32_floor_log2_got_inval,
           [0,[0,cst$34,caml_call1(sexp_of_t$6,i)],0]));
      return 31 - runtime.Base_int_math_int32_clz(i) | 0}
    function ceil_log2$3(i)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],i,Stdlib_Int32[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int32_ceil_log2_got_invali,
           [0,[0,cst$35,caml_call1(sexp_of_t$6,i)],0]));
      return caml_call2(Stdlib_Int32[17],i,Stdlib_Int32[2])
              ?0
              :32
               -
               runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7],i))
               |
               0}
    var
     include$83=_cH_([0,to_string$24]),
     to_string_hum$5=include$83[1],
     sexp_of_int32=include$83[2];
    function hash$23(x){return caml_call1(func$1,x)}
    function to_string$25(i){return caml_call2(sprintf,_f7_,i)}
    function of_string$23(s)
     {function _oN_(_oO_){return _oO_}
      return caml_call3(Stdlib_Scanf[4],s,_f8_,_oN_)}
    var
     include$84=
      _cG_
       ([0,
         compare$11,
         hash_fold_t$2,
         hash$23,
         to_string$25,
         of_string$23,
         zero$5,
         symbol$224,
         neg$5,
         module_name$18]),
     Hex$3=include$84[1],
     pp$18=_w_([0,module_name$19,to_string$24])[1],
     include$85=
      _c2_
       ([0,
         of_float$3,
         to_float$4,
         of_string$22,
         to_string$24,
         symbol$229,
         symbol$228,
         symbol$227,
         symbol$226,
         neg$5,
         symbol$220,
         symbol$221,
         symbol$222,
         symbol$223,
         symbol$224,
         symbol$225,
         abs$6,
         neg$5,
         zero$5,
         int_to_int32_exn,
         rem$3]),
     symbol$231=include$85[1],
     symbol$232=include$85[2],
     symbol$233=include$85[3],
     round$3=include$85[4],
     round_towards_zero$3=include$85[5],
     round_down$3=include$85[6],
     round_up$3=include$85[7],
     round_nearest$3=include$85[8],
     _f9_=caml_int32_bswap,
     _f__=
      [0,
       symbol$229,
       symbol$228,
       symbol$227,
       symbol$226,
       neg$5,
       symbol$230,
       symbol$220,
       symbol$221,
       symbol$222,
       symbol$223,
       symbol$224,
       symbol$225,
       abs$6,
       neg$5,
       zero$5,
       symbol$231,
       symbol$232,
       symbol$233,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       lsl$2,
       asr$2,
       lsr$2];
    function _f$_(_oM_){return runtime.Base_int_math_int32_ctz(_oM_)}
    var
     Base_Int32=
      [0,
       t_sexp_grammar$5,
       of_float$3,
       to_float$4,
       int_to_int32_exn,
       int32_to_int_exn,
       hash_fold_t$2,
       func$12,
       t_of_sexp$6,
       sexp_of_int32,
       of_string$22,
       to_string$24,
       symbol$220,
       symbol$221,
       symbol$222,
       symbol$223,
       symbol$224,
       symbol$225,
       equal_int32$1,
       compare_int32$0,
       min$35,
       max$35,
       compare_int32$0,
       descending$29,
       between$15,
       clamp_exn$15,
       clamp$15,
       _f3_,
       pp$18,
       hashable$10,
       is_positive$3,
       is_non_negative$3,
       is_negative$3,
       is_non_positive$3,
       sign$3,
       invariant$22,
       Hex$3,
       to_string_hum$5,
       zero$5,
       one$4,
       minus_one$3,
       symbol$229,
       symbol$228,
       symbol$227,
       symbol$230,
       neg$5,
       neg$5,
       symbol$232,
       symbol$231,
       symbol$226,
       rem$3,
       symbol$233,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       lsl$2,
       asr$2,
       round$3,
       round_towards_zero$3,
       round_down$3,
       round_up$3,
       round_nearest$3,
       abs$6,
       succ$6,
       pred$5,
       pow$3,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       int32_popcount,
       lsl$2,
       asr$2,
       decr$4,
       incr$4,
       of_int32$0,
       to_int32$0,
       int64_to_int32_exn,
       int32_to_int64,
       nativeint_to_int32_exn,
       int32_to_nativeint,
       of_float_unchecked$3,
       num_bits$4,
       max_value$6,
       min_value$6,
       lsr$2,
       lsr$2,
       ceil_pow2$3,
       floor_pow2$3,
       ceil_log2$3,
       floor_log2$3,
       is_pow2$3,
       function(_oL_){return runtime.Base_int_math_int32_clz(_oL_)},
       _f$_,
       _f__,
       int_to_int32,
       int32_to_int,
       of_int32$0,
       to_int32$0,
       nativeint_to_int32,
       int32_to_nativeint,
       int64_to_int32,
       int_to_int32_trunc,
       int32_to_int_trunc,
       nativeint_to_int32_trunc,
       int64_to_int32_trunc,
       bits_of_float$0,
       float_of_bits$0,
       bswap16$1,
       _f9_];
    caml_register_global(1122,Base_Int32,"Base__Int32");
    var repr$0=word_size?0:1;
    function to_int$6(x){return [0,x]}
    function to_int_trunc$0(x){return x}
    function to_nativeint_trunc$0(x){return x}
    function to_nativeint$2(x){return [0,x]}
    var repr$1=0;
    function bswap32$1(t)
     {return caml_int64_to_int32(bswap32(caml_int64_of_int32(t)))}
    function bswap48$1(t)
     {return caml_int64_to_int32(bswap48(caml_int64_of_int32(t)))}
    if(repr$0)
     var
      impl=
       [0,
        t_sexp_grammar$6,
        of_float$2,
        to_float$3,
        of_int_exn$1,
        to_int_exn$1,
        hash_fold_t$1,
        func$11,
        t_of_sexp$33,
        sexp_of_t$61,
        of_string$19,
        to_string$20,
        _f0_,
        _fZ_,
        _fY_,
        _fX_,
        _fW_,
        _fV_,
        _fU_,
        _fT_,
        min$33,
        max$33,
        ascending$27,
        descending$27,
        between$13,
        clamp_exn$13,
        clamp$13,
        comparator$18,
        pp$16,
        hashable$8,
        is_positive$2,
        is_non_negative$2,
        is_negative$2,
        is_non_positive$2,
        sign$2,
        invariant$20,
        Hex$2,
        to_string_hum$4,
        zero$4,
        one$3,
        minus_one$2,
        symbol$197,
        symbol$198,
        symbol$199,
        symbol$201,
        neg$4,
        neg$4,
        symbol$210,
        symbol$209,
        symbol$200,
        rem$2,
        symbol$211,
        land$1,
        lor$1,
        lxor$1,
        lnot$3,
        lsl$1,
        asr$1,
        round$2,
        round_towards_zero$2,
        round_down$2,
        round_up$2,
        round_nearest$2,
        abs$5,
        succ$5,
        pred$4,
        pow$2,
        land$1,
        lor$1,
        lxor$1,
        lnot$3,
        popcount$1,
        lsl$1,
        asr$1,
        decr$3,
        incr$3,
        of_int32_exn$0,
        to_int32_exn,
        of_int64_exn$0,
        to_int64$0,
        of_nativeint_exn,
        to_nativeint_exn$0,
        num_bits$3,
        max_value$5,
        min_value$5,
        lsr$1,
        lsr$1,
        ceil_pow2$2,
        floor_pow2$2,
        ceil_log2$2,
        floor_log2$2,
        is_pow2$2,
        clz$0,
        ctz$0,
        _fS_,
        of_int$5,
        to_int$4,
        to_int_trunc,
        of_int32,
        to_int32,
        to_int32_trunc,
        of_int64,
        of_int64_trunc,
        of_nativeint$0,
        to_nativeint$1,
        of_nativeint_trunc,
        to_nativeint_trunc,
        of_float_unchecked$2,
        repr,
        bswap16$0,
        bswap32$0,
        bswap48$0];
    else
     var
      _kM_=runtime.caml_bswap16,
      _kN_=function(_oK_){return _oK_},
      _kO_=caml_int64_to_int32,
      _kP_=function(_oJ_){return _oJ_},
      _kQ_=function(_oI_,_oH_){return _oI_ >>> _oH_ | 0},
      _kR_=function(_oG_,_oF_){return _oG_ >> _oF_},
      _kS_=function(_oE_,_oD_){return _oE_ << _oD_},
      _kT_=O$0[2],
      _kU_=function(_oC_,_oB_){return _oC_ ^ _oB_},
      _kV_=function(_oA_,_oz_){return _oA_ | _oz_},
      _kW_=function(_oy_,_ox_){return _oy_ & _ox_},
      _kX_=O$0[7],
      _kY_=O$0[6],
      _kZ_=O$0[5],
      _k0_=O$0[4],
      _k1_=function(_ow_){return - _ow_ | 0},
      _k2_=O$0[3],
      _k3_=function(_ov_,_ou_){return _ov_ !== _ou_?1:0},
      _k4_=function(_ot_,_os_){return _ot_ < _os_?1:0},
      _k5_=function(_or_,_oq_){return _oq_ < _or_?1:0},
      _k6_=function(_op_,_oo_){return _op_ === _oo_?1:0},
      _k7_=function(_on_,_om_){return _on_ <= _om_?1:0},
      _k8_=function(_ol_,_ok_){return _ok_ <= _ol_?1:0},
      _k9_=O$0[1],
      _k__=function(_oj_){return - _oj_ | 0},
      _k$_=caml_div,
      _la_=caml_mul,
      _lb_=function(_oi_,_oh_){return _oi_ - _oh_ | 0},
      _lc_=
       [0,
        function(_og_,_of_){return _og_ + _of_ | 0},
        _lb_,
        _la_,
        _k$_,
        _k__,
        _k9_,
        _k8_,
        _k7_,
        _k6_,
        _k5_,
        _k4_,
        _k3_,
        _k2_,
        _k1_,
        _k0_,
        _kZ_,
        _kY_,
        _kX_,
        _kW_,
        _kV_,
        _kU_,
        _kT_,
        _kS_,
        _kR_,
        _kQ_],
      _ld_=function(_oe_,_od_){return _oe_ >>> _od_ | 0},
      _le_=function(_oc_,_ob_){return _oc_ >> _ob_},
      _lf_=function(_oa_,_n$_){return _oa_ << _n$_},
      _lg_=function(_n__,_n9_){return _n__ ^ _n9_},
      _lh_=function(_n8_,_n7_){return _n8_ | _n7_},
      _li_=function(_n6_,_n5_){return _n6_ & _n5_},
      _lj_=caml_div,
      _lk_=function(_n4_){return - _n4_ | 0},
      _ll_=function(_n3_){return - _n3_ | 0},
      _lm_=caml_mul,
      _ln_=function(_n2_,_n1_){return _n2_ - _n1_ | 0},
      _lo_=function(_n0_,_nZ_){return _n0_ + _nZ_ | 0},
      _lp_=function(_nY_,_nX_){return _nY_ !== _nX_?1:0},
      _lq_=function(_nW_,_nV_){return _nW_ < _nV_?1:0},
      _lr_=function(_nU_,_nT_){return _nT_ < _nU_?1:0},
      _ls_=function(_nS_,_nR_){return _nS_ === _nR_?1:0},
      _lt_=function(_nQ_,_nP_){return _nQ_ <= _nP_?1:0},
      impl=
       [0,
        t_sexp_grammar$3,
        to_int$3,
        of_int$2,
        of_int$3,
        to_int_exn,
        hash_fold_t$4,
        func$8,
        t_of_sexp$4,
        sexp_of_t$33,
        of_string$9,
        to_string,
        function(_nO_,_nN_){return _nN_ <= _nO_?1:0},
        _lt_,
        _ls_,
        _lr_,
        _lq_,
        _lp_,
        equal_int$1,
        compare_int$0,
        min$25,
        max$25,
        ascending$19,
        descending$19,
        between$5,
        clamp_exn$5,
        clamp$5,
        comparator$7,
        pp$11,
        hashable$3,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        invariant$14,
        Hex,
        to_string_hum$1,
        zero,
        one,
        minus_one,
        _lo_,
        _ln_,
        _lm_,
        symbol$136,
        _ll_,
        _lk_,
        symbol$138,
        symbol$137,
        _lj_,
        rem,
        symbol$139,
        _li_,
        _lh_,
        _lg_,
        lnot$0,
        _lf_,
        _le_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs$2,
        succ$1,
        pred$0,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount$0,
        shift_left,
        shift_right$0,
        decr$0,
        incr$0,
        int32_to_int_exn,
        int_to_int32_exn,
        int64_to_int_exn,
        int_to_int64,
        nativeint_to_int_exn,
        int_to_nativeint,
        num_bits,
        max_value$2,
        min_value$2,
        _ld_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        floor_log2,
        is_pow2,
        clz,
        ctz,
        _lc_,
        of_int$3,
        to_int$6,
        to_int_trunc$0,
        int32_to_int_exn,
        int_to_int32,
        _kP_,
        int64_to_int,
        _kO_,
        nativeint_to_int,
        to_nativeint$2,
        _kN_,
        to_nativeint_trunc$0,
        of_float_unchecked,
        repr$1,
        _kM_,
        bswap32$1,
        bswap48$1];
    var
     _gc_=impl[3],
     _ge_=impl[5],
     _gi_=impl[9],
     _gk_=impl[11],
     _gm_=impl[13],
     _gn_=impl[14],
     _go_=impl[15],
     _gp_=impl[16],
     _gq_=impl[17],
     _gr_=impl[18],
     _gD_=impl[30],
     _gL_=impl[38],
     _gM_=impl[39],
     _gO_=impl[41],
     _gP_=impl[42],
     _gQ_=impl[43],
     _gS_=impl[45],
     _gW_=impl[49],
     _g__=impl[63],
     _hc_=impl[67],
     _hd_=impl[68],
     _he_=impl[69],
     _hf_=impl[70],
     _hh_=impl[72],
     _hn_=impl[78],
     _ho_=impl[79],
     _hr_=impl[82],
     _ht_=impl[84],
     _hD_=impl[95],
     _hP_=impl[107],
     _ga_=impl[1],
     _gb_=impl[2],
     _gd_=impl[4],
     _gf_=impl[6],
     _gg_=impl[7],
     _gh_=impl[8],
     _gj_=impl[10],
     _gl_=impl[12],
     _gs_=impl[19],
     _gt_=impl[20],
     _gu_=impl[21],
     _gv_=impl[22],
     _gw_=impl[23],
     _gx_=impl[24],
     _gy_=impl[25],
     _gz_=impl[26],
     _gA_=impl[27],
     _gB_=impl[28],
     _gC_=impl[29],
     _gE_=impl[31],
     _gF_=impl[32],
     _gG_=impl[33],
     _gH_=impl[34],
     _gI_=impl[35],
     _gJ_=impl[36],
     _gK_=impl[37],
     _gN_=impl[40],
     _gR_=impl[44],
     _gT_=impl[46],
     _gU_=impl[47],
     _gV_=impl[48],
     _gX_=impl[50],
     _gY_=impl[51],
     _gZ_=impl[52],
     _g0_=impl[53],
     _g1_=impl[54],
     _g2_=impl[55],
     _g3_=impl[56],
     _g4_=impl[57],
     _g5_=impl[58],
     _g6_=impl[59],
     _g7_=impl[60],
     _g8_=impl[61],
     _g9_=impl[62],
     _g$_=impl[64],
     _ha_=impl[65],
     _hb_=impl[66],
     _hg_=impl[71],
     _hi_=impl[73],
     _hj_=impl[74],
     _hk_=impl[75],
     _hl_=impl[76],
     _hm_=impl[77],
     _hp_=impl[80],
     _hq_=impl[81],
     _hs_=impl[83],
     _hu_=impl[85],
     _hv_=impl[86],
     _hw_=impl[87],
     _hx_=impl[88],
     _hy_=impl[89],
     _hz_=impl[91],
     _hA_=impl[92],
     _hB_=impl[93],
     _hC_=impl[94],
     _hE_=impl[96],
     _hF_=impl[97],
     _hG_=impl[98],
     _hH_=impl[99],
     _hI_=impl[100],
     _hJ_=impl[101],
     _hK_=impl[102],
     _hL_=impl[103],
     _hM_=impl[104],
     _hN_=impl[105],
     _hO_=impl[106],
     _hQ_=impl[108],
     _hR_=impl[109],
     _hS_=impl[110],
     _hT_=impl[111];
    function symbol$234(t,u)
     {var sum=_gO_(t,u),_nK_=_he_(t,_hf_(sum));
      if(_gp_(_hd_(_he_(t,u),_nK_),_gL_))return sum;
      var
       _nL_=[0,[0,cst_sum,caml_call1(_gi_,sum)],0],
       _nM_=[0,[0,cst_u,caml_call1(_gi_,u)],_nL_];
      return raise_s
              (caml_call2
                (message,cst_overflow,[0,[0,cst_t,caml_call1(_gi_,t)],_nM_]))}
    function symbol$235(t,u)
     {var diff=_gP_(t,u),pos_diff=_go_(t,u);
      if(_gq_(t,u) && caml_call2(symbol$216,pos_diff,caml_call1(_gD_,diff)))
       {var
         _nI_=[0,[0,cst_diff,caml_call1(_gi_,diff)],0],
         _nJ_=[0,[0,cst_u$0,caml_call1(_gi_,u)],_nI_];
        return raise_s
                (caml_call2
                  (message,
                   cst_overflow$0,
                   [0,[0,cst_t$0,caml_call1(_gi_,t)],_nJ_]))}
      return diff}
    var negative_one=_hD_(-1);
    function div_would_overflow(t,u)
     {var _nH_=_gn_(t,_ht_);return _nH_?_gn_(u,negative_one):_nH_}
    function symbol$236(t,u)
     {var product=_gQ_(t,u);
      if(_gq_(u,_gL_))
       {var switch$0=0;
        if(! div_would_overflow(product,u) && ! _gq_(_gW_(product,u),t))
         switch$0 = 1;
        if(! switch$0)
         {var
           _nF_=[0,[0,cst_product,caml_call1(_gi_,product)],0],
           _nG_=[0,[0,cst_u$1,caml_call1(_gi_,u)],_nF_];
          return raise_s
                  (caml_call2
                    (message,
                     cst_overflow$1,
                     [0,[0,cst_t$1,caml_call1(_gi_,t)],_nG_]))}}
      return product}
    function symbol$237(t,u)
     {if(! div_would_overflow(t,u))return _gW_(t,u);
      var
       _nD_=[0,[0,cst_product$0,caml_call1(_gi_,_gW_(t,u))],0],
       _nE_=[0,[0,cst_u$2,caml_call1(_gi_,u)],_nD_];
      return raise_s
              (caml_call2
                (message,
                 cst_overflow$2,
                 [0,[0,cst_t$2,caml_call1(_gi_,t)],_nE_]))}
    function abs$7(t)
     {return _gn_(t,_ht_)?caml_call1(failwith$0,cst_abs_overflow):_g__(t)}
    function neg$6(t)
     {return _gn_(t,_ht_)?caml_call1(failwith$0,cst_neg_overflow):_gS_(t)}
    if(63 !== _hr_)throw [0,Assert_failure$0,_kL_];
    function random_of_int(opt,bound)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nC_=_ge_(bound);
      return _hD_(caml_call2(_ag_[6],state,_nC_))}
    function random_of_int64(opt,bound)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nB_=_ho_(bound);
      return _hn_(caml_call2(_ag_[9],state,_nB_))}
    var random_of_int$0=word_size?random_of_int:random_of_int64;
    function random_incl_of_int(opt,lo,hi)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nz_=_ge_(hi),_nA_=_ge_(lo);
      return _hD_(caml_call3(_ag_[11],state,_nA_,_nz_))}
    function random_incl_of_int64(opt,lo,hi)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nx_=_ho_(hi),_ny_=_ho_(lo);
      return _hn_(caml_call3(_ag_[14],state,_ny_,_nx_))}
    var random_incl=word_size?random_incl_of_int:random_incl_of_int64;
    function floor_log2$4(t)
     {if(word_size)return floor_log2(_ge_(t));
      if(_gm_(t,_gL_))
       raise_s
        (caml_call2
          (message,
           cst_Int_floor_log2_got_invalid$0,
           [0,[0,cst$36,caml_call1(_gi_,t)],0]));
      var floor_log2$0=[0,_hr_ - 2 | 0];
      for(;;)
       {if(! _gr_(_gL_,_hc_(t,_hh_(_gM_,floor_log2$0[1]))))
         return floor_log2$0[1];
        floor_log2$0[1] = floor_log2$0[1] - 1 | 0}}
    var
     Base_Int63=
      [0,
       _ga_,
       _gb_,
       _gc_,
       _gd_,
       _ge_,
       _gf_,
       _gg_,
       _gh_,
       _gi_,
       _gj_,
       _gk_,
       _gl_,
       _gm_,
       _gn_,
       _go_,
       _gp_,
       _gq_,
       _gr_,
       _gs_,
       _gt_,
       _gu_,
       _gv_,
       _gw_,
       _gx_,
       _gy_,
       _gz_,
       _gA_,
       _gB_,
       _gC_,
       _gD_,
       _gE_,
       _gF_,
       _gG_,
       _gH_,
       _gI_,
       _gJ_,
       _gK_,
       _gL_,
       _gM_,
       _gN_,
       _gO_,
       _gP_,
       _gQ_,
       _gR_,
       _gS_,
       _gT_,
       _gU_,
       _gV_,
       _gW_,
       _gX_,
       _gY_,
       _gZ_,
       _g0_,
       _g1_,
       _g2_,
       _g3_,
       _g4_,
       _g5_,
       _g6_,
       _g7_,
       _g8_,
       _g9_,
       _g__,
       _g$_,
       _ha_,
       _hb_,
       _hc_,
       _hd_,
       _he_,
       _hf_,
       _hg_,
       _hh_,
       _hi_,
       _hj_,
       _hk_,
       _hl_,
       _hm_,
       _hn_,
       _ho_,
       _hp_,
       _hq_,
       _hP_,
       _hr_,
       _hs_,
       _ht_,
       _hu_,
       _hv_,
       _hw_,
       _hx_,
       _hy_,
       _hz_,
       _hA_,
       _hB_,
       _hC_,
       [0,symbol$234,symbol$235,symbol$236,symbol$237,abs$7,neg$6],
       _hD_,
       _hE_,
       _hG_,
       _hH_,
       _hJ_,
       _hL_,
       _hM_,
       _hF_,
       _hI_,
       _hK_,
       _hN_,
       _hO_,
       _hR_,
       _hS_,
       _hT_,
       random_of_int$0,
       random_incl,
       floor_log2$4,
       [0,Repr$0,_hQ_]];
    caml_register_global(1123,Base_Int63,"Base__Int63");
    var
     Key=[0],
     Merge_into_action=[0],
     Base_Hashtbl_intf=[0,Key,Merge_into_action];
    caml_register_global(1124,Base_Hashtbl_intf,"Base__Hashtbl_intf");
    function max$36(x,y){return y < x?x:y}
    var empty$10=0;
    function is_empty$14(param){return typeof param === "number"?1:0}
    function height$1(param)
     {if(typeof param === "number")return 0;
      if(0 !== param[0])return 1;
      var height=param[4];
      return height}
    function invariant$23(t,compare)
     {function inv(param)
       {if(typeof param !== "number" && 0 === param[0])
         {var
           left=param[1],
           k=param[2],
           h=param[4],
           right=param[5],
           hr=height$1(right),
           hl=height$1(left);
          inv(left);
          inv(right);
          var switch$0=0;
          if(typeof left === "number")
           switch$0 = 1;
          else
           var left_key=0 === left[0]?left[2]:left[1];
          if(! switch$0 && 0 <= caml_call2(compare,left_key,k))
           throw [0,Assert_failure$0,_hU_];
          var switch$1=0;
          if(typeof right === "number")
           switch$1 = 1;
          else
           var right_key=0 === right[0]?right[2]:right[1];
          if(! switch$1 && 0 >= caml_call2(compare,right_key,k))
           throw [0,Assert_failure$0,_hV_];
          if(h !== (max$36(hl,hr) + 1 | 0))throw [0,Assert_failure$0,_hX_];
          if(2 < caml_call1(abs$0,hl - hr | 0))
           throw [0,Assert_failure$0,_hW_];
          return 0}
        return 0}
      return inv(t)}
    function update_height(x)
     {if(typeof x !== "number" && 0 === x[0])
       {var
         left=x[1],
         old_height=x[4],
         right=x[5],
         _nu_=height$1(right),
         new_height=max$36(height$1(left),_nu_) + 1 | 0,
         _nv_=new_height !== old_height?1:0,
         _nw_=_nv_?(x[4] = new_height,0):_nv_;
        return _nw_}
      throw [0,Assert_failure$0,_hY_]}
    function balance(tree)
     {if(typeof tree !== "number" && 0 === tree[0])
       {var left=tree[1],right=tree[5],hl=height$1(left),hr=height$1(right);
        if((hr + 2 | 0) < hl)
         {if(typeof left !== "number" && 0 === left[0])
           {var
             left_node_left=left[1],
             left_node_right=left[5],
             _ns_=height$1(left_node_right);
            if(_ns_ <= height$1(left_node_left))
             {tree[1] = left_node_right;
              left[5] = tree;
              update_height(tree);
              update_height(left);
              return left}
            if
             (typeof left_node_right !== "number" && 0 === left_node_right[0])
             {var lr_left=left_node_right[1],lr_right=left_node_right[5];
              left[5] = lr_left;
              tree[1] = lr_right;
              left_node_right[5] = tree;
              left_node_right[1] = left;
              update_height(left);
              update_height(tree);
              update_height(left_node_right);
              return left_node_right}
            throw [0,Assert_failure$0,_h0_]}
          throw [0,Assert_failure$0,_hZ_]}
        if((hl + 2 | 0) >= hr){update_height(tree);return tree}
        if(typeof right !== "number" && 0 === right[0])
         {var
           right_node_left=right[1],
           right_node_right=right[5],
           _nt_=height$1(right_node_left);
          if(_nt_ <= height$1(right_node_right))
           {tree[5] = right_node_left;
            right[1] = tree;
            update_height(tree);
            update_height(right);
            return right}
          if(typeof right_node_left !== "number" && 0 === right_node_left[0])
           {var rl_left=right_node_left[1],rl_right=right_node_left[5];
            right[1] = rl_right;
            tree[5] = rl_left;
            right_node_left[1] = tree;
            right_node_left[5] = right;
            update_height(right);
            update_height(tree);
            update_height(right_node_left);
            return right_node_left}
          throw [0,Assert_failure$0,_h2_]}
        throw [0,Assert_failure$0,_h1_]}
      return tree}
    function set_left(r,tree)
     {var tree$0=balance(tree);
      if(typeof r !== "number" && 0 === r[0])
       {var left=r[1];
        if(left !== tree$0)r[1] = tree$0;
        return update_height(r)}
      throw [0,Assert_failure$0,_h3_]}
    function set_right(r,tree)
     {var tree$0=balance(tree);
      if(typeof r !== "number" && 0 === r[0])
       {var right=r[5];
        if(right !== tree$0)r[5] = tree$0;
        return update_height(r)}
      throw [0,Assert_failure$0,_h4_]}
    function add$6(t,replace,added,compare,k,v)
     {if(typeof t === "number"){added[1] = 1;return [1,k,v]}
      if(0 !== t[0])
       {var k$1=t[1],c$0=caml_call2(compare,k$1,k);
        if(0 !== c$0)
         {added[1] = 1;return 0 <= c$0?[0,0,k,v,2,t]:[0,t,k,v,2,0]}
        added[1] = 0;
        if(replace)t[2] = v;
        return t}
      var left=t[1],k$0=t[2],right=t[5],c=caml_call2(compare,k,k$0);
      if(0 === c)
       {added[1] = 0;if(replace)t[3] = v}
      else
       if(0 <= c)
        set_right(t,add$6(right,replace,added,compare,k,v));
       else
        set_left(t,add$6(left,replace,added,compare,k,v));
      return t}
    function add$7(t,replace,compare,added,key,data)
     {var t$0=add$6(t,replace,added,compare,key,data);
      return added[1]?balance(t$0):t$0}
    function first$0(t)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var _nr_=t$0[1];
          if(typeof _nr_ !== "number"){var t$0=_nr_;continue}
          var v=t$0[3],k=t$0[2]}
        else
         var k$0=t$0[1],v$0=t$0[2],v=v$0,k=k$0;
        return [0,[0,k,v]]}}
    function last$2(t)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var _np_=t$0[2],_nq_=t$0[3];
          if(typeof t$0[5] !== "number"){var t$1=t$0[5],t$0=t$1;continue}
          var v=_nq_,k=_np_}
        else
         var k$0=t$0[1],v$0=t$0[2],v=v$0,k=k$0;
        return [0,[0,k,v]]}}
    function findi_and_call_impl
     (t,
      compare,
      k,
      arg1,
      arg2,
      call_if_found,
      call_if_not_found,
      if_found,
      if_not_found)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")
         return caml_call4(call_if_not_found,if_not_found,k,arg1,arg2);
        if(0 !== t$0[0])
         {var k$1=t$0[1],v$0=t$0[2];
          return 0 === caml_call2(compare,k,k$1)
                  ?caml_call5(call_if_found,if_found,k$1,v$0,arg1,arg2)
                  :caml_call4(call_if_not_found,if_not_found,k,arg1,arg2)}
        var
         left=t$0[1],
         k$0=t$0[2],
         v=t$0[3],
         right=t$0[5],
         c=caml_call2(compare,k,k$0);
        if(0 === c)return caml_call5(call_if_found,if_found,k$0,v,arg1,arg2);
        var t$1=0 <= c?right:left,t$0=t$1}}
    function call_if_found(if_found,param,data,_no_,_nn_)
     {return caml_call1(if_found,data)}
    function call_if_not_found(if_not_found,key,param,_nm_)
     {return caml_call1(if_not_found,key)}
    function find_and_call(t,compare,k,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               0,
               0,
               call_if_found,
               call_if_not_found,
               if_found,
               if_not_found)}
    function call_if_found$0(if_found,key,data,param,_nl_)
     {return caml_call2(if_found,key,data)}
    function call_if_not_found$0(if_not_found,key,param,_nk_)
     {return caml_call1(if_not_found,key)}
    function findi_and_call(t,compare,k,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               0,
               0,
               call_if_found$0,
               call_if_not_found$0,
               if_found,
               if_not_found)}
    function call_if_found$1(if_found,param,data,arg,_nj_)
     {return caml_call2(if_found,data,arg)}
    function call_if_not_found$1(if_not_found,key,arg,param)
     {return caml_call2(if_not_found,key,arg)}
    function find_and_call1(t,compare,k,a,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               0,
               call_if_found$1,
               call_if_not_found$1,
               if_found,
               if_not_found)}
    function call_if_found$2(if_found,key,data,arg,param)
     {return caml_call3(if_found,key,data,arg)}
    function call_if_not_found$2(if_not_found,key,arg,param)
     {return caml_call2(if_not_found,key,arg)}
    function findi_and_call1(t,compare,k,a,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               0,
               call_if_found$2,
               call_if_not_found$2,
               if_found,
               if_not_found)}
    function call_if_found$3(if_found,param,data,arg1,arg2)
     {return caml_call3(if_found,data,arg1,arg2)}
    function call_if_not_found$3(if_not_found,key,arg1,arg2)
     {return caml_call3(if_not_found,key,arg1,arg2)}
    function find_and_call2(t,compare,k,a,b,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               b,
               call_if_found$3,
               call_if_not_found$3,
               if_found,
               if_not_found)}
    function call_if_found$4(if_found,key,data,arg1,arg2)
     {return caml_call4(if_found,key,data,arg1,arg2)}
    function call_if_not_found$4(if_not_found,key,arg1,arg2)
     {return caml_call3(if_not_found,key,arg1,arg2)}
    function findi_and_call2(t,compare,k,a,b,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               b,
               call_if_found$4,
               call_if_not_found$4,
               if_found,
               if_not_found)}
    function if_found(v){return [0,v]}
    function if_not_found$0(param){return 0}
    function find$15(t,compare,k)
     {return find_and_call(t,compare,k,if_found,if_not_found$0)}
    function if_found$0(param){return 1}
    function if_not_found$1(param){return 0}
    function mem$13(t,compare,k)
     {return find_and_call(t,compare,k,if_found$0,if_not_found$1)}
    function remove_min_elt$1(tree)
     {if(typeof tree === "number")throw [0,Assert_failure$0,_h5_];
      if(0 !== tree[0])return 0;
      var _ng_=tree[1];
      if(typeof _ng_ === "number"){var right=tree[5];return right}
      if(0 === _ng_[0]){set_left(tree,remove_min_elt$1(_ng_));return tree}
      var _nh_=tree[2],_ni_=tree[3];
      return typeof tree[5] === "number"?[1,_nh_,_ni_]:(set_left(tree,0),tree)}
    function remove$6(t,removed,compare,k$0)
     {if(typeof t === "number"){removed[1] = 0;return 0}
      if(0 !== t[0])
       {var k$2=t[1];
        return 0 === caml_call2(compare,k$0,k$2)
                ?(removed[1] = 1,0)
                :(removed[1] = 0,t)}
      var left=t[1],k$1=t[2],right=t[5],c=caml_call2(compare,k$0,k$1);
      if(0 !== c)
       return 0 <= c
               ?(set_right(t,remove$6(right,removed,compare,k$0)),t)
               :(set_left(t,remove$6(left,removed,compare,k$0)),t);
      removed[1] = 1;
      if(typeof left === "number")return right;
      if(typeof right === "number")return left;
      var tree=right;
      for(;;)
       {if(typeof tree === "number")
         var tree$0=0;
        else
         if(0 === tree[0])
          {var _ne_=tree[1];
           if(typeof _ne_ !== "number"){var tree=_ne_;continue}
           var tree$0=tree}
         else
          var tree$0=tree;
        if(typeof tree$0 === "number")throw [0,Assert_failure$0,_h6_];
        if(0 === tree$0[0])
         {set_right(tree$0,remove_min_elt$1(right));
          set_left(tree$0,left);
          return tree$0}
        var
         k=tree$0[1],
         v=tree$0[2],
         t2=balance(remove_min_elt$1(right)),
         _nf_=height$1(t2);
        return [0,left,k,v,max$36(height$1(left),_nf_) + 1 | 0,t2]}}
    function remove$7(t,removed,compare,k)
     {return balance(remove$6(t,removed,compare,k))}
    function fold$17(t,init,f)
     {var t$0=t,init$0=init;
      for(;;)
       {if(typeof t$0 === "number")return init$0;
        if(0 !== t$0[0])
         {var key$1=t$0[1],data$1=t$0[2];
          return caml_call3(f,key$1,data$1,init$0)}
        var _m4_=t$0[1],switch$0=0;
        if(typeof _m4_ === "number")
         {var _m7_=t$0[5],_m5_=t$0[2],_m6_=t$0[3];
          if(typeof _m7_ !== "number" && 0 !== _m7_[0])
           {var rkey=_m7_[1],rdata=_m7_[2];
            return caml_call3(f,rkey,rdata,caml_call3(f,_m5_,_m6_,init$0))}}
        else
         if(0 === _m4_[0])
          {var _m__=t$0[5],_m8_=t$0[2],_m9_=t$0[3];
           if(typeof _m__ !== "number" && 0 !== _m__[0])
            {var rkey$0=_m__[1],rdata$0=_m__[2];
             return caml_call3
                     (f,
                      rkey$0,
                      rdata$0,
                      caml_call3(f,_m8_,_m9_,fold$17(_m4_,init$0,f)))}
           switch$0 = 1}
         else
          {var _m$_=_m4_[1],_na_=_m4_[2],_nb_=t$0[2],_nc_=t$0[3],_nd_=t$0[5];
           if(typeof _nd_ === "number")
            return caml_call3(f,_nb_,_nc_,caml_call3(f,_m$_,_na_,init$0));
           if(0 !== _nd_[0])
            {var rkey$1=_nd_[1],rdata$1=_nd_[2];
             return caml_call3
                     (f,
                      rkey$1,
                      rdata$1,
                      caml_call3(f,_nb_,_nc_,caml_call3(f,_m$_,_na_,init$0)))}
           switch$0 = 1}
        if(switch$0 && typeof _m4_ !== "number" && 1 === _m4_[0])
         {var
           lkey=_m4_[1],
           ldata=_m4_[2],
           key$0=t$0[2],
           data$0=t$0[3],
           right$0=t$0[5],
           init$2=caml_call3(f,key$0,data$0,caml_call3(f,lkey,ldata,init$0)),
           t$0=right$0,
           init$0=init$2;
          continue}
        var
         key=t$0[2],
         data=t$0[3],
         right=t$0[5],
         init$1=caml_call3(f,key,data,fold$17(_m4_,init$0,f)),
         t$0=right,
         init$0=init$1}}
    function iter$22(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var left=t$0[1],key=t$0[2],data=t$0[3],right=t$0[5];
          iter$22(left,f);
          caml_call2(f,key,data);
          var t$0=right;
          continue}
        var key$0=t$0[1],data$0=t$0[2];
        return caml_call2(f,key$0,data$0)}}
    function mapi_inplace(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var left=t$0[1],key=t$0[2],value=t$0[3],right=t$0[5];
          mapi_inplace(left,f);
          t$0[3] = caml_call2(f,key,value);
          var t$0=right;
          continue}
        var key$0=t$0[1],value$0=t$0[2];
        t$0[2] = caml_call2(f,key$0,value$0);
        return 0}}
    function choose_exn$2(param)
     {if(typeof param === "number")
       return raise_s(caml_call2(message,cst_Avltree_choose_exn_of_empt,0));
      if(0 === param[0])
       var value=param[3],key=param[2];
      else
       var key$0=param[1],value$0=param[2],value=value$0,key=key$0;
      return [0,key,value]}
    var
     Base_Avltree=
      [0,
       empty$10,
       is_empty$14,
       invariant$23,
       add$7,
       first$0,
       last$2,
       find$15,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem$13,
       remove$7,
       fold$17,
       iter$22,
       mapi_inplace,
       choose_exn$2];
    caml_register_global(1125,Base_Avltree,"Base__Avltree");
    function sexp_of_key(t){return t[5][3]}
    function compare_key$0(t){return t[5][2]}
    function ensure_mutation_allowed(t)
     {var _m3_=1 - t[6];
      return _m3_?caml_call1(failwith$0,cst_Hashtbl_mutation_not_allow):_m3_}
    function without_mutating(t,f)
     {if(! t[6])return caml_call1(f,0);
      t[6] = 0;
      try
       {var x=caml_call1(f,0)}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = 1;throw exn}
      t[6] = 1;
      return x}
    var max_table_length=floor_pow2(max_length$0);
    function create$16(opt,_m2_,hashable,param)
     {if(opt)var sth=opt[1],growth_allowed=sth;else var growth_allowed=1;
      if(_m2_)var sth$0=_m2_[1],size=sth$0;else var size=0;
      var
       size$0=caml_call2(min$25,caml_call2(max$25,1,size),max_table_length),
       size$1=ceil_pow2(size$0);
      return [0,caml_make_vect(size$1,0),0,[0,0],growth_allowed,hashable,1]}
    function slot(t,key)
     {var hash=caml_call1(t[5][1],key);
      return hash & (t[1].length - 1 - 1 | 0)}
    function add_worker(t,replace,key,data)
     {var i=slot(t,key),root=caml_check_bound(t[1],i)[1 + i],added=t[3];
      added[1] = 0;
      var new_root=add$7(root,replace,compare_key$0(t),added,key,data);
      if(added[1])t[2] = t[2] + 1 | 0;
      var
       _m0_=1 - (new_root === root?1:0),
       _m1_=_m0_?(caml_check_bound(t[1],i)[1 + i] = new_root,0):_m0_;
      return _m1_}
    function maybe_resize_table(t)
     {var
       len=t[1].length - 1,
       should_grow=len < t[2]?1:0,
       _mT_=should_grow?t[4]:should_grow;
      if(_mT_)
       {var
         new_array_length=caml_call2(min$25,len * 2 | 0,max_table_length),
         _mU_=len < new_array_length?1:0;
        if(_mU_)
         {var new_table=caml_make_vect(new_array_length,0),old_table=t[1];
          t[1] = new_table;
          t[2] = 0;
          var
           f=function(key,data){return add_worker(t,1,key,data)},
           _mW_=old_table.length - 1 - 1 | 0,
           _mV_=0;
          if(_mW_ >= 0)
           {var i=_mV_;
            for(;;)
             {iter$22(caml_check_bound(old_table,i)[1 + i],f);
              var _mZ_=i + 1 | 0;
              if(_mW_ !== i){var i=_mZ_;continue}
              break}}
          var _mX_=0}
        else
         var _mX_=_mU_;
        var _mY_=_mX_}
      else
       var _mY_=_mT_;
      return _mY_}
    function set$9(t,key,data)
     {ensure_mutation_allowed(t);
      add_worker(t,1,key,data);
      return maybe_resize_table(t)}
    function add$8(t,key,data)
     {ensure_mutation_allowed(t);
      add_worker(t,0,key,data);
      return t[3][1]?(maybe_resize_table(t),17724):-1024851605}
    function add_exn$3(t,key,data)
     {var match=add$8(t,key,data);
      if(17724 <= match)return 0;
      var
       sexp_of_key$0=sexp_of_key(t),
       error=create$2(0,0,cst_Hashtbl_add_exn_got_key_al,key,sexp_of_key$0);
      return raise(error)}
    function clear$3(t)
     {ensure_mutation_allowed(t);
      var _mR_=t[1].length - 1 - 1 | 0,_mQ_=0;
      if(_mR_ >= 0)
       {var i=_mQ_;
        for(;;)
         {caml_check_bound(t[1],i)[1 + i] = empty$10;
          var _mS_=i + 1 | 0;
          if(_mR_ !== i){var i=_mS_;continue}
          break}}
      t[2] = 0;
      return 0}
    function find_and_call$0(t,key,if_found,if_not_found)
     {var _mP_=slot(t,key),tree=caml_check_bound(t[1],_mP_)[1 + _mP_];
      if(typeof tree === "number")return caml_call1(if_not_found,key);
      if(0 === tree[0])
       return find_and_call(tree,compare_key$0(t),key,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call1(if_found,v)
              :caml_call1(if_not_found,key)}
    function find_and_call1$0(t,key,a,if_found,if_not_found)
     {var _mO_=slot(t,key),tree=caml_check_bound(t[1],_mO_)[1 + _mO_];
      if(typeof tree === "number")return caml_call2(if_not_found,key,a);
      if(0 === tree[0])
       return find_and_call1
               (tree,compare_key$0(t),key,a,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call2(if_found,v,a)
              :caml_call2(if_not_found,key,a)}
    function find_and_call2$0(t,key,a,b,if_found,if_not_found)
     {var _mN_=slot(t,key),tree=caml_check_bound(t[1],_mN_)[1 + _mN_];
      if(typeof tree === "number")return caml_call3(if_not_found,key,a,b);
      if(0 === tree[0])
       return find_and_call2
               (tree,compare_key$0(t),key,a,b,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call3(if_found,v,a,b)
              :caml_call3(if_not_found,key,a,b)}
    function findi_and_call$0(t,key,if_found,if_not_found)
     {var _mM_=slot(t,key),tree=caml_check_bound(t[1],_mM_)[1 + _mM_];
      if(typeof tree === "number")return caml_call1(if_not_found,key);
      if(0 === tree[0])
       return findi_and_call(tree,compare_key$0(t),key,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call2(if_found,k,v)
              :caml_call1(if_not_found,key)}
    function findi_and_call1$0(t,key,a,if_found,if_not_found)
     {var _mL_=slot(t,key),tree=caml_check_bound(t[1],_mL_)[1 + _mL_];
      if(typeof tree === "number")return caml_call2(if_not_found,key,a);
      if(0 === tree[0])
       return findi_and_call1
               (tree,compare_key$0(t),key,a,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call3(if_found,k,v,a)
              :caml_call2(if_not_found,key,a)}
    function findi_and_call2$0(t,key,a,b,if_found,if_not_found)
     {var _mK_=slot(t,key),tree=caml_check_bound(t[1],_mK_)[1 + _mK_];
      if(typeof tree === "number")return caml_call3(if_not_found,key,a,b);
      if(0 === tree[0])
       return findi_and_call2
               (tree,compare_key$0(t),key,a,b,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call4(if_found,k,v,a,b)
              :caml_call3(if_not_found,key,a,b)}
    function if_found$1(v){return [0,v]}
    function if_not_found$2(param){return 0}
    function find$16(t,key)
     {return find_and_call$0(t,key,if_found$1,if_not_found$2)}
    function mem$14(t,key)
     {var _mJ_=slot(t,key),tree=caml_check_bound(t[1],_mJ_)[1 + _mJ_];
      if(typeof tree === "number")return 0;
      if(0 === tree[0])return mem$13(tree,compare_key$0(t),key);
      var k=tree[1];
      return 0 === caml_call2(compare_key$0(t),k,key)?1:0}
    function remove$8(t,key)
     {ensure_mutation_allowed(t);
      var
       i=slot(t,key),
       root=caml_check_bound(t[1],i)[1 + i],
       added_or_removed=t[3];
      added_or_removed[1] = 0;
      var new_root=remove$7(root,added_or_removed,compare_key$0(t),key);
      if(1 - (root === new_root?1:0))
       caml_check_bound(t[1],i)[1 + i] = new_root;
      var _mH_=added_or_removed[1],_mI_=_mH_?(t[2] = t[2] - 1 | 0,0):_mH_;
      return _mI_}
    function length$22(t){return t[2]}
    function is_empty$15(t){return 0 === t[2]?1:0}
    function fold$18(t,init,f)
     {if(0 === t[2])return init;
      var n=t[1].length - 1,acc=[0,init],m=t[6];
      try
       {t[6] = 0;
        var _mF_=n - 1 | 0,_mE_=0;
        if(_mF_ >= 0)
         {var i=_mE_;
          for(;;)
           {var bucket=t[1][1 + i];
            if(typeof bucket !== "number")
             if(0 === bucket[0])
              acc[1] = fold$17(bucket,acc[1],f);
             else
              {var key=bucket[1],data=bucket[2];
               acc[1] = caml_call3(f,key,data,acc[1])}
            var _mG_=i + 1 | 0;
            if(_mF_ !== i){var i=_mG_;continue}
            break}}}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = m;throw exn}
      t[6] = m;
      return acc[1]}
    function iteri$13(t,f)
     {if(0 === t[2])return 0;
      var n=t[1].length - 1,m=t[6];
      try
       {t[6] = 0;
        var _mC_=n - 1 | 0,_mB_=0;
        if(_mC_ >= 0)
         {var i=_mB_;
          for(;;)
           {var bucket=t[1][1 + i];
            if(typeof bucket !== "number")
             if(0 === bucket[0])
              iter$22(bucket,f);
             else
              {var key=bucket[1],data=bucket[2];caml_call2(f,key,data)}
            var _mD_=i + 1 | 0;
            if(_mC_ !== i){var i=_mD_;continue}
            break}}}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = m;throw exn}
      t[6] = m;
      return 0}
    function iter$23(t,f)
     {return iteri$13(t,function(param,data){return caml_call1(f,data)})}
    function iter_keys$2(t,f)
     {return iteri$13(t,function(key,param){return caml_call1(f,key)})}
    function choose_nonempty(table,i)
     {var i$0=i;
      for(;;)
       {var avltree=caml_check_bound(table,i$0)[1 + i$0];
        if(! is_empty$14(avltree))return choose_exn$2(avltree);
        var i$1=i$0 + 1 | 0,i$0=i$1}}
    function choose_exn$3(t)
     {if(0 === t[2])
       raise_s(caml_call2(message,cst_Hashtbl_choose_exn_of_empt,0));
      return choose_nonempty(t[1],0)}
    function choose$2(t){return is_empty$15(t)?0:[0,choose_nonempty(t[1],0)]}
    function invariant$24(invariant_key,invariant_data,t)
     {var _my_=t[1].length - 1 - 1 | 0,_mx_=0;
      if(_my_ >= 0)
       {var i=_mx_;
        for(;;)
         {var _mz_=compare_key$0(t);
          invariant$23(caml_check_bound(t[1],i)[1 + i],_mz_);
          var _mA_=i + 1 | 0;
          if(_my_ !== i){var i=_mA_;continue}
          break}}
      var
       real_len=
        fold$18
         (t,
          0,
          function(key,data,i)
           {caml_call1(invariant_key,key);
            caml_call1(invariant_data,data);
            return i + 1 | 0});
      if(real_len === t[2])return 0;
      throw [0,Assert_failure$0,_h7_]}
    function if_found$2(v,param){return v}
    function if_not_found$3(k,t)
     {throw [0,Not_found_s,[1,[0,_h8_,[0,caml_call1(t[5][3],k),0]]]]}
    function find_exn$9(t,key)
     {return find_and_call1$0(t,key,t,if_found$2,if_not_found$3)}
    function existsi$10(t,f)
     {return with_return
              (function(r)
                {iteri$13
                  (t,
                   function(key,data)
                    {var _mw_=caml_call2(f,key,data);
                     return _mw_?caml_call1(r,1):_mw_});
                 return 0})}
    function exists$15(t,f)
     {return existsi$10(t,function(param,data){return caml_call1(f,data)})}
    function for_alli$10(t,f)
     {return 1
             -
             existsi$10
              (t,function(key,data){return 1 - caml_call2(f,key,data)})}
    function for_all$15(t,f)
     {return 1
             -
             existsi$10(t,function(param,data){return 1 - caml_call1(f,data)})}
    function counti$10(t,f)
     {return fold$18
              (t,
               0,
               function(key,data,acc)
                {return caml_call2(f,key,data)?acc + 1 | 0:acc})}
    function count$14(t,f)
     {return fold$18
              (t,
               0,
               function(param,data,acc)
                {return caml_call1(f,data)?acc + 1 | 0:acc})}
    function mapi$11(t,f)
     {var new_t=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,function(key,data){return set$9(new_t,key,caml_call2(f,key,data))});
      return new_t}
    function map$37(t,f)
     {return mapi$11(t,function(param,data){return caml_call1(f,data)})}
    function copy$7(t){return map$37(t,function(_mv_){return _mv_})}
    function filter_mapi$7(t,f)
     {var new_t=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,
        function(key,data)
         {var match=caml_call2(f,key,data);
          if(! match)return 0;
          var new_data=match[1];
          return set$9(new_t,key,new_data)});
      return new_t}
    function filter_map$12(t,f)
     {return filter_mapi$7(t,function(param,data){return caml_call1(f,data)})}
    function filteri$8(t,f)
     {return filter_mapi$7
              (t,function(key,data){return caml_call2(f,key,data)?[0,data]:0})}
    function filter$12(t,f)
     {return filteri$8(t,function(param,data){return caml_call1(f,data)})}
    function filter_keys$2(t,f)
     {return filteri$8(t,function(key,param){return caml_call1(f,key)})}
    function partition_mapi$2(t,f)
     {var
       t0=create$16([0,t[4]],[0,t[2]],t[5],0),
       t1=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,
        function(key,data)
         {var match=caml_call2(f,key,data);
          if(0 === match[0])
           {var new_data=match[1];return set$9(t0,key,new_data)}
          var new_data$0=match[1];
          return set$9(t1,key,new_data$0)});
      return [0,t0,t1]}
    function partition_map$3(t,f)
     {return partition_mapi$2
              (t,function(param,data){return caml_call1(f,data)})}
    function partitioni_tf$3(t,f)
     {return partition_mapi$2
              (t,
               function(key,data)
                {return caml_call2(f,key,data)?[0,data]:[1,data]})}
    function partition_tf$7(t,f)
     {return partitioni_tf$3
              (t,function(param,data){return caml_call1(f,data)})}
    function find_or_add(t,id,default$0)
     {function _mt_(key,t,default$0)
       {var default$1=caml_call1(default$0,0);
        set$9(t,key,default$1);
        return default$1}
      return find_and_call2$0
              (t,id,t,default$0,function(data,param,_mu_){return data},_mt_)}
    function findi_or_add(t,id,default$0)
     {function _mr_(key,t,default$0)
       {var default$1=caml_call1(default$0,key);
        set$9(t,key,default$1);
        return default$1}
      return find_and_call2$0
              (t,id,t,default$0,function(data,param,_ms_){return data},_mr_)}
    function find_and_remove(t,id)
     {var result=find$16(t,id);
      if(is_some(result))remove$8(t,id);
      return result}
    function change$2(t,id,f)
     {var match=caml_call1(f,find$16(t,id));
      if(! match)return remove$8(t,id);
      var data=match[1];
      return set$9(t,id,data)}
    function update_and_return(t,id,f)
     {var data=caml_call1(f,find$16(t,id));set$9(t,id,data);return data}
    function update$2(t,id,f){update_and_return(t,id,f);return 0}
    function incr_by(remove_if_zero,t,key,by)
     {return remove_if_zero
              ?change$2
                (t,
                 key,
                 function(opt)
                  {var n=by + value(opt,0) | 0;return 0 === n?0:[0,n]})
              :update$2
                (t,
                 key,
                 function(param)
                  {if(! param)return by;var i=param[1];return by + i | 0})}
    function incr$5(opt,_mq_,t,key)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      if(_mq_)
       var sth$0=_mq_[1],remove_if_zero=sth$0;
      else
       var remove_if_zero=0;
      return incr_by(remove_if_zero,t,key,by)}
    function decr$5(opt,_mp_,t,key)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      if(_mp_)
       var sth$0=_mp_[1],remove_if_zero=sth$0;
      else
       var remove_if_zero=0;
      return incr_by(remove_if_zero,t,key,- by | 0)}
    function add_multi$2(t,key,data)
     {return update$2
              (t,
               key,
               function(param)
                {if(! param)return [0,data,0];
                 var l=param[1];
                 return [0,data,l]})}
    function remove_multi$2(t,key)
     {var match=find$16(t,key);
      if(! match)return 0;
      var _mo_=match[1];
      if(_mo_ && _mo_[2]){var tl=_mo_[2];return set$9(t,key,tl)}
      return remove$8(t,key)}
    function find_multi$2(t,key)
     {var match=find$16(t,key);if(! match)return 0;var l=match[1];return l}
    function create_mapped(growth_allowed,size,hashable,get_key,get_data,rows)
     {if(size)var s=size[1],size$0=s;else var size$0=caml_call1(length,rows);
      var res=create$16(growth_allowed,[0,size$0],hashable,0),dupes=[0,0];
      iter$0
       (rows,
        function(r)
         {var key=caml_call1(get_key,r),data=caml_call1(get_data,r);
          return mem$14(res,key)
                  ?(dupes[1] = [0,key,dupes[1]],0)
                  :set$9(res,key,data)});
      var _mn_=dupes[1];
      return _mn_?[0,175765640,dedup_and_sort(_mn_,hashable[2])]:[0,17724,res]}
    function of_alist$4(growth_allowed,size,hashable,lst)
     {var
       match=
        create_mapped(growth_allowed,size,hashable,get_key,get_data,lst);
      if(175765640 <= match[1])
       {var k=match[2];return [0,-1048878709,caml_call1(hd_exn,k)]}
      var t=match[2];
      return [0,17724,t]}
    function of_alist_report_all_dups(growth_allowed,size,hashable,lst)
     {return create_mapped(growth_allowed,size,hashable,get_key,get_data,lst)}
    function of_alist_or_error$4(growth_allowed,size,hashable,lst)
     {var match=of_alist$4(growth_allowed,size,hashable,lst);
      if(17724 <= match[1]){var v=match[2];return [0,v]}
      var key=match[2],sexp_of_key=hashable[3];
      return error$0(0,0,cst_Hashtbl_of_alist_exn_dupli,key,sexp_of_key)}
    function of_alist_exn$4(growth_allowed,size,hashable,lst)
     {var match=of_alist_or_error$4(growth_allowed,size,hashable,lst);
      if(0 === match[0]){var v=match[1];return v}
      var e=match[1];
      return raise(e)}
    function of_alist_multi$4(growth_allowed,size$0,hashable,lst)
     {if(size$0)var s=size$0[1],size=s;else var size=caml_call1(length,lst);
      var res=create$16(growth_allowed,[0,size],hashable,0);
      iter$0
       (lst,
        function(r){var key=r[1],data=r[2];return add_multi$2(res,key,data)});
      return res}
    function to_alist$2(t)
     {return fold$18
              (t,0,function(key,data,list){return [0,[0,key,data],list]})}
    function sexp_of_t$62(sexp_of_key,sexp_of_data,t)
     {var
       _mk_=to_alist$2(t),
       _ml_=
        sort
         (_mk_,
          function(param,_mm_)
           {var k2=_mm_[1],k1=param[1];return caml_call2(t[5][2],k1,k2)});
      return caml_call1
              (caml_call1
                (sexp_of_t$10,
                 caml_call2(sexp_of_pair,sexp_of_key,sexp_of_data)),
               _ml_)}
    function t_of_sexp$34(hashable,k_of_sexp,d_of_sexp,sexp)
     {var
       alist=
        caml_call2
         (t_of_sexp$10,caml_call2(pair_of_sexp,k_of_sexp,d_of_sexp),sexp),
       match=of_alist$4(0,[0,caml_call1(length,alist)],hashable,alist);
      if(17724 <= match[1]){var v=match[2];return v}
      var k=match[2];
      function _me_(_mj_){return _mj_}
      var
       alist_sexps=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,function(_mi_){return _mi_},_me_),
          sexp),
       found_first_k=[0,0];
      iter2_exn
       (alist,
        alist_sexps,
        function(param,_mf_)
         {var
           k2_sexp=_mf_[1],
           k2=param[1],
           _mg_=0 === caml_call2(hashable[2],k,k2)?1:0;
          if(_mg_)
           {if(found_first_k[1])
             return caml_call2
                     (of_sexp_error,cst_Hashtbl_t_of_sexp_duplicat,k2_sexp);
            found_first_k[1] = 1;
            var _mh_=0}
          else
           var _mh_=_mg_;
          return _mh_});
      throw [0,Assert_failure$0,_h9_]}
    function t_sexp_grammar$32(k_grammar,v_grammar)
     {var _md_=caml_call2(_aE_[3],k_grammar,v_grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_md_)}
    function to_list$13(t)
     {return fold$18(t,0,function(key,param,acc){return [0,key,acc]})}
    function data$2(t)
     {return fold$18(t,0,function(param,data,list){return [0,data,list]})}
    function group$2
     (growth_allowed,size,hashable,get_key,get_data,combine,rows)
     {var groups=create$16(growth_allowed,size,hashable,0);
      iter$0
       (rows,
        function(row)
         {var
           key=caml_call1(get_key,row),
           data=caml_call1(get_data,row),
           match=find$16(groups,key);
          if(match)
           var old=match[1],data$0=caml_call2(combine,old,data);
          else
           var data$0=data;
          return set$9(groups,key,data$0)});
      return groups}
    function create_with_key(growth_allowed,size,hashable,get_key,rows)
     {return create_mapped
              (growth_allowed,
               size,
               hashable,
               get_key,
               function(_mc_){return _mc_},
               rows)}
    function create_with_key_or_error
     (growth_allowed,size,hashable,get_key,rows)
     {var match=create_with_key(growth_allowed,size,hashable,get_key,rows);
      if(175765640 <= match[1])
       {var keys=match[2],sexp_of_key=hashable[3];
        return error_s
                (caml_call2
                  (message,
                   cst_Hashtbl_create_with_key_du,
                   [0,[0,cst_keys,caml_call2(sexp_of_t$10,sexp_of_key,keys)],0]))}
      var t=match[2];
      return [0,t]}
    function create_with_key_exn(growth_allowed,size,hashable,get_key,rows)
     {return ok_exn$0
              (create_with_key_or_error
                (growth_allowed,size,hashable,get_key,rows))}
    function maybe_set(t,key,f,d)
     {var match=caml_call2(f,key,d);
      if(! match)return 0;
      var v=match[1];
      return set$9(t,key,v)}
    function merge$6(t_left,t_right,f)
     {if(1 - caml_call2(equal$17,t_left[5],t_right[5]))
       caml_call1(invalid_arg$0,cst_Hashtbl_merge_different_ha);
      var new_t=create$16([0,t_left[4]],[0,t_left[2]],t_left[5],0);
      without_mutating
       (t_left,
        function(param)
         {return without_mutating
                  (t_right,
                   function(param)
                    {iteri$13
                      (t_left,
                       function(key,left)
                        {var match=find$16(t_right,key);
                         if(! match)return maybe_set(new_t,key,f,[0,847852583,left]);
                         var right=match[1];
                         return maybe_set(new_t,key,f,[0,737457313,[0,left,right]])});
                     return iteri$13
                             (t_right,
                              function(key,right)
                               {var match=find$16(t_left,key);
                                return match?0:maybe_set(new_t,key,f,[0,-57574468,right])})})});
      return new_t}
    function merge_into(src,dst,f)
     {return iteri$13
              (src,
               function(key,data)
                {var
                  dst_data=find$16(dst,key),
                  action=
                   without_mutating
                    (dst,
                     function(param){return caml_call3(f,key,data,dst_data)});
                 if(! action)return remove$8(dst,key);
                 var data$0=action[1];
                 if(! dst_data)return set$9(dst,key,data$0);
                 var
                  dst_data$0=dst_data[1],
                  _mb_=1 - (dst_data$0 === data$0?1:0);
                 return _mb_?set$9(dst,key,data$0):_mb_})}
    function filteri_inplace$1(t,f)
     {var
       to_remove=
        fold$18
         (t,
          0,
          function(key,data,ac){return caml_call2(f,key,data)?ac:[0,key,ac]});
      return iter$0(to_remove,function(key){return remove$8(t,key)})}
    function filter_inplace$1(t,f)
     {return filteri_inplace$1
              (t,function(param,data){return caml_call1(f,data)})}
    function filter_keys_inplace(t,f)
     {return filteri_inplace$1
              (t,function(key,param){return caml_call1(f,key)})}
    function filter_mapi_inplace(t,f)
     {var
       map_results=
        fold$18
         (t,
          0,
          function(key,data,ac){return [0,[0,key,caml_call2(f,key,data)],ac]});
      return iter$0
              (map_results,
               function(param)
                {var result=param[2],key=param[1];
                 if(! result)return remove$8(t,key);
                 var data=result[1];
                 return set$9(t,key,data)})}
    function filter_map_inplace(t,f)
     {return filter_mapi_inplace
              (t,function(param,data){return caml_call1(f,data)})}
    function mapi_inplace$0(t,f)
     {ensure_mutation_allowed(t);
      return without_mutating
              (t,
               function(param)
                {function _l$_(_ma_){return mapi_inplace(_ma_,f)}
                 return iter(t[1],_l$_)})}
    function map_inplace$0(t,f)
     {return mapi_inplace$0(t,function(param,data){return caml_call1(f,data)})}
    function similar(equal,t$0,t)
     {var _l9_=t$0[2] === t[2]?1:0;
      return _l9_
              ?with_return
                (function(r)
                  {without_mutating
                    (t,
                     function(param)
                      {return iteri$13
                               (t$0,
                                function(key,data)
                                 {var match=find$16(t,key);
                                  if(! match)return caml_call1(r,0);
                                  var data$0=match[1],_l__=1 - caml_call2(equal,data,data$0);
                                  return _l__?caml_call1(r,0):_l__})});
                   return 1})
              :_l9_}
    function Creators(Key)
     {var hashable=Key[1];
      function create(growth_allowed,size,param)
       {return create$16(growth_allowed,size,hashable,0)}
      function of_alist(growth_allowed,size,l)
       {return of_alist$4(growth_allowed,size,hashable,l)}
      function of_alist_report_all_dups$0(growth_allowed,size,l)
       {return of_alist_report_all_dups(growth_allowed,size,hashable,l)}
      function of_alist_or_error(growth_allowed,size,l)
       {return of_alist_or_error$4(growth_allowed,size,hashable,l)}
      function of_alist_exn(growth_allowed,size,l)
       {return of_alist_exn$4(growth_allowed,size,hashable,l)}
      function t_of_sexp(k_of_sexp,d_of_sexp,sexp)
       {return t_of_sexp$34(hashable,k_of_sexp,d_of_sexp,sexp)}
      function of_alist_multi(growth_allowed,size,l)
       {return of_alist_multi$4(growth_allowed,size,hashable,l)}
      function create_mapped$0(growth_allowed,size,get_key,get_data,l)
       {return create_mapped(growth_allowed,size,hashable,get_key,get_data,l)}
      function create_with_key$0(growth_allowed,size,get_key,l)
       {return create_with_key(growth_allowed,size,hashable,get_key,l)}
      function create_with_key_or_error$0(growth_allowed,size,get_key,l)
       {return create_with_key_or_error
                (growth_allowed,size,hashable,get_key,l)}
      function create_with_key_exn$0(growth_allowed,size,get_key,l)
       {return create_with_key_exn(growth_allowed,size,hashable,get_key,l)}
      function group(growth_allowed,size,get_key,get_data,combine,l)
       {return group$2
                (growth_allowed,size,hashable,get_key,get_data,combine,l)}
      return [0,
              t_of_sexp,
              create,
              of_alist,
              of_alist_report_all_dups$0,
              of_alist_or_error,
              of_alist_exn,
              of_alist_multi,
              create_mapped$0,
              create_with_key$0,
              create_with_key_or_error$0,
              create_with_key_exn$0,
              group]}
    var
     _h__=Creators([0,hashable]),
     t_of_sexp$35=_h__[1],
     create$17=_h__[2],
     of_alist$5=_h__[3],
     of_alist_report_all_dups$0=_h__[4],
     of_alist_or_error$5=_h__[5],
     of_alist_exn$5=_h__[6],
     of_alist_multi$5=_h__[7],
     create_mapped$0=_h__[8],
     create_with_key$0=_h__[9],
     create_with_key_or_error$0=_h__[10],
     create_with_key_exn$0=_h__[11],
     group$3=_h__[12];
    function hashable$11(t){return t[5]}
    var Private$5=[0,hashable$11];
    function create$18(growth_allowed,size,m)
     {return create$16(growth_allowed,size,caml_call1(of_key$0,m),0)}
    function of_alist$6(growth_allowed,size,m,l)
     {return of_alist$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_report_all_dups$1(growth_allowed,size,m,l)
     {return of_alist_report_all_dups
              (growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_or_error$6(growth_allowed,size,m,l)
     {return of_alist_or_error$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_exn$6(growth_allowed,size,m,l)
     {return of_alist_exn$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_multi$6(growth_allowed,size,m,l)
     {return of_alist_multi$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function create_mapped$1(growth_allowed,size,m,get_key,get_data,l)
     {return create_mapped
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,get_data,l)}
    function create_with_key$1(growth_allowed,size,m,get_key,l)
     {return create_with_key
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function create_with_key_or_error$1(growth_allowed,size,m,get_key,l)
     {return create_with_key_or_error
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function create_with_key_exn$1(growth_allowed,size,m,get_key,l)
     {return create_with_key_exn
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function group$4(growth_allowed,size,m,get_key,get_data,combine,l)
     {return group$2
              (growth_allowed,
               size,
               caml_call1(of_key$0,m),
               get_key,
               get_data,
               combine,
               l)}
    function hashable_s(t){return caml_call1(to_key$0,t[5])}
    function M$1(K){return [0]}
    function sexp_of_m_t$1(K)
     {return function(sexp_of_v,t){return sexp_of_t$62(K[1],sexp_of_v,t)}}
    function m_t_of_sexp$1(K)
     {return function(v_of_sexp,sexp)
       {var _l8_=K[1];
        return t_of_sexp$34
                (caml_call1(of_key$0,[0,K[2],K[3],K[4]]),_l8_,v_of_sexp,sexp)}}
    function m_t_sexp_grammar$1(K)
     {return function(v_grammar){return t_sexp_grammar$32(K[1],v_grammar)}}
    function equal_m_t$1(param,equal_v,t1,t2){return similar(equal_v,t1,t2)}
    var
     _h$_=
      [0,
       t_of_sexp$35,
       sexp_of_t$62,
       t_sexp_grammar$32,
       hashable,
       invariant$24,
       create$17,
       of_alist$5,
       of_alist_report_all_dups$0,
       of_alist_or_error$5,
       of_alist_exn$5,
       of_alist_multi$5,
       create_mapped$0,
       create_with_key$0,
       create_with_key_or_error$0,
       create_with_key_exn$0,
       group$3,
       sexp_of_key,
       clear$3,
       copy$7,
       fold$18,
       iter_keys$2,
       iter$23,
       iteri$13,
       existsi$10,
       exists$15,
       for_alli$10,
       for_all$15,
       counti$10,
       count$14,
       length$22,
       is_empty$15,
       mem$14,
       remove$8,
       choose$2,
       choose_exn$3,
       set$9,
       add$8,
       add_exn$3,
       change$2,
       update$2,
       update_and_return,
       map$37,
       mapi$11,
       filter_map$12,
       filter_mapi$7,
       filter_keys$2,
       filter$12,
       filteri$8,
       partition_map$3,
       partition_mapi$2,
       partition_tf$7,
       partitioni_tf$3,
       find_or_add,
       findi_or_add,
       find$16,
       find_exn$9,
       find_and_call$0,
       find_and_call1$0,
       find_and_call2$0,
       findi_and_call$0,
       findi_and_call1$0,
       findi_and_call2$0,
       find_and_remove,
       merge$6,
       merge_into,
       to_list$13,
       data$2,
       filter_keys_inplace,
       filter_inplace$1,
       filteri_inplace$1,
       map_inplace$0,
       mapi_inplace$0,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist$2,
       incr$5,
       decr$5,
       add_multi$2,
       remove_multi$2,
       find_multi$2],
     Base_Hashtbl=
      [0,
       hash$5,
       hash_param$0,
       sexp_of_t$62,
       create$18,
       of_alist$6,
       of_alist_report_all_dups$1,
       of_alist_or_error$6,
       of_alist_exn$6,
       of_alist_multi$6,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$4,
       sexp_of_key,
       clear$3,
       copy$7,
       fold$18,
       iter_keys$2,
       iter$23,
       iteri$13,
       existsi$10,
       exists$15,
       for_alli$10,
       for_all$15,
       counti$10,
       count$14,
       length$22,
       is_empty$15,
       mem$14,
       remove$8,
       choose$2,
       choose_exn$3,
       set$9,
       add$8,
       add_exn$3,
       change$2,
       update$2,
       update_and_return,
       map$37,
       mapi$11,
       filter_map$12,
       filter_mapi$7,
       filter_keys$2,
       filter$12,
       filteri$8,
       partition_map$3,
       partition_mapi$2,
       partition_tf$7,
       partitioni_tf$3,
       find_or_add,
       findi_or_add,
       find$16,
       find_exn$9,
       find_and_call$0,
       find_and_call1$0,
       find_and_call2$0,
       findi_and_call$0,
       findi_and_call1$0,
       findi_and_call2$0,
       find_and_remove,
       merge$6,
       merge_into,
       to_list$13,
       data$2,
       filter_keys_inplace,
       filter_inplace$1,
       filteri_inplace$1,
       map_inplace$0,
       mapi_inplace$0,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist$2,
       incr$5,
       decr$5,
       add_multi$2,
       remove_multi$2,
       find_multi$2,
       hashable_s,
       invariant$24,
       Creators,
       _h$_,
       M$1,
       sexp_of_m_t$1,
       m_t_of_sexp$1,
       m_t_sexp_grammar$1,
       equal_m_t$1,
       Private$5];
    caml_register_global(1126,Base_Hashtbl,"Base__Hashtbl");
    var Base_Hash_set_intf=[0];
    caml_register_global(1127,Base_Hash_set_intf,"Base__Hash_set_intf");
    var hashable$12=Private$5[1],poly_hashable=_h$_[4];
    function is_empty$16(t){return is_empty$15(t)}
    function find_map$11(t,f)
     {return with_return
              (function(r)
                {iter_keys$2
                  (t,
                   function(elt)
                    {var o=caml_call1(f,elt);return o?caml_call1(r,o):0});
                 return 0})}
    function find$17(t,f)
     {return find_map$11(t,function(a){return caml_call1(f,a)?[0,a]:0})}
    function add$9(t,k){return set$9(t,k,0)}
    function strict_add(t,k)
     {return mem$14(t,k)
              ?error_string(cst_element_already_exists)
              :(set$9(t,k,0),_ia_)}
    function strict_add_exn(t,k){return ok_exn$0(strict_add(t,k))}
    function strict_remove(t,k)
     {return mem$14(t,k)
              ?(remove$8(t,k),_ib_)
              :error$0(0,0,cst_element_not_in_set,k,sexp_of_key(t))}
    function strict_remove_exn(t,k){return ok_exn$0(strict_remove(t,k))}
    function fold$19(t,init,f)
     {return fold$18
              (t,init,function(key,param,acc){return caml_call2(f,acc,key)})}
    function iter$24(t,f){return iter_keys$2(t,f)}
    function count$15(t,f){return count(fold$19,t,f)}
    function sum$11(m,t,f){return caml_call2(sum(fold$19,m),t,f)}
    function min_elt$15(t,compare){return min_elt(fold$19,t,compare)}
    function max_elt$15(t,compare){return max_elt(fold$19,t,compare)}
    function fold_result$10(t,init,f){return fold_result(fold$19,init,f,t)}
    function fold_until$14(t,init,f)
     {return function(_l7_){return fold_until(fold$19,init,f,_l7_,t)}}
    function sexp_of_t$63(sexp_of_e,t)
     {var _l6_=to_list$13(t);
      return caml_call2
              (sexp_of_t$10,sexp_of_e,sort(_l6_,caml_call1(hashable$12,t)[2]))}
    function to_array$12(t)
     {var len=t[2],index=[0,len - 1 | 0];
      return fold$19
              (t,
               [0],
               function(acc,key)
                {if(0 === acc.length - 1)return caml_make_vect(len,key);
                 index[1] = index[1] - 1 | 0;
                 var _l5_=index[1];
                 caml_check_bound(acc,_l5_)[1 + _l5_] = key;
                 return acc})}
    function exists$16(t,f)
     {return existsi$10(t,function(key,param){return caml_call1(f,key)})}
    function for_all$16(t,f)
     {return 1
             -
             existsi$10(t,function(key,param){return 1 - caml_call1(f,key)})}
    function equal$47(t1,t2)
     {return similar(function(param,_l4_){return 1},t1,t2)}
    function copy$8(t){return copy$7(t)}
    function filter$13(t,f)
     {return filteri$8(t,function(key,param){return caml_call1(f,key)})}
    function union$2(t1,t2)
     {return merge$6(t1,t2,function(param,_l3_){return _ic_})}
    function diff$2(t1,t2)
     {return filter$13(t1,function(key){return 1 - mem$14(t2,key)})}
    function inter$2(t1,t2)
     {if(t2[2] < t1[2])var larger=t1,smaller=t2;else var larger=t2,smaller=t1;
      return filteri$8(smaller,function(key,param){return mem$14(larger,key)})}
    function filter_inplace$2(t,f)
     {var
       to_remove=
        fold$19(t,0,function(ac,x){return caml_call1(f,x)?ac:[0,x,ac]});
      return iter$0(to_remove,function(x){return remove$8(t,x)})}
    function of_hashtbl_keys(hashtbl)
     {return map$37(hashtbl,function(_l2_){return 0})}
    function to_hashtbl(t,f)
     {return mapi$11(t,function(key,param){return caml_call1(f,key)})}
    function create$19(growth_allowed,size,m)
     {return create$18(growth_allowed,size,m)}
    function of_list$11(growth_allowed,size,m,l)
     {if(size)var x=size[1],size$0=x;else var size$0=caml_call1(length,l);
      var t=create$18(growth_allowed,[0,size$0],m);
      iter$0(l,function(k){return add$9(t,k)});
      return t}
    function t_of_sexp$36(m,e_of_sexp,sexp)
     {if(0 === sexp[0])
       return caml_call2(of_sexp_error,cst_Hash_set_t_of_sexp_require,sexp);
      var list=sexp[1],t=create$19(0,[0,caml_call1(length,list)],m);
      iter$0
       (list,
        function(sexp)
         {var e=caml_call1(e_of_sexp,sexp),match=strict_add(t,e);
          return 0 === match[0]
                  ?0
                  :caml_call2
                    (of_sexp_error,cst_Hash_set_t_of_sexp_got_a_d,sexp)});
      return t}
    function Creators$0(Elt)
     {function create(growth_allowed,size,param)
       {return create$19(growth_allowed,size,caml_call1(to_key$0,Elt[1]))}
      function of_list(growth_allowed,size,l)
       {return of_list$11(growth_allowed,size,caml_call1(to_key$0,Elt[1]),l)}
      function t_of_sexp(e_of_sexp,sexp)
       {return t_of_sexp$36(caml_call1(to_key$0,Elt[1]),e_of_sexp,sexp)}
      return [0,t_of_sexp,create,of_list]}
    var
     _id_=Creators$0([0,poly_hashable]),
     t_of_sexp$37=_id_[1],
     create$20=_id_[2],
     of_list$12=_id_[3];
    function t_sexp_grammar$33(grammar)
     {var _l1_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_l1_)}
    function M$2(Elt){return [0]}
    function sexp_of_m_t$2(Elt)
     {return function(t){return sexp_of_t$63(Elt[1],t)}}
    function m_t_of_sexp$2(Elt)
     {return function(sexp)
       {return t_of_sexp$36([0,Elt[2],Elt[3],Elt[4]],Elt[1],sexp)}}
    function m_t_sexp_grammar$2(Elt)
     {var _l0_=caml_call1(list_sexp_grammar,Elt[1]);
      return caml_call1(Sexplib0_Sexp_grammar[1],_l0_)}
    function equal_m_t$2(param,t1,t2){return equal$47(t1,t2)}
    var
     hashable$13=Private$5[1],
     Private$6=[0,hashable$13],
     Base_Hash_set=
      [0,
       sexp_of_t$63,
       create$19,
       of_list$11,
       length$22,
       is_empty$16,
       iter$24,
       fold$19,
       fold_result$10,
       fold_until$14,
       exists$16,
       for_all$16,
       count$15,
       sum$11,
       find$17,
       find_map$11,
       to_list$13,
       to_array$12,
       min_elt$15,
       max_elt$15,
       mem$14,
       copy$8,
       add$9,
       strict_add,
       strict_add_exn,
       remove$8,
       strict_remove,
       strict_remove_exn,
       clear$3,
       equal$47,
       filter$13,
       filter_inplace$2,
       inter$2,
       union$2,
       diff$2,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$37,
        sexp_of_t$63,
        t_sexp_grammar$33,
        create$20,
        of_list$12,
        length$22,
        is_empty$16,
        iter$24,
        fold$19,
        fold_result$10,
        fold_until$14,
        exists$16,
        for_all$16,
        count$15,
        sum$11,
        find$17,
        find_map$11,
        to_list$13,
        to_array$12,
        min_elt$15,
        max_elt$15,
        mem$14,
        copy$8,
        add$9,
        strict_add,
        strict_add_exn,
        remove$8,
        strict_remove,
        strict_remove_exn,
        clear$3,
        equal$47,
        filter$13,
        filter_inplace$2,
        inter$2,
        union$2,
        diff$2,
        of_hashtbl_keys,
        to_hashtbl],
       Creators$0,
       M$2,
       sexp_of_m_t$2,
       m_t_of_sexp$2,
       m_t_sexp_grammar$2,
       equal_m_t$2,
       Private$6];
    caml_register_global(1128,Base_Hash_set,"Base__Hash_set");
    function hash$24(x){return caml_call1(specialized_hash,x)}
    var
     hashable$14=[0,hash$24,compare$33,sexp_of_t$5],
     compare$62=include$7[9],
     include$86=_P_([0,compare$62,sexp_of_t$5]),
     _ie_=include$86[1];
    function invariant$25(param){return 0}
    function to_float$5(x){return x}
    function of_float$4(x){return x}
    function of_string$24(s)
     {try
       {var _lY_=caml_float_of_string(s);return _lY_}
      catch(_lZ_){return caml_call2(invalid_argf(_if_),s,0)}}
    function to_string$26(x)
     {var
       y=caml_format_float(cst_15g,x),
       _lX_=caml_float_of_string(y),
       y$0=caml_call2(include$7[4],_lX_,x)?y:caml_format_float(cst_17g,x),
       l=caml_ml_string_length(y$0),
       i=0;
      for(;;)
       {if(l <= i)return caml_call2(symbol$59,y$0,cst$37);
        var match=caml_string_get(y$0,i),switch$0=0;
        if(48 <= match)
         {if(58 > match)switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(! switch$0)return y$0;
        var i$0=i + 1 | 0,i=i$0}}
    var
     min_positive_subnormal_value=4.94065645841e-324,
     min_positive_normal_value=2.22507385850720138e-308,
     zero$6=0.,
     one$5=1.,
     minus_one$4=-1.,
     pi=3.14159265358979312,
     sqrt_pi=1.7724538509055161,
     sqrt_2pi=2.50662827463100069,
     euler=0.577215664901532866;
    function of_int63(i){return _gc_(i)}
    function of_int64$0(i){return caml_int64_to_float(i)}
    var
     to_int64$1=caml_int64_of_float,
     iround_lbound=lower_bound_for_int(num_bits),
     iround_ubound=upper_bound_for_int(num_bits);
    function iround_up(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,iround_lbound)?[0,t | 0]:0;
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,iround_ubound)?[0,t$0 | 0]:0}
    function iround_up_exn(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,iround_lbound)
               ?t | 0
               :caml_call2(invalid_argf(_ih_),t + 0.,0);
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,iround_ubound)
              ?t$0 | 0
              :caml_call2(invalid_argf(_ig_),t + 0.,0)}
    function iround_down(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,iround_ubound)?[0,t | 0]:0;
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,iround_lbound)?[0,t$0 | 0]:0}
    function iround_down_exn(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,iround_ubound)
               ?t | 0
               :caml_call2(invalid_argf(_ii_),t + 0.,0);
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,iround_lbound)
              ?t$0 | 0
              :caml_call2(invalid_argf(_ij_),t + 0.,0)}
    function iround_towards_zero(t)
     {if
       (caml_call2(include$7[6],t,iround_lbound)
        &&
        caml_call2(include$7[2],t,iround_ubound))
       return [0,t | 0];
      return 0}
    function iround_towards_zero_exn(t)
     {if
       (caml_call2(include$7[6],t,iround_lbound)
        &&
        caml_call2(include$7[2],t,iround_ubound))
       return t | 0;
      return caml_call2(invalid_argf(_ik_),t + 0.,0)}
    var
     one_ulp_less_than_half=one_ulp(759637122,0.5),
     round_nearest_lb=-4503599627370496.,
     round_nearest_ub=4503599627370496.;
    function add_half_for_round_nearest(t)
     {var
       _lW_=
        caml_call2(include$7[4],t,one_ulp_less_than_half)
         ?one_ulp_less_than_half
         :0.5;
      return t + _lW_}
    function iround_nearest_32(t)
     {if(caml_call2(include$7[6],t,0.))
       {var t$0=add_half_for_round_nearest(t);
        return caml_call2(include$7[2],t$0,iround_ubound)?[0,t$0 | 0]:0}
      var t$1=Math.floor(t + 0.5);
      return caml_call2(include$7[6],t$1,iround_lbound)?[0,t$1 | 0]:0}
    function iround_nearest_64(t)
     {return caml_call2(include$7[6],t,0.)
              ?caml_call2(include$7[1],t,round_nearest_ub)
                ?[0,add_half_for_round_nearest(t) | 0]
                :caml_call2(include$7[2],t,iround_ubound)?[0,t | 0]:0
              :caml_call2(include$7[5],t,round_nearest_lb)
                ?[0,Math.floor(t + 0.5) | 0]
                :caml_call2(include$7[6],t,iround_lbound)?[0,t | 0]:0}
    var iround_nearest_64$0=word_size?iround_nearest_64:iround_nearest_32;
    function iround_nearest_exn_32(t)
     {if(caml_call2(include$7[6],t,0.))
       {var t$0=add_half_for_round_nearest(t);
        return caml_call2(include$7[2],t$0,iround_ubound)
                ?t$0 | 0
                :caml_call2(invalid_argf(_il_),t + 0.,0)}
      var t$1=Math.floor(t + 0.5);
      return caml_call2(include$7[6],t$1,iround_lbound)
              ?t$1 | 0
              :caml_call2(invalid_argf(_im_),t + 0.,0)}
    function iround_nearest_exn_64(t)
     {return caml_call2(include$7[6],t,0.)
              ?caml_call2(include$7[1],t,round_nearest_ub)
                ?add_half_for_round_nearest(t) | 0
                :caml_call2(include$7[2],t,iround_ubound)
                  ?t | 0
                  :caml_call2(invalid_argf(_in_),t + 0.,0)
              :caml_call2(include$7[5],t,round_nearest_lb)
                ?Math.floor(t + 0.5) | 0
                :caml_call2(include$7[6],t,iround_lbound)
                  ?t | 0
                  :caml_call2(invalid_argf(_io_),t + 0.,0)}
    var
     iround_nearest_exn=
      word_size?iround_nearest_exn_64:iround_nearest_exn_32;
    function iround_exn(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      return 857423934 <= dir
              ?1003109192 <= dir
                ?iround_towards_zero_exn(t)
                :iround_nearest_exn(t)
              :759637122 <= dir?iround_down_exn(t):iround_up_exn(t)}
    function iround(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      try
       {var _lU_=[0,iround_exn([0,dir],t)];return _lU_}
      catch(_lV_){return 0}}
    function is_inf(t){return caml_call2(include$7[4],1. / t,0.)}
    function is_finite(t){return caml_call2(include$7[4],t - t,0.)}
    function min_inan(x,y)
     {return is_nan(y)?x:is_nan(x)?y:caml_call2(include$7[1],x,y)?x:y}
    function max_inan(x,y)
     {return is_nan(y)?x:is_nan(x)?y:caml_call2(include$7[5],x,y)?x:y}
    function square(x){return x * x}
    function fractional(t){return t[1]}
    function integral(t){return t[2]}
    function round_towards_zero$4(t)
     {return caml_call2(include$7[6],t,0.)?Math.floor(t):Math.ceil(t)}
    function round_nearest_inline(t)
     {if
       (caml_call2(include$7[5],t,round_nearest_lb)
        &&
        caml_call2(include$7[1],t,round_nearest_ub))
       return Math.floor(add_half_for_round_nearest(t));
      return t + 0.}
    function round_nearest$4(t){return round_nearest_inline(t)}
    function round_nearest_half_to_even(t)
     {if
       (!
        caml_call2(include$7[2],t,round_nearest_lb)
        &&
        !
        caml_call2(include$7[6],t,round_nearest_ub))
       {var
         floor=Math.floor(t),
         ceil_or_succ=floor + 1.,
         diff_floor=t - floor,
         diff_ceil=ceil_or_succ - t;
        return caml_call2(include$7[1],diff_floor,diff_ceil)
                ?floor
                :caml_call2(include$7[5],diff_floor,diff_ceil)
                  ?ceil_or_succ
                  :caml_call2(include$7[4],floor % 2.,0.)?floor:ceil_or_succ}
      return t + 0.}
    var
     int63_round_lbound=lower_bound_for_int(_hr_),
     int63_round_ubound=upper_bound_for_int(_hr_);
    function int63_round_up_exn(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,int63_round_lbound)
               ?_hP_(t)
               :caml_call2(invalid_argf(_iq_),t + 0.,0);
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,int63_round_ubound)
              ?_hP_(t$0)
              :caml_call2(invalid_argf(_ip_),t + 0.,0)}
    function int63_round_down_exn(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,int63_round_ubound)
               ?_hP_(t)
               :caml_call2(invalid_argf(_ir_),t + 0.,0);
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,int63_round_lbound)
              ?_hP_(t$0)
              :caml_call2(invalid_argf(_is_),t + 0.,0)}
    function int63_round_nearest_portable_a(t0)
     {var t=round_nearest_inline(t0);
      return caml_call2(include$7[5],t,0.)
              ?caml_call2(include$7[2],t,int63_round_ubound)
                ?_hP_(t)
                :caml_call2(invalid_argf(_it_),t0 + 0.,0)
              :caml_call2(include$7[6],t,int63_round_lbound)
                ?_hP_(t)
                :caml_call2(invalid_argf(_iu_),t0 + 0.,0)}
    function int63_round_nearest_arch64_noa(f)
     {return _hD_(iround_nearest_exn(f))}
    var
     int63_round_nearest_exn=
      word_size?int63_round_nearest_arch64_noa:int63_round_nearest_portable_a;
    function round$4(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      return 857423934 <= dir
              ?1003109192 <= dir?round_towards_zero$4(t):round_nearest$4(t)
              :759637122 <= dir?Math.floor(t):Math.ceil(t)}
    var compare$63=caml_int_compare;
    function t_of_sexp$38(sexp_007)
     {if(0 === sexp_007[0])
       {var
         _lO_=sexp_007[1],
         _lP_=caml_string_compare(_lO_,cst_infinite),
         switch$0=0;
        if(0 <= _lP_)
         if(0 < _lP_)
          if(caml_string_notequal(_lO_,cst_nan$1))
           if(caml_string_notequal(_lO_,cst_normal))
            if(caml_string_notequal(_lO_,cst_subnormal))
             {if(! caml_string_notequal(_lO_,cst_zero$3))switch$0 = 5}
            else
             switch$0 = 4;
           else
            switch$0 = 3;
          else
           switch$0 = 2;
         else
          switch$0 = 1;
        else
         if(caml_string_notequal(_lO_,cst_Infinite))
          if(caml_string_notequal(_lO_,cst_Nan$1))
           if(caml_string_notequal(_lO_,cst_Normal))
            if(caml_string_notequal(_lO_,cst_Subnormal))
             {if(! caml_string_notequal(_lO_,cst_Zero$3))switch$0 = 5}
            else
             switch$0 = 4;
           else
            switch$0 = 3;
          else
           switch$0 = 2;
         else
          switch$0 = 1;
        switch(switch$0)
         {case 1:return 0;
          case 2:return 1;
          case 3:return 2;
          case 4:return 3;
          case 5:return 4
          }}
      else
       {var _lQ_=sexp_007[1];
        if(! _lQ_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_006$0,sexp_007);
        var _lR_=_lQ_[1];
        if(0 !== _lR_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_006$0,sexp_007);
        var
         _lS_=_lR_[1],
         _lT_=caml_string_compare(_lS_,cst_infinite$0),
         switch$1=0;
        if(0 <= _lT_)
         if(0 < _lT_)
          if(caml_string_notequal(_lS_,cst_nan$2))
           if(caml_string_notequal(_lS_,cst_normal$0))
            if(caml_string_notequal(_lS_,cst_subnormal$0))
             {if(! caml_string_notequal(_lS_,cst_zero$4))switch$1 = 5}
            else
             switch$1 = 4;
           else
            switch$1 = 3;
          else
           switch$1 = 2;
         else
          switch$1 = 1;
        else
         if(caml_string_notequal(_lS_,cst_Infinite$0))
          if(caml_string_notequal(_lS_,cst_Nan$2))
           if(caml_string_notequal(_lS_,cst_Normal$0))
            if(caml_string_notequal(_lS_,cst_Subnormal$0))
             {if(! caml_string_notequal(_lS_,cst_Zero$4))switch$1 = 5}
            else
             switch$1 = 4;
           else
            switch$1 = 3;
          else
           switch$1 = 2;
         else
          switch$1 = 1;
        switch(switch$1)
         {case 1:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 2:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 3:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 4:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 5:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007)
          }}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_006$0,sexp_007)}
    function sexp_of_t$64(param)
     {switch(param)
       {case 0:return _iv_;
        case 1:return _iw_;
        case 2:return _ix_;
        case 3:return _iy_;
        default:return _iz_}}
    function to_string$27(t){return caml_call1(t_of_sexp$2,sexp_of_t$64(t))}
    function of_string$25(s){return t_of_sexp$38(caml_call1(sexp_of_t$2,s))}
    function classify(t)
     {var match=caml_classify_float(t);
      switch(match)
       {case 0:return 2;
        case 1:return 3;
        case 2:return 4;
        case 3:return 0;
        default:return 1}}
    function insert_underscores$0(opt,_lN_,string)
     {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
      if(_lN_)var sth$0=_lN_[1],strip_zero=sth$0;else var strip_zero=0;
      var match=lsplit2(string,46);
      if(! match)return insert_delimiter(string,delimiter);
      var
       match$0=match[1],
       right=match$0[2],
       left=match$0[1],
       left$0=insert_delimiter(left,delimiter),
       right$0=
        strip_zero
         ?rstrip([0,function(c){return caml_call2(symbol$107,c,48)}],right)
         :right;
      return caml_string_notequal(right$0,cst$38)
              ?caml_call2
                (symbol$59,left$0,caml_call2(symbol$59,cst$39,right$0))
              :left$0}
    function to_string_hum$6(delimiter,opt,strip_zero,_lM_,f)
     {if(opt)var sth=opt[1],decimals=sth;else var decimals=3;
      if(_lM_)var sth$0=_lM_[1],explicit_plus=sth$0;else var explicit_plus=0;
      if(decimals < 0)caml_call2(invalid_argf(_iA_),decimals,0);
      var match=classify(f);
      if(1 === match)return cst_nan$3;
      if(! match)return caml_call2(include$7[5],f,0.)?cst_inf:cst_inf$0;
      var
       s=
        explicit_plus
         ?caml_call3(sprintf,_iB_,decimals,f)
         :caml_call3(sprintf,_iC_,decimals,f);
      return insert_underscores$0(delimiter,strip_zero,s)}
    function sexp_of_float(t)
     {var sexp=caml_call1(sexp_of_t$5,t);
      if(1009018843 <= of_float_style[1])return sexp;
      if(0 !== sexp[0])
       return raise_s
               (caml_call2
                 (message,
                  cst_sexp_of_float_produced_str,
                  [0,[0,cst_sexp,caml_call1(sexp_of_t,sexp)],0]));
      var string=sexp[1];
      return contains(0,0,string,69)?sexp:[0,insert_underscores$0(0,0,string)]}
    function to_padded_compact_string_custo
     (t,opt,kilo,mega,giga,tera,peta,param)
     {if(opt)var sth=opt[1],prefix=sth;else var prefix=cst$41;
      var match=classify(t);
      if(1 === match)return cst_nan$4;
      if(! match)return caml_call2(include$7[1],t,0.)?cst_inf$1:cst_inf$2;
      function go(t)
       {function conv(mag,t,denominator)
         {var switch$0=0;
          if
           (caml_call2(include$7[4],denominator,100.)
            &&
            caml_call2(include$7[6],t,999.95))
           switch$0 = 1;
          if(! switch$0)
           {var switch$1=0;
            if(caml_call2(include$7[6],denominator,100000.))
             {var _lL_=round_nearest$4(denominator * 9.9995);
              if(! caml_call2(include$7[6],t,_lL_))switch$1 = 1}
            else
             switch$1 = 1;
            if(switch$1)throw [0,Assert_failure$0,_iJ_]}
          var _lK_=round_nearest$4(denominator * 9999.5);
          if(! caml_call2(include$7[1],t,_lK_))
           throw [0,Assert_failure$0,_iI_];
          var
           k=Math.floor(t / denominator),
           lower=denominator * k,
           higher=denominator * (k + 1.),
           diff_right=higher - t,
           diff_left=t - lower,
           k$0=iround_nearest_exn(k),
           k$1=
            caml_call2(include$7[1],diff_right,diff_left)
             ?k$0 + 1 | 0
             :caml_call2(include$7[5],diff_right,diff_left)
               ?k$0
               :0 === (k$0 % 2 | 0)?k$0:k$0 + 1 | 0,
           d=k$1 % 10 | 0,
           i=k$1 / 10 | 0;
          if(0 <= i && 1000 > i)
           {if(0 <= d && 10 > d)
             return 0 === d
                     ?caml_call4(sprintf,_iG_,prefix,i,mag)
                     :caml_call5(sprintf,_iH_,prefix,i,mag,d);
            throw [0,Assert_failure$0,_iF_]}
          throw [0,Assert_failure$0,_iE_]}
        if(! caml_call2(include$7[1],t,999.95))
         {if(caml_call2(include$7[1],t,999950.))return conv(kilo,t,100.);
          if(caml_call2(include$7[1],t,999950000.))
           return conv(mega,t,100000.);
          if(caml_call2(include$7[1],t,999950000000.))
           return conv(giga,t,100000000.);
          if(caml_call2(include$7[1],t,999950000000000.))
           return conv(tera,t,100000000000.);
          if(! peta)return caml_call3(sprintf,_iL_,prefix,t);
          var peta$0=peta[1];
          return caml_call2(include$7[1],t,999950000000000000.)
                  ?conv(peta$0,t,100000000000000.)
                  :caml_call3(sprintf,_iK_,prefix,t)}
        if(caml_call2(include$7[2],0.,t) && caml_call2(include$7[1],t,999.95))
         {var x=caml_call2(symbol$59,prefix,caml_format_float(cst_1f,t));
          if(! is_suffix$1(x,cst_0))return x;
          var x$0=caml_call1(of_string$1,x),n=caml_ml_bytes_length(x$0);
          caml_bytes_set(x$0,n - 1 | 0,32);
          caml_bytes_set(x$0,n - 2 | 0,32);
          return unsafe_to_string(x$0)}
        throw [0,Assert_failure$0,_iD_]}
      return caml_call2(include$7[6],t,0.)
              ?go(t)
              :caml_call2(symbol$59,cst$40,go(- t))}
    function to_padded_compact_string(t)
     {return to_padded_compact_string_custo
              (t,0,cst_k,cst_m,cst_g,cst_t$3,_iM_,0)}
    function int_pow$0(x,n)
     {if(0 === n)return 1.;
      var x$0=[0,x - 0.],n$0=[0,n],accum=[0,1.];
      if(n$0[1] < 0)
       {x$0[1] = 1. / x$0[1];
        n$0[1] = - n$0[1] | 0;
        if(n$0[1] < 0){accum[1] = x$0[1];decr(n$0)}}
      for(;;)
       {if(1 >= n$0[1])return x$0[1] * accum[1];
        if(0 !== (n$0[1] & 1))accum[1] = x$0[1] * accum[1];
        x$0[1] = x$0[1] * x$0[1];
        n$0[1] = n$0[1] >>> 1 | 0}}
    function round_gen(x,how)
     {if(caml_call2(include$7[4],x,0.))return 0.;
      if(! is_finite(x))return x;
      if(555917426 <= how[1])
       var
        sd=how[2],
        dd=sd - to_int$3(Math.ceil(caml_log10_float(Math.abs(x)))) | 0,
        dd$0=dd,
        sd$0=sd;
      else
       var
        dd$1=how[2],
        sd$1=dd$1 + to_int$3(Math.ceil(caml_log10_float(Math.abs(x)))) | 0,
        dd$0=dd$1,
        sd$0=sd$1;
      if(0 > sd$0)return 0.;
      if(17 <= sd$0)return x;
      var abs_dd=abs$2(dd$0);
      if(22 >= abs_dd && 16 > sd$0)
       {var order=int_pow$0(10.,abs_dd);
        return 0 <= dd$0
                ?round_nearest_half_to_even(x * order) / order
                :round_nearest_half_to_even(x / order) * order}
      return of_string$24(caml_call3(sprintf,_iN_,sd$0,x))}
    function round_significant(x,significant_digits)
     {return 0 < significant_digits
              ?round_gen(x,[0,555917426,significant_digits])
              :caml_call2(invalid_argf(_iO_),significant_digits,0)}
    function round_decimal(x,decimal_digits)
     {return round_gen(x,[0,-352548012,decimal_digits])}
    function between$16(t,low,high)
     {var _lJ_=caml_call2(include$7[2],low,t);
      return _lJ_?caml_call2(include$7[2],t,high):_lJ_}
    function clamp_exn$16(t,min,max)
     {if(caml_call2(include$7[2],min,max))return clamp_unchecked(t,min,max);
      throw [0,Assert_failure$0,_iP_]}
    function clamp$16(t,min,max)
     {if(caml_call2(include$7[2],min,max))
       return [0,clamp_unchecked(t,min,max)];
      var _lI_=[0,[0,cst_max$9,caml_call1(sexp_of_t$5,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$9,
                 [0,[0,cst_min$9,caml_call1(sexp_of_t$5,min)],_lI_]))}
    function sign_exn(t)
     {return caml_call2(include$7[5],t,0.)
              ?2
              :caml_call2(include$7[1],t,0.)
                ?0
                :caml_call2(include$7[4],t,0.)
                  ?1
                  :raise_s
                    (caml_call2
                      (message,
                       cst_Float_sign_exn_of_NAN,
                       [0,[0,cst$42,sexp_of_float(t)],0]))}
    function sign_or_nan(t)
     {return caml_call2(include$7[5],t,0.)
              ?2
              :caml_call2(include$7[1],t,0.)
                ?0
                :caml_call2(include$7[4],t,0.)?1:3}
    function ieee_negative(t)
     {var bits=caml_int64_bits_of_float(t);
      return caml_lessthan(bits,Stdlib_Int64[1])}
    var
     exponent_mask64=caml_int64_sub(caml_int64_shift_left(one$1,11),one$1),
     exponent_mask=int64_to_int_exn(exponent_mask64),
     mantissa_mask=_gP_(_hh_(_gM_,52),_gM_),
     mantissa_mask64=_ho_(mantissa_mask);
    function ieee_exponent(t)
     {var bits=caml_int64_bits_of_float(t);
      return caml_int64_to_int32
              (caml_int64_and
                (caml_int64_shift_right_unsigne(bits,52),exponent_mask64))}
    function ieee_mantissa(t)
     {var bits=caml_int64_bits_of_float(t);
      return _hn_(caml_int64_and(bits,mantissa_mask64))}
    function create_ieee_exn(negative,exponent,mantissa)
     {if((exponent & exponent_mask) !== exponent)
       return caml_call3(failwithf(_iQ_),exponent,exponent_mask,0);
      if(_gq_(_hc_(mantissa,mantissa_mask),mantissa))
       {var
         _lG_=caml_call1(_gk_,mantissa_mask),
         _lH_=caml_call1(_gk_,mantissa);
        return caml_call3(failwithf(_iR_),_lH_,_lG_,0)}
      var
       sign_bits=negative?Stdlib_Int64[10]:Stdlib_Int64[1],
       expt_bits=caml_int64_shift_left(caml_int64_of_int32(exponent),52),
       mant_bits=_ho_(mantissa),
       bits=caml_int64_or(sign_bits,caml_int64_or(expt_bits,mant_bits));
      return caml_int64_float_of_bits(bits)}
    function create_ieee(negative,exponent,mantissa)
     {return try_with$0
              (0,
               function(param)
                {return create_ieee_exn(negative,exponent,mantissa)})}
    function to_string$28(x){return caml_call2(sprintf,_iS_,x)}
    function sexp_of_t$65(x){return [0,to_string$28(x)]}
    function of_string$26(x){return of_string$24(x)}
    var
     include$87=_aY_([0,compare$62,sexp_of_t$5,zero$6]),
     sign$4=include$87[5];
    function is_positive$4(t){return caml_call2(include$7[5],t,0.)}
    function is_non_negative$4(t){return caml_call2(include$7[6],t,0.)}
    function is_negative$4(t){return caml_call2(include$7[1],t,0.)}
    function is_non_positive$4(t){return caml_call2(include$7[2],t,0.)}
    var
     include$88=_w_([0,module_name$20,to_string$26]),
     pp$19=include$88[1],
     symbol$238=include$7[3],
     symbol$239=include$7[1],
     symbol$240=include$7[5],
     symbol$241=include$7[4],
     symbol$242=include$7[2],
     symbol$243=include$7[6];
    function of_float$5(x){return x}
    var
     Private$7=
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
     symbol$244=include$7[1],
     symbol$245=include$7[2],
     symbol$246=include$7[3],
     symbol$247=include$7[4],
     symbol$248=include$7[5],
     symbol$249=include$7[6],
     ascending$29=include$7[7],
     descending$30=include$7[8],
     compare_float$1=include$7[9],
     equal_float$1=include$7[10];
    function min$36(x,y)
     {if(! caml_call2(symbol$244,x,y) && ! is_nan(x))return y;return x}
    function max$37(x,y)
     {if(! caml_call2(symbol$248,x,y) && ! is_nan(x))return y;return x}
    var
     include$89=[0,add,sub,scale,symbol$9,symbol$85,symbol$84,neg$0],
     Base_Float=
      [0,
       t_sexp_grammar$4,
       of_float$4,
       to_float$5,
       hash_fold_t$7,
       hash$24,
       t_of_sexp$5,
       sexp_of_float,
       of_string$24,
       symbol$249,
       symbol$245,
       symbol$247,
       symbol$248,
       symbol$244,
       symbol$246,
       equal_float$1,
       compare_float$1,
       min$36,
       max$37,
       ascending$29,
       descending$30,
       between$16,
       clamp_exn$16,
       clamp$16,
       _ie_,
       pp$19,
       hashable$14,
       is_positive$4,
       is_non_negative$4,
       is_negative$4,
       is_non_positive$4,
       invariant$25,
       nan$1,
       infinity$1,
       neg_infinity$1,
       infinity$1,
       neg_infinity$1,
       zero$6,
       one$5,
       minus_one$4,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float$1,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int$2,
       to_int$3,
       of_int63,
       of_int64$0,
       to_int64$1,
       round$4,
       iround,
       iround_exn,
       round_towards_zero$4,
       floor,
       ceil,
       round_nearest$4,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       add,
       sub,
       symbol$9,
       symbol$85,
       scale,
       symbol$84,
       neg$0,
       [0,fractional,integral],
       modf,
       mod_float,
       add,
       sub,
       neg$0,
       scale,
       abs_float,
       [0,
        add,
        sub,
        scale,
        symbol$9,
        symbol$85,
        symbol$84,
        neg$0,
        symbol$243,
        symbol$242,
        symbol$241,
        symbol$240,
        symbol$239,
        symbol$238,
        abs_float,
        neg$0,
        zero$6,
        of_int$2,
        of_float$5],
       include$89,
       to_string$26,
       to_string_hum$6,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow$0,
       square,
       ldexp,
       frexp,
       [0,
        compare$63,
        all$21,
        t_of_sexp$38,
        sexp_of_t$64,
        t_sexp_grammar$34,
        of_string$25,
        to_string$27],
       classify,
       sign$4,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0,t_of_sexp$5,sexp_of_t$65,t_sexp_grammar$4,of_string$26,to_string$28],
       Private$7];
    caml_register_global(1129,Base_Float,"Base__Float");
    var Base_Fieldslib=[0];
    caml_register_global(1130,Base_Fieldslib,"Base__Fieldslib");
    var Base_Buffer_intf=[0];
    caml_register_global(1131,Base_Buffer_intf,"Base__Buffer_intf");
    var
     create$21=Stdlib_Buffer[1],
     contents=Stdlib_Buffer[2],
     to_bytes=Stdlib_Buffer[3],
     nth$8=Stdlib_Buffer[6],
     length$23=Stdlib_Buffer[7],
     clear$4=Stdlib_Buffer[8],
     reset$0=Stdlib_Buffer[9],
     add_char=Stdlib_Buffer[12],
     add_string=Stdlib_Buffer[16],
     add_bytes=Stdlib_Buffer[17],
     add_buffer=Stdlib_Buffer[21],
     _iT_=Stdlib_Buffer[18],
     _iU_=Stdlib_Buffer[19];
    function add_substring(t,s,pos,len){return caml_call4(_iT_,t,s,pos,len)}
    function add_subbytes(t,s,pos,len){return caml_call4(_iU_,t,s,pos,len)}
    function sexp_of_t$66(t)
     {return caml_call1(sexp_of_t$2,caml_call1(contents,t))}
    var create$22=caml_create_bytes,length$24=caml_ml_bytes_length;
    function unsafe_blit$9(src,src_pos,dst,dst_pos,len)
     {return caml_call5(Stdlib_Buffer[5],src,src_pos,dst,dst_pos,len)}
    var
     To_bytes$0=_a5_([0,length$23],[0,length$24,create$22,unsafe_blit$9]),
     blit$6=To_bytes$0[1],
     blito$4=To_bytes$0[2],
     unsafe_blit$10=To_bytes$0[3],
     sub$11=To_bytes$0[4],
     subo$5=To_bytes$0[5],
     To_string$0=Make_to_string([0],To_bytes$0),
     Base_Buffer=
      [0,
       sexp_of_t$66,
       create$21,
       contents,
       to_bytes,
       blit$6,
       blito$4,
       unsafe_blit$10,
       sub$11,
       subo$5,
       To_string$0,
       nth$8,
       length$23,
       clear$4,
       reset$0,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
    caml_register_global(1133,Base_Buffer,"Base__Buffer");
    var elide=[0,0];
    function get$6(opt,param)
     {if(opt)
       var sth=opt[1],at_most_num_frames=sth;
      else
       var at_most_num_frames=max_value$2;
      return runtime.caml_get_current_callstack(at_most_num_frames)}
    function to_string$29(t)
     {return elide[1]?elided_message:caml_call1(Stdlib_Printexc[14],t)}
    function to_string_list(t){return split_lines(to_string$29(t))}
    function sexp_of_t$67(t)
     {function _lF_(x){return [0,x]}return [1,map$9(to_string_list(t),_lF_)]}
    var set_recording=Stdlib_Printexc[7],am_recording=Stdlib_Printexc[8];
    function most_recent(param){return caml_call1(Stdlib_Printexc[12],0)}
    function most_recent_for_exn(exn)
     {return runtime.Base_caml_exn_is_most_recent_exn(exn)
              ?[0,most_recent(0)]
              :0}
    function with_recording(b,f)
     {var saved=caml_call1(am_recording,0);
      caml_call1(set_recording,b);
      return protect
              (f,function(param){return caml_call1(set_recording,saved)})}
    function initialize_module$0(param)
     {var match=getenv(cst_OCAMLRUNPARAM);
      if(match)
       var
        x=match[1],
        _lC_=function(_lE_){return is_prefix$1(_lE_,cst_b)},
        ocamlrunparam_mentions_backtra=exists(split(x,44),_lC_);
      else
       var ocamlrunparam_mentions_backtra=0;
      var _lD_=1 - ocamlrunparam_mentions_backtra;
      return _lD_?caml_call1(set_recording,1):_lD_}
    var
     Base_Backtrace=
      [0,
       sexp_of_t$67,
       get$6,
       to_string$29,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module$0];
    caml_register_global(1134,Base_Backtrace,"Base__Backtrace");
    var
     Exit$1=include$0[3],
     Not_found$1=include$0[4],
     max_int$1=include$0[8],
     min_int$1=include$0[9],
     infinity$2=include$0[11],
     neg_infinity$2=include$0[12],
     nan$2=include$0[13],
     max_float$1=include$0[14],
     min_float$1=include$0[15],
     epsilon_float$2=include$0[16],
     char_of_int$1=include$0[18],
     string_of_bool$1=include$0[19],
     bool_of_string_opt$1=include$0[20],
     bool_of_string$1=include$0[21],
     string_of_int$1=include$0[22],
     int_of_string_opt$1=include$0[23],
     string_of_float$1=include$0[24],
     float_of_string_opt$1=include$0[25],
     stdin$1=include$0[27],
     stdout$1=include$0[28],
     stderr$1=include$0[29],
     print_char$1=include$0[30],
     print_string$1=include$0[31],
     print_bytes$1=include$0[32],
     print_int$1=include$0[33],
     print_float$1=include$0[34],
     print_endline$1=include$0[35],
     print_newline$1=include$0[36],
     prerr_char$1=include$0[37],
     prerr_string$1=include$0[38],
     prerr_bytes$1=include$0[39],
     prerr_int$1=include$0[40],
     prerr_float$1=include$0[41],
     prerr_endline$1=include$0[42],
     prerr_newline$1=include$0[43],
     read_line$1=include$0[44],
     read_int_opt$1=include$0[45],
     read_int$1=include$0[46],
     read_float_opt$1=include$0[47],
     read_float$1=include$0[48],
     open_out$1=include$0[49],
     open_out_bin$1=include$0[50],
     open_out_gen$1=include$0[51],
     flush$1=include$0[52],
     flush_all$1=include$0[53],
     output_char$1=include$0[54],
     output_string$1=include$0[55],
     output_bytes$1=include$0[56],
     output$1=include$0[57],
     output_substring$1=include$0[58],
     output_byte$1=include$0[59],
     output_binary_int$1=include$0[60],
     output_value$1=include$0[61],
     seek_out$1=include$0[62],
     pos_out$1=include$0[63],
     out_channel_length$1=include$0[64],
     close_out$1=include$0[65],
     close_out_noerr$1=include$0[66],
     set_binary_mode_out$1=include$0[67],
     open_in$1=include$0[68],
     open_in_bin$1=include$0[69],
     open_in_gen$1=include$0[70],
     input_char$1=include$0[71],
     input_line$1=include$0[72],
     input$1=include$0[73],
     really_input$1=include$0[74],
     really_input_string$1=include$0[75],
     input_byte$1=include$0[76],
     input_binary_int$1=include$0[77],
     input_value$1=include$0[78],
     seek_in$1=include$0[79],
     pos_in$1=include$0[80],
     in_channel_length$1=include$0[81],
     close_in$1=include$0[82],
     close_in_noerr$1=include$0[83],
     set_binary_mode_in$1=include$0[84],
     string_of_format$1=include$0[85],
     symbol$250=include$0[86],
     exit$1=include$0[87],
     at_exit$1=include$0[88],
     valid_float_lexem$1=include$0[89],
     unsafe_really_input$1=include$0[90],
     do_at_exit$1=include$0[91],
     Sexp$0=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string$0,
       symbol$159,
       symbol$160,
       symbol$161,
       symbol$162,
       symbol$163,
       symbol$164,
       equal$29,
       compare$44,
       min$29,
       max$29,
       ascending$23,
       descending$23,
       between$9,
       clamp_exn$9,
       clamp$9,
       comparator$11],
     Exported_for_specific_uses=[0,am_testing];
    function array_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$20(a_sexp_grammar)}
    function hash_bool$0(x){return hash$22(x)}
    function hash_char(x){return caml_call1(_bE_,x)}
    function hash_float(x){return hash$24(x)}
    function hash_int$0(x){return func$8(x)}
    function hash_int32$0(x){return func$12(x)}
    function hash_int64$0(x){return func$10(x)}
    function list_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$12(a_sexp_grammar)}
    function hash_nativeint$0(x){return func$9(x)}
    function option_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$18(a_sexp_grammar)}
    function ref_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$28(a_sexp_grammar)}
    function hash_string$0(x){return runtime.Base_hash_string(x)}
    function hash_unit$0(x){return caml_call1(func$7,x)}
    var
     symbol$251=Infix[1],
     symbol$252=O$0[1],
     lnot$5=O$0[2],
     abs$8=O$0[3],
     zero$7=O$0[4],
     symbol$253=O$0[5],
     symbol$254=O$0[6],
     symbol$255=O$0[7],
     ascending$30=include$1[1],
     descending$31=include$1[2],
     max$38=include$1[3],
     min$37=include$1[4],
     symbol$256=include$89[1],
     symbol$257=include$89[2],
     symbol$258=include$89[3],
     symbol$259=include$89[4],
     symbol$260=include$89[5],
     symbol$261=include$89[6],
     symbol$262=include$89[7],
     Export$1=
      [0,
       compare_array$0,
       equal_array$1,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$1,
       hash_fold_t$5,
       hash_bool$0,
       t_of_sexp$1,
       sexp_of_t$1,
       t_sexp_grammar$0,
       compare_char$0,
       equal_char$1,
       _bD_,
       hash_char,
       _bF_,
       _bG_,
       t_sexp_grammar$2,
       sexp_of_exn,
       compare_float$1,
       equal_float$1,
       hash_fold_t$7,
       hash_float,
       t_of_sexp$5,
       sexp_of_float,
       t_sexp_grammar$4,
       compare_int$0,
       equal_int$1,
       hash_fold_t$4,
       hash_int$0,
       t_of_sexp$4,
       sexp_of_t$33,
       t_sexp_grammar$3,
       compare_int32$0,
       equal_int32$1,
       hash_fold_t$2,
       hash_int32$0,
       t_of_sexp$6,
       sexp_of_int32,
       t_sexp_grammar$5,
       compare_int64$0,
       equal_int64$1,
       hash_fold_t$1,
       hash_int64$0,
       t_of_sexp$7,
       sexp_of_int64,
       t_sexp_grammar$6,
       compare_list$1,
       equal_list$1,
       hash_fold_t$9,
       t_of_sexp$10,
       sexp_of_t$10,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$1,
       hash_fold_t$0,
       hash_nativeint$0,
       t_of_sexp$8,
       sexp_of_t$53,
       t_sexp_grammar$7,
       compare_option$0,
       equal_option$1,
       hash_fold_option$0,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar$0,
       compare_string$1,
       equal_string$1,
       hash_fold_t$6,
       hash_string$0,
       t_of_sexp$2,
       sexp_of_t$2,
       t_sexp_grammar$1,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit$1,
       equal_unit$1,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$251,
       symbol$252,
       lnot$5,
       abs$8,
       zero$7,
       symbol$253,
       symbol$254,
       symbol$255,
       ascending$30,
       descending$31,
       max$38,
       min$37,
       symbol$256,
       symbol$257,
       symbol$258,
       symbol$259,
       symbol$260,
       symbol$261,
       symbol$262,
       symbol$59,
       get_key,
       get_data,
       failwith$0,
       invalid_arg$0,
       raise_s,
       phys_equal],
     _iV_=Export$1[1],
     _iW_=Export$1[2],
     _iX_=Export$1[3],
     _iY_=Export$1[4],
     _iZ_=Export$1[5],
     _i0_=Export$1[6],
     _i1_=Export$1[7],
     _i2_=Export$1[8],
     _i3_=Export$1[9],
     _i4_=Export$1[10],
     _i5_=Export$1[11],
     _i6_=Export$1[12],
     _i7_=Export$1[13],
     _i8_=Export$1[14],
     _i9_=Export$1[15],
     _i__=Export$1[16],
     _i$_=Export$1[17],
     _ja_=Export$1[18],
     _jb_=Export$1[19],
     _jc_=Export$1[20],
     _jd_=Export$1[21],
     _je_=Export$1[22],
     _jf_=Export$1[23],
     _jg_=Export$1[24],
     _jh_=Export$1[25],
     _ji_=Export$1[26],
     _jj_=Export$1[27],
     _jk_=Export$1[28],
     _jl_=Export$1[29],
     _jm_=Export$1[30],
     _jn_=Export$1[31],
     _jo_=Export$1[32],
     _jp_=Export$1[33],
     _jq_=Export$1[34],
     _jr_=Export$1[35],
     _js_=Export$1[36],
     _jt_=Export$1[37],
     _ju_=Export$1[38],
     _jv_=Export$1[39],
     _jw_=Export$1[40],
     _jx_=Export$1[41],
     _jy_=Export$1[42],
     _jz_=Export$1[43],
     _jA_=Export$1[44],
     _jB_=Export$1[45],
     _jC_=Export$1[46],
     _jD_=Export$1[47],
     _jE_=Export$1[48],
     _jF_=Export$1[49],
     _jG_=Export$1[50],
     _jH_=Export$1[51],
     _jI_=Export$1[52],
     _jJ_=Export$1[53],
     _jK_=Export$1[54],
     _jL_=Export$1[55],
     _jM_=Export$1[56],
     _jN_=Export$1[57],
     _jO_=Export$1[58],
     _jP_=Export$1[59],
     _jQ_=Export$1[60],
     _jR_=Export$1[61],
     _jS_=Export$1[62],
     _jT_=Export$1[63],
     _jU_=Export$1[64],
     _jV_=Export$1[65],
     _jW_=Export$1[66],
     _jX_=Export$1[67],
     _jY_=Export$1[68],
     _jZ_=Export$1[69],
     _j0_=Export$1[70],
     _j1_=Export$1[71],
     _j2_=Export$1[72],
     _j3_=Export$1[73],
     _j4_=Export$1[74],
     _j5_=Export$1[75],
     _j6_=Export$1[76],
     _j7_=Export$1[77],
     _j8_=Export$1[78],
     _j9_=Export$1[79],
     _j__=Export$1[80],
     _j$_=Export$1[81],
     _ka_=Export$1[82],
     _kb_=Export$1[83],
     _kc_=Export$1[84],
     _kd_=Export$1[85],
     _ke_=Export$1[86],
     _kf_=Export$1[87],
     _kg_=Export$1[88],
     _kh_=Export$1[89],
     _ki_=Export$1[90],
     _kj_=Export$1[91],
     _kk_=Export$1[92],
     _kl_=Export$1[93],
     _km_=Export$1[94],
     _kn_=Export$1[95],
     _ko_=Export$1[96],
     _kp_=Export$1[97],
     _kq_=Export$1[98],
     _kr_=Export$1[99],
     _ks_=Export$1[100],
     _kt_=Export$1[101],
     _ku_=Export$1[102],
     _kv_=Export$1[103],
     _kw_=Export$1[104],
     _kx_=Export$1[105],
     _ky_=Export$1[106],
     _kz_=Export$1[107],
     _kA_=Export$1[108],
     _kB_=Export$1[109],
     _kC_=Export$1[110],
     _kD_=Export$1[111],
     _kE_=Export$1[112],
     _kF_=Export$1[113],
     _kG_=Export$1[114],
     _kH_=Export$1[115],
     _kI_=Export$1[116],
     _kJ_=Export$1[117],
     _kK_=include$27[1];
    initialize_module$0(0);
    var
     Base$0=
      [0,
       Exit$1,
       Not_found$1,
       max_int$1,
       min_int$1,
       infinity$2,
       neg_infinity$2,
       nan$2,
       max_float$1,
       min_float$1,
       epsilon_float$2,
       char_of_int$1,
       string_of_bool$1,
       bool_of_string_opt$1,
       bool_of_string$1,
       string_of_int$1,
       int_of_string_opt$1,
       string_of_float$1,
       float_of_string_opt$1,
       stdin$1,
       stdout$1,
       stderr$1,
       print_char$1,
       print_string$1,
       print_bytes$1,
       print_int$1,
       print_float$1,
       print_endline$1,
       print_newline$1,
       prerr_char$1,
       prerr_string$1,
       prerr_bytes$1,
       prerr_int$1,
       prerr_float$1,
       prerr_endline$1,
       prerr_newline$1,
       read_line$1,
       read_int_opt$1,
       read_int$1,
       read_float_opt$1,
       read_float$1,
       open_out$1,
       open_out_bin$1,
       open_out_gen$1,
       flush$1,
       flush_all$1,
       output_char$1,
       output_string$1,
       output_bytes$1,
       output$1,
       output_substring$1,
       output_byte$1,
       output_binary_int$1,
       output_value$1,
       seek_out$1,
       pos_out$1,
       out_channel_length$1,
       close_out$1,
       close_out_noerr$1,
       set_binary_mode_out$1,
       open_in$1,
       open_in_bin$1,
       open_in_gen$1,
       input_char$1,
       input_line$1,
       input$1,
       really_input$1,
       really_input_string$1,
       input_byte$1,
       input_binary_int$1,
       input_value$1,
       seek_in$1,
       pos_in$1,
       in_channel_length$1,
       close_in$1,
       close_in_noerr$1,
       set_binary_mode_in$1,
       string_of_format$1,
       symbol$250,
       exit$1,
       at_exit$1,
       valid_float_lexem$1,
       unsafe_really_input$1,
       do_at_exit$1,
       Sexp$0,
       Exported_for_specific_uses,
       Export$1,
       _iV_,
       _iW_,
       _iX_,
       _iY_,
       _iZ_,
       _i0_,
       _i1_,
       _i2_,
       _i3_,
       _i4_,
       _i5_,
       _i6_,
       _i7_,
       _i8_,
       _i9_,
       _i__,
       _i$_,
       _ja_,
       _jb_,
       _jc_,
       _jd_,
       _je_,
       _jf_,
       _jg_,
       _jh_,
       _ji_,
       _jj_,
       _jk_,
       _jl_,
       _jm_,
       _jn_,
       _jo_,
       _jp_,
       _jq_,
       _jr_,
       _js_,
       _jt_,
       _ju_,
       _jv_,
       _jw_,
       _jx_,
       _jy_,
       _jz_,
       _jA_,
       _jB_,
       _jC_,
       _jD_,
       _jE_,
       _jF_,
       _jG_,
       _jH_,
       _jI_,
       _jJ_,
       _jK_,
       _jL_,
       _jM_,
       _jN_,
       _jO_,
       _jP_,
       _jQ_,
       _jR_,
       _jS_,
       _jT_,
       _jU_,
       _jV_,
       _jW_,
       _jX_,
       _jY_,
       _jZ_,
       _j0_,
       _j1_,
       _j2_,
       _j3_,
       _j4_,
       _j5_,
       _j6_,
       _j7_,
       _j8_,
       _j9_,
       _j__,
       _j$_,
       _ka_,
       _kb_,
       _kc_,
       _kd_,
       _ke_,
       _kf_,
       _kg_,
       _kh_,
       _ki_,
       _kj_,
       _kk_,
       _kl_,
       _km_,
       _kn_,
       _ko_,
       _kp_,
       _kq_,
       _kr_,
       _ks_,
       _kt_,
       _ku_,
       _kv_,
       _kw_,
       _kx_,
       _ky_,
       _kz_,
       _kA_,
       _kB_,
       _kC_,
       _kD_,
       _kE_,
       _kF_,
       _kG_,
       _kH_,
       _kI_,
       _kJ_,
       _kK_,
       Not_found_s];
    caml_register_global(1135,Base$0,"Base");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJtb2R1bGVfbmFtZSIsImVycm9yX3NvdXJjZV8wMTEiLCJlcnJvcl9zb3VyY2VfMDA1IiwiYWxsJDMiLCJlcnJvcl9zb3VyY2VfMDA1JDAiLCJ0X3NleHBfZ3JhbW1hciQxMSIsImVycm9yX3NvdXJjZV8wMjIiLCJ0X3NleHBfZ3JhbW1hciQxNCIsIm1vZHVsZV9uYW1lJDAiLCJ0X3NleHBfZ3JhbW1hciQxNSIsIm1vZHVsZV9uYW1lJDEiLCJlcnJvcl9zb3VyY2VfMDAzIiwidF9zZXhwX2dyYW1tYXIkMTciLCJhbGwkNiIsIm1vZHVsZV9uYW1lJDIiLCJhbGwkNyIsIm1vZHVsZV9uYW1lJDMiLCJhbGwkOCIsImFsbCQ5IiwiZXJyb3Jfc291cmNlXzAyNSIsIm1vZHVsZV9uYW1lJDQiLCJtb2R1bGVfbmFtZSQ1Iiwib2NhbWxfbGV4X3RhYmxlcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbiIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSIsIm0xIiwibTIiLCJtNCIsImgwMSIsIm1hc2siLCJtb2R1bGVfbmFtZSQ2IiwibW9kdWxlX25hbWUkNyIsIm1vZHVsZV9uYW1lJDgiLCJzb21lX3QiLCJlcnJvcl9zb3VyY2VfMDAzJDAiLCJ0X3NleHBfZ3JhbW1hciQyNSIsImFsbCQxNCIsIm1vZHVsZV9uYW1lJDkiLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImVycm9yX3NvdXJjZV8wNTciLCJhbGwkMTYiLCJhbGwkMTciLCJ0X3NleHBfZ3JhbW1hciQzMCIsIm1vZHVsZV9uYW1lJDEwIiwibW9kdWxlX25hbWUkMTEiLCJtb2R1bGVfbmFtZSQxMiIsImVtcHR5JDUiLCJuYW1lJDEiLCJuYW1lJDIiLCJtb2R1bGVfbmFtZSQxMyIsIm1vZHVsZV9uYW1lJDE0IiwibWFzayQwIiwibW9kdWxlX25hbWUkMTUiLCJtb2R1bGVfbmFtZSQxNiIsImFsbCQyMCIsIm1vZHVsZV9uYW1lJDE3IiwibW9kdWxlX25hbWUkMTgiLCJtb2R1bGVfbmFtZSQxOSIsImFsbCQyMSIsImVycm9yX3NvdXJjZV8wMDYkMCIsInRfc2V4cF9ncmFtbWFyJDM0IiwibW9kdWxlX25hbWUkMjAiLCJlbGlkZWRfbWVzc2FnZSIsIngiLCJ5Iiwic2NhbGUiLCJhZGQiLCJzdWIiLCJzeW1ib2wkOSIsInN5bWJvbCQ1OSIsIm5lZyIsIm5lZyQwIiwiZmFpbHdpdGgkMCIsImdldF9rZXkiLCJpbnZhbGlkX2FyZyQwIiwiZ2V0X2RhdGEiLCJwaHlzX2VxdWFsIiwiYW1fdGVzdGluZyIsImZhaWx3aXRoZiIsImZtdCIsInMiLCJpbnZhbGlkX2FyZ2YiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImJpZ19lbmRpYW4iLCJtYXhfbGVuZ3RoJDAiLCJydW50aW1lX3ZhcmlhbnQiLCJydW50aW1lX3BhcmFtZXRlcnMiLCJhcmd2IiwiZ2V0X2FyZ3YiLCJvY2FtbF92ZXJzaW9uIiwiZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJnZXRlbnZfZXhuIiwidmFyJDAiLCJnZXRlbnYiLCJjcmVhdGUiLCJsZW4iLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImluaXQiLCJtYWtlX21hdHJpeCIsIm9mX2xpc3QiLCJzdWIkMCIsInRvX2xpc3QiLCJmb2xkIiwidCIsImYiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0IiwiY29tcGFyZSIsInN3YXAiLCJpIiwiaiIsImVsdF9pIiwiZWx0X2oiLCJ0b19pbnQiLCJ1bnNhZmVfb2ZfaW50IiwiaW50X2lzX29rIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwib2ZfaW50Iiwib2ZfaW50X2V4biIsImVxdWFsJDciLCJ0MSIsInQyIiwib2Zfc3RyaW5nIiwidG9fZmxvYXQiLCJvZl9mbG9hdCIsIm1heF92YWx1ZSQwIiwibWluX3ZhbHVlJDAiLCJzdWNjIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkX2xlZnQiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIkMCIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0IiwibCIsInN0YWJsZV9zb3J0JDAiLCJyZXYiLCJyZXMiLCJyZXN0IiwiZm9sZF9yaWdodCQwIiwiYSIsImIiLCJoYXNoX2ZvbGRfdW5pdCIsImFzX2ludCIsImhhc2hfZm9sZF9pbnQzMiIsImhhc2hfZm9sZF9jaGFyIiwiaGFzaF9mb2xkX2Jvb2wiLCJoYXNoX2ZvbGRfbmF0aXZlaW50IiwiaGFzaF9mb2xkX29wdGlvbiIsImhhc2hfZm9sZF9lbGVtIiwiaGFzaF9mb2xkX2xpc3QiLCJzJDEiLCJsaXN0JDAiLCJzJDIiLCJsaXN0IiwieHMiLCJzJDAiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiYXJyYXkiLCJlIiwiaSQwIiwiaGFzaF9uYXRpdmVpbnQiLCJoYXNoX2ludDY0IiwiaGFzaF9pbnQzMiIsImhhc2hfY2hhciIsImhhc2hfaW50IiwiaGFzaF9ib29sIiwiaGFzaF9zdHJpbmciLCJoYXNoX2Zsb2F0IiwiaGFzaF91bml0Iiwic2VlZCIsIm9mX2ZvbGQiLCJoYXNoX2ZvbGRfdCIsInJ1biIsImZvbGRlciIsIm9wdCIsInN0aCIsImNvbXBhcmVfc3RhdGUiLCJzdGF0ZV90b19zdHJpbmciLCJzdGF0ZSIsImNyZWF0ZSQwIiwidCQwIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwibGVuX2EiLCJsZW5fYiIsInJldCIsInIiLCJjb21wYXJlX2xpc3QiLCJhJDAiLCJiJDAiLCJ5cyIsImNvbXBhcmVfb3B0aW9uIiwiY29tcGFyZV9yZWYiLCJlcXVhbF9ib29sIiwiZXF1YWxfY2hhciIsImVxdWFsX2ludCIsImVxdWFsX2ludDMyIiwiZXF1YWxfaW50NjQiLCJlcXVhbF9uYXRpdmVpbnQiLCJlcXVhbF9zdHJpbmciLCJlcXVhbF91bml0IiwiZXF1YWxfZmxvYXQiLCJlcXVhbF9hcnJheSIsImVxdWFsX2VsdCIsImVxdWFsX2xpc3QiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9yZWYiLCJjb21wYXJlJDciLCJhXzAwMSIsImJfMDAyIiwiYl8wMDQiLCJiXzAwNiIsImhzdiIsImFyZyIsImEwIiwiaHN2JDAiLCJhMCQwIiwiaHN2JDEiLCJzZXhwX29mX3QkMCIsInNleHBfb2ZfdCQxIiwic2V4cF9vZl90JDIiLCJzZXhwX29mX2J5dGVzIiwic2V4cF9vZl90JDMiLCJzZXhwX29mX3QkNCIsInNleHBfb2ZfdCQ1Iiwic2V4cF9vZl90JDYiLCJzZXhwX29mX3QkNyIsInNleHBfb2ZfdCQ4Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX3QkOSIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl90JDEwIiwic2V4cF9vZl9hcnJheSIsInRfb2Zfc2V4cCQwIiwidF9vZl9zZXhwJDEiLCJ0X29mX3NleHAkMiIsImJ5dGVzX29mX3NleHAiLCJ0X29mX3NleHAkMyIsInRfb2Zfc2V4cCQ1IiwidF9vZl9zZXhwJDYiLCJ0X29mX3NleHAkNyIsInRfb2Zfc2V4cCQ4IiwicmVmX29mX3NleHAiLCJ0X29mX3NleHAkOSIsIm9wdGlvbl9vZl9zZXhwIiwidF9vZl9zZXhwJDEwIiwiYXJyYXlfb2Zfc2V4cCIsInVuaXRfc2V4cF9ncmFtbWFyIiwidF9zZXhwX2dyYW1tYXIkMCIsInRfc2V4cF9ncmFtbWFyJDEiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJ0X3NleHBfZ3JhbW1hciQyIiwidF9zZXhwX2dyYW1tYXIkNCIsInRfc2V4cF9ncmFtbWFyJDUiLCJ0X3NleHBfZ3JhbW1hciQ2IiwidF9zZXhwX2dyYW1tYXIkNyIsInNleHBfb2ZfZXhuIiwiaGFzaF9mb2xkX3QkMCIsImhhc2hfZm9sZF90JDEiLCJoYXNoX2ZvbGRfdCQyIiwiaGFzaF9mb2xkX3QkMyIsImhhc2hfZm9sZF90JDUiLCJoYXNoX2ZvbGRfdCQ2IiwiaGFzaF9mb2xkX3QkNyIsImhhc2hfZm9sZF90JDgiLCJoYXNoX2ZvbGRfb3B0aW9uJDAiLCJoYXNoX2ZvbGRfdCQ5IiwiZnVuYyIsImZ1bmMkMCIsImZ1bmMkMSIsImZ1bmMkMiIsImZ1bmMkMyIsImZ1bmMkNCIsImZ1bmMkNSIsInNwZWNpYWxpemVkX2hhc2giLCJmdW5jJDYiLCJjb21wYXJlJDgiLCJjb21wYXJlJDkiLCJjb21wYXJlJDEwIiwiY29tcGFyZSQxMSIsImNvbXBhcmUkMTIiLCJjb21wYXJlJDEzIiwiY29tcGFyZV9hcnJheSQwIiwiY29tcGFyZV9vcHRpb24kMCIsImNvbXBhcmVfcmVmJDAiLCJlcXVhbF9yZWYkMCIsInNleHBfb2ZfdCQxMSIsIm51bV9iaXRzJDAiLCJ3b3JkX3NpemUiLCJhbGwiLCJyZWdpc3RlciIsInAiLCJwcCIsImZvcm1hdHRlciIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA3IiwicmVzMV8wMDgiLCJjcmVhdGVfcyIsInNleHAiLCJyYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInJlcmFpc2UiLCJleG4iLCJzdHIiLCJleG4kMCIsImJ0IiwicmVyYWlzZWYiLCJleGMiLCJmb3JtYXQiLCJ0b19zdHJpbmckMSIsInRvX3N0cmluZ19tYWNoJDAiLCJwcm90ZWN0eCIsImZpbmFsbHkkMCIsImZpbmFsX2V4biIsInByb3RlY3QiLCJkb2VzX3JhaXNlIiwicHAkMCIsInBwZiIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJkb19hdF9leGl0IiwiZXhpdCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsInJlcmFpc2VfdW5jYXVnaHQiLCJyYWlzZV93aXRob3V0X2JhY2t0cmFjZSIsImluaXRpYWxpemVfbW9kdWxlIiwiY2xlYXJfYmFja3RyYWNlIiwid2l0aF9yZXR1cm4iLCJpc19hbGl2ZSIsInJldHVybiQwIiwid2l0aF9yZXR1cm5fb3B0aW9uIiwicHJlcGVuZCIsInBhcmFtIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiYmluZCIsImpvaW4iLCJpZ25vcmVfbSIsImFsbF91bml0IiwibWFwX3ZpYV9iaW5kIiwibWEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sX2JpbmQkMSIsInN5bWJvbF9tYXAkMSIsImJvdGgiLCJsb29wIiwidnMiLCJ0cyIsInYiLCJtYXAkMCIsImJpbmQkMCIsInJldHVybiQxIiwibWFwJDEiLCJhbGwkMCIsInRvX21vbmFkIiwib2ZfbW9uYWQiLCJkZXJpdmVkX21hcCIsIm1hcDIiLCJ0YSIsInRiIiwibWFwMyIsInRjIiwic3ltYm9sIiwidSIsInN5bWJvbCQwIiwidGYiLCJmYWIiLCJjIiwic3ltYm9sJDEiLCJhcHBseSIsIm1mIiwibXgiLCJ0eCIsImN1c3RvbV9tYXAiLCJhcHBseSQwIiwibWFrZSQwIiwic2V4cF9vZl90IiwiY29tcGFyYXRvciIsImNvbXBhcmUkMTUiLCJzZXhwX29mX3QkMTIiLCJjb21wYXJlJDE2IiwiY21wX2YiLCJjbXBfcyIsImhhc2hfZm9sZF90JDEwIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCQxMSIsIm9mX2ZfMDA3Iiwib2Zfc18wMDgiLCJzZXhwXzAxMyIsInNleHBfYXJnc18wMjAiLCJhcmcwXzAyMSIsInJlczBfMDIyIiwic2V4cF9hcmdzXzAxNSIsImFyZzBfMDE2IiwicmVzMF8wMTciLCJzZXhwX29mX3QkMTMiLCJvZl9mXzAyNSIsIm9mX3NfMDI2IiwiYXJnMF8wMjciLCJyZXMwXzAyOCIsImFyZzBfMDI5IiwicmVzMF8wMzAiLCJ0X3NleHBfZ3JhbW1hciQ4IiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwibWFwJDMiLCJmaWVsZCIsInVwZGF0ZXIiLCJjYXBpdGFsaXplIiwiY29tcGFyZSQxNyIsImNvcHkkMSIsImVzY2FwZWQiLCJsb3dlcmNhc2UiLCJtYWtlJDEiLCJzdWIkMiIsInVuY2FwaXRhbGl6ZSIsInVuc2FmZV9ibGl0JDAiLCJ1cHBlcmNhc2UiLCJjb25jYXQkMCIsInNlcCIsIml0ZXIkMSIsImNvbXBhcmUkMTgiLCJuIiwibiQwIiwibiQxIiwiaGFzaF9mb2xkX3QkMTEiLCJoc3YkMiIsImhhc2gkMCIsInNleHBfb2ZfdCQxNCIsInBvc19jbnVtXzAxMCIsInBvc19ib2xfMDA4IiwicG9zX2xudW1fMDA2IiwicG9zX2ZuYW1lXzAwNCIsImFyZ18wMTEiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJibmRzXzAwMyQwIiwiYXJnXzAwNyIsImJuZHNfMDAzJDEiLCJhcmdfMDA1IiwiYm5kc18wMDMkMiIsImNvbXBhcmUkMTkiLCJoYXNoX2ZvbGRfdCQxMiIsImhhc2gkMSIsIm1ha2VfbG9jYXRpb25fc3RyaW5nIiwicG9zX2ZuYW1lIiwicG9zX2xudW0iLCJwb3NfY251bSIsInBvc19ib2wiLCJ0b19zdHJpbmckMyIsInNleHBfb2ZfdCQxNSIsImlzX2VtcHR5IiwicGFydGl0aW9uX21hcCIsImZzdCIsInNuZCIsImZzdCQwIiwieSQwIiwic25kJDAiLCJ0X29mX3NleHAkMTIiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJzZXhwX2FyZ3NfMDA5IiwiYXJnMF8wMTAiLCJyZXMwXzAxMSIsInNleHBfYXJnc18wMTQiLCJhcmcwXzAxNSIsInJlczBfMDE2Iiwic2V4cF9vZl90JDE2Iiwib2ZfYV8wMTkiLCJvZl9iXzAyMCIsImFyZzBfMDIzIiwicmVzMF8wMjQiLCJ0X3NleHBfZ3JhbW1hciQ5IiwiYV9zZXhwX2dyYW1tYXIiLCJiX3NleHBfZ3JhbW1hciIsImNvbXBhcmUkMjAiLCJjbXBfYSIsImNtcF9iIiwiYV8wMjciLCJiXzAyOCIsImJfMDMwIiwiYl8wMzIiLCJlcXVhbCQ5IiwiYV8wMzMiLCJiXzAzNCIsImJfMDM2IiwiYl8wMzgiLCJoYXNoX2ZvbGRfdCQxMyIsImhhc2hfZm9sZF9hIiwiaGFzaF9mb2xkX2IiLCJiaW5kJDEiLCJ4JDAiLCJtYXAkNCIsInJldHVybiQyIiwiYmluZCQyIiwicmV0dXJuJDMiLCJtYXAkNSIsImpvaW4kMCIsImlnbm9yZV9tJDAiLCJhbGwkMSIsImFsbF91bml0JDAiLCJpbnZhcmlhbnQkMCIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQzIiwibWFwJDYiLCJyZXR1cm4kNCIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyJDIiLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMiIsImVycjIiLCJjb21iaW5lX2Vycm9ycyIsImVycnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiaXRlciQzIiwiY291bnQiLCJzdW0iLCJNIiwiZm9sZF9yZXN1bHQiLCJhY2MiLCJpdGVtIiwiZm9sZF91bnRpbCIsImZpbmlzaCIsIm1pbl9lbHQiLCJlbHQiLCJtaW4iLCJtYXhfZWx0IiwibWF4IiwibGVuZ3RoJDAiLCJpc19lbXB0eSQwIiwiZXhpc3RzJDAiLCJmb3JfYWxsJDAiLCJmaW5kX21hcCIsImZpbmQiLCJ0b19saXN0JDAiLCJ0b19hcnJheSIsImxlbmd0aCQxIiwic3VtJDAiLCJtIiwiY291bnQkMCIsImZpbmRfbWFwJDAiLCJmaW5kJDAiLCJ0b19hcnJheSQwIiwibWluX2VsdCQwIiwibWF4X2VsdCQwIiwiZm9sZF9yZXN1bHQkMCIsImZvbGRfdW50aWwkMCIsImZvbGQkMCIsIm1lbSIsImVxdWFsIiwidF9zZXhwX2dyYW1tYXIkMTAiLCJjb21wYXJlJDIxIiwiY29tcGFyZV9hIiwiZXF1YWwkMTAiLCJlcXVhbF9hIiwiaGFzaF9mb2xkX3QkMTQiLCJyZXR1cm4kNSIsImJpbmQkNCIsIm1hcCQ3IiwiYmluZCQ1IiwicmV0dXJuJDYiLCJtYXAkOCIsImpvaW4kMSIsImlnbm9yZV9tJDEiLCJhbGwkMiIsImFsbF91bml0JDEiLCJzZXhwX29mX3QkMTciLCJzZXhwX29mX2EiLCJzbG93X2NoZWNrX3Bvc19sZW5fZXhuIiwicG9zIiwidG90YWxfbGVuZ3RoIiwic3RvcCIsImxlbiQwIiwib2Zfc3RhdGUiLCJhc3NpZ24iLCJ0MSQwIiwidDIkMCIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQkMCIsImdldF9zdGF0ZSIsImZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyIsImFsbG93X2luX3Rlc3RzIiwiYml0cyIsImludCQwIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsIm1ha2UkMiIsImNvcHkkMiIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiYml0cyQxIiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJyMSIsInIyIiwicmVzdWx0IiwiZmxvYXRfcmFuZ2UiLCJiaXRzJDIiLCJpbnQkMiIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwiaW50X2luY2wkMCIsImludDMyX2luY2wkMCIsIm5hdGl2ZWludF9pbmNsJDAiLCJpbnQ2NF9pbmNsJDAiLCJmbG9hdF9yYW5nZSQwIiwiYm9vbCQwIiwiY2hhciQxIiwiYXNjaWkkMCIsImZ1bGxfaW5pdCIsImluaXQkMCIsInNlbGZfaW5pdCIsInNldF9zdGF0ZSIsInBlcm11dGUiLCJyYW5kb21fc3RhdGUiLCJzdGgkMCIsIm51bV9zd2FwcyIsInRoaXNfaSIsInJhbmRvbV9pIiwiY29uc3QkMCIsIm5vbiIsImZvcmV2ZXIiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJhcHBseV9uX3RpbWVzIiwieCQxIiwiY29tcGFyZSQyMiIsImhhc2hfZm9sZF90JDE1IiwiaGFzaCQyIiwidF9vZl9zZXhwJDEzIiwic2V4cF8wMDYiLCJzZXhwX29mX3QkMTgiLCJlcXVhbCQxMSIsIm9mX2ludCQwIiwidG9faW50JDAiLCJ0X3NleHBfZ3JhbW1hciQxMiIsImNvbXBhcmUkMjMiLCJhXzAwNiIsImJfMDA3IiwiYl8wMDkiLCJzZXhwX29mX3QkMTkiLCJvZl9hXzAxMCIsImFyZzBfMDExIiwicmVzMF8wMTIiLCJpbnZhcmlhbnQkMSIsIm9mX2xpc3QkMCIsInJhbmdlIiwic3RyaWRlIiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0IiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImFjY3VtIiwiaV90b19zdG9wX29yZGVyIiwibmV4dF9pJDAiLCJhY2N1bSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwiYiQxIiwiYSQxIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImMkMCIsImMkMSIsImNoZWNrX2xlbmd0aDNfZXhuIiwibDMiLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9yX2FsbDIiLCJmb3JfYWxsMl9leG4iLCJleGlzdHMyIiwiZXhpc3RzMl9leG4iLCJicyIsInJldl9maWx0ZXIiLCJmaWx0ZXIiLCJub3RfZm91bmQiLCJmaW5kX21hcF9leG4iLCJub3RfZm91bmQkMCIsImZpbmRfZXhuIiwiZmluZGkiLCJub3RfZm91bmQkMSIsImZpbmRpX2V4biIsImZpbmRfbWFwaSIsIm5vdF9mb3VuZCQyIiwiZmluZF9tYXBpX2V4biIsImZvcl9hbGxpIiwiZXhpc3RzaSIsInRvX2xpc3QkMSIsIm1heF9ub25fdGFpbGNhbGwiLCJjb3VudF9hcHBlbmQiLCJ4NSIsImFwcGVuZCQwIiwiY291bnRfbWFwIiwiY3RyIiwiZjEkMyIsImYxJDIiLCJmMiQyIiwiZjEkMSIsImYyJDEiLCJmMyQxIiwiZjEkMCIsImYyJDAiLCJmMyQwIiwiZjQkMCIsIng1JDAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwieHMkMCIsIng4IiwieDciLCJ4NiIsIng0IiwieDMiLCJ4MiIsIngxIiwieDAiLCJ5MCQwIiwieTEkMCIsInkyJDAiLCJ5MyQwIiwieTQkMCIsInk1JDAiLCJ5NiQwIiwieTckMCIsInk4JDAiLCJwYXJhbSQwIiwieTgiLCJ5NyIsInk2IiwieTUiLCJ5NCIsInkzIiwieTIiLCJ5MSIsInkwIiwibWFwJDkiLCJmb2xkaW5nX21hcCIsIm5ld19hY2MiLCJmb2xkX21hcCIsInN5bWJvbF9tYXAkMiIsIm1hcDJfb2siLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwibDEkMCIsImwyJDAiLCJsMyQwIiwiYWMiLCJsMyQxIiwibDIkMSIsImwxJDEiLCJhYyQwIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJ1bnppcCQwIiwibGlzdCQyIiwibGlzdCQxIiwidW56aXAzIiwieiIsInppcF9leG4iLCJ6aXAiLCJyZXZfbWFwaSIsIm1hcGkkMSIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsIml0ZXJpJDAiLCJmb2xkaSIsImZpbHRlcmkiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicmVkdWNlX2JhbGFuY2VkIiwic3RlcF9hY2N1bSIsIm51bSIsIm51bSQwIiwiYWNjJDAiLCJudW0kMSIsInJlZHVjZV9iYWxhbmNlZF9leG4iLCJncm91cGkiLCJicmVhayQwIiwiZ3JvdXBzIiwiY3VycmVudF9ncm91cCIsImdyb3VwIiwic29ydF9hbmRfZ3JvdXAiLCJiaW5kJDYiLCJjb25jYXRfbWFwaSIsIm1lcmdlIiwiaDIiLCJoMSIsImFjYyQxIiwibWFwMiQwIiwicmV0dXJuJDciLCJzeW1ib2xfYmluZCQyIiwibWFwJDEwIiwibWFwJDExIiwiYWxsJDQiLCJhbGxfdW5pdCQyIiwiaWdub3JlX20kMiIsImpvaW4kMiIsIm1hcDMkMCIsInN5bWJvbCQ2MCIsInN5bWJvbCQ2MSIsInN5bWJvbCQ2MiIsInN5bWJvbCQ2MyIsInN5bWJvbCQ2NCIsInN5bWJvbCQ2NSIsImxhc3RfZXhuIiwibGFzdCIsImlzX3ByZWZpeCIsInByZWZpeCIsInByZWZpeCQwIiwidGwkMCIsImhkJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsImExIiwiYTEkMCIsImEyIiwicmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMiLCJ3aGljaF90b19rZWVwIiwidG9fa2VlcCQwIiwiZGVkdXBfYW5kX3NvcnQiLCJzb3J0ZWQiLCJmaW5kX2FfZHVwIiwibCQwIiwibCQxIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsImNvbXBhcmUkMCIsInNvcnRlZCQwIiwicHJldiIsImFscmVhZHlfcmVjb3JkZWQiLCJhbGxfZXF1YWwiLCJjb3VudGkiLCJpZHgiLCJpbml0JDEiLCJpJDEiLCJyZXZfZmlsdGVyX21hcCIsImZpbHRlcl9tYXAiLCJyZXZfZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsInRyZCIsInRyZCQwIiwieSQxIiwicGFydGl0aW9uX3RmIiwiZiQwIiwicGFydGl0aW9uX3Jlc3VsdCIsInRfb2Zfc2V4cCQxNCIsIm9mX2FfMDE0Iiwib2ZfYl8wMTUiLCJ4XzAyMyIsInNleHBfMDIxIiwiYXJnMV8wMTgiLCJhcmcwXzAxNyIsInJlczBfMDE5IiwicmVzMV8wMjAiLCJzZXhwX29mX3QkMjAiLCJvZl9hXzAyNCIsIm9mX2JfMDI1IiwieF8wMzAiLCJhcmcxXzAyNyIsImFyZzBfMDI2IiwicmVzMV8wMjkiLCJ0X3NleHBfZ3JhbW1hciQxMyIsInBhaXJfb2ZfZ3JvdXAiLCJrIiwiZ3JvdXAkMCIsImFsaXN0Iiwic29ydF9hbmRfZ3JvdXAkMCIsImZpbmQkMSIsImtleSIsImtleSQwIiwibm90X2ZvdW5kJDMiLCJmaW5kX2V4biQwIiwidmFsdWUiLCJtZW0kMCIsInJlbW92ZSIsImFkZCQwIiwiaW52ZXJzZSIsIm1hcCQxMiIsInN1YiQzIiwiZWwiLCJzcGxpdF9uIiwidF9vcmlnIiwidGFrZSIsImRyb3AiLCJjaHVua3Nfb2YiLCJzdWJsaXN0Iiwic3BsaXRfd2hpbGUiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsImRyb3BfbGFzdCIsImRyb3BfbGFzdF9leG4iLCJjYXJ0ZXNpYW5fcHJvZHVjdCIsImxpc3QxIiwibGlzdDIiLCJjb25jYXQkMSIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJwZXJtdXRlJDAiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImNvbXBhcmVfbGlzdCQxIiwiY21wIiwiZXF1YWxfbGlzdCQxIiwidDIkMSIsInQxJDEiLCJ0cmFuc3Bvc2UiLCJyb3dzIiwiY29sdW1ucyIsImRvX3JldiIsImNvbHVtbl9hY2MiLCJ0cmltbWVkX3Jvd3MiLCJmb3VuZF9lbXB0eSIsImNvbHVtbiIsImRvX3JldiQwIiwiY29sdW1ucyQwIiwidHJpbW1lZCIsImNvbHVtbl9hY2MkMCIsImFyZzBfMDMxIiwicmVzMF8wMzIiLCJ0cmFuc3Bvc2VfZXhuIiwiaW50ZXJzcGVyc2UiLCJpc19zdWZmaXgiLCJzdWZmaXgiLCJsaXN0X2xlbiIsInN1ZmZpeF9sZW4iLCJzZXhwX29mX3QkMjEiLCJyZXMwXzAwMiIsImFyZzBfMDAzIiwicmVzMF8wMDQiLCJyZXMwXzAwNiIsImFyZzBfMDA3IiwicmVzMF8wMDgiLCJhcmcyXzAxMSIsImFyZzFfMDEwIiwiYXJnMF8wMDkiLCJyZXMxXzAxMyIsInJlczJfMDE0IiwiYXJnMV8wMTYiLCJyZXMxXzAxOCIsImFyZzJfMDIxIiwiYXJnMV8wMjAiLCJhcmcwXzAxOSIsInJlczFfMDIzIiwicmVzMl8wMjQiLCJhcmcxXzAyNiIsImFyZzBfMDI1IiwicmVzMF8wMjciLCJyZXMxXzAyOCIsImFyZzFfMDMwIiwicmVzMF8wMzEiLCJyZXMxXzAzMiIsInRvX3N0cmluZ3NfaHVtIiwic3RyaW5nIiwic2V4cCQwIiwic2V4cCQxIiwidGFnIiwidGFnJDAiLCJzZXhwJDIiLCJ0YWckMSIsImJvZHkiLCJ0cnVuY19hZnRlciIsInRzJDAiLCJ0cyQxIiwiYWMkMSIsInRvX3NleHBzX2h1bSIsImhlcmUiLCJoZXJlJDAiLCJ0b19zZXhwX2h1bSIsInNleHBzIiwicHJvdGVjdCQwIiwidG9fbWVzc2FnZSIsImluZm8iLCJvZl9tZXNzYWdlIiwibWVzc2FnZSIsImxhenlfdCIsInN0cmljdCIsInNleHBfb2ZfeCIsImJhY2t0cmFjZSQwIiwiYmFja3RyYWNlJDEiLCJiYWNrdHJhY2UkMiIsInBwJDIiLCJwcCQzIiwicmFpc2UiLCJyYWlzZV9zIiwidG9faW5mbyIsIm9mX2luZm8iLCJpbnZhcmlhbnQkMyIsImNoZWNrX2ZpZWxkIiwiY29tcGFyZSQyNSIsImVxdWFsJDEzIiwiYV8wMDciLCJiXzAwOCIsImhhc2hfZm9sZF90JDE3IiwidF9vZl9zZXhwJDE2Iiwib2ZfYV8wMTMiLCJ4XzAxNSIsInNleHBfb2ZfdCQyMyIsIm9mX2FfMDE2IiwieF8wMTciLCJ0X3NleHBfZ3JhbW1hciQxNiIsImludmFyaWFudCQ0IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwibWFwJDEzIiwidHJ5X3dpdGgkMCIsInRyeV93aXRoX2pvaW4iLCJva19leG4kMCIsIm9mX2V4biQwIiwib2ZfZXhuX3Jlc3VsdCIsImVycm9yJDAiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidGFnX3MkMCIsInRhZ19zX2xhenkkMCIsInRhZ19hcmckMCIsInVuaW1wbGVtZW50ZWQiLCJjb21iaW5lX2Vycm9ycyQwIiwiY29tYmluZV9lcnJvcnNfdW5pdCQwIiwiZmlsdGVyX29rX2F0X2xlYXN0X29uZSIsImZpbmRfb2siLCJmaW5kX21hcF9vayIsInRfb2Zfc2V4cCQxNyIsInNleHBfMDA0Iiwic2V4cF9vZl90JDI0IiwiY29tcGFyZSQyNiIsImhhc2hfZm9sZF90JDE4Iiwic3ltYm9sJDY5Iiwic3ltYm9sJDcwIiwic3ltYm9sJDcxIiwic3ltYm9sJDcyIiwic3ltYm9sJDczIiwic3ltYm9sJDc0IiwiYXNjZW5kaW5nJDEwIiwiZGVzY2VuZGluZyQxMCIsImNvbXBhcmUkMjciLCJlcXVhbCQxNCIsIm1heCQxMiIsIm1pbiQxMiIsIm9mX3N0cmluZyQzIiwidG9fc3RyaW5nJDQiLCJ0b19pbnQkMSIsImdlcSIsImxlcSIsImVxdWFsJDE1IiwibWluJDEzIiwibWF4JDEzIiwic3ltYm9sJDIiLCJzeW1ib2wkMyIsInN5bWJvbCQ0IiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJsZXhpY29ncmFwaGljIiwiY21wcyIsImxpZnQiLCJyZXZlcnNlIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24kMCIsImVxdWFsJDE2IiwiaGFzaF9wYXJhbSIsImhhc2gkNCIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoIiwiZXF1YWwkMTciLCJoYXNoX3BhcmFtJDAiLCJoYXNoJDUiLCJoYXNoYWJsZSIsIm9mX2tleSQwIiwidG9fa2V5JDAiLCJoYXNoJDYiLCJjb21wYXJlJDI4Iiwib2Zfc3RyaW5nJDQiLCJ0b19zdHJpbmckNSIsImhhc2hfZm9sZF91bml0JDAiLCJmdW5jJDciLCJ1bml0X29mX3NleHAiLCJzZXhwX29mX3VuaXQiLCJlcXVhbF91bml0JDEiLCJjb21wYXJlX3VuaXQkMSIsImludmFyaWFudCQ1IiwiZ2V0X3Bvc19sZW4iLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmciLCJwcmVkIiwicG9zJDAiLCJoaSQwIiwibG8kMSIsIm1pZCIsImxvJDIiLCJsbyQwIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJiaW5hcnlfc2VhcmNoIiwiaG93IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiYmluYXJ5X3NlYXJjaCQwIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkMCIsInVuc2FmZV9ibGl0Iiwic3JjIiwic3JjX3BvcyIsImRzdCIsImRzdF9wb3MiLCJibGl0byIsInNyY19sZW4iLCJzdWJvIiwiY3JlYXRlX2xpa2UiLCJ0X3NleHBfZ3JhbW1hciQxOCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsIml0ZXIkNCIsImludmFyaWFudCQ2IiwiY2FsbCIsInZhbHVlX2V4biIsIm0kMCIsIm0kMSIsInZhbHVlX29yX3RodW5rIiwidG9fbGlzdCQyIiwibWluX2VsdCQxIiwibWF4X2VsdCQxIiwic3VtJDEiLCJmb3JfYWxsJDEiLCJleGlzdHMkMSIsIm1lbSQxIiwiY291bnQkMSIsImZpbmQkMiIsImZpbmRfbWFwJDEiLCJlcXVhbF9vcHRpb24kMSIsInNvbWUiLCJmaXJzdF9zb21lIiwic29tZV9pZiIsImNvbmQiLCJtZXJnZSQwIiwiZmlsdGVyJDAiLCJ0cnlfd2l0aCQxIiwidHJ5X3dpdGhfam9pbiQwIiwiYXBwbHkkMiIsInJldHVybiQ5IiwibWFwJDE1IiwiYmluZCQ3Iiwic3ltYm9sX2JpbmQkNCIsImJpbmQkOCIsImpvaW4kMyIsImlnbm9yZV9tJDMiLCJmb2xkX3Jlc3VsdCQxIiwiZm9sZF91bnRpbCQxIiwidF9vZl9zZXhwIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwic3dhcCQwIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJ2YWx1ZSQwIiwidmFsdWVfbWFwJDAiLCJmaXJzdCIsInNlY29uZCIsIm1hcCQxNyIsImVxdWFsJDE4IiwiZXExIiwiZXEyIiwiaW52YXJpYW50JDciLCJvdGhlciIsImVpdGhlciIsIm90aGVyX2xvb3AiLCJyZXR1cm5fbG9vcCIsImNvbWJpbmVfYWxsIiwib3RoZXJfbG9vcCQwIiwicmV0dXJuX2xvb3AkMCIsImNvbWJpbmVfYWxsX3VuaXQiLCJ0b19vcHRpb24iLCJ3aXRoX3JldHVybiQwIiwiY29tYmluZSQwIiwiYmluZCQ5IiwiZWl0aGVyJDAiLCJjb21iaW5lJDEiLCJiaW5kJDEwIiwiaXRlcmkkMSIsImZvbGRpJDAiLCJjb3VudGkkMCIsImV4aXN0c2kkMCIsImZvcl9hbGxpJDAiLCJmaW5kX21hcGkkMCIsImZpbmRpJDAiLCJmb2xkaSQxIiwic2V4cF9vZl90JDI1Iiwib2Zfc18wMDIiLCJuZXh0X3N0ZXAiLCJkZWxheWVkX2ZvbGRfc3RlcCIsIm5leHQiLCJ1bmZvbGRfc3RlcCIsInVuZm9sZCIsInVuZm9sZF93aXRoIiwic2VlZCQwIiwic2VlZCQxIiwidW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCIsInJ1bm5pbmdfc3RlcCIsImlubmVyX2ZpbmlzaGVkIiwiZmluaXNoaW5nX3N0ZXAiLCJzdGF0ZSQwIiwic3RhdGUkMSIsInN0YXRlJDIiLCJpbm5lcl9zdGF0ZSIsInN0YXRlJDMiLCJpbm5lcl9zdGF0ZSQwIiwiaW5uZXJfc3RhdGUkMSIsInN0YXRlJDQiLCJzdGF0ZSQ1Iiwib2ZfbGlzdCQxIiwiZm9sZCQxIiwidiQwIiwidiQxIiwidG9fbGlzdF9yZXYiLCJ0b19saXN0JDMiLCJzZXhwX29mX3QkMjYiLCJyYW5nZSQxIiwic3RhcnRfdiIsInN0b3BfdiIsInN0ZXAiLCJvZl9sYXp5JDAiLCJ0X2xhenkiLCJtYXBpJDIiLCJmb2xkaW5nX21hcCQwIiwiZm9sZGluZ19tYXBpJDAiLCJmaWx0ZXIkMSIsImZpbHRlcmkkMCIsImxlbmd0aCQyIiwidG9fYXJyYXkkMSIsImwkMiIsImZpbmQkMyIsImZpbmRfbWFwJDIiLCJzb21lX2IiLCJmaW5kX21hcGkkMSIsImZvcl9hbGwkMiIsImZvcl9hbGxpJDEiLCJleGlzdHMkMiIsImV4aXN0c2kkMSIsIml0ZXIkNSIsImlzX2VtcHR5JDEiLCJtZW0kMiIsImVtcHR5IiwiYmluZCQxMSIsIm5leHQkMCIsInJldHVybiQxMSIsIm1hcCQxOCIsInN5bWJvbF9iaW5kJDUiLCJzeW1ib2xfbWFwJDYiLCJiaW5kJDEyIiwicmV0dXJuJDEyIiwibWFwJDE5Iiwiam9pbiQ0IiwiaWdub3JlX20kNCIsImFsbCQxMSIsImFsbF91bml0JDUiLCJudGgkMCIsInMkMyIsIm50aF9leG4kMCIsImNvbXBhcmUkMjkiLCJhXzAxMSIsImJfMDEyIiwiYl8wMTQiLCJiXzAxNiIsImJfMDIwIiwiYl8wMTgiLCJoYXNoX2ZvbGRfdCQxOSIsImEwJDEiLCJoc3YkMyIsInRfb2Zfc2V4cCQxOCIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInNleHBfYXJnc18wMzQiLCJhcmcwXzAzNSIsInJlczBfMDM2Iiwic2V4cF9hcmdzXzAyOSIsImFyZzBfMDMwIiwic2V4cF9hcmdzXzAzOSIsImFyZzFfMDQxIiwiYXJnMF8wNDAiLCJyZXMwXzA0MiIsInJlczFfMDQzIiwic2V4cF9vZl90JDI3Iiwib2ZfYV8wNDYiLCJvZl9iXzA0NyIsImFyZzBfMDQ4IiwicmVzMF8wNDkiLCJhcmcwXzA1MCIsInJlczBfMDUxIiwiYXJnMV8wNTMiLCJhcmcwXzA1MiIsInJlczBfMDU0IiwicmVzMV8wNTUiLCJ0X3NleHBfZ3JhbW1hciQxOSIsIm1lcmdlX3dpdGhfZHVwbGljYXRlcyIsIm5leHQyIiwiczIiLCJuZXh0MSIsInMxIiwiczIkMCIsInMyJDEiLCJzMiQyIiwiY29tcGFyaXNvbiIsIm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCIsIm1lcmdlX3NvcnRlZCIsImhkX2V4biQwIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiZmlsdGVyX29wdCQwIiwiZmlsdGVyX21hcCQwIiwiZmlsdGVyX21hcGkkMCIsInNwbGl0X24kMCIsImNodW5rc19leG4iLCJmaW5kaSQxIiwiZmluZF9leG4kMSIsImFwcGVuZCQxIiwiczEkMCIsInMxJDEiLCJjb25jYXRfbWFwIiwiY29uY2F0JDIiLCJjb25jYXRfbWFwaSQwIiwiemlwJDAiLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsInNlZWQkMiIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwibWF4JDAiLCJpdGVyaSQyIiwicmVkdWNlJDAiLCJyZWR1Y2VfZXhuJDAiLCJncm91cCQxIiwiY3VyIiwiY3VyJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSQwIiwibGFzdF9lbHQiLCJsYXN0X2VsdCQwIiwicmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMkMCIsImNvdW50JDIiLCJjb3VudGkkMSIsInN1bSQyIiwibWluX2VsdCQyIiwibWF4X2VsdCQyIiwiaW5pdCQyIiwic3ViJDQiLCJ0YWtlJDAiLCJkcm9wJDAiLCJ0YWtlX3doaWxlJDAiLCJkcm9wX3doaWxlJDAiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCIsImludGVyc3BlcnNlJDAiLCJzJDUiLCJzJDQiLCJyZXBlYXQiLCJjeWNsZV9saXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0JDAiLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9sZF91bnRpbCQyIiwiZm9sZF9yZXN1bHQkMiIsImZvcmNlX2VhZ2VybHkiLCJtZW1vaXplIiwiZHJvcF9lYWdlcmx5IiwiZHJvcF93aGlsZV9vcHRpb24iLCJjb21wYXJlJDMwIiwidjIiLCJ2MSIsImVxdWFsJDE5Iiwicm91bmRfcm9iaW4iLCJkb25lX3N0YWNrIiwidG9kb19zdGFjayIsInRvZG9fc3RhY2skMCIsImludGVybGVhdmUiLCJpbnRlcmxlYXZlZF9jYXJ0ZXNpYW5fcHJvZHVjdCIsIm9mX3NlcSIsInNlcSIsInRvX3NlcSIsInJldHVybiQxMyIsImJpbmQkMTMiLCJtYXAkMjAiLCJzeW1ib2xfYmluZCQ2Iiwic3ltYm9sX21hcCQ3IiwiYmluZCQxNCIsInJldHVybiQxNCIsIm1hcCQyMSIsImpvaW4kNSIsImlnbm9yZV9tJDUiLCJhbGwkMTIiLCJhbGxfdW5pdCQ2IiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJydW4kMCIsInRodW5rIiwidF9zZXhwX2dyYW1tYXIkMjAiLCJnZXQkMCIsInNldCIsInN3YXAkMSIsInRtcCIsInNvcnQkMCIsImxlZnQiLCJyaWdodCIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDEiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0zIiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsInIkMyIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJsZWZ0JDEiLCJwdiIsInAkMCIsInIkMCIsInIkMSIsInNvcnQkMiIsInNvcnQkMyIsInRvX2FycmF5JDIiLCJpc19lbXB0eSQyIiwiaXNfc29ydGVkJDAiLCJlbHRfaV9taW51c18xIiwiaXNfc29ydGVkX3N0cmljdGx5JDAiLCJtZXJnZSQxIiwibWVyZ2VkIiwiYTFfaW5kZXgiLCJhMl9pbmRleCIsInVzZV9hMSIsImNvcHlfbWF0cml4IiwiZm9sZGluZ19tYXAkMSIsImZvbGRfbWFwJDAiLCJmb2xkX3Jlc3VsdCQzIiwiZm9sZF91bnRpbCQzIiwiY291bnQkMyIsInN1bSQzIiwibWluX2VsdCQzIiwibWF4X2VsdCQzIiwiZm9sZGkkMiIsImZvbGRpbmdfbWFwaSQxIiwiZm9sZF9tYXBpJDAiLCJjb3VudGkkMiIsImNvbmNhdF9tYXAkMCIsImNvbmNhdF9tYXBpJDEiLCJyZXZfaW5wbGFjZSIsInJldiQwIiwib2ZfbGlzdF9yZXYiLCJvZl9saXN0X21hcCIsIm9mX2xpc3RfbWFwaSIsIm9mX2xpc3RfcmV2X21hcCIsIm9mX2xpc3RfcmV2X21hcGkiLCJmaWx0ZXJfbWFwaSQxIiwiZmlsdGVyX21hcCQxIiwiZmlsdGVyX29wdCQxIiwiY2hlY2tfbGVuZ3RoMl9leG4kMCIsIml0ZXIyX2V4biQwIiwibWFwMl9leG4kMCIsImZvbGQyX2V4biQwIiwiZmlsdGVyJDIiLCJmaWx0ZXJpJDEiLCJleGlzdHMkMyIsImV4aXN0c2kkMiIsIm1lbSQzIiwiZm9yX2FsbCQzIiwiZm9yX2FsbGkkMiIsImV4aXN0czJfZXhuJDAiLCJmb3JfYWxsMl9leG4kMCIsImVxdWFsX2FycmF5JDEiLCJtYXBfaW5wbGFjZSIsImZpbmRpX2ludGVybmFsIiwiaWZfZm91bmQiLCJpZl9ub3RfZm91bmQiLCJmb3VuZCIsInZhbHVlX2ZvdW5kIiwiZmluZGkkMiIsImZpbmRpX2V4biQwIiwiZmluZF9leG4kMiIsImZpbmQkNCIsImZpbmRfbWFwJDMiLCJub3RfZm91bmQkNCIsImZpbmRfbWFwX2V4biQwIiwiZmluZF9tYXBpJDIiLCJub3RfZm91bmQkNSIsImZpbmRfbWFwaV9leG4kMCIsImZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlJDEiLCJyZWR1Y2UkMSIsInJlZHVjZV9leG4kMSIsInJhbmRvbV9lbGVtZW50X2V4biQwIiwicmFuZG9tX2VsZW1lbnQkMCIsInppcCQxIiwiemlwX2V4biQwIiwidW56aXAkMSIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJwYXJ0aXRpb25fdGYkMCIsImxhc3QkMCIsInRvX3NlcXVlbmNlX211dGFibGUiLCJ0b19zZXF1ZW5jZSIsImNhcnRlc2lhbl9wcm9kdWN0JDEiLCJpMSIsImkyIiwidHJhbnNwb3NlJDAiLCJ0dCIsIndpZHRoIiwiZGVwdGgiLCJkIiwidyIsInRyYW5zcG9zZV9leG4kMCIsInR0JDAiLCJnZXQkMSIsImxlbmd0aCQzIiwibGVuZ3RoJDQiLCJ1bnNhZmVfYmxpdCQxIiwiaW52YXJpYW50JDgiLCJpbnZhcmlhbnQkOSIsImxlbmd0aCQ1Iiwic2V4cF9vZl90JDI4IiwiY3JlYXRlX3plcm8iLCJlbXB0eSQwIiwiZ2V0JDIiLCJ1bnNhZmVfZ2V0IiwidW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5Iiwib2JqIiwic2V0X3dpdGhfY2FtbF9tb2RpZnkiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4iLCJzZXQkMCIsIm9sZF9vYmoiLCJ1bnNhZmVfc2V0IiwidW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlIiwic3dhcCQyIiwiY3JlYXRlJDMiLCJzaW5nbGV0b24kMCIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfYmxpdCQzIiwidW5zYWZlX2JsaXQkNCIsImNvcHkkMyIsInVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCIsImNyZWF0ZV9vYmpfYXJyYXkiLCJjcmVhdGUkNCIsInNpbmdsZXRvbiQxIiwic3dhcCQzIiwiZ2V0JDMiLCJzZXQkMSIsInVuc2FmZV9nZXQkMCIsInVuc2FmZV9zZXQkMCIsInVuc2FmZV9zZXRfaW50JDAiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4kMCIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyQwIiwidW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlJDAiLCJ1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkkMCIsInNldF93aXRoX2NhbWxfbW9kaWZ5JDAiLCJpbnZhcmlhbnQkMTAiLCJpbml0JDMiLCJvZl9hcnJheSIsIm1hcCQyMiIsIm1hcGkkMyIsIml0ZXIkNiIsIml0ZXJpJDMiLCJmb2xkaSQzIiwidG9fbGlzdCQ0Iiwib2ZfbGlzdCQyIiwidG9fYXJyYXkkMyIsImV4aXN0cyQ0IiwiZm9yX2FsbCQ0IiwibWFwMl9leG4kMSIsInRfc2V4cF9ncmFtbWFyJDIxIiwiZ3JhbW1hciIsImNyZWF0ZV9saWtlJDAiLCJ1bnNhZmVfYmxpdCQ1IiwiZm9sZCQyIiwibWluX2VsdCQ0IiwibWF4X2VsdCQ0IiwiY29tcGFyZSQzMSIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJmbG9hdF9vZl9zdHJpbmckMCIsIm5hbiQxIiwiaW5maW5pdHkkMSIsIm5lZ19pbmZpbml0eSQxIiwibWF4X2Zpbml0ZV92YWx1ZSIsImVwc2lsb25fZmxvYXQkMSIsImNsYXNzaWZ5X2Zsb2F0IiwiYWJzX2Zsb2F0IiwiaXNfaW50ZWdlciIsInN5bWJvbCQ4NCIsInN5bWJvbCQ4NSIsImZyZXhwIiwibGRleHAiLCJpc19uYW4iLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biIsIm9mX2ludDY0X3ByZXNlcnZlX29yZGVyIiwib25lX3VscCIsImRpciIsInVwcGVyX2JvdW5kX2Zvcl9pbnQiLCJudW1fYml0cyIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJoYXNoJDciLCJ0b19zdHJpbmckNyIsIm9mX3N0cmluZyQ2IiwicHAkNiIsImludmFyaWFudCQxMSIsImFsbCQxMyIsImlzX2xvd2VyY2FzZSIsImlzX3VwcGVyY2FzZSIsImlzX3ByaW50IiwiaXNfd2hpdGVzcGFjZSIsImlzX2RpZ2l0IiwiaXNfYWxwaGEiLCJpc19hbHBoYW51bSIsImdldF9kaWdpdF9leG4iLCJnZXRfZGlnaXQiLCJpc19oZXhfZGlnaXQiLCJpc19oZXhfZGlnaXRfbG93ZXIiLCJpc19oZXhfZGlnaXRfdXBwZXIiLCJnZXRfaGV4X2RpZ2l0X2V4biIsImdldF9oZXhfZGlnaXQiLCJzeW1ib2wkOTIiLCJzeW1ib2wkOTMiLCJzeW1ib2wkOTQiLCJzeW1ib2wkOTUiLCJzeW1ib2wkOTYiLCJzeW1ib2wkOTciLCJjb21wYXJlJDM0IiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDIwIiwiaGFzaCQ4IiwiY29tcGFyZV9jaGFyJDAiLCJlcXVhbF9jaGFyJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpJDIiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiaGFzaCQ5IiwiaGFzaGFibGUkMSIsImludmFyaWFudCQxMiIsInN1YiQ4Iiwic3VibyQyIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImlzX2VtcHR5JDMiLCJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCIsImluZGV4X2V4bl9pbnRlcm5hbCIsIm5vdF9mb3VuZCQ2IiwiaW5kZXhfZXhuIiwibm90X2ZvdW5kJDciLCJpbmRleF9mcm9tX2V4biIsInJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCIsInJpbmRleF9leG5faW50ZXJuYWwiLCJub3RfZm91bmQkOCIsInJpbmRleF9leG4iLCJub3RfZm91bmQkOSIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsInNleHBfb2ZfdCQzMCIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiY3JlYXRlJDUiLCJpbmRleF9pbnRlcm5hbCIsInRleHQiLCJtYXRjaGVzIiwiaW4kMCIsImluZGV4X2V4biQwIiwiaW5kZXhfYWxsIiwibWF5X292ZXJsYXAiLCJyZXBsYWNlX2ZpcnN0Iiwid2l0aCQwIiwibGVuX3MiLCJsZW5fdCIsImxlbl93aXRoIiwicmVwbGFjZV9hbGwiLCJudW1fbWF0Y2hlcyIsIm5leHRfZHN0X3BvcyIsIm5leHRfc3JjX3BvcyIsInNwbGl0X29uIiwicGF0dGVybl9sZW4iLCJlcXVhbCQyMyIsImFfMDAyIiwiYl8wMDMiLCJzZXhwX29mX3QkMzEiLCJrbXBfYXJyYXlfMDExIiwiY2FzZV9zZW5zaXRpdmVfMDA5IiwicGF0dGVybl8wMDciLCJhcmdfMDEyIiwiYm5kc18wMDYiLCJhcmdfMDEwIiwiYm5kc18wMDYkMCIsImFyZ18wMDgiLCJibmRzXzAwNiQxIiwicmVwcmVzZW50YXRpb24iLCJzdWJzdHJfaW5kZXhfZ2VuIiwic3Vic3RyX2luZGV4X2V4bl9nZW4iLCJzdWJzdHJfaW5kZXhfYWxsX2dlbiIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiIsInN1YnN0cl9yZXBsYWNlX2FsbF9nZW4iLCJpc19zdWJzdHJpbmdfZ2VuIiwic3Vic3RyaW5nIiwic3Vic3RyX2luZGV4Iiwic3Vic3RyX2luZGV4X2V4biIsInN1YnN0cl9pbmRleF9hbGwiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCIsInN1YnN0cl9yZXBsYWNlX2FsbCIsImlzX3N1YnN0cmluZyIsImlzX3N1YnN0cmluZ19hdF9nZW4iLCJzdHJfcG9zJDEiLCJzdHJfbGVuIiwic3ViX2xlbiIsInN0cl9wb3MiLCJzdWJfcG9zIiwic3ViX3BvcyQwIiwic3RyX3BvcyQwIiwiaXNfc3VmZml4X2dlbiIsInN0cmluZ19sZW4iLCJpc19wcmVmaXhfZ2VuIiwicHJlZml4X2xlbiIsImNvbXBhcmUkMzYiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwiaGFzaF9mb2xkX3QkMjEiLCJoYXNoJDEwIiwiaXNfc3VmZml4JDAiLCJpc19wcmVmaXgkMCIsInN1YnN0cl9pbmRleCQwIiwic3Vic3RyX2luZGV4X2V4biQwIiwic3Vic3RyX2luZGV4X2FsbCQwIiwic3Vic3RyX3JlcGxhY2VfZmlyc3QkMCIsInN1YnN0cl9yZXBsYWNlX2FsbCQwIiwiaXNfc3Vic3RyaW5nJDAiLCJpc19zdWJzdHJpbmdfYXQiLCJvZl9zdHJpbmckNyIsInRvX3N0cmluZyQ4IiwiaW5pdCQ0IiwidG9fbGlzdCQ1IiwidG9fbGlzdF9yZXYkMCIsInJldiQxIiwibm90X2ZvdW5kJDEwIiwibHNwbGl0Ml9leG4iLCJsaW5lIiwiZGVsaW0iLCJub3RfZm91bmQkMTEiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsInBvcyQyIiwibGFzdF9wb3MkMCIsInBvczEiLCJzdWJfc3RyIiwic3BsaXQiLCJzcGxpdF9vbl9jaGFycyIsImNoYXJzIiwiYmFja191cF9hdF9uZXdsaW5lIiwiZW9sIiwic3BsaXRfbGluZXMiLCJpc19zdWZmaXgkMSIsImlzX3ByZWZpeCQxIiwiaXNfc3Vic3RyaW5nX2F0JDAiLCJ3cmFwX3N1Yl9uIiwib25fZXJyb3IiLCJkcm9wX3ByZWZpeCIsImRyb3Bfc3VmZml4IiwibGZpbmRpIiwiZmluZCQ1IiwiZmluZF9tYXAkNCIsInJmaW5kaSIsImxhc3Rfbm9uX2Ryb3AiLCJyc3RyaXAiLCJmaXJzdF9ub25fZHJvcCIsImxzdHJpcCIsInN0cmlwIiwibWFwaSQ0IiwibWFwJDIzIiwidG9fYXJyYXkkNCIsImV4aXN0cyQ1IiwiZm9yX2FsbCQ1IiwiZm9sZCQzIiwiZm9sZGkkNCIsIml0ZXJpJDQiLCJjb3VudCQ0Iiwic3VtJDQiLCJtaW5fZWx0JDUiLCJtYXhfZWx0JDUiLCJmb2xkX3Jlc3VsdCQ0IiwiZm9sZF91bnRpbCQ0IiwiZmluZF9tYXBpJDMiLCJmaW5kaSQzIiwiY291bnRpJDMiLCJmb3JfYWxsaSQzIiwiZXhpc3RzaSQzIiwibWVtJDQiLCJ0ciIsInRyX211bHRpIiwiY29uY2F0X2FycmF5IiwiYXIiLCJjb25jYXRfbWFwJDEiLCJmaWx0ZXIkMyIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImZpbHRlcmkkMiIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwicHAkNyIsIm9mX2NoYXIkMCIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsInRvX2VzY2FwZSIsImVzY2FwZWRfY2hhciIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJzdGF0dXMkMCIsInRvX3VuZXNjYXBlIiwiZHN0X3BvcyQwIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsImNudCQwIiwidXBkYXRlX2VzY2FwZV9zdGF0dXMiLCJlc2NhcGVfc3RhdHVzIiwib2RkIiwiY2hlY2tfYm91bmQiLCJmdW5jdGlvbl9uYW1lIiwiaXNfY2hhcl9lc2NhcGluZyIsImlzX2NoYXJfZXNjYXBlZCIsImlzX2NoYXJfbGl0ZXJhbCIsImluZGV4X2Zyb20kMCIsInN0YXR1cyQxIiwiaW5kZXhfZnJvbV9leG4kMCIsImluZGV4JDEiLCJpbmRleF9leG4kMSIsInJpbmRleF9mcm9tJDAiLCJlc2NhcGVfY2hhcnMiLCJyaW5kZXhfZnJvbV9leG4kMCIsInJpbmRleCQwIiwicmluZGV4X2V4biQwIiwic3BsaXRfZ2VuJDAiLCJzcGxpdCQwIiwic3BsaXRfb25fY2hhcnMkMCIsInNwbGl0X2F0IiwibHNwbGl0MiQwIiwicnNwbGl0MiQwIiwibHNwbGl0Ml9leG4kMCIsInJzcGxpdDJfZXhuJDAiLCJsYXN0X25vbl9kcm9wX2xpdGVyYWwiLCJmaXJzdF9ub25fZHJvcF9saXRlcmFsIiwicnN0cmlwX2xpdGVyYWwiLCJsc3RyaXBfbGl0ZXJhbCIsInN0cmlwX2xpdGVyYWwiLCJiZXR3ZWVuJDIiLCJjbGFtcF91bmNoZWNrZWQkMCIsImNsYW1wX2V4biQyIiwiY2xhbXAkMiIsImNyZWF0ZSQ2IiwiY29tcGFyZV9zdHJpbmckMSIsImVxdWFsX3N0cmluZyQxIiwicHAkOCIsImNyZWF0ZSQ3IiwiY3JlYXRlJDgiLCJsZW5ndGgkNiIsInVuc2FmZV9ibGl0JDciLCJsZW5ndGgkNyIsImludmFyaWFudCQxMyIsImluaXQkNSIsIm9mX2NoYXJfbGlzdCQwIiwidG9fbGlzdCQ2IiwidG9fYXJyYXkkNSIsIm1hcCQyNCIsIm1hcGkkNSIsImZvbGQkNCIsImZvbGRpJDUiLCJ0ciQwIiwidHJfbXVsdGkkMCIsImJldHdlZW4kMyIsImNsYW1wX3VuY2hlY2tlZCQxIiwiY2xhbXBfZXhuJDMiLCJjbGFtcCQzIiwiY29udGFpbnMkMCIsImNvbXBhcmVfYnl0ZXMiLCJlcXVhbF9ieXRlcyIsInBhcnNlX2hleCIsImxleGJ1ZiIsIm9jYW1sX2xleF9zdGF0ZSIsIm9jYW1sX2xleF9zdGF0ZSQwIiwiY29udmVydF9mYWlsdXJlIiwidG9fc3RyaW5nIiwibnVtX2JpdHNfbmF0aXZlaW50IiwibnVtX2JpdHNfaW50MzIiLCJudW1fYml0c19pbnQ2NCIsImludDMyX3RvX2ludF90cnVuYyIsImludF90b19pbnQzMl90cnVuYyIsImludF90b19pbnQzMiIsImludDMyX3RvX2ludCIsImludF90b19pbnQzMl9leG4iLCJpbnQzMl90b19pbnRfZXhuIiwiaW50X3RvX2ludDY0IiwiaW50NjRfdG9faW50X3RydW5jIiwibWluJDIxIiwibWF4JDIxIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQiLCJpbnQ2NF90b19pbnQiLCJpbnQ2NF90b19pbnRfZXhuIiwiaW50X3RvX25hdGl2ZWludCIsIm5hdGl2ZWludF90b19pbnRfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50IiwibmF0aXZlaW50X3RvX2ludF9leG4iLCJpbnQzMl90b19pbnQ2NCIsImludDY0X3RvX2ludDMyX3RydW5jIiwibWluJDIyIiwibWF4JDIyIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzIiwiaW50NjRfdG9faW50MzIiLCJpbnQ2NF90b19pbnQzMl9leG4iLCJpbnQzMl90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50MzIiLCJuYXRpdmVpbnRfdG9faW50MzJfZXhuIiwiaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludDY0IiwibWluJDM4IiwibWF4JDM5IiwidG9fbmF0aXZlaW50IiwidG9fbmF0aXZlaW50X2V4biIsIm1pbiQyMyIsIm1heCQyMyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NiIsImludDY0X2ZpdF9vbl9pbnQ2M19leG4iLCJpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IiwiaW5wdXQiLCJkZWxpbWl0ZXIiLCJjaGFyc19wZXJfZGVsaW1pdGVyIiwiaW5wdXRfbGVuZ3RoIiwiaGFzX3NpZ24iLCJudW1fZGlnaXRzIiwibnVtX2RlbGltaXRlcnMiLCJvdXRwdXRfbGVuZ3RoIiwib3V0cHV0IiwiaW5wdXRfcG9zIiwib3V0cHV0X3BvcyIsIm51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIiLCJmaXJzdF9kaWdpdF9wb3MiLCJpbnNlcnRfZGVsaW1pdGVyIiwiaW5zZXJ0X3VuZGVyc2NvcmVzIiwiZGVsaW1pdGVyJDAiLCJtYWtlX3N1ZmZpeCIsInRvX3N0cmluZyQwIiwidG9fc3RyaW5nX2h1bSIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJ0X3NleHBfZ3JhbW1hciIsImludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSIsIm92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUiLCJpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsIiwiaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwibmVnYXRpdmVfZXhwb25lbnQiLCJvdmVyZmxvdyIsImludF9wb3ciLCJiYXNlIiwiZXhwb25lbnQiLCJpbnQ2NF9wb3ciLCJpbnQ2M19wb3dfb25faW50NjQiLCJydmFsIiwib25lIiwicm91bmRfZG93biIsIm1vZHVsdXMiLCJyb3VuZF91cCIsInJlbWFpbmRlciIsInJvdW5kX3Rvd2FyZHNfemVybyIsInRvX211bHRpcGxlX29mIiwicm91bmRfbmVhcmVzdCIsIm1vZHVsdXNfbWludXNfcmVtYWluZGVyIiwicm91bmQiLCJpbnQ2NF9wb3Bjb3VudCIsIngkMiIsImludDMyX3BvcGNvdW50IiwicG9wY291bnQiLCJ0b19mbG9hdCQwIiwiZmxpcCQwIiwic3ltYm9sJDEyOCIsInN5bWJvbCQxMjkiLCJzeW1ib2wkMTMwIiwic3ltYm9sJDEzMSIsInN5bWJvbCQxMzIiLCJzeW1ib2wkMTMzIiwic3ltYm9sJDEzNCIsImFzY2VuZGluZyQxOCIsImRlc2NlbmRpbmckMTgiLCJjb21wYXJlJDM4IiwiZXF1YWwkMjUiLCJtYXgkMjQiLCJtaW4kMjQiLCJmdW5jJDgiLCJjb21wYXJlJDM5IiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsIm9mX2ludCQyIiwidG9faW50JDMiLCJoYXNoJDEyIiwic3ltYm9sJDEzNSIsInRvX3N0cmluZyQxMCIsIm9mX3N0cmluZyQxMCIsImNsYW1wX3VuY2hlY2tlZCQyIiwibm9uX3Bvc2l0aXZlX2FyZ3VtZW50IiwieCQzIiwieCQ0IiwieCQ1IiwieCQ2IiwiY29tcGFyZV9pbnQkMCIsImVxdWFsX2ludCQxIiwiaGFzaF9mb2xkX3QkMjMiLCJoYXNoJDEzIiwidG9fc3RyaW5nJDExIiwic2V4cF9vZl90JDM0IiwidF9vZl9zZXhwJDIxIiwidF9zZXhwX2dyYW1tYXIkMjIiLCJpbnZhcmlhbnQkMTUiLCJzdWNjX2V4biIsIm1zZyIsInN1Y2MkMiIsInByZWRfZXhuIiwicHJlZCQxIiwib2Zfc2NhbGFyIiwib2Zfc2NhbGFyX2V4biIsInRvX3NjYWxhciIsInRvX2NoYXIiLCJ0b19jaGFyX2V4biIsInV0ZjhfYnl0ZV9sZW5ndGgiLCJ1Y2hhciIsImNvZGVwb2ludCIsInNleHBfb2ZfdCQzNSIsInJlZmwiLCJzeW0iLCJ0cmFucyIsImNvbnYiLCJkZXR1cGxlMiIsInR1cGxlMiIsInNleHBfb2ZfdCQzNiIsIndpdG5lc3MiLCJ2XzAwNSIsInRvX3NleHAiLCJuYW1lJDAiLCJjcmVhdGUkOSIsInVpZCIsImhhc2gkMTQiLCJoYXNoX2ZvbGRfdCQyNCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsImlzX25vbmUkMCIsImlzX3NvbWUkMCIsInNvbWUkMCIsInZhbHVlX3Vuc2FmZSIsInZhbHVlX2V4biQwIiwib2Zfc2V4cGFibGUiLCJ0b19zZXhwYWJsZSIsInRfb2Zfc2V4cCQyMyIsInhfMDAzIiwic2V4cF9vZl90JDM4Iiwib2ZfYV8wMDQiLCJ4XzAwNSIsInRfc2V4cF9ncmFtbWFyJDIzIiwiY3JlYXRlJDEwIiwiaW5pdCQ2IiwiaW5pdF9zb21lIiwiZ2V0JDQiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDEiLCJpc19zb21lJDEiLCJzZXQkMiIsInNldF9zb21lIiwic2V0X25vbmUiLCJzd2FwJDQiLCJ1bnNhZmVfZ2V0JDEiLCJ1bnNhZmVfZ2V0X3NvbWVfZXhuIiwidW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUiLCJ1bnNhZmVfaXNfc29tZSIsInVuc2FmZV9zZXQkMSIsInVuc2FmZV9zZXRfc29tZSIsInVuc2FmZV9zZXRfbm9uZSIsImNsZWFyIiwiZWxlbSIsImZvbGQkNSIsImZvbGRpJDYiLCJpdGVyJDciLCJpdGVyaSQ1IiwibGVuZ3RoJDgiLCJtYXAkMjUiLCJtYXBfc29tZSIsIm9mX2FycmF5JDAiLCJvZl9hcnJheV9zb21lIiwidG9fYXJyYXkkNiIsImNyZWF0ZV9saWtlJDEiLCJjYXBhY2l0eSIsImludmFyaWFudCQxNiIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsImNyZWF0ZSQxMSIsImxlbmd0aCQxMCIsImlzX2VtcHR5JDUiLCJmb2xkJDciLCJpdGVyJDkiLCJpdGVyJDEwIiwibGVuZ3RoJDExIiwib2ZfbGlzdCQzIiwic2V4cF9vZl90JDM5IiwidF9vZl9zZXhwJDI0IiwidF9zZXhwX2dyYW1tYXIkMjQiLCJyZXNpemUiLCJzaXplIiwic2V0X2NhcGFjaXR5IiwibmV3X2NhcGFjaXR5IiwibmV3X2NhcGFjaXR5JDAiLCJwdXNoIiwicG9wX25vbmVtcHR5IiwicG9wX2Vycm9yIiwicG9wIiwicG9wX2V4biIsInRvcF9ub25lbXB0eSIsInRvcF9lcnJvciIsInRvcCIsInRvcF9leG4iLCJjb3B5JDQiLCJjbGVhciQwIiwidW50aWxfZW1wdHkiLCJzaW5nbGV0b24kMiIsImhhc2gkMTUiLCJvZl9wb3MiLCJ0X29mX3NleHAkMjUiLCJzZXhwX29mX3QkNDAiLCJjb21wYXJlJDQyIiwiaGFzaF9mb2xkX3QkMjUiLCJoYXNoJDE2Iiwib2Zfc3RyaW5nJDExIiwidG9fc3RyaW5nJDEyIiwic3ltYm9sJDE1MiIsInN5bWJvbCQxNTMiLCJzeW1ib2wkMTU0Iiwic3ltYm9sJDE1NSIsInN5bWJvbCQxNTYiLCJzeW1ib2wkMTU3IiwiYXNjZW5kaW5nJDIyIiwiZGVzY2VuZGluZyQyMiIsImNvbXBhcmUkNDMiLCJlcXVhbCQyOCIsIm1heCQyOCIsIm1pbiQyOCIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsIm9mX2ludCQ0IiwidG9faW50X2V4biQwIiwiZmxpcCQxIiwic3ltYm9sJDE1OCIsImFsbCQxNSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsInRfb2Zfc2V4cCQyNyIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJzZXhwX2FyZ3NfMDEwIiwic2V4cF9vZl90JDQyIiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZzBfMDIyIiwicmVzMF8wMjMiLCJ0X3NleHBfZ3JhbW1hciQyNiIsImludGVydmFsX2NvbXBhcmlzb25fb2Zfc2V4cCIsInNleHBfMDI4Iiwic2V4cF9vZl9pbnRlcnZhbF9jb21wYXJpc29uIiwiY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uIiwiaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ludGVydmFsX2NvbXBhcmlzb24iLCJtYXAkMjYiLCJpbmNsIiwiZXhjbCIsImlzX2xvd2VyX2JvdW5kIiwiaXNfdXBwZXJfYm91bmQiLCJib3VuZHNfY3Jvc3NlZCIsImxvd2VyIiwidXBwZXIiLCJsb3dlciQwIiwidXBwZXIkMCIsImNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIiwiaW50ZXJ2YWxfY29udGFpbnNfZXhuIiwiY29tcGFyZSQ0NSIsInJpZ2h0XzAwNCIsImxlZnRfMDAzIiwiZXF1YWwkMzAiLCJhXzAwNSIsInJpZ2h0XzAwOCIsImxlZnRfMDA3Iiwic2V4cF9vZl90JDQzIiwib2ZfYV8wMDkiLCJ2XzAxMCIsImNvbXBhcmUkNDYiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsImVxdWFsJDMxIiwidF8wMzAiLCJ0XzAyOSIsInRfMDMyIiwidF8wMzEiLCJyaWdodF8wMzQiLCJsZWZ0XzAzMyIsInJpZ2h0XzAzOCIsImxlZnRfMDM3IiwidF8wNDAiLCJ0XzAzOSIsInRfMDQyIiwidF8wNDEiLCJyaWdodF8wMzYiLCJsZWZ0XzAzNSIsInRfb2Zfc2V4cCQyOCIsIm9mX2tfMDQzIiwib2Zfdl8wNDQiLCJzZXhwXzA3MSIsImFyZzFfMDY4IiwiYXJnMF8wNjciLCJyZXMwXzA2OSIsImF0b21fMDQ3Iiwic2V4cF9hcmdzXzA1MCIsImF0b21fMDQ3JDAiLCJhcmcwXzA1OCIsInJlczBfMDU5IiwiYXJnMF8wNjEiLCJyZXMwXzA2MiIsImFyZzBfMDY0IiwicmVzMF8wNjUiLCJyZXMxXzA3MCIsInNleHBfb2ZfdCQ0NCIsIm9mX2tfMDcyIiwib2Zfdl8wNzMiLCJhcmcxXzA4MiIsImFyZzBfMDgxIiwicmVzMF8wODMiLCJ2XzA3NCIsInJlczFfMDg0Iiwidl8wNzYiLCJhcmcxXzA3OCIsImFyZzBfMDc3IiwicmVzMF8wNzkiLCJyZXMxXzA4MCIsInZfMDc1IiwidF9zZXhwX2dyYW1tYXIkMjciLCJrX3NleHBfZ3JhbW1hciIsInZfc2V4cF9ncmFtbWFyIiwiY29tcGFyZSQ0NyIsImNtcF9sZWZ0IiwiY21wX3JpZ2h0IiwiYV8wODUiLCJiXzA4NiIsInJpZ2h0XzA5MiIsImxlZnRfMDkxIiwidF8wOTQiLCJ0XzA5MyIsInRfMDk2IiwidF8wOTUiLCJyaWdodF8wODgiLCJsZWZ0XzA4NyIsInJpZ2h0XzA5MCIsImxlZnRfMDg5IiwiZXF1YWwkMzIiLCJhXzA5NyIsImJfMDk4IiwicmlnaHRfMTA0IiwibGVmdF8xMDMiLCJ0XzEwNiIsInRfMTA1IiwidF8xMDgiLCJ0XzEwNyIsInJpZ2h0XzEwMCIsImxlZnRfMDk5IiwicmlnaHRfMTAyIiwibGVmdF8xMDEiLCJzZXhwX29mX3QkNDUiLCJvZl9sZWZ0XzEwOSIsIm9mX3JpZ2h0XzExMCIsInZfMTEzIiwiYXJnMV8xMTUiLCJhcmcwXzExNCIsInJlczBfMTE2IiwicmVzMV8xMTciLCJ2XzExMSIsInZfMTEyIiwiY29tcGFyZSQ0OCIsImVxdWFsJDMzIiwic2V4cF9vZl90JDQ2IiwiY29tcGFyZSQ0OSIsImVxdWFsJDM0Iiwic2V4cF9vZl90JDQ3IiwiaGVpZ2h0IiwibGVuZ3RoJDEyIiwiaW5fcmFuZ2UiLCJobCIsImhyIiwibG93ZXIkMSIsImludmFyaWFudHMiLCJpc19lbXB0eSQ2IiwiY3JlYXRlJDEyIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImskMCIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhZGQkMSIsImF1eCIsImpvaW4kNiIsInJoIiwicnYkMCIsIm1pbl9lbHQkNyIsIm1pbl9lbHRfZXhuIiwiZm9sZF91bnRpbCQ2IiwiZm9sZF91bnRpbF9oZWxwZXIiLCJtYXhfZWx0JDciLCJwYXJhbSQxIiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsIm1lcmdlJDIiLCJjb25jYXQkMyIsInNwbGl0JDEiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImFscmVhZHlfc2VlbiIsIm1lbSQ1IiwicmVtb3ZlJDAiLCJyZW1vdmVfaW5kZXgiLCJsX3NpemUiLCJ1bmlvbiIsInYyJDAiLCJyMiQwIiwidW5pb25fbGlzdCIsInRvX3RyZWUiLCJpbnRlciIsInYxJDAiLCJvdGhlcl9zZXQiLCJjb25zJDAiLCJlJDAiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiaXRlciQxMSIsImVudW0kMCIsInRyZWUiLCJzeW1tZXRyaWNfZGlmZiIsImVudW0yIiwidHJlZTIiLCJjb21wYXJlX3Jlc3VsdCIsIm5leHRfc3RhdGUiLCJ0b19zZXF1ZW5jZSQwIiwiZ3JlYXRlcl9vcl9lcXVhbF90byIsImxlc3Nfb3JfZXF1YWxfdG8iLCJpbmNsdXNpdmVfYm91bmQiLCJzaWRlIiwibWF5YmUiLCJ0JDYiLCJ2JDIiLCJ2JDMiLCJ2JDQiLCJlJDIiLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmckMCIsImZpbmRfbGFzdF9zYXRpc2Z5aW5nJDAiLCJiaW5hcnlfc2VhcmNoJDEiLCJlbHQkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDEiLCJtZXJnZV90b19zZXF1ZW5jZSIsImNvbXBhcmUkNTAiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJpdGVyMiQwIiwiZW51bTEiLCJ0cmVlMSIsInQyJDIiLCJ0MSQyIiwiZXF1YWwkMzUiLCJpc19zdWJzZXQiLCJhcmVfZGlzam9pbnQiLCJpdGVyJDEyIiwiZm9sZCQ4IiwiYWNjdSIsImFjY3UkMCIsImFjY3UkMSIsImNvdW50JDYiLCJzdW0kNiIsImZvbGRfcmlnaHQkMSIsImZvcl9hbGwkNyIsImV4aXN0cyQ3IiwiZmlsdGVyJDQiLCJmaWx0IiwiZmlsdGVyX21hcCQyIiwicGFydGl0aW9uX3RmJDEiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJub3RfZm91bmQkMTIiLCJjaG9vc2VfZXhuIiwib2ZfbGlzdCQ0Iiwib2Zfc2VxdWVuY2UkMCIsInRvX2xpc3QkOCIsIm9mX2FycmF5JDEiLCJ0b19hcnJheSQ3IiwicG9zX3JlZiIsIm1hcCQyNyIsImdyb3VwX2J5IiwiZXF1aXYiLCJlcXVpdl9jbGFzc2VzIiwiZXF1aXZfeCIsImVxdWl2X2NsYXNzZXMkMCIsImZpbmQkNyIsImZpbmRfbWFwJDYiLCJmaW5kX2V4biQzIiwibnRoJDEiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiQwIiwiYWxyZWFkeV9zZWVuJDEiLCJsZWZ0b3ZlcnMkMCIsInRfb2Zfc2V4cF9kaXJlY3QiLCJlbHRfbHN0IiwiZWxfc2V4cCIsInNleHBfb2ZfdCQ0OCIsImlzX3N1YnNldCQwIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJzZXhwX29mX2VsdCIsImludmFsaWRfZWxlbWVudHMiLCJpbnZhbGlkX2VsZW1lbnRzX3NleHAiLCJsaWtlIiwiY29tcGFyYXRvciQxMiIsImludmFyaWFudHMkMCIsImxlbmd0aCQxMyIsImlzX2VtcHR5JDciLCJlbGVtZW50cyQwIiwibWluX2VsdCQ4IiwibWluX2VsdF9leG4kMCIsIm1heF9lbHQkOCIsIm1heF9lbHRfZXhuJDAiLCJjaG9vc2UkMCIsImNob29zZV9leG4kMCIsInRvX2xpc3QkOSIsInRvX2FycmF5JDgiLCJmb2xkJDkiLCJmb2xkX3VudGlsJDciLCJmb2xkX3JpZ2h0JDIiLCJmb2xkX3Jlc3VsdCQ2IiwiaXRlciQxMyIsIml0ZXIyJDEiLCJleGlzdHMkOCIsImZvcl9hbGwkOCIsImNvdW50JDciLCJzdW0kNyIsImZpbmQkOCIsImZpbmRfZXhuJDQiLCJmaW5kX21hcCQ3IiwibWVtJDYiLCJmaWx0ZXIkNSIsImFkZCQyIiwicmVtb3ZlJDEiLCJ1bmlvbiQwIiwiaW50ZXIkMCIsImRpZmYkMCIsInN5bW1ldHJpY19kaWZmJDAiLCJjb21wYXJlX2RpcmVjdCIsImVxdWFsJDM2IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwiZXF1YWwkMzciLCJwYXJ0aXRpb25fdGYkMiIsInRyZWVfZiIsInRyZWVfdCIsInNwbGl0JDIiLCJncm91cF9ieSQwIiwibnRoJDIiLCJyZW1vdmVfaW5kZXgkMCIsInNleHBfb2ZfdCQ0OSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDIiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQyIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJoYXNoX2ZvbGRfa2V5IiwiY29tcGFyZSQ1MSIsInRfb2Zfc2V4cF9kaXJlY3QkMCIsImVtcHR5JDEiLCJzaW5nbGV0b24kMyIsImxlbmd0aCQxNCIsImludmFyaWFudHMkMSIsImlzX2VtcHR5JDgiLCJlbGVtZW50cyQxIiwibWluX2VsdCQ5IiwibWluX2VsdF9leG4kMSIsIm1heF9lbHQkOSIsIm1heF9lbHRfZXhuJDEiLCJjaG9vc2UkMSIsImNob29zZV9leG4kMSIsInRvX2xpc3QkMTAiLCJ0b19hcnJheSQ5IiwiaXRlciQxNCIsImV4aXN0cyQ5IiwiZm9yX2FsbCQ5IiwiY291bnQkOCIsInN1bSQ4IiwiZmluZCQ5IiwiZmluZF9leG4kNSIsImZpbmRfbWFwJDgiLCJmb2xkJDEwIiwiZm9sZF91bnRpbCQ4IiwiZm9sZF9yaWdodCQzIiwibWFwJDI4IiwiZmlsdGVyJDYiLCJmaWx0ZXJfbWFwJDMiLCJwYXJ0aXRpb25fdGYkMyIsIml0ZXIyJDIiLCJtZW0kNyIsImFkZCQzIiwicmVtb3ZlJDIiLCJ1bmlvbiQxIiwiaW50ZXIkMSIsImRpZmYkMSIsInN5bW1ldHJpY19kaWZmJDEiLCJjb21wYXJlX2RpcmVjdCQwIiwiZXF1YWwkMzgiLCJpc19zdWJzZXQkMyIsImFyZV9kaXNqb2ludCQxIiwib2ZfbGlzdCQ1Iiwib2Zfc2VxdWVuY2UkMSIsIm9mX2FycmF5JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDAiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMCIsIm9mX3NvcnRlZF9hcnJheSQwIiwidW5pb25fbGlzdCQwIiwic3RhYmxlX2RlZHVwX2xpc3QkMCIsImdyb3VwX2J5JDEiLCJzcGxpdCQzIiwibnRoJDMiLCJyZW1vdmVfaW5kZXgkMSIsInNleHBfb2ZfdCQ1MCIsIm9mX3RyZWUiLCJ0b19zZXF1ZW5jZSQyIiwiYmluYXJ5X3NlYXJjaCQzIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkMyIsIm1lcmdlX3RvX3NlcXVlbmNlJDEiLCJmb2xkX3Jlc3VsdCQ3IiwiaXNfc3Vic2V0JDQiLCJlcXVhbCQzOSIsInRvX3RyZWUkMCIsIm9mX3RyZWUkMCIsInRfb2Zfc2V4cF9kaXJlY3QkMSIsImVtcHR5JDIiLCJzaW5nbGV0b24kNCIsInVuaW9uX2xpc3QkMSIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMSIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQxIiwib2Zfc29ydGVkX2FycmF5JDEiLCJvZl9saXN0JDYiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMyIsInN0YWJsZV9kZWR1cF9saXN0JDEiLCJtYXAkMjkiLCJmaWx0ZXJfbWFwJDQiLCJjb21wYXJhdG9yX3MiLCJlbXB0eSQzIiwic2luZ2xldG9uJDUiLCJ1bmlvbl9saXN0JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDIiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMiIsIm9mX3NvcnRlZF9hcnJheSQyIiwib2ZfbGlzdCQ3Iiwib2Zfc2VxdWVuY2UkMyIsIm9mX2FycmF5JDQiLCJzdGFibGVfZGVkdXBfbGlzdCQyIiwibWFwJDMwIiwiZmlsdGVyX21hcCQ1Iiwic2V4cF9vZl9tX3QiLCJFbHQiLCJtX3Rfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX21fdCIsImVxdWFsX21fdCIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX21fdCIsImNvbXBhcmF0b3IkMTMiLCJlbXB0eSQ0Iiwic2luZ2xldG9uJDYiLCJ1bmlvbl9saXN0JDMiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDMiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMyIsIm9mX3NvcnRlZF9hcnJheSQzIiwib2ZfbGlzdCQ4Iiwib2Zfc2VxdWVuY2UkNCIsIm9mX2FycmF5JDUiLCJzdGFibGVfZGVkdXBfbGlzdCQzIiwibWFwJDMxIiwiZmlsdGVyX21hcCQ2Iiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwidF9zZXhwX2dyYW1tYXIkMjgiLCJzd2FwJDUiLCJyZXBsYWNlIiwic2V0X3RlbXBvcmFyaWx5IiwicmVzdG9yZV90byIsInNldCQzIiwic2V0cyIsInNuYXBzaG90Iiwic2V0c190ZW1wb3JhcmlseSIsImFuZF92YWx1ZXMiLCJpbmNfbnVtX211dGF0aW9ucyIsImNhcGFjaXR5JDAiLCJlbHRzX2luZGV4IiwidW5zYWZlX2dldCQyIiwidW5zYWZlX3NldCQyIiwiY2hlY2tfaW5kZXhfZXhuIiwiZ2V0JDUiLCJzZXQkNCIsImlzX2VtcHR5JDkiLCJsZW5ndGgkMTUiLCJlbnN1cmVfbm9fbXV0YXRpb24iLCJudW1fbXV0YXRpb25zIiwibnVtX211dGF0aW9uc18wMDMiLCJmcm9udF8wMDUiLCJtYXNrXzAwNyIsImxlbmd0aF8wMDkiLCJlbHRzXzAxMSIsImJuZHNfMDAyJDEiLCJibmRzXzAwMiQyIiwiYm5kc18wMDIkMyIsImNvbXBhcmUkNTIiLCJlcXVhbCQ0MCIsImludmFyaWFudCQxNyIsImZyb250IiwiY3JlYXRlJDEzIiwiY2FwYWNpdHkkMSIsImJsaXRfdG9fYXJyYXkiLCJmcm9udF9sZW4iLCJyZXN0X2xlbiIsInNldF9jYXBhY2l0eSQwIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwibGFzdCQxIiwibGFzdF9leG4kMCIsImNsZWFyJDEiLCJibGl0X3RyYW5zZmVyIiwibGVuJDEiLCJkc3Rfc3RhcnQiLCJzcmNfaSIsImRzdF9pIiwiZW5xdWV1ZV9hbGwiLCJmb2xkJDExIiwiZm9sZGkkOCIsIml0ZXIkMTUiLCJpdGVyaSQ3IiwidG9fbGlzdCQxMSIsIml0ZXIkMTYiLCJsZW5ndGgkMTYiLCJmb2xkaSQ5IiwiaXRlcmkkOCIsImNvdW50JDkiLCJleGlzdHMkMTAiLCJmaW5kJDEwIiwiZmluZF9tYXAkOSIsImZvbGRfcmVzdWx0JDgiLCJmb2xkX3VudGlsJDkiLCJmb3JfYWxsJDEwIiwibWF4X2VsdCQxMCIsIm1lbSQ4IiwibWluX2VsdCQxMCIsInN1bSQ5IiwiY291bnRpJDUiLCJleGlzdHNpJDUiLCJmaW5kX21hcGkkNSIsImZpbmRpJDUiLCJmb3JfYWxsaSQ1IiwiY29uY2F0X21hcCQyIiwidF9yZXN1bHQiLCJjb25jYXRfbWFwaSQyIiwiZmlsdGVyX21hcCQ3IiwiZmlsdGVyX21hcGkkMiIsImZpbHRlciQ3IiwiZmlsdGVyaSQzIiwiZmlsdGVyX2lucGxhY2UiLCJmaWx0ZXJpX2lucGxhY2UiLCJjb3B5JDUiLCJvZl9saXN0JDkiLCJpbml0JDciLCJvZl9hcnJheSQ2IiwidG9fYXJyYXkkMTAiLCJtYXAkMzIiLCJtYXBpJDYiLCJzaW5nbGV0b24kNyIsInNleHBfb2ZfdCQ1MSIsInRfb2Zfc2V4cCQyOSIsInRfc2V4cF9ncmFtbWFyJDI5IiwidG9fc3RyaW5nJDE0IiwiYWxsJDE4IiwiaGFzaF9mb2xkX3QkMjciLCJjb21wYXJlJDUzIiwidF9vZl9zZXhwJDMwIiwib2Zfc3RyaW5nJDEzIiwiZnVuYyQ5IiwiaGFzaGFibGUkNiIsImNvbXBhcmUkNTYiLCJ0b19zdHJpbmckMTYiLCJvZl9zdHJpbmckMTUiLCJ6ZXJvJDAiLCJoYXNoJDE5IiwiemVybyQxIiwibmVnJDEiLCJzeW1ib2wkMTcxIiwidG9fc3RyaW5nJDE3Iiwib2Zfc3RyaW5nJDE2IiwiaW52YXJpYW50JDE4IiwibnVtX2JpdHMkMSIsImZsb2F0X2xvd2VyX2JvdW5kJDAiLCJmbG9hdF91cHBlcl9ib3VuZCQwIiwibHNyJDAiLCJhc3IkMCIsImxzbCQwIiwibG5vdCQxIiwibHhvciQwIiwibG9yJDAiLCJsYW5kJDAiLCJtaW5fdmFsdWUkMyIsIm1heF92YWx1ZSQzIiwiYWJzJDMiLCJwcmVkJDIiLCJzdWNjJDMiLCJyZW0kMCIsIm5lZyQyIiwibWludXNfb25lJDAiLCJvbmUkMCIsInplcm8kMiIsInRvX2Zsb2F0JDEiLCJvZl9mbG9hdF91bmNoZWNrZWQkMCIsIm9mX2Zsb2F0JDAiLCJub25fcG9zaXRpdmVfYXJndW1lbnQkMCIsImNlaWxfcG93MiQwIiwiZmxvb3JfcG93MiQwIiwiaXNfcG93MiQwIiwiZmxvb3JfbG9nMiQwIiwiY2VpbF9sb2cyJDAiLCJiZXR3ZWVuJDExIiwiY2xhbXBfdW5jaGVja2VkJDMiLCJjbGFtcF9leG4kMTEiLCJjbGFtcCQxMSIsInN5bWJvbCQxNzIiLCJzeW1ib2wkMTczIiwic3ltYm9sJDE3NCIsInN5bWJvbCQxNzUiLCJpbmNyJDEiLCJkZWNyJDEiLCJvZl9uYXRpdmVpbnQiLCJ0b19uYXRpdmVpbnQkMCIsInBvdyQwIiwic3ltYm9sJDE3NiIsInN5bWJvbCQxNzciLCJzeW1ib2wkMTc4Iiwic3ltYm9sJDE3OSIsInN5bWJvbCQxODAiLCJzeW1ib2wkMTgxIiwic3ltYm9sJDE4MiIsImNvbXBhcmVfbmF0aXZlaW50JDAiLCJlcXVhbF9uYXRpdmVpbnQkMSIsImNvbXBhcmUkNTciLCJhbGwkMTkiLCJlcXVhbCQ0MiIsInNleHBfb2ZfdCQ1NCIsIm9mX2NvbnRpbnVlX29yX3N0b3AiLCJ0b19jb250aW51ZV9vcl9zdG9wIiwiY29tcGFyZSQ1OCIsImVxdWFsJDQzIiwic2V4cF9vZl90JDU1IiwibGVmdF92YWx1ZSIsInJpZ2h0X3ZhbHVlIiwidmFsdWVzIiwibGVmdF9kZWZhdWx0IiwicmlnaHRfZGVmYXVsdCIsInJpZ2h0JDAiLCJoZWlnaHQkMCIsImluX3JhbmdlJDAiLCJjb21wYXJlX2tleSIsImxvb3AkMCIsImludmFyaWFudHMkMiIsImNyZWF0ZSQxNCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ0IiwidmwiLCJ2bCQwIiwidnIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDQiLCJrMCIsImsxIiwib2Zfc29ydGVkX2FycmF5JDQiLCJiYWwkMCIsImxkIiwibHJkIiwibHJkJDAiLCJyZCIsInJsZCIsInJsZCQwIiwiZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvIiwiaXNfZW1wdHkkMTAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNldCQ1Iiwic2V0JDYiLCJzaW5nbGV0b25fdG9fdHJlZV9leG4iLCJjb2xsYXBzZSIsImpvaW4kNyIsImdvIiwiYWRkX3VuY2hlY2tlZCIsImdvJDAiLCJ0b190cmVlX3VuY2hlY2tlZCIsIm1heF9rZXkiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIiwiYnVpbGRlciIsInByZXZfa2V5Iiwiam9pbiQ4IiwicmsiLCJyZCQwIiwicmskMCIsImxrIiwic3BsaXQkNCIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJmaW5kJDExIiwiYWRkX211bHRpIiwiZGF0YSQwIiwiZmluZF9tdWx0aSIsImZpbmRfZXhuJDYiLCJtZW0kOSIsIm1pbl9lbHQkMTEiLCJtaW5fZWx0X2V4biQyIiwibWF4X2VsdCQxMSIsIm1heF9lbHRfZXhuJDIiLCJyZW1vdmVfbWluX2VsdCQwIiwiYXBwZW5kJDIiLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm1pbl91cHBlciIsIm1heF9sb3dlciIsInVwcGVyX3BhcnRfd2l0aG91dF9taW4iLCJnbyQxIiwiY19taW4iLCJjX21heCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlIiwicmFuZ2VfdG9fYWxpc3QiLCJjb25jYXRfdW5jaGVja2VkIiwicmVtb3ZlJDMiLCJyZW1vdmVfbG9vcCIsImNoYW5nZSIsImNoYW5nZV9jb3JlIiwiZCQxIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJpdGVyX2tleXMiLCJpdGVyJDE3IiwiaXRlcmkkOSIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsIm1hcCQzMyIsIm1hcGkkNyIsImZvbGQkMTIiLCJmb2xkX3VudGlsJDEwIiwiZm9sZF91bnRpbF9sb29wIiwiZmluYWwkMSIsImZpbmFsJDAiLCJmb2xkX3JpZ2h0JDQiLCJmaWx0ZXJfa2V5cyIsImZpbHRlciQ4IiwiZmlsdGVyaSQ0IiwiZmlsdGVyX21hcCQ4IiwiZmlsdGVyX21hcGkkMyIsInBhcnRpdGlvbl9tYXBpIiwicGFpcjIiLCJwYWlyMSIsInBhcnRpdGlvbl9tYXAkMCIsInBhcnRpdGlvbmlfdGYkMCIsInBhcnRpdGlvbl90ZiQ0IiwiY29ucyQxIiwiY29uc19yaWdodCQwIiwib2ZfdHJlZSQyIiwiZm9sZCQxMyIsImZvbGQyJDAiLCJjdXJyIiwiY3VyciQwIiwiazIiLCJjdXJyJDEiLCJjdXJyJDIiLCJjdXJyJDMiLCJzeW1tZXRyaWNfZGlmZiQyIiwiZGF0YV9lcXVhbCIsInRvX3NlcXVlbmNlJDMiLCJrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8iLCJrZXlzX2xlc3Nfb3JfZXF1YWxfdG8iLCJkJDIiLCJjb21wYXJlJDU5IiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImVxdWFsJDQ0IiwiaXRlcjIkMyIsImZvbGQyJDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwiYWNjJDgiLCJyaWdodCQyIiwibGVmdCQyIiwicmlnaHQkMSIsImxlbmd0aCQxNyIsImtleXMiLCJvZl9mb2xkYWJsZV9mb2xkIiwiZm9sZGFibGUiLCJwcmV2X2RhdGEiLCJvZl9mb2xkYWJsZV9yZWR1Y2UiLCJuZXdfZGF0YSIsIm9mX2ZvbGRhYmxlIiwib2ZfZm9sZGFibGVfb3JfZXJyb3IiLCJvZl9mb2xkYWJsZV9leG4iLCJvZl9hbGlzdF9mb2xkIiwib2ZfYWxpc3RfcmVkdWNlIiwib2ZfYWxpc3QiLCJvZl9hbGlzdF9vcl9lcnJvciIsIm9mX2FsaXN0X2V4biIsIm9mX2ZvbGRhYmxlX211bHRpIiwib2ZfYWxpc3RfbXVsdGkiLCJvZl9zZXF1ZW5jZV9mb2xkIiwib2Zfc2VxdWVuY2VfcmVkdWNlIiwib2Zfc2VxdWVuY2UkNSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJmb3JfYWxsJDExIiwiZm9yX2FsbGkkNiIsImV4aXN0cyQxMSIsImV4aXN0c2kkNiIsImNvdW50JDEwIiwiY291bnRpJDYiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlJDMiLCJtZXJnZV9sYXJnZV9maXJzdCIsImxlbmd0aF9sYXJnZSIsInRfbGFyZ2UiLCJ0X3NtYWxsIiwiY2FsbCQwIiwic3dhcCQ2IiwibWVyZ2Vfc2tld2VkIiwibGVuZ3RoMSIsImxlbmd0aDIiLCJyZXBhY2thZ2UiLCJtYXJrZXIiLCJjbG9zZXN0X2tleSIsImZvdW5kX21hcmtlciIsImZvdW5kX2tleSIsImZvdW5kX3ZhbHVlIiwicmFuayIsIm50aCQ0IiwibnVtX3RvX3NlYXJjaCIsIm50aCQ1IiwiZmluZF9maXJzdF9zYXRpc2Z5aW5nJDEiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyQxIiwiYmluYXJ5X3NlYXJjaCQ0IiwicGFpciIsInBhaXIkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDQiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwidF9vZl9zZXhwX2RpcmVjdCQyIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdCQ1NiIsInNleHBfb2ZfdmFsdWUiLCJjb21iaW5lX2Vycm9ycyQxIiwiZXJyb3JfdHJlZSIsIm9rcyIsIm1hcF9rZXlzIiwibWFwX2tleXNfZXhuIiwibGlrZSQwIiwibGlrZTIiLCJsaWtlX21heWJlX25vX29wIiwib2xkX3QiLCJvbGRfdHJlZSIsIndpdGhfc2FtZV9sZW5ndGgiLCJvZl90cmVlJDMiLCJjb21wYXJhdG9yJDE2IiwidG9fdHJlZSQyIiwiaW52YXJpYW50cyQzIiwiaXNfZW1wdHkkMTEiLCJsZW5ndGgkMTgiLCJzZXQkNyIsImFkZF9leG4kMCIsImFkZF9leG5faW50ZXJuYWwkMCIsImFkZCQ0IiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJmaW5kX2V4biQ3IiwiZmluZCQxMiIsInJlbW92ZSQ0IiwibWVtJDEwIiwiaXRlcl9rZXlzJDAiLCJpdGVyJDE4IiwiaXRlcmkkMTAiLCJpdGVyaV91bnRpbCQwIiwiaXRlcjIkNCIsIm1hcCQzNCIsIm1hcGkkOCIsImZvbGQkMTQiLCJmb2xkX3VudGlsJDExIiwiZm9sZF9yaWdodCQ1IiwiZm9sZDIkMiIsImZpbHRlcl9rZXlzJDAiLCJmaWx0ZXIkOSIsImZpbHRlcmkkNSIsImZpbHRlcl9tYXAkOSIsImZpbHRlcl9tYXBpJDQiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwicGFydGl0aW9uX3RmJDUiLCJjb21iaW5lX2Vycm9ycyQyIiwiY29tcGFyZV9kaXJlY3QkMSIsImVxdWFsJDQ1Iiwia2V5cyQwIiwidG9fYWxpc3QkMCIsInN5bW1ldHJpY19kaWZmJDMiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQ0IiwibWVyZ2Vfc2tld2VkJDAiLCJtaW5fZWx0JDEyIiwibWluX2VsdF9leG4kMyIsIm1heF9lbHQkMTIiLCJtYXhfZWx0X2V4biQzIiwiZm9yX2FsbCQxMiIsImZvcl9hbGxpJDciLCJleGlzdHMkMTIiLCJleGlzdHNpJDciLCJjb3VudCQxMSIsImNvdW50aSQ3Iiwic3BsaXQkNSIsImJvdGhfbGVuIiwic3VicmFuZ2UiLCJoX2wiLCJoX3IiLCJvdXRlcl9qb2luZWRfaGVpZ2h0IiwibWlkX2xlbmd0aCIsImFwcGVuZCQzIiwiZm9sZF9yYW5nZV9pbmNsdXNpdmUkMCIsInJhbmdlX3RvX2FsaXN0JDAiLCJjbG9zZXN0X2tleSQwIiwibnRoJDYiLCJudGhfZXhuJDEiLCJyYW5rJDAiLCJzZXhwX29mX3QkNTciLCJzZXhwX29mX2siLCJzZXhwX29mX3YiLCJ0b19zZXF1ZW5jZSQ0IiwiYmluYXJ5X3NlYXJjaCQ1IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkNSIsImhhc2hfZm9sZF9kaXJlY3QkMCIsImhhc2hfZm9sZF9kYXRhIiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSIsImVtcHR5JDYiLCJvZl90cmVlJDQiLCJzaW5nbGV0b24kOCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkNSIsIm9mX3NvcnRlZF9hcnJheSQ1Iiwib2ZfYWxpc3QkMCIsIm9mX2FsaXN0X29yX2Vycm9yJDAiLCJvZl9hbGlzdF9leG4kMCIsIm9mX2FsaXN0X211bHRpJDAiLCJvZl9hbGlzdF9mb2xkJDAiLCJvZl9hbGlzdF9yZWR1Y2UkMCIsIm9mX2l0ZXJpJDAiLCJvZl9pdGVyaV9leG4kMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ1IiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlJDYiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQwIiwib2Zfc2VxdWVuY2VfZXhuJDAiLCJvZl9zZXF1ZW5jZV9tdWx0aSQwIiwib2Zfc2VxdWVuY2VfZm9sZCQwIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDAiLCJ0b190cmVlJDMiLCJpbnZhcmlhbnRzJDQiLCJpc19lbXB0eSQxMiIsImxlbmd0aCQxOSIsInNldCQ4IiwiYWRkX2V4biQxIiwiYWRkJDUiLCJhZGRfbXVsdGkkMSIsInJlbW92ZV9tdWx0aSQxIiwiZmluZF9tdWx0aSQxIiwiY2hhbmdlJDEiLCJ1cGRhdGUkMSIsImZpbmRfZXhuJDgiLCJmaW5kJDEzIiwicmVtb3ZlJDUiLCJtZW0kMTEiLCJpdGVyX2tleXMkMSIsIml0ZXIkMTkiLCJpdGVyaSQxMSIsIml0ZXJpX3VudGlsJDEiLCJpdGVyMiQ1IiwibWFwJDM1IiwibWFwaSQ5IiwiZm9sZCQxNSIsImZvbGRfdW50aWwkMTIiLCJmb2xkX3JpZ2h0JDYiLCJmb2xkMiQzIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlciQxMCIsImZpbHRlcmkkNiIsImZpbHRlcl9tYXAkMTAiLCJmaWx0ZXJfbWFwaSQ1IiwicGFydGl0aW9uX21hcGkkMSIsInBhcnRpdGlvbl9tYXAkMiIsInBhcnRpdGlvbmlfdGYkMiIsInBhcnRpdGlvbl90ZiQ2IiwiY29tYmluZV9lcnJvcnMkMyIsImNvbXBhcmVfZGlyZWN0JDIiLCJlcXVhbCQ0NiIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJzeW1tZXRyaWNfZGlmZiQ0IiwiZm9sZF9zeW1tZXRyaWNfZGlmZiQxIiwibWVyZ2UkNSIsIm1lcmdlX3NrZXdlZCQxIiwibWluX2VsdCQxMyIsIm1pbl9lbHRfZXhuJDQiLCJtYXhfZWx0JDEzIiwibWF4X2VsdF9leG4kNCIsImZvcl9hbGwkMTMiLCJmb3JfYWxsaSQ4IiwiZXhpc3RzJDEzIiwiZXhpc3RzaSQ4IiwiY291bnQkMTIiLCJjb3VudGkkOCIsInNwbGl0JDYiLCJhcHBlbmQkNCIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkNyIsIm50aF9leG4kMiIsInJhbmskMSIsInNleHBfb2ZfdCQ1OCIsInRfb2Zfc2V4cF9kaXJlY3QkMyIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsInRvX3NlcXVlbmNlJDUiLCJiaW5hcnlfc2VhcmNoJDYiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQ2IiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSQwIiwibWFwX2tleXMkMCIsImR1cCIsIm1hcF9rZXlzX2V4biQwIiwiYWRkX2V4biQyIiwidG9fdHJlZSQ0IiwiZW1wdHkkNyIsInNpbmdsZXRvbiQ5Iiwib2ZfdHJlZTAiLCJvZl90cmVlJDUiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDYiLCJvZl9zb3J0ZWRfYXJyYXkkNiIsIm9mX2FsaXN0JDEiLCJvZl9hbGlzdF9vcl9lcnJvciQxIiwib2ZfYWxpc3RfZXhuJDEiLCJvZl9hbGlzdF9tdWx0aSQxIiwib2ZfYWxpc3RfZm9sZCQxIiwib2ZfYWxpc3RfcmVkdWNlJDEiLCJvZl9pdGVyaSQxIiwidHJlZV9sZW5ndGgiLCJvZl9pdGVyaV9leG4kMSIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ2Iiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2UkNyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDEiLCJvZl9zZXF1ZW5jZV9leG4kMSIsIm9mX3NlcXVlbmNlX211bHRpJDEiLCJvZl9zZXF1ZW5jZV9mb2xkJDEiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMSIsInRfb2Zfc2V4cF9kaXJlY3QkNCIsIm1hcF9rZXlzJDEiLCJtYXBfa2V5c19leG4kMSIsImNvbXBhcmF0b3JfcyQwIiwib2ZfdHJlZSQ2IiwiZW1wdHkkOCIsInNpbmdsZXRvbiQxMCIsIm9mX2FsaXN0JDIiLCJvZl9hbGlzdF9vcl9lcnJvciQyIiwib2ZfYWxpc3RfZXhuJDIiLCJvZl9hbGlzdF9tdWx0aSQyIiwib2ZfYWxpc3RfZm9sZCQyIiwib2ZfYWxpc3RfcmVkdWNlJDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDciLCJvZl9zb3J0ZWRfYXJyYXkkNyIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ3Iiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQyIiwib2Zfc2VxdWVuY2UkOCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsInNleHBfb2ZfbV90JDAiLCJLIiwibV90X29mX3NleHAkMCIsIm1fdF9zZXhwX2dyYW1tYXIkMCIsInZfZ3JhbW1hciIsImNvbXBhcmVfbV90JDAiLCJjb21wYXJlX3YiLCJlcXVhbF9tX3QkMCIsImVxdWFsX3YiLCJoYXNoX2ZvbGRfbV90JDAiLCJoYXNoX2ZvbGRfdiIsImNvbXBhcmF0b3IkMTciLCJvZl90cmVlJDciLCJlbXB0eSQ5Iiwic2luZ2xldG9uJDExIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkOCIsIm9mX3NvcnRlZF9hcnJheSQ4Iiwib2ZfaXRlcmkkMyIsIm9mX2l0ZXJpX2V4biQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDgiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDMiLCJvZl9zZXF1ZW5jZSQ5Iiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMyIsIm9mX3NlcXVlbmNlX2V4biQzIiwib2Zfc2VxdWVuY2VfbXVsdGkkMyIsIm9mX3NlcXVlbmNlX2ZvbGQkMyIsIm9mX3NlcXVlbmNlX3JlZHVjZSQzIiwibWFwX2tleXMkMyIsIm1hcF9rZXlzX2V4biQzIiwiY3JlYXRlJDE1IiwiY2xlYXIkMiIsImNvcHkkNiIsImlzX2VtcHR5JDEzIiwibGVuZ3RoJDIwIiwicGVla19leG4kMCIsImRlcXVldWVfZXhuJDAiLCJwdXNoJDAiLCJ0cmFuc2ZlciIsIml0ZXIkMjAiLCJmb2xkJDE2IiwiZW5xdWV1ZSQwIiwiZGVxdWV1ZSQwIiwicGVlayQwIiwiaXRlciQyMSIsImxlbmd0aCQyMSIsImNvdW50JDEzIiwiZXhpc3RzJDE0IiwiZmluZCQxNCIsImZpbmRfbWFwJDEwIiwiZm9sZF9yZXN1bHQkOSIsImZvbGRfdW50aWwkMTMiLCJmb3JfYWxsJDE0IiwibWF4X2VsdCQxNCIsIm1lbSQxMiIsIm1pbl9lbHQkMTQiLCJzdW0kMTAiLCJ0b19saXN0JDEyIiwiY291bnRpJDkiLCJleGlzdHNpJDkiLCJmaW5kX21hcGkkNiIsImZpbmRpJDYiLCJmb2xkaSQxMCIsImZvcl9hbGxpJDkiLCJpdGVyaSQxMiIsInRyYW5zZmVyJDAiLCJjb25jYXRfbWFwJDMiLCJjb25jYXRfbWFwaSQzIiwiZmlsdGVyX21hcCQxMSIsImZpbHRlcl9tYXBpJDYiLCJmaWx0ZXIkMTEiLCJmaWx0ZXJpJDciLCJtYXAkMzYiLCJtYXBpJDEwIiwiZmlsdGVyX2lucGxhY2UkMCIsInEiLCJxJDAiLCJmaWx0ZXJpX2lucGxhY2UkMCIsImVucXVldWVfYWxsJDAiLCJvZl9saXN0JDEwIiwib2ZfYXJyYXkkNyIsImluaXQkOCIsInRvX2FycmF5JDExIiwidF9vZl9zZXhwJDMyIiwic2V4cF9vZl90JDU5IiwidF9zZXhwX2dyYW1tYXIkMzEiLCJzaW5nbGV0b24kMTIiLCJmdW5jJDEwIiwiaGFzaGFibGUkNyIsImNvbXBhcmUkNjAiLCJ0b19zdHJpbmckMTgiLCJvZl9zdHJpbmckMTciLCJmbG9hdF9sb3dlcl9ib3VuZCQxIiwiZmxvYXRfdXBwZXJfYm91bmQkMSIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0Iiwic2hpZnRfcmlnaHRfbG9naWNhbCQwIiwic2hpZnRfcmlnaHQkMSIsInNoaWZ0X2xlZnQkMCIsImxub3QkMiIsImJpdF94b3IkMCIsImJpdF9vciQwIiwiYml0X2FuZCQwIiwibWluX3ZhbHVlJDQiLCJtYXhfdmFsdWUkNCIsImFicyQ0IiwicHJlZCQzIiwic3VjYyQ0IiwicG93JDEiLCJyZW0kMSIsIm5lZyQzIiwibWludXNfb25lJDEiLCJvbmUkMSIsInplcm8kMyIsInRvX2Zsb2F0JDIiLCJvZl9mbG9hdF91bmNoZWNrZWQkMSIsIm51bV9iaXRzJDIiLCJvZl9mbG9hdCQxIiwic3ltYm9sJDE5MiIsImJzd2FwMTYiLCJic3dhcDMyIiwiYnN3YXA0OCIsImludmFyaWFudCQxOSIsImJldHdlZW4kMTIiLCJjbGFtcF91bmNoZWNrZWQkNCIsImNsYW1wX2V4biQxMiIsImNsYW1wJDEyIiwiaW5jciQyIiwiZGVjciQyIiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9pbnRfZXhuJDAiLCJvZl9pbnQzMl9leG4iLCJub25fcG9zaXRpdmVfYXJndW1lbnQkMSIsImNlaWxfcG93MiQxIiwiZmxvb3JfcG93MiQxIiwiaXNfcG93MiQxIiwiZmxvb3JfbG9nMiQxIiwiY2VpbF9sb2cyJDEiLCJzZXhwX29mX2ludDY0IiwiaGFzaCQyMCIsInN5bWJvbCQxOTMiLCJ0b19zdHJpbmckMTkiLCJvZl9zdHJpbmckMTgiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NCQxIiwiY29tcGFyYXRvciQxOCIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJpbnZhcmlhbnQkMjAiLCJzeW1ib2wkMTk3Iiwic3ltYm9sJDE5OCIsIm5lZyQ0IiwiYWJzJDUiLCJvbmUkMiIsInN1Y2MkNSIsInByZWQkNCIsIm1pbl92YWx1ZSQ1IiwibWF4X3ZhbHVlJDUiLCJsbm90JDMiLCJsYW5kJDEiLCJseG9yJDEiLCJsb3IkMSIsImxzbCQxIiwiYXNyJDEiLCJsc3IkMSIsInBvdyQyIiwic3ltYm9sJDE5OSIsInN5bWJvbCQyMDAiLCJyZW0kMiIsInBvcGNvdW50JDEiLCJ0b19pbnQ2NCQwIiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4kMCIsIm9mX2ludDY0X3RydW5jIiwidF9vZl9zZXhwJDMzIiwic2V4cF9vZl90JDYwIiwiY29tcGFyZSQ2MSIsImlzX3BvdzIkMiIsImNseiQwIiwiY3R6JDAiLCJmbG9vcl9wb3cyJDIiLCJjZWlsX3BvdzIkMiIsImZsb29yX2xvZzIkMiIsImNlaWxfbG9nMiQyIiwiZnVuYyQxMSIsImhhc2hhYmxlJDgiLCJpbnZhbGlkX3N0ciIsInNpZ25fYW5kX3NpZ25lZG5lc3MiLCJzaWduIiwidG9fc3RyaW5nJDIwIiwib2Zfc3RyaW5nJDE5Iiwic2lnbmVkbmVzcyIsInBvc19zdHIiLCJpbnQ2MyIsImludDYzJDAiLCJic3dhcDE2JDAiLCJic3dhcDMyJDAiLCJic3dhcDQ4JDAiLCJmbG9hdF9sb3dlcl9ib3VuZCQyIiwiZmxvYXRfdXBwZXJfYm91bmQkMiIsIm1pbnVzX29uZSQyIiwib25lJDMiLCJ6ZXJvJDQiLCJudW1fYml0cyQzIiwidG9fZmxvYXQkMyIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQyIiwib2ZfZmxvYXQkMiIsImJldHdlZW4kMTMiLCJjbGFtcF91bmNoZWNrZWQkNSIsImNsYW1wX2V4biQxMyIsImNsYW1wJDEzIiwic3ltYm9sJDIwMSIsImluY3IkMyIsImRlY3IkMyIsIm9mX2ludCQ1Iiwib2ZfaW50X2V4biQxIiwidG9faW50JDQiLCJ0b19pbnRfZXhuJDEiLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQzMiIsIm9mX2ludDMyX2V4biQwIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJ0b19pbnQzMl90cnVuYyIsIm9mX25hdGl2ZWludCQwIiwib2ZfbmF0aXZlaW50X2V4biIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCQxIiwidG9fbmF0aXZlaW50X2V4biQwIiwidG9fbmF0aXZlaW50X3RydW5jIiwiaGFzaCQyMSIsInN5bWJvbCQyMDIiLCJ0b19zdHJpbmckMjEiLCJvZl9zdHJpbmckMjAiLCJ0b19zdHJpbmckMjIiLCJzeW1ib2wkMjAzIiwic3ltYm9sJDIwNCIsInN5bWJvbCQyMDUiLCJzeW1ib2wkMjA2Iiwic3ltYm9sJDIwNyIsInN5bWJvbCQyMDgiLCJyZXByIiwiaGFzaCQyMiIsImhhc2hhYmxlJDkiLCJvZl9zdHJpbmckMjEiLCJ0b19zdHJpbmckMjMiLCJpbnZhcmlhbnQkMjEiLCJiZXR3ZWVuJDE0IiwiY2xhbXBfdW5jaGVja2VkJDYiLCJjbGFtcF9leG4kMTQiLCJjbGFtcCQxNCIsInRvX2ludCQ1Iiwic3ltYm9sJDIxMiIsInN5bWJvbCQyMTMiLCJjb21wYXJlX2Jvb2wkMCIsImVxdWFsX2Jvb2wkMSIsImZ1bmMkMTIiLCJoYXNoYWJsZSQxMCIsImNvbXBhcmVfaW50MzIkMCIsInRvX3N0cmluZyQyNCIsIm9mX3N0cmluZyQyMiIsImZsb2F0X2xvd2VyX2JvdW5kJDMiLCJmbG9hdF91cHBlcl9ib3VuZCQzIiwiZmxvYXRfb2ZfYml0cyQwIiwiYml0c19vZl9mbG9hdCQwIiwibnVtX2JpdHMkNCIsImxzciQyIiwiYXNyJDIiLCJsc2wkMiIsImxub3QkNCIsImx4b3IkMiIsImxvciQyIiwibGFuZCQyIiwibWluX3ZhbHVlJDYiLCJtYXhfdmFsdWUkNiIsImFicyQ2IiwicHJlZCQ1Iiwic3VjYyQ2IiwicmVtJDMiLCJuZWckNSIsIm1pbnVzX29uZSQzIiwib25lJDQiLCJ6ZXJvJDUiLCJ0b19mbG9hdCQ0Iiwib2ZfZmxvYXRfdW5jaGVja2VkJDMiLCJvZl9mbG9hdCQzIiwic3ltYm9sJDIyMCIsInN5bWJvbCQyMjEiLCJzeW1ib2wkMjIyIiwic3ltYm9sJDIyMyIsInN5bWJvbCQyMjQiLCJzeW1ib2wkMjI1IiwiZGVzY2VuZGluZyQyOSIsIm1pbiQzNSIsIm1heCQzNSIsImVxdWFsX2ludDMyJDEiLCJiZXR3ZWVuJDE1IiwiY2xhbXBfdW5jaGVja2VkJDciLCJjbGFtcF9leG4kMTUiLCJjbGFtcCQxNSIsImludmFyaWFudCQyMiIsInN5bWJvbCQyMjYiLCJzeW1ib2wkMjI3Iiwic3ltYm9sJDIyOCIsInN5bWJvbCQyMjkiLCJpbmNyJDQiLCJkZWNyJDQiLCJvZl9pbnQzMiQwIiwidG9faW50MzIkMCIsInBvdyQzIiwic3ltYm9sJDIzMCIsImJzd2FwMTYkMSIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCQyIiwiY2VpbF9wb3cyJDMiLCJmbG9vcl9wb3cyJDMiLCJpc19wb3cyJDMiLCJmbG9vcl9sb2cyJDMiLCJjZWlsX2xvZzIkMyIsInNleHBfb2ZfaW50MzIiLCJoYXNoJDIzIiwidG9fc3RyaW5nJDI1Iiwib2Zfc3RyaW5nJDIzIiwicmVwciQwIiwidG9faW50JDYiLCJ0b19pbnRfdHJ1bmMkMCIsInRvX25hdGl2ZWludF90cnVuYyQwIiwidG9fbmF0aXZlaW50JDIiLCJyZXByJDEiLCJic3dhcDMyJDEiLCJic3dhcDQ4JDEiLCJpbXBsIiwic3ltYm9sJDIzNCIsInN5bWJvbCQyMzUiLCJwb3NfZGlmZiIsIm5lZ2F0aXZlX29uZSIsImRpdl93b3VsZF9vdmVyZmxvdyIsInN5bWJvbCQyMzYiLCJwcm9kdWN0Iiwic3ltYm9sJDIzNyIsImFicyQ3IiwibmVnJDYiLCJyYW5kb21fb2ZfaW50IiwicmFuZG9tX29mX2ludDY0IiwicmFuZG9tX29mX2ludCQwIiwicmFuZG9tX2luY2xfb2ZfaW50IiwicmFuZG9tX2luY2xfb2ZfaW50NjQiLCJyYW5kb21faW5jbCIsImZsb29yX2xvZzIkNCIsIm1heCQzNiIsImVtcHR5JDEwIiwiaXNfZW1wdHkkMTQiLCJoZWlnaHQkMSIsImludmFyaWFudCQyMyIsImludiIsImxlZnRfa2V5IiwicmlnaHRfa2V5IiwidXBkYXRlX2hlaWdodCIsIm9sZF9oZWlnaHQiLCJuZXdfaGVpZ2h0IiwiYmFsYW5jZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsInNldF9sZWZ0IiwidHJlZSQwIiwic2V0X3JpZ2h0IiwiYWRkJDYiLCJhZGRlZCIsImFkZCQ3IiwibGFzdCQyIiwiZmluZGlfYW5kX2NhbGxfaW1wbCIsImFyZzEiLCJhcmcyIiwiY2FsbF9pZl9mb3VuZCIsImNhbGxfaWZfbm90X2ZvdW5kIiwiZmluZF9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMCIsImNhbGxfaWZfbm90X2ZvdW5kJDAiLCJmaW5kaV9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMSIsImNhbGxfaWZfbm90X2ZvdW5kJDEiLCJmaW5kX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMiIsImNhbGxfaWZfbm90X2ZvdW5kJDIiLCJmaW5kaV9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDMiLCJjYWxsX2lmX25vdF9mb3VuZCQzIiwiZmluZF9hbmRfY2FsbDIiLCJjYWxsX2lmX2ZvdW5kJDQiLCJjYWxsX2lmX25vdF9mb3VuZCQ0IiwiZmluZGlfYW5kX2NhbGwyIiwiaWZfbm90X2ZvdW5kJDAiLCJmaW5kJDE1IiwiaWZfZm91bmQkMCIsImlmX25vdF9mb3VuZCQxIiwibWVtJDEzIiwicmVtb3ZlX21pbl9lbHQkMSIsInJlbW92ZSQ2IiwicmVtb3ZlZCIsInJlbW92ZSQ3IiwiZm9sZCQxNyIsImtleSQxIiwicmtleSIsInJkYXRhIiwicmtleSQwIiwicmRhdGEkMCIsInJrZXkkMSIsInJkYXRhJDEiLCJsa2V5IiwibGRhdGEiLCJpdGVyJDIyIiwibWFwaV9pbnBsYWNlIiwiY2hvb3NlX2V4biQyIiwiY29tcGFyZV9rZXkkMCIsImVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIiwid2l0aG91dF9tdXRhdGluZyIsIm1heF90YWJsZV9sZW5ndGgiLCJjcmVhdGUkMTYiLCJncm93dGhfYWxsb3dlZCIsInNpemUkMCIsInNpemUkMSIsInNsb3QiLCJhZGRfd29ya2VyIiwibmV3X3Jvb3QiLCJtYXliZV9yZXNpemVfdGFibGUiLCJzaG91bGRfZ3JvdyIsIm5ld19hcnJheV9sZW5ndGgiLCJuZXdfdGFibGUiLCJvbGRfdGFibGUiLCJzZXQkOSIsImFkZCQ4IiwiYWRkX2V4biQzIiwic2V4cF9vZl9rZXkkMCIsImNsZWFyJDMiLCJmaW5kX2FuZF9jYWxsJDAiLCJmaW5kX2FuZF9jYWxsMSQwIiwiZmluZF9hbmRfY2FsbDIkMCIsImZpbmRpX2FuZF9jYWxsJDAiLCJmaW5kaV9hbmRfY2FsbDEkMCIsImZpbmRpX2FuZF9jYWxsMiQwIiwiaWZfZm91bmQkMSIsImlmX25vdF9mb3VuZCQyIiwiZmluZCQxNiIsIm1lbSQxNCIsInJlbW92ZSQ4IiwiYWRkZWRfb3JfcmVtb3ZlZCIsImxlbmd0aCQyMiIsImlzX2VtcHR5JDE1IiwiZm9sZCQxOCIsImJ1Y2tldCIsIml0ZXJpJDEzIiwiaXRlciQyMyIsIml0ZXJfa2V5cyQyIiwiY2hvb3NlX25vbmVtcHR5IiwidGFibGUiLCJhdmx0cmVlIiwiY2hvb3NlX2V4biQzIiwiY2hvb3NlJDIiLCJpbnZhcmlhbnQkMjQiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsImlmX2ZvdW5kJDIiLCJpZl9ub3RfZm91bmQkMyIsImZpbmRfZXhuJDkiLCJleGlzdHNpJDEwIiwiZXhpc3RzJDE1IiwiZm9yX2FsbGkkMTAiLCJmb3JfYWxsJDE1IiwiY291bnRpJDEwIiwiY291bnQkMTQiLCJtYXBpJDExIiwibmV3X3QiLCJtYXAkMzciLCJjb3B5JDciLCJmaWx0ZXJfbWFwaSQ3IiwiZmlsdGVyX21hcCQxMiIsImZpbHRlcmkkOCIsImZpbHRlciQxMiIsImZpbHRlcl9rZXlzJDIiLCJwYXJ0aXRpb25fbWFwaSQyIiwidDAiLCJuZXdfZGF0YSQwIiwicGFydGl0aW9uX21hcCQzIiwicGFydGl0aW9uaV90ZiQzIiwicGFydGl0aW9uX3RmJDciLCJmaW5kX29yX2FkZCIsImlkIiwiZGVmYXVsdCQxIiwiZmluZGlfb3JfYWRkIiwiZmluZF9hbmRfcmVtb3ZlIiwiY2hhbmdlJDIiLCJ1cGRhdGVfYW5kX3JldHVybiIsInVwZGF0ZSQyIiwiaW5jcl9ieSIsInJlbW92ZV9pZl96ZXJvIiwiYnkiLCJpbmNyJDUiLCJkZWNyJDUiLCJhZGRfbXVsdGkkMiIsInJlbW92ZV9tdWx0aSQyIiwiZmluZF9tdWx0aSQyIiwiY3JlYXRlX21hcHBlZCIsImR1cGVzIiwib2ZfYWxpc3QkNCIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyIsIm9mX2FsaXN0X29yX2Vycm9yJDQiLCJvZl9hbGlzdF9leG4kNCIsIm9mX2FsaXN0X211bHRpJDQiLCJ0b19hbGlzdCQyIiwic2V4cF9vZl90JDYyIiwic2V4cF9vZl9kYXRhIiwidF9vZl9zZXhwJDM0IiwiZF9vZl9zZXhwIiwidF9zZXhwX2dyYW1tYXIkMzIiLCJrX2dyYW1tYXIiLCJ0b19saXN0JDEzIiwiZGF0YSQyIiwiZ3JvdXAkMiIsInJvdyIsIm9sZCIsImNyZWF0ZV93aXRoX2tleSIsImNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciIsImNyZWF0ZV93aXRoX2tleV9leG4iLCJtYXliZV9zZXQiLCJtZXJnZSQ2IiwidF9sZWZ0IiwidF9yaWdodCIsIm1lcmdlX2ludG8iLCJkc3RfZGF0YSIsImFjdGlvbiIsImRzdF9kYXRhJDAiLCJmaWx0ZXJpX2lucGxhY2UkMSIsInRvX3JlbW92ZSIsImZpbHRlcl9pbnBsYWNlJDEiLCJmaWx0ZXJfa2V5c19pbnBsYWNlIiwiZmlsdGVyX21hcGlfaW5wbGFjZSIsIm1hcF9yZXN1bHRzIiwiZmlsdGVyX21hcF9pbnBsYWNlIiwibWFwaV9pbnBsYWNlJDAiLCJtYXBfaW5wbGFjZSQwIiwic2ltaWxhciIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQwIiwiY3JlYXRlX21hcHBlZCQwIiwiY3JlYXRlX3dpdGhfa2V5JDAiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMCIsImNyZWF0ZV93aXRoX2tleV9leG4kMCIsInRfb2Zfc2V4cCQzNSIsImNyZWF0ZSQxNyIsIm9mX2FsaXN0JDUiLCJvZl9hbGlzdF9vcl9lcnJvciQ1Iiwib2ZfYWxpc3RfZXhuJDUiLCJvZl9hbGlzdF9tdWx0aSQ1IiwiZ3JvdXAkMyIsImhhc2hhYmxlJDExIiwiY3JlYXRlJDE4Iiwib2ZfYWxpc3QkNiIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQxIiwib2ZfYWxpc3Rfb3JfZXJyb3IkNiIsIm9mX2FsaXN0X2V4biQ2Iiwib2ZfYWxpc3RfbXVsdGkkNiIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQ0IiwiaGFzaGFibGVfcyIsInNleHBfb2ZfbV90JDEiLCJtX3Rfb2Zfc2V4cCQxIiwibV90X3NleHBfZ3JhbW1hciQxIiwiZXF1YWxfbV90JDEiLCJoYXNoYWJsZSQxMiIsInBvbHlfaGFzaGFibGUiLCJpc19lbXB0eSQxNiIsImZpbmRfbWFwJDExIiwiZmluZCQxNyIsImFkZCQ5Iiwic3RyaWN0X2FkZCIsInN0cmljdF9hZGRfZXhuIiwic3RyaWN0X3JlbW92ZSIsInN0cmljdF9yZW1vdmVfZXhuIiwiZm9sZCQxOSIsIml0ZXIkMjQiLCJjb3VudCQxNSIsInN1bSQxMSIsIm1pbl9lbHQkMTUiLCJtYXhfZWx0JDE1IiwiZm9sZF9yZXN1bHQkMTAiLCJmb2xkX3VudGlsJDE0Iiwic2V4cF9vZl90JDYzIiwic2V4cF9vZl9lIiwidG9fYXJyYXkkMTIiLCJleGlzdHMkMTYiLCJmb3JfYWxsJDE2IiwiZXF1YWwkNDciLCJjb3B5JDgiLCJmaWx0ZXIkMTMiLCJ1bmlvbiQyIiwiZGlmZiQyIiwiaW50ZXIkMiIsImxhcmdlciIsInNtYWxsZXIiLCJmaWx0ZXJfaW5wbGFjZSQyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJjcmVhdGUkMTkiLCJvZl9saXN0JDExIiwidF9vZl9zZXhwJDM2IiwiZV9vZl9zZXhwIiwidF9vZl9zZXhwJDM3IiwiY3JlYXRlJDIwIiwib2ZfbGlzdCQxMiIsInRfc2V4cF9ncmFtbWFyJDMzIiwic2V4cF9vZl9tX3QkMiIsIm1fdF9vZl9zZXhwJDIiLCJtX3Rfc2V4cF9ncmFtbWFyJDIiLCJlcXVhbF9tX3QkMiIsImhhc2hhYmxlJDEzIiwiaGFzaCQyNCIsImhhc2hhYmxlJDE0IiwiY29tcGFyZSQ2MiIsImludmFyaWFudCQyNSIsInRvX2Zsb2F0JDUiLCJvZl9mbG9hdCQ0Iiwib2Zfc3RyaW5nJDI0IiwidG9fc3RyaW5nJDI2IiwibWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSIsIm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUiLCJ6ZXJvJDYiLCJvbmUkNSIsIm1pbnVzX29uZSQ0IiwicGkiLCJzcXJ0X3BpIiwic3FydF8ycGkiLCJldWxlciIsIm9mX2ludDYzIiwib2ZfaW50NjQkMCIsInRvX2ludDY0JDEiLCJpcm91bmRfbGJvdW5kIiwiaXJvdW5kX3Vib3VuZCIsImlyb3VuZF91cCIsImlyb3VuZF91cF9leG4iLCJpcm91bmRfZG93biIsImlyb3VuZF9kb3duX2V4biIsImlyb3VuZF90b3dhcmRzX3plcm8iLCJpcm91bmRfdG93YXJkc196ZXJvX2V4biIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsImFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IiwiaXJvdW5kX25lYXJlc3RfMzIiLCJpcm91bmRfbmVhcmVzdF82NCIsImlyb3VuZF9uZWFyZXN0XzY0JDAiLCJpcm91bmRfbmVhcmVzdF9leG5fMzIiLCJpcm91bmRfbmVhcmVzdF9leG5fNjQiLCJpcm91bmRfbmVhcmVzdF9leG4iLCJpcm91bmRfZXhuIiwiaXJvdW5kIiwiaXNfaW5mIiwiaXNfZmluaXRlIiwibWluX2luYW4iLCJtYXhfaW5hbiIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX3Rvd2FyZHNfemVybyQ0Iiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0JDQiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwicm91bmQkNCIsImNvbXBhcmUkNjMiLCJ0X29mX3NleHAkMzgiLCJzZXhwX29mX3QkNjQiLCJ0b19zdHJpbmckMjciLCJvZl9zdHJpbmckMjUiLCJjbGFzc2lmeSIsImluc2VydF91bmRlcnNjb3JlcyQwIiwic3RyaXBfemVybyIsInRvX3N0cmluZ19odW0kNiIsImRlY2ltYWxzIiwiZXhwbGljaXRfcGx1cyIsInNleHBfb2ZfZmxvYXQiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG8iLCJraWxvIiwibWVnYSIsImdpZ2EiLCJ0ZXJhIiwicGV0YSIsIm1hZyIsImRlbm9taW5hdG9yIiwiaGlnaGVyIiwiZGlmZl9yaWdodCIsImRpZmZfbGVmdCIsInBldGEkMCIsInRvX3BhZGRlZF9jb21wYWN0X3N0cmluZyIsImludF9wb3ckMCIsInJvdW5kX2dlbiIsInNkIiwiZGQiLCJkZCQwIiwic2QkMCIsImRkJDEiLCJzZCQxIiwiYWJzX2RkIiwicm91bmRfc2lnbmlmaWNhbnQiLCJzaWduaWZpY2FudF9kaWdpdHMiLCJyb3VuZF9kZWNpbWFsIiwiZGVjaW1hbF9kaWdpdHMiLCJiZXR3ZWVuJDE2IiwiY2xhbXBfZXhuJDE2IiwiY2xhbXAkMTYiLCJzaWduX2V4biIsInNpZ25fb3JfbmFuIiwiaWVlZV9uZWdhdGl2ZSIsImV4cG9uZW50X21hc2s2NCIsImV4cG9uZW50X21hc2siLCJtYW50aXNzYV9tYXNrIiwibWFudGlzc2FfbWFzazY0IiwiaWVlZV9leHBvbmVudCIsImllZWVfbWFudGlzc2EiLCJjcmVhdGVfaWVlZV9leG4iLCJuZWdhdGl2ZSIsIm1hbnRpc3NhIiwic2lnbl9iaXRzIiwiZXhwdF9iaXRzIiwibWFudF9iaXRzIiwiY3JlYXRlX2llZWUiLCJ0b19zdHJpbmckMjgiLCJzZXhwX29mX3QkNjUiLCJvZl9zdHJpbmckMjYiLCJpc19wb3NpdGl2ZSQ0IiwiaXNfbm9uX25lZ2F0aXZlJDQiLCJpc19uZWdhdGl2ZSQ0IiwiaXNfbm9uX3Bvc2l0aXZlJDQiLCJzeW1ib2wkMjM4Iiwic3ltYm9sJDIzOSIsInN5bWJvbCQyNDAiLCJzeW1ib2wkMjQxIiwic3ltYm9sJDI0MiIsInN5bWJvbCQyNDMiLCJvZl9mbG9hdCQ1IiwiY29tcGFyZV9mbG9hdCQxIiwiZXF1YWxfZmxvYXQkMSIsIm1pbiQzNiIsIm1heCQzNyIsImFkZF9zdWJzdHJpbmciLCJhZGRfc3ViYnl0ZXMiLCJzZXhwX29mX3QkNjYiLCJjcmVhdGUkMjIiLCJsZW5ndGgkMjQiLCJ1bnNhZmVfYmxpdCQ5IiwiZWxpZGUiLCJnZXQkNiIsImF0X21vc3RfbnVtX2ZyYW1lcyIsInRvX3N0cmluZyQyOSIsInRvX3N0cmluZ19saXN0Iiwic2V4cF9vZl90JDY3Iiwic2V0X3JlY29yZGluZyIsImFtX3JlY29yZGluZyIsIm1vc3RfcmVjZW50IiwibW9zdF9yZWNlbnRfZm9yX2V4biIsIndpdGhfcmVjb3JkaW5nIiwic2F2ZWQiLCJpbml0aWFsaXplX21vZHVsZSQwIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwibWF4X2ludCQxIiwibWluX2ludCQxIiwiaW5maW5pdHkkMiIsIm5lZ19pbmZpbml0eSQyIiwibmFuJDIiLCJtYXhfZmxvYXQkMSIsIm1pbl9mbG9hdCQxIiwiZXBzaWxvbl9mbG9hdCQyIiwiY2hhcl9vZl9pbnQkMSIsInN0cmluZ19vZl9ib29sJDEiLCJib29sX29mX3N0cmluZ19vcHQkMSIsImJvb2xfb2Zfc3RyaW5nJDEiLCJzdHJpbmdfb2ZfaW50JDEiLCJpbnRfb2Zfc3RyaW5nX29wdCQxIiwic3RyaW5nX29mX2Zsb2F0JDEiLCJmbG9hdF9vZl9zdHJpbmdfb3B0JDEiLCJzdGRpbiQxIiwic3Rkb3V0JDEiLCJzdGRlcnIkMSIsInByaW50X2NoYXIkMSIsInByaW50X3N0cmluZyQxIiwicHJpbnRfYnl0ZXMkMSIsInByaW50X2ludCQxIiwicHJpbnRfZmxvYXQkMSIsInByaW50X2VuZGxpbmUkMSIsInByaW50X25ld2xpbmUkMSIsInByZXJyX2NoYXIkMSIsInByZXJyX3N0cmluZyQxIiwicHJlcnJfYnl0ZXMkMSIsInByZXJyX2ludCQxIiwicHJlcnJfZmxvYXQkMSIsInByZXJyX2VuZGxpbmUkMSIsInByZXJyX25ld2xpbmUkMSIsInJlYWRfbGluZSQxIiwicmVhZF9pbnRfb3B0JDEiLCJyZWFkX2ludCQxIiwicmVhZF9mbG9hdF9vcHQkMSIsInJlYWRfZmxvYXQkMSIsIm9wZW5fb3V0JDEiLCJvcGVuX291dF9iaW4kMSIsIm9wZW5fb3V0X2dlbiQxIiwiZmx1c2gkMSIsImZsdXNoX2FsbCQxIiwib3V0cHV0X2NoYXIkMSIsIm91dHB1dF9zdHJpbmckMSIsIm91dHB1dF9ieXRlcyQxIiwib3V0cHV0JDEiLCJvdXRwdXRfc3Vic3RyaW5nJDEiLCJvdXRwdXRfYnl0ZSQxIiwib3V0cHV0X2JpbmFyeV9pbnQkMSIsIm91dHB1dF92YWx1ZSQxIiwic2Vla19vdXQkMSIsInBvc19vdXQkMSIsIm91dF9jaGFubmVsX2xlbmd0aCQxIiwiY2xvc2Vfb3V0JDEiLCJjbG9zZV9vdXRfbm9lcnIkMSIsInNldF9iaW5hcnlfbW9kZV9vdXQkMSIsIm9wZW5faW4kMSIsIm9wZW5faW5fYmluJDEiLCJvcGVuX2luX2dlbiQxIiwiaW5wdXRfY2hhciQxIiwiaW5wdXRfbGluZSQxIiwiaW5wdXQkMSIsInJlYWxseV9pbnB1dCQxIiwicmVhbGx5X2lucHV0X3N0cmluZyQxIiwiaW5wdXRfYnl0ZSQxIiwiaW5wdXRfYmluYXJ5X2ludCQxIiwiaW5wdXRfdmFsdWUkMSIsInNlZWtfaW4kMSIsInBvc19pbiQxIiwiaW5fY2hhbm5lbF9sZW5ndGgkMSIsImNsb3NlX2luJDEiLCJjbG9zZV9pbl9ub2VyciQxIiwic2V0X2JpbmFyeV9tb2RlX2luJDEiLCJzdHJpbmdfb2ZfZm9ybWF0JDEiLCJzeW1ib2wkMjUwIiwiZXhpdCQxIiwiYXRfZXhpdCQxIiwidmFsaWRfZmxvYXRfbGV4ZW0kMSIsInVuc2FmZV9yZWFsbHlfaW5wdXQkMSIsImRvX2F0X2V4aXQkMSIsImFycmF5X3NleHBfZ3JhbW1hciQwIiwiaGFzaF9ib29sJDAiLCJoYXNoX2ludCQwIiwiaGFzaF9pbnQzMiQwIiwiaGFzaF9pbnQ2NCQwIiwibGlzdF9zZXhwX2dyYW1tYXIkMCIsImhhc2hfbmF0aXZlaW50JDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJyZWZfc2V4cF9ncmFtbWFyJDAiLCJoYXNoX3N0cmluZyQwIiwiaGFzaF91bml0JDAiXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9leG4ubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9laXRoZXIwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcmVzdWx0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvb3JkZXJpbmcubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9saXN0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW5mby5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2Vycm9yLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc2lnbjAubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS91bml0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGVfaW50Zi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3NlcXVlbmNlLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvY2hhci5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2J5dGVzLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaGV4X2xleGVyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcG93X292ZXJmbG93X2JvdW5kcy5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3BvcGNvdW50Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW50Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvdWNoYXIubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS90eXBlX2VxdWFsLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc2lnbl9vcl9uYW4ubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL21hcF9pbnRmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvbm90aGluZy5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL25hdGl2ZWludC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL21hcC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2ludDY0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW50NjNfZW11bC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2Jvb2wubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9pbnQzMi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2Zsb2F0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvYmFja3RyYWNlLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcG9seTAubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9pbXBvcnQwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc3RyaW5nMC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2Jhc2UubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9oYXNodGJsLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcHJpbnRmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc3lzMC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2FycmF5MC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2NoYXIwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW50MC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2xpc3QwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaGFzaC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3BweF9jb21wYXJlX2xpYi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3NleHAubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9zdHJpbmcubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9sYXp5Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvd29yZF9zaXplLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS93aXRoX3JldHVybi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2hhc2hfc2V0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvbW9uYWRfaW50Zi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL21vbmFkLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvYXBwbGljYXRpdmUubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9ieXRlczAubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9jb21wYXJhdG9yLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvZmllbGQubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9zb3VyY2VfY29kZV9wb3NpdGlvbjAubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9saXN0MS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL29yX2Vycm9yLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvY29udGFpbmVyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvY29udGFpbmVyX2ludGYubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3JhbmRvbV9yZXByLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcmFuZG9tLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvYXJyYXkubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9hcnJheV9wZXJtdXRlLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvZm4ubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9pbnQ2My5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2ludmFyaWFudC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2NvbXBhcmFibGUubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9oYXNoYWJsZV9pbnRmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaWRlbnRpZmlhYmxlLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoYWJsZS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2JsaXQubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9vcHRpb24ubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9zZXhwYWJsZS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2VpdGhlci5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2luZGV4ZWRfY29udGFpbmVyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvb2JqX2FycmF5Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvdW5pZm9ybV9hcnJheS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL29wdGlvbl9hcnJheS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2Zsb2F0MC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2J5dGVzX3RyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW50X2NvbnZlcnNpb25zLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvaW50X21hdGgubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9zaWduLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc3RhY2subWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9zb3VyY2VfY29kZV9wb3NpdGlvbi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL3NldF9pbnRmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2Uvc2V0Lm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcmVmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcXVldWUubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9saW5rZWRfcXVldWUwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvbGlua2VkX3F1ZXVlLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvYXZsdHJlZS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlL2J1ZmZlci5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0ErR1FBOzs7Ozs7Ozs7Ozs7Ozs7S0MvREFDOzs7Ozs7Ozs7Ozs7Ozs7S0NqQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDYUpDO0tBR0dDO0tBMkJGQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzI2QkdDOzs7Ozs7Ozs7Ozs7O0tDOTBCSEM7O0tBaUZHQztLQ2pPSkM7S0FTSUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ0xEQztLQTJCRkM7Ozs7Ozs7OztLQWlDREM7S0FnQ0FDOzs7Ozs7Ozs7Ozs7O0tDbEdFQztLQXdCQUM7S0NLQUM7Ozs7OztLQXFCQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NxY0lDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3RkRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N0QkZDO0tDVEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ29OQUM7O0tBc0VBQzs7S0NsUkVDO0tBRUFDO0tBRUFDO0tBRUFDO0tBZUFDOzs7Ozs7Ozs7OztLQ21ERUM7S0FPQUM7Ozs7OztLQ3ZGRkM7Ozs7OztLQ3dIRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3BIQ0M7S0FnQ0ZDOzs7Ozs7Ozs7OztLQW1DREM7S0FNQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3ZEQUM7S0FvRkNDOztLQTZCRkM7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2hDR0M7O0tBb1BGQztLQXFCQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N4V0NDO0tBVUNDOzs7Ozs7Ozs7OztLQ29DQUM7S0FPQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd3RFQUM7Ozs7Ozs7OztLQW5pQ0VDO0tBMEJBQzs7Ozs7Ozs7Ozs7S0NwaUNGQztLQU9BQzs7Ozs7O0tDdklGQztLQWlSRUM7S0FPQUM7Ozs7Ozs7S0MvWEZDO0tBa0NFQzs7Ozs7Ozs7Ozs7S0M4TUFDO0tBT0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDeVJGQztLQUdHQztLQW9DRkM7Ozs7Ozs7Ozs7Ozs7S0EwWUNDOzs7S0NuOEJKQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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OUI1WUFDO0s4QitLQUM7Ozs7S0FnVENDO0tQemRBQztLa0I2ZEVDO0tYekJGQztLdkIzVUVDOztLa0J6SEZDO0tESkFDO0tGNEpBQztLSDNKQUM7Ozs7Ozs7OztLV3dPREM7Ozs7S1hsUENDO0tHcVdFQztLRXRXRkM7S2pCSUFDOztLZ0JBQUM7S2tCSUFDO0toQkpBQztLckJIQUM7SzBCeVlEQztLOUJzMUJGQzs7OztLbUJwckNNQztLRy9CQUM7S0UwTkFDO0tqQi9ORkM7S0s4REVDO0tXOURGQztLa0JJQUM7S2hCNDlCRkM7S3JCbitCRUM7S21CSkZDO0toQkNBQzs7S0s4REVDO0tZaUtBQztLRjFOQUM7S0grQkFDOzs7S1c4SUZDOztLQThNQUM7S0FvQ0FDOzs7Ozs7Ozs7Ozs7O0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09MakNGaFI7O09BSkFDOztPQUNBQzs7T0FxZUFDOzs7Ozs7Ozs7Ozs7Ozs7O09JOTBCQUM7T2pCbURJQztPYXVUSkM7Ozs7Ozs7Ozs7T0tpS0VDO09DL0NtREM7T0RnRG5EQztPQ2hENERDO09EcUQ1REM7Ozs7T0FoWUFDOzs7OztPMUJqS0FpTTtPbUJHQUM7T2tCNmRFQztPWHpCRkM7T3ZCM1VFQztPSzVIRkM7T2FHQUM7T0RKQUM7T0ZTRUM7T0hSRkM7T1dtYUFDO09ZN2FGQztPWndaRUM7OztPOUIvWUFDO084QmtMQUM7Ozs7Ozs7O08xQmxMQUM7T21CR0FDO09rQjZkRUM7T1h6QkZDO092QjNVRUM7O09rQnpIRkM7T0RKQUM7T0hBQUM7T0ZDQUM7T1dnYUFDO09ZMWFGQztPWnFaRUM7OztPOUI1WUFDO084QitLQUM7Ozs7T0FnVENDO09QemRBQztPa0I2ZEVDO09YekJGQztPdkIzVUVDOztPa0J6SEZDO09ESkFDO09GNEpBQztPSDNKQUM7Ozs7Ozs7OztPV3dPREM7Ozs7T1hsUENDO09HcVdFQztPRXRXRkM7T2pCSUFDOztPZ0JBQUM7T2tC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ckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJBO0tBRXFCLEtBRnJCQTtLQUVxQixLQUZyQkE7S0FFcUIsS0FGckJB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0JHOzs7Ozs7T0FqaUJMNnNJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWlpQks7VSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBDYW1sLmV4aXRcblxuZXhjZXB0aW9uIEZpbmFsbHkgb2YgdCAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGaW5hbGx5XSAoZnVuY3Rpb25cbiAgICB8IEZpbmFsbHkgKGFyZzBfXzAwMV8sIGFyZzFfXzAwMl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDAzXyA9IHNleHBfb2ZfdCBhcmcwX18wMDFfXG4gICAgICBhbmQgcmVzMV9fMDA0XyA9IHNleHBfb2ZfdCBhcmcxX18wMDJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuRmluYWxseVwiOyByZXMwX18wMDNfOyByZXMxX18wMDRfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFJlcmFpc2VkIG9mIHN0cmluZyAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBSZXJhaXNlZF0gKGZ1bmN0aW9uXG4gICAgfCBSZXJhaXNlZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgIGxldCByZXMwX18wMDdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA1X1xuICAgICAgYW5kIHJlczFfXzAwOF8gPSBzZXhwX29mX3QgYXJnMV9fMDA2XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLlJlcmFpc2VkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gU2V4cCBvZiBTZXhwLnRcblxuKCogV2UgaW5zdGFsbCBhIGN1c3RvbSBleG4tY29udmVydGVyIHJhdGhlciB0aGFuIHVzZTpcblxuICAge1tcbiAgICAgZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuICAgICAoKiAuLi4gKilcbiAgICAgW0BAQGVuZF1cbiAgIF19XG5cbiAgIHRvIGVsaW1pbmF0ZSB0aGUgZXh0cmEgd3JhcHBpbmcgb2YgWyhTZXhwIC4uLildLiAqKVxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNleHBdIChmdW5jdGlvblxuICAgIHwgU2V4cCB0IC0+IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBTZXhwIHNleHBcblxubGV0IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIHQgYmFja3RyYWNlID1cbiAgQ2FtbC5QcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB0IGJhY2t0cmFjZVxuOztcblxuZXh0ZXJuYWwgaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCA6IHQgLT4gYm9vbCA9IFwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG5cIlxuXG5sZXQgcmVyYWlzZSBleG4gc3RyID1cbiAgbGV0IGV4bicgPSBSZXJhaXNlZCAoc3RyLCBleG4pIGluXG4gIGlmIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuXG4gIHRoZW4gKFxuICAgIGxldCBidCA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgKG1hdGNoIGZpbmFsbHkgeCB3aXRoXG4gICAgIHwgKCkgLT4gcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuIGJ0XG4gICAgIHwgZXhjZXB0aW9uIGZpbmFsX2V4biAtPlxuICAgICAgICgqIFVuZm9ydHVuYXRlbHksIHRoZSBiYWNrdHJhY2Ugb2YgdGhlIFtmaW5hbF9leG5dIGlzIGRpc2NhcmRlZCBoZXJlLiAqKVxuICAgICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChGaW5hbGx5IChleG4sIGZpbmFsX2V4bikpIGJ0KVxuOztcblxubGV0IHByb3RlY3QgfmYgfmZpbmFsbHkgPSBwcm90ZWN0eCB+ZiAoKSB+ZmluYWxseVxuXG5sZXQgZG9lc19yYWlzZSAodHlwZSBhKSAoZiA6IHVuaXQgLT4gYSkgPVxuICB0cnlcbiAgICBpZ25vcmUgKGYgKCkgOiBhKTtcbiAgICBmYWxzZVxuICB3aXRoXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBleG5cblxuICAgIGxldCBwcCBwcGYgdCA9XG4gICAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgdCB3aXRoXG4gICAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgICAgfCBOb25lIC0+IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKENhbWwuUHJpbnRleGMudG9fc3RyaW5nIHQpXG4gICAgOztcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuICBlbmQpXG5cbmxldCBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSA9XG4gIENhbWwuRm9ybWF0LmVwcmludGYgXCJAWzwyPlVuY2F1Z2h0IGV4Y2VwdGlvbjpAXFxuQFxcbkBbJWFAXUBdQFxcbkAuXCIgcHAgZXhjO1xuICBpZiBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBDYW1sLlByaW50ZXhjLnByaW50X3Jhd19iYWNrdHJhY2UgQ2FtbC5zdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgQ2FtbC5mbHVzaCBDYW1sLnN0ZGVyclxuOztcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKSA9XG4gIENhbWwuUHJpbnRleGMuc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHByaW50X3dpdGhfYmFja3RyYWNlXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2F1eCB+ZG9fYXRfZXhpdCB+ZXhpdCBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4YyAtPlxuICAgIGxldCByYXdfYmFja3RyYWNlID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgQ2FtbC5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgXyAtPiAoKSk7XG4gICAgKHRyeSBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnlcbiAgICAgICAgICBDYW1sLlByaW50Zi5lcHJpbnRmIFwiRXhuLmhhbmRsZV91bmNhdWdodCBjb3VsZCBub3QgcHJpbnQ7IGV4aXRpbmcgYW55d2F5XFxuJSFcIlxuICAgICAgICB3aXRoXG4gICAgICAgIHwgXyAtPiAoKSkpO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmID0gaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0IH5kb19hdF9leGl0OnRydWVcblxubGV0IGhhbmRsZV91bmNhdWdodCB+ZXhpdDptdXN0X2V4aXQgZiA9XG4gIGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdDooaWYgbXVzdF9leGl0IHRoZW4gZXhpdCBlbHNlIGlnbm9yZSkgfmRvX2F0X2V4aXQ6bXVzdF9leGl0XG47O1xuXG5sZXQgcmVyYWlzZV91bmNhdWdodCBzdHIgZnVuYyA9XG4gIHRyeSBmdW5jICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIENhbWwucmFpc2Vfbm90cmFjZSBlXG47O1xuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKClcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsZWFyX2JhY2t0cmFjZSA9IGNsZWFyX2JhY2t0cmFjZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOlxuICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICdmICdzLlxuICAoU2V4cGxpYjAuU2V4cC50IC0+ICdmKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdzKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKCdmLCAncykgdFxuICA9XG4gIGZ1biAodHlwZSBmX18wMjNfIHNfXzAyNF8pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjNfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAyNF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAgIC0+IChmX18wMjNfLCBzX18wMjRfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAxMV8gPSBcImVpdGhlcjAubWwudFwiIGluXG4gICAgZnVuIF9vZl9mX18wMDdfIF9vZl9zX18wMDhfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2ZfXzAwN18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgICBGaXJzdCByZXMwX18wMTdfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMTlfKSA6OiBzZXhwX2FyZ3NfXzAyMF8pIGFzXG4gICAgICAgIF9zZXhwX18wMThfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyMF8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAyMV8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9zX18wMDhfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgICAgU2Vjb25kIHJlczBfXzAyMl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTFfXG4gICAgICAgICAgICAgX3RhZ19fMDE5X1xuICAgICAgICAgICAgIF9zZXhwX18wMThfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgc2V4cF9fMDEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTJfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICdmICdzLlxuICAoJ2YgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2YsICdzKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBmX18wMzFfIHNfXzAzMl8pXG4gICAgICA6ICAoKGZfXzAzMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDMyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGZfXzAzMV8sIHNfXzAzMl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfZl9fMDI1XyBfb2Zfc19fMDI2XyAtPiBmdW5jdGlvblxuICAgICAgfCBGaXJzdCBhcmcwX18wMjdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2ZfXzAyNV8gYXJnMF9fMDI3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJGaXJzdFwiOyByZXMwX18wMjhfIF1cbiAgICAgIHwgU2Vjb25kIGFyZzBfXzAyOV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMF8gPSBfb2Zfc19fMDI2XyBhcmcwX18wMjlfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNlY29uZFwiOyByZXMwX18wMzBfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nZl9zZXhwX2dyYW1tYXIgXydzX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRmlyc3RcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlNlY29uZFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nc19zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxudHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgQ2FtbC5yZXN1bHQgPVxuICB8IE9rIG9mICdhXG4gIHwgRXJyb3Igb2YgJ2JcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGVxdWFsLCBoYXNoXVxuXG5sZXQgdF9vZl9zZXhwIDpcbiAgJ2EgJ2IuXG4gIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2EsICdiKSB0XG4gID1cbiAgZnVuICh0eXBlIGFfXzAxN18gYl9fMDE4XylcbiAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxN18pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgICAgLT4gKGFfXzAxN18sIGJfXzAxOF8pIHQpIC0+XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDA1XyA9IFwicmVzdWx0Lm1sLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2ZfYl9fMDAyXyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJva1wiIHwgXCJPa1wiKSBhcyBfdGFnX18wMDhfKSA6OiBzZXhwX2FyZ3NfXzAwOV8pIGFzXG4gICAgICAgIF9zZXhwX18wMDdfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAwOV8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAxMF8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDExXyA9IF9vZl9hX18wMDFfIGFyZzBfXzAxMF8gaW5cbiAgICAgICAgICAgT2sgcmVzMF9fMDExX1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgICBfdGFnX18wMDhfXG4gICAgICAgICAgICAgX3NleHBfXzAwN18pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImVycm9yXCIgfCBcIkVycm9yXCIpIGFzIF90YWdfXzAxM18pIDo6IHNleHBfYXJnc19fMDE0XykgYXNcbiAgICAgICAgX3NleHBfXzAxMl8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE0XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE1XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTZfID0gX29mX2JfXzAwMl8gYXJnMF9fMDE1XyBpblxuICAgICAgICAgICBFcnJvciByZXMwX18wMTZfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAxM19cbiAgICAgICAgICAgICBfc2V4cF9fMDEyXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm9rXCIgfCBcIk9rXCIpIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICAgIHwgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG47O1xuXG5sZXQgc2V4cF9vZl90IDpcbiAgJ2EgJ2IuXG4gICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGFfXzAyNV8gYl9fMDI2XylcbiAgICAgIDogICgoYV9fMDI1XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMjZfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAtPiAoYV9fMDI1XywgYl9fMDI2XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMTlfIF9vZl9iX18wMjBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IE9rIGFyZzBfXzAyMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyMl8gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAyMl8gXVxuICAgICAgfCBFcnJvciBhcmcwX18wMjNfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjRfID0gX29mX2JfXzAyMF8gYXJnMF9fMDIzXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFcnJvclwiOyByZXMwX18wMjRfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiT2tcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkVycm9yXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZSA6XG4gICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMjdfIGJfXzAyOF8gLT5cbiAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDI3XyBiX18wMjhfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMjdfLCBiX18wMjhfIHdpdGhcbiAgICB8IE9rIF9hX18wMjlfLCBPayBfYl9fMDMwXyAtPiBfY21wX19hIF9hX18wMjlfIF9iX18wMzBfXG4gICAgfCBPayBfLCBfIC0+IC0xXG4gICAgfCBfLCBPayBfIC0+IDFcbiAgICB8IEVycm9yIF9hX18wMzFfLCBFcnJvciBfYl9fMDMyXyAtPiBfY21wX19iIF9hX18wMzFfIF9iX18wMzJfKVxuOztcblxubGV0IGVxdWFsIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAzM18gYl9fMDM0XyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMzNfIGJfXzAzNF9cbiAgdGhlbiB0cnVlXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgIHwgT2sgX2FfXzAzNV8sIE9rIF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICB8IE9rIF8sIF8gLT4gZmFsc2VcbiAgICB8IF8sIE9rIF8gLT4gZmFsc2VcbiAgICB8IEVycm9yIF9hX18wMzdfLCBFcnJvciBfYl9fMDM4XyAtPiBfY21wX19iIF9hX18wMzdfIF9iX18wMzhfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBhIGIuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChhLCBiKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBfaGFzaF9mb2xkX2IgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IE9rIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgfCBFcnJvciBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG47O1xuXG5bQEBAZW5kXVxuXG5pbmNsdWRlIE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICAgIHwgT2sgeCAtPiBmIHhcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IE9rIChmIHgpXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCByZXR1cm4geCA9IE9rIHhcbiAgZW5kKVxuXG5sZXQgaW52YXJpYW50IGNoZWNrX29rIGNoZWNrX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBvayAtPiBjaGVja19vayBva1xuICB8IEVycm9yIGVycm9yIC0+IGNoZWNrX2Vycm9yIGVycm9yXG47O1xuXG5sZXQgZmFpbCB4ID0gRXJyb3IgeFxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxuXG5sZXQgbWFwX2Vycm9yIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBfIGFzIHggLT4geFxuICB8IEVycm9yIHggLT4gRXJyb3IgKGYgeClcbjs7XG5cbm1vZHVsZSBFcnJvciA9IE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgT2sgXyBhcyBvayAtPiBva1xuICAgICAgfCBFcnJvciBlIC0+IGYgZVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBfZXJyb3JcbiAgICBsZXQgcmV0dXJuIGUgPSBFcnJvciBlXG4gIGVuZClcblxubGV0IGlzX29rID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gZmFsc2VcbiAgfCBFcnJvciBfIC0+IHRydWVcbjs7XG5cbmxldCBvayA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBTb21lIHhcbiAgfCBFcnJvciBfIC0+IE5vbmVcbjs7XG5cbmxldCBlcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBOb25lXG4gIHwgRXJyb3IgeCAtPiBTb21lIHhcbjs7XG5cbmxldCBvZl9vcHRpb24gb3B0IH5lcnJvciA9XG4gIG1hdGNoIG9wdCB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+IEVycm9yIGVycm9yXG47O1xuXG5sZXQgaXRlciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgeCAtPiBmIHhcbiAgfCBFcnJvciBfIC0+ICgpXG47O1xuXG5sZXQgaXRlcl9lcnJvciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgXyAtPiAoKVxuICB8IEVycm9yIHggLT4gZiB4XG47O1xuXG5sZXQgdG9fZWl0aGVyIDogXyB0IC0+IF8gRWl0aGVyLnQgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gRmlyc3QgeFxuICB8IEVycm9yIHggLT4gU2Vjb25kIHhcbjs7XG5cbmxldCBvZl9laXRoZXIgOiBfIEVpdGhlci50IC0+IF8gdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBPayB4XG4gIHwgU2Vjb25kIHggLT4gRXJyb3IgeFxuOztcblxubGV0IG9rX2lmX3RydWUgYm9vbCB+ZXJyb3IgPSBpZiBib29sIHRoZW4gT2sgKCkgZWxzZSBFcnJvciBlcnJvclxuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBva19vcl9mYWlsd2l0aCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3Igc3RyIC0+IGZhaWx3aXRoIHN0clxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnb2ssICdlcnIpIF9yZXN1bHQgPSAoJ29rLCAnZXJyKSB0ID1cbiAgICB8IE9rIG9mICdva1xuICAgIHwgRXJyb3Igb2YgJ2VyclxuXG4gIGxldCBpc19lcnJvciA9IGlzX2Vycm9yXG4gIGxldCBpc19vayA9IGlzX29rXG5lbmRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IE9rIF8sIEVycm9yIGUgfCBFcnJvciBlLCBPayBfIC0+IEVycm9yIGVcbiAgfCBPayBvazEsIE9rIG9rMiAtPiBPayAob2sgb2sxIG9rMilcbiAgfCBFcnJvciBlcnIxLCBFcnJvciBlcnIyIC0+IEVycm9yIChlcnIgZXJyMSBlcnIyKVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0MS5wYXJ0aXRpb25fbWFwIGwgfmY6dG9fZWl0aGVyIGluXG4gIG1hdGNoIGVycnMgd2l0aFxuICB8IFtdIC0+IE9rIG9rXG4gIHwgXyA6OiBfIC0+IEVycm9yIGVycnNcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBtYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuXG4oKiBkZXByZWNhdGVkIGJpbmRpbmcgZm9yIGV4cG9ydCBvbmx5ICopXG5sZXQgb2tfZnN0ID0gdG9fZWl0aGVyXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBMZXNzXG4gIHwgRXF1YWxcbiAgfCBHcmVhdGVyXG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBMZXNzIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IEVxdWFsIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IEdyZWF0ZXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIExlc3M7IEVxdWFsOyBHcmVhdGVyIF0gOiB0IGxpc3QpXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDA1XyA9IFwib3JkZXJpbmcubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIC0+IExlc3NcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIC0+IEVxdWFsXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgLT4gR3JlYXRlclxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZXNzXCIgfCBcIkxlc3NcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgc2V4cF9fMDA0XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IExlc3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVzc1wiXG4gICAgfCBFcXVhbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJFcXVhbFwiXG4gICAgfCBHcmVhdGVyIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkdyZWF0ZXJcIlxuICAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJMZXNzXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJFcXVhbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiR3JlYXRlclwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSBfb3JkZXJpbmcgPSB0ID1cbiAgICB8IExlc3NcbiAgICB8IEVxdWFsXG4gICAgfCBHcmVhdGVyXG5lbmRcblxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBMZXNzIGVsc2UgaWYgbiA9IDAgdGhlbiBFcXVhbCBlbHNlIEdyZWF0ZXJcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTGVzcyAtPiAtMVxuICB8IEVxdWFsIC0+IDBcbiAgfCBHcmVhdGVyIC0+IDFcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxuXG5pbmNsdWRlIExpc3QxXG5cbigqIFRoaXMgaXRzZWxmIGluY2x1ZGVzIFtMaXN0MF0uICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGlzdF9vZl9zZXhwXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xpc3RcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxpc3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBPcl91bmVxdWFsX2xlbmd0aHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE9rIG9mICdhXG4gICAgfCBVbmVxdWFsX2xlbmd0aHNcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDA2XyBiX18wMDdfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDA2XyBiX18wMDdfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDZfLCBiX18wMDdfIHdpdGhcbiAgICAgIHwgT2sgX2FfXzAwOF8sIE9rIF9iX18wMDlfIC0+IF9jbXBfX2EgX2FfXzAwOF8gX2JfXzAwOV9cbiAgICAgIHwgT2sgXywgXyAtPiAtMVxuICAgICAgfCBfLCBPayBfIC0+IDFcbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzLCBVbmVxdWFsX2xlbmd0aHMgLT4gMClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gKHR5cGUgYV9fMDEzXykgOiAoKGFfXzAxM18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMTNfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDEwXyAtPiBmdW5jdGlvblxuICAgICAgfCBPayBhcmcwX18wMTFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAxMF8gYXJnMF9fMDExXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyByZXMwX18wMTJfIF1cbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZXF1YWxfbGVuZ3Roc1wiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGludmFyaWFudCBmIHQgPSBpdGVyIHQgfmZcbmxldCBvZl9saXN0IHQgPSB0XG5cbmxldCByYW5nZScgfmNvbXBhcmUgfnN0cmlkZSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBsZXQgbmV4dF9pID0gc3RyaWRlIHN0YXJ0X2kgaW5cbiAgbGV0IG9yZGVyIHggeSA9IE9yZGVyaW5nLm9mX2ludCAoY29tcGFyZSB4IHkpIGluXG4gIGxldCByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpID1cbiAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IHJldHVybiB0aGUgc2FtZSB2YWx1ZVwiXG4gIGluXG4gIGxldCBpbml0aWFsX3N0cmlkZV9vcmRlciA9XG4gICAgbWF0Y2ggb3JkZXIgc3RhcnRfaSBuZXh0X2kgd2l0aFxuICAgIHwgRXF1YWwgLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgIHwgTGVzcyAtPiBgTGVzc1xuICAgIHwgR3JlYXRlciAtPiBgR3JlYXRlclxuICBpblxuICBsZXQgcmVjIGxvb3AgaSBhY2N1bSA9XG4gICAgbGV0IGlfdG9fc3RvcF9vcmRlciA9IG9yZGVyIGkgc3RvcF9pIGluXG4gICAgbWF0Y2ggaV90b19zdG9wX29yZGVyLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+XG4gICAgICAoKiBoYXZlbid0IHlldCByZWFjaGVkIFtzdG9wX2ldLiBDb250aW51ZS4gKilcbiAgICAgIGxldCBuZXh0X2kgPSBzdHJpZGUgaSBpblxuICAgICAgKG1hdGNoIG9yZGVyIGkgbmV4dF9pLCBpbml0aWFsX3N0cmlkZV9vcmRlciB3aXRoXG4gICAgICAgfCBFcXVhbCwgXyAtPiByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpXG4gICAgICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IGNoYW5nZSBkaXJlY3Rpb25cIlxuICAgICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPiBsb29wIG5leHRfaSAoaSA6OiBhY2N1bSkpXG4gICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAoKiBzdGVwcGVkIHBhc3QgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIGFjY3VtXG4gICAgfCBFcXVhbCwgXyAtPlxuICAgICAgKCogcmVhY2hlZCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgKG1hdGNoIHN0b3Agd2l0aFxuICAgICAgIHwgYGluY2x1c2l2ZSAtPiBpIDo6IGFjY3VtXG4gICAgICAgfCBgZXhjbHVzaXZlIC0+IGFjY3VtKVxuICBpblxuICBsZXQgc3RhcnRfaSA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgYGluY2x1c2l2ZSAtPiBzdGFydF9pXG4gICAgfCBgZXhjbHVzaXZlIC0+IG5leHRfaVxuICBpblxuICByZXYgKGxvb3Agc3RhcnRfaSBbXSlcbjs7XG5cbmxldCByYW5nZSA/KHN0cmlkZSA9IDEpID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGlmIHN0cmlkZSA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2U6IHN0cmlkZSBtdXN0IGJlIG5vbi16ZXJvXCI7XG4gIHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlOihmdW4geCAtPiB4ICsgc3RyaWRlKSB+c3RhcnQgfnN0b3Agc3RhcnRfaSBzdG9wX2lcbjs7XG5cbmxldCBoZCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogXyAtPiBTb21lIHhcbjs7XG5cbmxldCB0bCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogdCcgLT4gU29tZSB0J1xuOztcblxubGV0IG50aCB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBudGhfYXV4IHQgbiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhIDo6IHQgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IHQgKG4gLSAxKVxuICAgIGluXG4gICAgbnRoX2F1eCB0IG4pXG47O1xuXG5sZXQgbnRoX2V4biB0IG4gPVxuICBtYXRjaCBudGggdCBuIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnZiBcIkxpc3QubnRoX2V4biAlZCBjYWxsZWQgb24gbGlzdCBvZiBsZW5ndGggJWRcIiBuIChsZW5ndGggdCkgKClcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHVub3JkZXJlZF9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsIHwgbCwgW10gLT4gbFxuICB8IF8gLT4gcmV2X2FwcGVuZCBsMSBsMlxuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgICB8IFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiIC0+IGxvb3AgYSBiIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8gfCBfLCBbXSAtPiBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIGwxIGwyID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iIH0gLT5cbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiXG4gICAgICBuYW1lXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EpXG4gICAgICAoc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IpXG4gICAgICAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMilcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2MgOiAnYyBsaXN0XG4gICAgICAgIH1cblxuICAoKiBJbiB0aGUgW1VuZXF1YWxfbGVuZ3Roc10gY2FzZSwgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWlscyB3aWxsIGJlIG5vbi1lbXB0eS4gKilcbiAgbGV0IG9mX2xpc3RzIGwxIGwyIGwzID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiIGMgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiLCBjIHdpdGhcbiAgICAgIHwgW10sIFtdLCBbXSAtPiBTYW1lX2xlbmd0aCBzaGFyZWRfbGVuZ3RoXG4gICAgICB8IF8gOjogYSwgXyA6OiBiLCBfIDo6IGMgLT4gbG9vcCBhIGIgYyAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfLCBfIHwgXywgW10sIF8gfCBfLCBfLCBbXSAtPlxuICAgICAgICBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2EgPSBhOyB0YWlsX29mX2IgPSBiOyB0YWlsX29mX2MgPSBjIH1cbiAgICBpblxuICAgIGxvb3AgbDEgbDIgbDMgMFxuICA7O1xuZW5kXG5cbmxldCBjaGVja19sZW5ndGgzX2V4biBuYW1lIGwxIGwyIGwzID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiAoKVxuICB8IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYTsgdGFpbF9vZl9iOyB0YWlsX29mX2MgfSAtPlxuICAgIGxldCBuMSA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hIGluXG4gICAgbGV0IG4yID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2IgaW5cbiAgICBsZXQgbjMgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYyBpblxuICAgIGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWQgfHwgJWQgPD4gJWRcIiBuYW1lIG4xIG4yIG4yIG4zICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyIGwzKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubGV0IGl0ZXIyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooaXRlcjJfb2sgfmYpXG5cbmxldCBpdGVyMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIml0ZXIyX2V4blwiIGwxIGwyO1xuICBpdGVyMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjoocmV2X21hcDJfb2sgfmYpXG5cbmxldCByZXZfbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcInJldl9tYXAyX2V4blwiIGwxIGwyO1xuICByZXZfbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGZvbGQyIGwxIGwyIH5pbml0IH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9sZDJfb2sgfmluaXQgfmYpXG5cbmxldCBmb2xkMl9leG4gbDEgbDIgfmluaXQgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvbGQyX2V4blwiIGwxIGwyO1xuICBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZlxuOztcblxubGV0IGZvcl9hbGwyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9yX2FsbDJfb2sgfmYpXG5cbmxldCBmb3JfYWxsMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvcl9hbGwyX2V4blwiIGwxIGwyO1xuICBmb3JfYWxsMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGV4aXN0czIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihleGlzdHMyX29rIH5mKVxuXG5sZXQgZXhpc3RzMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImV4aXN0czJfZXhuXCIgbDEgbDI7XG4gIGV4aXN0czJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBlcXVhbCBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBiIDo6IGJzIC0+IGVxdWFsIGEgYiB8fCBsb29wIGVxdWFsIGEgYnNcbiAgaW5cbiAgbG9vcCBlcXVhbCBhIHRcbjs7XG5cbigqIFRoaXMgaXMgYSBjb3B5IG9mIHRoZSBjb2RlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggYW4gZXh0cmEgZXRhLWV4cGFuc2lvbiB0b1xuICAgYXZvaWQgY3JlYXRpbmcgcGFydGlhbCBjbG9zdXJlcyAoc2hvd2VkIHVwIGZvciBbZmlsdGVyXSkgaW4gcHJvZmlsaW5nKS4gKilcbmxldCByZXZfZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVjIGZpbmQgfmYgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gZmluZCB+ZiAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCB+ZiBhY2N1IGxcbiAgaW5cbiAgZmluZCB+ZiBbXSB0XG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSByZXYgKHJldl9maWx0ZXIgdCB+ZilcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBsXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICBpblxuICBsb29wIHRcbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIGxvb3AgbFxuICBpblxuICBsb29wIHRcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmVjIGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCB4IDo6IHQgLT4gaWYgZiB4IHRoZW4geCBlbHNlIGZpbmRfZXhuIHQgfmZcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgKGksIHgpIGVsc2UgbG9vcCAoaSArIDEpIGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBmaW5kaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgZmluZGlfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBsKVxuICBpblxuICBsb29wIDAgdFxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gdHJ1ZVxuICAgIHwgaGQgOjogdGwgLT4gZiBpIGhkICYmIGxvb3AgKGkgKyAxKSB0bFxuICBpblxuICBsb29wIDAgdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCB8fCBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbigqKiBGb3IgdGhlIGNvbnRhaW5lciBpbnRlcmZhY2UuICopXG5sZXQgZm9sZF9sZWZ0ID0gZm9sZFxuXG5sZXQgdG9fYXJyYXkgPSBBcnJheS5vZl9saXN0XG5sZXQgdG9fbGlzdCB0ID0gdFxuXG5sZXQgbWF4X25vbl90YWlsY2FsbCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMV8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQncyBzbWFsbC4gVGhpc1xuICAgICBudW1iZXIgd2FzIHRha2VuIGZyb20gb2NhbWwjc3RkbGliL2xpc3QubWwgd2hpY2ggaXMgYWxzbyBlcXVhbCB0byB0aGUgZGVmYXVsdCBsaW1pdFxuICAgICBvZiByZWN1cnNpdmUgY2FsbCBpbiB0aGUganNfb2Zfb2NhbWwgY29tcGlsZXIgYmVmb3JlIHN3aXRjaGluZyB0byB0cmFtcG9saW5lLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG47O1xuXG4oKiogVGFpbCByZWN1cnNpdmUgdmVyc2lvbnMgb2Ygc3RhbmRhcmQgW0xpc3RdIG1vZHVsZSAqKVxuXG5sZXQgdGFpbF9hcHBlbmQgbDEgbDIgPSByZXZfYXBwZW5kIChyZXYgbDEpIGwyXG5cbigqIFRoZXJlIGFyZSBhIGZldyBvcHRpbWl6ZWQgbGlzdCBvcGVyYXRpb25zIGhlcmUsIGluY2x1ZGluZyBhcHBlbmQgYW5kIG1hcC4gIFRoZXJlIGFyZVxuICAgYmFzaWNhbGx5IHR3byBvcHRpbWl6YXRpb25zIGluIHBsYXk6IGxvb3AgdW5yb2xsaW5nLCBhbmQgZHluYW1pYyBzd2l0Y2hpbmcgYmV0d2VlblxuICAgc3RhY2sgYW5kIGhlYXAgYWxsb2NhdGlvbi5cblxuICAgVGhlIGxvb3AtdW5yb2xsaW5nIGlzIHN0cmFpZ2h0Zm9yd2FyZCwgd2UganVzdCB1bnJvbGwgNSBsZXZlbHMgb2YgdGhlIGxvb3AuICBUaGlzIG1ha2VzXG4gICBlYWNoIGl0ZXJhdGlvbiBmYXN0ZXIsIGFuZCBhbHNvIHJlZHVjZXMgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMgY29uc3VtZWQgcGVyIGxpc3RcbiAgIGVsZW1lbnQuXG5cbiAgIFRoZSBkeW5hbWljIHN3aXRjaGluZyBpcyBkb25lIGJ5IGNvdW50aW5nIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzLCBhbmQgdGhlblxuICAgc3dpdGNoaW5nIHRvIHRoZSBcInNsb3dcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIHdlIGV4Y2VlZCBhIGdpdmVuIGxpbWl0LiAgVGhpcyBtZWFucyB0aGF0XG4gICBzaG9ydCBsaXN0cyB1c2UgdGhlIGZhc3Qgc3RhY2stYWxsb2NhdGlvbiBtZXRob2QsIGFuZCBsb25nIGxpc3RzIHVzZSBhIHNsb3dlciBvbmUgdGhhdFxuICAgZG9lc24ndCByZXF1aXJlIHN0YWNrIHNwYWNlLiAqKVxubGV0IHJlYyBjb3VudF9hcHBlbmQgbDEgbDIgY291bnQgPVxuICBtYXRjaCBsMiB3aXRoXG4gIHwgW10gLT4gbDFcbiAgfCBfIC0+XG4gICAgKG1hdGNoIGwxIHdpdGhcbiAgICAgfCBbXSAtPiBsMlxuICAgICB8IFsgeDEgXSAtPiB4MSA6OiBsMlxuICAgICB8IFsgeDE7IHgyIF0gLT4geDEgOjogeDIgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDMgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiBsMlxuICAgICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiBsMlxuICAgICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgICAgeDFcbiAgICAgICA6OiB4MlxuICAgICAgIDo6IHgzXG4gICAgICAgOjogeDRcbiAgICAgICA6OiB4NVxuICAgICAgIDo6XG4gICAgICAgKGlmIGNvdW50ID4gbWF4X25vbl90YWlsY2FsbFxuICAgICAgICB0aGVuIHRhaWxfYXBwZW5kIHRsIGwyXG4gICAgICAgIGVsc2UgY291bnRfYXBwZW5kIHRsIGwyIChjb3VudCArIDEpKSlcbjs7XG5cbmxldCBhcHBlbmQgbDEgbDIgPSBjb3VudF9hcHBlbmQgbDEgbDIgMFxuXG4oKiBBbiBvcmRpbmFyeSB0YWlsIHJlY3Vyc2l2ZSBtYXAgYnVpbGRzIHVwIGFuIGludGVybWVkaWF0ZSAocmV2ZXJzZWQpIHJlcHJlc2VudGF0aW9uLFxuICAgd2l0aCBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0IHBlciBlbGVtZW50LiBUaGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uIGluc3RlYWQgY2h1bmtzXG4gICA5IG9iamVjdHMgaW50byBvbmUgaGVhcCBhbGxvY2F0ZWQgb2JqZWN0LCByZWR1Y2luZyBhbGxvY2F0aW9uIGFuZCBwZXJmb3JtYW5jZSBjb3N0c1xuICAgYWNjb3JkaW5nbHkuIE5vdGUgdGhhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGxpc3QgaXMgZG9uZSBieSB0aGUgc3RkbGliJ3MgbWFwXG4gICBmdW5jdGlvbi4gKilcbmxldCB0YWlsX21hcCB4cyB+ZiA9XG4gIGxldCByZWMgcmlzZSB5cyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB5c1xuICAgIHwgKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzIC0+XG4gICAgICByaXNlICh5MCA6OiB5MSA6OiB5MiA6OiB5MyA6OiB5NCA6OiB5NSA6OiB5NiA6OiB5NyA6OiB5OCA6OiB5cykgYnNcbiAgaW5cbiAgbGV0IHJlYyBkaXZlIGJzID0gZnVuY3Rpb25cbiAgICB8IHgwIDo6IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHg2IDo6IHg3IDo6IHg4IDo6IHhzIC0+XG4gICAgICBsZXQgeTAgPSBmIHgwIGluXG4gICAgICBsZXQgeTEgPSBmIHgxIGluXG4gICAgICBsZXQgeTIgPSBmIHgyIGluXG4gICAgICBsZXQgeTMgPSBmIHgzIGluXG4gICAgICBsZXQgeTQgPSBmIHg0IGluXG4gICAgICBsZXQgeTUgPSBmIHg1IGluXG4gICAgICBsZXQgeTYgPSBmIHg2IGluXG4gICAgICBsZXQgeTcgPSBmIHg3IGluXG4gICAgICBsZXQgeTggPSBmIHg4IGluXG4gICAgICBkaXZlICgoeTAsIHkxLCB5MiwgeTMsIHk0LCB5NSwgeTYsIHk3LCB5OCkgOjogYnMpIHhzXG4gICAgfCB4cyAtPiByaXNlIChub250YWlsX21hcCB+ZiB4cykgYnNcbiAgaW5cbiAgZGl2ZSBbXSB4c1xuOztcblxubGV0IHJlYyBjb3VudF9tYXAgfmYgbCBjdHIgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IFsgeDEgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBbIGYxIF1cbiAgfCBbIHgxOyB4MiBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBbIGYxOyBmMiBdXG4gIHwgWyB4MTsgeDI7IHgzIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBbIGYxOyBmMjsgZjMgXVxuICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgbGV0IGYzID0gZiB4MyBpblxuICAgIGxldCBmNCA9IGYgeDQgaW5cbiAgICBbIGYxOyBmMjsgZjM7IGY0IF1cbiAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgbGV0IGYzID0gZiB4MyBpblxuICAgIGxldCBmNCA9IGYgeDQgaW5cbiAgICBsZXQgZjUgPSBmIHg1IGluXG4gICAgZjFcbiAgICA6OiBmMlxuICAgIDo6IGYzXG4gICAgOjogZjRcbiAgICA6OiBmNVxuICAgIDo6IChpZiBjdHIgPiBtYXhfbm9uX3RhaWxjYWxsIHRoZW4gdGFpbF9tYXAgfmYgdGwgZWxzZSBjb3VudF9tYXAgfmYgdGwgKGN0ciArIDEpKVxuOztcblxubGV0IG1hcCBsIH5mID0gY291bnRfbWFwIH5mIGwgMFxuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCAoID4+fCApIGwgZiA9IG1hcCBsIH5mXG5sZXQgbWFwMl9vayBsMSBsMiB+ZiA9IHJldiAocmV2X21hcDJfb2sgbDEgbDIgfmYpXG5sZXQgbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KG1hcDJfb2sgfmYpXG5cbmxldCBtYXAyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwibWFwMl9leG5cIiBsMSBsMjtcbiAgbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAzX29rIGwxIGwyIGwzIH5mID1cbiAgbGV0IHJlYyBsb29wIGwxIGwyIGwzIGFjID1cbiAgICBtYXRjaCBsMSwgbDIsIGwzIHdpdGhcbiAgICB8IFtdLCBbXSwgW10gLT4gYWNcbiAgICB8IHgxIDo6IGwxLCB4MiA6OiBsMiwgeDMgOjogbDMgLT4gbG9vcCBsMSBsMiBsMyAoZiB4MSB4MiB4MyA6OiBhYylcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGxvb3AgbDEgbDIgbDMgW11cbjs7XG5cbmxldCByZXZfbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KHJldl9tYXAzX29rIH5mKVxuXG5sZXQgcmV2X21hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJyZXZfbWFwM19leG5cIiBsMSBsMiBsMztcbiAgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCBtYXAzX29rIGwxIGwyIGwzIH5mID0gcmV2IChyZXZfbWFwM19vayBsMSBsMiBsMyB+ZilcbmxldCBtYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoobWFwM19vayB+ZilcblxubGV0IG1hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJtYXAzX2V4blwiIGwxIGwyIGwzO1xuICBtYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kIGwxIGwyIH5mID1cbiAgbWF0Y2ggbDEgd2l0aFxuICB8IFtdIC0+IGwyXG4gIHwgaCA6OiB0IC0+IHJldl9tYXBfYXBwZW5kIH5mIHQgKGYgaCA6OiBsMilcbjs7XG5cbmxldCB1bnppcCBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyXG4gICAgfCAoeCwgeSkgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXVxuOztcblxubGV0IHVuemlwMyBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgbDMgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyLCBsM1xuICAgIHwgKHgsIHksIHopIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKSAoeiA6OiBsMylcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdIFtdXG47O1xuXG5sZXQgemlwX2V4biBsMSBsMiA9XG4gIHRyeSBtYXAyX29rIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiB6aXBfZXhuOiAlZCA8PiAlZFwiIChsZW5ndGggbDEpIChsZW5ndGggbDIpICgpXG47O1xuXG5sZXQgemlwIGwxIGwyID0gbWFwMiB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMlxuXG4oKiogQWRkaXRpb25hbCBsaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJldl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoIDo6IHQgLT4gbG9vcCAoaSArIDEpIChmIGkgaCA6OiBhY2MpIHRcbiAgaW5cbiAgbG9vcCAwIFtdIGxcbjs7XG5cbmxldCBtYXBpIGwgfmYgPSByZXYgKHJldl9tYXBpIGwgfmYpXG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGl0ZXJpIGwgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCBsIH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIHNuZCAoZm9sZCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHYgLT4gaSArIDEsIGYgaSBhY2MgdikpXG47O1xuXG5sZXQgZmlsdGVyaSBsIH5mID1cbiAgcmV2IChmb2xkaSBsIH5mOihmdW4gcG9zIGFjYyB4IC0+IGlmIGYgcG9zIHggdGhlbiB4IDo6IGFjYyBlbHNlIGFjYykgfmluaXQ6W10pXG47O1xuXG5sZXQgcmVkdWNlIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgaGQgOjogdGwgLT4gU29tZSAoZm9sZCB+aW5pdDpoZCB+ZiB0bClcbjs7XG5cbmxldCByZWR1Y2VfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2UgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiA9XG4gICgqIENhbGwgdGhlIFwic2l6ZVwiIG9mIGEgdmFsdWUgdGhlIG51bWJlciBvZiBsaXN0IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNvbWJpbmVkIGludG9cbiAgICAgaXQgdmlhIGNhbGxzIHRvIFtmXS4gIFdlIHByb2NlZWQgYnkgdXNpbmcgW2ZdIHRvIGNvbWJpbmUgZWxlbWVudHMgaW4gdGhlIGFjY3VtdWxhdG9yXG4gICAgIG9mIHRoZSBzYW1lIHNpemUgdW50aWwgd2UgY2FuJ3QgY29tYmluZSBhbnkgbW9yZSwgdGhlbiBnZXR0aW5nIGEgbmV3IGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgaW5wdXQgbGlzdCBhbmQgcmVwZWF0aW5nLlxuXG4gICAgIFdpdGggdGhpcyBzdHJhdGVneSwgaW4gdGhlIGFjY3VtdWxhdG9yOlxuICAgICAtIHdlIG9ubHkgZXZlciBoYXZlIGVsZW1lbnRzIG9mIHNpemVzIGEgcG93ZXIgb2YgdHdvXG4gICAgIC0gd2UgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGVsZW1lbnQgb2YgZWFjaCBzaXplXG4gICAgIC0gdGhlIHN1bSBvZiBhbGwgdGhlIGVsZW1lbnQgc2l6ZXMgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZFxuXG4gICAgIFRoZXNlIGNvbmRpdGlvbnMgZW5mb3JjZSB0aGF0IGxpc3Qgb2YgZWxlbWVudHMgb2YgZWFjaCBzaXplIGlzIHByZWNpc2VseSB0aGUgYmluYXJ5XG4gICAgIGV4cGFuc2lvbiBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkOiBpZiB5b3UndmUgY29uc3VtZWQgMTMgPSAwYjExMDFcbiAgICAgZWxlbWVudHMsIHlvdSBoYXZlIG9uZSBlbGVtZW50IG9mIHNpemUgOCwgb25lIG9mIHNpemUgNCwgYW5kIG9uZSBvZiBzaXplIDEuICBIZW5jZVxuICAgICB3aGVuIGEgbmV3IGVsZW1lbnQgY29tZXMgYWxvbmcsIHRoZSBudW1iZXIgb2YgY29tYmluaW5ncyB5b3UgbmVlZCB0byBkbyBpcyB0aGUgbnVtYmVyXG4gICAgIG9mIHRyYWlsaW5nIDFzIGluIHRoZSBiaW5hcnkgZXhwYW5zaW9uIG9mIFtudW1dLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZVxuICAgICBhbHJlYWR5IGdvbmUgaW50byB0aGUgYWNjdW11bGF0b3IuICBUaGUgYWNjdW11bGF0b3IgaXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHNpemUsIHNvXG4gICAgIHRoZSBuZXh0IGVsZW1lbnQgdG8gY29tYmluZSB3aXRoIGlzIGFsd2F5cyB0aGUgaGVhZCBvZiB0aGUgbGlzdC4gKilcbiAgbGV0IHJlYyBzdGVwX2FjY3VtIG51bSBhY2MgeCA9XG4gICAgaWYgbnVtIGxhbmQgMSA9IDBcbiAgICB0aGVuIHggOjogYWNjXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICgqIE5ldyBlbGVtZW50cyBmcm9tIGxhdGVyIGluIHRoZSBpbnB1dCBsaXN0IGdvIG9uIHRoZSBmcm9udCBvZiB0aGUgYWNjdW11bGF0b3IsIHNvXG4gICAgICAgICB0aGUgYWNjdW11bGF0b3IgaXMgaW4gcmV2ZXJzZSBvcmRlciB3cnQgdGhlIG9yaWdpbmFsIGxpc3Qgb3JkZXIsIGhlbmNlIFtmIHkgeF1cbiAgICAgICAgIGluc3RlYWQgb2YgW2YgeCB5XS4gKilcbiAgICAgIHwgeSA6OiB5cyAtPiBzdGVwX2FjY3VtIChudW0gYXNyIDEpIHlzIChmIHkgeCkpXG4gIGluXG4gICgqIEV4cGVyaW1lbnRhbGx5LCBpbmxpbmluZyBbZm9sZGldIGFuZCB1bnJvbGxpbmcgdGhpcyBsb29wIGEgZmV3IHRpbWVzIGNhbiByZWR1Y2VcbiAgICAgcnVudGltZSBkb3duIHRvIGEgdGhpcmQgYW5kIGFsbG9jYXRpb24gdG8gMS8xNnRoIG9yIHNvIGluIHRoZSBtaWNyb2JlbmNobWFya3MgYmVsb3cuXG4gICAgIEhvd2V2ZXIsIGluIG1vc3QgdXNlIGNhc2VzIFtmXSBpcyBsaWtlbHkgdG8gYmUgZXhwZW5zaXZlIChvdGhlcndpc2Ugd2h5IGRvIHlvdSBjYXJlXG4gICAgIGFib3V0IHRoZSBvcmRlciBvZiByZWR1Y3Rpb24/KSBzbyB0aGUgb3ZlcmhlYWQgb2YgdGhpcyBmdW5jdGlvbiBpdHNlbGYgZG9lc24ndCByZWFsbHlcbiAgICAgbWF0dGVyLiBJZiB5b3UgY29tZSB1cCB3aXRoIGEgdXNlLWNhc2Ugd2hlcmUgaXQgZG9lcywgdGhlbiB0aGF0J3Mgc29tZXRoaW5nIHlvdSBtaWdodFxuICAgICB3YW50IHRvIHRyeTogc2VlIGhnIGxvZyAtcHIgNDllZjA2NWY0MjlkLiAqKVxuICBtYXRjaCBmb2xkaSBsIH5pbml0OltdIH5mOnN0ZXBfYWNjdW0gd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IFNvbWUgKGZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIHggeSAtPiBmIHkgeCkpXG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlX2JhbGFuY2VkIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9iYWxhbmNlZF9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgZ3JvdXBpIGwgfmJyZWFrID1cbiAgbGV0IGdyb3VwcyA9XG4gICAgZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIHggLT5cbiAgICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgICB8IFtdIC0+IFsgWyB4IF0gXVxuICAgICAgfCBjdXJyZW50X2dyb3VwIDo6IHRsIC0+XG4gICAgICAgIGlmIGJyZWFrIGkgKGhkX2V4biBjdXJyZW50X2dyb3VwKSB4XG4gICAgICAgIHRoZW4gWyB4IF0gOjogY3VycmVudF9ncm91cCA6OiB0bCAoKiBzdGFydCBuZXcgZ3JvdXAgKilcbiAgICAgICAgZWxzZSAoeCA6OiBjdXJyZW50X2dyb3VwKSA6OiB0bClcbiAgICAoKiBleHRlbmQgY3VycmVudCBncm91cCAqKVxuICBpblxuICBtYXRjaCBncm91cHMgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgbCAtPiByZXZfbWFwIGwgfmY6cmV2XG47O1xuXG5sZXQgZ3JvdXAgbCB+YnJlYWsgPSBncm91cGkgbCB+YnJlYWs6KGZ1biBfIHggeSAtPiBicmVhayB4IHkpXG5cbmxldCBzb3J0X2FuZF9ncm91cCBsIH5jb21wYXJlID1cbiAgbCB8PiBzdGFibGVfc29ydCB+Y29tcGFyZSB8PiBncm91cCB+YnJlYWs6KGZ1biB4IHkgLT4gY29tcGFyZSB4IHkgPD4gMClcbjs7XG5cbmxldCBjb25jYXRfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gYXV4IChyZXZfYXBwZW5kIChmIGhkKSBhY2MpIHRsXG4gIGluXG4gIGF1eCBbXSBsXG47O1xuXG5sZXQgY29uY2F0X21hcGkgbCB+ZiA9XG4gIGxldCByZWMgYXV4IGNvbnQgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IGF1eCAoY29udCArIDEpIChyZXZfYXBwZW5kIChmIGNvbnQgaGQpIGFjYykgdGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuOztcblxubGV0IG1lcmdlIGwxIGwyIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGFjYyBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGFjYyBsMlxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgYWNjIGwxXG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNvbXBhcmUgaDEgaDIgPD0gMCB0aGVuIGxvb3AgKGgxIDo6IGFjYykgdDEgbDIgZWxzZSBsb29wIChoMiA6OiBhY2MpIGwxIHQyXG4gIGluXG4gIGxvb3AgW10gbDEgbDJcbjs7XG5cbm1vZHVsZSBDYXJ0ZXNpYW5fcHJvZHVjdCA9IHN0cnVjdFxuICAoKiBXZSBhcmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3ZSBleHBvcnQgZnJvbSBmdW5jdG9ycyBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseVxuICAgICByZWJpbmQgbW9yZSBlZmZpY2llbnQgbGlzdC1zcGVjaWZpYyBmdW5jdGlvbnMuICopXG5cbiAgbGV0IGJpbmQgPSBjb25jYXRfbWFwXG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcDIgYSBiIH5mID0gY29uY2F0X21hcCBhIH5mOihmdW4geCAtPiBtYXAgYiB+ZjooZnVuIHkgLT4gZiB4IHkpKVxuICBsZXQgcmV0dXJuIHggPSBbIHggXVxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG5cbiAgb3BlbiBzdHJ1Y3RcbiAgICBtb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgICAgbGV0IG1hcDIgPSBtYXAyXG4gICAgICBlbmQpXG5cbiAgICBtb2R1bGUgTW9uYWQgPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgZW5kKVxuICBlbmRcblxuICBsZXQgYWxsID0gTW9uYWQuYWxsXG4gIGxldCBhbGxfdW5pdCA9IE1vbmFkLmFsbF91bml0XG4gIGxldCBpZ25vcmVfbSA9IE1vbmFkLmlnbm9yZV9tXG4gIGxldCBqb2luID0gTW9uYWQuam9pblxuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuICBlbmRcblxuICBsZXQgYXBwbHkgPSBBcHBsaWNhdGl2ZS5hcHBseVxuICBsZXQgYm90aCA9IEFwcGxpY2F0aXZlLmJvdGhcbiAgbGV0IG1hcDMgPSBBcHBsaWNhdGl2ZS5tYXAzXG4gIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gICAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuICBlbmRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgKENhcnRlc2lhbl9wcm9kdWN0IDogTW9uYWQuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0KVxuXG4oKiogcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdF9leG4gbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IHhcbiAgfCBfIDo6IHRsIC0+IGxhc3RfZXhuIHRsXG4gIHwgW10gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lmxhc3RcIlxuOztcblxuKCoqIG9wdGlvbmFsbHkgcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdCBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4gU29tZSB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0IHRsXG4gIHwgW10gLT4gTm9uZVxuOztcblxubGV0IHJlYyBpc19wcmVmaXggbGlzdCB+cHJlZml4IH5lcXVhbCA9XG4gIG1hdGNoIHByZWZpeCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IGhkIDo6IHRsIC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+IGZhbHNlXG4gICAgIHwgaGQnIDo6IHRsJyAtPiBlcXVhbCBoZCBoZCcgJiYgaXNfcHJlZml4IHRsJyB+cHJlZml4OnRsIH5lcXVhbClcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBhMSA6OiB0IC0+XG4gICAgbGV0IHJlYyBsb29wIGExIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYTIgOjogdCAtPiBpZiBlcXVhbCBhMSBhMiB0aGVuIFNvbWUgKGExLCBhMikgZWxzZSBsb29wIGEyIHRcbiAgICBpblxuICAgIGxvb3AgYTEgdFxuOztcblxuKCogcmV0dXJucyBsaXN0IHdpdGhvdXQgYWRqYWNlbnQgZHVwbGljYXRlcyAqKVxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzID8od2hpY2hfdG9fa2VlcCA9IGBMYXN0KSBsaXN0IH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCB0b19rZWVwIGFjY3VtID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHRvX2tlZXAgOjogYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBlcXVhbCBoZCB0b19rZWVwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRvX2tlZXAgPVxuICAgICAgICAgIG1hdGNoIHdoaWNoX3RvX2tlZXAgd2l0aFxuICAgICAgICAgIHwgYEZpcnN0IC0+IHRvX2tlZXBcbiAgICAgICAgICB8IGBMYXN0IC0+IGhkXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgdG9fa2VlcCBhY2N1bSB0bClcbiAgICAgIGVsc2UgbG9vcCBoZCAodG9fa2VlcCA6OiBhY2N1bSkgdGxcbiAgaW5cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiByZXYgKGxvb3AgaGQgW10gdGwpXG47O1xuXG4oKiogcmV0dXJucyBzb3J0ZWQgdmVyc2lvbiBvZiBsaXN0IHdpdGggZHVwbGljYXRlcyByZW1vdmVkICopXG5sZXQgZGVkdXBfYW5kX3NvcnQgbGlzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIHwgWyBfIF0gLT4gbGlzdCAoKiBwZXJmb3JtYW5jZSBoYWNrICopXG4gIHwgXyAtPlxuICAgIGxldCBlcXVhbCB4IHgnID0gY29tcGFyZSB4IHgnID0gMCBpblxuICAgIGxldCBzb3J0ZWQgPSBzb3J0IH5jb21wYXJlIGxpc3QgaW5cbiAgICByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyB+ZXF1YWwgc29ydGVkXG47O1xuXG5sZXQgZmluZF9hX2R1cCBsIH5jb21wYXJlID1cbiAgbGV0IHNvcnRlZCA9IHNvcnQgbCB+Y29tcGFyZSBpblxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IE5vbmVcbiAgICB8IGhkMSA6OiAoaGQyIDo6IF8gYXMgdGwpIC0+IGlmIGNvbXBhcmUgaGQxIGhkMiA9IDAgdGhlbiBTb21lIGhkMSBlbHNlIGxvb3AgdGxcbiAgaW5cbiAgbG9vcCBzb3J0ZWRcbjs7XG5cbmxldCBjb250YWluc19kdXAgbHN0IH5jb21wYXJlID1cbiAgbWF0Y2ggZmluZF9hX2R1cCBsc3QgfmNvbXBhcmUgd2l0aFxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZpbmRfYWxsX2R1cHMgbCB+Y29tcGFyZSA9XG4gICgqIFdlIGFkZCB0aGlzIHJldmVyc2FsLCBzbyB3ZSBjYW4gc2tpcCBhIFtyZXZdIGF0IHRoZSBlbmQuIFdlIGNvdWxkIHNraXBcbiAgICAgW3Jldl0gYW55d2F5IHNpbmNlIHdlIGRvbiBub3QgZ2l2ZSBhbnkgb3JkZXJpbmcgZ3VhcmFudGVlcywgYnV0IGl0IGlzXG4gICAgIG5pY2UgdG8gZ2V0IHJlc3VsdHMgaW4gbmF0dXJhbCBvcmRlci4gKilcbiAgbGV0IGNvbXBhcmUgYSBiID0gLTEgKiBjb21wYXJlIGEgYiBpblxuICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsIGluXG4gICgqIFdhbGsgdGhlIGxpc3QgYW5kIHJlY29yZCB0aGUgZmlyc3Qgb2YgZWFjaCBjb25zZWN1dGl2ZSBydW4gb2YgaWRlbnRpY2FsIGVsZW1lbnRzICopXG4gIGxldCByZWMgbG9vcCBzb3J0ZWQgcHJldiB+YWxyZWFkeV9yZWNvcmRlZCBhY2MgPVxuICAgIG1hdGNoIHNvcnRlZCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBjb21wYXJlIHByZXYgaGQgPD4gMFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIGFjY1xuICAgICAgZWxzZSBpZiBhbHJlYWR5X3JlY29yZGVkXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSBhY2NcbiAgICAgIGVsc2UgbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlIChoZCA6OiBhY2MpXG4gIGluXG4gIG1hdGNoIHNvcnRlZCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIFtdXG47O1xuXG5sZXQgcmVjIGFsbF9lcXVhbF90byB0IHYgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IHggOjogeHMgLT4gZXF1YWwgeCB2ICYmIGFsbF9lcXVhbF90byB4cyB2IH5lcXVhbFxuOztcblxubGV0IGFsbF9lcXVhbCB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IHhzIC0+IGlmIGFsbF9lcXVhbF90byB4cyB4IH5lcXVhbCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcbjs7XG5cbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpZHggY291bnQgYSAtPiBpZiBmIGlkeCBhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG47O1xuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmluaXQgJWRcIiBuICgpO1xuICBsZXQgcmVjIGxvb3AgaSBhY2N1bSA9XG4gICAgYXNzZXJ0IChpID49IDApO1xuICAgIGlmIGkgPSAwIHRoZW4gYWNjdW0gZWxzZSBsb29wIChpIC0gMSkgKGYgKGkgLSAxKSA6OiBhY2N1bSlcbiAgaW5cbiAgbG9vcCBuIFtdXG47O1xuXG5sZXQgcmV2X2ZpbHRlcl9tYXAgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgbCBbXVxuOztcblxubGV0IGZpbHRlcl9tYXAgbCB+ZiA9IHJldiAocmV2X2ZpbHRlcl9tYXAgbCB+ZilcblxubGV0IHJldl9maWx0ZXJfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGkgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgKGkgKyAxKSB0bCAoeCA6OiBhY2N1bSlcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIHRsIGFjY3VtKVxuICBpblxuICBsb29wIDAgbCBbXVxuOztcblxubGV0IGZpbHRlcl9tYXBpIGwgfmYgPSByZXYgKHJldl9maWx0ZXJfbWFwaSBsIH5mKVxubGV0IGZpbHRlcl9vcHQgbCA9IGZpbHRlcl9tYXAgbCB+ZjpGbi5pZFxuXG5sZXQgcGFydGl0aW9uM19tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IGZzdCBzbmQgdHJkID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmQsIHJldiB0cmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBgRnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kIHRyZFxuICAgICAgIHwgYFNuZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSB0cmRcbiAgICAgICB8IGBUcmQgeSAtPiBsb29wIHQgZnN0IHNuZCAoeSA6OiB0cmQpKVxuICBpblxuICBsb29wIHQgW10gW10gW11cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gIGxldCBmIHggOiBfIEVpdGhlci50ID0gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4IGluXG4gIHBhcnRpdGlvbl9tYXAgdCB+ZlxuOztcblxubGV0IHBhcnRpdGlvbl9yZXN1bHQgdCA9IHBhcnRpdGlvbl9tYXAgdCB+ZjpSZXN1bHQudG9fZWl0aGVyXG5cbm1vZHVsZSBBc3NvYyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EgKiAnYikgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdhICdiLlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAyMl8gPSBcImxpc3QubWwuQXNzb2MudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMTRfIF9vZl9iX18wMTVfIHhfXzAyM18gLT5cbiAgICAgIGxpc3Rfb2Zfc2V4cFxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzAxN187IGFyZzFfXzAxOF8gXSAtPlxuICAgICAgICAgICAgbGV0IHJlczBfXzAxOV8gPSBfb2ZfYV9fMDE0XyBhcmcwX18wMTdfXG4gICAgICAgICAgICBhbmQgcmVzMV9fMDIwXyA9IF9vZl9iX18wMTVfIGFyZzFfXzAxOF8gaW5cbiAgICAgICAgICAgIHJlczBfXzAxOV8sIHJlczFfXzAyMF9cbiAgICAgICAgICB8IHNleHBfXzAyMV8gLT5cbiAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjJfXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgc2V4cF9fMDIxXylcbiAgICAgICAgeF9fMDIzX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfYV9fMDI0XyBfb2ZfYl9fMDI1XyB4X18wMzBfIC0+XG4gICAgICBzZXhwX29mX2xpc3RcbiAgICAgICAgKGZ1biAoYXJnMF9fMDI2XywgYXJnMV9fMDI3XykgLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAyOF8gPSBfb2ZfYV9fMDI0XyBhcmcwX18wMjZfXG4gICAgICAgICAgIGFuZCByZXMxX18wMjlfID0gX29mX2JfXzAyNV8gYXJnMV9fMDI3XyBpblxuICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wMjhfOyByZXMxX18wMjlfIF0pXG4gICAgICAgIHhfXzAzMF9cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgICBsaXN0X3NleHBfZ3JhbW1hclxuICAgICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgICAgTGlzdCAoQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSkpXG4gICAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBwYWlyX29mX2dyb3VwID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGssIF8pIDo6IF8gYXMgbGlzdCAtPiBrLCBtYXAgbGlzdCB+ZjpzbmRcbiAgOztcblxuICBsZXQgZ3JvdXAgYWxpc3QgfmVxdWFsID1cbiAgICBncm91cCBhbGlzdCB+YnJlYWs6KGZ1biAoeCwgXykgKHksIF8pIC0+IG5vdCAoZXF1YWwgeCB5KSkgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmUgPVxuICAgIHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlOihmdW4gKHgsIF8pICh5LCBfKSAtPiBjb21wYXJlIHggeSlcbiAgICB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5mOihmdW4gKGtleScsIF8pIC0+IGVxdWFsIGtleSBrZXknKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChzbmQgeClcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuQXNzb2MuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICAgIGxldCBmaW5kX2V4biB0IH5lcXVhbCBrZXkgPVxuICAgICAgbWF0Y2ggZmluZCB0IGtleSB+ZXF1YWwgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHZhbHVlIC0+IHZhbHVlXG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5lcXVhbCBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBfIC0+IHRydWVcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgfmVxdWFsIGtleSA9IGZpbHRlciB0IH5mOihmdW4gKGtleScsIF8pIC0+IG5vdCAoZXF1YWwga2V5IGtleScpKVxuXG4gIGxldCBhZGQgdCB+ZXF1YWwga2V5IHZhbHVlID1cbiAgICAoKiB0aGUgcmVtb3ZlIGRvZXNuJ3QgY2hhbmdlIHRoZSBtYXAgc2VtYW50aWNzLCBidXQga2VlcHMgdGhlIGxpc3Qgc21hbGwgKilcbiAgICAoa2V5LCB2YWx1ZSkgOjogcmVtb3ZlIHQgfmVxdWFsIGtleVxuICA7O1xuXG4gIGxldCBpbnZlcnNlIHQgPSBtYXAgdCB+ZjooZnVuICh4LCB5KSAtPiB5LCB4KVxuICBsZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZjooZnVuIChrZXksIHZhbHVlKSAtPiBrZXksIGYgdmFsdWUpXG5lbmRcblxubGV0IHN1YiBsIH5wb3MgfmxlbiA9XG4gICgqIFdlIHVzZSBbcG9zID4gbGVuZ3RoIGwgLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiBsZW5ndGggbF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gbGVuZ3RoIGwgLSBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3Quc3ViXCI7XG4gIHJldlxuICAgIChmb2xkaSBsIH5pbml0OltdIH5mOihmdW4gaSBhY2MgZWwgLT5cbiAgICAgICBpZiBpID49IHBvcyAmJiBpIDwgcG9zICsgbGVuIHRoZW4gZWwgOjogYWNjIGVsc2UgYWNjKSlcbjs7XG5cbmxldCBzcGxpdF9uIHRfb3JpZyBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gW10sIHRfb3JpZ1xuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bSwgdFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZywgW10gKCogaW4gdGhpcyBjYXNlLCB0X29yaWcgPSByZXYgYWNjdW0gKilcbiAgICAgICAgfCBoZCA6OiB0bCAtPiBsb29wIChuIC0gMSkgdGwgKGhkIDo6IGFjY3VtKSlcbiAgICBpblxuICAgIGxvb3AgbiB0X29yaWcgW10pXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfbl0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZSB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBuIHQgYWNjdW0gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gcmV2IGFjY3VtXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gdF9vcmlnXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxubGV0IHJlYyBkcm9wIHQgbiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IF8gOjogdGwgd2hlbiBuID4gMCAtPiBkcm9wIHRsIChuIC0gMSlcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBjaHVua3Nfb2YgbCB+bGVuZ3RoID1cbiAgaWYgbGVuZ3RoIDw9IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmNodW5rc19vZjogRXhwZWN0ZWQgbGVuZ3RoID4gMCwgZ290ICVkXCIgbGVuZ3RoICgpO1xuICBsZXQgcmVjIGF1eCBvZl9sZW5ndGggYWNjIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgXyA6OiBfIC0+XG4gICAgICBsZXQgc3VibGlzdCwgbCA9IHNwbGl0X24gbCBsZW5ndGggaW5cbiAgICAgIGF1eCBvZl9sZW5ndGggKHN1Ymxpc3QgOjogYWNjKSBsXG4gIGluXG4gIGF1eCBsZW5ndGggW10gbFxuOztcblxubGV0IHNwbGl0X3doaWxlIHhzIH5mID1cbiAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gbG9vcCAoaGQgOjogYWNjKSB0bFxuICAgIHwgdCAtPiByZXYgYWNjLCB0XG4gIGluXG4gIGxvb3AgW10geHNcbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF93aGlsZV0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZV93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IF8gLT4gcmV2IGFjY1xuICBpblxuICBsb29wIFtdIHhzXG47O1xuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBkcm9wX3doaWxlIHRsIH5mXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgZHJvcF9sYXN0IHQgPVxuICBtYXRjaCByZXYgdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogbHN0IC0+IFNvbWUgKHJldiBsc3QpXG47O1xuXG5sZXQgZHJvcF9sYXN0X2V4biB0ID1cbiAgbWF0Y2ggZHJvcF9sYXN0IHQgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJMaXN0LmRyb3BfbGFzdF9leG46IGVtcHR5IGxpc3RcIlxuICB8IFNvbWUgbHN0IC0+IGxzdFxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IGxpc3QxIGxpc3QyID1cbiAgaWYgaXNfZW1wdHkgbGlzdDJcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbDEgbDIgYWNjdW0gPVxuICAgICAgbWF0Y2ggbDEgd2l0aFxuICAgICAgfCBbXSAtPiBhY2N1bVxuICAgICAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGwyIChyZXZfYXBwZW5kIChtYXAgfmY6KGZ1biB4IC0+IGhkLCB4KSBsMikgYWNjdW0pXG4gICAgaW5cbiAgICByZXYgKGxvb3AgbGlzdDEgbGlzdDIgW10pKVxuOztcblxubGV0IGNvbmNhdCBsID0gZm9sZF9yaWdodCBsIH5pbml0OltdIH5mOmFwcGVuZFxubGV0IGNvbmNhdF9ub19vcmRlciBsID0gZm9sZCBsIH5pbml0OltdIH5mOihmdW4gYWNjIGwgLT4gcmV2X2FwcGVuZCBsIGFjYylcbmxldCBjb25zIHggbCA9IHggOjogbFxuXG5sZXQgaXNfc29ydGVkIGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPD0gMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsXG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPCAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGxcbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gICgqIHNwZWNpYWwgY2FzZXMgdG8gc3BlZWQgdGhpbmdzIHVwIGluIHRyaXZpYWwgY2FzZXMgKilcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3RcbiAgfCBbIHg7IHkgXSAtPiBpZiBSYW5kb20uU3RhdGUuYm9vbCByYW5kb21fc3RhdGUgdGhlbiBbIHk7IHggXSBlbHNlIGxpc3RcbiAgfCBfIC0+XG4gICAgbGV0IGFyciA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIEFycmF5X3Blcm11dGUucGVybXV0ZSBhcnIgfnJhbmRvbV9zdGF0ZTtcbiAgICBBcnJheS50b19saXN0IGFyclxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgaWYgaXNfZW1wdHkgbGlzdFxuICB0aGVuIGZhaWx3aXRoIFwiTGlzdC5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGxpc3RcIlxuICBlbHNlIG50aF9leG4gbGlzdCAoUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCBsaXN0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIGxpc3QpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgY29tcGFyZSBjbXAgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgaWYgbiA9IDAgdGhlbiBjb21wYXJlIGNtcCB4cyB5cyBlbHNlIG5cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA9IGhhc2hfZm9sZF9saXN0XG5cbmxldCBlcXVhbCBlcXVhbCB0MSB0MiA9XG4gIGxldCByZWMgbG9vcCB+ZXF1YWwgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgeDEgOjogdDEsIHgyIDo6IHQyIC0+IGVxdWFsIHgxIHgyICYmIGxvb3AgfmVxdWFsIHQxIHQyXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgfmVxdWFsIHQxIHQyXG47O1xuXG5sZXQgdHJhbnNwb3NlID1cbiAgbGV0IHJlYyBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHQgY29sdW1uX2FjYyB0cmltbWVkIGZvdW5kX2VtcHR5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGNvbHVtbl9hY2MsIHRyaW1tZWQsIGZvdW5kX2VtcHR5XG4gICAgfCBbXSA6OiB0bCAtPiBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsIGNvbHVtbl9hY2MgdHJpbW1lZCB0cnVlXG4gICAgfCAoeCA6OiB4cykgOjogdGwgLT5cbiAgICAgIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgKHggOjogY29sdW1uX2FjYykgKHhzIDo6IHRyaW1tZWQpIGZvdW5kX2VtcHR5XG4gIGluXG4gIGxldCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgPSBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgW10gW10gZmFsc2UgaW5cbiAgbGV0IHJlYyBsb29wIHJvd3MgY29sdW1ucyBkb19yZXYgPVxuICAgIG1hdGNoIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyB3aXRoXG4gICAgfCBbXSwgW10sIF8gLT4gU29tZSAocmV2IGNvbHVtbnMpXG4gICAgfCBjb2x1bW4sIHRyaW1tZWRfcm93cywgZm91bmRfZW1wdHkgLT5cbiAgICAgIGlmIGZvdW5kX2VtcHR5XG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgY29sdW1uID0gaWYgZG9fcmV2IHRoZW4gcmV2IGNvbHVtbiBlbHNlIGNvbHVtbiBpblxuICAgICAgICBsb29wIHRyaW1tZWRfcm93cyAoY29sdW1uIDo6IGNvbHVtbnMpIChub3QgZG9fcmV2KSlcbiAgaW5cbiAgZnVuIHQgLT4gbG9vcCB0IFtdIHRydWVcbjs7XG5cbmV4Y2VwdGlvbiBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIG9mIGludCBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXVxuICAgIChmdW5jdGlvblxuICAgICAgfCBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIGFyZzBfXzAzMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMl8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9pbnQgYXJnMF9fMDMxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxpc3QubWwuVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc1wiXG4gICAgICAgICAgOyByZXMwX18wMzJfXG4gICAgICAgICAgXVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmxldCB0cmFuc3Bvc2VfZXhuIGwgPVxuICBtYXRjaCB0cmFuc3Bvc2UgbCB3aXRoXG4gIHwgU29tZSBsIC0+IGxcbiAgfCBOb25lIC0+IHJhaXNlIChUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIChtYXAgbCB+ZjpsZW5ndGgpKVxuOztcblxubGV0IGludGVyc3BlcnNlIHQgfnNlcCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiB4IDo6IGZvbGRfcmlnaHQgeHMgfmluaXQ6W10gfmY6KGZ1biB5IGFjYyAtPiBzZXAgOjogeSA6OiBhY2MpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuXG5sZXQgaXNfc3VmZml4IGxpc3QgfnN1ZmZpeCB+ZXF1YWw6ZXF1YWxfZWx0ID1cbiAgbGV0IGxpc3RfbGVuID0gbGVuZ3RoIGxpc3QgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIGxpc3RfbGVuID49IHN1ZmZpeF9sZW4gJiYgZXF1YWwgZXF1YWxfZWx0IChkcm9wIGxpc3QgKGxpc3RfbGVuIC0gc3VmZml4X2xlbikpIHN1ZmZpeFxuOztcbiIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0luZm9dLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIGFzIG1hbnkgcGxhY2VzIGFzIHBvc3NpYmxlLiBQbGVhc2UgYXZvaWRcbiAgIGFkZGluZyBuZXcgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb19pbnRmXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG5tb2R1bGUgTWVzc2FnZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBvZiBTZXhwLnRcbiAgICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgICB8IEV4biBvZiBleG5cbiAgICB8IFNleHAgb2YgU2V4cC50XG4gICAgfCBUYWdfc2V4cCBvZiBzdHJpbmcgKiBTZXhwLnQgKiBTb3VyY2VfY29kZV9wb3NpdGlvbjAudCBvcHRpb25cbiAgICB8IFRhZ190IG9mIHN0cmluZyAqIHRcbiAgICB8IFRhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50ICogdFxuICAgIHwgT2ZfbGlzdCBvZiBpbnQgb3B0aW9uICogdCBsaXN0XG4gICAgfCBXaXRoX2JhY2t0cmFjZSBvZiB0ICogc3RyaW5nICgqIGJhY2t0cmFjZSAqKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3QgYXJnMF9fMDAxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDAyXyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ291bGRfbm90X2NvbnN0cnVjdFwiOyByZXMwX18wMDJfIF1cbiAgICAgIHwgU3RyaW5nIGFyZzBfXzAwM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlN0cmluZ1wiOyByZXMwX18wMDRfIF1cbiAgICAgIHwgRXhuIGFyZzBfXzAwNV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwNl8gPSBzZXhwX29mX2V4biBhcmcwX18wMDVfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4blwiOyByZXMwX18wMDZfIF1cbiAgICAgIHwgU2V4cCBhcmcwX18wMDdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDhfID0gU2V4cC5zZXhwX29mX3QgYXJnMF9fMDA3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZXhwXCI7IHJlczBfXzAwOF8gXVxuICAgICAgfCBUYWdfc2V4cCAoYXJnMF9fMDA5XywgYXJnMV9fMDEwXywgYXJnMl9fMDExXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDlfXG4gICAgICAgIGFuZCByZXMxX18wMTNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDEwX1xuICAgICAgICBhbmQgcmVzMl9fMDE0XyA9IHNleHBfb2Zfb3B0aW9uIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgYXJnMl9fMDExXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19zZXhwXCI7IHJlczBfXzAxMl87IHJlczFfXzAxM187IHJlczJfXzAxNF8gXVxuICAgICAgfCBUYWdfdCAoYXJnMF9fMDE1XywgYXJnMV9fMDE2XykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAxN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTVfXG4gICAgICAgIGFuZCByZXMxX18wMThfID0gc2V4cF9vZl90IGFyZzFfXzAxNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX3RcIjsgcmVzMF9fMDE3XzsgcmVzMV9fMDE4XyBdXG4gICAgICB8IFRhZ19hcmcgKGFyZzBfXzAxOV8sIGFyZzFfXzAyMF8sIGFyZzJfXzAyMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE5X1xuICAgICAgICBhbmQgcmVzMV9fMDIzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAyMF9cbiAgICAgICAgYW5kIHJlczJfXzAyNF8gPSBzZXhwX29mX3QgYXJnMl9fMDIxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19hcmdcIjsgcmVzMF9fMDIyXzsgcmVzMV9fMDIzXzsgcmVzMl9fMDI0XyBdXG4gICAgICB8IE9mX2xpc3QgKGFyZzBfXzAyNV8sIGFyZzFfXzAyNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMjdfID0gc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9pbnQgYXJnMF9fMDI1X1xuICAgICAgICBhbmQgcmVzMV9fMDI4XyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX3QgYXJnMV9fMDI2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPZl9saXN0XCI7IHJlczBfXzAyN187IHJlczFfXzAyOF8gXVxuICAgICAgfCBXaXRoX2JhY2t0cmFjZSAoYXJnMF9fMDI5XywgYXJnMV9fMDMwXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBzZXhwX29mX3QgYXJnMF9fMDI5X1xuICAgICAgICBhbmQgcmVzMV9fMDMyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzFfXzAzMF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiV2l0aF9iYWNrdHJhY2VcIjsgcmVzMF9fMDMxXzsgcmVzMV9fMDMyXyBdXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcmVjIHRvX3N0cmluZ3NfaHVtIHQgYWMgPVxuICAgICgqIFdlIHVzZSBbU2V4cC50b19zdHJpbmdfbWFjaF0sIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCB3ZSBhcmUgaW1wbGVtZW50aW5nXG4gICAgICAgW3RvX3N0cmluZ3NfaHVtXSwgYmVjYXVzZSB3ZSB3YW50IHRoZSBpbmZvIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lLCBhbmQgb25jZSB3ZSd2ZVxuICAgICAgIGhhZCB0byByZXNvcnQgdG8gc2V4cHMsIHRoZSBtZXNzYWdlIGlzIGdvaW5nIHRvIHN0YXJ0IG5vdCBsb29raW5nIHNvIHByZXR0eVxuICAgICAgIGFueXdheS4gKilcbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgc2V4cCAtPlxuICAgICAgXCJjb3VsZCBub3QgY29uc3RydWN0IGluZm86IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gU2V4cC50b19zdHJpbmdfbWFjaCAoRXhuLnNleHBfb2ZfdCBleG4pIDo6IGFjXG4gICAgfCBTZXhwIHNleHAgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBfKSAtPiB0YWcgOjogXCI6IFwiIDo6IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gdGFnIDo6IFwiOiBcIiA6OiB0b19zdHJpbmdzX2h1bSB0IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhYyBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gYm9keSBlbHNlIHRhZyA6OiBcIjogXCIgOjogYm9keVxuICAgIHwgV2l0aF9iYWNrdHJhY2UgKHQsIGJhY2t0cmFjZSkgLT5cbiAgICAgIHRvX3N0cmluZ3NfaHVtIHQgKFwiXFxuQmFja3RyYWNlOlxcblwiIDo6IGJhY2t0cmFjZSA6OiBhYylcbiAgICB8IE9mX2xpc3QgKHRydW5jX2FmdGVyLCB0cykgLT5cbiAgICAgIGxldCB0cyA9XG4gICAgICAgIG1hdGNoIHRydW5jX2FmdGVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRzXG4gICAgICAgIHwgU29tZSBtYXggLT5cbiAgICAgICAgICBsZXQgbiA9IExpc3QubGVuZ3RoIHRzIGluXG4gICAgICAgICAgaWYgbiA8PSBtYXhcbiAgICAgICAgICB0aGVuIHRzXG4gICAgICAgICAgZWxzZSBMaXN0LnRha2UgdHMgbWF4IEAgWyBTdHJpbmcgKFByaW50Zi5zcHJpbnRmIFwiYW5kICVkIG1vcmUgaW5mb1wiIChuIC0gbWF4KSkgXVxuICAgICAgaW5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPlxuICAgICAgICB0b19zdHJpbmdzX2h1bSB0IChpZiBMaXN0LmlzX2VtcHR5IGFjIHRoZW4gYWMgZWxzZSBcIjsgXCIgOjogYWMpKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IFN0cmluZy5jb25jYXQgKHRvX3N0cmluZ3NfaHVtIHQgW10pXG5cbiAgbGV0IHJlYyB0b19zZXhwc19odW0gdCBhYyA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IF8gYXMgdCAtPiBzZXhwX29mX3QgdCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBBdG9tIHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBFeG4uc2V4cF9vZl90IGV4biA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIGhlcmUpIC0+XG4gICAgICBMaXN0XG4gICAgICAgIChBdG9tIHRhZ1xuICAgICAgICAgOjogc2V4cFxuICAgICAgICAgOjpcbiAgICAgICAgIChtYXRjaCBoZXJlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgaGVyZSAtPiBbIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZSBdKSlcbiAgICAgIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiBMaXN0IChBdG9tIHRhZyA6OiB0b19zZXhwc19odW0gdCBbXSkgOjogYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gc2V4cCA6OiB0b19zZXhwc19odW0gdCBbXSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gTGlzdCBib2R5IDo6IGFjIGVsc2UgTGlzdCAoQXRvbSB0YWcgOjogYm9keSkgOjogYWNcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICBTZXhwLkxpc3QgWyB0b19zZXhwX2h1bSB0OyBTZXhwLkF0b20gYmFja3RyYWNlIF0gOjogYWNcbiAgICB8IE9mX2xpc3QgKF8sIHRzKSAtPlxuICAgICAgTGlzdC5mb2xkIChMaXN0LnJldiB0cykgfmluaXQ6YWMgfmY6KGZ1biBhYyB0IC0+IHRvX3NleHBzX2h1bSB0IGFjKVxuXG4gIGFuZCB0b19zZXhwX2h1bSB0ID1cbiAgICBtYXRjaCB0b19zZXhwc19odW0gdCBbXSB3aXRoXG4gICAgfCBbIHNleHAgXSAtPiBzZXhwXG4gICAgfCBzZXhwcyAtPiBTZXhwLkxpc3Qgc2V4cHNcbiAgOztcblxuICAoKiBXZSB1c2UgW3Byb3RlY3RdIHRvIGd1YXJkIGFnYWluc3QgZXhjZXB0aW9ucyByYWlzZWQgYnkgdXNlci1zdXBwbGllZCBmdW5jdGlvbnMsIHNvXG4gICAgIHRoYXQgZmFpbHVyZSB0byBwcm9kdWNlIG9uZSBwYXJ0IG9mIGFuIGluZm8gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCBvdGhlciBwYXJ0cy4gKilcbiAgbGV0IHByb3RlY3QgZiA9XG4gICAgdHJ5IGYgKCkgd2l0aFxuICAgIHwgZXhuIC0+IENvdWxkX25vdF9jb25zdHJ1Y3QgKEV4bi5zZXhwX29mX3QgZXhuKVxuICA7O1xuXG4gIGxldCBvZl9pbmZvIGluZm8gPSBwcm90ZWN0IChmdW4gKCkgLT4gTGF6eS5mb3JjZSBpbmZvKVxuICBsZXQgdG9faW5mbyB0ID0gbGF6eSB0XG5lbmRcblxub3BlbiBNZXNzYWdlXG5cbnR5cGUgdCA9IE1lc3NhZ2UudCBMYXp5LnRcblxubGV0IGludmFyaWFudCBfID0gKClcbmxldCB0b19tZXNzYWdlID0gTWVzc2FnZS5vZl9pbmZvXG5sZXQgb2ZfbWVzc2FnZSA9IE1lc3NhZ2UudG9faW5mb1xuXG4oKiBJdCBpcyBPSyB0byB1c2UgW01lc3NhZ2UudG9fc2V4cF9odW1dLCB3aGljaCBpcyBub3Qgc3RhYmxlLCBiZWNhdXNlIFt0X29mX3NleHBdIGJlbG93XG4gICBjYW4gaGFuZGxlIGFueSBzZXhwLiAqKVxubGV0IHNleHBfb2ZfdCB0ID0gTWVzc2FnZS50b19zZXhwX2h1bSAodG9fbWVzc2FnZSB0KVxubGV0IHRfb2Zfc2V4cCBzZXhwID0gbGF6eSAoTWVzc2FnZS5TZXhwIHNleHApXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBBbnkgXCJJbmZvLnRcIiB9XG5sZXQgY29tcGFyZSB0MSB0MiA9IFNleHAuY29tcGFyZSAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGVxdWFsIHQxIHQyID0gU2V4cC5lcXVhbCAoc2V4cF9vZl90IHQxKSAoc2V4cF9vZl90IHQyKVxubGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBTZXhwLmhhc2hfZm9sZF90IHN0YXRlIChzZXhwX29mX3QgdClcbmxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG5cbmxldCB0b19zdHJpbmdfaHVtIHQgPVxuICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICB8IFN0cmluZyBzIC0+IHNcbiAgfCBtZXNzYWdlIC0+IFNleHAudG9fc3RyaW5nX2h1bSAoTWVzc2FnZS50b19zZXhwX2h1bSBtZXNzYWdlKVxuOztcblxubGV0IHRvX3N0cmluZ19odW1fZGVwcmVjYXRlZCB0ID0gTWVzc2FnZS50b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgKHRvX21lc3NhZ2UgdClcbmxldCB0b19zdHJpbmdfbWFjaCB0ID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl90IHQpXG5sZXQgb2ZfbGF6eSBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV9zZXhwIGwgPSBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gU2V4cCAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV90IGxhenlfdCA9IExhenkuam9pbiBsYXp5X3RcbmxldCBvZl9zdHJpbmcgbWVzc2FnZSA9IExhenkuZnJvbV92YWwgKFN0cmluZyBtZXNzYWdlKVxubGV0IGNyZWF0ZWYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIG9mX3N0cmluZyBmb3JtYXRcbmxldCBvZl90aHVuayBmID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFN0cmluZyAoZiAoKSkpKVxuXG5sZXQgY3JlYXRlID9oZXJlID9zdHJpY3QgdGFnIHggc2V4cF9vZl94ID1cbiAgbWF0Y2ggc3RyaWN0IHdpdGhcbiAgfCBOb25lIC0+IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfc2V4cCAodGFnLCBzZXhwX29mX3ggeCwgaGVyZSkpKVxuICB8IFNvbWUgKCkgLT4gb2ZfbWVzc2FnZSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBMYXp5LmZyb21fdmFsIChTZXhwIHNleHApXG5sZXQgdGFnIHQgfnRhZyA9IGxhenkgKFRhZ190ICh0YWcsIHRvX21lc3NhZ2UgdCkpXG5cbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnIChcIlwiLCBMYXp5LmZvcmNlIHRhZywgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgdGFnX3MgdCB+dGFnID0gdGFnX3NfbGF6eSB0IH50YWc6KExhenkuZnJvbV92YWwgdGFnKVxuXG5sZXQgdGFnX2FyZyB0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBUYWdfYXJnICh0YWcsIHNleHBfb2ZfeCB4LCB0b19tZXNzYWdlIHQpKSlcbjs7XG5cbmxldCBvZl9saXN0ID90cnVuY19hZnRlciB0cyA9IGxhenkgKE9mX2xpc3QgKHRydW5jX2FmdGVyLCBMaXN0Lm1hcCB0cyB+Zjp0b19tZXNzYWdlKSlcblxuZXhjZXB0aW9uIEV4biBvZiB0XG5cbmxldCAoKSA9XG4gICgqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2VcbiAgICAgW2V4Y2VwdGlvbiBFeG4gb2YgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF0gLi4uIFtAQEBlbmRdXSB0byBlbGltaW5hdGUgdGhlIGV4dHJhXG4gICAgIHdyYXBwaW5nIG9mIFwiKEV4biAuLi4pXCIuICopXG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeG5dIChmdW5jdGlvblxuICAgIHwgRXhuIHQgLT4gc2V4cF9vZl90IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IHRvX2V4biB0ID1cbiAgaWYgbm90IChMYXp5LmlzX3ZhbCB0KVxuICB0aGVuIEV4biB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIExhenkuZm9yY2UgdCB3aXRoXG4gICAgfCBNZXNzYWdlLkV4biBleG4gLT4gZXhuXG4gICAgfCBfIC0+IEV4biB0KVxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9XG4gIGxldCBiYWNrdHJhY2UgPVxuICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYEdldCAtPiBTb21lIChDYW1sLlByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gICAgfCBTb21lIChgVGhpcyBzKSAtPiBTb21lIHNcbiAgaW5cbiAgbWF0Y2ggZXhuLCBiYWNrdHJhY2Ugd2l0aFxuICB8IEV4biB0LCBOb25lIC0+IHRcbiAgfCBFeG4gdCwgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKHRvX21lc3NhZ2UgdCwgYmFja3RyYWNlKSlcbiAgfCBfLCBOb25lIC0+IExhenkuZnJvbV92YWwgKE1lc3NhZ2UuRXhuIGV4bilcbiAgfCBfLCBTb21lIGJhY2t0cmFjZSAtPiBsYXp5IChXaXRoX2JhY2t0cmFjZSAoU2V4cCAoRXhuLnNleHBfb2ZfdCBleG4pLCBiYWNrdHJhY2UpKVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbmZvXCJcbiAgICBsZXQgcHAgcHBmIHQgPSBDYW1sLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmdfaHVtIHQpXG4gIGVuZClcblxubW9kdWxlIEludGVybmFsX3JlcHIgPSBNZXNzYWdlXG5cbiIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0Vycm9yXSBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIHZhcmlvdXMgcGxhY2VzLiAgUGxlYXNlIGF2b2lkIGFkZGluZyBuZXdcbiAgIGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9cblxubGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIkVycm9yLnRcIiB9XG5sZXQgcmFpc2UgdCA9IHJhaXNlICh0b19leG4gdClcbmxldCByYWlzZV9zIHNleHAgPSByYWlzZSAoY3JlYXRlX3Mgc2V4cClcbmxldCB0b19pbmZvIHQgPSB0XG5sZXQgb2ZfaW5mbyB0ID0gdFxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkVycm9yXCJcbiAgICBsZXQgcHAgPSBwcFxuICBlbmQpXG4iLCIoKiBUaGlzIGlzIGJyb2tlbiBvZmYgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFNpZ24gYW5kIENvbXBhcmFibGUuICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IE5lZ1xuICB8IFplcm9cbiAgfCBQb3NcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZV1cblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduMC5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IE5lZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBaZXJvIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBOZWc7IFplcm87IFBvcyBdIDogdCBsaXN0KVxuXG5bQEBAZW5kXVxuXG5tb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxubGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTFcbiAgfCBaZXJvIC0+IDBcbiAgfCBQb3MgLT4gMVxuOztcblxubGV0IF8gPSBoYXNoXG5cbigqIElnbm9yZSB0aGUgaGFzaCBmdW5jdGlvbiBwcm9kdWNlZCBieSBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaF0gKilcbmxldCBoYXNoID0gdG9faW50XG5sZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnblwiXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIE5lZyBlbHNlIGlmIG4gPSAwIHRoZW4gWmVybyBlbHNlIFBvc1xuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHVuaXQgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBhbGwgPSAoWyAoKSBdIDogdCBsaXN0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfdW5pdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfdW5pdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAodW5pdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl91bml0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHVuaXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgY29tcGFyZSBfIF8gPSAwXG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcIigpXCIgLT4gKClcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJCYXNlLlVuaXQub2Zfc3RyaW5nOiAoKSBleHBlY3RlZFwiXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVW5pdFwiXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG5sZXQgaW52YXJpYW50ICgpID0gKClcbiIsIigqKiBNb2R1bGUgdHlwZXMgZm9yIGEgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9uIGZvciBhIHNlcXVlbmNlLCBhbmQgZnVuY3RvcnMgZm9yIGJ1aWxkaW5nXG4gICAgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9ucy4gKilcblxub3BlbiEgSW1wb3J0XG5cbigqKiBBbiBbSW5kZXhhYmxlXSB0eXBlIGlzIGEgZmluaXRlIHNlcXVlbmNlIG9mIGVsZW1lbnRzIGluZGV4ZWQgYnkgY29uc2VjdXRpdmUgaW50ZWdlcnNcbiAgICBbMF0gLi4uIFtsZW5ndGggdCAtIDFdLiAgW2dldF0gYW5kIFtsZW5ndGhdIG11c3QgYmUgTygxKSBmb3IgdGhlIHJlc3VsdGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSB0byBiZSBsZyhuKS4gKilcbm1vZHVsZSB0eXBlIEluZGV4YWJsZSA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICB2YWwgZ2V0IDogdCAtPiBpbnQgLT4gZWx0XG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGVdXG5cbiAgbGV0IGFsbCA9XG4gICAgKFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgIDsgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYExhc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICBdXG4gICAgIDogdCBsaXN0KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdoaWNoX3RhcmdldF9ieV9zZWdtZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTGFzdF9vbl9sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGVdXG5cbiAgbGV0IGFsbCA9IChbIGBMYXN0X29uX2xlZnQ7IGBGaXJzdF9vbl9yaWdodCBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5lbmRcblxudHlwZSAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2ggPVxuICA/cG9zOmludFxuICAtPiA/bGVuOmludFxuICAtPiAndFxuICAtPiBjb21wYXJlOignZWx0IC0+ICdrZXkgLT4gaW50KVxuICAtPiBXaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgLT4gJ2tleVxuICAtPiBpbnQgb3B0aW9uXG5cbnR5cGUgKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA9XG4gID9wb3M6aW50XG4gIC0+ID9sZW46aW50XG4gIC0+ICd0XG4gIC0+IHNlZ21lbnRfb2Y6KCdlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAtPiBXaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gIC0+IGludCBvcHRpb25cblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICAoKiogU2VlIFtCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hdIGluIGJpbmFyeV9zZWFyY2gubWwgKilcbiAgdmFsIGJpbmFyeV9zZWFyY2ggOiAodCwgZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoXG5cbiAgKCoqIFNlZSBbQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gaW4gYmluYXJ5X3NlYXJjaC5tbCAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgOiAodCwgZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoIDogKCdhIHQsICdhLCAna2V5KSBiaW5hcnlfc2VhcmNoXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA6ICgnYSB0LCAnYSkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCaW5hcnlfc2VhcmNoYWJsZSA9IHNpZ1xuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gIG1vZHVsZSB0eXBlIEluZGV4YWJsZSA9IEluZGV4YWJsZVxuICBtb2R1bGUgdHlwZSBJbmRleGFibGUxID0gSW5kZXhhYmxlMVxuXG4gIG1vZHVsZSBXaGljaF90YXJnZXRfYnlfa2V5ID0gV2hpY2hfdGFyZ2V0X2J5X2tleVxuICBtb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQgPSBXaGljaF90YXJnZXRfYnlfc2VnbWVudFxuXG4gIHR5cGUgbm9ucmVjICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaCA9ICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuICB0eXBlIG5vbnJlYyAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID0gKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuXG4gIG1vZHVsZSBNYWtlIChUIDogSW5kZXhhYmxlKSA6IFMgd2l0aCB0eXBlIHQgOj0gVC50IHdpdGggdHlwZSBlbHQgOj0gVC5lbHRcbiAgbW9kdWxlIE1ha2UxIChUIDogSW5kZXhhYmxlMSkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuIENvbnRhaW5lcl9pbnRmLkV4cG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgTGlzdCA9IExpc3QxXG5cbm1vZHVsZSBTdGVwID0gc3RydWN0XG4gICgqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZlxuICAgICB0aGUgc2VxdWVuY2UgKilcbiAgdHlwZSAoJ2EsICdzKSB0ID1cbiAgICB8IERvbmVcbiAgICB8IFNraXAgb2YgJ3NcbiAgICB8IFlpZWxkIG9mICdhICogJ3NcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2EgJ3MuXG4gICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ3MpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzAwOV8gc19fMDEwXylcbiAgICAgICAgOiAgKChhX18wMDlfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKHNfXzAxMF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgICAgLT4gKGFfXzAwOV8sIHNfXzAxMF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgICAgZnVuIF9vZl9hX18wMDFfIF9vZl9zX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgRG9uZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEb25lXCJcbiAgICAgICAgfCBTa2lwIGFyZzBfXzAwM18gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDA0XyA9IF9vZl9zX18wMDJfIGFyZzBfXzAwM18gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTa2lwXCI7IHJlczBfXzAwNF8gXVxuICAgICAgICB8IFlpZWxkIChhcmcwX18wMDVfLCBhcmcxX18wMDZfKSAtPlxuICAgICAgICAgIGxldCByZXMwX18wMDdfID0gX29mX2FfXzAwMV8gYXJnMF9fMDA1X1xuICAgICAgICAgIGFuZCByZXMxX18wMDhfID0gX29mX3NfXzAwMl8gYXJnMV9fMDA2XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIllpZWxkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxub3BlbiBTdGVwXG5cbigqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIHNlcXVlbmNlICopXG50eXBlICtfIHQgPSBTZXF1ZW5jZSA6ICdzICogKCdzIC0+ICgnYSwgJ3MpIFN0ZXAudCkgLT4gJ2EgdFxudHlwZSAnYSBzZXF1ZW5jZSA9ICdhIHRcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgbmV4dF9zdGVwIChTZXF1ZW5jZSAocywgZikpID1cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIGYpKVxuICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBTZXF1ZW5jZSAocywgZikpXG4gIDs7XG5cbiAgbGV0IGRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBsb29wIHMgbmV4dCBmaW5pc2ggZiBhY2MgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgICB8IFNraXAgcyAtPiBmIGFjYyBOb25lIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGYgYWNjIChTb21lIGEpIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGZpbmlzaCBmIGluaXRcbiAgOztcbmVuZFxuXG5sZXQgdW5mb2xkX3N0ZXAgfmluaXQgfmYgPSBTZXF1ZW5jZSAoaW5pdCwgZilcblxubGV0IHVuZm9sZCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOihmdW4gcyAtPlxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBOb25lIC0+IFN0ZXAuRG9uZVxuICAgIHwgU29tZSAoYSwgcykgLT4gU3RlcC5ZaWVsZCAoYSwgcykpXG47O1xuXG5sZXQgdW5mb2xkX3dpdGggcyB+aW5pdCB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIChpbml0LCBzKVxuICAgICAgLCBmdW4gKHNlZWQsIHMpIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKHNlZWQsIHMpXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAgICAgKG1hdGNoIGYgc2VlZCBhIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHNlZWQgLT4gU2tpcCAoc2VlZCwgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgc2VlZCkgLT4gWWllbGQgKGEsIChzZWVkLCBzKSkpIClcbjs7XG5cbmxldCB1bmZvbGRfd2l0aF9hbmRfZmluaXNoIHMgfmluaXQgfnJ1bm5pbmdfc3RlcCB+aW5uZXJfZmluaXNoZWQgfmZpbmlzaGluZ19zdGVwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYElubmVyX3J1bm5pbmcgKGluaXQsIHMpXG4gICAgICAsIGZ1biBzdGF0ZSAtPlxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBpbm5lcl9zdGF0ZSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIChgSW5uZXJfZmluaXNoZWQgKGlubmVyX2ZpbmlzaGVkIHN0YXRlKSlcbiAgICAgICAgICAgfCBTa2lwIGlubmVyX3N0YXRlIC0+IFNraXAgKGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKVxuICAgICAgICAgICB8IFlpZWxkICh4LCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAgICAobWF0Y2ggcnVubmluZ19zdGVwIHN0YXRlIHggd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgc3RhdGUgLT4gU2tpcCAoYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkpXG4gICAgICAgICAgICAgIHwgWWllbGQgKHksIHN0YXRlKSAtPiBZaWVsZCAoeSwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkpKSlcbiAgICAgICAgfCBgSW5uZXJfZmluaXNoZWQgc3RhdGUgLT5cbiAgICAgICAgICAobWF0Y2ggZmluaXNoaW5nX3N0ZXAgc3RhdGUgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgc3RhdGUgLT4gU2tpcCAoYElubmVyX2ZpbmlzaGVkIHN0YXRlKVxuICAgICAgICAgICB8IFlpZWxkICh5LCBzdGF0ZSkgLT4gWWllbGQgKHksIGBJbm5lcl9maW5pc2hlZCBzdGF0ZSkpIClcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpsIH5mOihmdW5jdGlvblxuICAgIHwgW10gLT4gRG9uZVxuICAgIHwgeCA6OiBsIC0+IFlpZWxkICh4LCBsKSlcbjs7XG5cblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIHYgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiB2XG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIHYgbmV4dCBmXG4gICAgfCBZaWVsZCAoYSwgcykgLT4gbG9vcCBzIChmIHYgYSkgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgaW5pdCBuZXh0IGZcbjs7XG5cbmxldCB0b19saXN0X3JldiB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbClcblxuXG5sZXQgdG9fbGlzdCAoU2VxdWVuY2UgKHMsIG5leHQpKSA9XG4gIGxldCBzYWZlX3RvX2xpc3QgdCA9IExpc3QucmV2ICh0b19saXN0X3JldiB0KSBpblxuICBsZXQgcmVjIHRvX2xpc3QgcyBuZXh0IGkgPVxuICAgIGlmIGkgPSAwXG4gICAgdGhlbiBzYWZlX3RvX2xpc3QgKFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gW11cbiAgICAgIHwgU2tpcCBzIC0+IHRvX2xpc3QgcyBuZXh0IGlcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGEgOjogdG9fbGlzdCBzIG5leHQgKGkgLSAxKSlcbiAgaW5cbiAgdG9fbGlzdCBzIG5leHQgNTAwXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfdiBzdG9wX3YgPVxuICBsZXQgc3RlcCA9XG4gICAgbWF0Y2ggc3RvcCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPiBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gICAgfCBgaW5jbHVzaXZlIC0+IGZ1biBpIC0+IGlmIGkgPCBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gICAgfCBgZXhjbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPj0gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBmdW4gaSAtPiBpZiBpIDw9IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgaW5cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfdlxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBzdGFydF92ICsgc3RyaWRlXG4gIGluXG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOnN0ZXBcbjs7XG5cbmxldCBvZl9sYXp5IHRfbGF6eSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnRfbGF6eSB+ZjooZnVuIHRfbGF6eSAtPlxuICAgIGxldCAoU2VxdWVuY2UgKHMsIG5leHQpKSA9IExhenkuZm9yY2UgdF9sYXp5IGluXG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+XG4gICAgICBTa2lwXG4gICAgICAgIChsZXQgdiA9IFNlcXVlbmNlIChzLCBuZXh0KSBpblxuICAgICAgICAgbGF6eSB2KVxuICAgIHwgWWllbGQgKHgsIHMpIC0+XG4gICAgICBZaWVsZFxuICAgICAgICAoIHhcbiAgICAgICAgLCBsZXQgdiA9IFNlcXVlbmNlIChzLCBuZXh0KSBpblxuICAgICAgICAgIGxhenkgdiApKVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc2VlZFxuICAgICAgLCBmdW4gc2VlZCAtPlxuICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGYgYSwgcykgKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChmIGkgYSwgKGkgKyAxLCBzKSkgKVxuOztcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICB1bmZvbGRfd2l0aCB0IH5pbml0IH5mOihmdW4gYWNjIHggLT5cbiAgICBsZXQgYWNjLCB4ID0gZiBhY2MgeCBpblxuICAgIFlpZWxkICh4LCBhY2MpKVxuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgaSBhY2MgeCBpblxuICAgIFlpZWxkICh4LCAoaSArIDEsIGFjYykpKVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc2VlZFxuICAgICAgLCBmdW4gc2VlZCAtPlxuICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gWWllbGQgKGEsIHMpXG4gICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IFNraXAgcyApXG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbWFwIH5mOnNuZCAoZmlsdGVyIChtYXBpIHQgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKSlcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gaVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgaSBzIG5leHRcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIChpICsgMSkgcyBuZXh0XG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIDAgc2VlZCBuZXh0XG47O1xuXG5sZXQgdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCA9IGZvbGQgdCB+aW5pdDooW10sIDApIH5mOihmdW4gKGwsIGkpIHggLT4geCA6OiBsLCBpICsgMSlcblxubGV0IHRvX2FycmF5IHQgPVxuICBsZXQgbCwgbGVuID0gdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCBpblxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgeCA6OiBsIC0+XG4gICAgbGV0IGEgPSBBcnJheS5jcmVhdGUgfmxlbiB4IGluXG4gICAgbGV0IHJlYyBsb29wIGkgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gLTEpXG4gICAgICB8IHggOjogbCAtPlxuICAgICAgICBhLihpKSA8LSB4O1xuICAgICAgICBsb29wIChpIC0gMSkgbFxuICAgIGluXG4gICAgbG9vcCAobGVuIC0gMikgbDtcbiAgICBhXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGEgLT4gU29tZSBhXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGYgYSB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgcyBuZXh0IGZcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggZiBpIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIG5vdCAoZiBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIG5vdCAoZiBpIGEpIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBpIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHNlZWQgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiAoKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgZiBhO1xuICAgICAgbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIF8gLT4gZmFsc2VcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGEgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYiwgXykgd2hlbiBlcXVhbCBhIGIgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGFcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGFcbjs7XG5cbmxldCBlbXB0eSA9IFNlcXVlbmNlICgoKSwgZnVuICgpIC0+IERvbmUpXG5cbmxldCBiaW5kIHQgfmYgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCksIHJlc3QgLT5cbiAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICB8IERvbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoZW1wdHksIFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgICAgICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFNraXAgKGYgYSwgU2VxdWVuY2UgKHMsIG5leHQpKSkpXG4gICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChTZXF1ZW5jZSAocywgbmV4dCksIHJlc3QpXG4gICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgKFNlcXVlbmNlIChzLCBuZXh0KSwgcmVzdCkpKSlcbiAgICB+aW5pdDooZW1wdHksIHQpXG47O1xuXG5sZXQgcmV0dXJuIHggPVxuICB1bmZvbGRfc3RlcCB+aW5pdDooU29tZSB4KSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gRG9uZVxuICAgIHwgU29tZSB4IC0+IFlpZWxkICh4LCBOb25lKSlcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgZW5kKVxuXG5sZXQgbnRoIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBOb25lXG4gICAgICB8IFNraXAgcyAtPiBsb29wIGkgcyBuZXh0XG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBpZiBwaHlzX2VxdWFsIGkgMCB0aGVuIFNvbWUgYSBlbHNlIGxvb3AgKGkgLSAxKSBzIG5leHRcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgbiBzIG5leHQpXG47O1xuXG5sZXQgbnRoX2V4biBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UubnRoXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggbnRoIHMgbiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UubnRoXCJcbiAgICB8IFNvbWUgeCAtPiB4KVxuOztcblxubW9kdWxlIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBMZWZ0IG9mICdhXG4gICAgfCBSaWdodCBvZiAnYlxuICAgIHwgQm90aCBvZiAnYSAqICdiXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDExXyBiX18wMTJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTFfLCBiX18wMTJfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDEzXywgTGVmdCBfYl9fMDE0XyAtPiBfY21wX19hIF9hX18wMTNfIF9iX18wMTRfXG4gICAgICB8IExlZnQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gMVxuICAgICAgfCBSaWdodCBfYV9fMDE1XywgUmlnaHQgX2JfXzAxNl8gLT4gX2NtcF9fYiBfYV9fMDE1XyBfYl9fMDE2X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gMVxuICAgICAgfCBCb3RoIChfYV9fMDE3XywgX2FfXzAxOV8pLCBCb3RoIChfYl9fMDE4XywgX2JfXzAyMF8pIC0+XG4gICAgICAgIChtYXRjaCBfY21wX19hIF9hX18wMTdfIF9iX18wMThfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19iIF9hX18wMTlfIF9iX18wMjBfXG4gICAgICAgICB8IG4gLT4gbikpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90XG4gICAgOiB0eXBlIGEgYi5cbiAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAtPiAoYSwgYikgdFxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICB8IExlZnQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgfCBSaWdodCBfYTAgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG4gICAgICB8IEJvdGggKF9hMCwgX2ExKSAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyIGluXG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgICBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICdhICdiLlxuICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNDRfIGJfXzA0NV8pXG4gICAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzA0NF8pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDQ1XylcbiAgICAgICAgICAgIC0+IFNleHBsaWIwLlNleHAudCAtPiAoYV9fMDQ0XywgYl9fMDQ1XykgdCkgLT5cbiAgICAgIGxldCBlcnJvcl9zb3VyY2VfXzAyNV8gPSBcInNlcXVlbmNlLm1sLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnRcIiBpblxuICAgICAgZnVuIF9vZl9hX18wMjFfIF9vZl9iX18wMjJfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgX3RhZ19fMDI4XykgOjogc2V4cF9hcmdzX18wMjlfKSBhc1xuICAgICAgICAgIF9zZXhwX18wMjdfIC0+XG4gICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDI5XyB3aXRoXG4gICAgICAgICAgIHwgWyBhcmcwX18wMzBfIF0gLT5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDMxXyA9IF9vZl9hX18wMjFfIGFyZzBfXzAzMF8gaW5cbiAgICAgICAgICAgICBMZWZ0IHJlczBfXzAzMV9cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMjhfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDI3XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIF90YWdfXzAzM18pIDo6IHNleHBfYXJnc19fMDM0XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDMyXyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAzNF8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDM1XyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzNl8gPSBfb2ZfYl9fMDIyXyBhcmcwX18wMzVfIGluXG4gICAgICAgICAgICAgUmlnaHQgcmVzMF9fMDM2X1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyNV9cbiAgICAgICAgICAgICAgIF90YWdfXzAzM19cbiAgICAgICAgICAgICAgIF9zZXhwX18wMzJfKVxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIF90YWdfXzAzOF8pIDo6IHNleHBfYXJnc19fMDM5XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDM3XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAzOV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDQwXzsgYXJnMV9fMDQxXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzA0Ml8gPSBfb2ZfYV9fMDIxXyBhcmcwX18wNDBfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzA0M18gPSBfb2ZfYl9fMDIyXyBhcmcxX18wNDFfIGluXG4gICAgICAgICAgICAgQm90aCAocmVzMF9fMDQyXywgcmVzMV9fMDQzXylcbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMzhfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDM3XylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjZfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjZfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI0X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMjRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgICAgICAgfCBzZXhwX18wMjRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI0X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdiLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNTZfIGJfXzA1N18pXG4gICAgICAgIDogICgoYV9fMDU2XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wNTdfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wNTZfLCBiX18wNTdfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDQ2XyBfb2ZfYl9fMDQ3XyAtPiBmdW5jdGlvblxuICAgICAgICB8IExlZnQgYXJnMF9fMDQ4XyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNDlfID0gX29mX2FfXzA0Nl8gYXJnMF9fMDQ4XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgcmVzMF9fMDQ5XyBdXG4gICAgICAgIHwgUmlnaHQgYXJnMF9fMDUwXyAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTFfID0gX29mX2JfXzA0N18gYXJnMF9fMDUwXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IHJlczBfXzA1MV8gXVxuICAgICAgICB8IEJvdGggKGFyZzBfXzA1Ml8sIGFyZzFfXzA1M18pIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzA1NF8gPSBfb2ZfYV9fMDQ2XyBhcmcwX18wNTJfXG4gICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2ZfYl9fMDQ3XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiOyByZXMwX18wNTRfOyByZXMxX18wNTVfIF1cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgIFZhcmlhbnRcbiAgICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkJvdGhcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5sZXQgbWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSB+Y29tcGFyZSA9XG4gIGxldCB1bnNoYWRvd2VkX2NvbXBhcmUgPSBjb21wYXJlIGluXG4gIGxldCBvcGVuIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50IGluXG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgICB8IChZaWVsZCAoYSwgczEnKSBhcyBzMSksIChZaWVsZCAoYiwgczInKSBhcyBzMikgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gdW5zaGFkb3dlZF9jb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8IDBcbiAgICAgIHRoZW4gWWllbGQgKExlZnQgYSwgKFNraXAgczEnLCBzMikpXG4gICAgICBlbHNlIGlmIGNvbXBhcmlzb24gPSAwXG4gICAgICB0aGVuIFlpZWxkIChCb3RoIChhLCBiKSwgKFNraXAgczEnLCBTa2lwIHMyJykpXG4gICAgICBlbHNlIFlpZWxkIChSaWdodCBiLCAoczEsIFNraXAgczInKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoTGVmdCBhLCAoU2tpcCBzMSwgRG9uZSkpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChSaWdodCBiLCAoRG9uZSwgU2tpcCBzMikpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgbWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIHMxIHMyIH5jb21wYXJlID1cbiAgbWFwIChtZXJnZV93aXRoX2R1cGxpY2F0ZXMgczEgczIgfmNvbXBhcmUpIH5mOihmdW5jdGlvblxuICAgIHwgTGVmdCB4IHwgUmlnaHQgeCB8IEJvdGggKHgsIF8pIC0+IHgpXG47O1xuXG5sZXQgKG1lcmdlIFtAZGVwcmVjYXRlZFxuICAgICAgIFwiW3NpbmNlIDIwMjEtMDddIEZvciBpZGVudGljYWwgYmVoYXZpb3IsIHVzZSBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkXSwgYnV0IGNvbnNpZGVyIHVzaW5nIFxcXG4gICAgICAgIFtTZXF1ZW5jZS5tZXJnZV9zb3J0ZWRdIGluc3RlYWQuXCJdKVxuICA9XG4gIG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZFxuOztcblxubGV0IG1lcmdlX3NvcnRlZCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgfmNvbXBhcmUgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCAoWWllbGQgKGEsIHMxJykgYXMgczEpLCAoWWllbGQgKGIsIHMyJykgYXMgczIpIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IGNvbXBhcmUgYSBiIGluXG4gICAgICBpZiBjb21wYXJpc29uIDw9IDAgdGhlbiBZaWVsZCAoYSwgKFNraXAgczEnLCBzMikpIGVsc2UgWWllbGQgKGIsIChzMSwgU2tpcCBzMicpKVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChhLCAoU2tpcCBzMSwgRG9uZSkpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChiLCAoRG9uZSwgU2tpcCBzMikpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgaGQgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgKGEsIF8pIC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBoZF9leG4gcyA9XG4gIG1hdGNoIGhkIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJoZF9leG5cIlxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdGwgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgKF8sIGEpIC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICAobWF0Y2ggbG9vcCBzIG5leHQgd2l0aFxuICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB8IFNvbWUgcyAtPiBTb21lIChTZXF1ZW5jZSAocywgbmV4dCkpKVxuOztcblxubGV0IHRsX2VhZ2VybHlfZXhuIHMgPVxuICBtYXRjaCB0bCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UudGxfZXhuXCJcbiAgfCBTb21lIHMgLT4gc1xuOztcblxubGV0IGxpZnRfaWRlbnRpdHkgbmV4dCBzID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBEb25lIC0+IERvbmVcbiAgfCBTa2lwIHMgLT4gU2tpcCAoYElkZW50aXR5IHMpXG4gIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgSWRlbnRpdHkgcylcbjs7XG5cbmxldCBuZXh0IHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBTb21lIChhLCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dFxuOztcblxubGV0IGZpbHRlcl9vcHQgcyA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNcbiAgICAgICwgZnVuIHMgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKE5vbmUsIHMpIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChTb21lIGEsIHMpIC0+IFlpZWxkIChhLCBzKSApXG47O1xuXG5sZXQgZmlsdGVyX21hcCBzIH5mID0gZmlsdGVyX29wdCAobWFwIHMgfmYpXG5sZXQgZmlsdGVyX21hcGkgcyB+ZiA9IGZpbHRlcl9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBzcGxpdF9uIHMgbiA9XG4gIGxldCByZWMgbG9vcCBzIGkgYWNjdW0gbmV4dCA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiBMaXN0LnJldiBhY2N1bSwgU2VxdWVuY2UgKHMsIG5leHQpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IExpc3QucmV2IGFjY3VtLCBlbXB0eVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBzIGkgYWNjdW0gbmV4dFxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gbG9vcCBzIChpIC0gMSkgKGEgOjogYWNjdW0pIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbiBbXSBuZXh0XG47O1xuXG5sZXQgY2h1bmtzX2V4biB0IG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmNodW5rc19leG5cIlxuICBlbHNlXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQ6dCB+ZjooZnVuIHQgLT5cbiAgICAgIG1hdGNoIHNwbGl0X24gdCBuIHdpdGhcbiAgICAgIHwgW10sIF9lbXB0eSAtPiBEb25lXG4gICAgICB8IChfIDo6IF8gYXMgeHMpLCB0IC0+IFlpZWxkICh4cywgdCkpXG47O1xuXG5sZXQgZmluZGkgcyB+ZiA9IGZpbmQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBmaW5kX2V4biBzIH5mID1cbiAgbWF0Y2ggZmluZCBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UuZmluZF9leG5cIlxuICB8IFNvbWUgeCAtPiB4XG47O1xuXG5sZXQgYXBwZW5kIHMxIHMyID1cbiAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgfCBTZXF1ZW5jZSAoczEsIG5leHQxKSwgU2VxdWVuY2UgKHMyLCBuZXh0MikgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgRmlyc3RfbGlzdCBzMVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBGaXJzdF9saXN0IHMxIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQxIHMxIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IFNraXAgKGBTZWNvbmRfbGlzdCBzMilcbiAgICAgICAgICAgfCBTa2lwIHMxIC0+IFNraXAgKGBGaXJzdF9saXN0IHMxKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzMSkgLT4gWWllbGQgKGEsIGBGaXJzdF9saXN0IHMxKSlcbiAgICAgICAgfCBgU2Vjb25kX2xpc3QgczIgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dDIgczIgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgczIgLT4gU2tpcCAoYFNlY29uZF9saXN0IHMyKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzMikgLT4gWWllbGQgKGEsIGBTZWNvbmRfbGlzdCBzMikpIClcbjs7XG5cbmxldCBjb25jYXRfbWFwIHMgfmYgPSBiaW5kIHMgfmZcbmxldCBjb25jYXQgcyA9IGNvbmNhdF9tYXAgcyB+ZjpGbi5pZFxubGV0IGNvbmNhdF9tYXBpIHMgfmYgPSBjb25jYXRfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgemlwIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIChhLCBzMSksIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKChhLCBiKSwgKFNraXAgczEsIFNraXAgczIpKVxuICAgIHwgRG9uZSwgXyB8IF8sIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IHppcF9mdWxsIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIChhLCBzMSksIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKGBCb3RoIChhLCBiKSwgKFNraXAgczEsIFNraXAgczIpKVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCBEb25lLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChgUmlnaHQgYiwgKERvbmUsIG5leHQyIHMyKSlcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKGBMZWZ0IGEsIChuZXh0MSBzMSwgRG9uZSkpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgYm91bmRlZF9sZW5ndGggKFNlcXVlbmNlIChzZWVkLCBuZXh0KSkgfmF0X21vc3QgPVxuICBsZXQgcmVjIGxvb3AgaSBzZWVkIG5leHQgPVxuICAgIGlmIGkgPiBhdF9tb3N0XG4gICAgdGhlbiBgR3JlYXRlclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBgSXMgaVxuICAgICAgfCBTa2lwIHNlZWQgLT4gbG9vcCBpIHNlZWQgbmV4dFxuICAgICAgfCBZaWVsZCAoXywgc2VlZCkgLT4gbG9vcCAoaSArIDEpIHNlZWQgbmV4dClcbiAgaW5cbiAgbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IGxlbmd0aF9pc19ib3VuZGVkX2J5ID8obWluID0gLTEpID9tYXggdCA9XG4gIGxldCBsZW5ndGhfaXNfYXRfbGVhc3QgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICAgIGxldCByZWMgbG9vcCBzIGFjYyA9XG4gICAgICBpZiBhY2MgPj0gbWluXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gZmFsc2VcbiAgICAgICAgfCBTa2lwIHMgLT4gbG9vcCBzIGFjY1xuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgKGFjYyArIDEpKVxuICAgIGluXG4gICAgbG9vcCBzIDBcbiAgaW5cbiAgbWF0Y2ggbWF4IHdpdGhcbiAgfCBOb25lIC0+IGxlbmd0aF9pc19hdF9sZWFzdCB0XG4gIHwgU29tZSBtYXggLT5cbiAgICAobWF0Y2ggYm91bmRlZF9sZW5ndGggdCB+YXRfbW9zdDptYXggd2l0aFxuICAgICB8IGBJcyBsZW4gd2hlbiBsZW4gPj0gbWluIC0+IHRydWVcbiAgICAgfCBfIC0+IGZhbHNlKVxuOztcblxubGV0IGl0ZXJpIHMgfmYgPSBpdGVyIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgZm9sZGkgcyB+aW5pdCB+ZiA9XG4gIGZvbGQgfmluaXQgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biBhY2MgKGksIHMpIC0+IGYgaSBhY2Mgcylcbjs7XG5cbmxldCByZWR1Y2UgcyB+ZiA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoYSwgcykgLT4gU29tZSAoZm9sZCBzIH5pbml0OmEgfmYpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBzIH5mID1cbiAgbWF0Y2ggcmVkdWNlIHMgfmYgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHJlcyAtPiByZXNcbjs7XG5cbmxldCBncm91cCAoU2VxdWVuY2UgKHMsIG5leHQpKSB+YnJlYWsgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5pbml0OihTb21lIChbXSwgcykpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gRG9uZVxuICAgICAgfCBTb21lIChhY2MsIHMpIC0+XG4gICAgICAgIChtYXRjaCBhY2MsIG5leHQgcyB3aXRoXG4gICAgICAgICB8IF8sIFNraXAgcyAtPiBTa2lwIChTb21lIChhY2MsIHMpKVxuICAgICAgICAgfCBbXSwgRG9uZSAtPiBEb25lXG4gICAgICAgICB8IGFjYywgRG9uZSAtPiBZaWVsZCAoTGlzdC5yZXYgYWNjLCBOb25lKVxuICAgICAgICAgfCBbXSwgWWllbGQgKGN1ciwgcykgLT4gU2tpcCAoU29tZSAoWyBjdXIgXSwgcykpXG4gICAgICAgICB8IChwcmV2IDo6IF8gYXMgYWNjKSwgWWllbGQgKGN1ciwgcykgLT5cbiAgICAgICAgICAgaWYgYnJlYWsgcHJldiBjdXJcbiAgICAgICAgICAgdGhlbiBZaWVsZCAoTGlzdC5yZXYgYWNjLCBTb21lIChbIGN1ciBdLCBzKSlcbiAgICAgICAgICAgZWxzZSBTa2lwIChTb21lIChjdXIgOjogYWNjLCBzKSkpKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIChTZXF1ZW5jZSAocywgbmV4dCkpIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBsYXN0X2VsdCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBsYXN0X2VsdCBzXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBsYXN0X2VsdCB3aXRoXG4gICAgICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU29tZSAoYiwgYSlcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gbG9vcCAoU29tZSBhKSBzKVxuICBpblxuICBsb29wIE5vbmUgc1xuOztcblxubGV0IHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIHMgfmVxdWFsID1cbiAgdW5mb2xkX3dpdGggcyB+aW5pdDpOb25lIH5mOihmdW4gcHJldiBhIC0+XG4gICAgbWF0Y2ggcHJldiB3aXRoXG4gICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU2tpcCAoU29tZSBhKVxuICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBZaWVsZCAoYSwgU29tZSBhKSlcbjs7XG5cbmxldCBjb3VudCBzIH5mID0gbGVuZ3RoIChmaWx0ZXIgcyB+ZilcbmxldCBjb3VudGkgdCB+ZiA9IGxlbmd0aCAoZmlsdGVyaSB0IH5mKVxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBpbml0IG4gfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gaSAtPiBpZiBpID49IG4gdGhlbiBEb25lIGVsc2UgWWllbGQgKGYgaSwgaSArIDEpKVxuOztcblxubGV0IHN1YiBzIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2Uuc3ViXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIGlmIGkgLSBwb3MgPj0gbGVuXG4gICAgICAgIHRoZW4gRG9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGkgPj0gcG9zIC0+IFlpZWxkIChhLCAoaSArIDEsIHMpKVxuICAgICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IFNraXAgKGkgKyAxLCBzKSkgKVxuOztcblxubGV0IHRha2UgcyBsZW4gPVxuICBpZiBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS50YWtlXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIGlmIGkgPj0gbGVuXG4gICAgICAgIHRoZW4gRG9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSkpIClcbjs7XG5cbmxldCBkcm9wIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UuZHJvcFwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGkgPj0gbGVuIC0+IFlpZWxkIChhLCAoaSArIDEsIHMpKVxuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIChpICsgMSwgcykgKVxuOztcblxubGV0IHRha2Vfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNcbiAgICAgICwgZnVuIHMgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFlpZWxkIChhLCBzKVxuICAgICAgICB8IFlpZWxkIChfLCBfKSAtPiBEb25lIClcbjs7XG5cbmxldCBkcm9wX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgRHJvcHBpbmcgc1xuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBEcm9wcGluZyBzIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGBEcm9wcGluZyBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBTa2lwIChgRHJvcHBpbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBJZGVudGl0eSBzKSlcbiAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcyApXG47O1xuXG5sZXQgc2hpZnRfcmlnaHQgcyB4ID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYENvbnNpbmcgKHNlZWQsIHgpXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYENvbnNpbmcgKHNlZWQsIHgpIC0+IFlpZWxkICh4LCBgSWRlbnRpdHkgc2VlZClcbiAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcyApXG47O1xuXG5sZXQgc2hpZnRfcmlnaHRfd2l0aF9saXN0IHMgbCA9IGFwcGVuZCAob2ZfbGlzdCBsKSBzXG5sZXQgc2hpZnRfbGVmdCA9IGRyb3BcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoIEAgKSA9IGFwcGVuZFxuZW5kXG5cbmxldCBpbnRlcnNwZXJzZSBzIH5zZXAgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgSW5pdCBzXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYEluaXQgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgSW5pdCBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYFJ1bm5pbmcgcykpXG4gICAgICAgIHwgYFJ1bm5pbmcgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgUnVubmluZyBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoc2VwLCBgUHV0dGluZyAoYSwgcykpKVxuICAgICAgICB8IGBQdXR0aW5nIChhLCBzKSAtPiBZaWVsZCAoYSwgYFJ1bm5pbmcgcykgKVxuOztcblxubGV0IHJlcGVhdCB4ID0gdW5mb2xkX3N0ZXAgfmluaXQ6eCB+ZjooZnVuIHggLT4gWWllbGQgKHgsIHgpKVxuXG5sZXQgY3ljbGVfbGlzdF9leG4geHMgPVxuICBpZiBMaXN0LmlzX2VtcHR5IHhzIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jeWNsZV9saXN0X2V4blwiO1xuICBsZXQgcyA9IG9mX2xpc3QgeHMgaW5cbiAgY29uY2F0X21hcCB+ZjooZnVuICgpIC0+IHMpIChyZXBlYXQgKCkpXG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3Qgc2Egc2IgPSBjb25jYXRfbWFwIHNhIH5mOihmdW4gYSAtPiB6aXAgKHJlcGVhdCBhKSBzYilcbmxldCBzaW5nbGV0b24geCA9IHJldHVybiB4XG5cbmxldCBkZWxheWVkX2ZvbGQgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmZpbmlzaCB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgIHwgTm9uZSAtPiBrIGFjY1xuICAgIHwgU29tZSBhIC0+IGYgYWNjIGEgfmspXG47O1xuXG5sZXQgZm9sZF9tIH5iaW5kIH5yZXR1cm4gdCB+aW5pdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdFxuICAgIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gYWNjKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGFjYyBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgaXRlcl9tIH5iaW5kIH5yZXR1cm4gdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdDooKVxuICAgIH5mOihmdW4gKCkgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiAoKSkgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgZm9sZF91bnRpbCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKCdhLCAnYikgQ29udGludWVfb3Jfc3RvcC50KSB3aXRoXG4gICAgICAgfCBTdG9wIHggLT4geFxuICAgICAgIHwgQ29udGludWUgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgcyB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IFJlc3VsdC5yZXR1cm4gYWNjXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKF8sIF8pIFJlc3VsdC50KSB3aXRoXG4gICAgICAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICAgICAgIHwgT2sgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHQgZiBpbml0XG47O1xuXG5sZXQgZm9yY2VfZWFnZXJseSB0ID0gb2ZfbGlzdCAodG9fbGlzdCB0KVxuXG5sZXQgbWVtb2l6ZSAodHlwZSBhKSAoU2VxdWVuY2UgKHMsIG5leHQpKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQgb2YgKGEsIHQpIFN0ZXAudCBMYXp5LnRcbiAgZW5kXG4gIGluXG4gIGxldCByZWMgbWVtb2l6ZSBzID0gTS5UIChsYXp5IChmaW5kX3N0ZXAgcykpXG4gIGFuZCBmaW5kX3N0ZXAgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+IGZpbmRfc3RlcCBzXG4gICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIG1lbW9pemUgcylcbiAgaW5cbiAgU2VxdWVuY2UgKG1lbW9pemUgcywgZnVuIChNLlQgbCkgLT4gTGF6eS5mb3JjZSBsKVxuOztcblxubGV0IGRyb3BfZWFnZXJseSBzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpIH5sZW4gcyBuZXh0ID1cbiAgICBpZiBpID49IGxlblxuICAgIHRoZW4gU2VxdWVuY2UgKHMsIG5leHQpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGVtcHR5XG4gICAgICB8IFNraXAgcyAtPiBsb29wIGkgfmxlbiBzIG5leHRcbiAgICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgKGkgKyAxKSB+bGVuIHMgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgMCB+bGVuIHMgbmV4dFxuOztcblxubGV0IGRyb3Bfd2hpbGVfb3B0aW9uIChTZXF1ZW5jZSAocywgbmV4dCkpIH5mID1cbiAgbGV0IHJlYyBsb29wIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHNcbiAgICB8IFlpZWxkICh4LCBzKSAtPiBpZiBmIHggdGhlbiBsb29wIHMgZWxzZSBTb21lICh4LCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gIGluXG4gIGxvb3Agc1xuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIHQxIHQyID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgICAgfCBgTGVmdCBfIC0+IHIucmV0dXJuIDFcbiAgICAgIHwgYFJpZ2h0IF8gLT4gci5yZXR1cm4gKC0xKVxuICAgICAgfCBgQm90aCAodjEsIHYyKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfYSB2MSB2MiBpblxuICAgICAgICBpZiBjIDw+IDAgdGhlbiByLnJldHVybiBjKTtcbiAgICAwKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPVxuICBmb3JfYWxsICh6aXBfZnVsbCB0MSB0MikgfmY6KGZ1bmN0aW9uXG4gICAgfCBgQm90aCAoYTEsIGEyKSAtPiBlcXVhbF9hIGExIGEyXG4gICAgfCBgTGVmdCBfIHwgYFJpZ2h0IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgcm91bmRfcm9iaW4gbGlzdCA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSAocywgZikgOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYgcyB3aXRoXG4gICAgICAgfCBZaWVsZCAoeCwgcykgLT4gWWllbGQgKHgsICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAocywgZikgOjogZG9uZV9zdGFjaykpXG4gICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIGYpIDo6IHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spXG4gICAgICAgfCBEb25lIC0+IFNraXAgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spKVxuICAgIHwgW10gLT4gaWYgTGlzdC5pc19lbXB0eSBkb25lX3N0YWNrIHRoZW4gRG9uZSBlbHNlIFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdKVxuICBpblxuICBsZXQgc3RhdGUgPSBsaXN0LCBbXSBpblxuICBTZXF1ZW5jZSAoc3RhdGUsIG5leHQpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZSAoU2VxdWVuY2UgKHMxLCBmMSkpID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSA9XG4gICAgbWF0Y2ggdG9kb19zdGFjayB3aXRoXG4gICAgfCBTZXF1ZW5jZSAoczIsIGYyKSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZjIgczIgd2l0aFxuICAgICAgIHwgWWllbGQgKHgsIHMyKSAtPiBZaWVsZCAoeCwgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzMiwgZjIpIDo6IGRvbmVfc3RhY2ssIHMxKSlcbiAgICAgICB8IFNraXAgczIgLT4gU2tpcCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMyLCBmMikgOjogZG9uZV9zdGFjaywgczEpXG4gICAgICAgfCBEb25lIC0+IFNraXAgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxKSlcbiAgICB8IFtdIC0+XG4gICAgICAobWF0Y2ggZjEgczEsIGRvbmVfc3RhY2sgd2l0aFxuICAgICAgIHwgWWllbGQgKHQsIHMxKSwgXyAtPiBTa2lwIChMaXN0LnJldiAodCA6OiBkb25lX3N0YWNrKSwgW10sIHMxKVxuICAgICAgIHwgU2tpcCBzMSwgXyAtPiBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSwgczEpXG4gICAgICAgfCBEb25lLCBfIDo6IF8gLT4gU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxKVxuICAgICAgIHwgRG9uZSwgW10gLT4gRG9uZSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gW10sIFtdLCBzMSBpblxuICBTZXF1ZW5jZSAoc3RhdGUsIG5leHQpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QgczEgczIgPVxuICBtYXAgczEgfmY6KGZ1biB4MSAtPiBtYXAgczIgfmY6KGZ1biB4MiAtPiB4MSwgeDIpKSB8PiBpbnRlcmxlYXZlXG47O1xuXG5sZXQgb2Zfc2VxIChzZXEgOiBfIENhbWwuU2VxLnQpID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6c2VxIH5mOihmdW4gc2VxIC0+XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBEb25lXG4gICAgfCBDb25zIChoZCwgdGwpIC0+IFlpZWxkIChoZCwgdGwpKVxuOztcblxubGV0IHRvX3NlcSAoU2VxdWVuY2UgKHN0YXRlLCBuZXh0KSkgPVxuICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgIG1hdGNoIG5leHQgc3RhdGUgd2l0aFxuICAgIHwgRG9uZSAtPiBDYW1sLlNlcS5OaWxcbiAgICB8IFNraXAgc3RhdGUgLT4gbG9vcCBzdGF0ZVxuICAgIHwgWWllbGQgKGhkLCBzdGF0ZSkgLT4gQ2FtbC5TZXEuQ29ucyAoaGQsIGZ1biAoKSAtPiBsb29wIHN0YXRlKVxuICBpblxuICBmdW4gKCkgLT4gbG9vcCBzdGF0ZVxuOztcblxubW9kdWxlIEdlbmVyYXRvciA9IHN0cnVjdFxuICB0eXBlICdlbHQgc3RlcHMgPSBXcmFwIG9mICgnZWx0LCB1bml0IC0+ICdlbHQgc3RlcHMpIFN0ZXAudFxuXG4gIGxldCB1bndyYXAgKFdyYXAgc3RlcCkgPSBzdGVwXG5cbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2VsdCkgdCA9ICgnYSAtPiAnZWx0IHN0ZXBzKSAtPiAnZWx0IHN0ZXBzXG5cbiAgICBsZXQgcmV0dXJuIHggayA9IGsgeFxuXG4gICAgbGV0IGJpbmQgbSB+ZiBrID1cbiAgICAgIG0gKGZ1biBhIC0+XG4gICAgICAgIGxldCBtJyA9IGYgYSBpblxuICAgICAgICBtJyBrKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwIG0gfmYgayA9IG0gKGZ1biBhIC0+IGsgKGYgYSkpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIE1vbmFkLk1ha2UyIChUKVxuXG4gIGxldCB5aWVsZCBlIGsgPSBXcmFwIChZaWVsZCAoZSwgaykpXG4gIGxldCB0b19zdGVwcyB0ID0gdCAoZnVuICgpIC0+IFdyYXAgRG9uZSlcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICAgIGRlbGF5ZWRfZm9sZFxuICAgICAgc2VxdWVuY2VcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuICgpIHggfmsgZiAtPiBXcmFwIChZaWVsZCAoeCwgZnVuICgpIC0+IGsgKCkgZikpKVxuICAgICAgfmZpbmlzaDpyZXR1cm5cbiAgOztcblxuICBsZXQgcnVuIHQgPVxuICAgIGxldCBpbml0ICgpID0gdG9fc3RlcHMgdCBpblxuICAgIGxldCBmIHRodW5rID0gdW53cmFwICh0aHVuayAoKSkgaW5cbiAgICB1bmZvbGRfc3RlcCB+aW5pdCB+ZlxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgQ2hhcjBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfY2hhciA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9jaGFyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9jaGFyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFN0cmluZy5tYWtlIDEgdFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbWF0Y2ggU3RyaW5nLmxlbmd0aCBzIHdpdGhcbiAgICB8IDEgLT4gcy5bMF1cbiAgICB8IF8gLT4gZmFpbHdpdGhmIFwiQ2hhci5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5DaGFyXCJcbiAgZW5kKVxuXG5sZXQgcHAgZm10IGMgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVDXCIgY1xuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGFsbCA9IEFycmF5LmluaXQgMjU2IH5mOnVuc2FmZV9vZl9pbnQgfD4gQXJyYXkudG9fbGlzdFxuXG5sZXQgaXNfbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfcHJpbnQgPSBmdW5jdGlvblxuICB8ICcgJyAuLiAnficgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc193aGl0ZXNwYWNlID0gZnVuY3Rpb25cbiAgfCAnXFx0JyB8ICdcXG4nIHwgJ1xcMDExJyAoKiB2ZXJ0aWNhbCB0YWIgKikgfCAnXFwwMTInICgqIGZvcm0gZmVlZCAqKSB8ICdcXHInIHwgJyAnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19hbHBoYSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbigqIFdyaXRpbmcgdGhlc2Ugb3V0LCBpbnN0ZWFkIG9mIGNhbGxpbmcgW2lzX2FscGhhXSBhbmQgW2lzX2RpZ2l0XSwgcmVkdWNlc1xuICAgcnVudGltZSBieSBhcHByb3guIDMwJSAqKVxubGV0IGlzX2FscGhhbnVtID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfZGlnaXRfdW5zYWZlIHQgPSB0b19pbnQgdCAtIHRvX2ludCAnMCdcblxubGV0IGdldF9kaWdpdF9leG4gdCA9XG4gIGlmIGlzX2RpZ2l0IHRcbiAgdGhlbiBnZXRfZGlnaXRfdW5zYWZlIHRcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLmdldF9kaWdpdF9leG4gJUM6IG5vdCBhIGRpZ2l0XCIgdCAoKVxuOztcblxubGV0IGdldF9kaWdpdCB0ID0gaWYgaXNfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9kaWdpdF91bnNhZmUgdCkgZWxzZSBOb25lXG5cbmxldCBpc19oZXhfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF9sb3dlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfdXBwZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdF9leG4gPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnMCdcbiAgfCAnYScgLi4gJ2YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ2EnICsgMTBcbiAgfCAnQScgLi4gJ0YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ0EnICsgMTBcbiAgfCB0IC0+XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJDaGFyLmdldF9oZXhfZGlnaXRfZXhuOiBub3QgYSBoZXhhZGVjaW1hbCBkaWdpdFwiXG4gICAgICAgICBbIFwiY2hhclwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IGdldF9oZXhfZGlnaXQgdCA9IGlmIGlzX2hleF9kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2hleF9kaWdpdF9leG4gdCkgZWxzZSBOb25lXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoID49ICkgPSAoID49IClcbiAgbGV0ICggPD0gKSA9ICggPD0gKVxuICBsZXQgKCA9ICkgPSAoID0gKVxuICBsZXQgKCA+ICkgPSAoID4gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgKCA8PiApID0gKCA8PiApXG5lbmRcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgYzEgYzIgPSBjb21wYXJlIChsb3dlcmNhc2UgYzEpIChsb3dlcmNhc2UgYzIpXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBoYXNoX2ZvbGRfY2hhciBzdGF0ZSAobG93ZXJjYXNlIHQpXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJ5dGVzIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChieXRlc19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ieXRlcyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBieXRlc19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQnl0ZXMwXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJ5dGVzXCJcbiAgbGV0IHBwIGZtdCB0ID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlU1wiICh0b19zdHJpbmcgdClcbmVuZFxuXG5pbmNsdWRlIFRcblxubW9kdWxlIFRvX2J5dGVzID0gQmxpdC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFQpIChUb19ieXRlcylcblxubW9kdWxlIEZyb21fc3RyaW5nID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIGVuZClcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgbiAwXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIkJ5dGVzLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gc2V0IHQgaSBjKTtcbiAgdFxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgKGkgLSAxKSAodW5zYWZlX2dldCB0IGkgOjogYWNjKVxuICBpblxuICBsb29wIHQgKGxlbmd0aCB0IC0gMSkgW11cbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcbmxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gbWFwaSB0IH5mXG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBwb3MgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzIGkpIHRhcmdldCB0aGVuIHVuc2FmZV9zZXQgcyBpIHJlcGxhY2VtZW50XG4gIGRvbmVcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAwXG4gIHRoZW4gc3RhZ2UgaWdub3JlXG4gIGVsc2UgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgMFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGk6IHJlcGxhY2VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgaWdub3JlXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IHMgaSAoU3RyaW5nLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCAodW5zYWZlX2dldCBzIGkpKSlcbiAgICAgICAgZG9uZSkpXG47O1xuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgY29udGFpbnMgP3BvcyA/bGVuIHQgY2hhciA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbGFzdCA9IHBvcyArIGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIGxhc3RcbiAgICAmJiAoQ2hhci5lcXVhbCAoZ2V0IHQgaSkgY2hhciB8fCBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIjIDEgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gXG50eXBlIHJlc3VsdCA9XG58IE5lZyBvZiBzdHJpbmdcbnwgUG9zIG9mIHN0cmluZ1xuXG4jIDggXCJzcmMvaGV4X2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMjdcXDAwMFxcMDgyXFwwMDBcXDEwNVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyBwYXJzZV9oZXggbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxMzUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAzKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOZWcgYm9keSApXG4jIDEzOSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDE0NSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDIpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE1IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBvcyBib2R5IClcbiMgMTQ5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIigqIFRoaXMgZmlsZSB3YXMgYXV0b2dlbmVyYXRlZCBieSAuLi9nZW5lcmF0ZS9nZW5lcmF0ZV9wb3dfb3ZlcmZsb3dfYm91bmRzLmV4ZSAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIGhhdmUgdG8gdXNlIEludDY0LnRvX2ludF9leG4gaW5zdGVhZCBvZiBpbnQgY29uc3RhbnRzIHRvIG1ha2VcbiAgIHN1cmUgdGhhdCBmaWxlIGNhbiBiZSBwcmVwcm9jZXNzZWQgb24gMzItYml0IG1hY2hpbmVzLiAqKVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIDogaW50MzIgPVxuICAyMTQ3NDgzNjQ3bFxuXG5sZXQgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50MzIgYXJyYXkgPVxuICBbfCAyMTQ3NDgzNjQ3bFxuICA7ICAyMTQ3NDgzNjQ3bFxuICA7ICA0NjM0MGxcbiAgOyAgMTI5MGxcbiAgOyAgMjE1bFxuICA7ICA3M2xcbiAgOyAgMzVsXG4gIDsgIDIxbFxuICA7ICAxNGxcbiAgOyAgMTBsXG4gIDsgIDhsXG4gIDsgIDdsXG4gIDsgIDVsXG4gIDsgIDVsXG4gIDsgIDRsXG4gIDsgIDRsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDNsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDJsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIDsgIDFsXG4gIHxdXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIDogaW50ID1cbiAgKC0xKSBsc3IgMVxuXG5sZXQgaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludCBhcnJheSA9XG4gIG1hdGNoIEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnQgd2l0aFxuICB8IDMyIC0+IEFycmF5Lm1hcCBpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgfmY6Q2FtbC5JbnQzMi50b19pbnRcbiAgfCA2MyAtPlxuICAgIFt8IENhbWwuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgOyAgQ2FtbC5JbnQ2NC50b19pbnQgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgICA7ICBDYW1sLkludDY0LnRvX2ludCAyMTQ3NDgzNjQ3TFxuICAgIDsgIDE2NjQ1MTBcbiAgICA7ICA0NjM0MFxuICAgIDsgIDU0MDRcbiAgICA7ICAxMjkwXG4gICAgOyAgNDYzXG4gICAgOyAgMjE1XG4gICAgOyAgMTE4XG4gICAgOyAgNzNcbiAgICA7ICA0OVxuICAgIDsgIDM1XG4gICAgOyAgMjdcbiAgICA7ICAyMVxuICAgIDsgIDE3XG4gICAgOyAgMTRcbiAgICA7ICAxMlxuICAgIDsgIDEwXG4gICAgOyAgOVxuICAgIDsgIDhcbiAgICA7ICA3XG4gICAgOyAgN1xuICAgIDsgIDZcbiAgICA7ICA1XG4gICAgOyAgNVxuICAgIDsgIDVcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgfF1cbiAgfCAzMSAtPlxuICAgIFt8IDEwNzM3NDE4MjNcbiAgICA7ICAxMDczNzQxODIzXG4gICAgOyAgMzI3NjdcbiAgICA7ICAxMDIzXG4gICAgOyAgMTgxXG4gICAgOyAgNjNcbiAgICA7ICAzMVxuICAgIDsgIDE5XG4gICAgOyAgMTNcbiAgICA7ICAxMFxuICAgIDsgIDdcbiAgICA7ICA2XG4gICAgOyAgNVxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIHxdXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbnQ2NF92YWx1ZSA6IGludDY0ID1cbiAgNDYxMTY4NjAxODQyNzM4NzkwM0xcblxubGV0IGludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgOyAgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgOyAgMjE0NzQ4MzY0N0xcbiAgOyAgMTY2NDUxMExcbiAgOyAgNDYzNDBMXG4gIDsgIDU0MDRMXG4gIDsgIDEyOTBMXG4gIDsgIDQ2M0xcbiAgOyAgMjE1TFxuICA7ICAxMThMXG4gIDsgIDczTFxuICA7ICA0OUxcbiAgOyAgMzVMXG4gIDsgIDI3TFxuICA7ICAyMUxcbiAgOyAgMTdMXG4gIDsgIDE0TFxuICA7ICAxMkxcbiAgOyAgMTBMXG4gIDsgIDlMXG4gIDsgIDhMXG4gIDsgIDdMXG4gIDsgIDdMXG4gIDsgIDZMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDFMXG4gIDsgIDFMXG4gIHxdXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUgOiBpbnQ2NCA9XG4gIDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG5cbmxldCBpbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIDMwMzcwMDA0OTlMXG4gIDsgIDIwOTcxNTFMXG4gIDsgIDU1MTA4TFxuICA7ICA2MjA4TFxuICA7ICAxNDQ4TFxuICA7ICA1MTFMXG4gIDsgIDIzNExcbiAgOyAgMTI3TFxuICA7ICA3OExcbiAgOyAgNTJMXG4gIDsgIDM4TFxuICA7ICAyOExcbiAgOyAgMjJMXG4gIDsgIDE4TFxuICA7ICAxNUxcbiAgOyAgMTNMXG4gIDsgIDExTFxuICA7ICA5TFxuICA7ICA4TFxuICA7ICA3TFxuICA7ICA3TFxuICA7ICA2TFxuICA7ICA2TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAxTFxuICB8XVxuXG5sZXQgaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCAtOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIC0zMDM3MDAwNDk5TFxuICA7ICAtMjA5NzE1MUxcbiAgOyAgLTU1MTA4TFxuICA7ICAtNjIwOExcbiAgOyAgLTE0NDhMXG4gIDsgIC01MTFMXG4gIDsgIC0yMzRMXG4gIDsgIC0xMjdMXG4gIDsgIC03OExcbiAgOyAgLTUyTFxuICA7ICAtMzhMXG4gIDsgIC0yOExcbiAgOyAgLTIyTFxuICA7ICAtMThMXG4gIDsgIC0xNUxcbiAgOyAgLTEzTFxuICA7ICAtMTFMXG4gIDsgIC05TFxuICA7ICAtOExcbiAgOyAgLTdMXG4gIDsgIC03TFxuICA7ICAtNkxcbiAgOyAgLTZMXG4gIDsgIC01TFxuICA7ICAtNUxcbiAgOyAgLTVMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTFMXG4gIHxdXG4iLCJvcGVuISBJbXBvcnRcblxuKCogQyBzdHViIGZvciBpbnQgcG9wY291bnQgdG8gdXNlIHRoZSBQT1BDTlQgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbmV4dGVybmFsIGludF9wb3Bjb3VudCA6IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50XCIgW0BAbm9hbGxvY11cblxuKCogVG8gbWFpbnRhaW4gamF2YXNjcmlwdCBjb21wYXRpYmlsaXR5IGFuZCBlbmFibGUgdW5ib3hpbmcsIHdlIGltcGxlbWVudCBwb3Bjb3VudCBpblxuICAgT0NhbWwgcmF0aGVyIHRoYW4gdXNlIEMgc3R1YnMuIEltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbTpcbiAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbW1pbmdfd2VpZ2h0I0VmZmljaWVudF9pbXBsZW1lbnRhdGlvbiAqKVxubGV0IGludDY0X3BvcGNvdW50ID1cbiAgbGV0IG9wZW4gQ2FtbC5JbnQ2NCBpblxuICBsZXQgKCArICkgPSBhZGQgaW5cbiAgbGV0ICggLSApID0gc3ViIGluXG4gIGxldCAoICogKSA9IG11bCBpblxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaW5cbiAgbGV0ICggbGFuZCApID0gbG9nYW5kIGluXG4gIGxldCBtMSA9IDB4NTU1NTU1NTU1NTU1NTU1NUwgaW5cbiAgKCogMGIwMTAxMDEwMS4uLiAqKVxuICBsZXQgbTIgPSAweDMzMzMzMzMzMzMzMzMzMzNMIGluXG4gICgqIDBiMDAxMTAwMTEuLi4gKilcbiAgbGV0IG00ID0gMHgwZjBmMGYwZjBmMGYwZjBmTCBpblxuICAoKiAwYjAwMDAxMTExLi4uICopXG4gIGxldCBoMDEgPSAweDAxMDEwMTAxMDEwMTAxMDFMIGluXG4gICgqIDEgYml0IHNldCBwZXIgYnl0ZSAqKVxuICBmdW4gW0BpbmxpbmVdIHggLT5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgcGFpciBvZiBiaXRzICopXG4gICAgbGV0IHggPSB4IC0gKCh4IGxzciAxKSBsYW5kIG0xKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSA0IGJpdHMgKilcbiAgICBsZXQgeCA9ICh4IGxhbmQgbTIpICsgKCh4IGxzciAyKSBsYW5kIG0yKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBieXRlICopXG4gICAgbGV0IHggPSAoeCArICh4IGxzciA0KSkgbGFuZCBtNCBpblxuICAgICgqIHN1bSB0aGUgYml0IGNvdW50cyBpbiB0aGUgdG9wIGJ5dGUgYW5kIHNoaWZ0IGl0IGRvd24gKilcbiAgICB0b19pbnQgKCh4ICogaDAxKSBsc3IgNTYpXG47O1xuXG5sZXQgaW50MzJfcG9wY291bnQgPVxuICAoKiBPbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpcyBmYXN0ZXIgdGhhbiBpbXBsZW1lbnRpbmcgdXNpbmcgW2ludDMyXSBhcml0aG1ldGljLiAqKVxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmTCBpblxuICBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKENhbWwuSW50NjQubG9nYW5kIChDYW1sLkludDY0Lm9mX2ludDMyIHgpIG1hc2spXG47O1xuXG5sZXQgbmF0aXZlaW50X3BvcGNvdW50ID1cbiAgbWF0Y2ggQ2FtbC5OYXRpdmVpbnQuc2l6ZSB3aXRoXG4gIHwgMzIgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDMyX3BvcGNvdW50IChDYW1sLk5hdGl2ZWludC50b19pbnQzMiB4KVxuICB8IDY0IC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQ2NF9wb3Bjb3VudCAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnRfaW50ZlxuaW5jbHVkZSBJbnQwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSB4IHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgeCB5XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICB0cnkgb2Zfc3RyaW5nIHMgd2l0aFxuICAgIHwgXyAtPiBQcmludGYuZmFpbHdpdGhmIFwiSW50Lm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuZW5kXG5cbmxldCBudW1fYml0cyA9IEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHRvX2Zsb2F0ID0gQ2FtbC5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBDYW1sLmludF9vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBDYW1sLmludF9vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIleFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyX3RydW5jIDogaW50MzIgLT4gdCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9pbnQ2NF90cnVuYyA6IGludDY0IC0+IHQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcblxubGV0IHByZWQgaSA9IGkgLSAxXG5sZXQgc3VjYyBpID0gaSArIDFcbmxldCB0b19pbnQgaSA9IGlcbmxldCB0b19pbnRfZXhuID0gdG9faW50XG5sZXQgb2ZfaW50IGkgPSBpXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IG1heF92YWx1ZSA9IENhbWwubWF4X2ludFxubGV0IG1pbl92YWx1ZSA9IENhbWwubWluX2ludFxubGV0IG1heF92YWx1ZV8zMF9iaXRzID0gMHgzRkZGX0ZGRkZcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgb2ZfaW50MzJfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50MzIgPSBDb252LmludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCB0b19pbnQ2NCA9IENvbnYuaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgYWJzIHggPSBhYnMgeFxuXG4oKiBub3RlIHRoYXQgcmVtIGlzIG5vdCBzYW1lIGFzICUgKilcbmxldCByZW0gYSBiID0gYSBtb2QgYlxubGV0IGluY3IgPSBDYW1sLmluY3JcbmxldCBkZWNyID0gQ2FtbC5kZWNyXG5sZXQgc2hpZnRfcmlnaHQgYSBiID0gYSBhc3IgYlxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYSBiID0gYSBsc3IgYlxubGV0IHNoaWZ0X2xlZnQgYSBiID0gYSBsc2wgYlxubGV0IGJpdF9ub3QgYSA9IGxub3QgYVxubGV0IGJpdF9vciBhIGIgPSBhIGxvciBiXG5sZXQgYml0X2FuZCBhIGIgPSBhIGxhbmQgYlxubGV0IGJpdF94b3IgYSBiID0gYSBseG9yIGJcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludF9wb3dcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCAtIDEgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggKyAxXG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4IC0gKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCAoeCAtIDEpID0gMFxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoKiBOb3RlIHRoYXQgd2UgcGFzcyB0aGUgdGFnZ2VkIGludCBoZXJlLiBTZWUgaW50X21hdGhfc3R1YnMuYyBmb3IgZGV0YWlscyBvbiB3aHlcbiAgICAgICAgICB0aGlzIGlzIGNvcnJlY3QuICopXG4gICAgaW50XG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50X2Nsel91bnRhZ2dlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludFtAdW50YWdnZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jdHpfdW50YWdnZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBpZiBpID0gMSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoaSAtIDEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBzaWduID0gU2lnbi5vZl9pbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludF9wb3Bjb3VudFxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG4gIGV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuICBleHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbiAgZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG4gIGV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogdCAtPiB0ID0gXCIlbmVnaW50XCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIG1vZHVsZSBGID0gSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBGXG5cbiAgZXh0ZXJuYWwgYnN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcblxuICAoKiBUaGVzZSBpbmxpbmVkIHZlcnNpb25zIG9mICglKSwgKC8lKSwgYW5kICgvLykgcGVyZm9ybSBiZXR0ZXIgdGhhbiB0aGVpciBmdW5jdG9yaXplZFxuICAgICBjb3VudGVycGFydHMgaW4gW0ZdIChzZWUgYmVuY2htYXJrcyBiZWxvdykuXG5cbiAgICAgVGhlIHJlYXNvbiB0aGVzZSBmdW5jdGlvbnMgYXJlIGlubGluZWQgaW4gW0ludF0gYnV0IG5vdCBpbiBhbnkgb2YgdGhlIG90aGVyIGludGVnZXJcbiAgICAgbW9kdWxlcyBpcyB0aGF0IHRoZXkgZXhpc3RlZCBpbiBbSW50XSBhbmQgW0ludF0gYWxvbmUgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZlxuICAgICB0aGUgW0ludF9tYXRoLk1ha2VdIGZ1bmN0b3IsIGFuZCB3ZSBkaWRuJ3Qgd2FudCB0byBkZWdyYWRlIHRoZWlyIHBlcmZvcm1hbmNlLlxuXG4gICAgIFdlIHdvbid0IHByZS1lbXB0aXZlbHkgZG8gdGhlIHNhbWUgZm9yIG5ldyBmdW5jdGlvbnMsIHVubGVzcyBzb21lb25lIGNhcmVzLCBvbiBhIGNhc2VcbiAgICAgYnkgY2FzZSBmYXNoaW9uLiAgKilcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gcmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuICBleHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG4gIGV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG4gIGxldCBsbm90ID0gbG5vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG4gIGV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG4gIGV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnRdIGFuZCBbSW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE9fRiA9IE8uRlxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBpbmNsdWRpbmcgZnVuY3RvclxuICAgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIFVjaGFyMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhclwiXG4gIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gSGFzaC5mb2xkX2ludCBzdGF0ZSAodG9faW50IHQpXG4gIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGxldCB0b19zdHJpbmcgdCA9IFByaW50Zi5zcHJpbnRmIFwiVSslMDRYXCIgKHRvX2ludCB0KVxuXG4gICgqIERvIG5vdCBhY3R1YWxseSBleHBvcnQgdGhpcy4gU2VlIGRpc2N1c3Npb24gaW4gdGhlIC5tbGkgKilcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IENhbWwuU2NhbmYuc3NjYW5mIHMgXCJVKyVYXCIgKGZ1biBpIC0+IFVjaGFyMC5vZl9pbnQgaSkgd2l0aFxuICAgICAgIHwgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG9mIHRoZSBmb3JtIFUrWFhYWCBuZWVkZWRcIiBzZXhwKVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGludF9pc19zY2FsYXIgPSBpc192YWxpZFxuXG5sZXQgc3VjY19leG4gYyA9XG4gIHRyeSBVY2hhcjAuc3VjYyBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5zdWNjX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBzdWNjIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnN1Y2MgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgcHJlZF9leG4gYyA9XG4gIHRyeSBVY2hhcjAucHJlZCBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5wcmVkX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBwcmVkIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnByZWQgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgb2Zfc2NhbGFyIGkgPSBpZiBpbnRfaXNfc2NhbGFyIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2Zfc2NhbGFyX2V4biBpID1cbiAgaWYgaW50X2lzX3NjYWxhciBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIub2ZfaW50X2V4biBnb3QgYSBpbnZhbGlkIFVuaWNvZGUgc2NhbGFyIHZhbHVlOiAlMDRYXCIgaSAoKVxuOztcblxubGV0IHRvX3NjYWxhciB0ID0gVWNoYXIwLnRvX2ludCB0XG5sZXQgdG9fY2hhciBjID0gaWYgaXNfY2hhciBjIHRoZW4gU29tZSAodW5zYWZlX3RvX2NoYXIgYykgZWxzZSBOb25lXG5cbmxldCB0b19jaGFyX2V4biBjID1cbiAgaWYgaXNfY2hhciBjXG4gIHRoZW4gdW5zYWZlX3RvX2NoYXIgY1xuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLnRvX2NoYXJfZXhuIGdvdCBhIG5vbiBsYXRpbi0xIGNoYXJhY3RlcjogVSslMDRYXCIgKHRvX2ludCBjKSAoKVxuOztcblxubGV0IHV0ZjhfYnl0ZV9sZW5ndGggdWNoYXIgPVxuICBsZXQgY29kZXBvaW50ID0gdG9fc2NhbGFyIHVjaGFyIGluXG4gIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHg4MFxuICB0aGVuIDFcbiAgZWxzZSBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4ODAwXG4gIHRoZW4gMlxuICBlbHNlIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHgxMDAwMFxuICB0aGVuIDNcbiAgZWxzZSA0XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdiKSB0ID0gVCA6ICgnYSwgJ2EpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDAzXyBiX18wMDRfKVxuICAgICAgOiAgKChhX18wMDNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMDNfLCBiX18wMDRfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gVCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCJcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmxldCByZWZsID0gVFxubGV0IHN5bSAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGIsIGEpIHQgPSBUXG5sZXQgdHJhbnMgKHR5cGUgYSBiIGMpIChUIDogKGEsIGIpIHQpIChUIDogKGIsIGMpIHQpIDogKGEsIGMpIHQgPSBUXG5sZXQgY29udiAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIChhIDogYSkgOiBiID0gYVxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuXG5tb2R1bGUgTGlmdDIgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpXG4gICAgOiAoKGExLCBhMikgWC50LCAoYjEsIGIyKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbm1vZHVsZSBMaWZ0MyAoWCA6IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyLCAnYTMpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIgYTMgYjMpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSAoVCA6IChhMywgYjMpIHQpXG4gICAgOiAoKGExLCBhMiwgYTMpIFgudCwgKGIxLCBiMiwgYjMpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubGV0IGRldHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSAqIGEyLCBiMSAqIGIyKSB0KSA6IChhMSwgYjEpIHQgKiAoYTIsIGIyKSB0ID1cbiAgVCwgVFxuOztcblxubGV0IHR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIDogKGExICogYTIsIGIxICogYjIpIHQgPSBUXG5cbm1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgc3RyaXAgOiAoJ2EgdCwgJ2IgdCkgZXF1YWwgLT4gKCdhLCAnYikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gIHR5cGUgKCdhMSwgJ2EyKSB0XG5cbiAgdmFsIHN0cmlwIDogKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBlcXVhbCAtPiAoJ2ExLCAnYjEpIGVxdWFsICogKCdhMiwgJ2IyKSBlcXVhbFxuZW5kXG5cbm1vZHVsZSBDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHkgKE0xIDogSW5qZWN0aXZlKSAoTTIgOiBJbmplY3RpdmUpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudFxuXG4gIGxldCBzdHJpcCBlID0gTTEuc3RyaXAgKE0yLnN0cmlwIGUpXG5lbmRcblxubW9kdWxlIElkID0gc3RydWN0XG4gIG1vZHVsZSBVaWQgPSBJbnRcblxuICBtb2R1bGUgV2l0bmVzcyA9IHN0cnVjdFxuICAgIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgXyB0ID0gLi5cbiAgICAgIHR5cGUgdHlwZV93aXRuZXNzX2ludCA9IFsgYHR5cGVfd2l0bmVzcyBvZiBpbnQgXSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgbGV0IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludCA9XG4gICAgICAgIChmdW4gKGB0eXBlX3dpdG5lc3Mgdl9fMDA1XykgLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidHlwZV93aXRuZXNzXCI7IHNleHBfb2ZfaW50IHZfXzAwNV8gXVxuICAgICAgICAgICA6IHR5cGVfd2l0bmVzc19pbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgOztcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgbGV0IHNleHBfb2ZfdCBfc2V4cF9vZl9hIHQgPVxuICAgICAgICBgdHlwZV93aXRuZXNzXG4gICAgICAgICAgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCB0KSlcbiAgICAgICAgfD4gc2V4cF9vZl90eXBlX3dpdG5lc3NfaW50XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIF8gS2V5LnQgKz0gS2V5IDogdCBLZXkudFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICBsZXQgc2V4cF9vZl90ICh0eXBlIGEpIHNleHBfb2ZfYSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgTS5LZXkgfD4gS2V5LnNleHBfb2ZfdCBzZXhwX29mX2FcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSB0KSAoKSA9XG4gICAgICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcbiAgICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdWlkICh0eXBlIGEpIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgICBDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgTS5LZXkpXG4gICAgOztcblxuICAgICgqIFdlIHdhbnQgYSBjb25zdGFudCBhbGxvY2F0ZWQgb25jZSB0aGF0IFtzYW1lXSBjYW4gcmV0dXJuIHdoZW5ldmVyIGl0IGdldHMgdGhlIHNhbWVcbiAgICAgICB3aXRuZXNzZXMuICBJZiB3ZSB3cml0ZSB0aGUgY29uc3RhbnQgaW5zaWRlIHRoZSBib2R5IG9mIFtzYW1lXSwgdGhlIG5hdGl2ZS1jb2RlXG4gICAgICAgY29tcGlsZXIgd2lsbCBkbyB0aGUgcmlnaHQgdGhpbmcgYW5kIGxpZnQgaXQgb3V0LiAgQnV0IGZvciBjbGFyaXR5IGFuZCByb2J1c3RuZXNzLFxuICAgICAgIHdlIGRvIGl0IG91cnNlbHZlcy4gKilcbiAgICBsZXQgc29tZV90ID0gU29tZSBUXG5cbiAgICBsZXQgc2FtZSAodHlwZSBhIGIpIChhIDogYSB0KSAoYiA6IGIgdCkgOiAoYSwgYikgZXF1YWwgb3B0aW9uID1cbiAgICAgIGxldCBtb2R1bGUgQSA9ICh2YWwgYSA6IFMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBCID0gKHZhbCBiIDogUyB3aXRoIHR5cGUgdCA9IGIpIGluXG4gICAgICBtYXRjaCBBLktleSB3aXRoXG4gICAgICB8IEIuS2V5IC0+IHNvbWVfdFxuICAgICAgfCBfIC0+IE5vbmVcbiAgICA7O1xuICBlbmRcblxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyB3aXRuZXNzIDogJ2EgV2l0bmVzcy50XG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgOyB0b19zZXhwIDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgXyB7IHdpdG5lc3M7IG5hbWU7IHRvX3NleHAgfSA6IFNleHAudCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gQXRvbSBuYW1lXG4gICAgZWxzZVxuICAgICAgTGlzdFxuICAgICAgICBbIExpc3QgWyBBdG9tIFwibmFtZVwiOyBBdG9tIG5hbWUgXVxuICAgICAgICA7IExpc3QgWyBBdG9tIFwid2l0bmVzc1wiOyB3aXRuZXNzIHw+IFdpdG5lc3Muc2V4cF9vZl90IHRvX3NleHAgXVxuICAgICAgICBdXG4gIDs7XG5cbiAgbGV0IHRvX3NleHAgdCA9IHQudG9fc2V4cFxuICBsZXQgbmFtZSB0ID0gdC5uYW1lXG4gIGxldCBjcmVhdGUgfm5hbWUgdG9fc2V4cCA9IHsgd2l0bmVzcyA9IFdpdG5lc3MuY3JlYXRlICgpOyBuYW1lOyB0b19zZXhwIH1cbiAgbGV0IHVpZCB0ID0gV2l0bmVzcy51aWQgdC53aXRuZXNzXG4gIGxldCBoYXNoIHQgPSB1aWQgdFxuICBsZXQgaGFzaF9mb2xkX3QgcyB0ID0gaGFzaF9mb2xkX2ludCBzICh1aWQgdClcbiAgbGV0IHNhbWVfd2l0bmVzcyB0MSB0MiA9IFdpdG5lc3Muc2FtZSB0MS53aXRuZXNzIHQyLndpdG5lc3NcbiAgbGV0IHNhbWUgdDEgdDIgPSBPcHRpb24uaXNfc29tZSAoc2FtZV93aXRuZXNzIHQxIHQyKVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIHQxIHQyID1cbiAgICBtYXRjaCBzYW1lX3dpdG5lc3MgdDEgdDIgd2l0aFxuICAgIHwgU29tZSB3IC0+IHdcbiAgICB8IE5vbmUgLT5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIlR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biBnb3QgZGlmZmVyZW50IGlkc1wiXG4gICAgICAgICAgIFsgKCBcIlwiXG4gICAgICAgICAgICAgLCBzZXhwX29mX3BhaXIgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHQxLCB0MilcbiAgICAgICAgICAgICApXG4gICAgICAgICAgIF0pXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmVnXG4gICAgfCBaZXJvXG4gICAgfCBQb3NcbiAgICB8IE5hblxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ25fb3JfbmFuLm1sLlQudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgIHwgTmVnIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICB8IE5hbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDNcbiAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3M7IE5hbiBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduX29yX25hblwiXG5lbmRcblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogVC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogVC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogVC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBULnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBvZl9zaWduID0gZnVuY3Rpb25cbiAgfCBTaWduLk5lZyAtPiBOZWdcbiAgfCBTaWduLlplcm8gLT4gWmVyb1xuICB8IFNpZ24uUG9zIC0+IFBvc1xuOztcblxubGV0IHRvX3NpZ25fZXhuID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gU2lnbi5OZWdcbiAgfCBaZXJvIC0+IFNpZ24uWmVyb1xuICB8IFBvcyAtPiBTaWduLlBvc1xuICB8IE5hbiAtPiBpbnZhbGlkX2FyZyBcIkJhc2UuU2lnbl9vcl9uYW4udG9fc2lnbl9leG46IE5hblwiXG47O1xuXG5sZXQgb2ZfaW50IG4gPSBvZl9zaWduIChTaWduLm9mX2ludCBuKVxubGV0IHRvX2ludF9leG4gdCA9IFNpZ24udG9faW50ICh0b19zaWduX2V4biB0KVxuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbiAgfCBOYW4gLT4gTmFuXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOYW4sIF8gfCBfLCBOYW4gLT4gTmFuXG4gIHwgXyAtPiBvZl9zaWduIChTaWduLiggKiApICh0b19zaWduX2V4biB0KSAodG9fc2lnbl9leG4gdCcpKVxuOztcblxuKCogSW5jbHVkZSBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBhbnkgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdFxuICAgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICB8IEluY2wgb2YgJ2FcbiAgfCBFeGNsIG9mICdhXG4gIHwgVW5ib3VuZGVkXG5bQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBhbGwgOiAnYS4gJ2EgbGlzdCAtPiAnYSB0IGxpc3QgPVxuICBmdW4gX2FsbF9vZl9hIC0+XG4gIFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgIHwgZW51bWVyYXRlX18wMDFfIDo6IGwgLT4gbWFwIGwgKEluY2wgZW51bWVyYXRlX18wMDFfIDo6IGFjYylcbiAgICAgaW5cbiAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAoUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgICAgfCBlbnVtZXJhdGVfXzAwMl8gOjogbCAtPiBtYXAgbCAoRXhjbCBlbnVtZXJhdGVfXzAwMl8gOjogYWNjKVxuICAgICAgICBpblxuICAgICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgICAgIFsgVW5ib3VuZGVkIF0pXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAxOF8pIDogKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8gdCkgLT5cbiAgbGV0IGVycm9yX3NvdXJjZV9fMDA2XyA9IFwibWF5YmVfYm91bmQubWwudFwiIGluXG4gIGZ1biBfb2ZfYV9fMDAzXyAtPiBmdW5jdGlvblxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBfdGFnX18wMDlfKSA6OiBzZXhwX2FyZ3NfXzAxMF8pIGFzXG4gICAgICBfc2V4cF9fMDA4XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDEwXyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxMV8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTFfIGluXG4gICAgICAgICBJbmNsIHJlczBfXzAxMl9cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAwOV9cbiAgICAgICAgICAgX3NleHBfXzAwOF8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgIF9zZXhwX18wMTNfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTVfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxNl8gaW5cbiAgICAgICAgIEV4Y2wgcmVzMF9fMDE3X1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDE0X1xuICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIC0+IFVuYm91bmRlZFxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgOjogXykgYXNcbiAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biAodHlwZSBhX18wMjRfKSA6ICgoYV9fMDI0XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyNF8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyAtPiBmdW5jdGlvblxuICAgIHwgSW5jbCBhcmcwX18wMjBfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkluY2xcIjsgcmVzMF9fMDIxXyBdXG4gICAgfCBFeGNsIGFyZzBfXzAyMl8gLT5cbiAgICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhjbFwiOyByZXMwX18wMjNfIF1cbiAgICB8IFVuYm91bmRlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmJvdW5kZWRcIlxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkluY2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkV4Y2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJVbmJvdW5kZWRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxudHlwZSBpbnRlcnZhbF9jb21wYXJpc29uID1cbiAgfCBCZWxvd19sb3dlcl9ib3VuZFxuICB8IEluX3JhbmdlXG4gIHwgQWJvdmVfdXBwZXJfYm91bmRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2hdXG5cbmxldCBpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDI3XyA9IFwibWF5YmVfYm91bmQubWwuaW50ZXJ2YWxfY29tcGFyaXNvblwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgLT4gQmVsb3dfbG93ZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIC0+IEluX3JhbmdlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSAtPiBBYm92ZV91cHBlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBzZXhwX18wMjZfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiBpbnRlcnZhbF9jb21wYXJpc29uKVxuOztcblxubGV0IHNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW5jdGlvblxuICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQmVsb3dfbG93ZXJfYm91bmRcIlxuICAgIHwgSW5fcmFuZ2UgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5fcmFuZ2VcIlxuICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQWJvdmVfdXBwZXJfYm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAoaW50ZXJ2YWxfY29tcGFyaXNvbl9zZXhwX2dyYW1tYXIgOiBpbnRlcnZhbF9jb21wYXJpc29uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiQmVsb3dfbG93ZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkluX3JhbmdlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJBYm92ZV91cHBlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlXG4gICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnQpXG47O1xuXG5sZXQgKGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIDpcbiAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgSW5fcmFuZ2UgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IEluY2wgKGYgaW5jbClcbiAgfCBFeGNsIGV4Y2wgLT4gRXhjbCAoZiBleGNsKVxuICB8IFVuYm91bmRlZCAtPiBVbmJvdW5kZWRcbjs7XG5cbmxldCBpc19sb3dlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGluY2wgYSA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgZXhjbCBhIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgaXNfdXBwZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBhIGluY2wgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGEgZXhjbCA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBtYXRjaCBsb3dlciB3aXRoXG4gIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gIHwgSW5jbCBsb3dlciB8IEV4Y2wgbG93ZXIgLT5cbiAgICAobWF0Y2ggdXBwZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICAgICB8IEluY2wgdXBwZXIgfCBFeGNsIHVwcGVyIC0+IGNvbXBhcmUgbG93ZXIgdXBwZXIgPiAwKVxuOztcblxubGV0IGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgaWYgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZVxuICB0aGVuIGZhaWx3aXRoIFwiTWF5YmVfYm91bmQuY29tcGFyZV90b19pbnRlcnZhbF9leG46IGxvd2VyIGJvdW5kID4gdXBwZXIgYm91bmRcIlxuOztcblxubGV0IGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlO1xuICBpZiBub3QgKGlzX2xvd2VyX2JvdW5kIGxvd2VyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBCZWxvd19sb3dlcl9ib3VuZFxuICBlbHNlIGlmIG5vdCAoaXNfdXBwZXJfYm91bmQgdXBwZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEFib3ZlX3VwcGVyX2JvdW5kXG4gIGVsc2UgSW5fcmFuZ2Vcbjs7XG5cbmxldCBpbnRlcnZhbF9jb250YWluc19leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgbWF0Y2ggY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlIHdpdGhcbiAgfCBJbl9yYW5nZSAtPiB0cnVlXG4gIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgT3JfZHVwbGljYXRlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgT2sgb2YgJ2FcbiAgICB8IGBEdXBsaWNhdGVcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgfCBgT2sgX2xlZnRfXzAwM18sIGBPayBfcmlnaHRfXzAwNF8gLT4gX2NtcF9fYSBfbGVmdF9fMDAzXyBfcmlnaHRfXzAwNF9cbiAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiAwXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNV8gYl9fMDA2XyAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDA1XyBiX18wMDZfXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBhX18wMDVfLCBiX18wMDZfIHdpdGhcbiAgICAgICAgfCBgT2sgX2xlZnRfXzAwN18sIGBPayBfcmlnaHRfXzAwOF8gLT4gX2NtcF9fYSBfbGVmdF9fMDA3XyBfcmlnaHRfXzAwOF9cbiAgICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IHRydWVcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMDlfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBPayB2X18wMTBfIC0+IFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IF9vZl9hX18wMDlfIHZfXzAxMF8gXVxuICAgICAgfCBgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkR1cGxpY2F0ZVwiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gY29tcGFyYXRvcjooJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gKCdrZXksICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdrICd2LiAoJ2sgLT4gJ2sgLT4gaW50KSAtPiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgbGV0IHRfXzAxM18sIHRfXzAxNF8gPSBhX18wMTFfIGluXG4gICAgbGV0IHRfXzAxNV8sIHRfXzAxNl8gPSBiX18wMTJfIGluXG4gICAgbWF0Y2ggX2NtcF9fayB0X18wMTNfIHRfXzAxNV8gd2l0aFxuICAgIHwgMCAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+ICdrIC0+IGJvb2wpIC0+ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAyN18gYl9fMDI4XyAtPlxuICAgICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgICBsZXQgdF9fMDMxXywgdF9fMDMyXyA9IGJfXzAyOF8gaW5cbiAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgICAoaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDMwXyB0X18wMzJfXG4gICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBtYXRjaCB0X18wMzBfLCB0X18wMzJfIHdpdGhcbiAgICAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDMzXywgYExlZnQgX3JpZ2h0X18wMzRfIC0+IF9jbXBfX3YgX2xlZnRfXzAzM18gX3JpZ2h0X18wMzRfXG4gICAgICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMzVfLCBgUmlnaHQgX3JpZ2h0X18wMzZfIC0+IF9jbXBfX3YgX2xlZnRfXzAzNV8gX3JpZ2h0X18wMzZfXG4gICAgICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAzN18sIGBVbmVxdWFsIF9yaWdodF9fMDM4XyAtPlxuICAgICAgICAgICAgIGxldCB0X18wMzlfLCB0X18wNDBfID0gX2xlZnRfXzAzN18gaW5cbiAgICAgICAgICAgICBsZXQgdF9fMDQxXywgdF9fMDQyXyA9IF9yaWdodF9fMDM4XyBpblxuICAgICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX3YgdF9fMDM5XyB0X18wNDFfKSAoX2NtcF9fdiB0X18wNDBfIHRfXzA0Ml8pXG4gICAgICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnayAndi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdrKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdrLCAndikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJtYXBfaW50Zi5tbC5TeW1tZXRyaWNfZGlmZl9lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2Zfa19fMDQzXyBfb2Zfdl9fMDQ0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNjdfOyBhcmcxX18wNjhfIF0gLT5cbiAgICAgICAgbGV0IHJlczBfXzA2OV8gPSBfb2Zfa19fMDQzXyBhcmcwX18wNjdfXG4gICAgICAgIGFuZCByZXMxX18wNzBfID1cbiAgICAgICAgICBsZXQgc2V4cF9fMDY2XyA9IGFyZzFfXzA2OF8gaW5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG1hdGNoIHNleHBfXzA2Nl8gd2l0aFxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyBhcyBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIDo6IHNleHBfYXJnc19fMDUwXykgYXNcbiAgICAgICAgICAgICAgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiBhcyBfdGFnX18wNjNfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2NF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDY1XyA9IF9vZl92X18wNDRfIGFyZzBfXzA2NF8gaW5cbiAgICAgICAgICAgICAgICAgICAgYExlZnQgcmVzMF9fMDY1X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjNfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiBhcyBfdGFnX18wNjBfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2MV8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDYyXyA9IF9vZl92X18wNDRfIGFyZzBfXzA2MV8gaW5cbiAgICAgICAgICAgICAgICAgICAgYFJpZ2h0IHJlczBfXzA2Ml9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiBhcyBfdGFnX18wNTFfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA1OF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU5XyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggYXJnMF9fMDU4XyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNTJfOyBhcmcxX18wNTNfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDUyX1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2Zfdl9fMDQ0XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMwX18wNTRfLCByZXMxX18wNTVfXG4gICAgICAgICAgICAgICAgICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNleHBfXzA1Nl9cbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgYFVuZXF1YWwgcmVzMF9fMDU5X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNTFfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuTm9fdmFyaWFudF9tYXRjaCAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgIHNleHBfXzA2Nl9cbiAgICAgICAgaW5cbiAgICAgICAgcmVzMF9fMDY5XywgcmVzMV9fMDcwX1xuICAgICAgfCBzZXhwX18wNzFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgZXJyb3Jfc291cmNlX18wNTdfIDIgc2V4cF9fMDcxX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdrICd2LlxuICAgICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2Zfa19fMDcyXyBfb2Zfdl9fMDczXyAoYXJnMF9fMDgxXywgYXJnMV9fMDgyXykgLT5cbiAgICAgIGxldCByZXMwX18wODNfID0gX29mX2tfXzA3Ml8gYXJnMF9fMDgxX1xuICAgICAgYW5kIHJlczFfXzA4NF8gPVxuICAgICAgICBtYXRjaCBhcmcxX18wODJfIHdpdGhcbiAgICAgICAgfCBgTGVmdCB2X18wNzRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2Zfdl9fMDczXyB2X18wNzRfIF1cbiAgICAgICAgfCBgUmlnaHQgdl9fMDc1XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl92X18wNzNfIHZfXzA3NV8gXVxuICAgICAgICB8IGBVbmVxdWFsIHZfXzA3Nl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbFwiXG4gICAgICAgICAgICA7IChsZXQgYXJnMF9fMDc3XywgYXJnMV9fMDc4XyA9IHZfXzA3Nl8gaW5cbiAgICAgICAgICAgICAgIGxldCByZXMwX18wNzlfID0gX29mX3ZfXzA3M18gYXJnMF9fMDc3X1xuICAgICAgICAgICAgICAgYW5kIHJlczFfXzA4MF8gPSBfb2Zfdl9fMDczXyBhcmcxX18wNzhfIGluXG4gICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wNzlfOyByZXMxX18wODBfIF0pXG4gICAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDgzXzsgcmVzMV9fMDg0XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8na19zZXhwX2dyYW1tYXIgXyd2X3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgKCBfJ2tfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAgICggVmFyaWFudFxuICAgICAgICAgICAgICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiVW5lcXVhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKSApKVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDg1XyBiX18wODZfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDg1XyBiX18wODZfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wODVfLCBiX18wODZfIHdpdGhcbiAgICAgIHwgYExlZnQgX2xlZnRfXzA4N18sIGBMZWZ0IF9yaWdodF9fMDg4XyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wODdfIF9yaWdodF9fMDg4X1xuICAgICAgfCBgUmlnaHQgX2xlZnRfXzA4OV8sIGBSaWdodCBfcmlnaHRfXzA5MF8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzA4OV8gX3JpZ2h0X18wOTBfXG4gICAgICB8IGBCb3RoIF9sZWZ0X18wOTFfLCBgQm90aCBfcmlnaHRfXzA5Ml8gLT5cbiAgICAgICAgbGV0IHRfXzA5M18sIHRfXzA5NF8gPSBfbGVmdF9fMDkxXyBpblxuICAgICAgICBsZXQgdF9fMDk1XywgdF9fMDk2XyA9IF9yaWdodF9fMDkyXyBpblxuICAgICAgICAobWF0Y2ggX2NtcF9fbGVmdCB0X18wOTNfIHRfXzA5NV8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX3JpZ2h0IHRfXzA5NF8gdF9fMDk2X1xuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDk3XyBiX18wOThfIC0+XG4gICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wOTdfIGJfXzA5OF9cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGFfXzA5N18sIGJfXzA5OF8gd2l0aFxuICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wOTlfLCBgTGVmdCBfcmlnaHRfXzEwMF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDk5XyBfcmlnaHRfXzEwMF9cbiAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzEwMV8sIGBSaWdodCBfcmlnaHRfXzEwMl8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzEwMV8gX3JpZ2h0X18xMDJfXG4gICAgICAgIHwgYEJvdGggX2xlZnRfXzEwM18sIGBCb3RoIF9yaWdodF9fMTA0XyAtPlxuICAgICAgICAgIGxldCB0X18xMDVfLCB0X18xMDZfID0gX2xlZnRfXzEwM18gaW5cbiAgICAgICAgICBsZXQgdF9fMTA3XywgdF9fMTA4XyA9IF9yaWdodF9fMTA0XyBpblxuICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX2xlZnQgdF9fMTA1XyB0X18xMDdfKSAoX2NtcF9fcmlnaHQgdF9fMTA2XyB0X18xMDhfKVxuICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnbGVmdCAncmlnaHQuXG4gICAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2xlZnRfXzEwOV8gX29mX3JpZ2h0X18xMTBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBMZWZ0IHZfXzExMV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2ZfbGVmdF9fMTA5XyB2X18xMTFfIF1cbiAgICAgIHwgYFJpZ2h0IHZfXzExMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3JpZ2h0X18xMTBfIHZfXzExMl8gXVxuICAgICAgfCBgQm90aCB2X18xMTNfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiXG4gICAgICAgICAgOyAobGV0IGFyZzBfXzExNF8sIGFyZzFfXzExNV8gPSB2X18xMTNfIGluXG4gICAgICAgICAgICAgbGV0IHJlczBfXzExNl8gPSBfb2ZfbGVmdF9fMTA5XyBhcmcwX18xMTRfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzExN18gPSBfb2ZfcmlnaHRfXzExMF8gYXJnMV9fMTE1XyBpblxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzExNl87IHJlczFfXzExN18gXSlcbiAgICAgICAgICBdXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5Db250aW51ZV9vcl9zdG9wICopXG5tb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ29udGludWVcbiAgICB8IFN0b3BcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgQ29udGludWU7IFN0b3AgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb250aW51ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJDb250aW51ZVwiXG4gICAgICB8IFN0b3AgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RvcFwiXG4gICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkZpbmlzaGVkX29yX3VuZmluaXNoZWQgKilcbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBGaW5pc2hlZFxuICAgIHwgVW5maW5pc2hlZFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBGaW5pc2hlZDsgVW5maW5pc2hlZCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkZpbmlzaGVkXCJcbiAgICAgIHwgVW5maW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmZpbmlzaGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICB0eXBlICdhIGtleVxuICB0eXBlICdjbXAgY21wXG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgdmFsIGFkZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzZXRcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBhZGRfbXVsdGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YgbGlzdCkgb3B0aW9uc1xuXG4gIHZhbCBjaGFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3Ygb3B0aW9uKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgZmluZF9leG4gOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2KSBvcHRpb25zXG4gIHZhbCByZW1vdmUgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sga2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAgIC0+IHVuaXQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZDJcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYSAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfa2V5c1xuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIGtleSAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcmlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICgnaywgJ2NtcCwgKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCkgb3B0aW9uc1xuXG4gIHZhbCBlcXVhbFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21iaW5lOihrZXk6J2sga2V5IC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KCdhIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAnayBrZXlcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sga2V5ICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFwcGVuZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBsb3dlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgLT4gdXBwZXJfYm91bmQ6J2sga2V5IE1heWJlX2JvdW5kLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbWluOidrIGtleVxuICAgICAgLT4gbWF4OidrIGtleVxuICAgICAgLT4gaW5pdDonYVxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sga2V5IC0+IG1heDonayBrZXkgLT4gKCdrIGtleSAqICd2KSBsaXN0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrIGtleVxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrIGtleSwgJ3YsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonayBrZXlcbiAgICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBzZXQgOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBhZGRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIGxpc3QgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleSAtPiAnYSBsaXN0IHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIGNoYW5nZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHRcbiAgdmFsIHVwZGF0ZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgdFxuICB2YWwgbWVtIDogXyB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiBfIHQgLT4gZjooa2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMiA6ICdhIHQgLT4gJ2IgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG1hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgZm9sZDJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2IgdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogJ2EgdCAtPiBmOihrZXkgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBmaWx0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgcGFydGl0aW9uX21hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAoJ2IsICdjKSBFaXRoZXIudCkgLT4gJ2IgdCAqICdjIHRcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2MpIEVpdGhlci50KSAtPiAnYiB0ICogJ2MgdFxuICB2YWwgcGFydGl0aW9uaV90ZiA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICdhIE9yX2Vycm9yLnQgdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiBfIHQgLT4ga2V5IGxpc3RcbiAgdmFsIGRhdGEgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FsaXN0IDogP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICB2YWwgbWVyZ2UgOiAnYSB0IC0+ICdiIHQgLT4gZjooa2V5OmtleSAtPiAoJ2EsICdiKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Mgb3B0aW9uKSAtPiAnYyB0XG4gIHZhbCBtZXJnZV9za2V3ZWQgOiAndiB0IC0+ICd2IHQgLT4gY29tYmluZTooa2V5OmtleSAtPiAndiAtPiAndiAtPiAndikgLT4gJ3YgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiAoa2V5LCAnYSkgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKGtleSwgJ2EpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3BsaXQgOiAnYSB0IC0+IGtleSAtPiAnYSB0ICogKGtleSAqICdhKSBvcHRpb24gKiAnYSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6J2EgdFxuICAgIC0+IHVwcGVyX3BhcnQ6J2EgdFxuICAgIC0+IFsgYE9rIG9mICdhIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgJ2EgdFxuICAgIC0+IGxvd2VyX2JvdW5kOmtleSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6a2V5IE1heWJlX2JvdW5kLnRcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgJ2EgdFxuICAgIC0+IG1pbjprZXlcbiAgICAtPiBtYXg6a2V5XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYilcbiAgICAtPiAnYlxuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICdhIHQgLT4gbWluOmtleSAtPiBtYXg6a2V5IC0+IChrZXkgKiAnYSkgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICdhIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4ga2V5XG4gICAgLT4gKGtleSAqICdhKSBvcHRpb25cblxuICB2YWwgbnRoIDogJ2EgdCAtPiBpbnQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAnYSB0IC0+IGludCAtPiBrZXkgKiAnYVxuICB2YWwgcmFuayA6IF8gdCAtPiBrZXkgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzprZXlcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOmtleVxuICAgIC0+ICdhIHRcbiAgICAtPiAoa2V5ICogJ2EpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICdhIHRcbiAgICAtPiBjb21wYXJlOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgJ2EgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTprZXkgLT4gZGF0YTonYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYikgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYikgdCAtPiAnYSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZpbHRlcl9tYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnYSwgJ2IgT3JfZXJyb3IudCkgdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG4gIHZhbCB0b19hbGlzdCA6ID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gLT4gKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gKCdhLCAnYikgdCAqICgnYSAqICdiKSBvcHRpb24gKiAoJ2EsICdiKSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2EsICdiKSB0IC0+IG1pbjonYSAtPiBtYXg6J2EgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6ICgnYSwgXykgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXywgJ2NtcCkgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogKCdhLCBfLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IsIF8pIHQgLT4gJ2IgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2EsICdiLCBfKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdhLCAnYiwgXykgdCAtPiBtaW46J2EgLT4gbWF4OidhIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdhLCAnYiwgXykgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYiwgXykgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IsIF8pIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHNldFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIGZpbmRfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAnYiBsaXN0XG5cbiAgdmFsIGNoYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgdXBkYXRlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+IGY6KCdiIG9wdGlvbiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbmQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuXG4gIHZhbCByZW1vdmVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfLCAnY21wKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXNcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdiIC0+ICdiIC0+IGludClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwga2V5cyA6ICgnYSwgXywgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiLCBfKSB0IC0+ICdiIGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EgKiAnYikgb3B0aW9uICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gbG93ZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxuKCoqIENvbnNpc3RlbmN5IGNoZWNrcyAoc2FtZSBhcyBpbiBbQ29udGFpbmVyXSkuICopXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKFQgOiBUMylcbiAgICAoVHJlZSA6IFQzKVxuICAgIChLZXkgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IEFjY2Vzc29yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMzIChNIDogQWNjZXNzb3JzMykgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgKE0gOiBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdFxuICB0eXBlICgnaywgJ3YsICdjbXApIHRyZWVcbiAgdHlwZSAnayBrZXlcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdrLCAnY21wLCAnayBrZXkgLT4gJ3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgICAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpXG4gICAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIga2V5IF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0IC0+IGY6KCdrMSBrZXkgLT4gJ2syIGtleSkgLT4gKCdrMiwgJ3YsICdjbXAyKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgbGVuOmludCAtPiBmOihpbnQgLT4gJ2sga2V5ICogJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBsaXN0IC0+IGluaXQ6J3YyIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdXG4gICAgICApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgIC0+IGluaXQ6J3YyXG4gICAgICAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MilcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KVxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBpdGVyaTooZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2ssICdjbXAsICgnayBrZXksICd2LCAnY21wKSB0cmVlIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6IF8gdFxuICB2YWwgc2luZ2xldG9uIDoga2V5IC0+ICdhIC0+ICdhIHRcbiAgdmFsIG1hcF9rZXlzIDogJ3YgdCAtPiBmOihrZXkgLT4ga2V5KSAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICd2IHQgLT4gZjooa2V5IC0+IGtleSkgLT4gJ3YgdFxuICB2YWwgb2ZfYWxpc3QgOiAoa2V5ICogJ2EpIGxpc3QgLT4gWyBgT2sgb2YgJ2EgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX2FsaXN0X2V4biA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSBsaXN0IHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoa2V5ICogJ2EpIGxpc3QgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlIDogKGtleSAqICdhKSBsaXN0IC0+IGY6KCdhIC0+ICdhIC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoa2V5ICogJ2EpIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IChrZXkgKiAnYSkgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiBrZXkgKiAnYSkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICdhIHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGkgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBmOignYSAtPiAnYSAtPiAnYSkgLT4gJ2EgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6a2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cblxuICB2YWwgb2ZfaXRlcmlfZXhuIDogaXRlcmk6KGY6KGtleTprZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAndiB0XG4gIHZhbCBvZl90cmVlIDogJ2EgdHJlZSAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAoXywgXykgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2IgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazEsICd2KSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICgnazEsICd2KSB0IC0+IGY6KCdrMSAtPiAnazIpIC0+ICgnazIsICd2KSB0XG4gIHZhbCBvZl9hbGlzdCA6ICgnYSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoJ2EgKiAnYikgbGlzdCAtPiBpbml0OidjIC0+IGY6KCdjIC0+ICdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2UgOiAoJ2EgKiAnYikgbGlzdCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhICogJ2IpIGFycmF5IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICgnYSAqICdiKSBhcnJheSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhICogJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IgbGlzdCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4biA6IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl90cmVlIDogKCdhLCAnYikgdHJlZSAtPiAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsIF8sICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gJ2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogIGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiAoJ2syLCAndiwgJ2NtcDIpIHRcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9hbGlzdF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EgKiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3RyZWVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnNcbiAgICAoVCA6IFQzKVxuICAgIChUcmVlIDogVDMpXG4gICAgKEtleSA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yIChNIDogQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yczFcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGtleSA6PSBrZXlcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMyXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczJcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxuICB2YWwgc2V4cF9vZl9tX190XG4gICAgOiAgKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoJ3YgLT4gU2V4cC50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190XG4gICAgOiAgKG1vZHVsZSBDb21wYXJlX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGludClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoSGFzaC5zdGF0ZSAtPiAndiAtPiBIYXNoLnN0YXRlKVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gSGFzaC5zdGF0ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1hcCA9IHNpZ1xuICAoKiogW01hcF0gaXMgYSBmdW5jdGlvbmFsIGRhdGEgc3RydWN0dXJlIChiYWxhbmNlZCBiaW5hcnkgdHJlZSkgaW1wbGVtZW50aW5nIGZpbml0ZSBtYXBzXG4gICAgICBvdmVyIGEgdG90YWxseS1vcmRlcmVkIGRvbWFpbiwgY2FsbGVkIGEgXCJrZXlcIi4gKilcblxuICB0eXBlICgna2V5LCArJ3ZhbHVlLCAnY21wKSB0XG5cbiAgbW9kdWxlIE9yX2R1cGxpY2F0ZSA9IE9yX2R1cGxpY2F0ZVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IENvbnRpbnVlX29yX3N0b3BcblxuICBtb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA6IHNpZ1xuICAgIHR5cGUgdCA9IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudCA9XG4gICAgICB8IEZpbmlzaGVkXG4gICAgICB8IFVuZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfZW51bWVyYXRlX2xpYi5FbnVtZXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIE1hcHMgW0NvbnRpbnVlXSB0byBbRmluaXNoZWRdIGFuZCBbU3RvcF0gdG8gW1VuZmluaXNoZWRdLiAqKVxuICAgIHZhbCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHRcblxuICAgICgqKiBNYXBzIFtGaW5pc2hlZF0gdG8gW0NvbnRpbnVlXSBhbmQgW1VuZmluaXNoZWRdIHRvIFtTdG9wXS4gKilcbiAgICB2YWwgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNZXJnZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICAgIF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICB2YWwgY29tcGFyZVxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gaW50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gYm9vbFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBsZWZ0IDogKCdsZWZ0LCBfKSB0IC0+ICdsZWZ0IG9wdGlvblxuICAgIHZhbCByaWdodCA6IChfLCAncmlnaHQpIHQgLT4gJ3JpZ2h0IG9wdGlvblxuICAgIHZhbCBsZWZ0X3ZhbHVlIDogKCdsZWZ0LCBfKSB0IC0+IGRlZmF1bHQ6J2xlZnQgLT4gJ2xlZnRcbiAgICB2YWwgcmlnaHRfdmFsdWUgOiAoXywgJ3JpZ2h0KSB0IC0+IGRlZmF1bHQ6J3JpZ2h0IC0+ICdyaWdodFxuXG4gICAgdmFsIHZhbHVlc1xuICAgICAgOiAgKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGxlZnRfZGVmYXVsdDonbGVmdFxuICAgICAgLT4gcmlnaHRfZGVmYXVsdDoncmlnaHRcbiAgICAgIC0+ICdsZWZ0ICogJ3JpZ2h0XG4gIGVuZFxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIGxldCBtYXAgPSBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgICAgICAgICBbIFwiYVwiLCAxOyBcImFcIiwgMTA7IFwiYlwiLCAyOyBcImJcIiwgMjA7IFwiYlwiLCAyMDAgXVxuICAgICAgICAgICAgICAgICAgICAgIH5pbml0OkludC5TZXQuZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmludF9zIFslc2V4cCAobWFwIDogSW50LlNldC50IFN0cmluZy5NYXAudCldOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaXRlcmkgfml0ZXJpXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0XSwgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB0YWtpbmcgYSBjb25jcmV0ZVxuICAgICAgZGF0YSBzdHJ1Y3R1cmUsIGl0IHRha2VzIGFuIGl0ZXJhdGlvbiBmdW5jdGlvbi4gIEZvciBpbnN0YW5jZSwgdG8gY29udmVydCBhIHN0cmluZyB0YWJsZVxuICAgICAgaW50byBhIG1hcDogW29mX2l0ZXJpIChtb2R1bGUgU3RyaW5nKSB+ZjooSGFzaHRibC5pdGVyaSB0YWJsZSldLiAgSXQgaXMgZmFzdGVyIHRoYW5cbiAgICAgIGFkZGluZyB0aGUgZWxlbWVudHMgb25lIGJ5IG9uZS4gKilcbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogTGlrZSBbb2ZfaXRlcmldIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXkgYyAoU2VxdWVuY2UudG9fYXJyYXlcbiAgICAgIHNlcSldLCBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBhcnJheS5cblxuICAgICAgVGhlIHNlcXVlbmNlIHdpbGwgYmUgZm9sZGVkIG92ZXIgb25jZSwgYW5kIHRoZSBhZGRpdGlvbmFsIHRpbWUgY29tcGxleGl0eSBpcyB7ZSBPKG4pfS5cbiAgKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0IGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG5cbiAgICAgIElmIHlvdXIgc2VxdWVuY2UgaXMgaW5jcmVhc2luZywgdXNlIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXS5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX29yX2Vycm9yIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X29yX2Vycm9yIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9leG4gYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC5cblxuICAgICAgW29mX3NlcXVlbmNlX211bHRpIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX2ZvbGQgYyBzZXEgfmluaXQgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZm9sZCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmluaXQgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfcmVkdWNlIGMgc2VxIH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X3JlZHVjZSBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBUZXN0cyB3aGV0aGVyIGEgbWFwIGlzIGVtcHR5LiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFtsZW5ndGggbWFwXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gW21hcF0uICBPKDEpLCBidXQgW1RyZWUubGVuZ3RoXSBpc1xuICAgICAgTyhuKS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgbmV3IGJpbmRpbmc7IGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgYm91bmQsIGl0c1xuICAgICAgcHJldmlvdXMgYmluZGluZyBkaXNhcHBlYXJzLiAqKVxuICB2YWwgc2V0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthZGQgdCB+a2V5IH5kYXRhXSBhZGRzIGEgbmV3IGVudHJ5IHRvIFt0XSBtYXBwaW5nIFtrZXldIHRvIFtkYXRhXSBhbmQgcmV0dXJucyBbYE9rXVxuICAgICAgd2l0aCB0aGUgbmV3IG1hcCwgb3IgaWYgW2tleV0gaXMgYWxyZWFkeSBwcmVzZW50IGluIFt0XSwgcmV0dXJucyBbYER1cGxpY2F0ZV0uICopXG4gIHZhbCBhZGQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBJZiBba2V5XSBpcyBub3QgcHJlc2VudCB0aGVuIGFkZCBhIHNpbmdsZXRvbiBsaXN0LCBvdGhlcndpc2UsIGNvbnMgZGF0YSBvbnRvIHRoZVxuICAgICAgaGVhZCBvZiB0aGUgZXhpc3RpbmcgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogSWYgdGhlIGtleSBpcyBwcmVzZW50LCB0aGVuIHJlbW92ZSBpdHMgaGVhZCBlbGVtZW50OyBpZiB0aGUgcmVzdWx0IGlzIGVtcHR5LCByZW1vdmVcbiAgICAgIHRoZSBrZXkuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIHRoZSBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vbmUuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICd2IGxpc3RcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gcmV0dXJucyBhIG5ldyBtYXAgW21dIHRoYXQgaXMgdGhlIHNhbWUgYXMgW3RdIG9uIGFsbCBrZXlzIGV4Y2VwdFxuICAgICAgZm9yIFtrZXldLCBhbmQgd2hvc2UgdmFsdWUgZm9yIFtrZXldIGlzIGRlZmluZWQgYnkgW2ZdLCBpLmUuLCBbZmluZCBtIGtleSA9IGYgKGZpbmRcbiAgICAgIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuXG4gICgqKiBSZXR1cm5zIFtTb21lIHZhbHVlXSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciBbTm9uZV0gaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndiBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgcmFpc2luZyBbQ2FtbC5Ob3RfZm91bmRdIG9yIFtOb3RfZm91bmRfc11cbiAgICAgIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYW55IGJpbmRpbmcgZm9yIHRoZSBrZXkgaW4gcXVlc3Rpb24gcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbbWVtIG1hcCBrZXldIHRlc3RzIHdoZXRoZXIgW21hcF0gY29udGFpbnMgYSBiaW5kaW5nIGZvciBba2V5XS4gKilcbiAgdmFsIG1lbSA6ICgnaywgXywgJ2NtcCkgdCAtPiAnayAtPiBib29sXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIFtmXSByZXR1cm5zIFtTdG9wXS4gSWYgW2ZdIHJldHVybnMgW1N0b3BdLCB0aGUgZmluYWxcbiAgICAgIHJlc3VsdCBpcyBbVW5maW5pc2hlZF0uIE90aGVyd2lzZSwgdGhlIGZpbmFsIHJlc3VsdCBpcyBbRmluaXNoZWRdLiAqKVxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyByZXBsYWNlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiopXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIENvbnZlcnQgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHRvIGEgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHVzaW5nIFtmXS4gKilcbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgKCoqIExpa2UgW21hcF9rZXlzXSwgYnV0IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XSwgdW50aWwgdGhlIGZpcnN0XG4gICAgICB0aW1lIHRoYXQgW2ZdIHJldHVybnMgW1N0b3AgX10uIElmIFtmXSByZXR1cm5zIFtTdG9wIGZpbmFsXSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gICAgICBpbW1lZGlhdGVseSB3aXRoIHRoZSB2YWx1ZSBbZmluYWxdLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgYW5kIHRoZSBmaW5hbFxuICAgICAgY2FsbCB0byBbZl0gcmV0dXJucyBbQ29udGludWUgbGFzdF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBbZmluaXNoIGxhc3RdLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gZGVjcmVhc2luZyBvcmRlciBvZiBba2V5XS4gKilcbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgKCoqIEZvbGRzIG92ZXIgdHdvIG1hcHMgc2lkZSBieSBzaWRlLCBsaWtlIFtpdGVyMl0uICopXG4gIHZhbCBmb2xkMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2EgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl9tYXBpXSBydW4gaW4gTyhuICogbGdcbiAgICAgIG4pIHRpbWU7IHRoZXkgc2ltcGx5IGFjY3VtdWxhdGUgZWFjaCBrZXkgJiBkYXRhIHBhaXIgcmV0YWluZWQgYnkgW2ZdIGludG8gYSBuZXcgbWFwXG4gICAgICB1c2luZyBbYWRkXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyBmaWx0ZXJlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXBpIHQgfmZdIHJldHVybnMgdHdvIG5ldyBbdF1zLCB3aXRoIGVhY2gga2V5IGluIFt0XSBhcHBlYXJpbmcgaW5cbiAgICAgIGV4YWN0bHkgb25lIG9mIHRoZSByZXN1bHRpbmcgbWFwcyBkZXBlbmRpbmcgb24gaXRzIG1hcHBpbmcgaW4gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUHJvZHVjZXMgW09rXSBvZiBhIG1hcCBpbmNsdWRpbmcgYWxsIGtleXMgaWYgYWxsIGRhdGEgaXMgW09rXSwgb3IgYW4gW0Vycm9yXVxuICAgICAgaW5jbHVkaW5nIGFsbCBlcnJvcnMgb3RoZXJ3aXNlLiAqKVxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFJldHVybnMgYSB0b3RhbCBvcmRlcmluZyBiZXR3ZWVuIG1hcHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHRvdGFsIG9yZGVyaW5nIHVzZWRcbiAgICAgIHRvIGNvbXBhcmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXF1YWwga2V5cyBpbiB0aGUgdHdvIG1hcHMuICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIG1hcHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgbSkuY29tcGFyZV0gb2YgdGhlIG1hcCBbbV0gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnayBIYXNoLmZvbGRlciAtPiAndiBIYXNoLmZvbGRlciAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCBjbXAgbTEgbTJdIHRlc3RzIHdoZXRoZXIgdGhlIG1hcHMgW20xXSBhbmQgW20yXSBhcmUgZXF1YWwsIHRoYXQgaXMsIGNvbnRhaW5cbiAgICAgIHRoZSBzYW1lIGtleXMgYW5kIGFzc29jaWF0ZSBlYWNoIGtleSB3aXRoIHRoZSBzYW1lIHZhbHVlLiAgW2NtcF0gaXMgdGhlIGVxdWFsaXR5XG4gICAgICBwcmVkaWNhdGUgdXNlZCB0byBjb21wYXJlIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sgbGlzdFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgKCoqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBmcm9tIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gKCoqIGRlZmF1bHQgaXMgW2BJbmNyZWFzaW5nXSAqKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiB7MiBBZGRpdGlvbmFsIG9wZXJhdGlvbnMgb24gbWFwc30gKilcblxuICAoKiogTWVyZ2VzIHR3byBtYXBzLiBUaGUgcnVudGltZSBpcyBPKGxlbmd0aCh0MSkgKyBsZW5ndGgodDIpKS4gWW91IHNob3VsZG4ndCB1c2UgdGhpc1xuICAgICAgZnVuY3Rpb24gdG8gbWVyZ2UgYSBsaXN0IG9mIG1hcHM7IGNvbnNpZGVyIHVzaW5nIFttZXJnZV9za2V3ZWRdIGluc3RlYWQuICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICAgIDogICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gcmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uXG4gICAgICBJdCBpcyBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudFxuICAgICAgb2Ygc3RydWN0dXJlLiBUaGUga2V5cyBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlIHdpbGwgYmUgaW4gc29ydGVkIG9yZGVyLlxuXG4gICAgICBJdCBpcyBhc3N1bWVkIHRoYXQgW2RhdGFfZXF1YWxdIGlzIGF0IGxlYXN0IGFzIGVxdWF0aW5nIGFzIHBoeXNpY2FsIGVxdWFsaXR5OiB0aGF0XG4gICAgICBbcGh5c19lcXVhbCB4IHldIGltcGxpZXMgW2RhdGFfZXF1YWwgeCB5XS4gT3RoZXJ3aXNlLCBbc3ltbWV0cmljX2RpZmZdIG1heSBiZWhhdmUgaW5cbiAgICAgIHVuZXhwZWN0ZWQgd2F5cy4gRm9yIGV4YW1wbGUsIHdpdGggW35kYXRhX2VxdWFsOihmdW4gXyBfIC0+IGZhbHNlKV0gaXQgaXMgTk9UXG4gICAgICBuZWNlc3NhcmlseSB0aGUgY2FzZSB0aGUgcmVzdWx0aW5nIGNoYW5nZSBzZXF1ZW5jZSB3aWxsIGNvbnRhaW4gYW4gZWxlbWVudFxuICAgICAgWyhrLCBgVW5lcXVhbCBfKV0gZm9yIGV2ZXJ5IGtleSBba10gc2hhcmVkIGJ5IGJvdGggbWFwcy5cblxuICAgICAgV2FybmluZzogRmxvYXQgZXF1YWxpdHkgdmlvbGF0ZXMgdGhpcyBwcm9wZXJ0eSEgW3BoeXNfZXF1YWwgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXNcbiAgICAgIHRydWUsIGJ1dCBbRmxvYXQuKD0pIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzIGZhbHNlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW2ZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIGZvbGRzIGFjcm9zcyBhbiBpbXBsaWNpdCBzZXF1ZW5jZSBvZiBjaGFuZ2VzXG4gICAgICBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0sIGluIHNvcnRlZCBvcmRlciBieSBrZXlzLiBFcXVpdmFsZW50IHRvXG4gICAgICBbU2VxdWVuY2UuZm9sZCAoc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwpXSwgYW5kIG1vcmUgZWZmaWNpZW50LiAqKVxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooJ2EgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFttaW5fZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtaW5pbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogW21heF9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1heGltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIFttYXBdIGlzIGVtcHR5LiAqKVxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBUaGVzZSBmdW5jdGlvbnMgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgc2ltaWxhciBmdW5jdGlvbnMgaW4gW0xpc3RdLiAqKVxuXG4gIHZhbCBmb3JfYWxsIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGludFxuXG5cbiAgKCoqIFtzcGxpdCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSwgdGhlIG1hcHBpbmcgb2YgW2tleV0gaWZcbiAgICAgIGFueSwgYW5kIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnRdIHJldHVybnMgW2BPayBtYXBdIHdoZXJlIFttYXBdIGNvbnRhaW5zIGFsbCB0aGVcbiAgICAgIFsoa2V5LCB2YWx1ZSldIHBhaXJzIGZyb20gdGhlIHR3byBpbnB1dCBtYXBzIGlmIGFsbCB0aGUga2V5cyBmcm9tIFtsb3dlcl9wYXJ0XSBhcmVcbiAgICAgIGxlc3MgdGhhbiBhbGwgdGhlIGtleXMgZnJvbSBbdXBwZXJfcGFydF0uICBPdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAgW2BPdmVybGFwcGluZ19rZXlfcmFuZ2VzXS5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBuKSB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBsYXJnZXIgaW5wdXQgbWFwLiAgVGhpcyBjYW4gYmVcbiAgICAgIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gW01hcC5tZXJnZV0gb3IgcmVwZWF0ZWQgW01hcC5hZGRdLlxuXG4gICAgICB7W1xuICAgICAgICBhc3NlcnQgKG1hdGNoIE1hcC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgd2l0aFxuICAgICAgICAgIHwgYE9rIHdob2xlX21hcCAtPlxuICAgICAgICAgICAgTWFwLnRvX2FsaXN0IHdob2xlX21hcFxuICAgICAgICAgICAgPSBMaXN0LmFwcGVuZCAodG9fYWxpc3QgbG93ZXJfcGFydCkgKHRvX2FsaXN0IHVwcGVyX3BhcnQpXG4gICAgICAgICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiB0cnVlKTtcbiAgICAgIF19ICopXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gICgqKiBbc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXSByZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGZyb21cbiAgICAgIFt0XSB3aG9zZSBrZXlzIGxpZSBpbnNpZGUgdGhlIGludGVydmFsIGluZGljYXRlZCBieSBbfmxvd2VyX2JvdW5kXSBhbmRcbiAgICAgIFt+dXBwZXJfYm91bmRdLiAgSWYgdGhpcyBpbnRlcnZhbCBpcyBlbXB0eSwgYW4gZW1wdHkgbWFwIGlzIHJldHVybmVkLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgb3V0cHV0IG1hcC4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgb3V0cHV0IG1hcC4gKilcbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmZdIGZvbGRzIFtmXSAod2l0aCBpbml0aWFsIHZhbHVlIFt+aW5pdF0pXG4gICAgICBvdmVyIGFsbCBrZXlzIChhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMpIHRoYXQgYXJlIGluIHRoZSByYW5nZSBbW21pbiwgbWF4XV1cbiAgICAgIChpbmNsdXNpdmUpLiAgKilcbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IG1pbjona1xuICAgIC0+IG1heDona1xuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXhdIHJldHVybnMgYW4gYXNzb2NpYXRpdmUgbGlzdCBvZiB0aGUgZWxlbWVudHMgd2hvc2Uga2V5c1xuICAgICAgbGllIGluIFtbbWluLCBtYXhdXSAoaW5jbHVzaXZlKSwgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGJlaW5nIGF0IHRoZSBoZWFkIG9mIHRoZVxuICAgICAgbGlzdC4gKilcbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sgLT4gbWF4OidrIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIFtjbG9zZXN0X2tleSB0IGRpciBrXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XSB3aXRoIFtrZXldIGNsb3Nlc3QgdG9cbiAgICAgIFtrXSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gaW5lcXVhbGl0eSBib3VuZC5cblxuICAgICAgRm9yIGV4YW1wbGUsIFtjbG9zZXN0X2tleSB0IGBMZXNzX3RoYW4ga10gd291bGQgYmUgdGhlIHBhaXIgd2l0aCB0aGUgY2xvc2VzdCBrZXkgdG9cbiAgICAgIFtrXSB3aGVyZSBba2V5IDwga10uXG5cbiAgICAgIFt0b19zZXF1ZW5jZV0gY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBzYW1lIHJlc3VsdHMgYXMgW2Nsb3Nlc3Rfa2V5XS4gIEl0IGlzIGxlc3NcbiAgICAgIGVmZmljaWVudCBmb3IgaW5kaXZpZHVhbCBsb29rdXBzIGJ1dCBtb3JlIGVmZmljaWVudCBmb3IgZmluZGluZyBtYW55IGVsZW1lbnRzIHN0YXJ0aW5nXG4gICAgICBhdCBzb21lIHZhbHVlLiAqKVxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdrXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbbnRoIHQgbl0gZmluZHMgdGhlIChrZXksIHZhbHVlKSBwYWlyIG9mIHJhbmsgbiAoaS5lLiwgc3VjaCB0aGF0IHRoZXJlIGFyZSBleGFjdGx5IG5cbiAgICAgIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBmb3VuZCBrZXkpLCBpZiBvbmUgZXhpc3RzLiAgTyhsb2cobGVuZ3RoIHQpICsgbikgdGltZS4gKilcbiAgdmFsIG50aCA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICdrICogJ3ZcblxuICAoKiogW3JhbmsgdCBrXSBJZiBba10gaXMgaW4gW3RdLCByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tdIGluXG4gICAgICBbdF0sIGFuZCBbTm9uZV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgcmFuayA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gaW50IG9wdGlvblxuXG5cblxuICAoKiogW3RvX3NlcXVlbmNlID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdF1cbiAgICAgIGdpdmVzIGEgc2VxdWVuY2Ugb2Yga2V5LXZhbHVlIHBhaXJzIGJldHdlZW4gW2tleXNfbGVzc19vcl9lcXVhbF90b10gYW5kXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBpbmNsdXNpdmUsIHByZXNlbnRlZCBpbiBbb3JkZXJdLiAgSWZcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dLCB0aGUgc2VxdWVuY2UgaXNcbiAgICAgIGVtcHR5LlxuXG4gICAgICBXaGVuIG5laXRoZXIgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gbm9yIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFyZVxuICAgICAgcHJvdmlkZWQsIHRoZSBjb3N0IGlzIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSB0byBwcm9kdWNlXG4gICAgICBlYWNoIGVsZW1lbnQuIElmIGVpdGhlciBpcyBwcm92aWRlZCAoYW5kIGlzIHVzZWQgYnkgdGhlIG9yZGVyIHBhcmFtZXRlclxuICAgICAgcHJvdmlkZWQpLCB0aGVuIHRoZSB0aGUgY29zdCBpcyBPKG4pIHVwIGZyb250LCBhbmQgYW1vcnRpemVkIE8oMSkgdG9cbiAgICAgIHByb2R1Y2UgZWFjaCBlbGVtZW50LiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2tcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgd2hpY2ggZWx0XSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XVxuICAgICAgc3BlY2lmaWVkIGJ5IFtjb21wYXJlXSBhbmQgW3doaWNoXSwgaWYgb25lIGV4aXN0cy5cblxuICAgICAgW3RdIG11c3QgYmUgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIFtjb21wYXJlXSwgd2hlcmUgW2NvbXBhcmVdIGFuZFxuICAgICAgW2VsdF0gZGl2aWRlIFt0XSBpbnRvIHRocmVlIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgIDwgZWx0ICB8ICA9IGVsdCAgfCAgPiBlbHQgIHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSByZXR1cm5zIGFuIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieVxuICAgICAgW3doaWNoXS4gIFNlZSB0aGUgZGlhZ3JhbSBiZWxvdyBuZXh0IHRvIHRoZSBbd2hpY2hdIHZhcmlhbnRzLlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbY29tcGFyZV0gb3JkZXJzIFt0XSwgYW5kIGJlaGF2aW9yIGlzXG4gICAgICB1bnNwZWNpZmllZCBpZiBbY29tcGFyZV0gZG9lc24ndCBvcmRlciBbdF0uICBCZWhhdmlvciBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIG9uIHRoZSBib3VuZGFyeSBvZiB0aGVcbiAgICAgIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlXG4gICAgICBsZWZ0IHNlZ21lbnQsIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC5cbiAgICAgIEl0IHJldHVybnMgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc3VicmFuZ2VdIHRha2VzIGEgW2NvbXBhcmVdIGZ1bmN0aW9uIHRoYXQgZGl2aWRlcyBbdF0gaW50byB0aHJlZVxuICAgICAgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50cyB3aXRoIHJlc3BlY3QgdG8gW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXTpcblxuICAgICAge3ZcbiAgICAgICAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEluX3JhbmdlIHwgQWJvdmVfdXBwZXJfYm91bmQgfFxuICAgICAgdn1cblxuICAgICAgYW5kIHJldHVybnMgYSBtYXAgb2YgdGhlIFtJbl9yYW5nZV0gc2VnbWVudC5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBtICsgbikgd2hlcmUgW21dIGlzIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IG1hcCBhbmQgW25dIGlzIHRoZVxuICAgICAgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuIFRoZSBsaW5lYXIgdGVybSBpbiBbbl0gaXMgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuXG5cbiAgICAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBpZiBbY29tcGFyZV0gZG9lcyBub3Qgc2VnbWVudCBbdF0gYXMgc2hvd24gYWJvdmUsIG9yIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBpdHMgaW5wdXRzLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IGludCBNYXAuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSAoU3RyaW5nLnQsIGludCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgTWFwLnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtpbnQgTWFwLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kIHN5bnRheFxuICAgICAgZG9lc24ndCAoYmVjYXVzZSB0aGVyZSBpcyBubyBzdWNoIHRoaW5nIGFzLCBzYXksIFtTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3NdXG4gICAgICAtLSBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLlxuXG4gICAgICBJbiBhZGRpdGlvbiwgd2hlbiB1c2luZyBbQEBkZXJpdmluZ10sIHRoZSByZXF1aXJlbWVudHMgb24gdGhlIGtleSBtb2R1bGUgYXJlIG9ubHlcbiAgICAgIHRob3NlIG5lZWRlZCB0byBzYXRpc2Z5IHdoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGVyaXZlIG9uIHRoZSBtYXAgaXRzZWxmLiBTYXkgeW91XG4gICAgICB3cml0ZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSB0ID0gaW50IE1hcC5NKFgpLnQgW0BAZGVyaXZpbmcgaGFzaF1cbiAgICAgIF19XG5cbiAgICAgIHRoZW4gdGhpcyB3aWxsIGJlIHdlbGwgdHlwZWQgZXhhY3RseSBpZiBbWF0gY29udGFpbnMgYXQgbGVhc3Q6XG4gICAgICAtIGEgdHlwZSBbdF0gd2l0aCBubyBwYXJhbWV0ZXJzXG4gICAgICAtIGEgY29tcGFyYXRvciB3aXRuZXNzXG4gICAgICAtIGEgW2hhc2hfZm9sZF90XSBmdW5jdGlvbiB3aXRoIHRoZSByaWdodCB0eXBlICopXG4gIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgna2V5LCAndmFsdWUsICdjbXApIHQgOj0gKCdrZXksICd2YWx1ZSwgJ2NtcCkgdFxuXG4gICgqKiBbVXNpbmdfY29tcGFyYXRvcl0gaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW01hcF0sIGV4Y2VwdCB0aGVcbiAgICAgIGZ1bmN0aW9ucyB0YWtlIGEgW35jb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XSwgd2hlcmVhcyB0aGUgZnVuY3Rpb25zIGF0IHRoZVxuICAgICAgdG9wbGV2ZWwgb2YgW01hcF0gdGFrZSBhIFsoJ2ssICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnaywgKyd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgdHlwZSAoKydrLCArJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzM1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAgIHZhbCBoYXNoX2ZvbGRfZGlyZWN0XG4gICAgICA6ICAnayBIYXNoLmZvbGRlclxuICAgICAgLT4gJ3YgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgICgqKiBUbyBnZXQgYXJvdW5kIHRoZSB2YWx1ZSByZXN0cmljdGlvbiwgYXBwbHkgdGhlIGZ1bmN0b3IgYW5kIGluY2x1ZGUgaXQuIFlvdVxuICAgICAgICBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgdGhpcyBpbiB0aGUgW1BvbHldIHN1Ym1vZHVsZSBiZWxvdy4gKilcbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpIDogc2lnXG4gICAgICB2YWwgZW1wdHkgOiAoJ2EgSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgTWFwLiAqKVxuICBtb2R1bGUgUG9seSA6XG4gICAgU19wb2x5XG4gICAgd2l0aCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0ID0gKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICBhbmQgdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdHJlZSA9XG4gICAgICAgICAgICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICAoKiogQ3JlYXRlIGEgbWFwIGZyb20gYSB0cmVlIHVzaW5nIHRoZSBnaXZlbiBjb21wYXJhdG9yLiAqKVxuICB2YWwgb2ZfdHJlZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBFeHRyYWN0IGEgdHJlZSBmcm9tIGEgbWFwLiAqKVxuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcblxuXG4gICgqKiB7MiBNb2R1bGVzIGFuZCBtb2R1bGUgdHlwZXMgZm9yIGV4dGVuZGluZyBbTWFwXX1cblxuICAgICAgRm9yIHVzZSBpbiBleHRlbnNpb25zIG9mIEJhc2UsIGxpa2UgW0NvcmVdLiAqKVxuXG4gIG1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBXaXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbiAgbW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IFdpdGhvdXRfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IEFjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IEFjY2Vzc29yczJcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMyA9IEFjY2Vzc29yczNcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IENyZWF0b3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBDcmVhdG9yczJcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID1cbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHxcblxuICBsZXQgdW5yZWFjaGFibGVfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCAoXyA6IHQpIC0+IC5cbiAgOztcblxuICBsZXQgYWxsID0gW11cbiAgbGV0IGhhc2hfZm9sZF90IF8gdCA9IHVucmVhY2hhYmxlX2NvZGUgdFxuICBsZXQgaGFzaCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IGNvbXBhcmUgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBzZXhwX29mX3QgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCB0X29mX3NleHAgc2V4cCA9IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV90eXBlIFwiQmFzZS5Ob3RoaW5nLnRcIiBzZXhwXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbiAgbGV0IHRvX3N0cmluZyA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IG9mX3N0cmluZyAoXyA6IHN0cmluZykgPSBmYWlsd2l0aCBcIkJhc2UuTm90aGluZy5vZl9zdHJpbmc6IG5vdCBzdXBwb3J0ZWRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Ob3RoaW5nXCJcbiAgZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLk5hdGl2ZWludFxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfbmF0aXZlaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKG5hdGl2ZWludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9uYXRpdmVpbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gbmF0aXZlaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAgIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfbmF0aXZlaW50IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9IG5lZ1xuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbnhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVueFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5hdGl2ZWludC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5hdGl2ZWludFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IG51bV9iaXRzID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIk5hdGl2ZWludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuTmF0aXZlaW50LmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5OYXRpdmVpbnQuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLk5hdGl2ZWludC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgKHggOiBuYXRpdmVpbnQpID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5OYXRpdmVpbnQucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLk5hdGl2ZWludC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLk5hdGl2ZWludC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLk5hdGl2ZWludC5wcmVkIHggPSAwblxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIG5hdGl2ZWludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiXG4gICAgICAgICAgIFsgXCJcIiwgc2V4cF9vZl9uYXRpdmVpbnQgaSBdKTtcbiAgICBpZiBDYW1sLk5hdGl2ZWludC5lcXVhbCBpIENhbWwuTmF0aXZlaW50Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuTmF0aXZlaW50LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9uYXRpdmVpbnQgdCA9IHRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50IHQgPSB0XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQubmF0aXZlaW50X3BvcGNvdW50XG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxubGV0IHRvX2ludDMyX3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfdHJ1bmNcbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBDb252LmludDY0X3RvX25hdGl2ZWludF90cnVuY1xubGV0IHRvX2ludDY0ID0gQ29udi5uYXRpdmVpbnRfdG9faW50NjRcbmxldCBwb3cgYiBlID0gb2ZfaW50X2V4biAoSW50X21hdGguUHJpdmF0ZS5pbnRfcG93ICh0b19pbnRfZXhuIGIpICh0b19pbnRfZXhuIGUpKVxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtOYXRpdmVpbnRdIGFuZCBbTmF0aXZlaW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuZXh0ZXJuYWwgYnN3YXAgOiB0IC0+IHQgPSBcIiVic3dhcF9uYXRpdmVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTWFwX2ludGZcblxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5GaW5pc2hlZF9vcl91bmZpbmlzaGVkXG5cbiAgKCogVGhlc2UgdHdvIGZ1bmN0aW9ucyBhcmUgdGVzdGVkIGluIFt0ZXN0X21hcC5tbF0gdG8gbWFrZSBzdXJlIG91ciB1c2Ugb2ZcbiAgICAgW0NhbWwuT2JqLm1hZ2ljXSBpcyBjb3JyZWN0IGFuZCBzYWZlLiAqKVxuICBsZXQgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0ID0gQ2FtbC5PYmoubWFnaWNcbiAgbGV0IHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudCA9IENhbWwuT2JqLm1hZ2ljXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5NZXJnZV9lbGVtZW50XG5cbiAgbGV0IGxlZnQgPSBmdW5jdGlvblxuICAgIHwgYFJpZ2h0IF8gLT4gTm9uZVxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBTb21lIGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHQgPSBmdW5jdGlvblxuICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IFNvbWUgcmlnaHRcbiAgOztcblxuICBsZXQgbGVmdF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBSaWdodCBfIC0+IGRlZmF1bHRcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gbGVmdFxuICA7O1xuXG4gIGxldCByaWdodF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IF8gLT4gZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiByaWdodFxuICA7O1xuXG4gIGxldCB2YWx1ZXMgdCB+bGVmdF9kZWZhdWx0IH5yaWdodF9kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IGxlZnQgLT4gbGVmdCwgcmlnaHRfZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IC0+IGxlZnRfZGVmYXVsdCwgcmlnaHRcbiAgICB8IGBCb3RoIChsZWZ0LCByaWdodCkgLT4gbGVmdCwgcmlnaHRcbiAgOztcbmVuZFxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5leGNlcHRpb24gRHVwbGljYXRlIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRHVwbGljYXRlXSAoZnVuY3Rpb25cbiAgICB8IER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuRHVwbGljYXRlXCJcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgTGVhZiBvZiAnayAqICd2XG4gICAgfCBOb2RlIG9mICgnaywgJ3YpIHQgKiAnayAqICd2ICogKCdrLCAndikgdCAqIGludFxuXG4gIHR5cGUgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIHRcblxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBfLCBoKSAtPiBoXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9rZXkgbG93ZXIgayA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2tleSBrIHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiAoaywgXykgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgfCBOb2RlIChsLCBrLCBfLCByLCBoKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIGspIGNvbXBhcmVfa2V5IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSBrKSB1cHBlciBjb21wYXJlX2tleSByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9rZXkgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9rZXkgdFxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMiAqKVxuICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA9IDAgJiYgaHIgPSAwXG4gICAgdGhlbiBMZWFmICh4LCBkKVxuICAgIGVsc2UgTm9kZSAobCwgeCwgZCwgciwgaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpXG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9IExlYWYgKGtleSwgZGF0YSlcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5NYXAgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpIDogKF8sIF8pIHQgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgaywgdiA9IGYgaSBpblxuICAgICAgICBMZWFmIChrLCB2KVxuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCwgdmwgPSBmIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgMSkgaW5cbiAgICAgICAgTm9kZSAoTGVhZiAoa2wsIHZsKSwgaywgdiwgRW1wdHksIDIpXG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IsIHZyID0gZiAoaSArIDIpIGluXG4gICAgICAgIE5vZGUgKExlYWYgKGtsLCB2bCksIGssIHYsIExlYWYgKGtyLCB2ciksIDIpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgdiByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDJcbiAgICAgICAgIHx8XG4gICAgICAgICBsZXQgazAsIF8gPSBhcnJheS4oMCkgaW5cbiAgICAgICAgIGxldCBrMSwgXyA9IGFycmF5LigxKSBpblxuICAgICAgICAgY29tcGFyZV9rZXkgazAgazEgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0LCBhcnJheV9sZW5ndGhcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSlcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oMCkpIChmc3QgYXJyYXkuKDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LihpKSkgKGZzdCBhcnJheS4oaSArIDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGVsZW1lbnRzIGFyZSBub3Qgb3JkZXJlZFwiKVxuICAgICAgICBkb25lO1xuICAgICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5KSlcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDMgKilcbiAgbGV0IGJhbCBsIHggZCByID1cbiAgICBsZXQgaGwgPSBoZWlnaHQgbCBpblxuICAgIGxldCBociA9IGhlaWdodCByIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaHIgKyAyICopXG4gICAgICB8IE5vZGUgKGxsLCBsdiwgbGQsIGxyLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyXG4gICAgICAgIHRoZW4gY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIChscnYsIGxyZCkgLT4gY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgRW1wdHkpIGxydiBscmQgKGNyZWF0ZSBFbXB0eSB4IGQgcilcbiAgICAgICAgICB8IE5vZGUgKGxybCwgbHJ2LCBscmQsIGxyciwgXykgLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaGwgKyAyICopXG4gICAgICB8IE5vZGUgKHJsLCBydiwgcmQsIHJyLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIChybHYsIHJsZCkgLT4gY3JlYXRlIChjcmVhdGUgbCB4IGQgRW1wdHkpIHJsdiBybGQgKGNyZWF0ZSBFbXB0eSBydiByZCBycilcbiAgICAgICAgICB8IE5vZGUgKHJsbCwgcmx2LCBybGQsIHJsciwgXykgLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycikpKVxuICAgIGVsc2UgY3JlYXRlIGwgeCBkIHJcbiAgOztcblxuICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleSB+c2V4cF9vZl9rZXkgPVxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJbTWFwLmFkZF9leG5dIGdvdCBrZXkgYWxyZWFkeSBwcmVzZW50XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcblxuICBtb2R1bGUgQWRkX29yX3NldCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IEFkZF9leG5faW50ZXJuYWxcbiAgICAgIHwgQWRkX2V4blxuICAgICAgfCBTZXRcbiAgZW5kXG5cblxuICBsZXQgcmVjIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgIH5rZXk6eFxuICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICAgICAgICB+KGFkZF9vcl9zZXQgOiBBZGRfb3Jfc2V0LnQpXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiAoeCwgZGF0YSksIGxlbmd0aCArIDFcbiAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGVcbiAgICAgICAgfCBBZGRfZXhuIC0+IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleVxuICAgICAgICB8IFNldCAtPiBMZWFmICh4LCBkYXRhKSwgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiBOb2RlIChMZWFmICh4LCBkYXRhKSwgdiwgZCwgRW1wdHksIDIpLCBsZW5ndGggKyAxXG4gICAgICBlbHNlIE5vZGUgKEVtcHR5LCB2LCBkLCBMZWFmICh4LCBkYXRhKSwgMiksIGxlbmd0aCArIDFcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGVcbiAgICAgICAgfCBBZGRfZXhuIC0+IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleVxuICAgICAgICB8IFNldCAtPiBOb2RlIChsLCB4LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsLCBsZW5ndGggPVxuICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgfmxlbmd0aCB+a2V5OnggfmRhdGEgbCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0XG4gICAgICAgIGluXG4gICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHIsIGxlbmd0aCA9XG4gICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldCB+bGVuZ3RoIH5rZXk6eCB+ZGF0YSByIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXRcbiAgICAgICAgaW5cbiAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXQ6QWRkX2V4blxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleVxuICAgICAgfmFkZF9vcl9zZXQ6QWRkX2V4bl9pbnRlcm5hbFxuICA7O1xuXG4gIGxldCBzZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXk6KGZ1biBfIC0+IExpc3QgW10pXG4gICAgICB+YWRkX29yX3NldDpTZXRcbiAgOztcblxuICBsZXQgc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleSA9IGZzdCAoc2V0IHQgfmxlbmd0aDowIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KVxuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgbW9kdWxlIEZyYWdtZW50ID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID1cbiAgICAgICAgeyBsZWZ0X3N1YnRyZWUgOiAoJ2ssICd2KSB0XG4gICAgICAgIDsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgfVxuXG4gICAgICBsZXQgc2luZ2xldG9uX3RvX3RyZWVfZXhuID0gZnVuY3Rpb25cbiAgICAgICAgfCB7IGxlZnRfc3VidHJlZSA9IEVtcHR5OyBrZXk7IGRhdGEgfSAtPiBzaW5nbGV0b24ga2V5IGRhdGFcbiAgICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiTWFwLnNpbmdsZXRvbl90b190cmVlX2V4bjogbm90IGEgc2luZ2xldG9uXCJcbiAgICAgIDs7XG5cbiAgICAgIGxldCBzaW5nbGV0b24gfmtleSB+ZGF0YSA9IHsgbGVmdF9zdWJ0cmVlID0gRW1wdHk7IGtleTsgZGF0YSB9XG5cbiAgICAgICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsLmxlZnRfc3VidHJlZSkgLSBoZWlnaHQocil8IDw9IDIsXG4gICAgICAgICBtYXhfa2V5KGwpIDwgbWluX2tleShyKVxuICAgICAgKilcbiAgICAgIGxldCBjb2xsYXBzZSBsIHIgPSBjcmVhdGUgbC5sZWZ0X3N1YnRyZWUgbC5rZXkgbC5kYXRhIHJcblxuICAgICAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwubGVmdF9zdWJ0cmVlKSAtIGhlaWdodChyLmxlZnRfc3VidHJlZSl8IDw9IDIsXG4gICAgICAgICBtYXhfa2V5KGwpIDwgbWluX2tleShyKVxuICAgICAgKilcbiAgICAgIGxldCBqb2luIGwgciA9IHsgciB3aXRoIGxlZnRfc3VidHJlZSA9IGNvbGxhcHNlIGwgci5sZWZ0X3N1YnRyZWUgfVxuICAgICAgbGV0IG1heF9rZXkgdCA9IHQua2V5XG4gICAgZW5kXG5cbiAgICAoKiogQnVpbGQgdHJlZXMgZnJvbSBzaW5nbGV0b25zIGluIGEgYmFsYW5jZWQgd2F5IGJ5IHVzaW5nIHNrZXcgYmluYXJ5IGVuY29kaW5nLlxuICAgICAgICBFYWNoIGxldmVsIGNvbnRhaW5zIHRyZWVzIG9mIHRoZSBzYW1lIGhlaWdodCwgY29uc2VjdXRpdmUgbGV2ZWxzIGhhdmUgY29uc2VjdXRpdmVcbiAgICAgICAgaGVpZ2h0cy4gVGhlcmUgYXJlIG5vIGdhcHMuIFRoZSBmaXJzdCBsZXZlbCBhcmUgc2luZ2xlIGtleXMuXG4gICAgKilcbiAgICB0eXBlICgnaywgJ3YpIHQgPVxuICAgICAgfCBaZXJvIG9mIHVuaXRcbiAgICAgICgqIFt1bml0XSB0byBtYWtlIHBhdHRlcm4gbWF0Y2hpbmcgZmFzdGVyICopXG4gICAgICB8IE9uZSBvZiAoJ2ssICd2KSB0ICogKCdrLCAndikgRnJhZ21lbnQudFxuICAgICAgfCBUd28gb2YgKCdrLCAndikgdCAqICgnaywgJ3YpIEZyYWdtZW50LnQgKiAoJ2ssICd2KSBGcmFnbWVudC50XG5cbiAgICBsZXQgZW1wdHkgPSBaZXJvICgpXG5cbiAgICBsZXQgYWRkX3VuY2hlY2tlZCA9XG4gICAgICBsZXQgcmVjIGdvIHQgeCA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFplcm8gKCkgLT4gT25lICh0LCB4KVxuICAgICAgICB8IE9uZSAodCwgeSkgLT4gVHdvICh0LCB5LCB4KVxuICAgICAgICB8IFR3byAodCwgeiwgeSkgLT4gT25lIChnbyB0IChGcmFnbWVudC5qb2luIHogeSksIHgpXG4gICAgICBpblxuICAgICAgZnVuIHQgfmtleSB+ZGF0YSAtPiBnbyB0IChGcmFnbWVudC5zaW5nbGV0b24gfmtleSB+ZGF0YSlcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWVfdW5jaGVja2VkID1cbiAgICAgIGxldCByZWMgZ28gdCByID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgWmVybyAoKSAtPiByXG4gICAgICAgIHwgT25lICh0LCBsKSAtPiBnbyB0IChGcmFnbWVudC5jb2xsYXBzZSBsIHIpXG4gICAgICAgIHwgVHdvICh0LCBsbCwgbCkgLT4gZ28gdCAoRnJhZ21lbnQuY29sbGFwc2UgKEZyYWdtZW50LmpvaW4gbGwgbCkgcilcbiAgICAgIGluXG4gICAgICBmdW5jdGlvblxuICAgICAgfCBaZXJvICgpIC0+IEVtcHR5XG4gICAgICB8IE9uZSAodCwgcikgLT4gZ28gdCAoRnJhZ21lbnQuc2luZ2xldG9uX3RvX3RyZWVfZXhuIHIpXG4gICAgICB8IFR3byAodCwgbCwgcikgLT4gZ28gKE9uZSAodCwgbCkpIChGcmFnbWVudC5zaW5nbGV0b25fdG9fdHJlZV9leG4gcilcbiAgICA7O1xuXG4gICAgbGV0IG1heF9rZXkgPSBmdW5jdGlvblxuICAgICAgfCBaZXJvICgpIC0+IE5vbmVcbiAgICAgIHwgT25lIChfLCByKSB8IFR3byAoXywgXywgcikgLT4gU29tZSAoRnJhZ21lbnQubWF4X2tleSByKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXkgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgbGV0IGJ1aWxkZXIsIGxlbmd0aCA9XG4gICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICBzZXFcbiAgICAgICAgICB+aW5pdDooQnVpbGRfaW5jcmVhc2luZy5lbXB0eSwgMClcbiAgICAgICAgICB+ZjooZnVuIChidWlsZGVyLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBtYXRjaCBCdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgYnVpbGRlciB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJlX2tleSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZTogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICAgICAgICB8IF8gLT4gQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIGJ1aWxkZXIgfmtleSB+ZGF0YSwgbGVuZ3RoICsgMSlcbiAgICAgIGluXG4gICAgICBPayAoQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCBidWlsZGVyLCBsZW5ndGgpKVxuICA7O1xuXG4gICgqIExpa2UgW2JhbF0gYnV0IGFsbG93cyBhbnkgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiBbbF0gYW5kIFtyXS5cblxuICAgICBPKHxoZWlnaHQgbCAtIGhlaWdodCByfCkgKilcbiAgbGV0IHJlYyBqb2luIGwgayBkIHIgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBsLCByIHdpdGhcbiAgICB8IEVtcHR5LCBfIC0+IHNldCcgciBrIGQgfmNvbXBhcmVfa2V5XG4gICAgfCBfLCBFbXB0eSAtPiBzZXQnIGwgayBkIH5jb21wYXJlX2tleVxuICAgIHwgTGVhZiAobGssIGxkKSwgXyAtPiBzZXQnIChzZXQnIHIgayBkIH5jb21wYXJlX2tleSkgbGsgbGQgfmNvbXBhcmVfa2V5XG4gICAgfCBfLCBMZWFmIChyaywgcmQpIC0+IHNldCcgKHNldCcgbCBrIGQgfmNvbXBhcmVfa2V5KSByayByZCB+Y29tcGFyZV9rZXlcbiAgICB8IE5vZGUgKGxsLCBsaywgbGQsIGxyLCBsaCksIE5vZGUgKHJsLCByaywgcmQsIHJyLCByaCkgLT5cbiAgICAgICgqIFtiYWxdIHJlcXVpcmVzIGhlaWdodCBkaWZmZXJlbmNlIDw9IDMuICopXG4gICAgICBpZiBsaCA+IHJoICsgM1xuICAgICAgKCogW2hlaWdodCBsciA+PSBoZWlnaHQgcl0sXG4gICAgICAgICB0aGVyZWZvcmUgW2hlaWdodCAoam9pbiBsciBrIGQgciAuLi4pXSBpcyBbaGVpZ2h0IHJsICsgMV0gb3IgW2hlaWdodCBybF1cbiAgICAgICAgIHRoZXJlZm9yZSB0aGUgaGVpZ2h0IGRpZmZlcmVuY2Ugd2l0aCBbbGxdIHdpbGwgYmUgPD0gMyAqKVxuICAgICAgdGhlbiBiYWwgbGwgbGsgbGQgKGpvaW4gbHIgayBkIHIgfmNvbXBhcmVfa2V5KVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgM1xuICAgICAgdGhlbiBiYWwgKGpvaW4gbCBrIGQgcmwgfmNvbXBhcmVfa2V5KSByayByZCByclxuICAgICAgZWxzZSBiYWwgbCBrIGQgclxuICA7O1xuXG4gIGxldCByZWMgc3BsaXQgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICB8IExlYWYgKGssIGQpIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgeCBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIEVtcHR5LCBTb21lIChrLCBkKSwgRW1wdHlcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgdFxuICAgICAgZWxzZSB0LCBOb25lLCBFbXB0eVxuICAgIHwgTm9kZSAobCwgaywgZCwgciwgXykgLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSB4IGsgaW5cbiAgICAgIGlmIGNtcCA9IDBcbiAgICAgIHRoZW4gbCwgU29tZSAoaywgZCksIHJcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsbCwgbWF5YmUsIGxyID0gc3BsaXQgbCB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBsbCwgbWF5YmUsIGpvaW4gbHIgayBkIHIgfmNvbXBhcmVfa2V5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBybCwgbWF5YmUsIHJyID0gc3BsaXQgciB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBqb2luIGwgayBkIHJsIH5jb21wYXJlX2tleSwgbWF5YmUsIHJyKVxuICA7O1xuXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byB4IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGxlZnQsIGJvdW5kYXJ5X29wdCwgcmlnaHQgPSBzcGxpdCB0IHggfmNvbXBhcmVfa2V5IGluXG4gICAgbWF0Y2ggYm91bmRhcnlfb3B0IHdpdGhcbiAgICB8IE5vbmUgLT4gbGVmdCwgcmlnaHRcbiAgICB8IFNvbWUgKGtleSwgZGF0YSkgLT5cbiAgICAgIGxldCBpbnNlcnRfaW50byB0cmVlID0gZnN0IChzZXQgdHJlZSB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXkpIGluXG4gICAgICAobWF0Y2ggaW50byB3aXRoXG4gICAgICAgfCBgTGVmdCAtPiBpbnNlcnRfaW50byBsZWZ0LCByaWdodFxuICAgICAgIHwgYFJpZ2h0IC0+IGxlZnQsIGluc2VydF9pbnRvIHJpZ2h0KVxuICA7O1xuXG4gIGxldCBzcGxpdF9yYW5nZVxuICAgICAgICB0XG4gICAgICAgIH4obG93ZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgICAgICB+KHVwcGVyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgPVxuICAgIGlmIE1heWJlX2JvdW5kLmJvdW5kc19jcm9zc2VkXG4gICAgICAgICB+Y29tcGFyZTpjb21wYXJlX2tleVxuICAgICAgICAgfmxvd2VyOmxvd2VyX2JvdW5kXG4gICAgICAgICB+dXBwZXI6dXBwZXJfYm91bmRcbiAgICB0aGVuIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZWZ0LCBtaWRfYW5kX3JpZ2h0ID1cbiAgICAgICAgbWF0Y2ggbG93ZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBlbXB0eSwgdFxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGV0IG1pZCwgcmlnaHQgPVxuICAgICAgICBtYXRjaCB1cHBlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IG1pZF9hbmRfcmlnaHQsIGVtcHR5XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+XG4gICAgICAgICAgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxlZnQsIG1pZCwgcmlnaHQpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAodiwgZCkgLT4gaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIFNvbWUgZCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGQgZWxzZSBmaW5kIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZGF0YSA9IGRhdGEgOjogT3B0aW9uLnZhbHVlIChmaW5kIHQga2V5IH5jb21wYXJlX2tleSkgfmRlZmF1bHQ6W10gaW5cbiAgICBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggZmluZCB0IHggfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gW11cbiAgICB8IFNvbWUgbCAtPiBsXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgaWZfbm90X2ZvdW5kIGtleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgcmFpc2UgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIk1hcC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHNleHBfb2Zfa2V5IGtleSBdKSlcbiAgICBpblxuICAgIGxldCByZWMgZmluZF9leG4gdCB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gZCBlbHNlIGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIGQgZWxzZSBmaW5kX2V4biAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgeCB+Y29tcGFyZV9rZXkgPSBPcHRpb24uaXNfc29tZSAoZmluZCB0IHggfmNvbXBhcmVfa2V5KVxuXG4gIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCBkKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoRW1wdHksIGssIGQsIF8sIF8pIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChsLCBfLCBfLCBfLCBfKSAtPiBtaW5fZWx0IGxcbiAgOztcblxuICBleGNlcHRpb24gTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBleGNlcHRpb24gTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgbWluX2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWluX2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgZCkgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKF8sIGssIGQsIEVtcHR5LCBfKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoXywgXywgXywgciwgXykgLT4gbWF4X2VsdCByXG4gIDs7XG5cbiAgbGV0IG1heF9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1heF9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSAoRW1wdHksIF8sIF8sIHIsIF8pIC0+IHJcbiAgICB8IE5vZGUgKGwsIHgsIGQsIHIsIF8pIC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgeCBkIHJcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbWF4X2VsdCBsb3dlcl9wYXJ0LCBtaW5fZWx0IHVwcGVyX3BhcnQgd2l0aFxuICAgIHwgTm9uZSwgXyAtPiBgT2sgdXBwZXJfcGFydFxuICAgIHwgXywgTm9uZSAtPiBgT2sgbG93ZXJfcGFydFxuICAgIHwgU29tZSAobWF4X2xvd2VyLCBfKSwgU29tZSAobWluX3VwcGVyLCB2KSB3aGVuIGNvbXBhcmVfa2V5IG1heF9sb3dlciBtaW5fdXBwZXIgPCAwIC0+XG4gICAgICBsZXQgdXBwZXJfcGFydF93aXRob3V0X21pbiA9IHJlbW92ZV9taW5fZWx0IHVwcGVyX3BhcnQgaW5cbiAgICAgIGBPayAoam9pbiB+Y29tcGFyZV9rZXkgbG93ZXJfcGFydCBtaW5fdXBwZXIgdiB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluKVxuICAgIHwgXyAtPiBgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc1xuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSA9XG4gICAgKCogVGhpcyBhc3N1bWVzIHRoYXQgbWluIDw9IG1heCwgd2hpY2ggaXMgY2hlY2tlZCBieSB0aGUgb3V0ZXIgZnVuY3Rpb24uICopXG4gICAgbGV0IHJlYyBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGluaXRcbiAgICAgIHwgTGVhZiAoaywgZCkgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBtaW4gPCAwIHx8IGNvbXBhcmVfa2V5IGsgbWF4ID4gMFxuICAgICAgICB0aGVuICgqIGsgPCBtaW4gfHwgayA+IG1heCAqKVxuICAgICAgICAgIGluaXRcbiAgICAgICAgZWxzZSBmIH5rZXk6ayB+ZGF0YTpkIGluaXRcbiAgICAgIHwgTm9kZSAobCwgaywgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGNfbWluID0gY29tcGFyZV9rZXkgayBtaW4gaW5cbiAgICAgICAgaWYgY19taW4gPCAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrIDwgbWluLCB0aGVuIHRoaXMgbm9kZSBhbmQgaXRzIGxlZnQgYnJhbmNoIGFyZSBvdXRzaWRlIG91ciByYW5nZSAqKVxuICAgICAgICAgIGdvIHIgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleVxuICAgICAgICBlbHNlIGlmIGNfbWluID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA9IG1pbiwgdGhlbiB0aGlzIG5vZGUncyBsZWZ0IGJyYW5jaCBpcyBvdXRzaWRlIG91ciByYW5nZSAqKVxuICAgICAgICAgIGdvIHIgfm1pbiB+bWF4IH5pbml0OihmIH5rZXk6ayB+ZGF0YTpkIGluaXQpIH5mIH5jb21wYXJlX2tleVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBrID4gbWluICopXG4gICAgICAgICAgbGV0IHogPSBnbyBsIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBsZXQgY19tYXggPSBjb21wYXJlX2tleSBrIG1heCBpblxuICAgICAgICAgICgqIGlmIGsgPiBtYXgsIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICBpZiBjX21heCA+IDBcbiAgICAgICAgICB0aGVuIHpcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCB6ID0gZiB+a2V5OmsgfmRhdGE6ZCB6IGluXG4gICAgICAgICAgICAoKiBpZiBrID0gbWF4LCB0aGVuIHdlIGZvbGQgaW4gdGhpcyBvbmUgbGFzdCB2YWx1ZSBhbmQgd2UncmUgZG9uZSAqKVxuICAgICAgICAgICAgaWYgY19tYXggPSAwIHRoZW4geiBlbHNlIGdvIHIgfm1pbiB+bWF4IH5pbml0OnogfmYgfmNvbXBhcmVfa2V5KSlcbiAgICBpblxuICAgIGZ1biB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgLT5cbiAgICAgIGlmIGNvbXBhcmVfa2V5IG1pbiBtYXggPD0gMCB0aGVuIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBlbHNlIGluaXRcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LnJldlxuICAgICAgKGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgICAgICB0XG4gICAgICAgICB+bWluXG4gICAgICAgICB+bWF4XG4gICAgICAgICB+aW5pdDpbXVxuICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIGwgLT4gKGtleSwgZGF0YSkgOjogbClcbiAgICAgICAgIH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgY29uY2F0X3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gIGV4Y2VwdGlvbiBSZW1vdmVfbm9fb3BcblxuICBsZXQgcmVtb3ZlIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyByZW1vdmVfbG9vcCB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBSZW1vdmVfbm9fb3BcbiAgICAgIHwgTGVhZiAodiwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgeCB2ID0gMFxuICAgICAgICB0aGVuIEVtcHR5LCBsZW5ndGggLSAxXG4gICAgICAgIGVsc2UgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFJlbW92ZV9ub19vcFxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIGNvbmNhdF91bmNoZWNrZWQgbCByLCBsZW5ndGggLSAxXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHJlbW92ZV9sb29wIGwgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSByZW1vdmVfbG9vcCByIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdHJ5IHJlbW92ZV9sb29wIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBSZW1vdmVfbm9fb3AgLT4gdCwgbGVuZ3RoXG4gIDs7XG5cbiAgKCogVXNlIGV4Y2VwdGlvbiB0byBhdm9pZCB0cmVlLXJlYnVpbGQgaW4gbm8tb3AgY2FzZSAqKVxuICBleGNlcHRpb24gQ2hhbmdlX25vX29wXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyBjaGFuZ2VfY29yZSB0IGtleSBmID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAobWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiByYWlzZSBDaGFuZ2Vfbm9fb3AgKCogZXF1aXZhbGVudCB0byByZXR1cm5pbmc6IEVtcHR5ICopXG4gICAgICAgICB8IFNvbWUgZGF0YSAtPiBMZWFmIChrZXksIGRhdGEpLCBsZW5ndGggKyAxKVxuICAgICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eSwgbGVuZ3RoIC0gMVxuICAgICAgICAgIHwgU29tZSBkJyAtPiBMZWFmICh2LCBkJyksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgRW1wdHksIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIEVtcHR5IHYgZCByLCBsZW5ndGgpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGNvbmNhdF91bmNoZWNrZWQgbCByLCBsZW5ndGggLSAxXG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZSAobCwga2V5LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBsIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIHIga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdHJ5IGNoYW5nZV9jb3JlIHQga2V5IGYgd2l0aFxuICAgIHwgQ2hhbmdlX25vX29wIC0+IHQsIGxlbmd0aFxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgdXBkYXRlX2NvcmUgdCBrZXkgZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgbGV0IGRhdGEgPSBmIE5vbmUgaW5cbiAgICAgICAgTGVhZiAoa2V5LCBkYXRhKSwgbGVuZ3RoICsgMVxuICAgICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBkJyA9IGYgKFNvbWUgZCkgaW5cbiAgICAgICAgICBMZWFmICh2LCBkJyksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgRW1wdHksIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIEVtcHR5IHYgZCByLCBsZW5ndGgpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGRhdGEgPSBmIChTb21lIGQpIGluXG4gICAgICAgICAgTm9kZSAobCwga2V5LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSB1cGRhdGVfY29yZSBsIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIHIga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdXBkYXRlX2NvcmUgdCBrZXkgZlxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGNoYW5nZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSB8IFNvbWUgKFtdIHwgWyBfIF0pIC0+IE5vbmVcbiAgICAgIHwgU29tZSAoXyA6OiAoXyA6OiBfIGFzIG5vbl9lbXB0eV90YWlsKSkgLT4gU29tZSBub25fZW1wdHlfdGFpbClcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJfa2V5cyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmICh2LCBfKSAtPiBmIHZcbiAgICB8IE5vZGUgKGwsIHYsIF8sIHIsIF8pIC0+XG4gICAgICBpdGVyX2tleXMgfmYgbDtcbiAgICAgIGYgdjtcbiAgICAgIGl0ZXJfa2V5cyB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKF8sIGQpIC0+IGYgZFxuICAgIHwgTm9kZSAobCwgXywgZCwgciwgXykgLT5cbiAgICAgIGl0ZXIgfmYgbDtcbiAgICAgIGYgZDtcbiAgICAgIGl0ZXIgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlcmkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGl0ZXJpIH5mIGw7XG4gICAgICBmIH5rZXk6diB+ZGF0YTpkO1xuICAgICAgaXRlcmkgfmYgclxuICA7O1xuXG4gIGxldCBpdGVyaV91bnRpbCA9XG4gICAgbGV0IHJlYyBpdGVyaV91bnRpbF9sb29wIHQgfmYgOiBDb250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgKG1hdGNoIGl0ZXJpX3VudGlsX2xvb3AgfmYgbCB3aXRoXG4gICAgICAgICB8IFN0b3AgLT4gU3RvcFxuICAgICAgICAgfCBDb250aW51ZSAtPlxuICAgICAgICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgLT4gU3RvcFxuICAgICAgICAgICAgfCBDb250aW51ZSAtPiBpdGVyaV91bnRpbF9sb29wIH5mIHIpKVxuICAgIGluXG4gICAgZnVuIHQgfmYgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC5vZl9jb250aW51ZV9vcl9zdG9wIChpdGVyaV91bnRpbF9sb29wIHQgfmYpXG4gIDs7XG5cbiAgbGV0IHJlYyBtYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiAodiwgZCkgLT4gTGVhZiAodiwgZiBkKVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBsJyA9IG1hcCB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgIGxldCByJyA9IG1hcCB+ZiByIGluXG4gICAgICBOb2RlIChsJywgdiwgZCcsIHInLCBoKVxuICA7O1xuXG4gIGxldCByZWMgbWFwaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmICh2LCBkKSAtPiBMZWFmICh2LCBmIH5rZXk6diB+ZGF0YTpkKVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBsJyA9IG1hcGkgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgbGV0IHInID0gbWFwaSB+ZiByIGluXG4gICAgICBOb2RlIChsJywgdiwgZCcsIHInLCBoKVxuICA7O1xuXG4gIGxldCByZWMgZm9sZCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBmb2xkIH5mIHIgfmluaXQ6KGYgfmtleTp2IH5kYXRhOmQgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgZm9sZF91bnRpbF9sb29wIHQgfmFjYyB+ZiA6IChfLCBfKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2NcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgKG1hdGNoIGZvbGRfdW50aWxfbG9vcCBsIH5hY2MgfmYgd2l0aFxuICAgICAgICAgfCBTdG9wIGZpbmFsIC0+IFN0b3AgZmluYWxcbiAgICAgICAgIHwgQ29udGludWUgYWNjIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIGFjYyB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgICAgfCBDb250aW51ZSBhY2MgLT4gZm9sZF91bnRpbF9sb29wIHIgfmFjYyB+ZikpXG4gICAgaW5cbiAgICBtYXRjaCBmb2xkX3VudGlsX2xvb3AgdCB+YWNjOmluaXQgfmYgd2l0aFxuICAgIHwgQ29udGludWUgYWNjIC0+IGZpbmlzaCBhY2NcbiAgICB8IFN0b3Agc3RvcCAtPiBzdG9wXG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkX3JpZ2h0IHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBmb2xkX3JpZ2h0IH5mIGwgfmluaXQ6KGYgfmtleTp2IH5kYXRhOmQgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiBrZXkgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG5cbiAgbGV0IGZpbHRlciB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIGRhdGEgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYgfmtleSB+ZGF0YSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgbWF0Y2ggZiBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhY2N1LCBsZW5ndGhcbiAgICAgIHwgU29tZSBiIC0+IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGE6YiBhY2N1IH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhY2N1LCBsZW5ndGhcbiAgICAgIHwgU29tZSBiIC0+IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGE6YiBhY2N1IH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OigoRW1wdHksIDApLCAoRW1wdHksIDApKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIChwYWlyMSwgcGFpcjIpIC0+XG4gICAgICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgeCAtPlxuICAgICAgICAgIGxldCB0LCBsZW5ndGggPSBwYWlyMSBpblxuICAgICAgICAgIHNldCB0IH5rZXkgfmRhdGE6eCB+Y29tcGFyZV9rZXkgfmxlbmd0aCwgcGFpcjJcbiAgICAgICAgfCBTZWNvbmQgeSAtPlxuICAgICAgICAgIGxldCB0LCBsZW5ndGggPSBwYWlyMiBpblxuICAgICAgICAgIHBhaXIxLCBzZXQgdCB+a2V5IH5kYXRhOnkgfmNvbXBhcmVfa2V5IH5sZW5ndGgpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICAgIGlmIGYgZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbiAgOztcblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0ID1cbiAgICAgIHwgRW5kXG4gICAgICB8IE1vcmUgb2YgJ2sgKiAndiAqICgnaywgJ3YpIHRyZWUgKiAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0XG5cbiAgICBsZXQgcmVjIGNvbnMgdCAoZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0KSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBjb25zIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgdCAoZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfdHJlZSB0cmVlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPSBjb25zIHRyZWUgRW5kXG4gICAgbGV0IG9mX3RyZWVfcmlnaHQgdHJlZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCB0cmVlIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiAodiwgZCkgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIGQsIEVtcHR5LCAxKSkgZVxuICAgICAgICB8IE5vZGUgKF8sIHYsIF8sIHIsIF8pIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBsb29wIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiAodiwgZCkgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIGQsIEVtcHR5LCAxKSkgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIF8sIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBsb29wIHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIGQxLCByMSwgZTEpLCBNb3JlICh2MiwgZDIsIHIyLCBlMikgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZGF0YSBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgICAgdGhlbiBsb29wIGUxIGUyXG4gICAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBjb21wYXJlX2tleSBkYXRhX2VxdWFsIHQxIHQyID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gdHJ1ZVxuICAgICAgICB8IEVuZCwgXyB8IF8sIEVuZCAtPiBmYWxzZVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgY29tcGFyZV9rZXkgdjEgdjIgPSAwXG4gICAgICAgICAgJiYgZGF0YV9lcXVhbCBkMSBkMlxuICAgICAgICAgICYmIGlmIHBoeXNfZXF1YWwgcjEgcjIgdGhlbiBsb29wIGUxIGUyIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGZvbGQgfmluaXQgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gaW5pdFxuICAgICAgfCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgIGxldCBuZXh0ID0gZiB+a2V5IH5kYXRhIGluaXQgaW5cbiAgICAgICAgZm9sZCAoY29ucyB0cmVlIGVudW0pIH5pbml0Om5leHQgfmZcbiAgICA7O1xuXG4gICAgbGV0IGZvbGQyIGNvbXBhcmVfa2V5IHQxIHQyIH5pbml0IH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiBjdXJyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBjdXJyXG4gICAgICAgIHwgRW5kLCBfIC0+XG4gICAgICAgICAgZm9sZCB0MiB+aW5pdDpjdXJyIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gZiB+a2V5IH5kYXRhOihgUmlnaHQgZGF0YSkgYWNjKVxuICAgICAgICB8IF8sIEVuZCAtPlxuICAgICAgICAgIGZvbGQgdDEgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYExlZnQgZGF0YSkgYWNjKVxuICAgICAgICB8IE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSwgTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgQm90aCAodjEsIHYyKSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgTGVmdCB2MSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIgbmV4dClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsyIH5kYXRhOihgUmlnaHQgdjIpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBpbml0XG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGtleSwgYFJpZ2h0IGRhdGEpLCAoRW5kLCBjb25zIHRyZWUgZW51bSkpXG4gICAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSwgRW5kIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGtleSwgYExlZnQgZGF0YSksIChjb25zIHRyZWUgZW51bSwgRW5kKSlcbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9XG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgICAgdGhlbiBlbnVtMSwgZW51bTJcbiAgICAgICAgICAgICAgZWxzZSBjb25zIHRyZWUxIGVudW0xLCBjb25zIHRyZWUyIGVudW0yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgZGF0YV9lcXVhbCB2MSB2MlxuICAgICAgICAgICAgdGhlbiBTZXF1ZW5jZS5TdGVwLlNraXAgbmV4dF9zdGF0ZVxuICAgICAgICAgICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazEsIGBVbmVxdWFsICh2MSwgdjIpKSwgbmV4dF9zdGF0ZSkpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMSwgYExlZnQgdjEpLCAoY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQpKVxuICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsyLCBgUmlnaHQgdjIpLCAobGVmdCwgY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6KG9mX3RyZWUgdDEsIG9mX3RyZWUgdDIpIH5mOnN0ZXBcbiAgICA7O1xuXG4gICAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICAgIGxldCByZW1vdmUgYWNjIGsgdiA9IGYgYWNjIChrLCBgTGVmdCB2KSBpblxuICAgICAgbGV0IHJlYyBsb29wIGxlZnQgcmlnaHQgYWNjID1cbiAgICAgICAgbWF0Y2ggbGVmdCwgcmlnaHQgd2l0aFxuICAgICAgICB8IEVuZCwgZW51bSAtPiBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBlbnVtLCBFbmQgLT4gZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGlmIGRhdGFfZXF1YWwgdjEgdjIgdGhlbiBhY2MgZWxzZSBmIGFjYyAoazEsIGBVbmVxdWFsICh2MSwgdjIpKSBpblxuICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgdGhlbiBsb29wIGVudW0xIGVudW0yIGFjY1xuICAgICAgICAgICAgZWxzZSBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrMSB2MSBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgcmlnaHQgYWNjKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgazIgdjIgaW5cbiAgICAgICAgICAgIGxvb3AgbGVmdCAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgKG9mX3RyZWUgdDEpIChvZl90cmVlIHQyKSBpbml0XG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGssIHYpLCBFbnVtLmNvbnMgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZSB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrLCB2KSwgRW51bS5jb25zX3JpZ2h0IHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWVfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmdfa2V5KVxuICAgICAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgICAgdFxuICAgID1cbiAgICBsZXQgaW5jbHVzaXZlX2JvdW5kIHNpZGUgdCBib3VuZCA9XG4gICAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IGwsIG1heWJlLCByID0gc3BsaXQgdCBib3VuZCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgIGxldCB0ID0gc2lkZSAobCwgcikgaW5cbiAgICAgIG1hdGNoIG1heWJlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0XG4gICAgICB8IFNvbWUgKGtleSwgZGF0YSkgLT4gc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleVxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmdfa2V5IC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGtleXNfbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleTprZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gdFxuICAgIHwgYERlY3JlYXNpbmdfa2V5IC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgc25kKSBpblxuICAgICAgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleTprZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgRW51bS5jb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKVxuICA7O1xuXG4gIGxldCBlcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIEVudW0uZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMlxuICAgICAgY29tcGFyZV9rZXlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDEpXG4gICAgICAoRW51bS5vZl90cmVlIHQyKVxuICAgICAgfmluaXQ6KClcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSAoKSAtPiBmIH5rZXkgfmRhdGEpXG4gIDs7XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMiBjb21wYXJlX2tleSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKSB+ZiB+aW5pdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICgqIFtFbnVtLmZvbGRfZGlmZnNdIGlzIGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgaXMgY29uc2lkZXJhYmx5XG4gICAgICAgc2xvd2VyLCBhcyB3ZSBoYXZlIHRvIGFsbG9jYXRlIHF1aXRlIGEgbG90IG9mIHN0YXRlIHRvIHRyYWNrIGVudW1lcmF0aW9uIG9mIGEgdHJlZS5cbiAgICAgICBBdm9pZCBpZiB3ZSBjYW4uXG4gICAgKilcbiAgICBsZXQgc2xvdyB4IHkgfmluaXQgPSBFbnVtLmZvbGRfc3ltbWV0cmljX2RpZmYgeCB5IH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+ZiB+aW5pdCBpblxuICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICBsZXQgZGVsdGEgYWNjIGsgdiB2JyA9IGlmIGRhdGFfZXF1YWwgdiB2JyB0aGVuIGFjYyBlbHNlIGYgYWNjIChrLCBgVW5lcXVhbCAodiwgdicpKSBpblxuICAgICgqIElmIHR3byB0cmVlcyBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBhdCB0aGUgcm9vdCAoYW5kIHRoZSBzYW1lIGtleSwgaWYgdGhleSdyZVxuICAgICAgIFtOb2RlXXMpIHdlIGNhbiB0cml2aWFsbHkgZGlmZiBlYWNoIHN1YnBhcnQgaW4gb2J2aW91cyB3YXlzLiAqKVxuICAgIGxldCByZWMgbG9vcCB0IHQnIGFjYyA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHQgdCdcbiAgICAgIHRoZW4gYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCwgdCcgd2l0aFxuICAgICAgICB8IEVtcHR5LCBuZXdfdmFscyAtPlxuICAgICAgICAgIGZvbGQgbmV3X3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBvbGRfdmFscywgRW1wdHkgLT5cbiAgICAgICAgICBmb2xkIG9sZF92YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgTGVhZiAoaywgdiksIExlYWYgKGsnLCB2JykgLT5cbiAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgayBrJyB3aXRoXG4gICAgICAgICAgIHwgeCB3aGVuIHggPSAwIC0+IGRlbHRhIGFjYyBrIHYgdidcbiAgICAgICAgICAgfCB4IHdoZW4geCA8IDAgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrIHYgaW5cbiAgICAgICAgICAgICBhZGQgYWNjIGsnIHYnXG4gICAgICAgICAgIHwgXyAoKiB3aGVuIHggPiAwICopIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgaycgdicgaW5cbiAgICAgICAgICAgICByZW1vdmUgYWNjIGsgdilcbiAgICAgICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSwgTm9kZSAobCcsIGsnLCB2JywgcicsIF8pIHdoZW4gY29tcGFyZV9rZXkgayBrJyA9IDAgLT5cbiAgICAgICAgICBsZXQgYWNjID0gbG9vcCBsIGwnIGFjYyBpblxuICAgICAgICAgIGxldCBhY2MgPSBkZWx0YSBhY2MgayB2IHYnIGluXG4gICAgICAgICAgbG9vcCByIHInIGFjY1xuICAgICAgICAoKiBPdXIgcm9vdHMgYXJlbid0IHRoZSBzYW1lIGtleS4gRmFsbGJhY2sgdG8gdGhlIHNsb3cgbW9kZS4gVHJlZXMgd2l0aCBzbWFsbFxuICAgICAgICAgICBkaWZmcyB3aWxsIG9ubHkgZG8gdGhpcyBvbiB2ZXJ5IHNtYWxsIHBhcnRzIG9mIHRoZSB0cmVlIChob3BlZnVsbHkgLSBpZiB0aGVcbiAgICAgICAgICAgb3ZlcmFsbCByb290IGlzIHJlYmFsYW5jZWQsIHdlJ2xsIGVhdCB0aGUgd2hvbGUgY29zdCwgdW5mb3J0dW5hdGVseS4pICopXG4gICAgICAgIHwgTm9kZSBfLCBOb2RlIF8gfCBOb2RlIF8sIExlYWYgXyB8IExlYWYgXywgTm9kZSBfIC0+IHNsb3cgdCB0JyB+aW5pdDphY2MpXG4gICAgaW5cbiAgICBsb29wIHQxIHQyIGluaXRcbiAgOztcblxuICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAobCwgXywgXywgciwgXykgLT4gbGVuZ3RoIGwgKyBsZW5ndGggciArIDFcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdCA9XG4gICAgZm9sZFxuICAgICAgdFxuICAgICAgfmluaXQ6KGhhc2hfZm9sZF9pbnQgc3RhdGUgKGxlbmd0aCB0KSlcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBzdGF0ZSAtPiBoYXNoX2ZvbGRfZGF0YSAoaGFzaF9mb2xkX2tleSBzdGF0ZSBrZXkpIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gbGlzdCAtPiBrZXkgOjogbGlzdCkgdCB+aW5pdDpbXVxuICBsZXQgZGF0YSB0ID0gZm9sZF9yaWdodCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgdCB+aW5pdDpbXVxuXG4gIG1vZHVsZSB0eXBlIEZvbGRhYmxlID0gc2lnXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcblxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiXG4gIGVuZFxuXG4gIG1vZHVsZSBPZl9mb2xkYWJsZSAoTSA6IEZvbGRhYmxlKSA9IHN0cnVjdFxuICAgIGxldCBvZl9mb2xkYWJsZV9mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIChhY2N1bSwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgcHJldl9kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbml0XG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldlxuICAgICAgICBpblxuICAgICAgICBsZXQgZGF0YSA9IGYgcHJldl9kYXRhIGRhdGEgaW5cbiAgICAgICAgc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9yZWR1Y2UgZm9sZGFibGUgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKGFjY3VtLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgIGxldCBuZXdfZGF0YSA9XG4gICAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgICAgIHwgU29tZSBwcmV2IC0+IGYgcHJldiBkYXRhXG4gICAgICAgIGluXG4gICAgICAgIHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGE6bmV3X2RhdGEgfmNvbXBhcmVfa2V5KVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgbWFwID1cbiAgICAgICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuICh0LCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBsZXQgKChfLCBsZW5ndGgnKSBhcyBhY2MpID0gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleSBpblxuICAgICAgICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyB0aGVuIHIucmV0dXJuIChgRHVwbGljYXRlX2tleSBrZXkpIGVsc2UgYWNjKVxuICAgICAgICBpblxuICAgICAgICBgT2sgbWFwKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfb3JfZXJyb3IgZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4gUmVzdWx0Lk9rIHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIE9yX2Vycm9yLmVycm9yXG4gICAgICAgICAgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfb3JfZXJyb3I6IGR1cGxpY2F0ZSBrZXlcIilcbiAgICAgICAgICBrZXlcbiAgICAgICAgICBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfZXhuIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9leG46IGR1cGxpY2F0ZSBrZXlcIikga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICAgIHw+IEVycm9yLnJhaXNlXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2FsaXN0ID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgICAgbGV0IG5hbWUgPSBcImFsaXN0XCJcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgZm9sZCA9IExpc3QuZm9sZFxuICAgIGVuZClcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2ZfYWxpc3QgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2ZfYWxpc3RfZXhuID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZXhuXG5cbiAgKCogUmV2ZXJzZSB0aGUgaW5wdXQsIHRoZW4gZm9sZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFRoZSByZXN1bHRpbmcgbWFwIHVzZXMgdGhlIGZpcnN0XG4gICAgIGluc3RhbmNlIG9mIGVhY2gga2V5IGZyb20gdGhlIGlucHV0IGxpc3QuIFRoZSByZWxhdGl2ZSBvcmRlcmluZyBvZiBlbGVtZW50cyBpbiBlYWNoXG4gICAgIG91dHB1dCBsaXN0IGlzIHRoZSBzYW1lIGFzIGluIHRoZSBpbnB1dCBsaXN0LiAqKVxuICBsZXQgb2ZfZm9sZGFibGVfbXVsdGkgZm9sZGFibGUgfmZvbGQgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWxpc3QgPSBmb2xkIGZvbGRhYmxlIH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgaW5cbiAgICBvZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleSA9XG4gICAgb2ZfZm9sZGFibGVfbXVsdGkgYWxpc3QgfmZvbGQ6TGlzdC5mb2xkIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIG1vZHVsZSBPZl9zZXF1ZW5jZSA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICAgIGxldCBuYW1lID0gXCJzZXF1ZW5jZVwiXG5cbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgICAgbGV0IGZvbGQgPSBTZXF1ZW5jZS5mb2xkXG4gICAgZW5kKVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9zZXF1ZW5jZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9leG5cblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgc2VxdWVuY2UgfmNvbXBhcmVfa2V5ID1cbiAgICBvZl9mb2xkYWJsZV9tdWx0aSBzZXF1ZW5jZSB+Zm9sZDpTZXF1ZW5jZS5mb2xkIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmb3JfYWxsIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBub3QgKGYgZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIG5vdCAoZiB+a2V5IH5kYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgZiBkYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCA/KGtleV9vcmRlciA9IGBJbmNyZWFzaW5nKSB0ID1cbiAgICBtYXRjaCBrZXlfb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT4gZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gICAgfCBgRGVjcmVhc2luZyAtPiBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZWx0cyA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46KGxlbmd0aCB0MSArIGxlbmd0aCB0MikgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlcjIgdDEgdDIgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YTp2YWx1ZXMgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB2YWx1ZXMgd2l0aFxuICAgICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICAgIFVuaWZvcm1fYXJyYXkuc2V0IGVsdHMgIWkgKGtleSwgdmFsdWUpO1xuICAgICAgICBpbmNyIGlcbiAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgbGV0IGxlbiA9ICFpIGluXG4gICAgbGV0IGdldCBpID0gVW5pZm9ybV9hcnJheS5nZXQgZWx0cyBpIGluXG4gICAgbGV0IHRyZWUgPSBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mOmdldCBpblxuICAgIHRyZWUsIGxlblxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgPVxuICAgIGxldCBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGhfbGFyZ2UgdF9sYXJnZSB0X3NtYWxsIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleSA9XG4gICAgICBmb2xkIHRfc21hbGwgfmluaXQ6KHRfbGFyZ2UsIGxlbmd0aF9sYXJnZSkgfmY6KGZ1biB+a2V5IH5kYXRhOmRhdGEnICh0LCBsZW5ndGgpIC0+XG4gICAgICAgIHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gZGF0YSdcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBjYWxsIGNvbWJpbmUgfmtleSBkYXRhIGRhdGEnKSlcbiAgICBpblxuICAgIGxldCBjYWxsIGYgfmtleSB4IHkgPSBmIH5rZXkgeCB5IGluXG4gICAgbGV0IHN3YXAgZiB+a2V5IHggeSA9IGYgfmtleSB5IHggaW5cbiAgICBmdW4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfmNvbWJpbmUgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBsZW5ndGgyIDw9IGxlbmd0aDFcbiAgICAgIHRoZW4gbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMSB0MSB0MiB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMiB0MiB0MSB+Y2FsbDpzd2FwIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIG1vZHVsZSBDbG9zZXN0X2tleV9pbXBsID0gc3RydWN0XG4gICAgKCogW21hcmtlcl0gYW5kIFtyZXBhY2thZ2VdIGFsbG93IHVzIHRvIGNyZWF0ZSBcImxvZ2ljYWxcIiBvcHRpb25zIHdpdGhvdXQgYWN0dWFsbHlcbiAgICAgICBhbGxvY2F0aW5nIGFueSBvcHRpb25zLiBQYXNzaW5nIFtGb3VuZCBrZXkgdmFsdWVdIHRvIGEgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0b1xuICAgICAgIHBhc3NpbmcgW1NvbWUgKGtleSwgdmFsdWUpXTsgcGFzc2luZyBbTWlzc2luZyAoKSAoKV0gaXMgZXF1aXZhbGVudCB0byBwYXNzaW5nXG4gICAgICAgW05vbmVdLiAqKVxuICAgIHR5cGUgKCdrLCAndiwgJ2tfb3B0LCAndl9vcHQpIG1hcmtlciA9XG4gICAgICB8IE1pc3NpbmcgOiAoJ2ssICd2LCB1bml0LCB1bml0KSBtYXJrZXJcbiAgICAgIHwgRm91bmQgOiAoJ2ssICd2LCAnaywgJ3YpIG1hcmtlclxuXG4gICAgbGV0IHJlcGFja2FnZVxuICAgICAgICAgICh0eXBlIGsgdiBrX29wdCB2X29wdClcbiAgICAgICAgICAobWFya2VyIDogKGssIHYsIGtfb3B0LCB2X29wdCkgbWFya2VyKVxuICAgICAgICAgIChrIDoga19vcHQpXG4gICAgICAgICAgKHYgOiB2X29wdClcbiAgICAgIDogKGsgKiB2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIG1hdGNoIG1hcmtlciB3aXRoXG4gICAgICB8IE1pc3NpbmcgLT4gTm9uZVxuICAgICAgfCBGb3VuZCAtPiBTb21lIChrLCB2KVxuICAgIDs7XG5cbiAgICAoKiBUaGUgdHlwZSBzaWduYXR1cmUgaXMgZXhwbGljaXQgaGVyZSB0byBhbGxvdyBwb2x5bW9ycGhpYyByZWN1cnNpb24uICopXG4gICAgbGV0IHJlYyBsb29wIDpcbiAgICAgICdrICd2ICdrX29wdCAndl9vcHQuXG4gICAgICAoJ2ssICd2KSB0cmVlXG4gICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAtPiAna1xuICAgICAgLT4gY29tcGFyZV9rZXk6KCdrIC0+ICdrIC0+IGludClcbiAgICAgIC0+ICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXJcbiAgICAgIC0+ICdrX29wdFxuICAgICAgLT4gJ3Zfb3B0XG4gICAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG4gICAgICA9XG4gICAgICBmdW4gdCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSAtPlxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICB8IExlYWYgKGsnLCB2JykgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgICBpZiBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byAtPiBjID49IDBcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPiBjID4gMFxuICAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byAtPiBjIDw9IDBcbiAgICAgICAgICAgIHwgYExlc3NfdGhhbiAtPiBjIDwgMFxuICAgICAgICAgIHRoZW4gU29tZSAoaycsIHYnKVxuICAgICAgICAgIGVsc2UgcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgfCBOb2RlIChsLCBrJywgdicsIHIsIF8pIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIFRoaXMgaXMgYSBiYXNlIGNhc2UgKG5vIHJlY3Vyc2l2ZSBjYWxsKS4gKilcbiAgICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYExlc3Nfb3JfZXF1YWxfdG8gLT4gU29tZSAoaycsIHYnKVxuICAgICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGlzX2VtcHR5IHIgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1pbl9lbHQgclxuICAgICAgICAgICAgfCBgTGVzc190aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGlzX2VtcHR5IGwgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1heF9lbHQgbClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICgqIFdlIGFyZSBndWFyYW50ZWVkIGhlcmUgdGhhdCBrJyA8PiBrLiAqKVxuICAgICAgICAgICAgKCogVGhpcyBpcyB0aGUgb25seSByZWN1cnNpdmUgY2FzZS4gKilcbiAgICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBjID4gMFxuICAgICAgICAgICAgICB0aGVuIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgICAgZWxzZSBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgICAgIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgICAgIHRoZW4gbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBGb3VuZCBrJyB2J1xuICAgICAgICAgICAgICBlbHNlIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSlcbiAgICA7O1xuXG4gICAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGsgfmNvbXBhcmVfa2V5ID0gbG9vcCB0IGRpciBrIH5jb21wYXJlX2tleSBNaXNzaW5nICgpICgpXG4gIGVuZFxuXG4gIGxldCBjbG9zZXN0X2tleSA9IENsb3Nlc3Rfa2V5X2ltcGwuY2xvc2VzdF9rZXlcblxuICBsZXQgcmVjIHJhbmsgdCBrIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrJywgXykgLT4gaWYgY29tcGFyZV9rZXkgaycgayA9IDAgdGhlbiBTb21lIDAgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrJywgXywgciwgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gU29tZSAobGVuZ3RoIGwpXG4gICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICB0aGVuIHJhbmsgbCBrIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBPcHRpb24ubWFwIChyYW5rIHIgayB+Y29tcGFyZV9rZXkpIH5mOihmdW4gcmFuayAtPiByYW5rICsgMSArIGxlbmd0aCBsKVxuICA7O1xuXG4gICgqIHRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgW1NlcXVlbmNlXSBpbnRlcmZhY2UgYnV0IHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgYWxsb2NhdGVzIG9ubHkgMiB3b3JkcyBhbmQgZG9lc24ndCByZXF1aXJlIHdyaXRlLWJhcnJpZXIgKilcbiAgbGV0IHJlYyBudGgnIG51bV90b19zZWFyY2ggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT5cbiAgICAgIGlmICFudW1fdG9fc2VhcmNoID0gMFxuICAgICAgdGhlbiBTb21lIChrLCB2KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGRlY3IgbnVtX3RvX3NlYXJjaDtcbiAgICAgICAgTm9uZSlcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICAobWF0Y2ggbnRoJyBudW1fdG9fc2VhcmNoIGwgd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gc29tZVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICAgICBudGgnIG51bV90b19zZWFyY2ggcikpXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBudGgnIChyZWYgbikgdFxuXG5cbiAgbGV0IHJlYyBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDwgMClcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMClcbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPiAwKVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgbGV0IGlzX2xlZnQgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBzZWdtZW50X29mIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgICB8IGBSaWdodCAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IGlzX3JpZ2h0IH5rZXkgfmRhdGEgPSBub3QgKGlzX2xlZnQgfmtleSB+ZGF0YSkgaW5cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOmlzX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodFxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZF0gZmluZHMgdGhlIGtleSBpbiBbdF0gd2hpY2ggc2F0aXNmaWVzIFttYXliZV9ib3VuZF1cbiAgICAgYW5kIHRoZSByZWxldmFudCBvbmUgb2YgW2lmX2V4Y2x1c2l2ZV0gb3IgW2lmX2luY2x1c2l2ZV0sIGFzIGp1ZGdlZCBieSBbY29tcGFyZV0uICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlIH5pZl9leGNsdXNpdmUgfmlmX2luY2x1c2l2ZSA9XG4gICAgbGV0IGZpbmRfYm91bmQgdCBob3cgYm91bmQgfmNvbXBhcmUgOiBfIE1heWJlX2JvdW5kLnQgb3B0aW9uID1cbiAgICAgIG1hdGNoIGJpbmFyeV9zZWFyY2ggdCBob3cgYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgfCBTb21lIChib3VuZCwgXykgLT4gU29tZSAoSW5jbCBib3VuZClcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCAobWF5YmVfYm91bmQgOiBfIE1heWJlX2JvdW5kLnQpIHdpdGhcbiAgICB8IEV4Y2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2V4Y2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgSW5jbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfaW5jbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBVbmJvdW5kZWQgLT4gU29tZSBVbmJvdW5kZWRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzXSBmaW5kcyB0aGUgKG5vdCBuZWNlc3NhcmlseSBkaXN0aW5jdCkga2V5cyBpbiBbdF1cbiAgICAgd2hpY2ggbW9zdCBjbG9zZWx5IGFwcHJvYWNoIChidXQgZG8gbm90IGNyb3NzKSBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdLCBhc1xuICAgICBqdWRnZWQgYnkgW2NvbXBhcmVdLiBJdCByZXR1cm5zIFtOb25lXSBpZiBubyBrZXlzIGluIFt0XSBhcmUgd2l0aGluIHRoYXQgcmFuZ2UuICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgZmluZF9sb3dlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbGV0IGZpbmRfdXBwZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBtYXRjaCBmaW5kX2xvd2VyX2JvdW5kIHQgbG93ZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGxvd2VyX2JvdW5kIC0+XG4gICAgICAobWF0Y2ggZmluZF91cHBlcl9ib3VuZCB0IHVwcGVyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgIHwgU29tZSB1cHBlcl9ib3VuZCAtPiBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpKVxuICA7O1xuXG4gIHR5cGUgKCdrLCAndikgYWNjID1cbiAgICB7IG11dGFibGUgYmFkX2tleSA6ICdrIG9wdGlvblxuICAgIDsgbXV0YWJsZSBtYXBfbGVuZ3RoIDogKCdrLCAndikgdCAqIGludFxuICAgIH1cblxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFjYyA9IHsgYmFkX2tleSA9IE5vbmU7IG1hcF9sZW5ndGggPSBlbXB0eSwgMCB9IGluXG4gICAgaXRlcmkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBsZXQgbWFwLCBsZW5ndGggPSBhY2MubWFwX2xlbmd0aCBpblxuICAgICAgbGV0ICgoXywgbGVuZ3RoJykgYXMgcGFpcikgPSBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIG1hcCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgJiYgT3B0aW9uLmlzX25vbmUgYWNjLmJhZF9rZXlcbiAgICAgIHRoZW4gYWNjLmJhZF9rZXkgPC0gU29tZSBrZXlcbiAgICAgIGVsc2UgYWNjLm1hcF9sZW5ndGggPC0gcGFpcik7XG4gICAgbWF0Y2ggYWNjLmJhZF9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBgT2sgYWNjLm1hcF9sZW5ndGhcbiAgICB8IFNvbWUga2V5IC0+IGBEdXBsaWNhdGVfa2V5IGtleVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbWF0Y2ggb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfaXRlcmlfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHAgc2V4cCB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHApIHNleHAgaW5cbiAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBtYXRjaCBvZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkgayAtPlxuICAgICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgICBsZXQgYWxpc3Rfc2V4cHMgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBGbi5pZCBGbi5pZCkgc2V4cCBpblxuICAgICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICAgIExpc3QuaXRlcjJfb2sgYWxpc3QgYWxpc3Rfc2V4cHMgfmY6KGZ1biAoazIsIF8pIChrMl9zZXhwLCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIGsyID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJNYXAudF9vZl9zZXhwX2RpcmVjdDogZHVwbGljYXRlIGtleVwiIGsyX3NleHBcbiAgICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgICBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsdWUgdCA9XG4gICAgbGV0IGYgfmtleSB+ZGF0YSBhY2MgPSBTZXhwLkxpc3QgWyBzZXhwX29mX2tleSBrZXk7IHNleHBfb2ZfdmFsdWUgZGF0YSBdIDo6IGFjYyBpblxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB+ZiB0IH5pbml0OltdKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGxldCBva3MsIChlcnJvcl90cmVlLCBfKSA9IHBhcnRpdGlvbl9tYXAgdCB+Y29tcGFyZV9rZXkgfmY6UmVzdWx0LnRvX2VpdGhlciBpblxuICAgIGlmIGlzX2VtcHR5IGVycm9yX3RyZWVcbiAgICB0aGVuIE9rIG9rc1xuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3JfcyAoc2V4cF9vZl90IHNleHBfb2Zfa2V5IEVycm9yLnNleHBfb2ZfdCBlcnJvcl90cmVlKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c1xuICAgICAgICB0MVxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcjooeyBjb21wYXJlID0gY29tcGFyZV9rZXk7IHNleHBfb2ZfdCA9IHNleHBfb2Zfa2V5IH0gOiBfIENvbXBhcmF0b3IudClcbiAgICA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBgT2tcbiAgICAgICAgKGZvbGQgdDEgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIH5rZXkgfmRhdGEgKHQyLCBsZW5ndGgpIC0+XG4gICAgICAgICAgIGxldCBrZXkgPSBmIGtleSBpblxuICAgICAgICAgICB0cnkgYWRkX2V4bl9pbnRlcm5hbCB0MiB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB3aXRoXG4gICAgICAgICAgIHwgRHVwbGljYXRlIC0+IHJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSkpKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggbWFwX2tleXMgdCB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcmVzdWx0IC0+IHJlc3VsdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBsZXQgc2V4cF9vZl9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90IGluXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJNYXAubWFwX2tleXNfZXhuOiBkdXBsaWNhdGUga2V5XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcbmVuZFxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2ssICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogKCdrLCAndikgVHJlZTAudFxuICA7IGxlbmd0aCA6IGludFxuICB9XG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG5cbmxldCBjb21wYXJlX2tleSB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGxlbmd0aCA9IF87IGNvbXBhcmF0b3IgfSAodHJlZSwgbGVuZ3RoKSA9XG4gIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCBsaWtlMiB4ICh5LCB6KSA9IGxpa2UgeCB5LCBsaWtlIHggelxuXG5sZXQgbGlrZV9tYXliZV9ub19vcCAoeyB0cmVlID0gb2xkX3RyZWU7IGxlbmd0aCA9IF87IGNvbXBhcmF0b3IgfSBhcyBvbGRfdCkgKHRyZWUsIGxlbmd0aClcbiAgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCB3aXRoX3NhbWVfbGVuZ3RoIHsgdHJlZSA9IF87IGNvbXBhcmF0b3I7IGxlbmd0aCB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5sZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbigqIEV4cG9zaW5nIHRoaXMgZnVuY3Rpb24gd291bGQgbWFrZSBpdCB2ZXJ5IGVhc3kgZm9yIHRoZSBpbnZhcmlhbnRzXG4gICBvZiB0aGlzIG1vZHVsZSB0byBiZSBicm9rZW4uICopXG5sZXQgb2ZfdHJlZV91bnNhZmUgfmNvbXBhcmF0b3Igfmxlbmd0aCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuXG4gIGxldCBpbnZhcmlhbnRzIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgJiYgVHJlZTAubGVuZ3RoIHQudHJlZSA9IHQubGVuZ3RoXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcblxuICBsZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZSB0IChUcmVlMC5zZXQgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5faW50ZXJuYWxcbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCByZXN1bHQgLT4gYE9rIHJlc3VsdFxuICAgIHwgZXhjZXB0aW9uIER1cGxpY2F0ZSAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICAgIGxpa2UgdCAoVHJlZTAucmVtb3ZlX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQga2V5ID0gVHJlZTAuZmluZF9tdWx0aSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mID1cbiAgICBsaWtlIHQgKFRyZWUwLmNoYW5nZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mID1cbiAgICBsaWtlIHQgKFRyZWUwLnVwZGF0ZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfZXhuXG4gICAgICB0LnRyZWVcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgZmluZCB0IGtleSA9IFRyZWUwLmZpbmQgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IHJlbW92ZSB0IGtleSA9XG4gICAgbGlrZV9tYXliZV9ub19vcFxuICAgICAgdFxuICAgICAgKFRyZWUwLnJlbW92ZSB0LnRyZWUga2V5IH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgbWVtIHQga2V5ID0gVHJlZTAubWVtIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdC50cmVlIH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQudHJlZSB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgdDEgdDIgfmYgPSBUcmVlMC5pdGVyMiB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgbGV0IG1hcCB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXAgdC50cmVlIH5mKVxuICBsZXQgbWFwaSB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXBpIHQudHJlZSB+ZilcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0LnRyZWUgfmYgfmluaXRcblxuICBsZXQgZm9sZDIgdDEgdDIgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGQyIHQxLnRyZWUgdDIudHJlZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJpIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcmkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfbWFwaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcGkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25pX3RmIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihsaWtlIHQpXG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnNcbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9kYXRhIHQxIHQyID0gVHJlZTAuZXF1YWwgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHQudHJlZVxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0LnRyZWVcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdC50cmVlXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDEudHJlZVxuICAgICAgdDIudHJlZVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgPVxuICAgIGxpa2UgdDEgKFRyZWUwLm1lcmdlIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSlcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBUaGlzIGlzIG9ubHkgYSBuby1vcCBpbiB0aGUgY2FzZSB3aGVyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIG1hcHMgaXMgZW1wdHkuICopXG4gICAgbGlrZV9tYXliZV9ub19vcFxuICAgICAgKGlmIHQyLmxlbmd0aCA8PSB0MS5sZW5ndGggdGhlbiB0MSBlbHNlIHQyKVxuICAgICAgKFRyZWUwLm1lcmdlX3NrZXdlZFxuICAgICAgICAgdDEudHJlZVxuICAgICAgICAgdDIudHJlZVxuICAgICAgICAgfmxlbmd0aDE6dDEubGVuZ3RoXG4gICAgICAgICB+bGVuZ3RoMjp0Mi5sZW5ndGhcbiAgICAgICAgIH5jb21iaW5lXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSlcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0LnRyZWVcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0LnRyZWVcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdC50cmVlXG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdC50cmVlXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdC50cmVlIH5mXG5cbiAgbGV0IHNwbGl0IHQgayA9XG4gICAgbGV0IGwsIG1heWJlLCByID0gVHJlZTAuc3BsaXQgdC50cmVlIGsgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSBpblxuICAgIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvciB0IGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGxldCBib3RoX2xlbiA9IGlmIE9wdGlvbi5pc19zb21lIG1heWJlIHRoZW4gdC5sZW5ndGggLSAxIGVsc2UgdC5sZW5ndGggaW5cbiAgICBpZiBUcmVlMC5oZWlnaHQgbCA8IFRyZWUwLmhlaWdodCByXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbCA9IG9mX3RyZWUgbCB+Y29tcGFyYXRvciBpblxuICAgICAgbCwgbWF5YmUsIG9mX3RyZWVfdW5zYWZlIHIgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggbCkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgciA9IG9mX3RyZWUgciB+Y29tcGFyYXRvciBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbCB+Y29tcGFyYXRvciB+bGVuZ3RoOihib3RoX2xlbiAtIGxlbmd0aCByKSwgbWF5YmUsIHIpXG4gIDs7XG5cbiAgbGV0IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGxlZnQsIG1pZCwgcmlnaHQgPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2UgdC50cmVlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGxldCBvdXRlcl9qb2luZWRfaGVpZ2h0ID1cbiAgICAgIGxldCBoX2wgPSBUcmVlMC5oZWlnaHQgbGVmdFxuICAgICAgYW5kIGhfciA9IFRyZWUwLmhlaWdodCByaWdodCBpblxuICAgICAgaWYgaF9sID0gaF9yIHRoZW4gaF9sICsgMSBlbHNlIG1heCBoX2wgaF9yXG4gICAgaW5cbiAgICBpZiBvdXRlcl9qb2luZWRfaGVpZ2h0IDwgVHJlZTAuaGVpZ2h0IG1pZFxuICAgIHRoZW4gKFxuICAgICAgbGV0IG1pZF9sZW5ndGggPSB0Lmxlbmd0aCAtIChUcmVlMC5sZW5ndGggbGVmdCArIFRyZWUwLmxlbmd0aCByaWdodCkgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KSB+bGVuZ3RoOm1pZF9sZW5ndGgpXG4gICAgZWxzZSBvZl90cmVlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KVxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5hcHBlbmRcbiAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSBsb3dlcl9wYXJ0KVxuICAgICAgICB+bG93ZXJfcGFydDpsb3dlcl9wYXJ0LnRyZWVcbiAgICAgICAgfnVwcGVyX3BhcnQ6dXBwZXJfcGFydC50cmVlXG4gICAgd2l0aFxuICAgIHwgYE9rIHRyZWUgLT5cbiAgICAgIGBPa1xuICAgICAgICAob2ZfdHJlZV91bnNhZmVcbiAgICAgICAgICAgdHJlZVxuICAgICAgICAgICB+Y29tcGFyYXRvcjooY29tcGFyYXRvciBsb3dlcl9wYXJ0KVxuICAgICAgICAgICB+bGVuZ3RoOihsb3dlcl9wYXJ0Lmxlbmd0aCArIHVwcGVyX3BhcnQubGVuZ3RoKSlcbiAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZSB0LnRyZWUgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQudHJlZSB+bWluIH5tYXggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQudHJlZSBkaXIga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0LnRyZWUgblxuICBsZXQgbnRoX2V4biB0IG4gPSBPcHRpb24udmFsdWVfZXhuIChudGggdCBuKVxuICBsZXQgcmFuayB0IGtleSA9IFRyZWUwLnJhbmsgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAuYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQudHJlZSB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gbGlrZV9tYXliZV9ub19vcCB0IChFbXB0eSwgMClcbiAgOztcbmVuZFxuXG4oKiBbMF0gaXMgdXNlZCBhcyB0aGUgW2xlbmd0aF0gYXJndW1lbnQgZXZlcnl3aGVyZSBpbiB0aGlzIG1vZHVsZSwgc2luY2UgdHJlZXMgZG8gbm90XG4gICBoYXZlIHRoZWlyIGxlbmd0aHMgc3RvcmVkIGF0IHRoZSByb290LCB1bmxpa2UgbWFwcy4gVGhlIHZhbHVlcyBhcmUgZGlzY2FyZGVkIGFsd2F5cy4gKilcbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdHJlZSA9IHRyZWVcbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGsgdiA9IFRyZWUwLnNpbmdsZXRvbiBrIHZcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgZnN0IChUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgVHJlZTAub2ZfYWxpc3Rfb3JfZXJyb3IgYWxpc3QgfmNvbXBhcmF0b3IgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPSBmc3QgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID0gZnN0IChUcmVlMC5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjpfcmVxdWlyZWRfYnlfaW50ZiB+bGVuIH5mID1cbiAgICBUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOmZzdFxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvciB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPSBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgdCA9IHRcblxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG5cbiAgbGV0IHNldCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIGZzdCAoVHJlZTAuc2V0IHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgZnN0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5sZW5ndGg6MFxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIHRyeSBgT2sgKGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhKSB3aXRoXG4gICAgfCBfIC0+IGBEdXBsaWNhdGVcbiAgOztcblxuICBsZXQgYWRkX211bHRpIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgVHJlZTAuYWRkX211bHRpIHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gZnN0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAucmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfD4gZnN0XG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfbXVsdGkgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZiA9XG4gICAgZnN0IChUcmVlMC5jaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdXBkYXRlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmY6KGZ1biBkYXRhIC0+IFNvbWUgKGYgZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdFxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5maW5kIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIGZzdCAoVHJlZTAucmVtb3ZlIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLm1lbSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0IH5mXG5cbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIHQxIHQyIH5mID1cbiAgICBUcmVlMC5pdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZlxuICBsZXQgbWFwaSB0IH5mID0gVHJlZTAubWFwaSB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmYgfmluaXRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gVHJlZTAuZm9sZF91bnRpbCB0IH5mIH5pbml0IH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB+Y29tcGFyYXRvciB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEgdDIgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX2tleXMgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlciB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlciB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcmkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX21hcCB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25pX3RmIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIH5jb21wYXJhdG9yIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6ZnN0XG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnNcbiAgICAgICAgIHRcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBjb21wYXJlX2RhdGEgdDEgdDJcbiAgOztcblxuICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5lcXVhbCBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBjb21wYXJlX2RhdGEgdDEgdDJcbiAgOztcblxuICBsZXQga2V5cyB0ID0gVHJlZTAua2V5cyB0XG4gIGxldCBkYXRhIHQgPSBUcmVlMC5kYXRhIHRcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdFxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5kYXRhX2VxdWFsXG4gIDs7XG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgIHQxXG4gICAgICB0MlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gIDs7XG5cbiAgbGV0IG1lcmdlIH5jb21wYXJhdG9yIHQxIHQyIH5mID1cbiAgICBmc3QgKFRyZWUwLm1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIH5jb21wYXJhdG9yIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBMZW5ndGggY29tcHV0YXRpb24gbWFrZXMgdGhpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIFttZXJnZV9za2V3ZWRdIG9uIGEgbWFwXG4gICAgICAgd2l0aCBhIFtsZW5ndGhdIGZpZWxkLCBidXQgZG9lcyBwcmVzZXJ2ZSBhbW91bnQgb2YgYWxsb2NhdGlvbi4gKilcbiAgICBmc3RcbiAgICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICAgIHQxXG4gICAgICAgICB0MlxuICAgICAgICAgfmxlbmd0aDE6KGxlbmd0aCB0MSlcbiAgICAgICAgIH5sZW5ndGgyOihsZW5ndGggdDIpXG4gICAgICAgICB+Y29tYmluZVxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0IH5mXG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGsgPSBUcmVlMC5zcGxpdCB0IGsgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IGFwcGVuZCB+Y29tcGFyYXRvciB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgVHJlZTAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBfLCByZXQsIF8gPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+bG93ZXJfYm91bmRcbiAgICAgICAgfnVwcGVyX2JvdW5kXG4gICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgcmV0XG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgdFxuICAgICAgfm1pblxuICAgICAgfm1heFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB+Y29tcGFyYXRvciB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQgZGlyIGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0IG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5yYW5rIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdFxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgZnN0IChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbWF0Y2ggVHJlZTAuYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBFbXB0eVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mIHdpdGhcbiAgICB8IGBPayAodCwgXykgLT4gYE9rIHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9IGZzdCAoVHJlZTAubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYpXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgPSBzdHJ1Y3RcbiAgICB0eXBlICgnaywgJ3YsICd3KSB0ID0gKCdrLCAndikgVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50XG5cbiAgICBsZXQgZW1wdHkgPSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLmVtcHR5XG5cbiAgICBsZXQgYWRkX2V4biB0IH5jb21wYXJhdG9yIH5rZXkgfmRhdGEgPVxuICAgICAgbWF0Y2ggVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IHQgd2l0aFxuICAgICAgfCBTb21lIHByZXZfa2V5IHdoZW4gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgcHJldl9rZXkga2V5ID49IDAgLT5cbiAgICAgICAgRXJyb3IucmFpc2VfcyAoU2V4cC5BdG9tIFwiTWFwLkJ1aWxkX2luY3JlYXNpbmcuYWRkOiBub24taW5jcmVhc2luZyBrZXlcIilcbiAgICAgIHwgXyAtPiBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdCB+a2V5IH5kYXRhXG4gICAgOztcblxuICAgIGxldCB0b190cmVlIHQgPSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWVfdW5jaGVja2VkIHRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgdHJlZSA9IFRyZWUwLmVtcHR5OyBjb21wYXJhdG9yOyBsZW5ndGggPSAwIH1cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBrIHYgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5zaW5nbGV0b24gayB2OyBsZW5ndGggPSAxIH1cbiAgbGV0IG9mX3RyZWUwIH5jb21wYXJhdG9yICh0cmVlLCBsZW5ndGgpID0geyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKHRyZWUsIFRyZWUwLmxlbmd0aCB0cmVlKVxuICBsZXQgdG9fdHJlZSA9IHRvX3RyZWVcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAgIH5mOihmdW4gdHJlZSAtPiBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgbGVuZ3RoKSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfml0ZXJpIHdpdGhcbiAgICB8IGBPayB0cmVlX2xlbmd0aCAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWVfbGVuZ3RoKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mLCBsZW4pXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihvZl90cmVlMCB+Y29tcGFyYXRvcilcbiAgICAgIChUcmVlMC5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgbWF0Y2ggVHJlZTAub2Zfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIGxlbmd0aCkgLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHBhaXIgLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciBwYWlyKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAubWFwX2tleXNfZXhuIHQudHJlZSB+ZiB+Y29tcGFyYXRvcilcbiAgOztcblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3IgPSBLLmNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBlbmRcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG50eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcblxubGV0IGNvbXBhcmF0b3JfcyAodHlwZSBrIGNtcCkgdCA6IChrLCBjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGtcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcFxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3JcbiAgZW5kKVxuOztcblxubGV0IHRvX2NvbXBhcmF0b3IgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgPSBNLmNvbXBhcmF0b3JcblxubGV0IG9mX3RyZWUgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgdHJlZSA9XG4gIG9mX3RyZWUgfmNvbXBhcmF0b3I6TS5jb21wYXJhdG9yIHRyZWVcbjs7XG5cbmxldCBlbXB0eSBtID0gVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxubGV0IHNpbmdsZXRvbiBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0X211bHRpIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3RfZm9sZCBtIGEgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+aW5pdCB+ZlxuOztcblxubGV0IG9mX2FsaXN0X3JlZHVjZSBtIGEgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfaXRlcmkgbSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuXG5sZXQgb2ZfaXRlcmlfZXhuIG0gfml0ZXJpID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBtIHNlcSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzZXFcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2V4biBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9tdWx0aSBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9mb2xkIG0gcyB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5pbml0IH5mXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIG0gcyB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmZcbjs7XG5cbmxldCBtYXBfa2V5cyBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCBtYXBfa2V5c19leG4gbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxuXG5tb2R1bGUgTSAoSyA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBrIGNtcClcbiAgICAgIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGsgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgdl9vZl9zZXhwXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOksuY29tcGFyYXRvciBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgICAodHlwZSBrKVxuICAgICAgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKVxuICAgICAgKHZfZ3JhbW1hciA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBMaXN0XG4gICAgICAgIChNYW55IChMaXN0IChDb25zIChLLnRfc2V4cF9ncmFtbWFyLnVudHlwZWQsIENvbnMgKHZfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkpKSkpXG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSBjb21wYXJlX3YgdDEgdDIgPSBjb21wYXJlX2RpcmVjdCBjb21wYXJlX3YgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGspIGhhc2hfZm9sZF92IHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBLLmhhc2hfZm9sZF90IGhhc2hfZm9sZF92IHN0YXRlXG47O1xuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID0gKCdrLCAndiwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZXhuIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9mb2xkIGEgfmluaXQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYSB+aW5pdCB+ZlxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhIH5mXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvclxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvclxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxXG4gIGxldCBvZl9zZXF1ZW5jZSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCBzIH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3IgcyB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgcyB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHMgfmZcbiAgbGV0IG1hcF9rZXlzIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmZcbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZlxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuSW50NjRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50NjQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IGNvbXBhcmUgPSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSA2NFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludDY0X3Bvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IENhbWwuSW50NjQub2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gQ2FtbC5JbnQ2NC5vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDY0Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXA2NCA6IHQgLT4gdCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDE2IHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgNDhcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDMyIHggPVxuICAoKiBUaGlzIGlzIHN0cmljdGx5IGJldHRlciB0aGFuIGNvZXJjaW5nIHRvIGFuIGludDMyIHRvIHBlcmZvcm0gYnl0ZXN3YXAuIENvZXJjaW5nXG4gICAgIGZyb20gYW4gaW50MzIgd2lsbCBhZGQgdW5uZWNlc3Nhcnkgc2hpZnQgb3BlcmF0aW9ucyB0byBzaWduIGV4dGVuZCB0aGUgbnVtYmVyXG4gICAgIGFwcHJvcHJpYXRlbHkuXG4gICopXG4gIENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAzMlxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDQ4IHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMTZcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IGluY3IgciA9IHIgOj0gYWRkICFyIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gc3ViICFyIG9uZVxuXG5leHRlcm5hbCBvZl9pbnQ2NCA6IHQgLT4gdCA9IFwiJWlkZW50aXR5XCJcblxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0XG5sZXQgdG9faW50NjQgdCA9IHRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmV4dGVybmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCB0b19uYXRpdmVpbnRfdHJ1bmMgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5cbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5pbnQ2NF90b19pbnRfZXhuXG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYuaW50NjRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252LmludDY0X3RvX2ludDMyX2V4blxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IG9mX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLkludDY0LmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuSW50NjQubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5JbnQ2NC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuSW50NjQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuSW50NjQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuSW50NjQucHJlZCB4ID0gQ2FtbC5JbnQ2NC56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQ2NCBpIF0pO1xuICAgIGlmIENhbWwuSW50NjQuZXF1YWwgaSBDYW1sLkludDY0Lm9uZSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5JbnQ2NC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50NjQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9IG5lZ1xuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlTHhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVMeFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjRcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBleHRlcm5hbCAoICsgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfYWRkXCJcbiAgZXh0ZXJuYWwgKCAtICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X3N1YlwiXG4gIGV4dGVybmFsICggKiApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9tdWxcIlxuICBleHRlcm5hbCAoIC8gKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfZGl2XCJcbiAgZXh0ZXJuYWwgKCB+LSApIDogdCAtPiB0ID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogdCAtPiB0ID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2FuZFwiXG4gIGV4dGVybmFsICggbG9yICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X29yXCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X3hvclwiXG5cbiAgbGV0IGxub3QgPSBiaXRfbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9sc2xcIlxuICBleHRlcm5hbCAoIGFzciApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2FzclwiXG4gIGV4dGVybmFsICggbHNyICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfbHNyXCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDY0XSBhbmQgW0ludDY0Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCogQSA2M2JpdCBpbnRlZ2VyIGlzIGEgNjRiaXQgaW50ZWdlciB3aXRoIGl0cyBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcbiAgIGFuZCBpdHMgbG93ZXN0IGJpdCBzZXQgdG8gMC5cbiAgIFRoaXMgaXMgdGhlIHNhbWUga2luZCBvZiBlbmNvZGluZyBhcyBPQ2FtbCBpbnQgb24gNjRiaXQgYXJjaGl0ZWN0dXJlLlxuICAgVGhlIG9ubHkgZGlmZmVyZW5jZSBiZWluZyB0aGUgbG93ZXN0IGJpdCAoaW1tZWRpYXRlIGJpdCkgc2V0IHRvIDEuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuXG5tb2R1bGUgVDAgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQ2NCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbm1vZHVsZSBXIDogc2lnXG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG4gIGVuZFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgdmFsIHdyYXBfZXhuIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIHdyYXBfbW9kdWxvIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIHVud3JhcCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG5cbiAgKCoqIFJldHVybnMgYSBub24tbmVnYXRpdmUgaW50NjQgdGhhdCBpcyBlcXVhbCB0byB0aGUgaW5wdXQgaW50NjMgbW9kdWxvIDJeNjMuICopXG4gIHZhbCB1bndyYXBfdW5zaWduZWQgOiB0IC0+IENhbWwuSW50NjQudFxuXG4gIHZhbCBpbnZhcmlhbnQgOiB0IC0+IHVuaXRcbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdWIgOiB0IC0+IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBhYnMgOiB0IC0+IHRcbiAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgdmFsIHByZWQgOiB0IC0+IHRcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGl2IDogdCAtPiB0IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3Bjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBiaXRfbm90IDogdCAtPiB0XG4gIHZhbCBiaXRfeG9yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9vciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfYW5kIDogdCAtPiB0IC0+IHRcbiAgdmFsIHNoaWZ0X2xlZnQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBtaW5fdmFsdWUgOiB0XG4gIHZhbCBtYXhfdmFsdWUgOiB0XG4gIHZhbCB0b19pbnQ2NCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG4gIHZhbCBvZl9pbnQ2NCA6IENhbWwuSW50NjQudCAtPiB0IG9wdGlvblxuICB2YWwgb2ZfaW50NjRfZXhuIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIG9mX2ludDY0X3RydW5jIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBjZWlsX3BvdzIgOiB0IC0+IHRcbiAgdmFsIGZsb29yX3BvdzIgOiB0IC0+IHRcbiAgdmFsIGNlaWxfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBmbG9vcl9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGlzX3BvdzIgOiB0IC0+IGJvb2xcbiAgdmFsIGNseiA6IHQgLT4gaW50XG4gIHZhbCBjdHogOiB0IC0+IGludFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgVDBcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIGxldCB3cmFwX2V4biB4ID1cbiAgICAoKiBSYWlzZXMgaWYgdGhlIGludDY0IHZhbHVlIGRvZXMgbm90IGZpdCBvbiBpbnQ2My4gKilcbiAgICBDb252LmludDY0X2ZpdF9vbl9pbnQ2M19leG4geDtcbiAgICBDYW1sLkludDY0Lm11bCB4IDJMXG4gIDs7XG5cbiAgbGV0IHdyYXAgeCA9XG4gICAgaWYgQ29udi5pbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiBTb21lIChDYW1sLkludDY0Lm11bCB4IDJMKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgd3JhcF9tb2R1bG8geCA9IENhbWwuSW50NjQubXVsIHggMkxcbiAgbGV0IHVud3JhcCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCB4IDFcbiAgbGV0IHVud3JhcF91bnNpZ25lZCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggMVxuXG4gICgqIFRoaXMgZG9lcyBub3QgdXNlIHdyYXAgb3IgdW53cmFwIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBpbiB0aGUgY2FzZSBvZlxuICAgICBvdmVyZmxvd3MuIFRoaXMgaXMgdG8gcHJlc2VydmUgdGhlIHNlbWFudGljcyBvZiBpbnQgdHlwZSBvbiA2NCBiaXQgYXJjaGl0ZWN0dXJlLiAqKVxuICBsZXQgZjIgZiBhIGIgPVxuICAgIENhbWwuSW50NjQubXVsIChmIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGEgMSkgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYiAxKSkgMkxcbiAgOztcblxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZUxcbiAgbGV0IG0geCA9IENhbWwuSW50NjQubG9nYW5kIHggbWFza1xuICBsZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKG0gdCA9IHQpXG4gIGxldCBhZGQgeCB5ID0gQ2FtbC5JbnQ2NC5hZGQgeCB5XG4gIGxldCBzdWIgeCB5ID0gQ2FtbC5JbnQ2NC5zdWIgeCB5XG4gIGxldCBuZWcgeCA9IENhbWwuSW50NjQubmVnIHhcbiAgbGV0IGFicyB4ID0gQ2FtbC5JbnQ2NC5hYnMgeFxuICBsZXQgb25lID0gd3JhcF9leG4gMUxcbiAgbGV0IHN1Y2MgYSA9IGFkZCBhIG9uZVxuICBsZXQgcHJlZCBhID0gc3ViIGEgb25lXG4gIGxldCBtaW5fdmFsdWUgPSBtIENhbWwuSW50NjQubWluX2ludFxuICBsZXQgbWF4X3ZhbHVlID0gbSBDYW1sLkludDY0Lm1heF9pbnRcbiAgbGV0IGJpdF9ub3QgeCA9IG0gKENhbWwuSW50NjQubG9nbm90IHgpXG4gIGxldCBiaXRfYW5kID0gQ2FtbC5JbnQ2NC5sb2dhbmRcbiAgbGV0IGJpdF94b3IgPSBDYW1sLkludDY0LmxvZ3hvclxuICBsZXQgYml0X29yID0gQ2FtbC5JbnQ2NC5sb2dvclxuICBsZXQgc2hpZnRfbGVmdCB4IGkgPSBDYW1sLkludDY0LnNoaWZ0X2xlZnQgeCBpXG4gIGxldCBzaGlmdF9yaWdodCB4IGkgPSBtIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IHggaSlcbiAgbGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCBpID0gbSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggaSlcbiAgbGV0IHBvdyA9IGYyIEludF9tYXRoLlByaXZhdGUuaW50NjNfcG93X29uX2ludDY0XG4gIGxldCBtdWwgYSBiID0gQ2FtbC5JbnQ2NC5tdWwgYSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpXG4gIGxldCBkaXYgYSBiID0gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQuZGl2IGEgYilcbiAgbGV0IHJlbSBhIGIgPSBDYW1sLkludDY0LnJlbSBhIGJcbiAgbGV0IHBvcGNvdW50IHggPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudCB4XG4gIGxldCB0b19pbnQ2NCB0ID0gdW53cmFwIHRcbiAgbGV0IG9mX2ludDY0IHQgPSB3cmFwIHRcbiAgbGV0IG9mX2ludDY0X2V4biB0ID0gd3JhcF9leG4gdFxuICBsZXQgb2ZfaW50NjRfdHJ1bmMgdCA9IHdyYXBfbW9kdWxvIHRcbiAgbGV0IHRfb2Zfc2V4cCB4ID0gd3JhcF9leG4gKGludDY0X29mX3NleHAgeClcbiAgbGV0IHNleHBfb2ZfdCB4ID0gc2V4cF9vZl9pbnQ2NCAodW53cmFwIHgpXG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBpc19wb3cyIHggPSBJbnQ2NC5pc19wb3cyICh1bndyYXAgeClcblxuICBsZXQgY2x6IHggPVxuICAgICgqIFdlIHJ1biBJbnQ2NC5jbHogZGlyZWN0bHkgb24gdGhlIHdyYXBwZWQgaW50NjMgdmFsdWUuIFRoaXMgaXMgY29ycmVjdCBiZWNhdXNlIHRoZVxuICAgICAgIGJpdHMgb2YgdGhlIGludDYzX2VtdWwgYXJlIGxlZnQtYWxpZ25lZCBpbiB0aGUgSW50NjQuICopXG4gICAgSW50NjQuY2x6IHhcbiAgOztcblxuICBsZXQgY3R6IHggPSBJbnQ2NC5jdHogKHVud3JhcCB4KVxuICBsZXQgZmxvb3JfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBjZWlsX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgZmxvb3JfbG9nMiB4ID0gSW50NjQuZmxvb3JfbG9nMiAodW53cmFwIHgpXG4gIGxldCBjZWlsX2xvZzIgeCA9IEludDY0LmNlaWxfbG9nMiAodW53cmFwIHgpXG5lbmRcblxub3BlbiBXXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFcudCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBXLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChXLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKFcuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IFcuY29tcGFyYXRvclxuICBsZXQgY29tcGFyZSA9IFcuY29tcGFyZVxuICBsZXQgaW52YXJpYW50ID0gVy5pbnZhcmlhbnRcblxuICAoKiBXZSBkb24ndCBleHBlY3QgW2hhc2hdIHRvIGZvbGxvdyB0aGUgYmVoYXZpb3Igb2YgaW50IGluIDY0Yml0IGFyY2hpdGVjdHVyZSAqKVxuICBsZXQgXyA9IGhhc2hcbiAgbGV0IGhhc2ggKHggOiB0KSA9IENhbWwuSGFzaHRibC5oYXNoIHhcbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgaW52YWxpZF9zdHIgeCA9IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQ2My5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiB4ICgpXG5cbiAgKCpcbiAgICAgXCJzaWduXCIgcmVmZXJzIHRvIHdoZXRoZXIgdGhlIG51bWJlciBzdGFydHMgd2l0aCBhICctJ1xuICAgICBcInNpZ25lZG5lc3MgPSBmYWxzZVwiIG1lYW5zIHRoZSByZXN0IG9mIHRoZSBudW1iZXIgaXMgcGFyc2VkIGFzIHVuc2lnbmVkIGFuZCB0aGVuIGNhc3RcbiAgICAgdG8gc2lnbmVkIHdpdGggd3JhcC1hcm91bmQgbW9kdWxvIDJeaVxuICAgICBcInNpZ25lZG5lc3MgPSB0cnVlXCIgbWVhbnMgbm8gc3VjaCBjcmF6aW5lc3MgaGFwcGVuc1xuXG4gICAgIFRoZSB0ZXJtaW5vbG9neSBhbmQgdGhlIGxvZ2ljIGlzIGR1ZSB0byB0aGUgY29kZSBpbiBieXRlcnVuL2ludHMuYyBpbiBvY2FtbCA0LjAzXG4gICAgIChbcGFyc2Vfc2lnbl9hbmRfYmFzZV0gZnVuY3Rpb24pLlxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIHRydWUgZm9yIHBsYWluIGRlY2ltYWwgbnVtYmVyIChlLmcuIDEyMzUsIC02Nzg5KVxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIGZhbHNlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgIC0gWzB4ZmZmZl0sIFstMHhmZmZmXSAoaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBiMDEwMV0sIFstMGIwMTAxXSAoYmluYXJ5IHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswbzEyMzddLCBbLTBvMTIzN10gKG9jdGFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswdTk4MTJdLCBbLTB1OTgxMl0gKHVuc2lnbmVkIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gLSBhdmFpbGFibGUgZnJvbSBPQ2FtbCA0LjAzKSAqKVxuICBsZXQgc2lnbl9hbmRfc2lnbmVkbmVzcyB4ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB4IGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBwb3MsIHNpZ24gPVxuICAgICAgaWYgMCA8IGxlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHguWzBdIHdpdGhcbiAgICAgICAgfCAnLScgLT4gMSwgYE5lZ1xuICAgICAgICB8ICcrJyAtPiAxLCBgUG9zXG4gICAgICAgIHwgXyAtPiAwLCBgUG9zKVxuICAgICAgZWxzZSAwLCBgUG9zXG4gICAgaW5cbiAgICBpZiBwb3MgKyAyIDwgbGVuXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYzEgPSB4Lltwb3NdIGluXG4gICAgICBsZXQgYzIgPSB4Lltwb3MgKyAxXSBpblxuICAgICAgbWF0Y2ggYzEsIGMyIHdpdGhcbiAgICAgIHwgJzAnLCAnMCcgLi4gJzknIC0+IHNpZ24sIHRydWVcbiAgICAgIHwgJzAnLCBfIC0+IHNpZ24sIGZhbHNlXG4gICAgICB8IF8gLT4gc2lnbiwgdHJ1ZSlcbiAgICBlbHNlIHNpZ24sIHRydWVcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nIHggPSBDYW1sLkludDY0LnRvX3N0cmluZyAodW53cmFwIHgpXG5cbiAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgIHRyeVxuICAgICAgbGV0IHNpZ24sIHNpZ25lZG5lc3MgPSBzaWduX2FuZF9zaWduZWRuZXNzIHN0ciBpblxuICAgICAgaWYgc2lnbmVkbmVzc1xuICAgICAgdGhlbiBvZl9pbnQ2NF9leG4gKENhbWwuSW50NjQub2Zfc3RyaW5nIHN0cilcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcG9zX3N0ciA9XG4gICAgICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICAgICAgfCBgTmVnIC0+IFN0cmluZy5zdWIgc3RyIH5wb3M6MSB+bGVuOihTdHJpbmcubGVuZ3RoIHN0ciAtIDEpXG4gICAgICAgICAgfCBgUG9zIC0+IHN0clxuICAgICAgICBpblxuICAgICAgICBsZXQgaW50NjQgPSBDYW1sLkludDY0Lm9mX3N0cmluZyBwb3Nfc3RyIGluXG4gICAgICAgICgqIHVuc2lnbmVkIDYzLWJpdCBpbnQgbXVzdCBwYXJzZSBhcyBhIHBvc2l0aXZlIHNpZ25lZCA2NC1iaXQgaW50ICopXG4gICAgICAgIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpbnQ2NCAwTCB0aGVuIGludmFsaWRfc3RyIHN0cjtcbiAgICAgICAgbGV0IGludDYzID0gd3JhcF9tb2R1bG8gaW50NjQgaW5cbiAgICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICAgIHwgYE5lZyAtPiBuZWcgaW50NjNcbiAgICAgICAgfCBgUG9zIC0+IGludDYzKVxuICAgIHdpdGhcbiAgICB8IF8gLT4gaW52YWxpZF9zdHIgc3RyXG4gIDs7XG5cbiAgbGV0IGJzd2FwMTYgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDE2ICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDMyIHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAzMiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXA0OCB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwNDggKHVud3JhcCB0KSlcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IG51bV9iaXRzID0gNjNcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGJpdF9ub3RcbmxldCBiaXRfeG9yID0gYml0X3hvclxubGV0IGJpdF9vciA9IGJpdF9vclxubGV0IGJpdF9hbmQgPSBiaXRfYW5kXG5sZXQgcG9wY291bnQgPSBwb3Bjb3VudFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBwb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtYXhfdmFsdWUgPSBtYXhfdmFsdWVcbmxldCBtaW5fdmFsdWUgPSBtaW5fdmFsdWVcbmxldCBtaW51c19vbmUgPSB3cmFwX2V4biBDYW1sLkludDY0Lm1pbnVzX29uZVxubGV0IG9uZSA9IHdyYXBfZXhuIENhbWwuSW50NjQub25lXG5sZXQgemVybyA9IHdyYXBfZXhuIENhbWwuSW50NjQuemVyb1xubGV0IGlzX3BvdzIgPSBpc19wb3cyXG5sZXQgZmxvb3JfcG93MiA9IGZsb29yX3BvdzJcbmxldCBjZWlsX3BvdzIgPSBjZWlsX3BvdzJcbmxldCBmbG9vcl9sb2cyID0gZmxvb3JfbG9nMlxubGV0IGNlaWxfbG9nMiA9IGNlaWxfbG9nMlxubGV0IGNseiA9IGNselxubGV0IGN0eiA9IGN0elxubGV0IHRvX2Zsb2F0IHggPSBDYW1sLkludDY0LnRvX2Zsb2F0ICh1bndyYXAgeClcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgeCA9IHdyYXBfbW9kdWxvIChDYW1sLkludDY0Lm9mX2Zsb2F0IHgpXG5cbmxldCBvZl9mbG9hdCB0ID1cbiAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIHQgPj0gZmxvYXRfbG93ZXJfYm91bmQgJiYgdCA8PSBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIHdyYXBfbW9kdWxvIChDYW1sLkludDY0Lm9mX2Zsb2F0IHQpXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDYzLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgb2ZfaW50NjQgPSBvZl9pbnQ2NFxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gb2ZfaW50NjRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IHRvX2ludDY0XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxuXG4oKiBXZSBjYW4gcmV1c2UgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tL3RvIGludDY0IGhlcmUuICopXG5sZXQgb2ZfaW50IHggPSB3cmFwX2V4biAoQ29udi5pbnRfdG9faW50NjQgeClcbmxldCBvZl9pbnRfZXhuIHggPSBvZl9pbnQgeFxubGV0IHRvX2ludCB4ID0gQ29udi5pbnQ2NF90b19pbnQgKHVud3JhcCB4KVxubGV0IHRvX2ludF9leG4geCA9IENvbnYuaW50NjRfdG9faW50X2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50X3RydW5jIHggPSBDb252LmludDY0X3RvX2ludF90cnVuYyAodW53cmFwIHgpXG5sZXQgb2ZfaW50MzIgeCA9IHdyYXBfZXhuIChDb252LmludDMyX3RvX2ludDY0IHgpXG5sZXQgb2ZfaW50MzJfZXhuIHggPSBvZl9pbnQzMiB4XG5sZXQgdG9faW50MzIgeCA9IENvbnYuaW50NjRfdG9faW50MzIgKHVud3JhcCB4KVxubGV0IHRvX2ludDMyX2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG4gKHVud3JhcCB4KVxubGV0IHRvX2ludDMyX3RydW5jIHggPSBDb252LmludDY0X3RvX2ludDMyX3RydW5jICh1bndyYXAgeClcbmxldCBvZl9uYXRpdmVpbnQgeCA9IG9mX2ludDY0IChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IG9mX25hdGl2ZWludF9leG4geCA9IHdyYXBfZXhuIChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IG9mX25hdGl2ZWludF90cnVuYyB4ID0gb2ZfaW50NjRfdHJ1bmMgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgdG9fbmF0aXZlaW50IHggPSBDb252LmludDY0X3RvX25hdGl2ZWludCAodW53cmFwIHgpXG5sZXQgdG9fbmF0aXZlaW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jICh1bndyYXAgeClcblxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoVC5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIFQuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gVC5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSAoIH4tIClcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuXG4gICAgbGV0IHRvX3N0cmluZyBpID1cbiAgICAgICgqIHRoZSB1c2Ugb2YgW3Vud3JhcF91bnNpZ25lZF0gaGVyZSBpcyBpbXBvcnRhbnQgZm9yIHRoZSBjYXNlIG9mIFttaW5fdmFsdWVdICopXG4gICAgICBQcmludGYuc3ByaW50ZiBcIiVMeFwiICh1bndyYXBfdW5zaWduZWQgaSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzID0gb2Zfc3RyaW5nIChcIjB4XCIgXiBzKVxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2My5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nIHggPSB0b19zdHJpbmcgeFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2M1wiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50NjNdIGFuZCBbSW50NjMuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIGVtdWxhdGVkID0gdFxuXG4gIHR5cGUgKCd1bmRlcmx5aW5nX3R5cGUsICdpbnRlcm1lZGlhdGVfdHlwZSkgdCA9XG4gICAgfCBJbnQgOiAoaW50LCBpbnQpIHRcbiAgICB8IEludDY0IDogKGludDY0LCBlbXVsYXRlZCkgdFxuZW5kXG5cbmxldCByZXByID0gUmVwci5JbnQ2NFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYm9vbCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9ib29sIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIGZhbHNlOyB0cnVlIF0gOiB0IGxpc3QpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9ib29sXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9ib29sIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChib29sX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2Jvb2wgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYm9vbF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICAgIHwgcyAtPiBpbnZhbGlkX2FyZ2YgXCJCb29sLm9mX3N0cmluZzogZXhwZWN0ZWQgdHJ1ZSBvciBmYWxzZSBidXQgZ290ICVzXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBDYW1sLnN0cmluZ19vZl9ib29sXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQm9vbFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCB0b19pbnQgeCA9IGJvb2xfdG9faW50IHhcblxubW9kdWxlIE5vbl9zaG9ydF9jaXJjdWl0aW5nID0gc3RydWN0XG4gICgqIFdlIGRvbid0IGV4cG9zZSB0aGlzLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBpbnZhcmlhbnQgbWVudGlvbmVkIGJlbG93IG9mXG4gICAgICh0b19pbnQgdHJ1ZSA9IDEpIGFuZCAodG9faW50IGZhbHNlID0gMCkuICopXG4gIGxldCB1bnNhZmVfb2ZfaW50ICh4IDogaW50KSA6IGJvb2wgPSBDYW1sLk9iai5tYWdpYyB4XG4gIGxldCAoIHx8ICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbG9yIHRvX2ludCBiKVxuICBsZXQgKCAmJiApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxhbmQgdG9faW50IGIpXG5lbmRcblxuKCogV2UgZG8gdGhpcyBhcyBhIGRpcmVjdCBhc3NlcnQgb24gdGhlIHRoZW9yeSB0aGF0IGl0J3MgYSBjaGVhcCB0aGluZyB0byB0ZXN0IGFuZCBhXG4gICByZWFsbHkgY29yZSBpbnZhcmlhbnQgdGhhdCB3ZSBuZXZlciBleHBlY3QgdG8gYnJlYWssIGFuZCB3ZSBzaG91bGQgYmUgaGFwcHkgZm9yIGFcbiAgIHByb2dyYW0gdG8gZmFpbCBpbW1lZGlhdGVseSBpZiB0aGlzIGlzIHZpb2xhdGVkLiAqKVxubGV0ICgpID0gYXNzZXJ0IChQb2x5LiggPSApICh0b19pbnQgdHJ1ZSkgMSAmJiBQb2x5LiggPSApICh0b19pbnQgZmFsc2UpIDApXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLkludDMyXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDMyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDMyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDMyX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSAzMlxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IGNvbXBhcmUgPSBjb21wYXJlXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50MzIub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIEluZml4X2NvbXBhcmUgPSBzdHJ1Y3RcbiAgb3BlbiBQb2x5XG5cbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSB4ID49IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSB4IDw9IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSB4ID4geVxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0geCA8IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSB4IDw+IHlcbmVuZFxuXG5tb2R1bGUgQ29tcGFyZSA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4X2NvbXBhcmVcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBDb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX2ludDMyIHQgPSB0XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiB0ID0gdFxubGV0IHRvX2ludDMyX2V4biA9IHRvX2ludDMyXG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnQzMl9wb3Bjb3VudFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9faW50MzJcbmxldCBvZl9pbnRfZXhuID0gQ29udi5pbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50X3RydW5jID0gQ29udi5pbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQgPSBDb252LmludDMyX3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDMyX3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252LmludDMyX3RvX2ludF90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBDb252LmludDY0X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252LmludDMyX3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBwb3cgYiBlID0gb2ZfaW50X2V4biAoSW50X21hdGguUHJpdmF0ZS5pbnRfcG93ICh0b19pbnRfZXhuIGIpICh0b19pbnRfZXhuIGUpKVxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwMzIgOiB0IC0+IHQgPSBcIiVic3dhcF9pbnQzMlwiXG5cbmxldCBic3dhcDE2IHggPSBDYW1sLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwMzIgeCkgMTZcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5JbnQzMi5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLkludDMyLmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuSW50MzIucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBDYW1sLkludDMyLnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBDYW1sLkludDMyLnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLkludDMyLnByZWQgeCA9IENhbWwuSW50MzIuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludDMyIGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgICgqIFRoZSBbaSA9IDFdIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIGNseigwKSBpcyB1bmRlZmluZWQgKilcbiAgICBpZiBDYW1sLkludDMyLmVxdWFsIGkgQ2FtbC5JbnQzMi5vbmUgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuSW50MzIucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDMyIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSAoIH4tIClcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJWx4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlbHhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMi5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyXCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoQ29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50MzJdIGFuZCBbSW50MzIuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBQcmludGZcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuaW5jbHVkZSBGbG9hdDBcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9mbG9hdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfZmxvYXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGZsb2F0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2Zsb2F0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGZsb2F0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCB0b19mbG9hdCB4ID0geFxubGV0IG9mX2Zsb2F0IHggPSB4XG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIHRyeSBmbG9hdF9vZl9zdHJpbmcgcyB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5vZl9zdHJpbmcgJXNcIiBzICgpXG47O1xuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqIFN0b2xlbiBmcm9tIFtwZXJ2YXNpdmVzLm1sXS4gIEFkZHMgYSBcIi5cIiBhdCB0aGUgZW5kIGlmIG5lZWRlZC4gIEl0IGlzIGluXG4gICBbcGVydmFzaXZlcy5tbGldLCBidXQgaXQgYWxzbyBzYXlzIG5vdCB0byB1c2UgaXQgZGlyZWN0bHksIHNvIHdlIGNvcHkgYW5kIHBhc3RlIHRoZVxuICAgY29kZS4gSXQgbWFrZXMgdGhlIGFzc3VtcHRpb24gb24gdGhlIHN0cmluZyBwYXNzZWQgaW4gYXJndW1lbnQgdGhhdCBpdCB3YXMgcmV0dXJuZWQgYnlcbiAgIFtmb3JtYXRfZmxvYXRdLiAqKVxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgaSBsXG4gICAgdGhlbiBzIF4gXCIuXCJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICAgIHwgXyAtPiBzKVxuICBpblxuICBsb29wIDBcbjs7XG5cbigqIExldCBbeV0gYmUgYSBwb3dlciBvZiAyLiAgVGhlbiB0aGUgbmV4dCByZXByZXNlbnRhYmxlIGZsb2F0IGlzOlxuICAgW3ogPSB5ICogKDEgKyAyICoqIC01MildXG4gICBhbmQgdGhlIHByZXZpb3VzIG9uZSBpc1xuICAgW3ggPSB5ICogKDEgLSAyICoqIC01MyldXG5cbiAgIEluIGdlbmVyYWwsIGV2ZXJ5IHR3byBhZGphY2VudCBmbG9hdHMgYXJlIHdpdGhpbiBhIGZhY3RvciBvZiBiZXR3ZWVuIFsxICsgMioqLTUzXVxuICAgYW5kIFsxICsgMioqLTUyXSBmcm9tIGVhY2ggb3RoZXIsIHRoYXQgaXMgd2l0aGluIFsxICsgMS4xZS0xNl0gYW5kIFsxICsgMi4zZS0xNl0uXG5cbiAgIFNvIGlmIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZmxvYXQgc3RhcnRzIHdpdGggXCIxXCIsIHRoZW4gaXRzIGFkamFjZW50IGZsb2F0c1xuICAgd2lsbCB1c3VhbGx5IGRpZmZlciBmcm9tIGl0IGJ5IDEsIGFuZCBzb21ldGltZXMgYnkgMiwgYXQgdGhlIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRcbiAgIChjb3VudGluZyBmcm9tIDEpLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gc3RhcnRzIHdpdGggXCI5XCIsIHRoZW4gdGhlIGFkamFjZW50XG4gICBmbG9hdHMgd2lsbCBiZSBvZmYgYnkgbm8gbW9yZSB0aGFuIDIzIGF0IHRoZSAxNnRoIGFuZCAxN3RoIHNpZ25pZmljYW50IGRpZ2l0cy5cblxuICAgRS5nLjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2N1xuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTlcIlxuICAgdn1cbiAgIFByaW50aW5nIGEgY291cGxlIG9mIGV4dHJhIGRpZ2l0cyByZXZlYWxzIHRoYXQgdGhlIGRpZmZlcmVuY2UgaW5kZWVkIGlzIHJvdWdobHkgMTEgYXRcbiAgIGRpZ2l0cyAxN3RoIGFuZCAxOHRoICh0aGF0IGlzLCAxM3RoIGFuZCAxNHRoIGFmdGVyIFwiLlwiKTpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyMy45OTk5OTk5OTk5OTk4ODZcIlxuICAgdn1cblxuICAgVGhlIHVscCAodGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhZGphY2VudCBmbG9hdHMpIGlzIHR3aWNlIGFzIGJpZyBvbiB0aGUgb3RoZXIgc2lkZSBvZlxuICAgMTAyNC46XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTlnXCIgKDEwMjQuICouICgxLiArLiAyLioqICgtNTIuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2Nzg5XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjQuMDAwMDAwMDAwMDAwMjI3XCJcbiAgIHZ9XG5cbiAgIE5vdyB0YWtlIGEgcG93ZXIgb2YgMiB3aGljaCBzdGFydHMgd2l0aCA5OTpcblxuICAge3ZcbiAgICAgIyAyLioqOTMuIDs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgMSAyMzQ1Njc4OTAxMjM0NTY3OFxuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MjJlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiArLiAyLioqICgtNTIuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0NDRlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiAtLiAyLioqICgtNTMuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MTFlKzI3XG4gICB2fVxuXG4gICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIDIqKjkzIGFuZCBpdHMgdHdvIG5laWdoYm9ycyBpcyBzbGlnaHRseSBtb3JlIHRoYW4sIHJlc3BlY3RpdmVseSxcbiAgIDEgYW5kIDIgYXQgc2lnbmlmaWNhbnQgZGlnaXQgMTYuXG5cbiAgIFRob3NlIGV4YW1wbGVzIHNob3cgdGhhdDpcbiAgIC0gMTcgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIGFsd2F5cyBzdWZmaWNpZW50IHRvIHJlcHJlc2VudCBhIGZsb2F0IHdpdGhvdXQgYW1iaWd1aXR5XG4gICAtIDE1dGggc2lnbmlmaWNhbnQgZGlnaXQgY2FuIGFsd2F5cyBiZSByZXByZXNlbnRlZCBhY2N1cmF0ZWx5XG4gICAtIGNvbnZlcnRpbmcgYSBkZWNpbWFsIG51bWJlciB3aXRoIDE2IHNpZ25pZmljYW50IGRpZ2l0cyB0byBpdHMgbmVhcmVzdCBmbG9hdCBhbmQgYmFja1xuICAgICBjYW4gY2hhbmdlIHRoZSBsYXN0IGRlY2ltYWwgZGlnaXQgYnkgbm8gbW9yZSB0aGFuIDFcblxuICAgVG8gbWFrZSBzdXJlIHRoYXQgZmxvYXRzIG9idGFpbmVkIGJ5IGNvbnZlcnNpb24gZnJvbSBkZWNpbWFsIGZyYWN0aW9ucyAoZS5nLiBcIjMuMTRcIilcbiAgIGFyZSBwcmludGVkIHdpdGhvdXQgdHJhaWxpbmcgbm9uLXplcm8gZGlnaXRzLCBvbmUgc2hvdWxkIGNob29zZSB0aGUgZmlyc3QgYW1vbmcgdGhlXG4gICAnJS4xNWcnLCAnJS4xNmcnLCBhbmQgJyUuMTdnJyByZXByZXNlbnRhdGlvbnMgd2hpY2ggZG9lcyByb3VuZC10cmlwOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0XCIgICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0MDAwMDAwMDAwMDAwMDFcIiAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZSAqKVxuXG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4XCIgICAgICAgICAgICAgICAgICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tZG9lcyBub3Qgcm91bmQtdHJpcCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOC4wMDAwMDAwMDAwMDAwMDJcIiAgICAgICAgKCogcHJlZmVyIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMThcIiAgICAgICAoKiB0aGlzIG9uZSBoYXMgb25lIGRpZ2l0IG9mIGp1bmsgYXQgdGhlIGVuZCAqKVxuICAgdn1cblxuICAgU2tpcHBpbmcgdGhlICclLjE2ZycgaW4gdGhlIGFib3ZlIHByb2NlZHVyZSBzYXZlcyB1cyBzb21lIHRpbWUsIGJ1dCBpdCBtZWFucyB0aGF0LCBhc1xuICAgc2VlbiBpbiB0aGUgc2Vjb25kIGV4YW1wbGUgYWJvdmUsIG9jY2FzaW9uYWxseSBudW1iZXJzIHdpdGggZXhhY3RseSAxNiBzaWduaWZpY2FudFxuICAgZGlnaXRzIHdpbGwgaGF2ZSBhbiBlcnJvciBpbnRyb2R1Y2VkIGF0IHRoZSAxN3RoIGRpZ2l0LiAgVGhhdCBpcyBwcm9iYWJseSBPSyBmb3JcbiAgIHR5cGljYWwgdXNlLCBiZWNhdXNlIGEgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIFwidWdseVwiIGFscmVhZHkuICBBZGRpbmcgb25lXG4gICBtb3JlIGRvZXNuJ3QgbWFrZSBpdCBtdWNoIHdvcnNlIGZvciBhIGh1bWFuIHJlYWRlci5cblxuICAgT24gdGhlIG90aGVyIGhhbmQsIHdlIGNhbm5vdCBza2lwICclLjE1ZycgYW5kIG9ubHkgbG9vayBhdCAnJS4xNmcnIGFuZCAnJS4xN2cnLCBzaW5jZVxuICAgdGhlIGluYWNjdXJhY3kgYXQgdGhlIDE2dGggZGlnaXQgbWlnaHQgaW50cm9kdWNlIHRoZSBub2lzZSB3ZSB3YW50IHRvIGF2b2lkOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTJcIiAgICAgICAgICAgICAgICAgICAgKCogcGljayB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDFcIiAgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUtLWp1bmsgYXQgdGhlIGVuZCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDA5XCJcbiAgIHZ9XG4qKVxubGV0IHRvX3N0cmluZyB4ID1cbiAgdmFsaWRfZmxvYXRfbGV4ZW1cbiAgICAobGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1Z1wiIHggaW5cbiAgICAgaWYgZmxvYXRfb2Zfc3RyaW5nIHkgPSB4IHRoZW4geSBlbHNlIGZvcm1hdF9mbG9hdCBcIiUuMTdnXCIgeClcbjs7XG5cbmxldCBtYXhfdmFsdWUgPSBpbmZpbml0eVxubGV0IG1pbl92YWx1ZSA9IG5lZ19pbmZpbml0eVxubGV0IG1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTA3NC5cbmxldCBtaW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gMi4gKiogLTEwMjIuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBwaSA9IDB4My4yNDNGNkE4ODg1QTMwOEQzMTMxOThBMkUwMzcwNzNcbmxldCBzcXJ0X3BpID0gMHgxLkM1QkY4OTFCNEVGNkFBNzlDM0IwNTIwRDVEQjkzOFxubGV0IHNxcnRfMnBpID0gMHgyLjgxQjI2M0ZFQzRFMEIyQ0FGOTQ4M0Y1Q0U0NTlEQ1xubGV0IGV1bGVyID0gMHgwLjkzQzQ2N0UzN0RCMEM3QTREMUJFM0Y4MTAxNTJDQlxubGV0IG9mX2ludCA9IEludC50b19mbG9hdFxubGV0IHRvX2ludCA9IEludC5vZl9mbG9hdFxubGV0IG9mX2ludDYzIGkgPSBJbnQ2My50b19mbG9hdCBpXG5sZXQgb2ZfaW50NjQgaSA9IENhbWwuSW50NjQudG9fZmxvYXQgaVxubGV0IHRvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9mbG9hdFxubGV0IGlyb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xubGV0IGlyb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xuXG4oKiBUaGUgcGVyZm9ybWFuY2Ugb2YgdGhlIFwiZXhuXCIgcm91bmRpbmcgZnVuY3Rpb25zIGlzIGltcG9ydGFudCwgc28gdGhleSBhcmUgd3JpdHRlblxuICAgb3V0IHNlcGFyYXRlbHksIGFuZCB0dW5lZCBpbmRpdmlkdWFsbHkuICAoV2UgY291bGQgaGF2ZSB0aGUgb3B0aW9uIHZlcnNpb25zIGNhbGxcbiAgIHRoZSBcImV4blwiIHZlcnNpb25zLCBidXQgdGhhdCBpbXBvc2VzIGFyZ3VhYmx5IGdyYXR1aXRvdXMgb3ZlcmhlYWQtLS1lc3BlY2lhbGx5XG4gICBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBvZiBiYWNrdHJhY2VzIGlzIGVuYWJsZWQgdXBvbiBcIndpdGhcIi0tLWFuZCB0aGF0IHNlZW1zXG4gICBub3Qgd29ydGggaXQgd2hlbiBjb21wYXJlZCB0byB0aGUgcmVsYXRpdmVseSBzbWFsbCBhbW91bnQgb2YgY29kZSBkdXBsaWNhdGlvbi4pICopXG5cbigqIEVycm9yIHJlcG9ydGluZyBiZWxvdyBpcyB2ZXJ5IGNhcmVmdWxseSBhcnJhbmdlZCBzbyB0aGF0LCBlLmcuLCBbaXJvdW5kX25lYXJlc3RfZXhuXVxuICAgaXRzZWxmIGNhbiBiZSBpbmxpbmVkIGludG8gY2FsbGVycyBzdWNoIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGEgYm94IGZvciB0aGVcbiAgIFtmbG9hdF0gYXJndW1lbnQuICBUaGlzIGlzIGRvbmUgd2l0aCBhIGJveCBbYm94XSBmdW5jdGlvbiBjYXJlZnVsbHkgY2hvc2VuIHRvIGFsbG93IHRoZVxuICAgY29tcGlsZXIgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm94IGZvciB0aGUgZmxvYXQgb25seSBpbiBlcnJvciBjYXNlcy4gIFNlZSwgZS5nLixcbiAgIFsuLi8uLi96ZXJvL3Rlc3QvcHJpY2VfdGVzdC5tbF0gZm9yIGEgbWVjaGFuaWNhbCB0ZXN0IG9mIHRoaXMgcHJvcGVydHkgd2hlbiBidWlsZGluZ1xuICAgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPXRydWVdLiAqKVxuXG5sZXQgaXJvdW5kX3VwIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9kb3duIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuIGlmIHQgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCkgZWxzZSBOb25lXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKCkpXG47O1xuXG5sZXQgaXJvdW5kX3Rvd2FyZHNfemVybyB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaXJvdW5kX3Rvd2FyZHNfemVyb19leG46IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoYm94IHQpXG4gICAgICAoKVxuOztcblxuKCogT3V0c2lkZSBvZiB0aGUgcmFuZ2UgKHJvdW5kX25lYXJlc3RfbGIuLnJvdW5kX25lYXJlc3RfdWIpLCBhbGwgcmVwcmVzZW50YWJsZSBkb3VibGVzXG4gICBhcmUgaW50ZWdlcnMgaW4gdGhlIG1hdGhlbWF0aWNhbCBzZW5zZSwgYW5kIFtyb3VuZF9uZWFyZXN0XSBzaG91bGQgYmUgaWRlbnRpdHkuXG5cbiAgIEhvd2V2ZXIsIGZvciBvZGQgbnVtYmVycyB3aXRoIHRoZSBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuIDIqKjUyIGFuZCAyKio1MywgdGhlIGZvcm11bGFcbiAgIFtyb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArIDAuNSldIGRvZXMgbm90IGhvbGQ6XG5cbiAgIHt2XG4gICAgICMgbGV0IG5haXZlX3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsuIDAuNSk7O1xuICAgICAjIGxldCB4ID0gMi4gKiogNTIuICsuIDEuOztcbiAgICAgdmFsIHggOiBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTcuXG4gICAgICMgbmFpdmVfcm91bmRfbmVhcmVzdCB4OztcbiAgICAgLSA6ICAgICBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTguXG4gICB2fVxuKilcblxubGV0IHJvdW5kX25lYXJlc3RfbGIgPSAtLigyLiAqKiA1Mi4pXG5sZXQgcm91bmRfbmVhcmVzdF91YiA9IDIuICoqIDUyLlxuXG4oKiBGb3IgW3ggPSBvbmVfdWxwIGBEb3duIDAuNV0sIHRoZSBmb3JtdWxhIFtmbG9vciAoeCArLiAwLjUpXSBmb3Igcm91bmRpbmcgdG8gbmVhcmVzdFxuICAgZG9lcyBub3Qgd29yaywgYmVjYXVzZSB0aGUgZXhhY3QgcmVzdWx0IGlzIGhhbGZ3YXkgYmV0d2VlbiBbb25lX3VscCBgRG93biAxLl0gYW5kIFsxLl0sXG4gICBhbmQgaXQgZ2V0cyByb3VuZGVkIHVwIHRvIFsxLl0gZHVlIHRvIHRoZSByb3VuZC10aWVzLXRvLWV2ZW4gcnVsZS4gKilcbmxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscCBgRG93biAwLjVcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0ID1cbiAgdFxuICArLlxuICBpZiB0ID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICB0aGVuIG9uZV91bHBfbGVzc190aGFuX2hhbGYgKCogc2luY2UgdCA8IDAuNSwgbWFrZSBzdXJlIHRoZSByZXN1bHQgaXMgPCAxLjAgKilcbiAgZWxzZSAwLjVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KSlcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICAgIGVsc2UgTm9uZVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF8zMlxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4bl8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX25lYXJlc3RfZXhuXzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF9leG5fNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzMyXG47O1xuXG4oKiBUaGUgZm9sbG93aW5nIFtpcm91bmRfZXhuXSBhbmQgW2lyb3VuZF0gZnVuY3Rpb25zIGFyZSBzbG93ZXIgdGhhbiB0aGUgb25lcyBhYm92ZS5cbiAgIFRoZWlyIGVxdWl2YWxlbmNlIHRvIHRob3NlIGZ1bmN0aW9ucyBpcyB0ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHMgYmVsb3cuICopXG5cbmxldFtAaW5saW5lXSBpcm91bmRfZXhuID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBaZXJvIC0+IGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHRcbiAgfCBgTmVhcmVzdCAtPiBpcm91bmRfbmVhcmVzdF9leG4gdFxuICB8IGBVcCAtPiBpcm91bmRfdXBfZXhuIHRcbiAgfCBgRG93biAtPiBpcm91bmRfZG93bl9leG4gdFxuOztcblxubGV0IGlyb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgdHJ5IFNvbWUgKGlyb3VuZF9leG4gfmRpciB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgaXNfaW5mIHQgPSAxLiAvLiB0ID0gMC5cbmxldCBpc19maW5pdGUgdCA9IHQgLS4gdCA9IDAuXG5cbmxldCBtaW5faW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgbWF4X2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IGFkZCA9ICggKy4gKVxubGV0IHN1YiA9ICggLS4gKVxubGV0IG5lZyA9ICggfi0uIClcbmxldCBhYnMgPSBhYnNfZmxvYXRcbmxldCBzY2FsZSA9ICggKi4gKVxubGV0IHNxdWFyZSB4ID0geCAqLiB4XG5cbm1vZHVsZSBQYXJ0cyA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZnJhY3Rpb25hbCA6IHQgLT4gZmxvYXRcbiAgdmFsIGludGVncmFsIDogdCAtPiBmbG9hdFxuICB2YWwgbW9kZiA6IGZsb2F0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCAqIGZsb2F0XG5cbiAgbGV0IGZyYWN0aW9uYWwgdCA9IGZzdCB0XG4gIGxldCBpbnRlZ3JhbCB0ID0gc25kIHRcbiAgbGV0IG1vZGYgPSBtb2RmXG5lbmRcblxubGV0IG1vZGYgPSBQYXJ0cy5tb2RmXG5sZXQgcm91bmRfZG93biA9IGZsb29yXG5sZXQgcm91bmRfdXAgPSBjZWlsXG5sZXQgcm91bmRfdG93YXJkc196ZXJvIHQgPSBpZiB0ID49IDAuIHRoZW4gcm91bmRfZG93biB0IGVsc2Ugcm91bmRfdXAgdFxuXG4oKiBzZWUgdGhlIGNvbW1lbnQgYWJvdmUgW3JvdW5kX25lYXJlc3RfbGJdIGFuZCBbcm91bmRfbmVhcmVzdF91Yl0gZm9yIGFuIGV4cGxhbmF0aW9uICopXG5sZXRbQG9jYW1sLmlubGluZV0gcm91bmRfbmVhcmVzdF9pbmxpbmUgdCA9XG4gIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiICYmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gZmxvb3IgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gIGVsc2UgdCArLiAwLlxuOztcblxubGV0IHJvdW5kX25lYXJlc3QgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdFxuXG5sZXQgcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gdCA9XG4gIGlmIHQgPD0gcm91bmRfbmVhcmVzdF9sYiB8fCB0ID49IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiB0ICsuIDAuXG4gIGVsc2UgKFxuICAgIGxldCBmbG9vciA9IGZsb29yIHQgaW5cbiAgICAoKiBbY2VpbF9vcl9zdWNjID0gaWYgdCBpcyBhbiBpbnRlZ2VyIHRoZW4gdCArLiAxLiBlbHNlIGNlaWwgdF0uICBGYXN0ZXIgdGhhbiBbY2VpbF0uICopXG4gICAgbGV0IGNlaWxfb3Jfc3VjYyA9IGZsb29yICsuIDEuIGluXG4gICAgbGV0IGRpZmZfZmxvb3IgPSB0IC0uIGZsb29yIGluXG4gICAgbGV0IGRpZmZfY2VpbCA9IGNlaWxfb3Jfc3VjYyAtLiB0IGluXG4gICAgaWYgZGlmZl9mbG9vciA8IGRpZmZfY2VpbFxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGlmIGRpZmZfZmxvb3IgPiBkaWZmX2NlaWxcbiAgICB0aGVuIGNlaWxfb3Jfc3VjY1xuICAgIGVsc2UgaWYgKCogZXhhY3QgdGllLCBwaWNrIHRoZSBldmVuICopXG4gICAgICBtb2RfZmxvYXQgZmxvb3IgMi4gPSAwLlxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGNlaWxfb3Jfc3VjYylcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5sZXQgaW50NjNfcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xuXG5sZXQgaW50NjNfcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biB0MCA9XG4gIGxldCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0MCBpblxuICBpZiB0ID4gMC5cbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChib3ggdDApXG4gICAgICAgICgpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKGJveCB0MClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gZiA9IEludDYzLm9mX2ludCAoaXJvdW5kX25lYXJlc3RfZXhuIGYpXG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICB8IFczMiAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuOztcblxubGV0IHJvdW5kID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBOZWFyZXN0IC0+IHJvdW5kX25lYXJlc3QgdFxuICB8IGBEb3duIC0+IHJvdW5kX2Rvd24gdFxuICB8IGBVcCAtPiByb3VuZF91cCB0XG4gIHwgYFplcm8gLT4gcm91bmRfdG93YXJkc196ZXJvIHRcbjs7XG5cbm1vZHVsZSBDbGFzcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgSW5maW5pdGVcbiAgICB8IE5hblxuICAgIHwgTm9ybWFsXG4gICAgfCBTdWJub3JtYWxcbiAgICB8IFplcm9cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEluZmluaXRlOyBOYW47IE5vcm1hbDsgU3Vibm9ybWFsOyBaZXJvIF0gOiB0IGxpc3QpXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcImZsb2F0Lm1sLkNsYXNzLnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSAtPiBJbmZpbml0ZVxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIC0+IE5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIC0+IFN1Ym5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICB8IHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgSW5maW5pdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5maW5pdGVcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgIHwgTm9ybWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5vcm1hbFwiXG4gICAgICB8IFN1Ym5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdWJub3JtYWxcIlxuICAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiSW5maW5pdGVcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTmFuXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJTdWJub3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmVuZFxuXG5sZXQgY2xhc3NpZnkgdCA9XG4gIGxldCBtb2R1bGUgQyA9IENsYXNzIGluXG4gIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHQgd2l0aFxuICB8IEZQX25vcm1hbCAtPiBDLk5vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbCAtPiBDLlN1Ym5vcm1hbFxuICB8IEZQX3plcm8gLT4gQy5aZXJvXG4gIHwgRlBfaW5maW5pdGUgLT4gQy5JbmZpbml0ZVxuICB8IEZQX25hbiAtPiBDLk5hblxuOztcblxubGV0IGluc2VydF91bmRlcnNjb3JlcyA/KGRlbGltaXRlciA9ICdfJykgPyhzdHJpcF96ZXJvID0gZmFsc2UpIHN0cmluZyA9XG4gIG1hdGNoIFN0cmluZy5sc3BsaXQyIHN0cmluZyB+b246Jy4nIHdpdGhcbiAgfCBOb25lIC0+IEludF9jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIHN0cmluZyB+ZGVsaW1pdGVyXG4gIHwgU29tZSAobGVmdCwgcmlnaHQpIC0+XG4gICAgbGV0IGxlZnQgPSBJbnRfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBsZWZ0IH5kZWxpbWl0ZXIgaW5cbiAgICBsZXQgcmlnaHQgPVxuICAgICAgaWYgc3RyaXBfemVybyB0aGVuIFN0cmluZy5yc3RyaXAgcmlnaHQgfmRyb3A6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnMCcpIGVsc2UgcmlnaHRcbiAgICBpblxuICAgIChtYXRjaCByaWdodCB3aXRoXG4gICAgIHwgXCJcIiAtPiBsZWZ0XG4gICAgIHwgXyAtPiBsZWZ0IF4gXCIuXCIgXiByaWdodClcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID9kZWxpbWl0ZXIgPyhkZWNpbWFscyA9IDMpID9zdHJpcF96ZXJvID8oZXhwbGljaXRfcGx1cyA9IGZhbHNlKSBmID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBkZWNpbWFscyAwXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwidG9fc3RyaW5nX2h1bTogaW52YWxpZCBhcmd1bWVudCB+ZGVjaW1hbHM9JWRcIiBkZWNpbWFscyAoKTtcbiAgbWF0Y2ggY2xhc3NpZnkgZiB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgZiA+IDAuIHRoZW4gXCJpbmZcIiBlbHNlIFwiLWluZlwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuXCJcbiAgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IHMgPVxuICAgICAgaWYgZXhwbGljaXRfcGx1cyB0aGVuIHNwcmludGYgXCIlKy4qZlwiIGRlY2ltYWxzIGYgZWxzZSBzcHJpbnRmIFwiJS4qZlwiIGRlY2ltYWxzIGZcbiAgICBpblxuICAgIGluc2VydF91bmRlcnNjb3JlcyBzID9kZWxpbWl0ZXIgP3N0cmlwX3plcm9cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGxldCBzZXhwID0gc2V4cF9vZl90IHQgaW5cbiAgbWF0Y2ggIVNleHAub2ZfZmxvYXRfc3R5bGUgd2l0aFxuICB8IGBOb191bmRlcnNjb3JlcyAtPiBzZXhwXG4gIHwgYFVuZGVyc2NvcmVzIC0+XG4gICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICB8IExpc3QgXyAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3NleHBfb2ZfZmxvYXRdIHByb2R1Y2VkIHN0cmFuZ2Ugc2V4cFwiXG4gICAgICAgICAgICBbIFwic2V4cFwiLCBTZXhwLnNleHBfb2ZfdCBzZXhwIF0pXG4gICAgIHwgQXRvbSBzdHJpbmcgLT5cbiAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgc3RyaW5nICdFJyB0aGVuIHNleHAgZWxzZSBBdG9tIChpbnNlcnRfdW5kZXJzY29yZXMgc3RyaW5nKSlcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgPyhwcmVmaXggPSBcIlwiKSB+a2lsbyB+bWVnYSB+Z2lnYSB+dGVyYSA/cGV0YSAoKSA9XG4gICgqIFJvdW5kIGEgcmF0aW8gdG93YXJkIHRoZSBuZWFyZXN0IGludGVnZXIsIHJlc29sdmluZyB0aWVzIHRvd2FyZCB0aGUgbmVhcmVzdCBldmVuXG4gICAgIG51bWJlci4gIEZvciBzYW5lIGlucHV0cyAoaW4gcGFydGljdWxhciwgd2hlbiBbZGVub21pbmF0b3JdIGlzIGFuIGludGVnZXIgYW5kXG4gICAgIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0pIHRoaXMgc2hvdWxkIGJlIGFjY3VyYXRlLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0IG1pZ2h0IGJlIGFcbiAgICAgbGl0dGxlIGJpdCBvZmYsIGJ1dCB3ZSBkb24ndCByZWFsbHkgdXNlIHRoYXQgY2FzZS4gKilcbiAgbGV0IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvciB+ZGVub21pbmF0b3IgPVxuICAgIGxldCBrID0gZmxvb3IgKG51bWVyYXRvciAvLiBkZW5vbWluYXRvcikgaW5cbiAgICAoKiBpZiBbYWJzIGsgPCAyZTUzXSwgdGhlbiBib3RoIFtrXSBhbmQgW2sgKy4gMS5dIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBhbmQgaW5cbiAgICAgICBwYXJ0aWN1bGFyIFtrICsuIDEuID4ga10uICBJZiBbZGVub21pbmF0b3JdIGlzIGFsc28gYW4gaW50ZWdlciwgYW5kXG4gICAgICAgW2FicyAoZGVub21pbmF0b3IgKi4gKGsgKy4gMSkpIDwgMmU1M10gKGFuZCBpbiBzb21lIG90aGVyIGNhc2VzLCB0b28pLCB0aGVuIFtsb3dlcl1cbiAgICAgICBhbmQgW2hpZ2hlcl0gYXJlIGFjdHVhbGx5IGJvdGggYWNjdXJhdGUuICBTaW5jZSAocm91Z2hseSlcbiAgICAgICBbbnVtZXJhdG9yID0gZGVub21pbmF0b3IgKi4ga10gdGhlbiBmb3IgW2FicyBudW1lcmF0b3IgPCAyZTUyXSB3ZSBzaG91bGQgYmVcbiAgICAgICBmaW5lLiAqKVxuICAgIGxldCBsb3dlciA9IGRlbm9taW5hdG9yICouIGsgaW5cbiAgICBsZXQgaGlnaGVyID0gZGVub21pbmF0b3IgKi4gKGsgKy4gMS4pIGluXG4gICAgKCogU3VidHJhY3RpbmcgbnVtYmVycyB3aXRoaW4gYSBmYWN0b3Igb2YgdHdvIGZyb20gZWFjaCBvdGhlciBpcyBhY2N1cmF0ZS5cbiAgICAgICBTbyBlaXRoZXIgdGhlIHR3byBzdWJ0cmFjdGlvbnMgYmVsb3cgYXJlIGFjY3VyYXRlLCBvciBrID0gMCwgb3IgayA9IC0xLlxuICAgICAgIEluIGNhc2Ugb2YgYSB0aWUsIHJvdW5kIHRvIGV2ZW4uICopXG4gICAgbGV0IGRpZmZfcmlnaHQgPSBoaWdoZXIgLS4gbnVtZXJhdG9yIGluXG4gICAgbGV0IGRpZmZfbGVmdCA9IG51bWVyYXRvciAtLiBsb3dlciBpblxuICAgIGxldCBrID0gaXJvdW5kX25lYXJlc3RfZXhuIGsgaW5cbiAgICBpZiBkaWZmX3JpZ2h0IDwgZGlmZl9sZWZ0XG4gICAgdGhlbiBrICsgMVxuICAgIGVsc2UgaWYgZGlmZl9yaWdodCA+IGRpZmZfbGVmdFxuICAgIHRoZW4ga1xuICAgIGVsc2UgaWYgKCogYSB0aWUgKilcbiAgICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGsgbW9kIDIpIDBcbiAgICB0aGVuIGtcbiAgICBlbHNlIGsgKyAxXG4gIGluXG4gIG1hdGNoIGNsYXNzaWZ5IHQgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIHQgPCAwLjAgdGhlbiBcIi1pbmYgIFwiIGVsc2UgXCJpbmYgIFwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuICBcIlxuICB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgZ28gdCA9XG4gICAgICBsZXQgY29udl9vbmUgdCA9XG4gICAgICAgIGFzc2VydCAoMC4gPD0gdCAmJiB0IDwgOTk5Ljk1KTtcbiAgICAgICAgbGV0IHggPSBwcmVmaXggXiBmb3JtYXRfZmxvYXQgXCIlLjFmXCIgdCBpblxuICAgICAgICAoKiBGaXggdGhlIFwiLjBcIiBzdWZmaXggKilcbiAgICAgICAgaWYgU3RyaW5nLmlzX3N1ZmZpeCB4IH5zdWZmaXg6XCIuMFwiXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB4ID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgICAgICAgICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCB4IGluXG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAxKSAnICc7XG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAyKSAnICc7XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp4KVxuICAgICAgICBlbHNlIHhcbiAgICAgIGluXG4gICAgICBsZXQgY29udiBtYWcgdCBkZW5vbWluYXRvciA9XG4gICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgKGRlbm9taW5hdG9yID0gMTAwLiAmJiB0ID49IDk5OS45NSlcbiAgICAgICAgICB8fCAoZGVub21pbmF0b3IgPj0gMTAwXzAwMC4gJiYgdCA+PSByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Ljk5OV81KSkpO1xuICAgICAgICBhc3NlcnQgKHQgPCByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Xzk5OS41KSk7XG4gICAgICAgIGxldCBpLCBkID1cbiAgICAgICAgICBsZXQgayA9IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvcjp0IH5kZW5vbWluYXRvciBpblxuICAgICAgICAgICgqIFttb2RdIGlzIG9rYXkgaGVyZSBiZWNhdXNlIHdlIGtub3cgaSA+PSAwLiAqKVxuICAgICAgICAgIGsgLyAxMCwgayBtb2QgMTBcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgICAgICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgMTAwMCk7XG4gICAgICAgIGFzc2VydCAoMCA8PSBkICYmIGQgPCAxMCk7XG4gICAgICAgIGlmIGQgPSAwXG4gICAgICAgIHRoZW4gc3ByaW50ZiBcIiVzJWQlcyBcIiBwcmVmaXggaSBtYWdcbiAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlZCVzJWRcIiBwcmVmaXggaSBtYWcgZFxuICAgICAgaW5cbiAgICAgICgqIFdoaWxlIHRoZSBzdGFuZGFyZCBtZXRyaWMgcHJlZml4ZXMgKGUuZy4gY2FwaXRhbCBcIk1cIiByYXRoZXIgdGhhbiBcIm1cIiwgWzFdKSBhcmVcbiAgICAgICAgIG5vbWluYWxseSBtb3JlIGNvcnJlY3QsIHRoaXMgaGluZGVycyByZWFkYWJpbGl0eSBpbiBvdXIgY2FzZS4gIEUuZy4sIDEwRzYgYW5kXG4gICAgICAgICAxMDY2IGxvb2sgdG9vIHNpbWlsYXIuICBUaGF0J3MgYW4gZXh0cmVtZSBleGFtcGxlLCBidXQgaW4gZ2VuZXJhbCBrLG0sZyx0LHBcbiAgICAgICAgIHByb2JhYmx5IHN0YW5kIG91dCBiZXR0ZXIgdGhhbiBLLE0sRyxULFAgd2hlbiBpbnRlcnNwZXJzZWQgd2l0aCBkaWdpdHMuXG5cbiAgICAgICAgIFsxXSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldHJpY19wcmVmaXggKilcbiAgICAgICgqIFRoZSB0cmljayBoZXJlIGlzIHRoYXQ6XG4gICAgICAgICAtIHRoZSBmaXJzdCBib3VuZGFyeSAoOTk5Ljk1KSBhcyBhIGZsb2F0IGlzIHNsaWdodGx5IG92ZXItcmVwcmVzZW50ZWQgKHNvIGl0IGlzXG4gICAgICAgICAgIGJldHRlciBhcHByb3hpbWF0ZWQgYXMgXCIxa1wiIHRoYW4gYXMgXCI5OTkuOVwiKSxcbiAgICAgICAgIC0gdGhlIG90aGVyIGJvdW5kYXJpZXMgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGJlY2F1c2UgdGhleSBhcmUgaW50ZWdlcnMuXG4gICAgICAgICAgIFRoYXQncyB3aHkgdGhlIHN0cmljdCBlcXVhbGl0aWVzIGJlbG93IGRvIGV4YWN0bHkgd2hhdCB3ZSB3YW50LiAqKVxuICAgICAgaWYgdCA8IDk5OS45NUUwXG4gICAgICB0aGVuIGNvbnZfb25lIHRcbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUzXG4gICAgICB0aGVuIGNvbnYga2lsbyB0IDEwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU2XG4gICAgICB0aGVuIGNvbnYgbWVnYSB0IDEwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFOVxuICAgICAgdGhlbiBjb252IGdpZ2EgdCAxMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUxMlxuICAgICAgdGhlbiBjb252IHRlcmEgdCAxMDBfMDAwXzAwMF8wMDAuXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcGV0YSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHRcbiAgICAgICAgfCBTb21lIHBldGEgLT5cbiAgICAgICAgICBpZiB0IDwgOTk5Ljk1RTE1XG4gICAgICAgICAgdGhlbiBjb252IHBldGEgdCAxMDBfMDAwXzAwMF8wMDBfMDAwLlxuICAgICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0KVxuICAgIGluXG4gICAgaWYgdCA+PSAwLiB0aGVuIGdvIHQgZWxzZSBcIi1cIiBeIGdvIH4tLnRcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmcgdCA9XG4gIHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCB+a2lsbzpcImtcIiB+bWVnYTpcIm1cIiB+Z2lnYTpcImdcIiB+dGVyYTpcInRcIiB+cGV0YTpcInBcIiAoKVxuOztcblxuKCogUGVyZm9ybWFuY2Ugbm90ZTogSW5pdGlhbGl6aW5nIHRoZSBhY2N1bXVsYXRvciB0byAxIHJlc3VsdHMgaW4gb25lIGV4dHJhXG4gICBtdWx0aXBseTsgZS5nLiwgdG8gY29tcHV0ZSB4ICoqIDQsIHdlIGluIHByaW5jaXBsZSBvbmx5IG5lZWQgMiBtdWx0aXBsaWVzLFxuICAgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIDMgbXVsdGlwbGllcy4gIEhvd2V2ZXIsIGF0dGVtcHRzIHRvIGF2b2lkIHRoaXNcbiAgIChsaWtlIGRlY3JlbWVudGluZyBuIGFuZCBpbml0aWFsaXppbmcgYWNjdW0gdG8gYmUgeCwgb3IgaGFuZGxpbmcgc21hbGxcbiAgIGV4cG9uZW50cyBhcyBhIHNwZWNpYWwgY2FzZSkgaGF2ZSBub3QgeWllbGRlZCBhbnl0aGluZyB0aGF0IGlzIGEgbmV0XG4gICBpbXByb3ZlbWVudC5cbiopXG5sZXQgaW50X3BvdyB4IG4gPVxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gMS5cbiAgZWxzZSAoXG4gICAgKCogVXNpbmcgW3ggKy4gKC0wLildIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBjb252aW5jZXMgdGhlIGNvbXBpbGVyIHRvIGF2b2lkIGEgY2VydGFpblxuICAgICAgIGJveGluZyAodGhhdCB3b3VsZCByZXN1bHQgaW4gYWxsb2NhdGlvbiBpbiBlYWNoIGl0ZXJhdGlvbikuICBTb29uLCB0aGUgY29tcGlsZXJcbiAgICAgICBzaG91bGRuJ3QgbmVlZCB0aGlzIFwiaGludFwiIHRvIGF2b2lkIHRoZSBib3hpbmcuICBUaGUgcmVhc29uIHdlIGFkZCAtMCByYXRoZXIgdGhhbiAwXG4gICAgICAgaXMgdGhhdCBbeCArLiAoLTAuKV0gaXMgYXBwYXJlbnRseSBhbHdheXMgdGhlIHNhbWUgYXMgW3hdLCB3aGVyZWFzIFt4ICsuIDAuXSBpc1xuICAgICAgIG5vdCwgaW4gdGhhdCBpdCBzZW5kcyBbLTAuXSB0byBbMC5dLiAgVGhpcyBtYWtlcyBhIGRpZmZlcmVuY2UgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAgW2ludF9wb3cgKC0wLikgKC0xKV0gdG8gcmV0dXJuIG5lZ19pbmZpbml0eSBqdXN0IGxpa2UgWy0wLiAqKiAtMS5dIHdvdWxkLiAgKilcbiAgICBsZXQgeCA9IHJlZiAoeCArLiAtMC4pIGluXG4gICAgbGV0IG4gPSByZWYgbiBpblxuICAgIGxldCBhY2N1bSA9IHJlZiAxLiBpblxuICAgIGlmICFuIDwgMFxuICAgIHRoZW4gKFxuICAgICAgKCogeCAqKiBuID0gKDEveCkgKiogLW4gKilcbiAgICAgIHggOj0gMS4gLy4gIXg7XG4gICAgICBuIDo9IH4tICghbik7XG4gICAgICBpZiAhbiA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBuIG11c3QgaGF2ZSBiZWVuIG1pbl9pbnQsIHNvIGl0IGlzIG5vdyBzbyBiaWcgdGhhdCBpdCBoYXMgd3JhcHBlZCBhcm91bmQuXG4gICAgICAgICAgIFdlIGRlY3JlbWVudCBpdCBzbyB0aGF0IGl0IGxvb2tzIHBvc2l0aXZlIGFnYWluLCBidXQgYWNjb3JkaW5nbHkgaGF2ZVxuICAgICAgICAgICB0byBwdXQgYW4gZXh0cmEgZmFjdG9yIG9mIHggaW4gdGhlIGFjY3VtdWxhdG9yLlxuICAgICAgICAqKVxuICAgICAgICBhY2N1bSA6PSAheDtcbiAgICAgICAgZGVjciBuKSk7XG4gICAgKCogTGV0dGluZyBbYV0gZGVub3RlICh0aGUgb3JpZ2luYWwgdmFsdWUgb2YpIFt4ICoqIG5dLCB3ZSBtYWludGFpblxuICAgICAgIHRoZSBpbnZhcmlhbnQgdGhhdCBbKHggKiogbikgKi4gYWNjdW0gPSBhXS4gKilcbiAgICB3aGlsZSAhbiA+IDEgZG9cbiAgICAgIGlmICFuIGxhbmQgMSA8PiAwIHRoZW4gYWNjdW0gOj0gIXggKi4gIWFjY3VtO1xuICAgICAgeCA6PSAheCAqLiAheDtcbiAgICAgIG4gOj0gIW4gbHNyIDFcbiAgICBkb25lO1xuICAgICgqIG4gaXMgbmVjZXNzYXJpbHkgMSBhdCB0aGlzIHBvaW50LCBzbyB0aGVyZSBpcyBvbmUgYWRkaXRpb25hbFxuICAgICAgIG11bHRpcGxpY2F0aW9uIGJ5IHguICopXG4gICAgIXggKi4gIWFjY3VtKVxuOztcblxubGV0IHJvdW5kX2dlbiB4IH5ob3cgPVxuICBpZiB4ID0gMC5cbiAgdGhlbiAwLlxuICBlbHNlIGlmIG5vdCAoaXNfZmluaXRlIHgpXG4gIHRoZW4geFxuICBlbHNlIChcbiAgICAoKiBTaWduaWZpY2FudCBkaWdpdHMgYW5kIGRlY2ltYWwgZGlnaXRzLiAqKVxuICAgIGxldCBzZCwgZGQgPVxuICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgIHwgYHNpZ25pZmljYW50X2RpZ2l0cyBzZCAtPlxuICAgICAgICBsZXQgZGQgPSBzZCAtIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICAgIHwgYGRlY2ltYWxfZGlnaXRzIGRkIC0+XG4gICAgICAgIGxldCBzZCA9IGRkICsgdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgIGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIHNkIDwgMFxuICAgIHRoZW4gMC5cbiAgICBlbHNlIGlmIHNkID49IDE3XG4gICAgdGhlbiB4XG4gICAgZWxzZSAoXG4gICAgICAoKiBDaG9vc2UgdGhlIG9yZGVyIHRoYXQgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQuIFNtYWxsIHBvc2l0aXZlXG4gICAgICAgICBpbnRlZ2VycyBhcmUsIGJ1dCB0aGVpciBpbnZlcnNlcyBpbiBtb3N0IGNhc2VzIGFyZSBub3QuICopXG4gICAgICBsZXQgYWJzX2RkID0gSW50LmFicyBkZCBpblxuICAgICAgaWYgYWJzX2RkID4gMjIgfHwgc2QgPj0gMTZcbiAgICAgICgqIDEwKioyMiBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgYnV0IDEwKioyMyBpcyBub3QsIHNvIHVzZSB0aGUgc2xvd1xuICAgICAgICAgcGF0aC4gIFNpbWlsYXJseSwgaWYgd2UgbmVlZCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJlc3VsdCwgdGhlbiB0aGUgaW50ZWdlclxuICAgICAgICAgW3JvdW5kX25lYXJlc3QgKHggPG9wPiBvcmRlcildIG1pZ2h0IG5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgc2luY2VcbiAgICAgICAgIGZvciBzb21lIHJhbmdlcyB3ZSBvbmx5IGhhdmUgMTUgZGlnaXRzIG9mIHByZWNpc2lvbiBndWFyYW50ZWVkLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHdlIGFyZSBzdGlsbCByb3VuZGluZyB0d2ljZSBoZXJlOlxuXG4gICAgICAgICAxKSBmaXJzdCB0aW1lIHdoZW4gcm91bmRpbmcgW3ggKi4gb3JkZXJdIG9yIFt4IC8uIG9yZGVyXSB0byB0aGUgbmVhcmVzdCBmbG9hdFxuICAgICAgICAgKGp1c3QgdGhlIG5vcm1hbCB3YXkgZmxvYXRpbmctcG9pbnQgbXVsdGlwbGljYXRpb24gb3IgZGl2aXNpb24gd29ya3MpLFxuXG4gICAgICAgICAyKSBzZWNvbmQgdGltZSB3aGVuIGFwcGx5aW5nIFtyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbl0gdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIGFib3ZlIG9wZXJhdGlvblxuXG4gICAgICAgICBTbyBmb3IgYXJndW1lbnRzIHdpdGhpbiBhbiB1bHAgZnJvbSBhIHRpZSB3ZSBtaWdodCBzdGlsbCBwcm9kdWNlIGFuIG9mZi1ieS1vbmVcbiAgICAgICAgIHJlc3VsdC4gKilcbiAgICAgIHRoZW4gb2Zfc3RyaW5nIChzcHJpbnRmIFwiJS4qZ1wiIHNkIHgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG9yZGVyID0gaW50X3BvdyAxMC4gYWJzX2RkIGluXG4gICAgICAgIGlmIGRkID49IDBcbiAgICAgICAgdGhlbiByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAqLiBvcmRlcikgLy4gb3JkZXJcbiAgICAgICAgZWxzZSByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAvLiBvcmRlcikgKi4gb3JkZXIpKSlcbjs7XG5cbmxldCByb3VuZF9zaWduaWZpY2FudCB4IH5zaWduaWZpY2FudF9kaWdpdHMgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBzaWduaWZpY2FudF9kaWdpdHMgMFxuICB0aGVuXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LnJvdW5kX3NpZ25pZmljYW50OiBpbnZhbGlkIGFyZ3VtZW50IHNpZ25pZmljYW50X2RpZ2l0czolZFwiXG4gICAgICBzaWduaWZpY2FudF9kaWdpdHNcbiAgICAgICgpXG4gIGVsc2Ugcm91bmRfZ2VuIHggfmhvdzooYHNpZ25pZmljYW50X2RpZ2l0cyBzaWduaWZpY2FudF9kaWdpdHMpXG47O1xuXG5sZXQgcm91bmRfZGVjaW1hbCB4IH5kZWNpbWFsX2RpZ2l0cyA9IHJvdW5kX2dlbiB4IH5ob3c6KGBkZWNpbWFsX2RpZ2l0cyBkZWNpbWFsX2RpZ2l0cylcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgKCogY2xhbXBfdW5jaGVja2VkIGlzIGluIGZsb2F0MC5tbCAqKVxuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGlmIG1pbiA8PSBtYXhcbiAgdGhlbiBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICBlbHNlXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuOztcblxubGV0ICggKyApID0gKCArLiApXG5sZXQgKCAtICkgPSAoIC0uIClcbmxldCAoICogKSA9ICggKi4gKVxubGV0ICggKiogKSA9ICggKiogKVxubGV0ICggLyApID0gKCAvLiApXG5sZXQgKCAlICkgPSAoICUuIClcbmxldCAoIH4tICkgPSAoIH4tLiApXG5cbmxldCBzaWduX2V4biB0IDogU2lnbi50ID1cbiAgaWYgdCA+IDAuXG4gIHRoZW4gUG9zXG4gIGVsc2UgaWYgdCA8IDAuXG4gIHRoZW4gTmVnXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gWmVyb1xuICBlbHNlIEVycm9yLnJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkZsb2F0LnNpZ25fZXhuIG9mIE5BTlwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBzaWduX29yX25hbiB0IDogU2lnbl9vcl9uYW4udCA9XG4gIGlmIHQgPiAwLiB0aGVuIFBvcyBlbHNlIGlmIHQgPCAwLiB0aGVuIE5lZyBlbHNlIGlmIHQgPSAwLiB0aGVuIFplcm8gZWxzZSBOYW5cbjs7XG5cbmxldCBpZWVlX25lZ2F0aXZlIHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIFBvbHkuKGJpdHMgPCBDYW1sLkludDY0Lnplcm8pXG47O1xuXG5sZXQgZXhwb25lbnRfYml0cyA9IDExXG5sZXQgbWFudGlzc2FfYml0cyA9IDUyXG5sZXQgZXhwb25lbnRfbWFzazY0ID0gSW50NjQuKHNoaWZ0X2xlZnQgb25lIGV4cG9uZW50X2JpdHMgLSBvbmUpXG5sZXQgZXhwb25lbnRfbWFzayA9IEludDY0LnRvX2ludF9leG4gZXhwb25lbnRfbWFzazY0XG5sZXQgbWFudGlzc2FfbWFzayA9IEludDYzLihzaGlmdF9sZWZ0IG9uZSBtYW50aXNzYV9iaXRzIC0gb25lKVxubGV0IG1hbnRpc3NhX21hc2s2NCA9IEludDYzLnRvX2ludDY0IG1hbnRpc3NhX21hc2tcblxubGV0IGllZWVfZXhwb25lbnQgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgSW50NjQuKGJpdF9hbmQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYml0cyBtYW50aXNzYV9iaXRzKSBleHBvbmVudF9tYXNrNjQpXG4gIHw+IENhbWwuSW50NjQudG9faW50XG47O1xuXG5sZXQgaWVlZV9tYW50aXNzYSB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBJbnQ2My5vZl9pbnQ2NF9leG4gQ2FtbC5JbnQ2NC4obG9nYW5kIGJpdHMgbWFudGlzc2FfbWFzazY0KVxuOztcblxubGV0IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSA9XG4gIGlmIEludC4oYml0X2FuZCBleHBvbmVudCBleHBvbmVudF9tYXNrIDw+IGV4cG9uZW50KVxuICB0aGVuIGZhaWx3aXRoZiBcImV4cG9uZW50ICVkIG91dCBvZiByYW5nZSBbMCwgJWRdXCIgZXhwb25lbnQgZXhwb25lbnRfbWFzayAoKVxuICBlbHNlIGlmIEludDYzLihiaXRfYW5kIG1hbnRpc3NhIG1hbnRpc3NhX21hc2sgPD4gbWFudGlzc2EpXG4gIHRoZW5cbiAgICBmYWlsd2l0aGZcbiAgICAgIFwibWFudGlzc2EgJXMgb3V0IG9mIHJhbmdlIFswLCAlc11cIlxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYSlcbiAgICAgIChJbnQ2My50b19zdHJpbmcgbWFudGlzc2FfbWFzaylcbiAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCBzaWduX2JpdHMgPSBpZiBuZWdhdGl2ZSB0aGVuIENhbWwuSW50NjQubWluX2ludCBlbHNlIENhbWwuSW50NjQuemVybyBpblxuICAgIGxldCBleHB0X2JpdHMgPSBDYW1sLkludDY0LnNoaWZ0X2xlZnQgKENhbWwuSW50NjQub2ZfaW50IGV4cG9uZW50KSBtYW50aXNzYV9iaXRzIGluXG4gICAgbGV0IG1hbnRfYml0cyA9IEludDYzLnRvX2ludDY0IG1hbnRpc3NhIGluXG4gICAgbGV0IGJpdHMgPSBDYW1sLkludDY0Lihsb2dvciBzaWduX2JpdHMgKGxvZ29yIGV4cHRfYml0cyBtYW50X2JpdHMpKSBpblxuICAgIENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyBiaXRzKVxuOztcblxubGV0IGNyZWF0ZV9pZWVlIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiBjcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EpXG47O1xuXG5tb2R1bGUgVGVyc2UgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdF9vZl9zZXhwID0gdF9vZl9zZXhwXG4gIGxldCB0b19zdHJpbmcgeCA9IFByaW50Zi5zcHJpbnRmIFwiJS44R1wiIHhcbiAgbGV0IHNleHBfb2ZfdCB4ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgeClcbiAgbGV0IG9mX3N0cmluZyB4ID0gb2Zfc3RyaW5nIHhcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gdF9zZXhwX2dyYW1tYXJcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbigqIFRoZXNlIGFyZSBwYXJ0bHkgaGVyZSBhcyBhIHBlcmZvcm1hbmNlIGhhY2sgdG8gYXZvaWQgc29tZSBib3hpbmcgd2UncmUgZ2V0dGluZyB3aXRoXG4gICB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10uICBUaGV5IGFsc28gbWFrZSBbRmxvYXQuaXNfbmVnYXRpdmUgbmFuXSBhbmRcbiAgIFtGbG9hdC5pc19ub25fcG9zaXRpdmUgbmFuXSByZXR1cm4gW2ZhbHNlXTsgdGhlIHZlcnNpb25zIHdlIGdldCBmcm9tIFtXaXRoX3plcm9dIHJldHVyblxuICAgW3RydWVdLiAqKVxubGV0IGlzX3Bvc2l0aXZlIHQgPSB0ID4gMC5cbmxldCBpc19ub25fbmVnYXRpdmUgdCA9IHQgPj0gMC5cbmxldCBpc19uZWdhdGl2ZSB0ID0gdCA8IDAuXG5sZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSB0IDw9IDAuXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkZsb2F0XCJcbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGVuZClcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggJSApID0gKCAlIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnQgPSBvZl9pbnRcbiAgbGV0IG9mX2Zsb2F0IHggPSB4XG5lbmRcblxubW9kdWxlIE9fZG90ID0gc3RydWN0XG4gIGxldCAoICouICkgPSAoICogKVxuICBsZXQgKCArLiApID0gKCArIClcbiAgbGV0ICggLS4gKSA9ICggLSApXG4gIGxldCAoIC8uICkgPSAoIC8gKVxuICBsZXQgKCAlLiApID0gKCAlIClcbiAgbGV0ICggfi0uICkgPSAoIH4tIClcbiAgbGV0ICggKiouICkgPSAoICoqIClcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgYm94ID0gYm94XG4gIGxldCBjbGFtcF91bmNoZWNrZWQgPSBjbGFtcF91bmNoZWNrZWRcbiAgbGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgPSBsb3dlcl9ib3VuZF9mb3JfaW50XG4gIGxldCB1cHBlcl9ib3VuZF9mb3JfaW50ID0gdXBwZXJfYm91bmRfZm9yX2ludFxuICBsZXQgc3BlY2lhbGl6ZWRfaGFzaCA9IGhhc2hfZmxvYXRcbiAgbGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIGxldCBpcm91bmRfbmVhcmVzdF9leG5fNjQgPSBpcm91bmRfbmVhcmVzdF9leG5fNjRcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBzcGVjaWZpY2FsbHkgcmVwbGFjZSBkZWZhdWx0cyBpbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuXG5cbiAgIFRoZSBkZXNpcmVkIGJlaGF2aW9yIGhlcmUgaXMgdG8gcHJvcGFnYXRlIGEgbmFuIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4uIEJlY2F1c2UgdGhlXG4gICBmaXJzdCBjb21wYXJpc29uIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLCBpdCBzdWZmaWNlcyB0b1xuICAgY2hlY2sgaWYgeCBpcyBuYW4uIFRoZW4sIHdoZW4geCBpcyBuYW4gb3IgYm90aCB4IGFuZCB5IGFyZSBuYW4sIHdlIHJldHVybiB4ID0gbmFuOyBhbmRcbiAgIHdoZW4geSBpcyBuYW4gYnV0IG5vdCB4LCB3ZSByZXR1cm4geSA9IG5hbi5cblxuICAgVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyB0byBpbXBsZW1lbnQgdGhlc2UgZnVuY3Rpb25zLiAgVGhlIGJlbmNobWFyayBiZWxvdyBzaG93cyBhIGZld1xuICAgZGlmZmVyZW50IHZlcnNpb25zLiAgVGhpcyBiZW5jaG1hcmsgd2FzIHJ1biBvdmVyIGFuIGFycmF5IG9mIHJhbmRvbSBmbG9hdHMgKG5vbmUgb2ZcbiAgIHdoaWNoIGFyZSBuYW4pLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi40MnVzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMi4wMnVzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS44OHVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgIFRoZSBiZW5jaG1hcmsgYmVsb3cgd2FzIHJ1biB3aGVuIHggPiB5IGlzIGFsd2F5cyB0cnVlIChhZ2Fpbiwgbm8gbmFuIHZhbHVlcykuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjgzdXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjk3dXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjU2dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiopXG5sZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbmxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VcblxubGV0IGVsaWRlID0gcmVmIGZhbHNlXG5sZXQgZWxpZGVkX21lc3NhZ2UgPSBcIjxiYWNrdHJhY2UgZWxpZGVkIGluIHRlc3Q+XCJcblxubGV0IGdldCA/KGF0X21vc3RfbnVtX2ZyYW1lcyA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgQ2FtbC5QcmludGV4Yy5nZXRfY2FsbHN0YWNrIGF0X21vc3RfbnVtX2ZyYW1lc1xuOztcblxubGV0IHRvX3N0cmluZyB0ID1cbiAgaWYgIWVsaWRlIHRoZW4gZWxpZGVkX21lc3NhZ2UgZWxzZSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHRcbjs7XG5cbmxldCB0b19zdHJpbmdfbGlzdCB0ID0gU3RyaW5nLnNwbGl0X2xpbmVzICh0b19zdHJpbmcgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuTGlzdCAoTGlzdC5tYXAgKHRvX3N0cmluZ19saXN0IHQpIH5mOihmdW4geCAtPiBTZXhwLkF0b20geCkpXG5cbm1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgbGV0IHNldF9yZWNvcmRpbmcgPSBDYW1sLlByaW50ZXhjLnJlY29yZF9iYWNrdHJhY2VcbiAgbGV0IGFtX3JlY29yZGluZyA9IENhbWwuUHJpbnRleGMuYmFja3RyYWNlX3N0YXR1c1xuICBsZXQgbW9zdF9yZWNlbnQgKCkgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpXG5cbiAgbGV0IG1vc3RfcmVjZW50X2Zvcl9leG4gZXhuID1cbiAgICBpZiBFeG4uaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCBleG4gdGhlbiBTb21lIChtb3N0X3JlY2VudCAoKSkgZWxzZSBOb25lXG4gIDs7XG5cbiAgKCogV2UgdHVybiBvbiBiYWNrdHJhY2VzIGJ5IGRlZmF1bHQgaWYgT0NBTUxSVU5QQVJBTSBkb2Vzbid0IGV4cGxpY2l0bHkgbWVudGlvbiB0aGVtLiAqKVxuICBsZXQgbWF5YmVfc2V0X3JlY29yZGluZyAoKSA9XG4gICAgbGV0IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyA9XG4gICAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT4gTGlzdC5leGlzdHMgKFN0cmluZy5zcGxpdCB4IH5vbjonLCcpIH5mOihTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCJiXCIpXG4gICAgaW5cbiAgICBpZiBub3Qgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzIHRoZW4gc2V0X3JlY29yZGluZyB0cnVlXG4gIDs7XG5cbiAgKCogdGhlIGNhbGxlciBzZXQgc29tZXRoaW5nLCB0aGV5IGFyZSByZXNwb25zaWJsZSAqKVxuXG4gIGxldCB3aXRoX3JlY29yZGluZyBiIH5mID1cbiAgICBsZXQgc2F2ZWQgPSBhbV9yZWNvcmRpbmcgKCkgaW5cbiAgICBzZXRfcmVjb3JkaW5nIGI7XG4gICAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBzZXRfcmVjb3JkaW5nIHNhdmVkKVxuICA7O1xuZW5kXG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IEV4bi5tYXliZV9zZXRfcmVjb3JkaW5nICgpXG4iLCIoKiogUHJpbWl0aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGVxdWFsIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggPSBDYW1sLm1heFxubGV0IG1pbiA9IENhbWwubWluXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAoKiBUaGVzZSBtb2R1bGVzIGFyZSByZWRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0KSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIENhbWwucmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG4oKiBSZXNodWZmbGUgW0NhbWxdIHNvIHRoYXQgd2UgY2hvb3NlIHRoZSBtb2R1bGVzIHVzaW5nIGxhYmVscyB3aGVuIGF2YWlsYWJsZS4gKilcbm1vZHVsZSBDYW1sID0gc3RydWN0XG5cbiAgaW5jbHVkZSBDYW1sXG5cbiAgbW9kdWxlIEFyZyA9IENhbWwuQXJnICgqKiBAY2Fub25pY2FsIENhbWwuQXJnICopXG5cbiAgbW9kdWxlIEFycmF5ID0gQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKilcblxuICBtb2R1bGUgQm9vbCA9IENhbWwuQm9vbCAoKiogQGNhbm9uaWNhbCBDYW1sLkJvb2wgKilcblxuICBtb2R1bGUgQnVmZmVyID0gQ2FtbC5CdWZmZXIgKCoqIEBjYW5vbmljYWwgQ2FtbC5CdWZmZXIgKilcblxuICBtb2R1bGUgQnl0ZXMgPSBDYW1sLlN0ZExhYmVscy5CeXRlcyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5CeXRlcyAqKVxuXG4gIG1vZHVsZSBDaGFyID0gQ2FtbC5DaGFyICgqKiBAY2Fub25pY2FsIENhbWwuQ2hhciAqKVxuXG4gIG1vZHVsZSBFcGhlbWVyb24gPSBDYW1sLkVwaGVtZXJvbiAoKiogQGNhbm9uaWNhbCBDYW1sLkVwaGVtZXJvbiAqKVxuXG4gIG1vZHVsZSBGbG9hdCA9IENhbWwuRmxvYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5GbG9hdCAqKVxuXG4gIG1vZHVsZSBGb3JtYXQgPSBDYW1sLkZvcm1hdCAoKiogQGNhbm9uaWNhbCBDYW1sLkZvcm1hdCAqKVxuXG4gIG1vZHVsZSBGdW4gPSBDYW1sLkZ1biAoKiogQGNhbm9uaWNhbCBDYW1sLkZ1biAqKVxuXG4gIG1vZHVsZSBHYyA9IENhbWwuR2MgKCoqIEBjYW5vbmljYWwgQ2FtbC5HYyAqKVxuXG4gIG1vZHVsZSBIYXNodGJsID0gQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKilcblxuICBtb2R1bGUgSW50MzIgPSBDYW1sLkludDMyICgqKiBAY2Fub25pY2FsIENhbWwuSW50MzIgKilcblxuICBtb2R1bGUgSW50ID0gQ2FtbC5JbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5JbnQgKilcblxuICBtb2R1bGUgSW50NjQgPSBDYW1sLkludDY0ICgqKiBAY2Fub25pY2FsIENhbWwuSW50NjQgKilcblxuICBtb2R1bGUgTGF6eSA9IENhbWwuTGF6eSAoKiogQGNhbm9uaWNhbCBDYW1sLkxhenkgKilcblxuICBtb2R1bGUgTGV4aW5nID0gQ2FtbC5MZXhpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5MZXhpbmcgKilcblxuICBtb2R1bGUgTGlzdCA9IENhbWwuU3RkTGFiZWxzLkxpc3QgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuTGlzdCAqKVxuXG4gIG1vZHVsZSBNYXAgPSBDYW1sLk1vcmVMYWJlbHMuTWFwICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5NYXAgKilcblxuICBtb2R1bGUgTmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5OYXRpdmVpbnQgKilcblxuICBtb2R1bGUgT2JqID0gQ2FtbC5PYmogKCoqIEBjYW5vbmljYWwgQ2FtbC5PYmogKilcblxuICBtb2R1bGUgT3B0aW9uID0gQ2FtbC5PcHRpb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5PcHRpb24gKilcblxuICBtb2R1bGUgUGFyc2luZyA9IENhbWwuUGFyc2luZyAoKiogQGNhbm9uaWNhbCBDYW1sLlBhcnNpbmcgKilcblxuICBtb2R1bGUgUHJpbnRleGMgPSBDYW1sLlByaW50ZXhjICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRleGMgKilcblxuICBtb2R1bGUgUHJpbnRmID0gQ2FtbC5QcmludGYgKCoqIEBjYW5vbmljYWwgQ2FtbC5QcmludGYgKilcblxuICBtb2R1bGUgUXVldWUgPSBDYW1sLlF1ZXVlICgqKiBAY2Fub25pY2FsIENhbWwuUXVldWUgKilcblxuICBtb2R1bGUgUmFuZG9tID0gQ2FtbC5SYW5kb20gKCoqIEBjYW5vbmljYWwgQ2FtbC5SYW5kb20gKilcblxuICBtb2R1bGUgUmVzdWx0ID0gQ2FtbC5SZXN1bHQgKCoqIEBjYW5vbmljYWwgQ2FtbC5SZXN1bHQgKilcblxuICBtb2R1bGUgU2NhbmYgPSBDYW1sLlNjYW5mICgqKiBAY2Fub25pY2FsIENhbWwuU2NhbmYgKilcblxuICBtb2R1bGUgU2VxID0gQ2FtbC5TZXEgKCoqIEBjYW5vbmljYWwgQ2FtbC5TZXEgKilcblxuICBtb2R1bGUgU2V0ID0gQ2FtbC5Nb3JlTGFiZWxzLlNldCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuU2V0ICopXG5cbiAgbW9kdWxlIFN0YWNrID0gQ2FtbC5TdGFjayAoKiogQGNhbm9uaWNhbCBDYW1sLlN0YWNrICopXG5cbiAgbW9kdWxlIFN0cmluZyA9IENhbWwuU3RkTGFiZWxzLlN0cmluZyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKilcblxuICBtb2R1bGUgU3lzID0gQ2FtbC5TeXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TeXMgKilcblxuICBtb2R1bGUgVWNoYXIgPSBDYW1sLlVjaGFyICgqKiBAY2Fub25pY2FsIENhbWwuVWNoYXIgKilcblxuICBtb2R1bGUgVW5pdCA9IENhbWwuVW5pdCAoKiogQGNhbm9uaWNhbCBDYW1sLlVuaXQgKilcblxuICBleGNlcHRpb24gTm90X2ZvdW5kID0gQ2FtbC5Ob3RfZm91bmRcbmVuZFxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4oKiBXZSB1c2UgW09iai5tYWdpY10gaGVyZSBhcyBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZ2VuZXJhdGUgYSBjb25kaXRpb25hbCBqdW1wIGFuZCB0aGVcbiAgIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2UgaXMgbm90aWNlYWJsZS4gKilcbmxldCBib29sX3RvX2ludCAoeCA6IGJvb2wpIDogaW50ID0gQ2FtbC5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5ICopXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgKCAhPSApID0gQ2FtbC4oICE9IClcbmxldCAoICogKSA9IENhbWwuKCAqIClcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxubGV0ICggKi4gKSA9IENhbWwuKCAqLiApXG5sZXQgKCArICkgPSBDYW1sLiggKyApXG5sZXQgKCArLiApID0gQ2FtbC4oICsuIClcbmxldCAoIC0gKSA9IENhbWwuKCAtIClcbmxldCAoIC0uICkgPSBDYW1sLiggLS4gKVxubGV0ICggLyApID0gQ2FtbC4oIC8gKVxubGV0ICggLy4gKSA9IENhbWwuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWF4ICh4IDogaW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGludCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBDYW1sLkludDMyLnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYm9vbCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBib29sKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogY2hhcikgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBjaGFyKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCBpIHggPSBDYW1sLlVjaGFyLnRvX2ludCB4XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIChpIHgpIChpIHkpXG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5kZXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuICBsZXQgbWF4ICh4IDogQ2FtbC5VY2hhci50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogZmxvYXQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogZmxvYXQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogc3RyaW5nKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogc3RyaW5nKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHN0cmluZykgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIFRoaXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBjYW4gc3BlY2lhbGl6ZSBpdCBhcyBhXG4gICBkaXJlY3Qgc2V0IG9yIGNhbWxfbW9kaWZ5ICopXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBvdGhlcndpc2UgdGhlIGNvbXBpbGVyIHdvbid0IHVuYm94XG4gICByZWZlcmVuY2VzICopXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5cbmxldCAoIEAgKSA9IENhbWwuKCBAIClcbmxldCAoIF4gKSA9IENhbWwuKCBeIClcbmxldCAoIH4tICkgPSBDYW1sLiggfi0gKVxubGV0ICggfi0uICkgPSBDYW1sLiggfi0uIClcbmxldCAoIGFzciApID0gQ2FtbC4oIGFzciApXG5sZXQgKCBsYW5kICkgPSBDYW1sLiggbGFuZCApXG5sZXQgbG5vdCA9IENhbWwubG5vdFxubGV0ICggbG9yICkgPSBDYW1sLiggbG9yIClcbmxldCAoIGxzbCApID0gQ2FtbC4oIGxzbCApXG5sZXQgKCBsc3IgKSA9IENhbWwuKCBsc3IgKVxubGV0ICggbHhvciApID0gQ2FtbC4oIGx4b3IgKVxubGV0ICggbW9kICkgPSBDYW1sLiggbW9kIClcbmxldCBhYnMgPSBDYW1sLmFic1xubGV0IGZhaWx3aXRoID0gQ2FtbC5mYWlsd2l0aFxubGV0IGZzdCA9IENhbWwuZnN0XG5sZXQgaW52YWxpZF9hcmcgPSBDYW1sLmludmFsaWRfYXJnXG5sZXQgc25kID0gQ2FtbC5zbmRcblxuKCogW3JhaXNlXSBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIGFzIHRoZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHJlcGxhY2VzXG4gICAnJXJhaXNlJyBieSAnJXJlcmFpc2UnIHdoZW4gYXBwcm9wcmlhdGUuICopXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG5sZXQgcGh5c19lcXVhbCA9IENhbWwuKCA9PSApXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IGluY3IgPSBDYW1sLmluY3JcblxuKCogdXNlZCBieSBzZXhwX2NvbnYsIHdoaWNoIGZsb2F0MCBkZXBlbmRzIG9uIHRocm91Z2ggb3B0aW9uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gQ2FtbC5mbG9hdF9vZl9zdHJpbmdcblxuKCogW2FtX3Rlc3RpbmddIGlzIHVzZWQgaW4gYSBmZXcgcGxhY2VzIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSB3aGVuIGluIHRlc3RpbmcgbW9kZSwgc3VjaFxuICAgYXMgaW4gW3JhbmRvbS5tbF0uICBbYW1fdGVzdGluZ10gaXMgaW1wbGVtZW50ZWQgdXNpbmcgW0Jhc2VfYW1fdGVzdGluZ10sIGEgd2VhayBDL2pzXG4gICBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFtmYWxzZV0sIGJ1dCB3aGVuIGxpbmtpbmcgYW4gaW5saW5lLXRlc3QtcnVubmVyIGV4ZWN1dGFibGUsIGlzXG4gICBvdmVycmlkZGVuIGJ5IGFub3RoZXIgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbdHJ1ZV0uICopXG5leHRlcm5hbCBhbV90ZXN0aW5nIDogdW5pdCAtPiBib29sID0gXCJCYXNlX2FtX3Rlc3RpbmdcIlxuXG5sZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmcgKClcbiIsIigqIFtTdHJpbmcwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN0cmluZ10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzdHJpbmcwLm1sIHNob3VsZFxuICAgdXNlIFtDYW1sLlN0cmluZ10uICBbU3RyaW5nMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzXG4gICBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzLCBpbmNsdWRpbmcgdGhlIHN1YnNjcmlwdCBzeW50YXhcbiAgIFt4LihpKV0gb3IgW3guKGkpIDwtIGVdIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0b1xuICAgW1N0cmluZ10sIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TdHJpbmddIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBDYW1sLlN0cmluZy5jYXBpdGFsaXplX2FzY2lpXG5sZXQgY29tcGFyZSA9IENhbWwuU3RyaW5nLmNvbXBhcmVcblxubGV0IGNvcHkgeCA9XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmdcbiAgICB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpcbiAgICAgIChCeXRlcy5vZl9zdHJpbmcgeClcbjs7XG5cbmxldCBlc2NhcGVkID0gQ2FtbC5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxubGV0IG1ha2UgPSBDYW1sLlN0cmluZy5tYWtlXG5sZXQgc3ViID0gQ2FtbC5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLlN0cmluZy51bnNhZmVfYmxpdFxubGV0IHVwcGVyY2FzZSA9IENhbWwuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxuXG5sZXQgY29uY2F0ID8oc2VwID0gXCJcIikgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiXCJcbiAgKCogVGhlIHN0ZGxpYiBkb2VzIG5vdCBzcGVjaWFsaXplIHRoaXMgY2FzZSBiZWNhdXNlIGl0IGNvdWxkIGJyZWFrIGV4aXN0aW5nIHByb2plY3RzLiAqKVxuICB8IFsgeCBdIC0+IHhcbiAgfCBsIC0+IENhbWwuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbigqIFRoZXNlIGFyZSBldGEgZXhwYW5kZWQgaW4gb3JkZXIgdG8gcGVybXV0ZSBwYXJhbWV0ZXIgb3JkZXIgdG8gZm9sbG93IEJhc2VcbiAgIGNvbnZlbnRpb25zLiAqKVxubGV0IGl0ZXIgdCB+ZiA9IENhbWwuU3RyaW5nLml0ZXIgdCB+ZlxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIHRoZSB0b3BsZXZlbCBvZiB0aGUgQmFzZSBsaWJyYXJ5OyBpdCdzIHdoYXQgeW91IGdldCB3aGVuIHlvdSB3cml0ZVxuICAgIFtvcGVuIEJhc2VdLlxuXG4gICAgVGhlIGdvYWwgb2YgQmFzZSBpcyBib3RoIHRvIGJlIGEgbW9yZSBjb21wbGV0ZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIHJpY2hlciBBUElzLFxuICAgIGFuZCB0byBiZSBtb3JlIGNvbnNpc3RlbnQgaW4gaXRzIGRlc2lnbi4gRm9yIGluc3RhbmNlLCBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeVxuICAgIHNvbWUgdGhpbmdzIGhhdmUgbW9kdWxlcyBhbmQgb3RoZXJzIGRvbid0OyBpbiBCYXNlLCBldmVyeXRoaW5nIGlzIGEgbW9kdWxlLlxuXG4gICAgQmFzZSBleHRlbmRzIHNvbWUgbW9kdWxlcyBhbmQgZGF0YSBzdHJ1Y3R1cmVzIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIGxpa2UgW0FycmF5XSxcbiAgICBbQnVmZmVyXSwgW0J5dGVzXSwgW0NoYXJdLCBbSGFzaHRibF0sIFtJbnQzMl0sIFtJbnQ2NF0sIFtMYXp5XSwgW0xpc3RdLCBbTWFwXSxcbiAgICBbTmF0aXZlaW50XSwgW1ByaW50Zl0sIFtSYW5kb21dLCBbU2V0XSwgW1N0cmluZ10sIFtTeXNdLCBhbmQgW1VjaGFyXS4gT25lIGtleVxuICAgIGRpZmZlcmVuY2UgaXMgdGhhdCBCYXNlIGRvZXNuJ3QgdXNlIGV4Y2VwdGlvbnMgYXMgbXVjaCBhcyB0aGUgc3RhbmRhcmQgbGlicmFyeSBhbmRcbiAgICBpbnN0ZWFkIG1ha2VzIGhlYXZ5IHVzZSBvZiB0aGUgW1Jlc3VsdF0gdHlwZSwgYXMgaW46XG5cbiAgICB7WyB0eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYiBdfVxuXG4gICAgQmFzZSBhbHNvIGFkZHMgZW50aXJlbHkgbmV3IG1vZHVsZXMsIG1vc3Qgbm90YWJseTpcblxuICAgIC0gW0NvbXBhcmFibGVdLCBbQ29tcGFyYXRvcl0sIGFuZCBbQ29tcGFyaXNvbnNdIGluIGxpZXUgb2YgcG9seW1vcnBoaWMgY29tcGFyZS5cbiAgICAtIFtDb250YWluZXJdLCB3aGljaCBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGFjcm9zcyBjb250YWluZXItbGlrZSBkYXRhXG4gICAgICBzdHJ1Y3R1cmVzIChhcnJheXMsIGxpc3RzLCBzdHJpbmdzKS5cbiAgICAtIFtSZXN1bHRdLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSwgc3VwcG9ydGluZyB0aGUgb3ItZXJyb3IgcGF0dGVybi5cbiopXG5cbigqXyBXZSBoaWRlIHRoaXMgZnJvbSB0aGUgd2ViIGRvY3MgYmVjYXVzZSB0aGUgbGluZSB3cmFwcGluZyBpcyBiYWQsIG1ha2luZyBpdFxuICBwcmV0dHkgbXVjaCBpbnNjcnV0YWJsZS4gKilcbigqKi8qKilcblxuKCogVGhlIGludGVudCBpcyB0byBzaGFkb3cgYWxsIG9mIElOUklBJ3Mgc3RhbmRhcmQgbGlicmFyeS4gIE1vZHVsZXMgYmVsb3cgd291bGQgY2F1c2VcbiAgIGNvbXBpbGF0aW9uIGVycm9ycyB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbSBbU2hhZG93X3N0ZGxpYl0gYmVmb3JlIGluY2x1c2lvbi4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgKCogTW9kdWxlcyBkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW5fY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLkluX2NoYW5uZWxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBPdXRfY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLk91dF9jaGFubmVsXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0XG4gICgqIFN1cHBvcnQgZm9yIGdlbmVyYXRlZCBsZXhlcnMgKilcbiAgd2l0aCBtb2R1bGUgTGV4aW5nIDo9IFNoYWRvd19zdGRsaWIuTGV4aW5nXG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0IDo9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA6PSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gIHdpdGggdHlwZSAnYSByZWYgOj0gJ2EgcmVmKSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiovKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmVcbm1vZHVsZSBBcnJheSA9IEFycmF5XG5tb2R1bGUgQXZsdHJlZSA9IEF2bHRyZWVcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYWNrdHJhY2Vcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmluYXJ5X3NlYXJjaFxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmluYXJ5X3NlYXJjaGFibGVcbm1vZHVsZSBCbGl0ID0gQmxpdFxubW9kdWxlIEJvb2wgPSBCb29sXG5tb2R1bGUgQnVmZmVyID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgPSBCeXRlc1xubW9kdWxlIENoYXIgPSBDaGFyXG5tb2R1bGUgQ29tcGFyYWJsZSA9IENvbXBhcmFibGVcbm1vZHVsZSBDb21wYXJhdG9yID0gQ29tcGFyYXRvclxubW9kdWxlIENvbXBhcmlzb25zID0gQ29tcGFyaXNvbnNcbm1vZHVsZSBDb250YWluZXIgPSBDb250YWluZXJcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXJcbm1vZHVsZSBFcXVhbCA9IEVxdWFsXG5tb2R1bGUgRXJyb3IgPSBFcnJvclxubW9kdWxlIEV4biA9IEV4blxubW9kdWxlIEZpZWxkID0gRmllbGRcbm1vZHVsZSBGbG9hdCA9IEZsb2F0XG5tb2R1bGUgRmxvYXRhYmxlID0gRmxvYXRhYmxlXG5tb2R1bGUgRm4gPSBGblxubW9kdWxlIEZvcm1hdHRlciA9IEZvcm1hdHRlclxubW9kdWxlIEhhc2ggPSBIYXNoXG5tb2R1bGUgSGFzaF9zZXQgPSBIYXNoX3NldFxubW9kdWxlIEhhc2hhYmxlID0gSGFzaGFibGVcbm1vZHVsZSBIYXNoZXIgPSBIYXNoZXJcbm1vZHVsZSBIYXNodGJsID0gSGFzaHRibFxubW9kdWxlIElkZW50aWZpYWJsZSA9IElkZW50aWZpYWJsZVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gSW5kZXhlZF9jb250YWluZXJcbm1vZHVsZSBJbmZvID0gSW5mb1xubW9kdWxlIEludCA9IEludFxubW9kdWxlIEludF9jb252ZXJzaW9ucyA9IEludF9jb252ZXJzaW9uc1xubW9kdWxlIEludDMyID0gSW50MzJcbm1vZHVsZSBJbnQ2MyA9IEludDYzXG5tb2R1bGUgSW50NjQgPSBJbnQ2NFxubW9kdWxlIEludGFibGUgPSBJbnRhYmxlXG5tb2R1bGUgSW50X21hdGggPSBJbnRfbWF0aFxubW9kdWxlIEludmFyaWFudCA9IEludmFyaWFudFxubW9kdWxlIExhenkgPSBMYXp5XG5tb2R1bGUgTGlzdCA9IExpc3Rcbm1vZHVsZSBNYXAgPSBNYXBcbm1vZHVsZSBNYXliZV9ib3VuZCA9IE1heWJlX2JvdW5kXG5tb2R1bGUgTW9uYWQgPSBNb25hZFxubW9kdWxlIE5hdGl2ZWludCA9IE5hdGl2ZWludFxubW9kdWxlIE5vdGhpbmcgPSBOb3RoaW5nXG5tb2R1bGUgT3B0aW9uID0gT3B0aW9uXG5tb2R1bGUgT3B0aW9uX2FycmF5ID0gT3B0aW9uX2FycmF5XG5tb2R1bGUgT3JfZXJyb3IgPSBPcl9lcnJvclxubW9kdWxlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24gPSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uXG5tb2R1bGUgT3JkZXJpbmcgPSBPcmRlcmluZ1xubW9kdWxlIFBvbHkgPSBQb2x5XG5tb2R1bGUgUG9seW1vcnBoaWNfY29tcGFyZSA9IFBvbHkgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE4LTExXSB1c2UgW1BvbHldIGluc3RlYWRcIl1cblxubW9kdWxlIFBvcGNvdW50ID0gUG9wY291bnRcbltAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxOC0xMF0gdXNlIFtwb3Bjb3VudF0gZnVuY3Rpb25zIGluIHRoZSBpbmRpdmlkdWFsIGludCBtb2R1bGVzXCJdXG5cbm1vZHVsZSBQcmV0dHlfcHJpbnRlciA9IFByZXR0eV9wcmludGVyXG5tb2R1bGUgUHJpbnRmID0gUHJpbnRmXG5tb2R1bGUgTGlua2VkX3F1ZXVlID0gTGlua2VkX3F1ZXVlXG5tb2R1bGUgUXVldWUgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSA9IFJhbmRvbVxubW9kdWxlIFJlZiA9IFJlZlxubW9kdWxlIFJlc3VsdCA9IFJlc3VsdFxubW9kdWxlIFNlcXVlbmNlID0gU2VxdWVuY2Vcbm1vZHVsZSBTZXQgPSBTZXRcbm1vZHVsZSBTZXhwYWJsZSA9IFNleHBhYmxlXG5tb2R1bGUgU2lnbiA9IFNpZ25cbm1vZHVsZSBTaWduX29yX25hbiA9IFNpZ25fb3JfbmFuXG5tb2R1bGUgU291cmNlX2NvZGVfcG9zaXRpb24gPSBTb3VyY2VfY29kZV9wb3NpdGlvblxubW9kdWxlIFN0YWNrID0gU3RhY2tcbm1vZHVsZSBTdGFnZWQgPSBTdGFnZWRcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdhYmxlID0gU3RyaW5nYWJsZVxubW9kdWxlIFN5cyA9IFN5c1xubW9kdWxlIFQgPSBUXG5tb2R1bGUgVHlwZV9lcXVhbCA9IFR5cGVfZXF1YWxcbm1vZHVsZSBVbmlmb3JtX2FycmF5ID0gVW5pZm9ybV9hcnJheVxubW9kdWxlIFVuaXQgPSBVbml0XG5tb2R1bGUgVWNoYXIgPSBVY2hhclxubW9kdWxlIFZhcmlhbnQgPSBWYXJpYW50XG5tb2R1bGUgV2l0aF9yZXR1cm4gPSBXaXRoX3JldHVyblxubW9kdWxlIFdvcmRfc2l6ZSA9IFdvcmRfc2l6ZVxuXG4oKiBBdm9pZCBhIGxldmVsIG9mIGluZGlyZWN0aW9uIGZvciB1c2VzIG9mIHRoZSBzaWduYXR1cmVzIGRlZmluZWQgaW4gW1RdLiAqKVxuaW5jbHVkZSBUXG5cbigqIFRoaXMgaXMgYSBoYWNrIHNvIHRoYXQgb2RvYyBjcmVhdGVzIGJldHRlciBkb2N1bWVudGF0aW9uLiAqKVxubW9kdWxlIFNleHAgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTZXhwX3dpdGhfY29tcGFyYWJsZSAoKiogQGlubGluZSAqKVxuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzID0gc3RydWN0XG4gIG1vZHVsZSBGaWVsZHNsaWIgPSBGaWVsZHNsaWJcbiAgbW9kdWxlIFBweF9oYXNoX2xpYiA9IFBweF9oYXNoX2xpYlxuICBtb2R1bGUgVmFyaWFudHNsaWIgPSBWYXJpYW50c2xpYlxuICBtb2R1bGUgUHB4X2NvbXBhcmVfbGliID0gUHB4X2NvbXBhcmVfbGliXG4gIG1vZHVsZSBQcHhfZW51bWVyYXRlX2xpYiA9IFBweF9lbnVtZXJhdGVfbGliXG5cbiAgbGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gICgqIFtkZXJpdmluZyBoYXNoXSBpcyBtaXNzaW5nIGZvciBbYXJyYXldIGFuZCBbcmVmXSBzaW5jZSB0aGVzZSB0eXBlcyBhcmUgbXV0YWJsZS4gKilcbiAgdHlwZSAnYSBhcnJheSA9ICdhIEFycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gaW50ID0gQXJyYXkuY29tcGFyZVxuICBsZXQgZXF1YWxfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGJvb2wgPSBBcnJheS5lcXVhbFxuXG4gIGxldCBhcnJheV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBhcnJheSA9XG4gICAgQXJyYXkudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfYXJyYXkgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgYXJyYXkgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBBcnJheS5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKGFycmF5X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBhcnJheSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gQXJyYXkudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBib29sID0gQm9vbC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2Jvb2wgPSAoQm9vbC5jb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludClcbiAgbGV0IGVxdWFsX2Jvb2wgPSAoQm9vbC5lcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2Jvb2wgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBCb29sLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Jvb2wgOiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBCb29sLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYm9vbF9vZl9zZXhwID0gKEJvb2wudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJvb2wpXG4gIGxldCBzZXhwX29mX2Jvb2wgPSAoQm9vbC5zZXhwX29mX3QgOiBib29sIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQm9vbC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjaGFyID0gQ2hhci50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2NoYXIgPSAoQ2hhci5jb21wYXJlIDogY2hhciAtPiBjaGFyIC0+IGludClcbiAgbGV0IGVxdWFsX2NoYXIgPSAoQ2hhci5lcXVhbCA6IGNoYXIgLT4gY2hhciAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2NoYXIgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBDaGFyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2NoYXIgOiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBDaGFyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgY2hhcl9vZl9zZXhwID0gKENoYXIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGNoYXIpXG4gIGxldCBzZXhwX29mX2NoYXIgPSAoQ2hhci5zZXhwX29mX3QgOiBjaGFyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChjaGFyX3NleHBfZ3JhbW1hciA6IGNoYXIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQ2hhci50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBleG4gPSBFeG4udCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl9leG4gPSAoRXhuLnNleHBfb2ZfdCA6IGV4biAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGZsb2F0ID0gRmxvYXQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9mbG9hdCA9IChGbG9hdC5jb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50KVxuICBsZXQgZXF1YWxfZmxvYXQgPSAoRmxvYXQuZXF1YWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2Zsb2F0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEZsb2F0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Zsb2F0IDogZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEZsb2F0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgZmxvYXRfb2Zfc2V4cCA9IChGbG9hdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gZmxvYXQpXG4gIGxldCBzZXhwX29mX2Zsb2F0ID0gKEZsb2F0LnNleHBfb2ZfdCA6IGZsb2F0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBGbG9hdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQgPSBJbnQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQgPSAoSW50LmNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludClcbiAgbGV0IGVxdWFsX2ludCA9IChJbnQuZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBJbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50IDogaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnRfb2Zfc2V4cCA9IChJbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludClcbiAgbGV0IHNleHBfb2ZfaW50ID0gKEludC5zZXhwX29mX3QgOiBpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDMyID0gSW50MzIudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQzMiA9IChJbnQzMi5jb21wYXJlIDogaW50MzIgLT4gaW50MzIgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50MzIgPSAoSW50MzIuZXF1YWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDMyIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDMyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDMyIDogaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDMyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50MzJfb2Zfc2V4cCA9IChJbnQzMi50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50MzIpXG4gIGxldCBzZXhwX29mX2ludDMyID0gKEludDMyLnNleHBfb2ZfdCA6IGludDMyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQzMi50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQ2NCA9IEludDY0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50NjQgPSAoSW50NjQuY29tcGFyZSA6IGludDY0IC0+IGludDY0IC0+IGludClcbiAgbGV0IGVxdWFsX2ludDY0ID0gKEludDY0LmVxdWFsIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQ2NCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQ2NC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQ2NCA6IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQ2NC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDY0X29mX3NleHAgPSAoSW50NjQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDY0KVxuICBsZXQgc2V4cF9vZl9pbnQ2NCA9IChJbnQ2NC5zZXhwX29mX3QgOiBpbnQ2NCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50NjQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgbGlzdCA9ICdhIExpc3QudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9saXN0IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBpbnQgPSBMaXN0LmNvbXBhcmVcbiAgbGV0IGVxdWFsX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBib29sID0gTGlzdC5lcXVhbFxuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2EgbGlzdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBMaXN0Lmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgbGlzdCA9XG4gICAgTGlzdC50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9saXN0IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGxpc3QgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBMaXN0LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAobGlzdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBsaXN0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gTGlzdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIG5hdGl2ZWludCA9IE5hdGl2ZWludC50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX25hdGl2ZWludCA9IChOYXRpdmVpbnQuY29tcGFyZSA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5lcXVhbCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9uYXRpdmVpbnQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIE5hdGl2ZWludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IE5hdGl2ZWludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IG5hdGl2ZWludF9vZl9zZXhwID0gKE5hdGl2ZWludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gbmF0aXZlaW50KVxuICBsZXQgc2V4cF9vZl9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LnNleHBfb2ZfdCA6IG5hdGl2ZWludCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgbGV0IChuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgTmF0aXZlaW50LnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIG9wdGlvbiA9ICdhIE9wdGlvbi50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uIC0+IGludCA9XG4gICAgT3B0aW9uLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uIC0+IGJvb2wgPVxuICAgIE9wdGlvbi5lcXVhbFxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSBvcHRpb25cbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgT3B0aW9uLmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IG9wdGlvbl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBvcHRpb24gPVxuICAgIE9wdGlvbi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9vcHRpb24gOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2Egb3B0aW9uIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgT3B0aW9uLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAob3B0aW9uX3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBvcHRpb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IE9wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHJlZiA9ICdhIFJlZi50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3JlZiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGludCA9IFJlZi5jb21wYXJlXG4gIGxldCBlcXVhbF9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gYm9vbCA9IFJlZi5lcXVhbFxuXG4gIGxldCByZWZfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgcmVmID1cbiAgICBSZWYudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfcmVmIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHJlZiAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIFJlZi5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKHJlZl9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSByZWYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZWYudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBzdHJpbmcgPSBTdHJpbmcudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9zdHJpbmcgPSAoU3RyaW5nLmNvbXBhcmUgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGludClcbiAgbGV0IGVxdWFsX3N0cmluZyA9IChTdHJpbmcuZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfc3RyaW5nIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBTdHJpbmcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfc3RyaW5nIDogc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBTdHJpbmcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzdHJpbmdfb2Zfc2V4cCA9IChTdHJpbmcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0cmluZylcbiAgbGV0IHNleHBfb2Zfc3RyaW5nID0gKFN0cmluZy5zZXhwX29mX3QgOiBzdHJpbmcgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJ5dGVzID0gQnl0ZXMudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ieXRlcyA9IChCeXRlcy5jb21wYXJlIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50KVxuICBsZXQgZXF1YWxfYnl0ZXMgPSAoQnl0ZXMuZXF1YWwgOiBieXRlcyAtPiBieXRlcyAtPiBib29sKVxuICBsZXQgYnl0ZXNfb2Zfc2V4cCA9IChCeXRlcy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYnl0ZXMpXG4gIGxldCBzZXhwX29mX2J5dGVzID0gKEJ5dGVzLnNleHBfb2ZfdCA6IGJ5dGVzIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCeXRlcy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSB1bml0ID0gVW5pdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3VuaXQgPSAoVW5pdC5jb21wYXJlIDogdW5pdCAtPiB1bml0IC0+IGludClcbiAgbGV0IGVxdWFsX3VuaXQgPSAoVW5pdC5lcXVhbCA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3VuaXQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBVbml0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3VuaXQgOiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBVbml0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdW5pdF9vZl9zZXhwID0gKFVuaXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHVuaXQpXG4gIGxldCBzZXhwX29mX3VuaXQgPSAoVW5pdC5zZXhwX29mX3QgOiB1bml0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVW5pdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIEZvcm1hdCBzdHVmZiAqKVxuXG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG5cbiAgKCoqIExpc3Qgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBMaXN0LkluZml4XG5cbiAgKCoqIEludCBvcGVyYXRvcnMgYW5kIGNvbXBhcmlzb25zICopXG5cbiAgaW5jbHVkZSBJbnQuT1xuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAoKiogRmxvYXQgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBGbG9hdC5PX2RvdFxuXG4gICgqIFRoaXMgaXMgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gYmUgb3B0aW1pemVkIGF3YXkgaW4gbW9yZSBjb250ZXh0cy4gKilcblxuICAoKiogUmV2ZXJzZSBhcHBsaWNhdGlvbiBvcGVyYXRvci4gW3ggfD4gZyB8PiBmXSBpcyBlcXVpdmFsZW50IHRvIFtmIChnICh4KSldLiAqKVxuICBleHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4gICgqKiBBcHBsaWNhdGlvbiBvcGVyYXRvci4gW2cgQEAgZiBAQCB4XSBpcyBlcXVpdmFsZW50IHRvIFtnIChmICh4KSldLiAqKVxuICBleHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4gICgqKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuICAoKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuICBleHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuICBleHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIGV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4gICgqIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBmb3IgdGhlIHdhcm5pbmdzIHRvIHdvcmsgcHJvcGVybHkuICopXG4gIGV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbiAgKCoqIENvbW1vbiBzdHJpbmcgb3BlcmF0aW9ucyAqKVxuICBsZXQgKCBeICkgPSBTdHJpbmcuKCBeIClcblxuICAoKiogUmVmZXJlbmNlIG9wZXJhdGlvbnMgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUgYW5kXG4gICAgIHRvIGtlZXAgcmVmZXJlbmNlIHVuYm94aW5nIHdvcmtpbmcgKilcbiAgZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuICBleHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG4gIGV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuICAoKiogUGFpciBvcGVyYXRpb25zICopXG5cbiAgbGV0IGZzdCA9IGZzdFxuICBsZXQgc25kID0gc25kXG5cbiAgKCoqIEV4Y2VwdGlvbnMgc3R1ZmYgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBtYXkgcmV3cml0ZSAnJXJhaXNlJyBhcyAnJXJlcmFpc2UnLiAqKVxuICBleHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG4gIGxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG4gIGxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gICgqKiBNaXNjICopXG5cbiAgbGV0IHBoeXNfZXF1YWwgPSBwaHlzX2VxdWFsXG5cbiAgZXh0ZXJuYWwgZm9yY2UgOiAnYSBMYXp5LnQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcbmVuZFxuXG5pbmNsdWRlIEV4cG9ydFxuXG5pbmNsdWRlIENvbnRhaW5lcl9pbnRmLkV4cG9ydCAoKiogQGlubGluZSAqKVxuXG5leGNlcHRpb24gTm90X2ZvdW5kX3MgPSBOb3RfZm91bmRfc1xuXG4oKiBXZSBwZXJmb3JtIHRoZXNlIHNpZGUgZWZmZWN0cyBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0aGVtIHRvIHJ1biBmb3IgYW55IGNvZGUgdGhhdCB1c2VzXG4gICBbQmFzZV0uICBJZiB0aGlzIHdlcmUgaW4gYW5vdGhlciBtb2R1bGUgaW4gW0Jhc2VdIHRoYXQgd2FzIG5vdCB1c2VkIGluIHNvbWUgcHJvZ3JhbSxcbiAgIHRoZW4gdGhlIHNpZGUgZWZmZWN0cyBtaWdodCBub3QgYmUgcnVuIGluIHRoYXQgcHJvZ3JhbS4gIFRoaXMgd2lsbCBydW4gYXMgbG9uZyBhcyB0aGVcbiAgIHByb2dyYW0gcmVmZXJzIHRvIGF0IGxlYXN0IG9uZSB2YWx1ZSBkaXJlY3RseSBpbiBbQmFzZV07IHJlZmVycmluZyB0byB2YWx1ZXMgaW5cbiAgIFtCYXNlLkJvb2xdLCBmb3IgZXhhbXBsZSwgaXMgbm90IHN1ZmZpY2llbnQuICopXG5sZXQgKCkgPSBCYWNrdHJhY2UuaW5pdGlhbGl6ZV9tb2R1bGUgKClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBIYXNodGJsX2ludGZcblxubW9kdWxlIHR5cGUgS2V5ID0gS2V5LlNcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cbmxldCBoYXNoX3BhcmFtID0gSGFzaGFibGUuaGFzaF9wYXJhbVxubGV0IGhhc2ggPSBIYXNoYWJsZS5oYXNoXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxudHlwZSAoJ2ssICd2KSB0ID1cbiAgeyBtdXRhYmxlIHRhYmxlIDogKCdrLCAndikgQXZsdHJlZS50IGFycmF5XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgKCogW3JlY2VudGx5X2FkZGVkXSBpcyB0aGUgcmVmZXJlbmNlIHBhc3NlZCB0byBbQXZsdHJlZS5hZGRdLiBXZSBwdXQgaXQgaW4gdGhlIGhhc2hcbiAgICAgdGFibGUgdG8gYXZvaWQgYWxsb2NhdGluZyBpdCBhdCBldmVyeSBbc2V0XS4gKilcbiAgOyByZWNlbnRseV9hZGRlZCA6IGJvb2wgcmVmXG4gIDsgZ3Jvd3RoX2FsbG93ZWQgOiBib29sXG4gIDsgaGFzaGFibGUgOiAnayBIYXNoYWJsZS50XG4gIDsgbXV0YWJsZSBtdXRhdGlvbl9hbGxvd2VkIDogYm9vbCAoKiBTZXQgZHVyaW5nIGFsbCBpdGVyYXRpb24gb3BlcmF0aW9ucyAqKVxuICB9XG5cbnR5cGUgJ2Ega2V5ID0gJ2FcblxubGV0IHNleHBfb2Zfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdFxubGV0IGNvbXBhcmVfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmVcblxubGV0IGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQgPVxuICBpZiBub3QgdC5tdXRhdGlvbl9hbGxvd2VkIHRoZW4gZmFpbHdpdGggXCJIYXNodGJsOiBtdXRhdGlvbiBub3QgYWxsb3dlZCBkdXJpbmcgaXRlcmF0aW9uXCJcbjs7XG5cbmxldCB3aXRob3V0X211dGF0aW5nIHQgZiA9XG4gIGlmIHQubXV0YXRpb25fYWxsb3dlZFxuICB0aGVuIChcbiAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgfCB4IC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgcmFpc2UgZXhuKVxuICBlbHNlIGYgKClcbjs7XG5cbigqKiBJbnRlcm5hbGx5IHVzZSBhIG1heGltdW0gc2l6ZSB0aGF0IGlzIGEgcG93ZXIgb2YgMi4gUmV2ZXJzZXMgdGhlIGFib3ZlIHRvIGZpbmQgdGhlXG4gICAgZmxvb3IgcG93ZXIgb2YgMiBiZWxvdyB0aGUgc3lzdGVtIG1heCBhcnJheSBsZW5ndGggKilcbmxldCBtYXhfdGFibGVfbGVuZ3RoID0gSW50LmZsb29yX3BvdzIgQXJyYXkubWF4X2xlbmd0aFxuXG4oKiBUaGUgZGVmYXVsdCBzaXplIGlzIGNob3NlbiB0byBiZSAwIChhcyBvcHBvc2VkIHRvIDEyOCBhcyBpdCB3YXMgYmVmb3JlKSBiZWNhdXNlOlxuICAgLSAxMjggY2FuIGNyZWF0ZSBzdWJzdGFudGlhbCBtZW1vcnkgb3ZlcmhlYWQgKHgxMCkgd2hlbiBjcmVhdGluZyBtYW55IHRhYmxlcywgbW9zdFxuICAgICBvZiB3aGljaCBhcmUgbm90IGJpZyAoc2F5LCBpZiB5b3UgaGF2ZSBhIGhhc2h0Ymwgb2YgaGFzaHRibCkuIEFuZCBtZW1vcnkgb3ZlcmhlYWQgaXNcbiAgICAgbm90IHRoYXQgZWFzeSB0byBwcm9maWxlLlxuICAgLSBpZiBhIGhhc2h0YmwgaXMgZ29pbmcgdG8gZ3JvdywgaXQncyBub3QgY2xlYXIgd2h5IDEyOCBpcyBtYXJrZWRseSBiZXR0ZXIgdGhhbiBvdGhlclxuICAgICBzaXplcyAoaWYgeW91IGdvaW5nIHRvIHN0aWNrIDEwMDAgZWxlbWVudHMsIHlvdSdyZSBnb2luZyB0byBncm93IHRoZSBoYXNodGFibGUgb25jZVxuICAgICBvciB0d2ljZSBhbnl3YXkpXG4gICAtIGluIG90aGVyIGxhbmd1YWdlcyAobGlrZSBydXN0LCBweXRob24sIGFuZCBhcHBhcmVudGx5IGdvKSwgdGhlIGRlZmF1bHQgaXMgYWxzbyBhXG4gICAgIHNtYWxsIHNpemUuICopXG5sZXQgY3JlYXRlID8oZ3Jvd3RoX2FsbG93ZWQgPSB0cnVlKSA/KHNpemUgPSAwKSB+aGFzaGFibGUgKCkgPVxuICBsZXQgc2l6ZSA9IEludC5taW4gKEludC5tYXggMSBzaXplKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gIGxldCBzaXplID0gSW50LmNlaWxfcG93MiBzaXplIGluXG4gIHsgdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpzaXplIEF2bHRyZWUuZW1wdHlcbiAgOyBsZW5ndGggPSAwXG4gIDsgZ3Jvd3RoX2FsbG93ZWRcbiAgOyByZWNlbnRseV9hZGRlZCA9IHJlZiBmYWxzZVxuICA7IGhhc2hhYmxlXG4gIDsgbXV0YXRpb25fYWxsb3dlZCA9IHRydWVcbiAgfVxuOztcblxuKCoqIFN1cHBsZW1lbnRhbCBoYXNoLiBUaGlzIG1heSBub3QgYmUgbmVjZXNzYXJ5LCBpdCBpcyBpbnRlbmRlZCBhcyBhIGRlZmVuc2UgYWdhaW5zdCBwb29yXG4gICAgaGFzaCBmdW5jdGlvbnMsIGZvciB3aGljaCB0aGUgcG93ZXIgb2YgMiBzaXplZCB0YWJsZSB3aWxsIGJlIGVzcGVjaWFsbHkgc2Vuc2l0aXZlLlxuICAgIFdpdGggc29tZSB0ZXN0aW5nIHdlIG1heSBjaG9vc2UgdG8gYWRkIGl0LCBidXQgdGhpcyB0YWJsZSBpcyBkZXNpZ25lZCB0byBiZSByb2J1c3QgdG9cbiAgICBjb2xsaXNpb25zLCBhbmQgaW4gbW9zdCBvZiBteSB0ZXN0aW5nIHRoaXMgZGVncmFkZXMgcGVyZm9ybWFuY2UuICopXG5sZXQgX3N1cHBsZW1lbnRhbF9oYXNoIGggPVxuICBsZXQgaCA9IGggbHhvciAoKGggbHNyIDIwKSBseG9yIChoIGxzciAxMikpIGluXG4gIGggbHhvciAoaCBsc3IgNykgbHhvciAoaCBsc3IgNClcbjs7XG5cbmxldCBzbG90IHQga2V5ID1cbiAgbGV0IGhhc2ggPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmhhc2gga2V5IGluXG4gICgqIHRoaXMgaXMgYWx3YXlzIG5vbi1uZWdhdGl2ZSBiZWNhdXNlIHdlIGRvIFtsYW5kXSB3aXRoIG5vbi1uZWdhdGl2ZSBudW1iZXIgKilcbiAgaGFzaCBsYW5kIChBcnJheS5sZW5ndGggdC50YWJsZSAtIDEpXG47O1xuXG5sZXQgYWRkX3dvcmtlciB0IH5yZXBsYWNlIH5rZXkgfmRhdGEgPVxuICBsZXQgaSA9IHNsb3QgdCBrZXkgaW5cbiAgbGV0IHJvb3QgPSB0LnRhYmxlLihpKSBpblxuICBsZXQgYWRkZWQgPSB0LnJlY2VudGx5X2FkZGVkIGluXG4gIGFkZGVkIDo9IGZhbHNlO1xuICBsZXQgbmV3X3Jvb3QgPVxuICAgICgqIFRoZSBhdmwgdHJlZSBtaWdodCByZXBsYWNlIHRoZSB2YWx1ZSBbcmVwbGFjZT10cnVlXSBvciBkbyBub3RoaW5nIFtyZXBsYWNlPWZhbHNlXVxuICAgICAgIHRvIHRoZSBlbnRyeSwgaW4gdGhhdCBjYXNlIHRoZSB0YWJsZSBkaWQgbm90IGdldCBiaWdnZXIsIHNvIHdlIHNob3VsZCBub3RcbiAgICAgICBpbmNyZW1lbnQgbGVuZ3RoLCB3ZSBwYXNzIGluIHRoZSBib29sIHJlZiB0LmFkZGVkIHNvIHRoYXQgaXQgY2FuIHRlbGwgdXMgd2hldGhlclxuICAgICAgIGl0IGFkZGVkIG9yIHJlcGxhY2VkLiBXZSBkbyBpdCB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uLiBTaW5jZSB0aGUgYm9vbFxuICAgICAgIGlzIGFuIGltbWVkaWF0ZSBpdCBkb2VzIG5vdCBnbyB0aHJvdWdoIHRoZSB3cml0ZSBiYXJyaWVyLiAqKVxuICAgIEF2bHRyZWUuYWRkIH5yZXBsYWNlIHJvb3QgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIH5hZGRlZCB+a2V5IH5kYXRhXG4gIGluXG4gIGlmICFhZGRlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMTtcbiAgKCogVGhpcyBsaXR0bGUgb3B0aW1pemF0aW9uIHNhdmVzIGEgY2FtbF9tb2RpZnkgd2hlbiB0aGUgdHJlZVxuICAgICBoYXNuJ3QgYmVlbiByZWJhbGFuY2VkLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgbmV3X3Jvb3Qgcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdFxuOztcblxubGV0IG1heWJlX3Jlc2l6ZV90YWJsZSB0ID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gIGxldCBzaG91bGRfZ3JvdyA9IHQubGVuZ3RoID4gbGVuIGluXG4gIGlmIHNob3VsZF9ncm93ICYmIHQuZ3Jvd3RoX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgbGV0IG5ld19hcnJheV9sZW5ndGggPSBJbnQubWluIChsZW4gKiAyKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gICAgaWYgbmV3X2FycmF5X2xlbmd0aCA+IGxlblxuICAgIHRoZW4gKFxuICAgICAgbGV0IG5ld190YWJsZSA9IEFycmF5LmNyZWF0ZSB+bGVuOm5ld19hcnJheV9sZW5ndGggQXZsdHJlZS5lbXB0eSBpblxuICAgICAgbGV0IG9sZF90YWJsZSA9IHQudGFibGUgaW5cbiAgICAgIHQudGFibGUgPC0gbmV3X3RhYmxlO1xuICAgICAgdC5sZW5ndGggPC0gMDtcbiAgICAgIGxldCBmIH5rZXkgfmRhdGEgPSBhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9sZF90YWJsZSAtIDEgZG9cbiAgICAgICAgQXZsdHJlZS5pdGVyIG9sZF90YWJsZS4oaSkgfmZcbiAgICAgIGRvbmUpKVxuOztcblxubGV0IHNldCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhO1xuICBtYXliZV9yZXNpemVfdGFibGUgdFxuOztcblxubGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBhZGRfd29ya2VyIH5yZXBsYWNlOmZhbHNlIHQgfmtleSB+ZGF0YTtcbiAgaWYgISh0LnJlY2VudGx5X2FkZGVkKVxuICB0aGVuIChcbiAgICBtYXliZV9yZXNpemVfdGFibGUgdDtcbiAgICBgT2spXG4gIGVsc2UgYER1cGxpY2F0ZVxuOztcblxubGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgbWF0Y2ggYWRkIHQgfmtleSB+ZGF0YSB3aXRoXG4gIHwgYE9rIC0+ICgpXG4gIHwgYER1cGxpY2F0ZSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5IHQgaW5cbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jcmVhdGUgXCJIYXNodGJsLmFkZF9leG4gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBrZXkgc2V4cF9vZl9rZXkgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IGNsZWFyIHQgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgdC50YWJsZS4oaSkgPC0gQXZsdHJlZS5lbXB0eVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSAwXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsMiB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gICgqIHdpdGggYSBnb29kIGhhc2ggZnVuY3Rpb24gdGhlc2UgZmlyc3QgdHdvIGNhc2VzIHdpbGwgYmUgdGhlIG92ZXJ3aGVsbWluZyBtYWpvcml0eSxcbiAgICAgYW5kIEF2bHRyZWUuZmluZCBpcyByZWN1cnNpdmUsIHNvIGl0IGNhbid0IGJlIGlubGluZWQsIHNvIGRvaW5nIHRoaXMgYXZvaWRzIGFcbiAgICAgZnVuY3Rpb24gY2FsbCBpbiBtb3N0IGNhc2VzLiAqKVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5XG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSB0IGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiB0IGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwyXG4gICAgICB0cmVlXG4gICAgICB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgICAgIGtleVxuICAgICAgfmFcbiAgICAgIH5iXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCBrZXkgLT4gZmluZF9hbmRfY2FsbCB0IGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSB0IGtleSA9XG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGZhbHNlXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSBfIH0gLT4gY29tcGFyZV9rZXkgdCBrIGtleSA9IDBcbiAgfCB0cmVlIC0+IEF2bHRyZWUubWVtIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuOztcblxubGV0IHJlbW92ZSB0IGtleSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCBhZGRlZF9vcl9yZW1vdmVkID0gdC5yZWNlbnRseV9hZGRlZCBpblxuICBhZGRlZF9vcl9yZW1vdmVkIDo9IGZhbHNlO1xuICBsZXQgbmV3X3Jvb3QgPVxuICAgIEF2bHRyZWUucmVtb3ZlIHJvb3QgfnJlbW92ZWQ6YWRkZWRfb3JfcmVtb3ZlZCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5XG4gIGluXG4gIGlmIG5vdCAocGh5c19lcXVhbCByb290IG5ld19yb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICBpZiAhYWRkZWRfb3JfcmVtb3ZlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMVxuOztcblxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGFjYyA6PSBmIH5rZXkgfmRhdGEgIWFjY1xuICAgICAgICB8IGJ1Y2tldCAtPiBhY2MgOj0gQXZsdHJlZS5mb2xkIGJ1Y2tldCB+aW5pdDohYWNjIH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgIWFjY1xuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuICgpXG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICAgICAgICB8IGJ1Y2tldCAtPiBBdmx0cmVlLml0ZXIgYnVja2V0IH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT4gdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG1cbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGl0ZXJfa2V5cyB0IH5mID0gaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IHJlYyBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgaSA9XG4gIGxldCBhdmx0cmVlID0gdGFibGUuKGkpIGluXG4gIGlmIEF2bHRyZWUuaXNfZW1wdHkgYXZsdHJlZVxuICB0aGVuIGNob29zZV9ub25lbXB0eSB0YWJsZSAoaSArIDEpXG4gIGVsc2UgQXZsdHJlZS5jaG9vc2VfZXhuIGF2bHRyZWVcbjs7XG5cbmxldCBjaG9vc2VfZXhuIHQgPVxuICBpZiB0Lmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSGFzaHRibC5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pO1xuICBjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwXG47O1xuXG5sZXQgY2hvb3NlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDApXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2tleSBpbnZhcmlhbnRfZGF0YSB0ID1cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIEF2bHRyZWUuaW52YXJpYW50IHQudGFibGUuKGkpIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICBkb25lO1xuICBsZXQgcmVhbF9sZW4gPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBpIC0+XG4gICAgICBpbnZhcmlhbnRfa2V5IGtleTtcbiAgICAgIGludmFyaWFudF9kYXRhIGRhdGE7XG4gICAgICBpICsgMSlcbiAgaW5cbiAgYXNzZXJ0IChyZWFsX2xlbiA9IHQubGVuZ3RoKVxuOztcblxubGV0IGZpbmRfZXhuID1cbiAgbGV0IGlmX2ZvdW5kIHYgXyA9IHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBrIHQgPVxuICAgIHJhaXNlXG4gICAgICAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiSGFzaHRibC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHQuaGFzaGFibGUuc2V4cF9vZl90IGsgXSkpXG4gIGluXG4gIGxldCBmaW5kX2V4biB0IGtleSA9IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hOnQgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmb3JfYWxsaSB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IG5vdCAoZiB+a2V5IH5kYXRhKSkpXG5sZXQgZm9yX2FsbCB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gbm90IChmIGRhdGEpKSlcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gaWYgZiBkYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTooZiB+a2V5IH5kYXRhKSk7XG4gIG5ld190XG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGNvcHkgdCA9IG1hcCB0IH5mOkZuLmlkXG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgU29tZSBuZXdfZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgTm9uZSAtPiAoKSk7XG4gIG5ld190XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmaWx0ZXJfa2V5cyB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KVxuXG5sZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gIGxldCB0MCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGxldCB0MSA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggKGYgfmtleSB+ZGF0YSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IG5ld19kYXRhIC0+IHNldCB0MCB+a2V5IH5kYXRhOm5ld19kYXRhXG4gICAgfCBTZWNvbmQgbmV3X2RhdGEgLT4gc2V0IHQxIH5rZXkgfmRhdGE6bmV3X2RhdGEpO1xuICB0MCwgdDFcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaW5kX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbDJcbiAgICB0XG4gICAgaWRcbiAgICB+YTp0XG4gICAgfmI6ZGVmYXVsdFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgXyBfIC0+IGRhdGEpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuIGtleSB0IGRlZmF1bHQgLT5cbiAgICAgIGxldCBkZWZhdWx0ID0gZGVmYXVsdCAoKSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdClcbjs7XG5cbmxldCBmaW5kaV9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGwyXG4gICAgdFxuICAgIGlkXG4gICAgfmE6dFxuICAgIH5iOmRlZmF1bHRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIF8gXyAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgdCBkZWZhdWx0IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQga2V5IGluXG4gICAgICBzZXQgdCB+a2V5IH5kYXRhOmRlZmF1bHQ7XG4gICAgICBkZWZhdWx0KVxuOztcblxuKCogU29tZSBoYXNodGJsIGltcGxlbWVudGF0aW9ucyBtYXkgYmUgYWJsZSB0byBwZXJmb3JtIHRoaXMgbW9yZSBlZmZpY2llbnRseSB0aGFuIHR3b1xuICAgc2VwYXJhdGUgbG9va3VwcyAqKVxubGV0IGZpbmRfYW5kX3JlbW92ZSB0IGlkID1cbiAgbGV0IHJlc3VsdCA9IGZpbmQgdCBpZCBpblxuICBpZiBPcHRpb24uaXNfc29tZSByZXN1bHQgdGhlbiByZW1vdmUgdCBpZDtcbiAgcmVzdWx0XG47O1xuXG5cbmxldCBjaGFuZ2UgdCBpZCB+ZiA9XG4gIG1hdGNoIGYgKGZpbmQgdCBpZCkgd2l0aFxuICB8IE5vbmUgLT4gcmVtb3ZlIHQgaWRcbiAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleTppZCB+ZGF0YVxuOztcblxubGV0IHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgPVxuICBsZXQgZGF0YSA9IGYgKGZpbmQgdCBpZCkgaW5cbiAgc2V0IHQgfmtleTppZCB+ZGF0YTtcbiAgZGF0YVxuOztcblxubGV0IHVwZGF0ZSB0IGlkIH5mID0gaWdub3JlICh1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mIDogXylcblxubGV0IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5ID1cbiAgaWYgcmVtb3ZlX2lmX3plcm9cbiAgdGhlblxuICAgIGNoYW5nZSB0IGtleSB+ZjooZnVuIG9wdCAtPlxuICAgICAgbWF0Y2ggYnkgKyBPcHRpb24udmFsdWUgb3B0IH5kZWZhdWx0OjAgd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgbiAtPiBTb21lIG4pXG4gIGVsc2VcbiAgICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYnlcbiAgICAgIHwgU29tZSBpIC0+IGJ5ICsgaSlcbjs7XG5cbmxldCBpbmNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnlcbmxldCBkZWNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgKC1ieSlcblxubGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFsgZGF0YSBdXG4gICAgfCBTb21lIGwgLT4gZGF0YSA6OiBsKVxuOztcblxubGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIFtdIHwgU29tZSBbIF8gXSAtPiByZW1vdmUgdCBrZXlcbiAgfCBTb21lIChfIDo6IHRsKSAtPiBzZXQgdCB+a2V5IH5kYXRhOnRsXG47O1xuXG5sZXQgZmluZF9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlIH5zaXplICgpIGluXG4gIGxldCBkdXBlcyA9IHJlZiBbXSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgaWYgbWVtIHJlcyBrZXkgdGhlbiBkdXBlcyA6PSBrZXkgOjogIWR1cGVzIGVsc2Ugc2V0IHJlcyB+a2V5IH5kYXRhKTtcbiAgbWF0Y2ggIWR1cGVzIHdpdGhcbiAgfCBbXSAtPiBgT2sgcmVzXG4gIHwga2V5cyAtPiBgRHVwbGljYXRlX2tleXMgKExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6aGFzaGFibGUuSGFzaGFibGUuY29tcGFyZSBrZXlzKVxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgfmhhc2hhYmxlICgpIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBhZGRfbXVsdGkgcmVzIH5rZXkgfmRhdGEpO1xuICByZXNcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Qgd2l0aFxuICB8IGBPayB0IC0+IGBPayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGsgLT4gYER1cGxpY2F0ZV9rZXkgKExpc3QuaGRfZXhuIGspXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IGBPayB2IC0+IFJlc3VsdC5PayB2XG4gIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3IgXCJIYXNodGJsLm9mX2FsaXN0X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBzZXhwX29mX2tleVxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBSZXN1bHQuT2sgdiAtPiB2XG4gIHwgUmVzdWx0LkVycm9yIGUgLT4gRXJyb3IucmFpc2UgZVxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IHRvX2FsaXN0IHQgPSBmb2xkIH5mOihmdW4gfmtleSB+ZGF0YSBsaXN0IC0+IChrZXksIGRhdGEpIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIHRcbiAgfD4gdG9fYWxpc3RcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKGsxLCBfKSAoazIsIF8pIC0+IHQuaGFzaGFibGUuY29tcGFyZSBrMSBrMilcbiAgfD4gc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhKVxuOztcblxubGV0IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID1cbiAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCkgc2V4cCBpblxuICBtYXRjaCBvZl9hbGlzdCB+aGFzaGFibGUgYWxpc3QgfnNpemU6KExpc3QubGVuZ3RoIGFsaXN0KSB3aXRoXG4gIHwgYE9rIHYgLT4gdlxuICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgIExpc3QuaXRlcjJfZXhuIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgIGlmIGhhc2hhYmxlLmNvbXBhcmUgayBrMiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiSGFzaHRibC50X29mX3NleHA6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hclxuICAgICAgKHR5cGUgayB2KVxuICAgICAgKGtfZ3JhbW1hciA6IGsgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgICAodl9ncmFtbWFyIDogdiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiAoaywgdikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QuQXNzb2MudF9zZXhwX2dyYW1tYXIga19ncmFtbWFyIHZfZ3JhbW1hcilcbjs7XG5cbmxldCBrZXlzIHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhOl8gYWNjIC0+IGtleSA6OiBhY2MpXG5sZXQgZGF0YSB0ID0gZm9sZCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgYWRkX3RvX2dyb3VwcyBncm91cHMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzID1cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByb3cgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByb3cgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHJvdyBpblxuICAgIGxldCBkYXRhID1cbiAgICAgIG1hdGNoIGZpbmQgZ3JvdXBzIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgfCBTb21lIG9sZCAtPiBjb21iaW5lIG9sZCBkYXRhXG4gICAgaW5cbiAgICBzZXQgZ3JvdXBzIH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgcm93cyA9XG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKSBpblxuICBhZGRfdG9fZ3JvdXBzIHJlcyB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgfnJvd3M7XG4gIHJlc1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhOkZuLmlkIHJvd3Ncbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgbWF0Y2ggY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyB3aXRoXG4gIHwgYE9rIHQgLT4gUmVzdWx0Lk9rIHRcbiAgfCBgRHVwbGljYXRlX2tleXMga2V5cyAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiSGFzaHRibC5jcmVhdGVfd2l0aF9rZXk6IGR1cGxpY2F0ZSBrZXlzXCJcbiAgICAgICAgIFsgXCJrZXlzXCIsIHNleHBfb2ZfbGlzdCBzZXhwX29mX2tleSBrZXlzIF0pXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBPcl9lcnJvci5va19leG4gKGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MpXG47O1xuXG5sZXQgbWVyZ2UgPVxuICBsZXQgbWF5YmVfc2V0IHQgfmtleSB+ZiBkID1cbiAgICBtYXRjaCBmIH5rZXkgZCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHYgLT4gc2V0IHQgfmtleSB+ZGF0YTp2XG4gIGluXG4gIGZ1biB0X2xlZnQgdF9yaWdodCB+ZiAtPlxuICAgIGlmIG5vdCAoSGFzaGFibGUuZXF1YWwgdF9sZWZ0Lmhhc2hhYmxlIHRfcmlnaHQuaGFzaGFibGUpXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIkhhc2h0YmwubWVyZ2U6IGRpZmZlcmVudCAnaGFzaGFibGUnIHZhbHVlc1wiO1xuICAgIGxldCBuZXdfdCA9XG4gICAgICBjcmVhdGVcbiAgICAgICAgfmdyb3d0aF9hbGxvd2VkOnRfbGVmdC5ncm93dGhfYWxsb3dlZFxuICAgICAgICB+aGFzaGFibGU6dF9sZWZ0Lmhhc2hhYmxlXG4gICAgICAgIH5zaXplOnRfbGVmdC5sZW5ndGhcbiAgICAgICAgKClcbiAgICBpblxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9sZWZ0IChmdW4gKCkgLT5cbiAgICAgIHdpdGhvdXRfbXV0YXRpbmcgdF9yaWdodCAoZnVuICgpIC0+XG4gICAgICAgIGl0ZXJpIHRfbGVmdCB+ZjooZnVuIH5rZXkgfmRhdGE6bGVmdCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9yaWdodCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYExlZnQgbGVmdClcbiAgICAgICAgICB8IFNvbWUgcmlnaHQgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBCb3RoIChsZWZ0LCByaWdodCkpKTtcbiAgICAgICAgaXRlcmkgdF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6cmlnaHQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfbGVmdCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYFJpZ2h0IHJpZ2h0KVxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICAgKCogYWxyZWFkeSBkb25lIGFib3ZlICopKSkpO1xuICAgIG5ld190XG47O1xuXG5sZXQgbWVyZ2VfaW50byB+c3JjIH5kc3QgfmYgPVxuICBpdGVyaSBzcmMgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IGRzdF9kYXRhID0gZmluZCBkc3Qga2V5IGluXG4gICAgbGV0IGFjdGlvbiA9IHdpdGhvdXRfbXV0YXRpbmcgZHN0IChmdW4gKCkgLT4gZiB+a2V5IGRhdGEgZHN0X2RhdGEpIGluXG4gICAgbWF0Y2ggKGFjdGlvbiA6IF8gTWVyZ2VfaW50b19hY3Rpb24udCkgd2l0aFxuICAgIHwgUmVtb3ZlIC0+IHJlbW92ZSBkc3Qga2V5XG4gICAgfCBTZXRfdG8gZGF0YSAtPlxuICAgICAgKG1hdGNoIGRzdF9kYXRhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gc2V0IGRzdCB+a2V5IH5kYXRhXG4gICAgICAgfCBTb21lIGRzdF9kYXRhIC0+IGlmIG5vdCAocGh5c19lcXVhbCBkc3RfZGF0YSBkYXRhKSB0aGVuIHNldCBkc3QgfmtleSB+ZGF0YSkpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdG9fcmVtb3ZlID1cbiAgICBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjIGVsc2Uga2V5IDo6IGFjKVxuICBpblxuICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4ga2V5IC0+IHJlbW92ZSB0IGtleSlcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGZpbHRlcl9rZXlzX2lucGxhY2UgdCB+ZiA9IGZpbHRlcmlfaW5wbGFjZSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KVxuXG5sZXQgZmlsdGVyX21hcGlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IG1hcF9yZXN1bHRzID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiAoa2V5LCBmIH5rZXkgfmRhdGEpIDo6IGFjKSBpblxuICBMaXN0Lml0ZXIgbWFwX3Jlc3VsdHMgfmY6KGZ1biAoa2V5LCByZXN1bHQpIC0+XG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVtb3ZlIHQga2V5XG4gICAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleSB+ZGF0YSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgdCB+ZiA9IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIHdpdGhvdXRfbXV0YXRpbmcgdCAoZnVuICgpIC0+IEFycmF5Lml0ZXIgdC50YWJsZSB+ZjooQXZsdHJlZS5tYXBpX2lucGxhY2UgfmYpKVxuOztcblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPSBtYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBlcXVhbCBlcXVhbCB0IHQnID1cbiAgbGVuZ3RoIHQgPSBsZW5ndGggdCdcbiAgJiYgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgd2l0aG91dF9tdXRhdGluZyB0JyAoZnVuICgpIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBtYXRjaCBmaW5kIHQnIGtleSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByLnJldHVybiBmYWxzZVxuICAgICAgICB8IFNvbWUgZGF0YScgLT4gaWYgbm90IChlcXVhbCBkYXRhIGRhdGEnKSB0aGVuIHIucmV0dXJuIGZhbHNlKSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBzaW1pbGFyID0gZXF1YWxcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG4gIGxldCBjaG9vc2UgPSBjaG9vc2VcbiAgbGV0IGNob29zZV9leG4gPSBjaG9vc2VfZXhuXG4gIGxldCBjbGVhciA9IGNsZWFyXG4gIGxldCBjb3B5ID0gY29weVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlXG4gIGxldCBzZXQgPSBzZXRcbiAgbGV0IGFkZCA9IGFkZFxuICBsZXQgYWRkX2V4biA9IGFkZF9leG5cbiAgbGV0IGNoYW5nZSA9IGNoYW5nZVxuICBsZXQgdXBkYXRlID0gdXBkYXRlXG4gIGxldCB1cGRhdGVfYW5kX3JldHVybiA9IHVwZGF0ZV9hbmRfcmV0dXJuXG4gIGxldCBhZGRfbXVsdGkgPSBhZGRfbXVsdGlcbiAgbGV0IHJlbW92ZV9tdWx0aSA9IHJlbW92ZV9tdWx0aVxuICBsZXQgZmluZF9tdWx0aSA9IGZpbmRfbXVsdGlcbiAgbGV0IG1lbSA9IG1lbVxuICBsZXQgaXRlcl9rZXlzID0gaXRlcl9rZXlzXG4gIGxldCBpdGVyID0gaXRlclxuICBsZXQgaXRlcmkgPSBpdGVyaVxuICBsZXQgZXhpc3RzID0gZXhpc3RzXG4gIGxldCBleGlzdHNpID0gZXhpc3RzaVxuICBsZXQgZm9yX2FsbCA9IGZvcl9hbGxcbiAgbGV0IGZvcl9hbGxpID0gZm9yX2FsbGlcbiAgbGV0IGNvdW50ID0gY291bnRcbiAgbGV0IGNvdW50aSA9IGNvdW50aVxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgaXNfZW1wdHkgPSBpc19lbXB0eVxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXBpID0gbWFwaVxuICBsZXQgZmlsdGVyX21hcCA9IGZpbHRlcl9tYXBcbiAgbGV0IGZpbHRlcl9tYXBpID0gZmlsdGVyX21hcGlcbiAgbGV0IGZpbHRlcl9rZXlzID0gZmlsdGVyX2tleXNcbiAgbGV0IGZpbHRlciA9IGZpbHRlclxuICBsZXQgZmlsdGVyaSA9IGZpbHRlcmlcbiAgbGV0IHBhcnRpdGlvbl9tYXAgPSBwYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fbWFwaSA9IHBhcnRpdGlvbl9tYXBpXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBwYXJ0aXRpb25fdGZcbiAgbGV0IHBhcnRpdGlvbmlfdGYgPSBwYXJ0aXRpb25pX3RmXG4gIGxldCBmaW5kX29yX2FkZCA9IGZpbmRfb3JfYWRkXG4gIGxldCBmaW5kaV9vcl9hZGQgPSBmaW5kaV9vcl9hZGRcbiAgbGV0IGZpbmQgPSBmaW5kXG4gIGxldCBmaW5kX2V4biA9IGZpbmRfZXhuXG4gIGxldCBmaW5kX2FuZF9jYWxsID0gZmluZF9hbmRfY2FsbFxuICBsZXQgZmluZF9hbmRfY2FsbDEgPSBmaW5kX2FuZF9jYWxsMVxuICBsZXQgZmluZF9hbmRfY2FsbDIgPSBmaW5kX2FuZF9jYWxsMlxuICBsZXQgZmluZGlfYW5kX2NhbGwgPSBmaW5kaV9hbmRfY2FsbFxuICBsZXQgZmluZGlfYW5kX2NhbGwxID0gZmluZGlfYW5kX2NhbGwxXG4gIGxldCBmaW5kaV9hbmRfY2FsbDIgPSBmaW5kaV9hbmRfY2FsbDJcbiAgbGV0IGZpbmRfYW5kX3JlbW92ZSA9IGZpbmRfYW5kX3JlbW92ZVxuICBsZXQgdG9fYWxpc3QgPSB0b19hbGlzdFxuICBsZXQgbWVyZ2UgPSBtZXJnZVxuICBsZXQgbWVyZ2VfaW50byA9IG1lcmdlX2ludG9cbiAgbGV0IGtleXMgPSBrZXlzXG4gIGxldCBkYXRhID0gZGF0YVxuICBsZXQgZmlsdGVyX2tleXNfaW5wbGFjZSA9IGZpbHRlcl9rZXlzX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9pbnBsYWNlID0gZmlsdGVyX2lucGxhY2VcbiAgbGV0IGZpbHRlcmlfaW5wbGFjZSA9IGZpbHRlcmlfaW5wbGFjZVxuICBsZXQgbWFwX2lucGxhY2UgPSBtYXBfaW5wbGFjZVxuICBsZXQgbWFwaV9pbnBsYWNlID0gbWFwaV9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlXG4gIGxldCBlcXVhbCA9IGVxdWFsXG4gIGxldCBzaW1pbGFyID0gc2ltaWxhclxuICBsZXQgaW5jciA9IGluY3JcbiAgbGV0IGRlY3IgPSBkZWNyXG4gIGxldCBzZXhwX29mX2tleSA9IHNleHBfb2Zfa2V5XG5lbmRcblxubW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEtleS5oYXNoYWJsZVxuXG4gIHR5cGUgKCdhLCAnYikgdF8gPSAoJ2EgS2V5LnQsICdiKSB0XG5cbiAgbGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKCkgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSAoKVxuICBsZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPSBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcblxuICBsZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBrX29mX3NleHAgZF9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cFxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICAgIGdyb3VwID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbiAgOztcbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuICB0eXBlICdhIGtleSA9ICdhXG5cbiAgbGV0IGhhc2hhYmxlID0gSGFzaGFibGUucG9seVxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHRfc2V4cF9ncmFtbWFyXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgSGFzaGFibGUgPSBIYXNoYWJsZS5IYXNoYWJsZVxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gIGxldCBoYXNoYWJsZSB0ID0gdC5oYXNoYWJsZVxuZW5kXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPVxuICBjcmVhdGUgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3Rfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9tdWx0aSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIGwgPVxuICBjcmVhdGVfbWFwcGVkIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5IH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3Igfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXlfZXhuIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGwgPVxuICBncm91cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIGxcbjs7XG5cbmxldCBoYXNoYWJsZV9zIHQgPSBIYXNoYWJsZS50b19rZXkgdC5oYXNoYWJsZVxuXG5tb2R1bGUgTSAoSyA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2KSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGspIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGspIHZfb2Zfc2V4cCBzZXhwID1cbiAgdF9vZl9zZXhwIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IChtb2R1bGUgSykpIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgaykgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKSB2X2dyYW1tYXIgPVxuICB0X3NleHBfZ3JhbW1hciBLLnRfc2V4cF9ncmFtbWFyIHZfZ3JhbW1hclxuOztcblxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgZXF1YWxfdiB0MSB0MiA9IGVxdWFsIGVxdWFsX3YgdDEgdDJcbiIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgQ2FtbC5QcmludGZcblxuKCoqIGZhaWx3aXRoLCBpbnZhbGlkX2FyZywgYW5kIGV4aXQgYWNjZXB0aW5nIHByaW50ZidzIGZvcm1hdC4gKilcblxubGV0IGZhaWx3aXRoZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG5sZXQgaW52YWxpZF9hcmdmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbiIsIigqIFtTeXMwXSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW0NhbWwuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN5c10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzeXMubWxcbiAgIHNob3VsZCB1c2UgW0NhbWwuU3lzXS4gW1N5czBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlXG4gICBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHRoZXNlXG4gICBmdW5jdGlvbnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN5c10gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIFN5cyA9IFN5czBdLiAgRGVmaW5pbmcgW21vZHVsZSBTeXMgPSBTeXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN5c10uICopXG5cbm9wZW4hIEltcG9ydDBcblxudHlwZSBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGVcbmxldCBpbnRlcmFjdGl2ZSA9IENhbWwuU3lzLmludGVyYWN0aXZlXG5sZXQgb3NfdHlwZSA9IENhbWwuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gQ2FtbC5TeXMudW5peFxubGV0IHdpbjMyID0gQ2FtbC5TeXMud2luMzJcbmxldCBjeWd3aW4gPSBDYW1sLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IENhbWwuU3lzLndvcmRfc2l6ZVxubGV0IGludF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy5pbnRfc2l6ZVxubGV0IGJpZ19lbmRpYW4gPSBDYW1sLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBDYW1sLlN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IG1heF9hcnJheV9sZW5ndGggPSBDYW1sLlN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5sZXQgcnVudGltZV92YXJpYW50ID0gQ2FtbC5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gQ2FtbC5TeXMucnVudGltZV9wYXJhbWV0ZXJzXG5sZXQgYXJndiA9IENhbWwuU3lzLmFyZ3ZcbmxldCBnZXRfYXJndiAoKSA9IENhbWwuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gQ2FtbC5TeXMub2NhbWxfdmVyc2lvblxubGV0IGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzID0gQ2FtbC5TeXMuZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcbmxldCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgPSBDYW1sLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IENhbWwuTm90X2ZvdW5kIC0+XG4gICAgUHJpbnRmLmZhaWx3aXRoZiBcIlN5cy5nZXRlbnZfZXhuOiBlbnZpcm9ubWVudCB2YXJpYWJsZSAlcyBpcyBub3Qgc2V0XCIgdmFyICgpXG47O1xuXG5sZXQgZ2V0ZW52IHZhciA9XG4gIG1hdGNoIENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcblxuZXhjZXB0aW9uIEJyZWFrID0gQ2FtbC5TeXMuQnJlYWtcbiIsIigqIFtBcnJheTBdIGRlZmluZXMgYXJyYXkgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zXG4gICBvZiBbQ2FtbC5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuQXJyYXldXG4gICB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGFycmF5MC5tbCBzaG91bGQgdXNlIFtDYW1sLkFycmF5XS5cbiAgIFtBcnJheTBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGFycmF5cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQXJyYXldIGluIGJ1aWxkIG9yZGVyIHNob3VsZFxuICAgZG8gW21vZHVsZSBBcnJheSA9IEFycmF5MF0uICBUaGlzIGluY2x1ZGVzIHVzZXMgb2Ygc3Vic2NyaXB0IHN5bnRheCAoW3guKGkpXSwgW3guKGkpIDwtXG4gICBlXSksIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbQXJyYXkuZ2V0XSBhbmQgW0FycmF5LnNldF0uXG4gICBEZWZpbmluZyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwIGZyb21cbiAgIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkFycmF5XS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCA6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuICBleHRlcm5hbCBnZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIHNldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOidhIGFycmF5XG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6J2EgYXJyYXlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5lbmRcblxuaW5jbHVkZSBBcnJheVxuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZSBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZSB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW4gPVxuICB0cnkgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgbGVuIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGFwcGVuZCA9IENhbWwuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IENhbWwuQXJyYXkuYmxpdFxubGV0IGNvbmNhdCA9IENhbWwuQXJyYXkuY29uY2F0XG5sZXQgY29weSA9IENhbWwuQXJyYXkuY29weVxubGV0IGZpbGwgPSBDYW1sLkFycmF5LmZpbGxcbmxldCBpbml0ID0gQ2FtbC5BcnJheS5pbml0XG5sZXQgbWFrZV9tYXRyaXggPSBDYW1sLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IENhbWwuQXJyYXkub2ZfbGlzdFxubGV0IHN1YiA9IENhbWwuQXJyYXkuc3ViXG5sZXQgdG9fbGlzdCA9IENhbWwuQXJyYXkudG9fbGlzdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkFycmF5LmZvbGRfbGVmdCB0IH5pbml0IH5mXG5sZXQgZm9sZF9yaWdodCB0IH5mIH5pbml0ID0gQ2FtbC5BcnJheS5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXIgdCB+ZlxubGV0IGl0ZXJpIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXJpIHQgfmZcbmxldCBtYXAgdCB+ZiA9IENhbWwuQXJyYXkubWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBDYW1sLkFycmF5Lm1hcGkgdCB+ZlxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBDYW1sLkFycmF5LnN0YWJsZV9zb3J0IHQgfmNtcDpjb21wYXJlXG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGVsdF9pID0gdC4oaSkgaW5cbiAgbGV0IGVsdF9qID0gdC4oaikgaW5cbiAgdW5zYWZlX3NldCB0IGkgZWx0X2o7XG4gIHVuc2FmZV9zZXQgdCBqIGVsdF9pXG47O1xuIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5DaGFyXS4gIFtDaGFyMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkNoYXJdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGNoYXIwLm1sIHNob3VsZCB1c2UgW0NhbWwuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IENhbWwuQ2hhci5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gQ2FtbC5DaGFyLmxvd2VyY2FzZV9hc2NpaVxubGV0IHRvX2ludCA9IENhbWwuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IENhbWwuQ2hhci51bnNhZmVfY2hyXG5sZXQgdXBwZXJjYXNlID0gQ2FtbC5DaGFyLnVwcGVyY2FzZV9hc2NpaVxuXG4oKiBXZSB1c2Ugb3VyIG93biByYW5nZSB0ZXN0IHdoZW4gY29udmVydGluZyBpbnRlZ2VycyB0byBjaGFycyByYXRoZXIgdGhhblxuICAgY2FsbGluZyBbQ2FtbC5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiIsIigqIFtJbnQwXSBkZWZpbmVzIGludGVnZXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbF0uIFtJbnQwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlXG4gICBwYXJ0IG9mIFtDYW1sXSB0aGF0IFtCYXNlXSB1c2VzIGZvciBpbnRlZ2VycyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gaW50MC5tbCBzaG91bGQgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0aHJvdWdoIFtDYW1sXS4gW0ludDBdIGhhc1xuICAgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgaW50cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuSW50XSBpbiBidWlsZFxuICAgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgSW50ICA9IEludDBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgSW50ID0gSW50MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcFxuICAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5JbnRdLiAqKVxuXG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgb2Zfc3RyaW5nID0gQ2FtbC5pbnRfb2Zfc3RyaW5nXG5sZXQgdG9fZmxvYXQgPSBDYW1sLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0ID0gQ2FtbC5pbnRfb2ZfZmxvYXRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBzdWNjID0gQ2FtbC5zdWNjXG4iLCIoKiBbTGlzdDBdIGRlZmluZXMgbGlzdCBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtDYW1sLkxpc3RdLiAgW0xpc3QwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbQ2FtbC5MaXN0XS5cbiAgIFtMaXN0MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgbGlzdHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkxpc3RdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBMaXN0ID0gTGlzdDBdLiAgRGVmaW5pbmcgW21vZHVsZSBMaXN0ID0gTGlzdDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuTGlzdF0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGhkX2V4biA9IENhbWwuTGlzdC5oZFxubGV0IGxlbmd0aCA9IENhbWwuTGlzdC5sZW5ndGhcbmxldCByZXZfYXBwZW5kID0gQ2FtbC5MaXN0LnJldl9hcHBlbmRcbmxldCB0bF9leG4gPSBDYW1sLkxpc3QudGxcbmxldCB1bnppcCA9IENhbWwuTGlzdC5zcGxpdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBleGlzdHMgdCB+ZiA9IENhbWwuTGlzdC5leGlzdHMgdCB+ZlxubGV0IGV4aXN0czJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZXhpc3RzMiBsMSBsMiB+ZlxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQgdCB+ZiB+aW5pdFxubGV0IGZvbGQyX29rIGwxIGwyIH5pbml0IH5mID0gQ2FtbC5MaXN0LmZvbGRfbGVmdDIgbDEgbDIgfmluaXQgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbCB0IH5mXG5sZXQgZm9yX2FsbDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbDIgbDEgbDIgfmZcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkxpc3QuaXRlciB0IH5mXG5sZXQgaXRlcjJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuaXRlcjIgbDEgbDIgfmZcbmxldCBub250YWlsX21hcCB0IH5mID0gQ2FtbC5MaXN0Lm1hcCB0IH5mXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBDYW1sLkxpc3QubWFwaSB0IH5mXG5sZXQgcGFydGl0aW9uIHQgfmYgPSBDYW1sLkxpc3QucGFydGl0aW9uIHQgfmZcbmxldCByZXZfbWFwIHQgfmYgPSBDYW1sLkxpc3QucmV2X21hcCB0IH5mXG5sZXQgcmV2X21hcDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QucmV2X21hcDIgbDEgbDIgfmZcbmxldCBzb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc29ydCBsIH5jbXA6Y29tcGFyZVxubGV0IHN0YWJsZV9zb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc3RhYmxlX3NvcnQgbCB+Y21wOmNvbXBhcmVcblxubGV0IHJldiA9IGZ1bmN0aW9uXG4gIHwgKFtdIHwgWyBfIF0pIGFzIHJlcyAtPiByZXNcbiAgfCB4IDo6IHkgOjogcmVzdCAtPiByZXZfYXBwZW5kIHJlc3QgWyB5OyB4IF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0IGwgfmYgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbClcbjs7XG4iLCIoKlxuICAgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHRvIHRoZSBydW50aW1lIHN1cHBvcnQgZm9yIFtwcHhfaGFzaF0uXG5cbiAgIFRoZSBbcHB4X2hhc2hdIHN5bnRheCBleHRlbnNpb24gc3VwcG9ydHM6IFtAQGRlcml2aW5nIGhhc2hdIGFuZCBbJWhhc2hfZm9sZDogVFlQRV0gYW5kXG4gICBbJWhhc2g6IFRZUEVdXG5cbiAgIEZvciB0eXBlIFt0XSBhIGZ1bmN0aW9uIFtoYXNoX2ZvbGRfdF0gb2YgdHlwZSBbSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGVdIGlzXG4gICBnZW5lcmF0ZWQuXG5cbiAgIFRoZSBnZW5lcmF0ZWQgW2hhc2hfZm9sZF88VD5dIGZ1bmN0aW9uIGlzIGNvbXBvc2l0aW9uYWwsIGZvbGxvd2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgdHlwZTsgYWxsb3dpbmcgdXNlciBvdmVycmlkZXMgYXQgZXZlcnkgbGV2ZWwuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gb2NhbWwncyBidWlsdGluXG4gICBwb2x5bW9ycGhpYyBoYXNoaW5nIFtIYXNodGJsLmhhc2hdIHdoaWNoIGlnbm9yZXMgdXNlciBvdmVycmlkZXMuXG5cbiAgIFRoZSBnZW5lcmF0b3IgYWxzbyBwcm92aWRlcyBhIGRpcmVjdCBoYXNoLWZ1bmN0aW9uIFtoYXNoXSAobmFtZWQgW2hhc2hfPFQ+XSB3aGVuIDxUPiAhPVxuICAgXCJ0XCIpIG9mIHR5cGU6IFt0IC0+IEhhc2guaGFzaF92YWx1ZV0uXG5cbiAgIFRoZSBmb2xkaW5nIGhhc2ggZnVuY3Rpb24gY2FuIGJlIGFjY2Vzc2VkIGFzIFslaGFzaF9mb2xkOiBUWVBFXVxuICAgVGhlIGRpcmVjdCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2g6IFRZUEVdXG4qKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEhhc2hfaW50ZlxuXG4oKiogQnVpbHRpbiBmb2xkaW5nLXN0eWxlIGhhc2ggZnVuY3Rpb25zLCBhYnN0cmFjdGVkIG92ZXIgW0hhc2hfaW50Zi5TXSAqKVxubW9kdWxlIEZvbGRpbmcgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuQnVpbHRpbl9pbnRmXG4gIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgaGFzaF9mb2xkX3VuaXQgcyAoKSA9IHNcbiAgbGV0IGhhc2hfZm9sZF9pbnQgPSBIYXNoLmZvbGRfaW50XG4gIGxldCBoYXNoX2ZvbGRfaW50NjQgPSBIYXNoLmZvbGRfaW50NjRcbiAgbGV0IGhhc2hfZm9sZF9mbG9hdCA9IEhhc2guZm9sZF9mbG9hdFxuICBsZXQgaGFzaF9mb2xkX3N0cmluZyA9IEhhc2guZm9sZF9zdHJpbmdcbiAgbGV0IGFzX2ludCBmIHMgeCA9IGhhc2hfZm9sZF9pbnQgcyAoZiB4KVxuXG4gICgqIFRoaXMgaWdub3JlcyB0aGUgc2lnbiBiaXQgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIHVubGlrZWx5IHRvIGxlYWQgdG9cbiAgICAgZnJlcXVlbnQgY29sbGlzaW9ucyAobWluX3ZhbHVlIGNvbGxpZGluZyB3aXRoIDAgaXMgdGhlIG1vc3QgbGlrZWx5IG9uZSkuICAqKVxuICBsZXQgaGFzaF9mb2xkX2ludDMyID0gYXNfaW50IENhbWwuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoQ2FtbC5MYXp5LmZvcmNlIHgpXG4gIGxldCBoYXNoX2ZvbGRfcmVmX2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzICF4XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gcyBhcnJheSBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIGFycmF5XG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZSA9IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSBpblxuICAgICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIGUpIGFycmF5IChpICsgMSkpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9hcnJheV9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyBhcnJheSA9XG4gICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pXG4gICAgICAoKiBbbGVuZ3RoXSBtdXN0IGJlIGluY29ycG9yYXRlZCBmb3IgYXJyYXlzLCBhcyBpdCBpcyBmb3IgbGlzdHMuIFNlZSBjb21tZW50IGFib3ZlICopXG4gICAgICBoYXNoX2ZvbGRfZWxlbVxuICAgICAgKGhhc2hfZm9sZF9pbnQgcyAoQXJyYXkubGVuZ3RoIGFycmF5KSlcbiAgICAgIGFycmF5XG4gICAgICAwXG4gIDs7XG5cbiAgKCogdGhlIGR1cGxpY2F0aW9uIGhlcmUgaXMgYmVjYXVzZSB3ZSB0aGlua1xuICAgICBvY2FtbCBjYW4ndCBlbGltaW5hdGUgaW5kaXJlY3QgZnVuY3Rpb24gY2FsbHMgb3RoZXJ3aXNlLiAqKVxuICBsZXQgaGFzaF9uYXRpdmVpbnQgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX25hdGl2ZWludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfaW50NjQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQ2NCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludDMyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50MzIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9jaGFyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfY2hhciAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2Jvb2wgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9ib29sIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcblxuICBsZXQgaGFzaF9zdHJpbmcgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3N0cmluZyAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZmxvYXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9mbG9hdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX3VuaXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF91bml0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbmVuZFxuXG5tb2R1bGUgRiAoSGFzaCA6IEhhc2hfaW50Zi5TKSA6XG4gIEhhc2hfaW50Zi5GdWxsXG4gIHdpdGggdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIHNlZWQgPSBIYXNoLnNlZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBvZl9mb2xkIGhhc2hfZm9sZF90IHQgPSBnZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3QgKGNyZWF0ZSAoKSkgdClcblxuICBtb2R1bGUgQnVpbHRpbiA9IEZvbGRpbmcgKEhhc2gpXG5cbiAgbGV0IHJ1biA/c2VlZCBmb2xkZXIgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChIYXNoLnJlc2V0ID9zZWVkIChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxoYXNoIDogc2lnXG4gIGluY2x1ZGVcbiAgICBIYXNoX2ludGYuU1xuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnN0YXRlXG4gICAgICgqIFdlIGdpdmUgYSBjb25jcmV0ZSB0eXBlIGZvciBbc3RhdGVdLCBhbGJlaXQgb25seSBwYXJ0aWFsbHkgZXhwb3NlZCAoc2VlXG4gICAgICAgIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzKSwgc28gdGhhdCBpdCB1bmlmaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBpbiBbQmFzZV9ib290XSxcbiAgICAgICAgYW5kIHRvIGFsbG93IG9wdGltaXphdGlvbnMgZm9yIHRoZSBpbW1lZGlhdGUgdHlwZS4gKilcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnNlZWRcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0IDogc3RhdGUgLT4gaW50NjQgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfaW50IDogc3RhdGUgLT4gaW50IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9mbG9hdCA6IHN0YXRlIC0+IGZsb2F0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX3N0cmluZyA6IHN0YXRlIC0+IHN0cmluZyAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGdldF9oYXNoX3ZhbHVlIDogc3RhdGUgLT4gaGFzaF92YWx1ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcIlxuICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCJCYXNlX2hhc2hfZG91YmxlXCIgW0BAbm9hbGxvY11cblxuICAgIGxldCBoYXNoX3VuaXQgKCkgPSAwXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgVFxuIiwib3BlbiBJbXBvcnQwXG5cbmxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG5leHRlcm5hbCBwb2x5bW9ycGhpY19jb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBwb2x5bW9ycGhpY19lcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG5cbm1vZHVsZSBDb21wYXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjb21wYXJlIDogdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2EgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAoJ2EsICdiKSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAnYyBjb21wYXJlIC0+ICgnYSwgJ2IsICdjKSB0IGNvbXBhcmVcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnVpbHRpbiA9IHN0cnVjdFxuICBsZXQgY29tcGFyZV9ib29sIDogYm9vbCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfZmxvYXQgOiBmbG9hdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludCA6IGludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfc3RyaW5nIDogc3RyaW5nIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfdW5pdCA6IHVuaXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgaWYgcGh5c19lcXVhbCBhIGJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgICAgaWYgcmV0IDw+IDBcbiAgICAgIHRoZW4gcmV0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgICAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAwKSlcbiAgOztcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdCBhIGJcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9lbHQgIWEgIWJcbiAgbGV0IGVxdWFsX2Jvb2wgOiBib29sIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfY2hhciA6IGNoYXIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMiA6IGludDMyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjQgOiBpbnQ2NCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA6IG5hdGl2ZWludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZyA6IHN0cmluZyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXQgOiB1bml0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gICgqIFtQb2x5LmVxdWFsXSBpcyBJRUVFIGNvbXBsaWFudCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudCBoZXJlLiAqKVxuICBsZXQgZXF1YWxfZmxvYXQgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0IHggeSkgMFxuXG4gIGxldCBlcXVhbF9hcnJheSBlcXVhbF9lbHQgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8XG4gICAgbGV0IGxlbl9hID0gQXJyYXkwLmxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgZXF1YWwgbGVuX2EgbGVuX2JcbiAgICAmJlxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGkgPSBsZW5fYVxuICAgICAgfHxcbiAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgZXF1YWxfZWx0IGwgciAmJiBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdCBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCBbXSwgXyB8IF8sIFtdIC0+IGZhbHNlXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+IGVxdWFsX2VsdCB4IHkgJiYgZXF1YWxfbGlzdCBlcXVhbF9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGVxdWFsX2VsdCBhIGJcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIGVxdWFsX2VsdCBhIGIgPSBlcXVhbF9lbHQgIWEgIWJcbmVuZFxuIiwib3BlbiBIYXNoLkJ1aWx0aW5cbm9wZW4gUHB4X2NvbXBhcmVfbGliLkJ1aWx0aW5cbmluY2x1ZGUgU2V4cGxpYjAuU2V4cFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPSBTZXhwbGliMC5TZXhwLnQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG5sZXQgcmVjIGNvbXBhcmUgPVxuICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZyBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbmluY2x1ZGUgU3RyaW5nMFxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG4oKiBUaGlzIGFsaWFzIGlzIG5lY2Vzc2FyeSBkZXNwaXRlIFtTdHJpbmcwXSBkZWZpbmluZyBbQnl0ZXMgPSBCeXRlczBdLCBpbiBvcmRlciB0b1xuICAgY29udmluY2Ugb2NhbWxkZXAgdGhhdCB0aGlzIGZpbGUgZG9lc24ndCBkZXBlbmQgb24gYnl0ZXMubWwuICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3N0cmluZ1xuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfc3RyaW5nIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxudHlwZSBlbHQgPSBjaGFyXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbigqIFRoaXMgaXMgY29waWVkL2FkYXB0ZWQgZnJvbSAnYmxpdC5tbCcuXG4gICBbc3ViXSwgW3N1Ym9dIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtCbGl0Lk1ha2UoQnl0ZXMpXSBwbHVzIHVuc2FmZSBjYXN0cyB0by9mcm9tXG4gICBzdHJpbmcgYnV0IHdlcmUgaW5saW5lZCBoZXJlIHRvIGF2b2lkIHVzaW5nIFtCeXRlcy51bnNhZmVfb2Zfc3RyaW5nXSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuKilcbmxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA9IDAgJiYgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmNcbiAgdGhlbiBzcmNcbiAgZWxzZSAoXG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHNyYyk7XG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KSlcbjs7XG5cbmxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICBzdWJcbiAgICBzcmNcbiAgICB+cG9zXG4gICAgfmxlbjpcbiAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICB8IE5vbmUgLT4gbGVuZ3RoIHNyYyAtIHBvcylcbjs7XG5cbmxldCByZWMgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXyBjaGFyID1cbiAgcG9zIDwgZW5kX1xuICAmJiAoQ2hhci5lcXVhbCAodW5zYWZlX2dldCB0IHBvcykgY2hhciB8fCBjb250YWluc191bnNhZmUgdCB+cG9zOihwb3MgKyAxKSB+ZW5kXyBjaGFyKVxuOztcblxubGV0IGNvbnRhaW5zID8ocG9zID0gMCkgP2xlbiB0IGNoYXIgPVxuICBsZXQgdG90YWxfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gIGxldCBsZW4gPSBPcHRpb24udmFsdWUgbGVuIH5kZWZhdWx0Oih0b3RhbF9sZW5ndGggLSBwb3MpIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF86KHBvcyArIGxlbikgY2hhclxuOztcblxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IHJlYyBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA+PSBsZW5cbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvczoocG9zICsgMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCBpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3M6MCB+bGVuOihsZW5ndGggdCkgfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBpbmRleF9leG4gdCBjaGFyID0gaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgaW5kZXhfZXhuXG47O1xuXG5sZXQgaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhclxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgcmVjIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA8IDBcbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyAtIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgcmluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOihsZW4gLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZXhuIHQgY2hhciA9IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZXhuXG47O1xuXG5sZXQgcmluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgLTEgfHwgcG9zID49IGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZnJvbV9leG5cbjs7XG5cbmxldCBpbmRleCB0IGNoYXIgPVxuICB0cnkgU29tZSAoaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmluZGV4IHQgY2hhciA9XG4gIHRyeSBTb21lIChyaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICB0cnkgU29tZSAocmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuMCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgPSBfIH0gOiBTZXhwLnQgPVxuICAgIExpc3RcbiAgICAgIFsgTGlzdCBbIEF0b20gXCJwYXR0ZXJuXCI7IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm4gXVxuICAgICAgOyBMaXN0IFsgQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZSBdXG4gICAgICBdXG4gIDs7XG5cbiAgbGV0IHBhdHRlcm4gdCA9IHQucGF0dGVyblxuICBsZXQgY2FzZV9zZW5zaXRpdmUgdCA9IHQuY2FzZV9zZW5zaXRpdmVcblxuICAoKiBGaW5kIG1heCBudW1iZXIgb2YgbWF0Y2hlZCBjaGFyYWN0ZXJzIGF0IFtuZXh0X3RleHRfY2hhcl0sIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgIFttYXRjaGVkX2NoYXJzXS4gVHJ5IHRvIGV4dGVuZCB0aGUgY3VycmVudCBtYXRjaCwgaWYgY2hhcnMgZG9uJ3QgbWF0Y2gsIHRyeSB0byBtYXRjaFxuICAgICBmZXdlciBjaGFycy4gSWYgY2hhcnMgbWF0Y2ggdGhlbiBleHRlbmQgdGhlIG1hdGNoLiAqKVxuICBsZXQga21wX2ludGVybmFsX2xvb3Agfm1hdGNoZWRfY2hhcnMgfm5leHRfdGV4dF9jaGFyIH5wYXR0ZXJuIH5rbXBfYXJyYXkgfmNoYXJfZXF1YWwgPVxuICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIG1hdGNoZWRfY2hhcnMgaW5cbiAgICB3aGlsZVxuICAgICAgIW1hdGNoZWRfY2hhcnMgPiAwXG4gICAgICAmJiBub3QgKGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycykpXG4gICAgZG9cbiAgICAgIG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKCFtYXRjaGVkX2NoYXJzIC0gMSlcbiAgICBkb25lO1xuICAgIGlmIGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycylcbiAgICB0aGVuIG1hdGNoZWRfY2hhcnMgOj0gIW1hdGNoZWRfY2hhcnMgKyAxO1xuICAgICFtYXRjaGVkX2NoYXJzXG4gIDs7XG5cbiAgbGV0IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbWF0Y2ggY2FzZV9zZW5zaXRpdmUgd2l0aFxuICAgIHwgdHJ1ZSAtPiBDaGFyLmVxdWFsXG4gICAgfCBmYWxzZSAtPiBDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVAgcHJlLXByb2Nlc3Npbmcgb2YgdGhlIHBhdHRlcm46IGJ1aWxkIHRoZSBpbnQgYXJyYXksIHdoaWNoLCBmb3IgZWFjaCBpLFxuICAgICBjb250YWlucyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IG5vbi10cml2aWFsIHByZWZpeCBvZiBzIHdoaWNoIGlzIGVxdWFsIHRvIGEgc3VmZml4XG4gICAgIGVuZGluZyBhdCBzLltpXSAqKVxuICBsZXQgY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBsZXQgbiA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgbGV0IGttcF9hcnJheSA9IEFycmF5LmNyZWF0ZSB+bGVuOm4gKC0xKSBpblxuICAgIGlmIG4gPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgMCAwO1xuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhcjoodW5zYWZlX2dldCBwYXR0ZXJuIGkpXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IGkgIW1hdGNoZWRfY2hhcnNcbiAgICAgIGRvbmUpO1xuICAgIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9XG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVA6IHVzZSB0aGUgcHJlLXByb2Nlc3NlZCBwYXR0ZXJuIHRvIG9wdGltaXplIGxvb2stYmVoaW5kcyBvbiBub24tbWF0Y2hlcy5cbiAgICAgV2UgcmV0dXJuIGludCB0byBhdm9pZCBhbGxvY2F0aW9uIGluIFtpbmRleF9leG5dLiAtMSBtZWFucyBubyBtYXRjaC4gKilcbiAgbGV0IGluZGV4X2ludGVybmFsID8ocG9zID0gMCkgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfmluXzp0ZXh0ID1cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlbmd0aCB0ZXh0IC0gbGVuZ3RoIHBhdHRlcm5cbiAgICB0aGVuIC0xXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IGogPSByZWYgcG9zIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICB3aGlsZSAhaiA8IG4gJiYgIW1hdGNoZWRfY2hhcnMgPCBrIGRvXG4gICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCAhaiBpblxuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgaiA6PSAhaiArIDFcbiAgICAgIGRvbmU7XG4gICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGsgdGhlbiAhaiAtIGsgZWxzZSAtMSlcbiAgOztcblxuICBsZXQgbWF0Y2hlcyB0IHN0ciA9IGluZGV4X2ludGVybmFsIHQgfmluXzpzdHIgPj0gMFxuXG4gIGxldCBpbmRleCA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPCAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgcFxuICA7O1xuXG4gIGxldCBpbmRleF9leG4gP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwID49IDBcbiAgICB0aGVuIHBcbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJTdWJzdHJpbmcgbm90IGZvdW5kXCIgWyBcInN1YnN0cmluZ1wiLCBzZXhwX29mX3N0cmluZyB0LnBhdHRlcm4gXSlcbiAgOztcblxuICBsZXQgaW5kZXhfYWxsIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5tYXlfb3ZlcmxhcCB+aW5fOnRleHQgPVxuICAgIGlmIGxlbmd0aCBwYXR0ZXJuID0gMFxuICAgIHRoZW4gTGlzdC5pbml0ICgxICsgbGVuZ3RoIHRleHQpIH5mOkZuLmlkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgbGV0IGZvdW5kID0gcmVmIFtdIGluXG4gICAgICBmb3IgaiA9IDAgdG8gbiBkb1xuICAgICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGtcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgZm91bmQgOj0gKGogLSBrKSA6OiAhZm91bmQ7XG4gICAgICAgICAgKCogd2UganVzdCBmb3VuZCBhIG1hdGNoIGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb24gKilcbiAgICAgICAgICBtYXRjaCBtYXlfb3ZlcmxhcCB3aXRoXG4gICAgICAgICAgfCB0cnVlIC0+IG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKGsgLSAxKVxuICAgICAgICAgIHwgZmFsc2UgLT4gbWF0Y2hlZF9jaGFycyA6PSAwKTtcbiAgICAgICAgaWYgaiA8IG5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0IGogaW5cbiAgICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICB+Y2hhcl9lcXVhbClcbiAgICAgIGRvbmU7XG4gICAgICBMaXN0LnJldiAhZm91bmQpXG4gIDs7XG5cbiAgbGV0IHJlcGxhY2VfZmlyc3QgP3BvcyB0IH5pbl86cyB+d2l0aF8gPVxuICAgIG1hdGNoIGluZGV4ID9wb3MgdCB+aW5fOnMgd2l0aFxuICAgIHwgTm9uZSAtPiBzXG4gICAgfCBTb21lIGkgLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgbGVuX3dpdGggLSBsZW5fdCkgaW5cbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOndpdGhfIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczppIH5sZW46bGVuX3dpdGg7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6KGkgKyBsZW5fdClcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczooaSArIGxlbl93aXRoKVxuICAgICAgICB+bGVuOihsZW5fcyAtIGkgLSBsZW5fdCk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG5cbiAgbGV0IHJlcGxhY2VfYWxsIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgbWF0Y2ggbWF0Y2hlcyB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBudW1fbWF0Y2hlcyA9IExpc3QubGVuZ3RoIG1hdGNoZXMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgKChsZW5fd2l0aCAtIGxlbl90KSAqIG51bV9tYXRjaGVzKSkgaW5cbiAgICAgIGxldCBuZXh0X2RzdF9wb3MgPSByZWYgMCBpblxuICAgICAgbGV0IG5leHRfc3JjX3BvcyA9IHJlZiAwIGluXG4gICAgICBMaXN0Lml0ZXIgbWF0Y2hlcyB+ZjooZnVuIGkgLT5cbiAgICAgICAgbGV0IGxlbiA9IGkgLSAhbmV4dF9zcmNfcG9zIGluXG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczohbmV4dF9zcmNfcG9zIH5kc3QgfmRzdF9wb3M6IW5leHRfZHN0X3BvcyB+bGVuO1xuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICAgIH5zcmM6d2l0aF9cbiAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgfmRzdFxuICAgICAgICAgIH5kc3RfcG9zOighbmV4dF9kc3RfcG9zICsgbGVuKVxuICAgICAgICAgIH5sZW46bGVuX3dpdGg7XG4gICAgICAgIG5leHRfZHN0X3BvcyA6PSAhbmV4dF9kc3RfcG9zICsgbGVuICsgbGVuX3dpdGg7XG4gICAgICAgIG5leHRfc3JjX3BvcyA6PSAhbmV4dF9zcmNfcG9zICsgbGVuICsgbGVuX3QpO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOiFuZXh0X3NyY19wb3NcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczohbmV4dF9kc3RfcG9zXG4gICAgICAgIH5sZW46KGxlbl9zIC0gIW5leHRfc3JjX3Bvcyk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG4gIGxldCBzcGxpdF9vbiB0IHMgPVxuICAgIGxldCBwYXR0ZXJuX2xlbiA9IFN0cmluZy5sZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgTGlzdC5tYXAyX2V4blxuICAgICAgKC1wYXR0ZXJuX2xlbiA6OiBtYXRjaGVzKVxuICAgICAgKG1hdGNoZXMgQCBbIFN0cmluZy5sZW5ndGggcyBdKVxuICAgICAgfmY6KGZ1biBpIGogLT4gc3ViIHMgfnBvczooaSArIHBhdHRlcm5fbGVuKSB+bGVuOihqIC0gaSAtIHBhdHRlcm5fbGVuKSlcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgcHVibGljID0gdFxuXG4gICAgdHlwZSBub25yZWMgdCA9IHQgPVxuICAgICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWwgPVxuICAgICAgKGZ1biBhX18wMDJfIGJfXzAwM18gLT5cbiAgICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMl8gYl9fMDAzX1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAoZXF1YWxfc3RyaW5nIGFfXzAwMl8ucGF0dGVybiBiX18wMDNfLnBhdHRlcm4pXG4gICAgICAgICAgICAgKFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAgICAoZXF1YWxfYm9vbCBhX18wMDJfLmNhc2Vfc2Vuc2l0aXZlIGJfXzAwM18uY2FzZV9zZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgKGVxdWFsX2FycmF5IGVxdWFsX2ludCBhX18wMDJfLmttcF9hcnJheSBiX18wMDNfLmttcF9hcnJheSkpXG4gICAgICAgICAgIDogdCAtPiB0IC0+IGJvb2wpXG4gICAgOztcblxuICAgIGxldCBzZXhwX29mX3QgPVxuICAgICAgKGZ1biB7IHBhdHRlcm4gPSBwYXR0ZXJuX18wMDdfXG4gICAgICAgICAgIDsgY2FzZV9zZW5zaXRpdmUgPSBjYXNlX3NlbnNpdGl2ZV9fMDA5X1xuICAgICAgICAgICA7IGttcF9hcnJheSA9IGttcF9hcnJheV9fMDExX1xuICAgICAgICAgICB9IC0+XG4gICAgICAgIGxldCBibmRzX18wMDZfID0gW10gaW5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgIGxldCBhcmdfXzAxMl8gPSBzZXhwX29mX2FycmF5IHNleHBfb2ZfaW50IGttcF9hcnJheV9fMDExXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImttcF9hcnJheVwiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlX18wMDlfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiY2FzZV9zZW5zaXRpdmVcIjsgYXJnX18wMTBfIF1cbiAgICAgICAgICA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA3XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBhdHRlcm5cIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDA2X1xuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gRm4uaWRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuX2hlbHBlciA9IHN0cnVjdFxuICBtb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBTZWFyY2hfcGF0dGVybjBcbmVuZFxuXG5vcGVuIFNlYXJjaF9wYXR0ZXJuX2hlbHBlclxuXG5sZXQgc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXggP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfZXhuID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfm1heV9vdmVybGFwIH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfYWxsXG4gICAgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybilcbiAgICB+bWF5X292ZXJsYXBcbiAgICB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfZmlyc3QgP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9hbGwgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+c3Vic3RyaW5nID1cbiAgT3B0aW9uLmlzX3NvbWUgKHN1YnN0cl9pbmRleF9nZW4gdCB+cGF0dGVybjpzdWJzdHJpbmcgfmNhc2Vfc2Vuc2l0aXZlKVxuOztcblxubGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5cbmxldCBpc19zdWJzdHJpbmdfYXRfZ2VuID1cbiAgbGV0IHJlYyBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvcyB+c3ViX2xlbiB+Y2hhcl9lcXVhbCA9XG4gICAgaWYgc3ViX3BvcyA9IHN1Yl9sZW5cbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGlmIGNoYXJfZXF1YWwgKHVuc2FmZV9nZXQgc3RyIHN0cl9wb3MpICh1bnNhZmVfZ2V0IHN1YiBzdWJfcG9zKVxuICAgIHRoZW4gbG9vcCB+c3RyIH5zdHJfcG9zOihzdHJfcG9zICsgMSkgfnN1YiB+c3ViX3Bvczooc3ViX3BvcyArIDEpIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG4gICAgZWxzZSBmYWxzZVxuICBpblxuICBmdW4gc3RyIH5wb3M6c3RyX3BvcyB+c3Vic3RyaW5nOnN1YiB+Y2hhcl9lcXVhbCAtPlxuICAgIGxldCBzdHJfbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCBzdWJfbGVuID0gbGVuZ3RoIHN1YiBpblxuICAgIGlmIHN0cl9wb3MgPCAwIHx8IHN0cl9wb3MgPiBzdHJfbGVuXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiU3RyaW5nLmlzX3N1YnN0cmluZ19hdDogaW52YWxpZCBpbmRleCAlZCBmb3Igc3RyaW5nIG9mIGxlbmd0aCAlZFwiXG4gICAgICAgIHN0cl9wb3NcbiAgICAgICAgc3RyX2xlblxuICAgICAgICAoKTtcbiAgICBzdHJfcG9zICsgc3ViX2xlbiA8PSBzdHJfbGVuXG4gICAgJiYgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3M6MCB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3N1ZmZpeF9nZW4gc3RyaW5nIH5zdWZmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIHN0cmluZ19sZW4gPj0gc3VmZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuXG4gICAgICAgc3RyaW5nXG4gICAgICAgfnBvczooc3RyaW5nX2xlbiAtIHN1ZmZpeF9sZW4pXG4gICAgICAgfnN1YnN0cmluZzpzdWZmaXhcbiAgICAgICB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3ByZWZpeF9nZW4gc3RyaW5nIH5wcmVmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHByZWZpeF9sZW4gPSBsZW5ndGggcHJlZml4IGluXG4gIHN0cmluZ19sZW4gPj0gcHJlZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuIHN0cmluZyB+cG9zOjAgfnN1YnN0cmluZzpwcmVmaXggfmNoYXJfZXF1YWxcbjs7XG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9zdHJpbmcgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNoYXJfY29tcGFyZV9jYXNlbGVzcyBjMSBjMiA9IENoYXIuY29tcGFyZSAoQ2hhci5sb3dlcmNhc2UgYzEpIChDaGFyLmxvd2VyY2FzZSBjMilcblxuICAgIGxldCByZWMgY29tcGFyZV9sb29wIH5wb3MgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjIgPVxuICAgICAgaWYgcG9zID0gbGVuMVxuICAgICAgdGhlbiBpZiBwb3MgPSBsZW4yIHRoZW4gMCBlbHNlIC0xXG4gICAgICBlbHNlIGlmIHBvcyA9IGxlbjJcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjID0gY2hhcl9jb21wYXJlX2Nhc2VsZXNzICh1bnNhZmVfZ2V0IHN0cmluZzEgcG9zKSAodW5zYWZlX2dldCBzdHJpbmcyIHBvcykgaW5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgMCAtPiBjb21wYXJlX2xvb3AgfnBvczoocG9zICsgMSkgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjJcbiAgICAgICAgfCBfIC0+IGMpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIHN0cmluZzEgc3RyaW5nMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHN0cmluZzEgc3RyaW5nMlxuICAgICAgdGhlbiAwXG4gICAgICBlbHNlXG4gICAgICAgIGNvbXBhcmVfbG9vcFxuICAgICAgICAgIH5wb3M6MFxuICAgICAgICAgIH5zdHJpbmcxXG4gICAgICAgICAgfmxlbjE6KFN0cmluZy5sZW5ndGggc3RyaW5nMSlcbiAgICAgICAgICB+c3RyaW5nMlxuICAgICAgICAgIH5sZW4yOihTdHJpbmcubGVuZ3RoIHN0cmluZzIpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID1cbiAgICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgICAgbGV0IHN0YXRlID0gcmVmIChoYXNoX2ZvbGRfaW50IHN0YXRlIGxlbikgaW5cbiAgICAgIGZvciBwb3MgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgc3RhdGUgOj0gaGFzaF9mb2xkX2NoYXIgIXN0YXRlIChDaGFyLmxvd2VyY2FzZSAodW5zYWZlX2dldCB0IHBvcykpXG4gICAgICBkb25lO1xuICAgICAgIXN0YXRlXG4gICAgOztcblxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gICAgbGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nX2F0ID0gaXNfc3Vic3RyaW5nX2F0X2dlbiB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbmVuZFxuXG5sZXQgb2Zfc3RyaW5nID0gRm4uaWRcbmxldCB0b19zdHJpbmcgPSBGbi5pZFxuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgQnl0ZXMuc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCB0b19saXN0IHMgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpIDwgMCB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgLSAxKSBpblxuICBsb29wIFtdIChsZW5ndGggcyAtIDEpXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpID0gbGVuIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSArIDEpIGluXG4gIGxvb3AgW10gMFxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCByZXMgaSAodW5zYWZlX2dldCB0IChsZW4gLSAxIC0gaSkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzXG47O1xuXG4oKiogRWZmaWNpZW50IHN0cmluZyBzcGxpdHRpbmcgKilcblxubGV0IGxzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmxzcGxpdDJfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGxzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgcG9zID0gaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGxzcGxpdDJfZXhuXG47O1xuXG5sZXQgcnNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucnNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcnNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBwb3MgPSByaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJzcGxpdDJfZXhuXG47O1xuXG5sZXQgbHNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChsc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcnNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChyc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG5sZXQgc3BsaXRfbGluZXMgPVxuICBsZXQgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbCA9XG4gICAgcG9zIDo9ICFwb3MgLSBpZiAhcG9zID4gMCAmJiBDaGFyLmVxdWFsIHQuWyFwb3MgLSAxXSAnXFxyJyB0aGVuIDIgZWxzZSAxO1xuICAgIGVvbCA6PSAhcG9zICsgMVxuICBpblxuICBmdW4gdCAtPlxuICAgIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgICgqIEludmFyaWFudDogWy0xIDw9IHBvcyA8IGVvbF0uICopXG4gICAgICBsZXQgcG9zID0gcmVmIChuIC0gMSkgaW5cbiAgICAgIGxldCBlb2wgPSByZWYgbiBpblxuICAgICAgbGV0IGFjID0gcmVmIFtdIGluXG4gICAgICAoKiBXZSB0cmVhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgc3BlY2lhbGx5LCBiZWNhdXNlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGFcbiAgICAgICAgIG5ld2xpbmUsIHdlIGRvbid0IHdhbnQgYW4gZXh0cmEgZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG91dHB1dC4gKilcbiAgICAgIGlmIENoYXIuZXF1YWwgdC5bIXBvc10gJ1xcbicgdGhlbiBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sO1xuICAgICAgd2hpbGUgIXBvcyA+PSAwIGRvXG4gICAgICAgIGlmIENoYXIuKCA8PiApIHQuWyFwb3NdICdcXG4nXG4gICAgICAgIHRoZW4gZGVjciBwb3NcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogQmVjYXVzZSBbcG9zIDwgZW9sXSwgd2Uga25vdyB0aGF0IFtzdGFydCA8PSBlb2xdLiAqKVxuICAgICAgICAgIGxldCBzdGFydCA9ICFwb3MgKyAxIGluXG4gICAgICAgICAgYWMgOj0gc3ViIHQgfnBvczpzdGFydCB+bGVuOighZW9sIC0gc3RhcnQpIDo6ICFhYztcbiAgICAgICAgICBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sKVxuICAgICAgZG9uZTtcbiAgICAgIHN1YiB0IH5wb3M6MCB+bGVuOiFlb2wgOjogIWFjKVxuOztcblxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBpIC0+IFNvbWUgdC5baV1cbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG5cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGYgdC5baV0gd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHJlcylcbiAgaW5cbiAgbG9vcCAwXG47O1xuXG5sZXQgcmZpbmRpID9wb3MgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA8IDAgdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSAtIDEpIGluXG4gIGxldCBwb3MgPVxuICAgIG1hdGNoIHBvcyB3aXRoXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgICB8IE5vbmUgLT4gbGVuZ3RoIHQgLSAxXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKVxuXG5sZXQgcnN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSBpIC0+IGlmIGkgPSBsZW5ndGggdCAtIDEgdGhlbiB0IGVsc2UgcHJlZml4IHQgKGkgKyAxKVxuOztcblxubGV0IGZpcnN0X25vbl9kcm9wIH5kcm9wIHQgPSBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBub3QgKGRyb3AgYykpXG5cbmxldCBsc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSAwIC0+IHRcbiAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG47O1xuXG4oKiBbc3RyaXAgdF0gY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgW2xzdHJpcCAocnN0cmlwIHQpXS4gIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG5sZXQgc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBmaXJzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgICB8IE5vbmUgLT4gXCJcIlxuICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHQnID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0JyBpIChmIGkgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbigqIHJlcGVhdGVkIGNvZGUgdG8gYXZvaWQgcmVxdWlyaW5nIGFuIGV4dHJhIGFsbG9jYXRpb24gZm9yIGEgY2xvc3VyZSBvbiBlYWNoIGNhbGwuICopXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiB0LltpXSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0J1xuOztcblxubGV0IHRvX2FycmF5IHMgPSBBcnJheS5pbml0IChsZW5ndGggcykgfmY6KGZ1biBpIC0+IHMuW2ldKVxuXG5sZXQgZXhpc3RzID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA8IGxlbiAmJiAoZiBzLltpXSB8fCBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb3JfYWxsID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA9IGxlbiB8fCAoZiBzLltpXSAmJiBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGZvbGRpID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBpIGFjIHQuW2ldKSB+ZiB+bGVuXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCAwIGluaXQgfmYgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0ID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdFxubGV0IG1heF9lbHQgdCA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHRcbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZmluZF9tYXBpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kX21hcGkgfml0ZXJpIHQgfmZcbmxldCBmaW5kaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZGkgfml0ZXJpIHQgfmZcbmxldCBjb3VudGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmNvdW50aSB+Zm9sZGkgdCB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5mb3JfYWxsaSB+aXRlcmkgdCB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmV4aXN0c2kgfml0ZXJpIHQgfmZcblxubGV0IG1lbSA9XG4gIGxldCByZWMgbG9vcCB0IGMgfnBvczppIH5sZW4gPVxuICAgIGkgPCBsZW4gJiYgKENoYXIuZXF1YWwgYyAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCBjIH5wb3M6KGkgKyAxKSB+bGVuKVxuICBpblxuICBmdW4gdCBjIC0+IGxvb3AgdCBjIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgaWYgQ2hhci5lcXVhbCB0YXJnZXQgcmVwbGFjZW1lbnRcbiAgdGhlbiBzXG4gIGVsc2UgaWYgbWVtIHMgdGFyZ2V0XG4gIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IGlmIENoYXIuZXF1YWwgYyB0YXJnZXQgdGhlbiByZXBsYWNlbWVudCBlbHNlIGMpXG4gIGVsc2Ugc1xuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgaXNfZW1wdHkgdGFyZ2V0XG4gIHRoZW4gc3RhZ2UgRm4uaWRcbiAgZWxzZSBpZiBpc19lbXB0eSByZXBsYWNlbWVudFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGkgcmVwbGFjZW1lbnQgaXMgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIEZuLmlkXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGlmIGV4aXN0cyBzIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICh1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpKVxuICAgICAgICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiB1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpXG4gICAgICAgIGVsc2UgcykpXG47O1xuXG4oKiBmYXN0IHZlcnNpb24sIGlmIHdlIGV2ZXIgbmVlZCBpdDpcbiAgIHtbXG4gICAgIGxldCBjb25jYXRfYXJyYXkgfnNlcCBhciA9XG4gICAgICAgbGV0IGFyX2xlbiA9IEFycmF5Lmxlbmd0aCBhciBpblxuICAgICAgIGlmIGFyX2xlbiA9IDAgdGhlbiBcIlwiXG4gICAgICAgZWxzZVxuICAgICAgICAgbGV0IHNlcF9sZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICBsZXQgcmVzX2xlbl9yZWYgPSByZWYgKHNlcF9sZW4gKiAoYXJfbGVuIC0gMSkpIGluXG4gICAgICAgICBmb3IgaSA9IDAgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICByZXNfbGVuX3JlZiA6PSAhcmVzX2xlbl9yZWYgKyBsZW5ndGggYXIuKGkpXG4gICAgICAgICBkb25lO1xuICAgICAgICAgbGV0IHJlcyA9IGNyZWF0ZSAhcmVzX2xlbl9yZWYgaW5cbiAgICAgICAgIGxldCBzdHJfMCA9IGFyLigwKSBpblxuICAgICAgICAgbGV0IGxlbl8wID0gbGVuZ3RoIHN0cl8wIGluXG4gICAgICAgICBibGl0IH5zcmM6c3RyXzAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczowIH5sZW46bGVuXzA7XG4gICAgICAgICBsZXQgcG9zX3JlZiA9IHJlZiBsZW5fMCBpblxuICAgICAgICAgZm9yIGkgPSAxIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgbGV0IHBvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzZXAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3Bvczpwb3MgfmxlbjpzZXBfbGVuO1xuICAgICAgICAgICBsZXQgbmV3X3BvcyA9IHBvcyArIHNlcF9sZW4gaW5cbiAgICAgICAgICAgbGV0IHN0cl9pID0gYXIuKGkpIGluXG4gICAgICAgICAgIGxldCBsZW5faSA9IGxlbmd0aCBzdHJfaSBpblxuICAgICAgICAgICBibGl0IH5zcmM6c3RyX2kgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczpuZXdfcG9zIH5sZW46bGVuX2k7XG4gICAgICAgICAgIHBvc19yZWYgOj0gbmV3X3BvcyArIGxlbl9pXG4gICAgICAgICBkb25lO1xuICAgICAgICAgcmVzXG4gICBdfSAqKVxuXG5sZXQgY29uY2F0X2FycmF5ID9zZXAgYXIgPSBjb25jYXQgP3NlcCAoQXJyYXkudG9fbGlzdCBhcilcbmxldCBjb25jYXRfbWFwID9zZXAgcyB+ZiA9IGNvbmNhdF9hcnJheSA/c2VwIChBcnJheS5tYXAgKHRvX2FycmF5IHMpIH5mKVxuXG4oKiBbZmlsdGVyIHQgZl0gaXMgaW1wbGVtZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0uXG5cbiAgIExldCBbbiA9IGxlbmd0aCB0XS5cblxuICAgMS4gRmluZCB0aGUgbG93ZXN0IFtpXSBzdWNoIHRoYXQgW25vdCAoZiB0LltpXSldLlxuXG4gICAyLiBJZiB0aGVyZSBpcyBubyBzdWNoIFtpXSwgdGhlbiByZXR1cm4gW3RdLlxuXG4gICAzLiBJZiB0aGVyZSBpcyBzdWNoIGFuIFtpXSwgYWxsb2NhdGUgYSBzdHJpbmcsIFtvdXRdLCB0byBob2xkIHRoZSByZXN1bHQuICBbb3V0XSBoYXNcbiAgIGxlbmd0aCBbbiAtIDFdLCB3aGljaCBpcyB0aGUgbWF4aW11bSBwb3NzaWJsZSBvdXRwdXQgc2l6ZSBnaXZlbiB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0XG4gICBvbmUgY2hhcmFjdGVyIG5vdCBzYXRpc2Z5aW5nIFtmXS5cblxuICAgNC4gQ29weSBjaGFyYWN0ZXJzIGF0IGluZGljZXMgMCAuLi4gW2kgLSAxXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNS4gV2FsayB0aHJvdWdoIGNoYXJhY3RlcnMgYXQgaW5kaWNlcyBbaSsxXSAuLi4gW24tMV0gb2YgW3RdLCBjb3B5aW5nIHRob3NlIHRoYXRcbiAgIHNhdGlzZnkgW2ZdIGZyb20gW3RdIHRvIFtvdXRdLlxuXG4gICA2LiBJZiB3ZSBjb21wbGV0ZWx5IGZpbGxlZCBbb3V0XSwgdGhlbiByZXR1cm4gaXQuICBJZiBub3QsIHJldHVybiB0aGUgcHJlZml4IG9mIFtvdXRdXG4gICB0aGF0IHdlIGRpZCBmaWxsIGluLlxuXG4gICBUaGlzIGFsZ29yaXRobSBoYXMgdGhlIHByb3BlcnR5IHRoYXQgaXQgZG9lc24ndCBhbGxvY2F0ZSBhIG5ldyBzdHJpbmcgaWYgdGhlcmUnc1xuICAgbm90aGluZyB0byBmaWx0ZXIsIHdoaWNoIGlzIGEgY29tbW9uIGNhc2UuICopXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IG4gJiYgZiAhaSB0LlshaV0gZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgaWYgIWkgPSBuXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgb3V0ID0gQnl0ZXMuY3JlYXRlIChuIC0gMSkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om91dCB+ZHN0X3BvczowIH5sZW46IWk7XG4gICAgbGV0IG91dF9wb3MgPSByZWYgIWkgaW5cbiAgICBpbmNyIGk7XG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgYyA9IHQuWyFpXSBpblxuICAgICAgaWYgZiAhaSBjXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dCAhb3V0X3BvcyBjO1xuICAgICAgICBpbmNyIG91dF9wb3MpO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBsZXQgb3V0ID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXQgaW5cbiAgICBpZiAhb3V0X3BvcyA9IG4gLSAxIHRoZW4gb3V0IGVsc2Ugc3ViIG91dCB+cG9zOjAgfmxlbjohb3V0X3Bvcylcbjs7XG5cbmxldCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gU29tZSAoZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3BfcHJlZml4X2lmX2V4aXN0cyBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9wcmVmaXhfZXhuIHMgfnByZWZpeCA9XG4gIG1hdGNoIGNob3BfcHJlZml4IHMgfnByZWZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9wcmVmaXhfZXhuICVTICVTXCIgcyBwcmVmaXggKClcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gU29tZSAoZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3Bfc3VmZml4X2lmX2V4aXN0cyBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9zdWZmaXhfZXhuIHMgfnN1ZmZpeCA9XG4gIG1hdGNoIGNob3Bfc3VmZml4IHMgfnN1ZmZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9zdWZmaXhfZXhuICVTICVTXCIgcyBzdWZmaXggKClcbjs7XG5cbm1vZHVsZSBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4ID0gc3RydWN0XG4gICgqIFdoZW4gdGFraW5nIGEgc3RyaW5nIHByZWZpeCBvciBzdWZmaXgsIHdlIGV4dHJhY3QgZnJvbSB0aGUgc2hvcnRlc3QgaW5wdXQgYXZhaWxhYmxlXG4gICAgIGluIGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIG9uZSBvZiBvdXIgaW5wdXRzIHdpdGhvdXQgYWxsb2NhdGluZyBhIG5ldyBzdHJpbmcuICopXG5cbiAgbGV0IHNob3J0ZXIgYSBiID0gaWYgbGVuZ3RoIGEgPD0gbGVuZ3RoIGIgdGhlbiBhIGVsc2UgYlxuXG4gIGxldCBzaG9ydGVzdCBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT4gTGlzdC5mb2xkIHJlc3QgfmluaXQ6Zmlyc3QgfmY6c2hvcnRlclxuICA7O1xuXG4gICgqIE91ciBnZW5lcmljIGFjY2Vzc29ycyBmb3IgY29tbW9uIHByZWZpeC9zdWZmaXggYWJzdHJhY3Qgb3ZlciBbZ2V0X3Bvc10sIHdoaWNoIGlzXG4gICAgIGVpdGhlciBbcG9zX2Zyb21fbGVmdF0gb3IgW3Bvc19mcm9tX3JpZ2h0XS4gKilcblxuICBsZXQgcG9zX2Zyb21fbGVmdCAoXyA6IHQpIChpIDogaW50KSA9IGlcbiAgbGV0IHBvc19mcm9tX3JpZ2h0IHQgaSA9IGxlbmd0aCB0IC0gaSAtIDFcblxuICBsZXQgcmVjIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXIgPVxuICAgIGlmIGxlbl9zb19mYXIgPj0gbWF4X2xlblxuICAgIHRoZW4gbWF4X2xlblxuICAgIGVsc2UgaWYgQ2hhci5lcXVhbFxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBhIChnZXRfcG9zIGEgbGVuX3NvX2ZhcikpXG4gICAgICAgICAgICAgICh1bnNhZmVfZ2V0IGIgKGdldF9wb3MgYiBsZW5fc29fZmFyKSlcbiAgICB0aGVuIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6KGxlbl9zb19mYXIgKyAxKVxuICAgIGVsc2UgbGVuX3NvX2ZhclxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyA9XG4gICAgbGV0IG1heF9sZW4gPSBtaW4gKGxlbmd0aCBhKSAobGVuZ3RoIGIpIGluXG4gICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCBsaXN0IH5nZXRfcG9zIH5tYXhfbGVuID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IG1heF9sZW5cbiAgICB8IHNlY29uZCA6OiByZXN0IC0+XG4gICAgICBsZXQgbWF4X2xlbiA9XG4gICAgICAgICgqIFdlIGNhbGwgW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW4gW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhdIHNvXG4gICAgICAgICAgIHRoYXQgW21heF9sZW5dIGxpbWl0cyBvdXIgdHJhdmVyc2FsIG9mIFtmaXJzdF0gYW5kIFtzZWNvbmRdLiAqKVxuICAgICAgICBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgZmlyc3Qgc2Vjb25kIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOjBcbiAgICAgIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBzZWNvbmQgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3BvcyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiAwXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+XG4gICAgICAoKiBQcmVjb21wdXRpbmcgW21heF9sZW5dIGJhc2VkIG9uIFtzaG9ydGVzdCBsaXN0XSBzYXZlcyB1cyB3b3JrIGluIGxvbmdlciBzdHJpbmdzLFxuICAgICAgICAgYXQgdGhlIGNvc3Qgb2YgYW4gZXh0cmEgcGFzcyBvdmVyIHRoZSBzcGluZSBvZiBbbGlzdF0uXG5cbiAgICAgICAgIEZvciBleGFtcGxlLCBpZiB5b3UncmUgbG9va2luZyBmb3IgdGhlIGxvbmdlc3QgcHJlZml4IG9mIHRoZSBzdHJpbmdzOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgbGV0IGxvbmdfYSA9IExpc3QuaW5pdCAxMDAwIH5mOihGbi5jb25zdCAnYScpXG4gICAgICAgICAgICBbIGxvbmdfYTsgbG9uZ19hOyAnYWEnIF1cbiAgICAgICAgIHZ9XG5cbiAgICAgICAgIHRoZSBhcHByb2FjaCBiZWxvdyB3aWxsIGp1c3QgY2hlY2sgdGhlIGZpcnN0IHR3byBjaGFyYWN0ZXJzIG9mIGFsbCB0aGUgc3RyaW5ncy5cbiAgICAgICopXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCAoc2hvcnRlc3QgbGlzdCkgaW5cbiAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgdGhhdCBwcm9kdWNlIGEgc3RyaW5nIGFic3RyYWN0IG92ZXIgW3Rha2VdLCB3aGljaCBpcyBlaXRoZXJcbiAgICAgW3ByZWZpeF0gb3IgW3N1ZmZpeF0uICopXG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljMiBhIGIgfmdldF9wb3MgfnRha2UgPVxuICAgIGxldCBsZW4gPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyBpblxuICAgICgqIFVzZSB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIHN0cmluZ3MsIHNvIHRoYXQgaWYgdGhlIHNob3J0ZXIgb25lIGlzIHRoZSBzaGFyZWRcbiAgICAgICBwcmVmaXgsIFt0YWtlXSB3b24ndCBhbGxvY2F0ZSBhbm90aGVyIHN0cmluZy4gKilcbiAgICB0YWtlIChzaG9ydGVyIGEgYikgbGVuXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljIGxpc3QgfmdldF9wb3MgfnRha2UgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gXCJcIlxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogQXMgd2l0aCBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSwgd2UgYmFzZSBbbWF4X2xlbl0gb24gW3Nob3J0ZXN0IGxpc3RdLiBXZSBhbHNvXG4gICAgICAgICB1c2UgdGhpcyByZXN1bHQgZm9yIFt0YWtlXSwgYmVsb3csIHRvIHBvdGVudGlhbGx5IGF2b2lkIGFsbG9jYXRpbmcgYSBzdHJpbmcuICopXG4gICAgICBsZXQgcyA9IHNob3J0ZXN0IGxpc3QgaW5cbiAgICAgIGxldCBtYXhfbGVuID0gbGVuZ3RoIHMgaW5cbiAgICAgIGlmIG1heF9sZW4gPSAwXG4gICAgICB0aGVuIFwiXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbGVuID1cbiAgICAgICAgICAoKiBXZSBjYWxsIGRpcmVjdGx5IGludG8gW2NvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wXSByYXRoZXIgdGhhblxuICAgICAgICAgICAgIFtjb21tb25fZ2VuZXJpY19sZW5ndGhdIHRvIGF2b2lkIHJlY29tcHV0aW5nIFtzaG9ydGVzdCBsaXN0XS4gKilcbiAgICAgICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gICAgICAgIGluXG4gICAgICAgIHRha2UgcyBsZW4pXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4XG5cbiAgbGV0IGNvbW1vbl9wcmVmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6cHJlZml4IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6c3VmZml4IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeF9sZW5ndGggbGlzdCA9IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDJfbGVuZ3RoIGEgYiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuZW5kXG5cbigqIFRoZXJlIHVzZWQgdG8gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gdGhhdCB3YXMgZmFzdGVyIGZvciB2ZXJ5IHNob3J0IHN0cmluZ3NcbiAgIChwZWFraW5nIGF0IDQwJSBmYXN0ZXIgZm9yIDQtNiBjaGFyIGxvbmcgc3RyaW5ncykuXG4gICBUaGlzIG5ldyBmdW5jdGlvbiBpcyBhcm91bmQgMjAlIGZhc3RlciB0aGFuIHRoZSBkZWZhdWx0IGhhc2ggZnVuY3Rpb24sIGJ1dCBzbG93ZXJcbiAgIHRoYW4gdGhlIHByZXZpb3VzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdGhlIG5ldyBPQ2FtbCBmdW5jdGlvbiBpcyB3ZWxsXG4gICBiZWhhdmVkLCBhbmQgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBsZXNzIGxpa2VseSB0byBkaXZlcmdlIGZyb20gdGhlIGRlZmF1bHQgT0NhbWxcbiAgIGltcGxlbWVudGF0aW9uIGRvZXMsIHdoaWNoIGlzIGEgZGVzaXJhYmxlIHByb3BlcnR5LiAoVGhlIG9ubHkgd2F5IHRvIGF2b2lkIHRoZVxuICAgZGl2ZXJnZW5jZSBpcyB0byBleHBvc2UgdGhlIG1hY3JvIHJlZGVmaW5lZCBpbiBoYXNoX3N0dWJzLmMgaW4gdGhlIGhhc2guaCBoZWFkZXIgb2ZcbiAgIHRoZSBPQ2FtbCBjb21waWxlci4pICopXG5tb2R1bGUgSGFzaCA9IHN0cnVjdFxuICBleHRlcm5hbCBoYXNoIDogc3RyaW5nIC0+IGludCA9IFwiQmFzZV9oYXNoX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5lbmRcblxuKCogW2luY2x1ZGUgSGFzaF0gdG8gbWFrZSB0aGUgW2V4dGVybmFsXSB2ZXJzaW9uIG92ZXJyaWRlIHRoZSBbaGFzaF0gZnJvbVxuICAgW0hhc2hhYmxlLk1ha2VfYmluYWJsZV0sIHNvIHRoYXQgd2UgZ2V0IGEgbGl0dGxlIGJpdCBvZiBhIHNwZWVkdXAgYnkgZXhwb3NpbmcgaXQgYXNcbiAgIGV4dGVybmFsIGluIHRoZSBtbGkuICopXG5sZXQgXyA9IGhhc2hcblxuaW5jbHVkZSBIYXNoXG5cbigqIGZvciBpbnRlcmFjdGl2ZSB0b3AtbGV2ZWxzIC0tIG1vZHVsZXMgZGVyaXZpbmcgZnJvbSBTdHJpbmcgc2hvdWxkIGhhdmUgU3RyaW5nJ3MgcHJldHR5XG4gICBwcmludGVyLiAqKVxubGV0IHBwIHBwZiBzdHJpbmcgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbm1vZHVsZSBFc2NhcGluZyA9IHN0cnVjdFxuICAoKiBJZiB0aGlzIGlzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0byB1cGRhdGUgW2VzY2FwZV0sIHdoaWNoIGF0dGVtcHRzIHRvIGVuc3VyZSBhbGwgdGhlXG4gICAgIGludmFyaWFudHMgY2hlY2tlZCBoZXJlLiAgKilcbiAgbGV0IGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgZnVuYyA9XG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgaWYgTGlzdC5Bc3NvYy5tZW0gZXNjYXBld29ydGh5X21hcCB+ZXF1YWw6Q2hhci5lcXVhbCBlc2NhcGVfY2hhclxuICAgICAgdGhlbiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICBlbHNlIChlc2NhcGVfY2hhciwgZXNjYXBlX2NoYXIpIDo6IGVzY2FwZXdvcnRoeV9tYXBcbiAgICBpblxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgKC0xKSBpblxuICAgIGxldCB2YWxzID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2IGZhbHNlIGluXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gT2sgYXJyXG4gICAgICB8IChjX2Zyb20sIGNfdG8pIDo6IGwgLT5cbiAgICAgICAgbGV0IGssIHYgPVxuICAgICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICAgIHwgYEVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX2Zyb20sIGNfdG9cbiAgICAgICAgICB8IGBVbmVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX3RvLCBjX2Zyb21cbiAgICAgICAgaW5cbiAgICAgICAgaWYgYXJyLihrKSA8PiAtMSB8fCB2YWxzLihDaGFyLnRvX2ludCB2KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgICAgXCJlc2NhcGV3b3J0aHlfbWFwIG5vdCBvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgIFsgXCJjX2Zyb21cIiwgc2V4cF9vZl9jaGFyIGNfZnJvbVxuICAgICAgICAgICAgICAgOyBcImNfdG9cIiwgc2V4cF9vZl9jaGFyIGNfdG9cbiAgICAgICAgICAgICAgIDsgKCBcImVzY2FwZXdvcnRoeV9tYXBcIlxuICAgICAgICAgICAgICAgICAsIHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2ZfY2hhciBzZXhwX29mX2NoYXIpIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgXSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYXJyLihrKSA8LSBDaGFyLnRvX2ludCB2O1xuICAgICAgICAgIHZhbHMuKENoYXIudG9faW50IHYpIDwtIHRydWU7XG4gICAgICAgICAgbG9vcCBsKVxuICAgIGluXG4gICAgbG9vcCBlc2NhcGV3b3J0aHlfbWFwXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBFc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAgKCogY2FsY3VsYXRlIGEgbGlzdCBvZiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpIGZpcnN0LCB0aGUgb3JkZXJcbiAgICAgICAgICAgICAgaXMgZnJvbSB0YWlsIHRvIGhlYWQgKilcbiAgICAgICAgICAgbGV0IHRvX2VzY2FwZV9sZW4gPSByZWYgMCBpblxuICAgICAgICAgICBsZXQgdG9fZXNjYXBlID1cbiAgICAgICAgICAgICBmb2xkaSBzcmMgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyBjIC0+XG4gICAgICAgICAgICAgICBtYXRjaCBlc2NhcGV3b3J0aHkuKENoYXIudG9faW50IGMpIHdpdGhcbiAgICAgICAgICAgICAgIHwgLTEgLT4gYWNjXG4gICAgICAgICAgICAgICB8IG4gLT5cbiAgICAgICAgICAgICAgICAgKCogKGluZGV4IG9mIGNoYXIgdG8gZXNjYXBlICogZXNjYXBlZCBjaGFyKSAqKVxuICAgICAgICAgICAgICAgICBpbmNyIHRvX2VzY2FwZV9sZW47XG4gICAgICAgICAgICAgICAgIChpLCBDaGFyLnVuc2FmZV9vZl9pbnQgbikgOjogYWNjKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBtYXRjaCB0b19lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAoKiBbdG9fZXNjYXBlXSBkaXZpZGUgW3NyY10gdG8gW0xpc3QubGVuZ3RoIHRvX2VzY2FwZSArIDFdIHBpZWNlcyBzZXBhcmF0ZWQgYnlcbiAgICAgICAgICAgICAgICB0aGUgY2hhcnMgdG8gZXNjYXBlLlxuXG4gICAgICAgICAgICAgICAgTGV0cyB0YWtlXG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIGVzY2FwZV9nZW5fZXhuXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGV3b3J0aHlfbWFwOlsoJ2EnLCAnQScpOyAoJ2InLCAnQicpOyAoJ2MnLCAnQycpXVxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBlX2NoYXI6J18nXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgYW5kIGFzc3VtZSB0aGUgc3RyaW5nIHRvIGVzY2FwZSBpc1xuXG4gICAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgICAgdGhlbiBbdG9fZXNjYXBlXSBpcyBbKDExLCAnQycpOyAoNywgJ0InKTsgKDMsICdBJyldLlxuXG4gICAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBbZHN0XSBvZiBsZW5ndGggW2xlbmd0aCBzcmMgKyAzXSB0byBzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICByZXN1bHQsIGNvcHkgcGllY2UgXCIzMzNcIiB0byBbZHN0XSBkaXJlY3RseSwgdGhlbiBjb3B5ICdfJyBhbmQgJ0MnIHRvIFtkc3RdO1xuICAgICAgICAgICAgICAgIHRoZW4gbW92ZSBvbiB0byBuZXh0OyBhZnRlciAzIGl0ZXJhdGlvbnMsIGNvcHkgcGllY2UgXCIwMDBcIiBhbmQgd2UgYXJlIGRvbmUuXG5cbiAgICAgICAgICAgICAgICBGaW5hbGx5IHRoZSByZXN1bHQgd2lsbCBiZVxuXG4gICAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIiAqKVxuICAgICAgICAgICAgIGxldCBzcmNfbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgICAgICAgICAgIGxldCBkc3RfbGVuID0gc3JjX2xlbiArICF0b19lc2NhcGVfbGVuIGluXG4gICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBkc3RfbGVuIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCAoaWR4LCBlc2NhcGVkX2NoYXIpIDo6IHRvX2VzY2FwZSAtPlxuICAgICAgICAgICAgICAgICAoKltpZHhdID0gdGhlIGNoYXIgdG8gZXNjYXBlKilcbiAgICAgICAgICAgICAgICAgKCogdGFrZSBmaXJzdCBpdGVyYXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICAgICAgICAgICAgICAgKCogY2FsY3VsYXRlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAxIGJlY2F1c2Ugd2UgZG9uJ3QgY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMSBpblxuICAgICAgICAgICAgICAgICAoKiBzZXQgdGhlIGRzdF9wb3MgdG8gY29weSB0byAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIsIHNldCBbc3JjX3Bvc10gdG8gW2lkeCArIDFdIHRvIHNraXAgJ2MnICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDEpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMiB0byBjb3B5ICdfJyBhbmQgJ0MnICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDIgaW5cbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCBkc3RfcG9zIGVzY2FwZV9jaGFyO1xuICAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IChkc3RfcG9zICsgMSkgZXNjYXBlZF9jaGFyO1xuICAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX2VzY2FwZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gZmlyc3QgKilcbiAgICAgICAgICAgICBsb29wIHNyY19sZW4gZHN0X2xlbiB0b19lc2NhcGU7XG4gICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuIChlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgZXNjYXBlIH5lc2NhcGV3b3J0aHkgfmVzY2FwZV9jaGFyID1cbiAgICAoKiBGb3IgW2VzY2FwZV9nZW5fZXhuXSwgd2UgZG9uJ3Qga25vdyBob3cgdG8gZml4IGludmFsaWQgZXNjYXBld29ydGh5X21hcCBzbyB3ZSBoYXZlXG4gICAgICAgdG8gcmFpc2UgZXhjZXB0aW9uOyBidXQgaW4gdGhpcyBjYXNlLCB3ZSBrbm93IGhvdyB0byBmaXggZHVwbGljYXRlZCBlbGVtZW50cyBpblxuICAgICAgIGVzY2FwZXdvcnRoeSBsaXN0LCBzbyB3ZSBqdXN0IGZpeCBpdCBpbnN0ZWFkIG9mIHJhaXNpbmcgZXhjZXB0aW9uIHRvIG1ha2UgdGhpc1xuICAgICAgIGZ1bmN0aW9uIGVhc2llciB0byB1c2UuICAqKVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGVzY2FwZXdvcnRoeVxuICAgICAgfD4gTGlzdC5kZWR1cF9hbmRfc29ydCB+Y29tcGFyZTpDaGFyLmNvbXBhcmVcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gYyAtPiBjLCBjKVxuICAgIGluXG4gICAgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBVbmVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICAoKiBDb250aW51ZSB0aGUgZXhhbXBsZSBpbiBbZXNjYXBlX2dlbl9leG5dLCBub3cgd2UgdW5lc2NhcGVcblxuICAgICAgICAgICAgICBcIjAwMF9BMTExX0IyMjJfQzMzM1wiXG5cbiAgICAgICAgICAgICAgYmFjayB0b1xuXG4gICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICBUaGVuIFt0b191bmVzY2FwZV0gaXMgWzE0OyA5OyA0XSwgd2hpY2ggaXMgaW5kZXhlcyBvZiAnXydzLlxuXG4gICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgc3RyaW5nIFtkc3RdIHRvIHN0b3JlIHRoZSByZXN1bHQsIGNvcHkgXCIzMzNcIiB0byBpdCwgdGhlbiBjb3B5XG4gICAgICAgICAgICAgICdjJywgdGhlbiBtb3ZlIG9uIHRvIG5leHQgaXRlcmF0aW9uLiBBZnRlciAzIGl0ZXJhdGlvbnMgY29weSBcIjAwMFwiIGFuZCB3ZSBhcmVcbiAgICAgICAgICAgICAgZG9uZS4gICopXG4gICAgICAgICAgICgqIGluZGV4ZXMgb2YgZXNjYXBlIGNoYXJzICopXG4gICAgICAgICAgIGxldCB0b191bmVzY2FwZSA9XG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzIGFjYyA9XG4gICAgICAgICAgICAgICBpZiBpID49IGxlbmd0aCBzcmNcbiAgICAgICAgICAgICAgIHRoZW4gYWNjXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHNyYyB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMgaW5cbiAgICAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBpbmcgLT4gaSA6OiBhY2NcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGFjYykpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBsb29wIDAgYExpdGVyYWwgW11cbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbWF0Y2ggdG9fdW5lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZScgLT5cbiAgICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5ndGggc3JjIC0gTGlzdC5sZW5ndGggdG9fdW5lc2NhcGUpIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAgKCogW2lkeF0gPSBpbmRleCBvZiBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICAgICgqIHRha2UgMXN0IGl0ZXJhdGlvbiBhcyBleGFtcGxlLCBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAyIHRvXG4gICAgICAgICAgICAgICAgICAgIHNraXAgJ19DJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAyIGluXG4gICAgICAgICAgICAgICAgICgqIHBvaW50IFtkc3RfcG9zXSB0byB0aGUgcG9zaXRpb24gdG8gY29weSBcIjMzM1wiIHRvICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAyKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDEgdG8gY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMSBpblxuICAgICAgICAgICAgICAgICBCeXRlcy5zZXRcbiAgICAgICAgICAgICAgICAgICBkc3RcbiAgICAgICAgICAgICAgICAgICBkc3RfcG9zXG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgc3JjLltpZHggKyAxXSkgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IC0xIC0+IHNyYy5baWR4ICsgMV1cbiAgICAgICAgICAgICAgICAgICAgfCBuIC0+IENoYXIudW5zYWZlX29mX2ludCBuKTtcbiAgICAgICAgICAgICAgICAgKCogdXBkYXRlIFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdICopXG4gICAgICAgICAgICAgICAgIGxvb3AgaWR4IGRzdF9wb3MgdG9fdW5lc2NhcGVcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIGlkeCA8IGxlbmd0aCBzcmMgLSAxXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gKilcbiAgICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICgqIGZvciBlc2NhcGVkIHN0cmluZyBlbmRpbmcgd2l0aCBhbiBlc2NhcGluZyBjaGFyIGxpa2UgXCIwMDBfXCIsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICB0aGUgbGFzdCBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjIC0gMSkgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlJztcbiAgICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIE9yX2Vycm9yLm9rX2V4biAodW5lc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgdW5lc2NhcGUgfmVzY2FwZV9jaGFyID0gdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcDpbXSB+ZXNjYXBlX2NoYXJcblxuICBsZXQgcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IHJlYyBsb29wIHAgY250ID1cbiAgICAgIGlmIHAgPCAwIHx8IENoYXIuKCA8PiApIHN0ci5bcF0gZXNjYXBlX2NoYXIgdGhlbiBjbnQgZWxzZSBsb29wIChwIC0gMSkgKGNudCArIDEpXG4gICAgaW5cbiAgICBsb29wIChwb3MgLSAxKSAwXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgb2RkID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBtb2QgMiA9IDEgaW5cbiAgICBtYXRjaCBvZGQsIENoYXIuZXF1YWwgc3RyLltwb3NdIGVzY2FwZV9jaGFyIHdpdGhcbiAgICB8IHRydWUsICh0cnVlIHwgZmFsc2UpIC0+IGBFc2NhcGVkXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiBgRXNjYXBpbmdcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBjaGVja19ib3VuZCBzdHIgcG9zIGZ1bmN0aW9uX25hbWUgPVxuICAgIGlmIHBvcyA+PSBsZW5ndGggc3RyIHx8IHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCIlczogb3V0IG9mIGJvdW5kc1wiIGZ1bmN0aW9uX25hbWUgKClcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGluZyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBpbmdcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGluZyAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBlZCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBlZFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwZWQgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwaW5nIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9saXRlcmFsIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9saXRlcmFsXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpbmRleF9mcm9tXCI7XG4gICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzID1cbiAgICAgIGlmIGkgPj0gcG9zXG4gICAgICAmJiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgJiYgQ2hhci5lcXVhbCBzdHIuW2ldIGNoYXJcbiAgICAgIHRoZW4gU29tZSBpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGkgPSBpICsgMSBpblxuICAgICAgICBpZiBpID49IGxlbmd0aCBzdHJcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgbG9vcCBpICh1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgc3RhdHVzKSlcbiAgICBpblxuICAgIGxvb3AgcG9zIChlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zKVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuICBsZXQgaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG5cbiAgbGV0IHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJyaW5kZXhfZnJvbVwiO1xuICAgICgqIGlmIHRoZSB0YXJnZXQgY2hhciBpcyB0aGUgc2FtZSBhcyBbZXNjYXBlX2NoYXJdLCB3ZSBoYXZlIG5vIHdheSB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICBlc2NhcGVfY2hhciBpcyBsaXRlcmFsLCBzbyBqdXN0IHJldHVybiBOb25lICopXG4gICAgaWYgQ2hhci5lcXVhbCBjaGFyIGVzY2FwZV9jaGFyXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgcG9zID1cbiAgICAgICAgaWYgcG9zIDwgMFxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGVzY2FwZV9jaGFycyA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgaW5cbiAgICAgICAgICBpZiBlc2NhcGVfY2hhcnMgbW9kIDIgPSAwICYmIENoYXIuZXF1YWwgc3RyLltwb3NdIGNoYXJcbiAgICAgICAgICB0aGVuIFNvbWUgcG9zXG4gICAgICAgICAgZWxzZSBsb29wIChwb3MgLSBlc2NhcGVfY2hhcnMgLSAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIHBvcylcbiAgOztcblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwicmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIGlmIGlzX2VtcHR5IHN0ciB0aGVuIE5vbmUgZWxzZSByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gIGxldCByaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgKCogW3NwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbl0gd29ya3Mgc2ltaWxhcmx5IHRvIFtTdHJpbmcuc3BsaXRfZ2VuXSwgd2l0aCBhblxuICAgICBhZGRpdGlvbmFsIHJlcXVpcmVtZW50OiBvbmx5IHNwbGl0IG9uIGxpdGVyYWwgY2hhcnMsIG5vdCBlc2NhcGluZyBvciBlc2NhcGVkICopXG4gIGxldCBzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b24gPVxuICAgIGxldCBpc19kZWxpbSA9XG4gICAgICBtYXRjaCBvbiB3aXRoXG4gICAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgICAgfCBgY2hhcl9saXN0IGwgLT4gZnVuIGMgLT4gY2hhcl9saXN0X21lbSBsIGNcbiAgICBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyBzdGF0dXMgbGFzdF9wb3MgcG9zID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBMaXN0LnJldiAoc3ViIHN0ciB+cG9zOmxhc3RfcG9zIH5sZW46KGxlbiAtIGxhc3RfcG9zKSA6OiBhY2MpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHN0YXR1cyBpblxuICAgICAgICBpZiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgICAmJiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoocG9zIC0gbGFzdF9wb3MpIGluXG4gICAgICAgICAgbG9vcCAoc3ViX3N0ciA6OiBhY2MpIHN0YXR1cyAocG9zICsgMSkgKHBvcyArIDEpKVxuICAgICAgICBlbHNlIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyAocG9zICsgMSkpXG4gICAgaW5cbiAgICBsb29wIFtdIGBMaXRlcmFsIDAgMFxuICA7O1xuXG4gIGxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxuICBsZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG4gIGxldCBzcGxpdF9hdCBzdHIgcG9zID1cbiAgICBzdWIgc3RyIH5wb3M6MCB+bGVuOnBvcywgc3ViIHN0ciB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggc3RyIC0gcG9zIC0gMSlcbiAgOztcblxuICBsZXQgbHNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAoaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCByc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChyaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCBsc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAoaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG4gIGxldCByc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAocmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuXG4gICgqIFtsYXN0X25vbl9kcm9wX2xpdGVyYWxdIGFuZCBbZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYXJlIGVpdGhlciBib3RoIFtOb25lXSBvciBib3RoXG4gICAgIFtTb21lXS4gSWYgW1NvbWVdLCB0aGVuIHRoZSBmb3JtZXIgaXMgPj0gdGhlIGxhdHRlci4gKilcbiAgbGV0IGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgcmZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKVxuICA7O1xuXG4gIGxldCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICBsZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENhbWwuTGF6eVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxhenlfdF9vZl9zZXhwXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9sYXp5X3RcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gbGF6eV90X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbWFwIHQgfmYgPSBsYXp5IChmIChmb3JjZSB0KSlcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIHQxIHQyID1cbiAgaWYgcGh5c19lcXVhbCB0MSB0MiB0aGVuIDAgZWxzZSBjb21wYXJlX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG47O1xuXG5sZXQgZXF1YWwgZXF1YWxfYSB0MSB0MiA9IGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiB0cnVlIGVsc2UgZXF1YWxfYSAoZm9yY2UgdDEpIChmb3JjZSB0MilcbmxldCBoYXNoX2ZvbGRfdCA9IEhhc2guQnVpbHRpbi5oYXNoX2ZvbGRfbGF6eV90XG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4geCA9IGZyb21fdmFsIHhcbiAgICBsZXQgYmluZCB0IH5mID0gbGF6eSAoZm9yY2UgKGYgKGZvcmNlIHQpKSlcbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIFRfdW5mb3JjaW5nID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgaWYgaXNfdmFsIHQgdGhlbiBzZXhwX29mX2EgKGZvcmNlIHQpIGVsc2Ugc2V4cF9vZl9zdHJpbmcgXCI8dW5mb3JjZWQgbGF6eT5cIlxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbnR5cGUgdCA9XG4gIHwgVzMyXG4gIHwgVzY0XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgIHwgVzMyIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlczMlwiXG4gICAgfCBXNjQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVzY0XCJcbiAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxuW0BAQGVuZF1cblxubGV0IG51bV9iaXRzID0gZnVuY3Rpb25cbiAgfCBXMzIgLT4gMzJcbiAgfCBXNjQgLT4gNjRcbjs7XG5cbmxldCB3b3JkX3NpemUgPVxuICBtYXRjaCBTeXMud29yZF9zaXplX2luX2JpdHMgd2l0aFxuICB8IDMyIC0+IFczMlxuICB8IDY0IC0+IFc2NFxuICB8IF8gLT4gZmFpbHdpdGggXCJ1bmtub3duIHdvcmQgc2l6ZVwiXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbmxldCByID0gcmVmIFsgXCJCYXNlLlNleHAucHBfaHVtXCIgXVxubGV0IGFsbCAoKSA9ICFyXG5sZXQgcmVnaXN0ZXIgcCA9IHIgOj0gcCA6OiAhclxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBwcCA6IEZvcm1hdHRlci50IC0+IHQgLT4gdW5pdFxuZW5kXG5cbm1vZHVsZSBSZWdpc3Rlcl9wcCAoTSA6IHNpZ1xuICAgIGluY2x1ZGUgU1xuXG4gICAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIGxldCAoKSA9IHJlZ2lzdGVyIChNLm1vZHVsZV9uYW1lIF4gXCIucHBcIilcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXIgKE0gOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICBlbmQpID1cbiAgUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgbGV0IHBwIGZvcm1hdHRlciB0ID0gQ2FtbC5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIGZvcm1hdHRlciAoTS50b19zdHJpbmcgdClcbiAgZW5kKVxuIiwiKCogYmVsb25ncyBpbiBDb21tb24sIGJ1dCBtb3ZlZCBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSAnYSByZXR1cm4gPSB7IHJldHVybiA6ICdiLiAnYSAtPiAnYiB9IFtAQHVuYm94ZWRdXG5cbmxldCB3aXRoX3JldHVybiAodHlwZSBhKSBmID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgKCogUmFpc2VkIHRvIGluZGljYXRlIH5yZXR1cm4gd2FzIGNhbGxlZC4gIExvY2FsIHNvIHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyB0aWVkIHRvIGFcbiAgICAgICBwYXJ0aWN1bGFyIGNhbGwgb2YgW3dpdGhfcmV0dXJuXS4gKilcbiAgICBleGNlcHRpb24gUmV0dXJuIG9mIGFcbiAgZW5kXG4gIGluXG4gIGxldCBpc19hbGl2ZSA9IHJlZiB0cnVlIGluXG4gIGxldCByZXR1cm4gYSA9XG4gICAgaWYgbm90ICFpc19hbGl2ZVxuICAgIHRoZW4gZmFpbHdpdGggXCJ1c2Ugb2YgW3JldHVybl0gZnJvbSBhIFt3aXRoX3JldHVybl0gdGhhdCBhbHJlYWR5IHJldHVybmVkXCI7XG4gICAgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIChNLlJldHVybiBhKVxuICBpblxuICB0cnlcbiAgICBsZXQgYSA9IGYgeyByZXR1cm4gfSBpblxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIGFcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIChtYXRjaCBleG4gd2l0aFxuICAgICB8IE0uUmV0dXJuIGEgLT4gYVxuICAgICB8IF8gLT4gcmFpc2UgZXhuKVxuOztcblxubGV0IHdpdGhfcmV0dXJuX29wdGlvbiBmID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByZXR1cm4gLT5cbiAgICBmIHsgcmV0dXJuID0gKGZ1biBhIC0+IHJldHVybi5yZXR1cm4gKFNvbWUgYSkpIH07XG4gICAgTm9uZSlcbjs7XG5cbmxldCBwcmVwZW5kIHsgcmV0dXJuIH0gfmYgPSB7IHJldHVybiA9IChmdW4geCAtPiByZXR1cm4gKGYgeCkpIH1cbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBIYXNoX3NldF9pbnRmXG5cbmxldCBoYXNoYWJsZV9zID0gSGFzaHRibC5oYXNoYWJsZV9zXG5sZXQgaGFzaGFibGUgPSBIYXNodGJsLlByaXZhdGUuaGFzaGFibGVcbmxldCBwb2x5X2hhc2hhYmxlID0gSGFzaHRibC5Qb2x5Lmhhc2hhYmxlXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICdhIHQgPSAoJ2EsIHVuaXQpIEhhc2h0YmwudFxudHlwZSAnYSBoYXNoX3NldCA9ICdhIHRcbnR5cGUgJ2EgZWx0ID0gJ2FcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICBsZXQgY2xlYXIgPSBIYXNodGJsLmNsZWFyXG4gIGxldCBsZW5ndGggPSBIYXNodGJsLmxlbmd0aFxuICBsZXQgbWVtID0gSGFzaHRibC5tZW1cbiAgbGV0IGlzX2VtcHR5IHQgPSBIYXNodGJsLmlzX2VtcHR5IHRcblxuICBsZXQgZmluZF9tYXAgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBIYXNodGJsLml0ZXJfa2V5cyB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgIG1hdGNoIGYgZWx0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBfIGFzIG8gLT4gci5yZXR1cm4gbyk7XG4gICAgICBOb25lKVxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kX21hcCB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBTb21lIGEgZWxzZSBOb25lKVxuICBsZXQgYWRkIHQgayA9IEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpXG5cbiAgbGV0IHN0cmljdF9hZGQgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiBPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJlbGVtZW50IGFscmVhZHkgZXhpc3RzXCJcbiAgICBlbHNlIChcbiAgICAgIEhhc2h0Ymwuc2V0IHQgfmtleTprIH5kYXRhOigpO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICA7O1xuXG4gIGxldCBzdHJpY3RfYWRkX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9hZGQgdCBrKVxuICBsZXQgcmVtb3ZlID0gSGFzaHRibC5yZW1vdmVcblxuICBsZXQgc3RyaWN0X3JlbW92ZSB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZSB0IGs7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gICAgZWxzZSBPcl9lcnJvci5lcnJvciBcImVsZW1lbnQgbm90IGluIHNldFwiIGsgKEhhc2h0Ymwuc2V4cF9vZl9rZXkgdClcbiAgOztcblxuICBsZXQgc3RyaWN0X3JlbW92ZV9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfcmVtb3ZlIHQgaylcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEhhc2h0YmwuZm9sZCB0IH5pbml0IH5mOihmdW4gfmtleSB+ZGF0YTooKSBhY2MgLT4gZiBhY2Mga2V5KVxuICBsZXQgaXRlciB0IH5mID0gSGFzaHRibC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgdG9fbGlzdCA9IEhhc2h0Ymwua2V5c1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lIHQgPVxuICAgIHNleHBfb2ZfbGlzdCBzZXhwX29mX2UgKHRvX2xpc3QgdCB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KGhhc2hhYmxlIHQpLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGxldCBpbmRleCA9IHJlZiAobGVuIC0gMSkgaW5cbiAgICBmb2xkIHQgfmluaXQ6W3x8XSB+ZjooZnVuIGFjYyBrZXkgLT5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCBhY2MgPSAwXG4gICAgICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIGtleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGluZGV4IDo9ICFpbmRleCAtIDE7XG4gICAgICAgIGFjYy4oIWluZGV4KSA8LSBrZXk7XG4gICAgICAgIGFjYykpXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID0gSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KVxuICBsZXQgZm9yX2FsbCB0IH5mID0gbm90IChIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gbm90IChmIGtleSkpKVxuICBsZXQgZXF1YWwgdDEgdDIgPSBIYXNodGJsLmVxdWFsIChmdW4gKCkgKCkgLT4gdHJ1ZSkgdDEgdDJcbiAgbGV0IGNvcHkgdCA9IEhhc2h0YmwuY29weSB0XG4gIGxldCBmaWx0ZXIgdCB+ZiA9IEhhc2h0YmwuZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbiAgbGV0IHVuaW9uIHQxIHQyID0gSGFzaHRibC5tZXJnZSB0MSB0MiB+ZjooZnVuIH5rZXk6XyBfIC0+IFNvbWUgKCkpXG4gIGxldCBkaWZmIHQxIHQyID0gZmlsdGVyIHQxIH5mOihmdW4ga2V5IC0+IG5vdCAoSGFzaHRibC5tZW0gdDIga2V5KSlcblxuICBsZXQgaW50ZXIgdDEgdDIgPVxuICAgIGxldCBzbWFsbGVyLCBsYXJnZXIgPSBpZiBsZW5ndGggdDEgPiBsZW5ndGggdDIgdGhlbiB0MiwgdDEgZWxzZSB0MSwgdDIgaW5cbiAgICBIYXNodGJsLmZpbHRlcmkgc21hbGxlciB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gSGFzaHRibC5tZW0gbGFyZ2VyIGtleSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gICAgbGV0IHRvX3JlbW92ZSA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjIHggLT4gaWYgZiB4IHRoZW4gYWMgZWxzZSB4IDo6IGFjKSBpblxuICAgIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biB4IC0+IHJlbW92ZSB0IHgpXG4gIDs7XG5cbiAgbGV0IG9mX2hhc2h0Ymxfa2V5cyBoYXNodGJsID0gSGFzaHRibC5tYXAgaGFzaHRibCB+ZjppZ25vcmVcbiAgbGV0IHRvX2hhc2h0YmwgdCB+ZiA9IEhhc2h0YmwubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG1cblxubGV0IG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIGxcbiAgaW5cbiAgbGV0IHQgPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgbSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIGsgLT4gYWRkIHQgayk7XG4gIHRcbjs7XG5cbmxldCB0X29mX3NleHAgbSBlX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IFNleHAuQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJIYXNoX3NldC50X29mX3NleHAgcmVxdWlyZXMgYSBsaXN0XCIgc2V4cFxuICB8IFNleHAuTGlzdCBsaXN0IC0+XG4gICAgbGV0IHQgPSBjcmVhdGUgbSB+c2l6ZTooTGlzdC5sZW5ndGggbGlzdCkgaW5cbiAgICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHNleHAgLT5cbiAgICAgIGxldCBlID0gZV9vZl9zZXhwIHNleHAgaW5cbiAgICAgIG1hdGNoIHN0cmljdF9hZGQgdCBlIHdpdGhcbiAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgIHwgRXJyb3IgXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIGdvdCBhIGR1cGxpY2F0ZSBlbGVtZW50XCIgc2V4cCk7XG4gICAgdFxuOztcblxubW9kdWxlIENyZWF0b3JzIChFbHQgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICBlbmQpIDogc2lnXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEVsdC50KSAtPiBTZXhwLnQgLT4gJ2EgRWx0LnQgdFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgRWx0LnQgdFxuICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICB3aXRoIHR5cGUgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID1cbiAgICBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSkgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgZV9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGVfb2Zfc2V4cCBzZXhwXG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgaGFzaF9zZXRcbiAgdHlwZSAnYSBlbHQgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IHBvbHlfaGFzaGFibGVcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbmVuZFxuXG5tb2R1bGUgTSAoRWx0IDogVC5UKSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gRWx0LnQgdFxuZW5kXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IHRcbjs7XG5cbmxldCBtX190X29mX3NleHAgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCkgc2V4cCA9XG4gIHRfb2Zfc2V4cCAobW9kdWxlIEVsdCkgRWx0LnRfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gZWx0KSA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBCYXNpYyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBUaGUgZm9sbG93aW5nIGlkZW50aXRpZXMgb3VnaHQgdG8gaG9sZCAoZm9yIHNvbWUgdmFsdWUgb2YgPSk6XG5cbiAgICAgIC0gW3JldHVybiB4ID4+PSBmID0gZiB4XVxuICAgICAgLSBbdCA+Pj0gZnVuIHggLT4gcmV0dXJuIHggPSB0XVxuICAgICAgLSBbKHQgPj49IGYpID4+PSBnID0gdCA+Pj0gZnVuIHggLT4gKGYgeCA+Pj0gZyldXG5cbiAgICAgIE5vdGU6IFs+Pj1dIGlzIHRoZSBpbmZpeCBub3RhdGlvbiBmb3IgW2JpbmRdKSAqKVxuXG4gICgqKiBUaGUgW21hcF0gYXJndW1lbnQgdG8gW01vbmFkLk1ha2VdIHNheXMgaG93IHRvIGltcGxlbWVudCB0aGUgbW9uYWQncyBbbWFwXSBmdW5jdGlvbi5cbiAgICAgIFtgRGVmaW5lX3VzaW5nX2JpbmRdIG1lYW5zIHRvIGRlZmluZSBbbWFwIHQgfmYgPSBiaW5kIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSldLlxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuXG5cbiAgICAgIFNvbWUgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtNb25hZC5NYWtlXSBhcmUgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbbWFwXSwgc29cbiAgICAgIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbbWFwXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeSBhcyB3ZWxsLiAqKVxuICB2YWwgbWFwIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHQgXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4ID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBbdCA+Pj0gZl0gcmV0dXJucyBhIGNvbXB1dGF0aW9uIHRoYXQgc2VxdWVuY2VzIHRoZSBjb21wdXRhdGlvbnMgcmVwcmVzZW50ZWQgYnkgdHdvXG4gICAgICBtb25hZCBlbGVtZW50cy4gIFRoZSByZXN1bHRpbmcgY29tcHV0YXRpb24gZmlyc3QgZG9lcyBbdF0gdG8geWllbGQgYSB2YWx1ZSBbdl0sIGFuZFxuICAgICAgdGhlbiBydW5zIHRoZSBjb21wdXRhdGlvbiByZXR1cm5lZCBieSBbZiB2XS4gKilcbiAgdmFsICggPj49ICkgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFt0ID4+fCBmXSBpcyBbdCA+Pj0gKGZ1biBhIC0+IHJldHVybiAoZiBhKSldLiAqKVxuICB2YWwgKCA+PnwgKSA6ICdhIHQgLT4gKCdhIC0+ICdiKSAtPiAnYiB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4ID0gc2lnXG4gICgqKiBPcGVuaW5nIGEgbW9kdWxlIG9mIHRoaXMgdHlwZSBhbGxvd3Mgb25lIHRvIHVzZSB0aGUgWyViaW5kXSBhbmQgWyVtYXBdIHN5bnRheFxuICAgICAgZXh0ZW5zaW9ucyBkZWZpbmVkIGJ5IHBweF9sZXQsIGFuZCBicmluZ3MgW3JldHVybl0gaW50byBzY29wZS4gKilcblxuICB0eXBlICdhIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICgqKiBUaGVzZSBhcmUgY29udmVuaWVudCB0byBoYXZlIGluIHNjb3BlIHdoZW4gcHJvZ3JhbW1pbmcgd2l0aCBhIG1vbmFkOiAqKVxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAgIGluY2x1ZGUgSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gICAgICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICAgICAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgICAgIHZhbCBib3RoIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAqICdiKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheCA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIEluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICgqKiBbYmluZCB0IH5mXSA9IFt0ID4+PSBmXSAqKVxuICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gICgqKiBbcmV0dXJuIHZdIHJldHVybnMgdGhlICh0cml2aWFsKSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgdi4gKilcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAoKiogW21hcCB0IH5mXSBpcyB0ID4+fCBmLiAqKVxuICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuXG4gICgqKiBbam9pbiB0XSBpcyBbdCA+Pj0gKGZ1biB0JyAtPiB0JyldLiAqKVxuICB2YWwgam9pbiA6ICdhIHQgdCAtPiAnYSB0XG5cbiAgKCoqIFtpZ25vcmVfbSB0XSBpcyBbbWFwIHQgfmY6KGZ1biBfIC0+ICgpKV0uICBbaWdub3JlX21dIHVzZWQgdG8gYmUgY2FsbGVkIFtpZ25vcmVdLFxuICAgICAgYnV0IHdlIGRlY2lkZWQgdGhhdCB3YXMgYSBiYWQgbmFtZSwgYmVjYXVzZSBpdCBzaGFkb3dlZCB0aGUgd2lkZWx5IHVzZWRcbiAgICAgIFtDYW1sLmlnbm9yZV0uICBTb21lIG1vbmFkcyBzdGlsbCBkbyBbbGV0IGlnbm9yZSA9IGlnbm9yZV9tXSBmb3IgaGlzdG9yaWNhbFxuICAgICAgcmVhc29ucy4gKilcbiAgdmFsIGlnbm9yZV9tIDogJ2EgdCAtPiB1bml0IHRcblxuICB2YWwgYWxsIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuXG4gICgqKiBMaWtlIFthbGxdLCBidXQgZW5zdXJlcyB0aGF0IGV2ZXJ5IG1vbmFkaWMgdmFsdWUgaW4gdGhlIGxpc3QgcHJvZHVjZXMgYSB1bml0IHZhbHVlLFxuICAgICAgYWxsIG9mIHdoaWNoIGFyZSBkaXNjYXJkZWQgcmF0aGVyIHRoYW4gYmVpbmcgY29sbGVjdGVkIGludG8gYSBsaXN0LiAqKVxuICB2YWwgYWxsX3VuaXQgOiB1bml0IHQgbGlzdCAtPiB1bml0IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N5bnRheCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzIgPSBzaWdcbiAgKCoqIE11bHRpIHBhcmFtZXRlciBtb25hZC4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgZ2V0cyB1bmlmaWVkIGFjcm9zcyBhbGwgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAgVGhpcyBpcyB1c2VkIHRvIGVuY29kZSBtb25hZHMgd29ya2luZyBvbiBhIG11bHRpIHBhcmFtZXRlciBkYXRhIHN0cnVjdHVyZSBsaWtlXG4gICAgICAoWygnYSwnYikgcmVzdWx0XSkuICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIG1hcCA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0IF1cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MiA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0d28gYXJndW1lbnRzLiBUaGUgc2Vjb25kIGlzIGFsd2F5cyBqdXN0XG4gICAgICBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheDIgPSBzaWdcbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG5cbiAgICBpbmNsdWRlIEluZml4MiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2UpIHQgLT4gKCdiLCAnZSkgdCAtPiAoJ2EgKiAnYiwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIGluY2x1ZGUgSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcbiAgaW5jbHVkZSBTeW50YXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2UpIHQsICdlKSB0IC0+ICgnYSwgJ2UpIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdlKSB0IC0+ICh1bml0LCAnZSkgdFxuICB2YWwgYWxsIDogKCdhLCAnZSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnZSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2UpIHQgbGlzdCAtPiAodW5pdCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzMgPSBzaWdcbiAgKCoqIE11bHRpIHBhcmFtZXRlciBtb25hZC4gVGhlIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVycyBnZXQgdW5pZmllZCBhY3Jvc3MgYWxsIHRoZVxuICAgICAgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MyA9IHNpZ1xuICAoKiogU2FtZSBhcyBJbmZpeCwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZVxuICAgICAgYWx3YXlzIGp1c3QgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXgzID0gc2lnXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYiwgJ2QsICdlKSB0IC0+ICgnYSAqICdiLCAnZCwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZFxuICAgICAgYW5kIHRoaXJkIGFyZSBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG4gIGluY2x1ZGUgU3ludGF4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdkLCAnZSkgdCwgJ2QsICdlKSB0IC0+ICgnYSwgJ2QsICdlKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnZCwgJ2UpIHQgLT4gKHVuaXQsICdkLCAnZSkgdFxuICB2YWwgYWxsIDogKCdhLCAnZCwgJ2UpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZCwgJ2UpIHQgbGlzdCAtPiAodW5pdCwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWNfaW5kZXhlZCA9IHNpZ1xuICAoKiogSW5kZXhlZCBtb25hZCwgaW4gdGhlIHN0eWxlIG9mIEF0a2V5LiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGFyZSBjb21wb3NlZFxuICAgICAgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gVG8gc2VlIHRoaXMgbW9yZSBjbGVhcmx5LCB5b3UgY2FuIGxvb2sgYXQgdGhlIHR5cGUgb2YgYmluZDpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIF19XG5cbiAgICAgIGFuZCBpc29sYXRlIHNvbWUgb2YgdGhlIHR5cGUgdmFyaWFibGVzIHRvIHNlZSB0aGVpciBpbmRpdmlkdWFsIGJlaGF2aW9yczpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAnYSAgICAgICAgICAgICAtPiBmOignYSAtPiAgJ2IgICAgICAgICAgICkgLT4gICdiXG4gICAgICAgIHZhbCBiaW5kIDogICAgICAnaSwgJ2ogICAgLT4gICAgICAgICAgICAgICAnaiwgJ2sgICAgIC0+ICAgICAnaSwgJ2tcbiAgICAgIF19XG5cbiAgICAgIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIEF0a2V5LXN0eWxlIGluZGV4ZWQgbW9uYWRzLCBzZWU6XG5cbiAgICAgIHt2XG4gICAgICAgIFBhcmFtZXRlcmlzZWQgTm90aW9ucyBvZiBDb21wdXRhdGlvblxuICAgICAgICBSb2JlcnQgQXRrZXlcbiAgICAgICAgaHR0cDovL2JlbnRuaWIub3JnL3BhcmFtbm90aW9ucy1qZnAucGRmXG4gICAgICB2fSAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHQgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4X2luZGV4ZWQgPSBzaWdcbiAgKCoqIFNhbWUgYXMgeyFJbmZpeH0sIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZFxuICAgICAgdGhpcmQgYXJlIGNvbXBvc2VkIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXhfaW5kZXhlZCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcblxuICAgIGluY2x1ZGUgSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYiwgJ2osICdrKSB0IC0+ICgnYSAqICdiLCAnaSwgJ2spIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2luZGV4ZWQgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBpbmNsdWRlIFN5bnRheF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2osICdrKSB0LCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2spIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdpLCAnaikgdCAtPiAodW5pdCwgJ2ksICdqKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdpLCAnaSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnaSwgJ2kpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdpLCAnaSkgdCBsaXN0IC0+ICh1bml0LCAnaSwgJ2kpIHRcbmVuZFxuXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MzIChYIDogUzIpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZFxuXG5tb2R1bGUgU190b19TX2luZGV4ZWQgKFggOiBTKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFNfaW5kZXhlZF90b19TMiAoWCA6IFNfaW5kZXhlZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnQgPVxuc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNb25hZCA9IHNpZ1xuICAoKiogQSBtb25hZCBpcyBhbiBhYnN0cmFjdGlvbiBvZiB0aGUgY29uY2VwdCBvZiBzZXF1ZW5jaW5nIG9mIGNvbXB1dGF0aW9ucy4gIEEgdmFsdWUgb2ZcbiAgICAgIHR5cGUgWydhIG1vbmFkXSByZXByZXNlbnRzIGEgY29tcHV0YXRpb24gdGhhdCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBbJ2FdLiAqKVxuXG4gIG1vZHVsZSB0eXBlIEJhc2ljID0gQmFzaWNcbiAgbW9kdWxlIHR5cGUgQmFzaWMyID0gQmFzaWMyXG4gIG1vZHVsZSB0eXBlIEJhc2ljMyA9IEJhc2ljM1xuICBtb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gQmFzaWNfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBJbmZpeCA9IEluZml4XG4gIG1vZHVsZSB0eXBlIEluZml4MiA9IEluZml4MlxuICBtb2R1bGUgdHlwZSBJbmZpeDMgPSBJbmZpeDNcbiAgbW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IEluZml4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU3ludGF4ID0gU3ludGF4XG4gIG1vZHVsZSB0eXBlIFN5bnRheDIgPSBTeW50YXgyXG4gIG1vZHVsZSB0eXBlIFN5bnRheDMgPSBTeW50YXgzXG4gIG1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gU3ludGF4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheCA9IFNfd2l0aG91dF9zeW50YXhcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzIgPSBTMlxuICBtb2R1bGUgdHlwZSBTMyA9IFMzXG4gIG1vZHVsZSB0eXBlIFNfaW5kZXhlZCA9IFNfaW5kZXhlZFxuXG4gIG1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnRcbiAgbW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudFxuICBtb2R1bGUgTWFrZTMgKFggOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnRcblxuICBtb2R1bGUgTWFrZV9pbmRleGVkIChYIDogQmFzaWNfaW5kZXhlZCkgOlxuICAgIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gICgqKiBEZWZpbmUgYSBtb25hZCB0aHJvdWdoIGFuIGlzb21vcnBoaXNtIHdpdGggYW4gZXhpc3RpbmcgbW9uYWQuIEZvciBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHQgPSB7IHZhbHVlIDogJ2EgfVxuXG4gICAgICAgIGluY2x1ZGUgTW9uYWQuT2ZfbW9uYWQgKE1vbmFkLklkZW50KSAoc3RydWN0XG4gICAgICAgICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICAgICAgICBsZXQgdG9fbW9uYWQgeyB2YWx1ZSB9ID0gdmFsdWVcbiAgICAgICAgICAgIGxldCBvZl9tb25hZCB2YWx1ZSA9IHsgdmFsdWUgfVxuICAgICAgICAgIGVuZClcbiAgICAgIF19ICopXG4gIG1vZHVsZSBPZl9tb25hZFxuICAgICAgKE1vbmFkIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICdhIE1vbmFkLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDJcbiAgICAgIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWQzXG4gICAgICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZF9pbmRleGVkXG4gICAgICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udFxuXG4gIG1vZHVsZSBJZGVudCA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTW9uYWRfaW50ZlxuXG5tb2R1bGUgdHlwZSBCYXNpY19nZW5lcmFsID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kXG4gICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kXG4gICAgICB8IGBDdXN0b20gb2YgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuZXJhbCAoTSA6IEJhc2ljX2dlbmVyYWwpID0gc3RydWN0XG4gIGxldCBiaW5kID0gTS5iaW5kXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuICBsZXQgbWFwX3ZpYV9iaW5kIG1hIH5mID0gTS5iaW5kIG1hIH5mOihmdW4gYSAtPiBNLnJldHVybiAoZiBhKSlcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBNLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2JpbmQgLT4gbWFwX3ZpYV9iaW5kXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICAgIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoIGEgYiA9IGEgPj49IGZ1biBhIC0+IGIgPj58IGZ1biBiIC0+IGEsIGJcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBsZXQgam9pbiB0ID0gdCA+Pj0gZnVuIHQnIC0+IHQnXG4gIGxldCBpZ25vcmVfbSB0ID0gbWFwIHQgfmY6KGZ1biBfIC0+ICgpKVxuXG4gIGxldCBhbGwgPVxuICAgIGxldCByZWMgbG9vcCB2cyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgdnMpXG4gICAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuIHYgLT4gbG9vcCAodiA6OiB2cykgdHNcbiAgICBpblxuICAgIGZ1biB0cyAtPiBsb29wIFtdIHRzXG4gIDs7XG5cbiAgbGV0IHJlYyBhbGxfdW5pdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuICgpIC0+IGFsbF91bml0IHRzXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaW5kZXhlZCAoTSA6IEJhc2ljX2luZGV4ZWQpIDpcbiAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTMgKE0gOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBNLnQgPVxuICBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMiAoTSA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZCkgdCA6PSAoJ2EsICdkKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UgKE0gOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfZ2VuZXJhbCAoTW9uYWQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICAgIHZhbCBiaW5kXG4gICAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gICAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuICBlbmQpIChNIDogc2lnXG4gICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnRcbiAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgICAgZW5kKSA9XG4gIE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2osICdkLCAnZSkgTS50XG5cbiAgICBsZXQgcmV0dXJuIGEgPSBNLm9mX21vbmFkIChNb25hZC5yZXR1cm4gYSlcbiAgICBsZXQgYmluZCB0IH5mID0gTS5vZl9tb25hZCAoTW9uYWQuYmluZCAoTS50b19tb25hZCB0KSB+ZjooZnVuIGEgLT4gTS50b19tb25hZCAoZiBhKSkpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gKGZ1biB0IH5mIC0+IE0ub2ZfbW9uYWQgKE1vbmFkLm1hcCAoTS50b19tb25hZCB0KSB+ZikpXG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkM1xuICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkMlxuICAgIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRcbiAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogJ2EgdCAtPiAnYSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBJZGVudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgYmluZCBhIH5mID0gZiBhXG4gICAgICBsZXQgcmV0dXJuIGEgPSBhXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIGEgfmYgLT4gZiBhKVxuICAgIGVuZClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcblxuKCoqIFRoaXMgbW9kdWxlIHNlcnZlcyBtb3N0bHkgYXMgYSBwYXJ0aWFsIGNoZWNrIHRoYXQgW1MyXSBhbmQgW1NdIGFyZSBpbiBzeW5jLCBidXRcbiAgICBhY3R1YWxseSBjYWxsaW5nIGl0IGlzIG9jY2FzaW9uYWxseSB1c2VmdWwuICopXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TMiAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCkgdCA9ICgnYSwgJ2QsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2FwcGx5IC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBtYXAyIHRhIHRiIH5mID0gbWFwIH5mIHRhIDwqPiB0YlxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcCB+ZiB0YSA8Kj4gdGIgPCo+IHRjXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0ICggKj4gKSB1IHYgPSByZXR1cm4gKGZ1biAoKSB5IC0+IHkpIDwqPiB1IDwqPiB2XG4gIGxldCAoIDwqICkgdSB2ID0gcmV0dXJuIChmdW4geCAoKSAtPiB4KSA8Kj4gdSA8Kj4gdlxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoWCA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MykgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBpbmNsdWRlIFhcbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IEltcGxcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MikgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsICdkLCBfKSB0ID0gKCdhLCAnZCkgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4XG4gICAgKFggOiBGb3JfbGV0X3N5bnRheCkgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZClcbiAgICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgyXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG4oKiogVGhpcyBmdW5jdG9yIGNsb3NlbHkgcmVzZW1ibGVzIFtNYWtlM10sIGFuZCBpbmRlZWQgaXQgY291bGQgYmUgaW1wbGVtZW50ZWRcbiAgICBtdWNoIHNob3J0ZXIgaW4gdGVybXMgb2YgW01ha2UzXS4gSG93ZXZlciwgd2UgaW1wbGVtZW50IGl0IGJ5IGhhbmQgc28gdGhhdFxuICAgIHRoZSByZXN1bHRpbmcgZnVuY3Rpb25zIGFyZSBtb3JlIGVmZmljaWVudCwgZS5nLiB1c2luZyBbbWFwMl0gZGlyZWN0bHkgaW5zdGVhZCBvZlxuICAgIGRlZmluaW5nIFthcHBseV0gaW4gdGVybXMgb2YgaXQgYW5kIHRoZW4gW21hcDJdIGluIHRlcm1zIG9mIHRoYXQuIEZvciBtb3N0XG4gICAgYXBwbGljYXRpdmVzIHRoaXMgZG9lcyBub3QgbWF0dGVyLCBidXQgZm9yIHNvbWUgKHN1Y2ggYXMgQm9uc2FpLlZhbHVlLnQpLCBpdCBoYXMgYVxuICAgIGxhcmdlciBpbXBhY3QuICopXG5tb2R1bGUgTWFrZTNfdXNpbmdfbWFwMiAoWCA6IEJhc2ljM191c2luZ19tYXAyKSA6XG4gIFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCBhcHBseSB0ZiB0YSA9IG1hcDIgdGYgdGEgfmY6KGZ1biBmIGEgLT4gZiBhKVxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX21hcDIgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwMiAobWFwMiB0YSB0YiB+ZikgdGMgfmY6KGZ1biBmYWIgYyAtPiBmYWIgYylcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCAoICo+ICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biAoKSB5IC0+IHkpXG4gIGxldCAoIDwqICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biB4ICgpIC0+IHgpXG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTJfdXNpbmdfbWFwMiAoWCA6IEJhc2ljMl91c2luZ19tYXAyKSA6XG4gIFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlX3VzaW5nX21hcDIgKFggOiBCYXNpY191c2luZ19tYXAyKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID1cbiAgTWFrZTJfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyIChNIDogTW9uYWQuUzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgTS50ID0gTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIE0udFxuXG4gICAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gICAgbGV0IGFwcGx5IG1mIG14ID0gTS5iaW5kIG1mIH5mOihmdW4gZiAtPiBNLm1hcCBteCB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBNLm1hcFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZCAoTSA6IE1vbmFkLlMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBPZl9tb25hZDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgQ29tcG9zZSAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50IEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCByZXR1cm4gYSA9IEcucmV0dXJuIChGLnJldHVybiBhKVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRy5hcHBseSAoRy5tYXAgfmY6Ri5hcHBseSB0ZikgdHhcbiAgICAgIGxldCBjdXN0b21fbWFwIHQgfmYgPSBHLm1hcCB+ZjooRi5tYXAgfmYpIHRcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIFBhaXIgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRi5yZXR1cm4gYSwgRy5yZXR1cm4gYVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRi5hcHBseSAoZnN0IHRmKSAoZnN0IHR4KSwgRy5hcHBseSAoc25kIHRmKSAoc25kIHR4KVxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEYubWFwIH5mIChmc3QgdCksIEcubWFwIH5mIChzbmQgdClcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcbiIsIigqIFtCeXRlczBdIGRlZmluZXMgc3RyaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW0NhbWwuQnl0ZXNdLiBbQnl0ZXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3NcbiAgIHRoZSBwYXJ0IG9mIFtDYW1sLkJ5dGVzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlclxuICAgdGhhbiBieXRlczAubWwgc2hvdWxkIHVzZSBbQ2FtbC5CeXRlc10uIFtCeXRlczBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmRcbiAgIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQnl0ZXNdIGluXG4gICBidWlsZCBvcmRlciBzaG91bGQgZG86XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBCeXRlcyAgPSBCeXRlczBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgQnl0ZXMgPSBCeXRlczBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHNcbiAgIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQnl0ZXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5tb2R1bGUgUHJpbWl0aXZlcyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuXG4gICgqIFt1bnNhZmVfYmxpdF9zdHJpbmddIGlzIG5vdCBleHBvcnRlZCBpbiB0aGUgW3N0ZGxpYl0gc28gd2UgZXhwb3J0IGl0IGhlcmUgKilcbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgOiAgc3JjOnN0cmluZ1xuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OmJ5dGVzXG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NHVcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5lbmRcblxuaW5jbHVkZSBQcmltaXRpdmVzXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgYmxpdCA9IENhbWwuQnl0ZXMuYmxpdFxubGV0IGJsaXRfc3RyaW5nID0gQ2FtbC5CeXRlcy5ibGl0X3N0cmluZ1xubGV0IGNvbXBhcmUgPSBDYW1sLkJ5dGVzLmNvbXBhcmVcbmxldCBjb3B5ID0gQ2FtbC5CeXRlcy5jb3B5XG5sZXQgY3JlYXRlID0gQ2FtbC5CeXRlcy5jcmVhdGVcbmxldCBmaWxsID0gQ2FtbC5CeXRlcy5maWxsXG5sZXQgbWFrZSA9IENhbWwuQnl0ZXMubWFrZVxubGV0IG1hcCA9IENhbWwuQnl0ZXMubWFwXG5sZXQgbWFwaSA9IENhbWwuQnl0ZXMubWFwaVxubGV0IHN1YiA9IENhbWwuQnl0ZXMuc3ViXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLkJ5dGVzLnVuc2FmZV9ibGl0XG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5CeXRlcy50b19zdHJpbmdcbmxldCBvZl9zdHJpbmcgPSBDYW1sLkJ5dGVzLm9mX3N0cmluZ1xubGV0IHVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cyA9IENhbWwuQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5sZXQgdW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211dGF0aW9uID0gQ2FtbC5CeXRlcy51bnNhZmVfb2Zfc3RyaW5nXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICd3aXRuZXNzKSB0ID1cbiAgeyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gIH1cblxudHlwZSAoJ2EsICdiKSBjb21wYXJhdG9yID0gKCdhLCAnYikgdFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhIHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfZmMgPSBzaWdcbiAgdHlwZSBjb21wYXJhYmxlX3RcblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gY29tcGFyYWJsZV90XG5lbmRcblxubW9kdWxlIE1vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnYilcbmVuZFxuXG5sZXQgbWFrZSAodHlwZSB0KSB+Y29tcGFyZSB+c2V4cF9vZl90ID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIGNvbXBhcmFibGVfdCA9IHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZCA6IFNfZmNcbiAgICB3aXRoIHR5cGUgY29tcGFyYWJsZV90ID0gdClcbjs7XG5cbm1vZHVsZSBTX3RvX1MxIChTIDogUykgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gUy50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gUy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBvcGVuIFNcblxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgTWFrZSAoTSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZTEgKE0gOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAnYSB0IC0+IFNleHAudFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBpbmNsdWRlIE1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCJfXCJcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZCA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSBjb21wYXJhdG9yIC0+ICgnYSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkIChNIDogc2lnXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZDIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcF9hKSBjb21wYXJhdG9yXG4gICAgLT4gKCdiLCAnY21wX2IpIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCAnYikgdCwgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZDIgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSBiID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgIDsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgYi5zZXhwX29mX3RcbiAgICB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZF9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXApIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCBfKSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkX3BoYW50b20gKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogKCdhIC0+ICdhIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2EsIF8pIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcF9hIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuIiwiKCogVGhlIHR5cGUgW3RdIHNob3VsZCBiZSBhYnN0cmFjdCB0byBtYWtlIHRoZSBmc2V0IGFuZCBzZXQgZnVuY3Rpb25zIHVuYXZhaWxhYmxlXG4gICBmb3IgcHJpdmF0ZSB0eXBlcyBhdCB0aGUgbGV2ZWwgb2YgdHlwZXMgKGFuZCBub3QgYnkgcHV0dGluZyBOb25lIGluIHRoZSBmaWVsZCkuXG4gICBVbmZvcnR1bmF0ZWx5LCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QgbWVhbnMgdGhhdCB3aGVuIGNyZWF0aW5nIGZpZWxkcyAodGhyb3VnaFxuICAgYSBbY3JlYXRlXSBmdW5jdGlvbikgdmFsdWUgcmVzdHJpY3Rpb24ga2lja3MgaW4uIFRoaXMgaXMgd29ya2VkIGFyb3VuZCBieSBpbnN0ZWFkXG4gICBub3QgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0LCBidXQgZm9yY2luZyBhbnlvbmUgYnJlYWtpbmcgdGhlIGFic3RyYWN0aW9uIHRvIHVzZVxuICAgdGhlIFtGb3JfZ2VuZXJhdGVkX2NvZGVdIG1vZHVsZSwgbWFraW5nIGl0IG9idmlvdXMgdG8gYW55IHJlYWRlciB0aGF0IHNvbWV0aGluZyB1Z2x5XG4gICBpcyBnb2luZyBvbi5cbiAgIHRfd2l0aF9wZXJtIChhbmQgZGVyaXZhdGl2ZXMpIGlzIHRoZSB0eXBlIHRoYXQgdXNlcnMgcmVhbGx5IHVzZS4gSXQgaXMgYSBjb25zdHJ1Y3RvclxuICAgYmVjYXVzZTpcbiAgIDEuIGl0IG1ha2VzIHR5cGUgZXJyb3JzIG1vcmUgcmVhZGFibGUgKGxlc3MgYWxpYXNpbmcpXG4gICAyLiB0aGUgdHlwZXIgaW4gb2NhbWwgNC4wMSBhbGxvd3MgdGhpczpcblxuICAge1tcbiAgICAgbW9kdWxlIEEgPSBzdHJ1Y3RcbiAgICAgICB0eXBlIHQgPSB7YSA6IGludH1cbiAgICAgZW5kXG4gICAgIHR5cGUgdCA9IEEudFxuICAgICBsZXQgZiAoeCA6IHQpID0geC5hXG4gICBdfVxuXG4gICAoYWx0aG91Z2ggd2l0aCBXYXJuaW5nIDQwOiBhIGlzIHVzZWQgb3V0IG9mIHNjb3BlKVxuICAgd2hpY2ggbWVhbnMgdGhhdCBpZiBbdF93aXRoX3Blcm1dIHdhcyByZWFsbHkgYW4gYWxpYXMgb24gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSxcbiAgIHBlb3BsZSBjb3VsZCBzYXkgW3Quc2V0dGVyXSBhbmQgYnJlYWsgdGhlIGFic3RyYWN0aW9uIHdpdGggbm8gaW5kaWNhdGlvbiB0aGF0XG4gICBzb21ldGhpbmcgdWdseSBpcyBnb2luZyBvbiBpbiB0aGUgc291cmNlIGNvZGUuXG4gICBUaGUgd2FybmluZyBpcyAoSSB0aGluaykgZm9yIHBlb3BsZSB3aG8gd2FudCB0byBtYWtlIHRoZWlyIGNvZGUgY29tcGF0aWJsZSB3aXRoXG4gICBwcmV2aW91cyB2ZXJzaW9ucyBvZiBvY2FtbCwgc28gd2UgbWF5IHZlcnkgd2VsbCB0dXJuIGl0IG9mZi5cblxuICAgVGhlIHR5cGUgdF93aXRoX3Blcm0gY291bGQgYWxzbyBoYXZlIGJlZW4gYSBbdW5pdCAtPiBGb3JfZ2VuZXJhdGVkX2NvZGUudF0gdG8gd29ya1xuICAgYXJvdW5kIHZhbHVlIHJlc3RyaWN0aW9uIGFuZCB0aGVuIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0gd291bGQgaGF2ZSBiZWVuIGEgcHJvcGVyXG4gICBhYnN0cmFjdCB0eXBlLCBidXQgaXQgbG9va3MgbGlrZSBpdCBjb3VsZCBpbXBhY3QgcGVyZm9ybWFuY2UgKGZvciBleGFtcGxlLCBhIGZvbGQgb24gYVxuICAgcmVjb3JkIHR5cGUgd2l0aCA0MCBmaWVsZHMgd291bGQgYWN0dWFsbHkgYWxsb2NhdGUgdGhlIDQwIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0ncyBhdFxuICAgZXZlcnkgc2luZ2xlIGZvbGQuKSAqKVxuXG5tb2R1bGUgRm9yX2dlbmVyYXRlZF9jb2RlID0gc3RydWN0XG4gIHR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHQgPVxuICAgIHsgZm9yY2VfdmFyaWFuY2UgOiAncGVybSAtPiB1bml0XG4gICAgOyAoKiBmb3JjZSBbdF0gdG8gYmUgY29udHJhdmFyaWFudCBpbiBbJ3Blcm1dLCBiZWNhdXNlIHBoYW50b20gdHlwZSB2YXJpYWJsZXMgb25cbiAgICAgICAgIGNvbmNyZXRlIHR5cGVzIGRvbid0IHdvcmsgdGhhdCB3ZWxsIG90aGVyd2lzZSAodXNpbmcgOj4gY2FuIHJlbW92ZSB0aGVtIGVhc2lseSkgKilcbiAgICAgIG5hbWUgOiBzdHJpbmdcbiAgICA7IHNldHRlciA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb25cbiAgICA7IGdldHRlciA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgOyBmc2V0IDogJ3JlY29yZCAtPiAnZmllbGQgLT4gJ3JlY29yZFxuICAgIH1cblxuICBsZXQgb3BhcXVlX2lkZW50aXR5ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHlcbmVuZFxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSA9XG4gIHwgRmllbGQgb2YgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIEZvcl9nZW5lcmF0ZWRfY29kZS50XG5bQEB1bmJveGVkXVxuXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHQgPSAoWyBgUmVhZCB8IGBTZXRfYW5kX2NyZWF0ZSBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG50eXBlICgncmVjb3JkLCAnZmllbGQpIHJlYWRvbmx5X3QgPSAoWyBgUmVhZCBdLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtXG5cbmxldCBuYW1lIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5uYW1lXG5sZXQgZ2V0IChGaWVsZCBmaWVsZCkgciA9IGZpZWxkLmdldHRlciByXG5sZXQgZnNldCAoRmllbGQgZmllbGQpIHIgdiA9IGZpZWxkLmZzZXQgciB2XG5sZXQgc2V0dGVyIChGaWVsZCBmaWVsZCkgPSBmaWVsZC5zZXR0ZXJcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdyZXN1bHQpIHVzZXIgPVxuICB7IGYgOiAnZmllbGQuICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybSAtPiAncmVzdWx0IH1cblxubGV0IG1hcCAoRmllbGQgZmllbGQpIHIgfmYgPSBmaWVsZC5mc2V0IHIgKGYgKGZpZWxkLmdldHRlciByKSlcblxubGV0IHVwZGF0ZXIgKEZpZWxkIGZpZWxkKSA9XG4gIG1hdGNoIGZpZWxkLnNldHRlciB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzZXR0ZXIgLT4gU29tZSAoZnVuIHIgfmYgLT4gc2V0dGVyIHIgKGYgKGZpZWxkLmdldHRlciByKSkpXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQ2FtbC5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID1cbiAgICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmcgYV9fMDAxXy5wb3NfZm5hbWUgYl9fMDAyXy5wb3NfZm5hbWUgd2l0aFxuICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19sbnVtIGJfXzAwMl8ucG9zX2xudW0gd2l0aFxuICAgICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludCBhX18wMDFfLnBvc19jbnVtIGJfXzAwMl8ucG9zX2NudW1cbiAgICAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIDogdCAtPiB0IC0+IGludClcbiAgOztcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgZnVuIGhzdiBhcmcgLT5cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IGFyZy5wb3NfZm5hbWVcbiAgICAgICAgICBpblxuICAgICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgICBpblxuICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2JvbFxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfY251bVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW4geyBwb3NfZm5hbWUgPSBwb3NfZm5hbWVfXzAwNF9cbiAgICAgICAgIDsgcG9zX2xudW0gPSBwb3NfbG51bV9fMDA2X1xuICAgICAgICAgOyBwb3NfYm9sID0gcG9zX2JvbF9fMDA4X1xuICAgICAgICAgOyBwb3NfY251bSA9IHBvc19jbnVtX18wMTBfXG4gICAgICAgICB9IC0+XG4gICAgICBsZXQgYm5kc19fMDAzXyA9IFtdIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfY251bVwiOyBhcmdfXzAxMV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfYm9sXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfbG51bVwiOyBhcmdfXzAwN18gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19mbmFtZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwM19cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIFBweF9oZXJlLmxpZnRfcG9zaXRpb25fYXNfc3RyaW5nLiAqKVxubGV0IG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbCA9XG4gIFN0cmluZy5jb25jYXRcbiAgICBbIHBvc19mbmFtZTsgXCI6XCI7IEludC50b19zdHJpbmcgcG9zX2xudW07IFwiOlwiOyBJbnQudG9fc3RyaW5nIChwb3NfY251bSAtIHBvc19ib2wpIF1cbjs7XG5cbmxldCB0b19zdHJpbmcgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCB9ID1cbiAgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpc3QwXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIChmIHggOiBfIEVpdGhlcjAudCkgd2l0aFxuICAgICAgIHwgRmlyc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmRcbiAgICAgICB8IFNlY29uZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuICBSZXN1bHQgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgUmVzdWx0XG4gIGVuZFxuICB3aXRoIG1vZHVsZSBFcnJvciA6PSBSZXN1bHQuRXJyb3IpXG5cbnR5cGUgJ2EgdCA9ICgnYSwgRXJyb3IudCkgUmVzdWx0LnRcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+IFJlc3VsdC5jb21wYXJlIF9jbXBfX2EgRXJyb3IuY29tcGFyZSBhX18wMDFfIGJfXzAwMl9cbjs7XG5cbmxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMDdfIGJfXzAwOF8gLT4gUmVzdWx0LmVxdWFsIF9jbXBfX2EgRXJyb3IuZXF1YWwgYV9fMDA3XyBiX18wMDhfXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgOlxuICAnYS5cbiAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAtPiAnYSB0XG4gIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgaHN2IGFyZyAtPiBSZXN1bHQuaGFzaF9mb2xkX3QgX2hhc2hfZm9sZF9hIEVycm9yLmhhc2hfZm9sZF90IGhzdiBhcmdcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAxM18geF9fMDE1XyAtPiBSZXN1bHQudF9vZl9zZXhwIF9vZl9hX18wMTNfIEVycm9yLnRfb2Zfc2V4cCB4X18wMTVfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMTZfIHhfXzAxN18gLT4gUmVzdWx0LnNleHBfb2ZfdCBfb2ZfYV9fMDE2XyBFcnJvci5zZXhwX29mX3QgeF9fMDE3X1xuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVzdWx0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIgRXJyb3IudF9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIGEgLT4gaW52YXJpYW50X2EgYVxuICB8IEVycm9yIGVycm9yIC0+IEVycm9yLmludmFyaWFudCBlcnJvclxuOztcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgbGV0IGFwcGx5IGYgeCA9XG4gICAgICBSZXN1bHQuY29tYmluZSBmIHggfm9rOihmdW4gZiB4IC0+IGYgeCkgfmVycjooZnVuIGUxIGUyIC0+IEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAoKiBmcm9tIEFwcGxpY2F0aXZlLk1ha2UgKilcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gIGVuZFxuZW5kXG5cbmxldCBvayA9IFJlc3VsdC5va1xubGV0IGlzX29rID0gUmVzdWx0LmlzX29rXG5sZXQgaXNfZXJyb3IgPSBSZXN1bHQuaXNfZXJyb3JcblxubGV0IHRyeV93aXRoID8oYmFja3RyYWNlID0gZmFsc2UpIGYgPVxuICB0cnkgT2sgKGYgKCkpIHdpdGhcbiAgfCBleG4gLT4gRXJyb3IgKEVycm9yLm9mX2V4biBleG4gP2JhY2t0cmFjZTooaWYgYmFja3RyYWNlIHRoZW4gU29tZSBgR2V0IGVsc2UgTm9uZSkpXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiA/YmFja3RyYWNlIGYgPSBqb2luICh0cnlfd2l0aCA/YmFja3RyYWNlIGYpXG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGVyciAtPiBFcnJvci5yYWlzZSBlcnJcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPSBFcnJvciAoRXJyb3Iub2ZfZXhuID9iYWNrdHJhY2UgZXhuKVxuXG5sZXQgb2ZfZXhuX3Jlc3VsdCA/YmFja3RyYWNlID0gZnVuY3Rpb25cbiAgfCBPayBfIGFzIHogLT4gelxuICB8IEVycm9yIGV4biAtPiBvZl9leG4gP2JhY2t0cmFjZSBleG5cbjs7XG5cbmxldCBlcnJvciA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBFcnJvciAoRXJyb3IuY3JlYXRlID9oZXJlID9zdHJpY3QgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCBlcnJvcl9zIHNleHAgPSBFcnJvciAoRXJyb3IuY3JlYXRlX3Mgc2V4cClcbmxldCBlcnJvcl9zdHJpbmcgbWVzc2FnZSA9IEVycm9yIChFcnJvci5vZl9zdHJpbmcgbWVzc2FnZSlcbmxldCBlcnJvcmYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGVycm9yX3N0cmluZyBmb3JtYXRcbmxldCB0YWcgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWcgfnRhZylcbmxldCB0YWdfcyB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZ19zIH50YWcpXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZ19zX2xhenkgfnRhZylcblxubGV0IHRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihmdW4gZSAtPiBFcnJvci50YWdfYXJnIGUgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCB1bmltcGxlbWVudGVkIHMgPSBlcnJvciBcInVuaW1wbGVtZW50ZWRcIiBzIHNleHBfb2Zfc3RyaW5nXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9IFJlc3VsdC5tYXBfZXJyb3IgKFJlc3VsdC5jb21iaW5lX2Vycm9ycyBsKSB+ZjpFcnJvci5vZl9saXN0XG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gUmVzdWx0Lm1hcCAoY29tYmluZV9lcnJvcnMgbCkgfmY6KGZ1biAoXyA6IHVuaXQgbGlzdCkgLT4gKCkpXG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0LnBhcnRpdGlvbl9tYXAgbCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gIG1hdGNoIG9rIHdpdGhcbiAgfCBbXSAtPiBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJzKVxuICB8IF8gLT4gT2sgb2tcbjs7XG5cbmxldCBmaW5kX29rIGwgPVxuICBtYXRjaCBMaXN0LmZpbmRfbWFwIGwgfmY6UmVzdWx0Lm9rIHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgfCBPayBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpXG47O1xuXG5sZXQgZmluZF9tYXBfb2sgbCB+ZiA9XG4gIFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIEVycm9yXG4gICAgICAoRXJyb3Iub2ZfbGlzdFxuICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgIG1hdGNoIGYgZWx0IHdpdGhcbiAgICAgICAgICAgIHwgT2sgXyBhcyB4IC0+IHJldHVybiB4XG4gICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSkpXG47O1xuXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IGl0ZXIgPSBSZXN1bHQuaXRlclxubGV0IGl0ZXJfZXJyb3IgPSBSZXN1bHQuaXRlcl9lcnJvclxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgQ29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPSAndCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cbnR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbnR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbmxldCBpdGVyIH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIC0+IGYgYSlcbmxldCBjb3VudCB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBuIGEgLT4gaWYgZiBhIHRoZW4gbiArIDEgZWxzZSBuKVxuXG5sZXQgc3VtICh0eXBlIGEpIH5mb2xkIChtb2R1bGUgTSA6IFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biBuIGEgLT4gTS4oICsgKSBuIChmIGEpKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBSZXN1bHQuT2tcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IFJlc3VsdC5PayB4IC0+IHhcbiAgICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IHJldHVybiBlKSkpXG47O1xuXG5sZXQgZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBmaW5pc2hcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IENvbnRpbnVlX29yX3N0b3AuQ29udGludWUgeCAtPiB4XG4gICAgICAgICB8IFN0b3AgeCAtPiByZXR1cm4geCkpKVxuOztcblxubGV0IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1pbiAtPiBpZiBjb21wYXJlIG1pbiBlbHQgPiAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpXG47O1xuXG5sZXQgbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWF4IC0+IGlmIGNvbXBhcmUgbWF4IGVsdCA8IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYylcbjs7XG5cbmxldCBsZW5ndGggfmZvbGQgYyA9IGZvbGQgYyB+aW5pdDowIH5mOihmdW4gYWNjIF8gLT4gYWNjICsgMSlcblxubGV0IGlzX2VtcHR5IH5pdGVyIGMgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biBfIC0+IHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IGV4aXN0cyB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBmb3JfYWxsIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIG5vdCAoZiB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IGZpbmRfbWFwIH5pdGVyIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIHQgfmY6KGZ1biB4IC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKVxuOztcblxubGV0IGZpbmQgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gKFNvbWUgeCkpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgdG9fbGlzdCB+Zm9sZCBjID0gTGlzdC5yZXYgKGZvbGQgYyB+aW5pdDpbXSB+ZjooZnVuIGFjYyB4IC0+IHggOjogYWNjKSlcblxubGV0IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgYyA9XG4gIGxldCBhcnJheSA9IHJlZiBbfHxdIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgaXRlciBjIH5mOihmdW4geCAtPlxuICAgIGlmICFpID0gMCB0aGVuIGFycmF5IDo9IEFycmF5LmNyZWF0ZSB+bGVuOihsZW5ndGggYykgeDtcbiAgICAhYXJyYXkuKCFpKSA8LSB4O1xuICAgIGluY3IgaSk7XG4gICFhcnJheVxuOztcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6IHNpZ1xuICBpbmNsdWRlIEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbmVuZCA9IHN0cnVjdFxuICBsZXQgZm9sZCA9IFQuZm9sZFxuXG4gIGxldCBpdGVyID1cbiAgICBtYXRjaCBULml0ZXIgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyIC0+IGl0ZXJcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+ZiAtPiBpdGVyIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgbGVuZ3RoID1cbiAgICBtYXRjaCBULmxlbmd0aCB3aXRoXG4gICAgfCBgQ3VzdG9tIGxlbmd0aCAtPiBsZW5ndGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCAtPiBsZW5ndGggfmZvbGQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gaXNfZW1wdHkgfml0ZXIgdFxuICBsZXQgc3VtIG0gdCA9IHN1bSB+Zm9sZCBtIHRcbiAgbGV0IGNvdW50IHQgfmYgPSBjb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IGV4aXN0cyB+aXRlciB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcCB+aXRlciB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kIH5pdGVyIHQgfmZcbiAgbGV0IHRvX2xpc3QgdCA9IHRvX2xpc3QgfmZvbGQgdFxuICBsZXQgdG9fYXJyYXkgdCA9IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgdFxuICBsZXQgbWluX2VsdCB0IH5jb21wYXJlID0gbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBmb2xkX3Jlc3VsdCB0IH5mb2xkIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IGZvbGRfdW50aWwgdCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoXG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIGVuZClcblxuICBsZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSlcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgJ2EgdCA9IFQudFxuICAgICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gICAgZW5kKVxuXG4gIGxldCBtZW0gdCBlbHQgPSBleGlzdHMgdCB+ZjooVC5FbHQuZXF1YWwgZWx0KVxuZW5kXG4iLCIoKiogUHJvdmlkZXMgZ2VuZXJpYyBzaWduYXR1cmVzIGZvciBjb250YWluZXIgZGF0YSBzdHJ1Y3R1cmVzLlxuXG4gICAgVGhlc2Ugc2lnbmF0dXJlcyBpbmNsdWRlIGZ1bmN0aW9ucyAoW2l0ZXJdLCBbZm9sZF0sIFtleGlzdHNdLCBbZm9yX2FsbF0sIC4uLikgdGhhdFxuICAgIHlvdSB3b3VsZCBleHBlY3QgdG8gZmluZCBpbiBhbnkgY29udGFpbmVyLiBVc2VkIGJ5IGluY2x1ZGluZyBbQ29udGFpbmVyLlMwXSBvclxuICAgIFtDb250YWluZXIuUzFdIGluIHRoZSBzaWduYXR1cmUgZm9yIGV2ZXJ5IGNvbnRhaW5lci1saWtlIGRhdGEgc3RydWN0dXJlIChbQXJyYXldLFxuICAgIFtMaXN0XSwgW1N0cmluZ10sIC4uLikgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBpbnRlcmZhY2UuICopXG5cbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gICgqKiBbQ29udGludWVfb3Jfc3RvcC50XSBpcyB1c2VkIGJ5IHRoZSBbZl0gYXJndW1lbnQgdG8gW2ZvbGRfdW50aWxdIGluIG9yZGVyIHRvXG4gICAgICBpbmRpY2F0ZSB3aGV0aGVyIGZvbGRpbmcgc2hvdWxkIGNvbnRpbnVlLCBvciBzdG9wIGVhcmx5LlxuXG4gICAgICBAY2Fub25pY2FsIEJhc2UuQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3BcbiAgKilcbiAgbW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgICAgfCBDb250aW51ZSBvZiAnYVxuICAgICAgfCBTdG9wIG9mICdiXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbigqKiBAY2Fub25pY2FsIEJhc2UuQ29udGFpbmVyLlN1bW1hYmxlICopXG5tb2R1bGUgdHlwZSBTdW1tYWJsZSA9IHNpZ1xuICB0eXBlIHRcblxuICAoKiogVGhlIHJlc3VsdCBvZiBzdW1taW5nIG5vIHZhbHVlcy4gKilcbiAgdmFsIHplcm8gOiB0XG5cbiAgKCoqIEFuIG9wZXJhdGlvbiB0aGF0IGNvbWJpbmVzIHR3byBbdF0ncyBhbmQgaGFuZGxlcyBbemVybyArIHhdIGJ5IGp1c3QgcmV0dXJuaW5nIFt4XSxcbiAgICAgIGFzIHdlbGwgYXMgaW4gdGhlIHN5bW1ldHJpYyBjYXNlLiAqKVxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lciAtIGEgY29udGFpbmVyIGZvciBhIHNwZWNpZmljIGVsZW1lbnQgdHlwZSwgZS5nLixcbiAgICBzdHJpbmcsIHdoaWNoIGlzIGEgY29udGFpbmVyIG9mIGNoYXJhY3RlcnMgKFt0eXBlIGVsdCA9IGNoYXJdKSBhbmQgbmV2ZXIgb2YgYW55dGhpbmdcbiAgICBlbHNlLiAqKVxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgZWx0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiB0IC0+IGVsdCAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IHQgLT4gYm9vbFxuXG4gICgqKiBbaXRlcl0gbXVzdCBhbGxvdyBleGNlcHRpb25zIHJhaXNlZCBpbiBbZl0gdG8gZXNjYXBlLCB0ZXJtaW5hdGluZyB0aGUgaXRlcmF0aW9uXG4gICAgICBjbGVhbmx5LiAgVGhlIHNhbWUgaG9sZHMgZm9yIGFsbCBmdW5jdGlvbnMgYmVsb3cgdGFraW5nIGFuIFtmXS4gKilcbiAgdmFsIGl0ZXIgOiB0IC0+IGY6KGVsdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6IHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBlbHQgb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogdCAtPiBmOihlbHQgLT4gJ2Egb3B0aW9uKSAtPiAnYSBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6IHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogdCAtPiBlbHQgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcC4gbWF4KSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkIFtjb21wYXJlXVxuICAgICAgZnVuY3Rpb24uIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdCBlbGVtZW50IGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlXG4gICAgICBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBbZm9sZF0gc28gaXQgaGFzIHRoZSBzYW1lXG4gICAgICBjb21wbGV4aXR5IGFzIFtmb2xkXS4gUmV0dXJucyBbTm9uZV0gaWZmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6IHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMF9waGFudG9tID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgZXF1YWxpdHkgb24gW2VsdF1zLiAqKVxuICB2YWwgbWVtIDogXyB0IC0+IGVsdCAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiBfIHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogXyB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBfIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGVcbiAgICAgIGVsZW1lbnRzIHdpbGwgYmUgc3VtbWVkIGlzIHVuc3BlY2lmaWVkLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IF8gdCAtPiBmOihlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBlbHQgb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogXyB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogXyB0IC0+IGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6IF8gdCAtPiBlbHQgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcCBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbiwgb3IgW05vbmVdIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiAgSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgIGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuICopXG4gIHZhbCBtaW5fZWx0IDogXyB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cbmVuZFxuXG4oKiogU2lnbmF0dXJlIGZvciBwb2x5bW9ycGhpYyBjb250YWluZXIsIGUuZy4sIFsnYSBsaXN0XSBvciBbJ2EgYXJyYXldLiAqKVxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0gICopXG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAnYSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW5pbXVtIChyZXNwIG1heGltdW0pIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWRcbiAgICAgIFtjb21wYXJlXSBmdW5jdGlvbiwgb3IgW05vbmVdIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3RcbiAgICAgIGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uXG4gICAgICB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eSBhcyBbZm9sZF0uICopXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b21faW52YXJpYW50ID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbSkgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgW2VxdWFsXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcCBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eVxuICAgICAgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMV9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCArJ3BoYW50b20pIHRcblxuICBpbmNsdWRlIFMxX3BoYW50b21faW52YXJpYW50IHdpdGggdHlwZSAoJ2EsICdwaGFudG9tKSB0IDo9ICgnYSwgJ3BoYW50b20pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICdhIHQgLT4gZjooJ2EgZWx0IC0+ICdzdW0pIC0+ICdzdW1cbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogJ2EgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAnYSB0IC0+ICdhIGVsdCBhcnJheVxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgR2VuZXJpY19waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbSkgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzdW1cbiAgICA6ICAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSBlbHQgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGFycmF5XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV9nZW5fYXJnID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFRoZSBbaXRlcl0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtpdGVyXSBmdW5jdGlvbi4gIFtgRGVmaW5lX3VzaW5nX2ZvbGRdIG1lYW5zIHRvIGRlZmluZSBbaXRlcl1cbiAgICAgIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgaXRlciB0IH5mID0gQ29udGFpbmVyLml0ZXIgfmZvbGQgdCB+ZlxuICAgICAgXX1cblxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuICBTZXZlcmFsIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbQ29udGFpbmVyLk1ha2VdIGFyZSBkZWZpbmVkIGluXG4gICAgICB0ZXJtcyBvZiBbaXRlcl0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbaXRlcl0gd2lsbCBpbXByb3ZlIHRoZWlyIGVmZmljaWVuY3lcbiAgICAgIGFzIHdlbGwuICopXG4gIHZhbCBpdGVyIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICdhIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXQgXVxuXG4gICgqKiBUaGUgW2xlbmd0aF0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtsZW5ndGhdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lXG4gICAgICBbbGVuZ3RoXSB2aWE6XG5cbiAgICAgIHtbXG4gICAgICAgIGxlbmd0aCB0IH5mID0gQ29udGFpbmVyLmxlbmd0aCB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtsZW5ndGhdLCBzbyBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW2xlbmd0aF0gd2lsbCBpbXByb3ZlIHRoZWlyXG4gICAgICBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBsZW5ndGggOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBpbnQgXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfYXJnID0gTWFrZV9nZW5fYXJnIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgTW9uYWQuSWRlbnQudFxuXG5tb2R1bGUgdHlwZSBNYWtlMF9hcmcgPSBzaWdcbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgZW5kXG5cbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICdhIHQgOj0gdCBhbmQgdHlwZSAnYSBlbHQgOj0gRWx0LnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDb250YWluZXIgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIEV4cG9ydFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMCA9IFMwXG4gIG1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBTMF9waGFudG9tXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgPSBTMV9waGFudG9tX2ludmFyaWFudFxuICBtb2R1bGUgdHlwZSBTMV9waGFudG9tID0gUzFfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBHZW5lcmljID0gR2VuZXJpY1xuICBtb2R1bGUgdHlwZSBHZW5lcmljX3BoYW50b20gPSBHZW5lcmljX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgU3VtbWFibGUgPSBTdW1tYWJsZVxuXG4gICgqKiBHZW5lcmljIGRlZmluaXRpb25zIG9mIGNvbnRhaW5lciBvcGVyYXRpb25zIGluIHRlcm1zIG9mIFtmb2xkXS5cblxuICAgICAgRS5nLjogW2l0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKV0uICopXG5cbiAgdHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPSAndCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cbiAgdHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB0eXBlICd0IGxlbmd0aCA9ICd0IC0+IGludFxuXG4gIHZhbCBpdGVyIDogZm9sZDooJ3QsICdhLCB1bml0KSBmb2xkIC0+ICgndCwgJ2EpIGl0ZXJcbiAgdmFsIGNvdW50IDogZm9sZDooJ3QsICdhLCBpbnQpIGZvbGQgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIG1pbl9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYSBvcHRpb24pIGZvbGRcbiAgICAtPiAndFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbGVuZ3RoIDogZm9sZDooJ3QsIF8sIGludCkgZm9sZCAtPiAndCAtPiBpbnRcbiAgdmFsIHRvX2xpc3QgOiBmb2xkOigndCwgJ2EsICdhIGxpc3QpIGZvbGQgLT4gJ3QgLT4gJ2EgbGlzdFxuXG4gIHZhbCBzdW1cbiAgICA6ICBmb2xkOigndCwgJ2EsICdzdW0pIGZvbGRcbiAgICAtPiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAndFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2IpIGZvbGRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gJ3RcbiAgICAtPiAoJ2IsICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYikgZm9sZFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICd0XG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2l0ZXJdIGFuZCBbbGVuZ3RoXS4gKilcbiAgdmFsIGlzX2VtcHR5IDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGJvb2xcblxuICB2YWwgZXhpc3RzIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZmluZCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19hcnJheSA6IGxlbmd0aDondCBsZW5ndGggLT4gaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFRoZSBpZGlvbSBmb3IgdXNpbmcgW0NvbnRhaW5lci5NYWtlXSBpcyB0byBiaW5kIHRoZSByZXN1bHRpbmcgbW9kdWxlIGFuZCB0b1xuICAgICAgZXhwbGljaXRseSBpbXBvcnQgZWFjaCBvZiB0aGUgZnVuY3Rpb25zIHRoYXQgb25lIHdhbnRzOlxuXG4gICAgICB7W1xuICAgICAgICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3QgLi4uIGVuZClcbiAgICAgICAgbGV0IGNvdW50ICAgID0gQy5jb3VudFxuICAgICAgICBsZXQgZXhpc3RzICAgPSBDLmV4aXN0c1xuICAgICAgICBsZXQgZmluZCAgICAgPSBDLmZpbmRcbiAgICAgICAgKCogLi4uICopXG4gICAgICBdfVxuXG4gICAgICBUaGlzIGlzIHByZWZlcmFibGUgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIGluY2x1ZGUgQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgXX1cblxuICAgICAgYmVjYXVzZSB0aGUgW2luY2x1ZGVdIG1ha2VzIGl0IHRvbyBlYXN5IHRvIHNoYWRvdyBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgIGNvbnRhaW5lciBmdW5jdGlvbnMgKFtsZW5ndGhdIGJlaW5nIGEgY29tbW9uIG9uZSkuXG5cbiAgICAgIFtDb250YWluZXIuTWFrZTBdIGlzIGxpa2UgW0NvbnRhaW5lci5NYWtlXSwgYnV0IGZvciBtb25vbW9ycGhpYyBjb250YWluZXJzIGxpa2VcbiAgICAgIFtzdHJpbmddLiAqKVxuICBtb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuXG4gIG1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgOiBTMCB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgZWx0IDo9IFQuRWx0LnRcblxuICBtb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDpcbiAgICBHZW5lcmljIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudCBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbmVuZFxuIiwiKCogU3BsaXQgb2ZmIHRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCBbT3JfZXJyb3JdLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubGV0IHNsb3dfY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgcG9zaXRpb246ICVkXCIgcG9zICgpO1xuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgbGVuZ3RoOiAlZFwiIGxlbiAoKTtcbiAgKCogV2UgdXNlIFtwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiB0b3RhbF9sZW5ndGhdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwicG9zICsgbGVuIHBhc3QgZW5kOiAlZCArICVkID4gJWRcIiBwb3MgbGVuIHRvdGFsX2xlbmd0aCAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gICgqIFRoaXMgaXMgYmV0dGVyIHRoYW4gW3Nsb3dfY2hlY2tfcG9zX2xlbl9leG5dIGZvciB0d28gcmVhc29uczpcblxuICAgICAtIG11Y2ggbGVzcyBpbmxpbmVkIGNvZGVcbiAgICAgLSBvbmx5IG9uZSBjb25kaXRpb25hbCBqdW1wXG5cbiAgICAgVGhlIHJlYXNvbiBpdCB3b3JrcyBpcyB0aGF0IGNoZWNraW5nIFs8IDBdIGlzIHRlc3RpbmcgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0LCBzb1xuICAgICBbYSA8IDAgfHwgYiA8IDBdIGlzIHRoZSBzYW1lIGFzIFthIGxvciBiIDwgMF0uXG5cbiAgICAgW3BvcyArIGxlbl0gY2FuIG92ZXJmbG93LCBzbyBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSBpcyBub3QgZXF1aXZhbGVudCB0b1xuICAgICBbdG90YWxfbGVuZ3RoIC0gbGVuIC0gcG9zIDwgMF0sIHdlIG5lZWQgdG8gdGVzdCBmb3IgW3BvcyArIGxlbl0gb3ZlcmZsb3cgYXNcbiAgICAgd2VsbC4gKilcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgaWYgcG9zIGxvciBsZW4gbG9yIHN0b3AgbG9yICh0b3RhbF9sZW5ndGggLSBzdG9wKSA8IDBcbiAgdGhlbiBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iLCJcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3QgOiBpbnQgYXJyYXlcbiAgICA7IG11dGFibGUgaWR4IDogaW50XG4gICAgfVxuXG4gIGxldCBvZl9zdGF0ZSA6IENhbWwuUmFuZG9tLlN0YXRlLnQgLT4gdCA9IENhbWwuT2JqLm1hZ2ljXG5lbmRcblxubGV0IGFzc2lnbiB0MSB0MiA9XG4gIGxldCB0MSA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDEpIGluXG4gIGxldCB0MiA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDIpIGluXG4gIEFycmF5LmJsaXQgfnNyYzp0Mi5zdCB+c3JjX3BvczowIH5kc3Q6dDEuc3QgfmRzdF9wb3M6MCB+bGVuOihBcnJheS5sZW5ndGggdDEuc3QpO1xuICB0MS5pZHggPC0gdDIuaWR4XG5cbmxldCBtYWtlX2RlZmF1bHQgZGVmYXVsdCA9IGRlZmF1bHRcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBnZXRfc3RhdGUgc3RhdGUgPSBzdGF0ZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIENoYXIgPSBDaGFyMFxuXG4oKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGRvZXMgbm90IGV4cG9zZVxuICAgW0NhbWwuUmFuZG9tLlN0YXRlLmRlZmF1bHRdLCB3ZSBoYXZlIHRvIGNvbnN0cnVjdCBvdXIgb3duLiAgV2UgdGhlbiBidWlsZCB0aGVcbiAgIFtDYW1sLlJhbmRvbS5pbnRdLCBbQ2FtbC5SYW5kb20uYm9vbF0gZnVuY3Rpb25zIGFuZCBmcmllbmRzIHVzaW5nIHRoYXQgZGVmYXVsdCBzdGF0ZSBpblxuICAgZXhhY3RseSB0aGUgc2FtZSB3YXkgYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkuXG5cbiAgIE9uZSBvdGhlciB0cmlja2luZXNzIGlzIHRoYXQgd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHVuZXhwb3NlZCBbQ2FtbC5SYW5kb20uU3RhdGUuYXNzaWduXVxuICAgZnVuY3Rpb24sIHdoaWNoIGFjY2Vzc2VzIHRoZSB1bmV4cG9zZWQgc3RhdGUgcmVwcmVzZW50YXRpb24uICBTbywgd2UgY29weSB0aGVcbiAgIFtTdGF0ZS5yZXByXSB0eXBlIGRlZmluaXRpb24gYW5kIFthc3NpZ25dIGZ1bmN0aW9uIHRvIGhlcmUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSxcbiAgIGFuZCB1c2UgW09iai5tYWdpY10gdG8gZ2V0IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gKilcblxuKCogUmVncmVzc2lvbiB0ZXN0cyBvdWdodCB0byBiZSBkZXRlcm1pbmlzdGljIGJlY2F1c2UgdGhhdCB3YXkgYW55b25lIHdobyBicmVha3MgdGhlIHRlc3RcbiAgIGtub3dzIHRoYXQgaXQncyB0aGVpciBjb2RlIHRoYXQgYnJva2UgdGhlIHRlc3QuICBJZiB0ZXN0cyBhcmUgbm9uZGV0ZXJtaW5pc3RpYywgYSB0ZXN0XG4gICBmYWlsdXJlIG1heSBpbnN0ZWFkIGhhcHBlbiBiZWNhdXNlIHRoZSB0ZXN0IHJ1bm5lciBnb3QgdW5sdWNreSBhbmQgdW5jb3ZlcmVkIGFuXG4gICBleGlzdGluZyBidWcgaW4gdGhlIGNvZGUgc3VwcG9zZWRseSBiZWluZyBcInByb3RlY3RlZFwiIGJ5IHRoZSB0ZXN0IGluIHF1ZXN0aW9uLiAqKVxubGV0IGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHMgPVxuICBpZiBhbV90ZXN0aW5nXG4gIHRoZW4gKFxuICAgIG1hdGNoIGFsbG93X2luX3Rlc3RzIHdpdGhcbiAgICB8IFNvbWUgdHJ1ZSAtPiAoKVxuICAgIHwgTm9uZSB8IFNvbWUgZmFsc2UgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nIFJhbmRvbSB3aXRoIGEgbm9uZGV0ZXJtaW5pc3RpYyBzZWVkIGlzIGZvcmJpZGRlbiBpbiBpbmxpbmUgdGVzdHNcIilcbjs7XG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkIDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubGV0IHJhbmRvbV9zZWVkID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gIHJhbmRvbV9zZWVkICgpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogV2UgYWxsb3cgbGF6aW5lc3Mgb25seSBmb3IgdGhlIGRlZmluaXRpb24gb2YgW2RlZmF1bHRdLCBiZWxvdywgd2hpY2ggbWF5IGxhemlseSBjYWxsXG4gICAgIFttYWtlX3NlbGZfaW5pdF0uIEZvciBhbGwgb3RoZXIgcHVycG9zZXMsIHdlIGNyZWF0ZSBhbmQgdXNlIFt0XSBlYWdlcmx5LiAqKVxuICB0eXBlIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS50IExhenkudFxuXG4gIGxldCBiaXRzIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHQpXG4gIGxldCBib29sIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5ib29sIChMYXp5LmZvcmNlIHQpXG4gIGxldCBpbnQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDMyIHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDMyIChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDY0IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDY0IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5uYXRpdmVpbnQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgbWFrZSBzZWVkID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUubWFrZSBzZWVkKVxuICBsZXQgY29weSB0ID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUuY29weSAoTGF6eS5mb3JjZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBMYXp5LmZyb21fdmFsIChDYW1sLlJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcbiAgOztcblxuICBsZXQgYXNzaWduID0gUmFuZG9tX3JlcHIuYXNzaWduXG5cbiAgbGV0IGZ1bGxfaW5pdCB0IHNlZWQgPSBhc3NpZ24gdCAobWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIENhbWwuUmFuZG9tLiBIb3dldmVyLCBiZWNhdXNlIFtnZXRfc3RhdGVdIHJldHVybnNcbiAgICAgICAgIGEgY29weSwgQmFzZS5SYW5kb20gYW5kIE9DYW1sLlJhbmRvbSBhcmUgbm90IHVzaW5nIHRoZSBzYW1lIHN0YXRlLiBJZiBhIHByb2dyYW1cbiAgICAgICAgIHVzZWQgYm90aCwgZWFjaCBvZiB0aGVtIHdvdWxkIGdvIHRocm91Z2ggdGhlIHNhbWUgc2VxdWVuY2Ugb2YgcmFuZG9tIGJpdHMuIFRvXG4gICAgICAgICBhdm9pZCB0aGF0LCB3ZSByZXNldCBPQ2FtbCdzIHJhbmRvbSBzdGF0ZSB0byBhIGRpZmZlcmVudCBzZWVkLCBnaXZpbmcgaXQgYVxuICAgICAgICAgZGlmZmVyZW50IHNlcXVlbmNlLiAqKVxuICAgICAgbGV0IHQgPSBDYW1sLlJhbmRvbS5nZXRfc3RhdGUgKCkgaW5cbiAgICAgIENhbWwuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgTGF6eS5mcm9tX3ZhbCB0KVxuICAgIGVsc2VcbiAgICAgIGxhenlcbiAgICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgICAgV2UgZm9yY2UgdGhlIHJhbmRvbSBpbml0aWFsaXphdGlvbiB0byBiZSBsYXp5IHNvIHRoYXQgd2UgZG8gbm90IHBheSBhbnkgY29zdFxuICAgICAgICAgICBmb3IgaXQgaW4gcHJvZ3JhbXMgdGhhdCBkbyBub3QgdXNlIHJhbmRvbW5lc3MuICopXG4gICAgICAgIChMYXp5LmZvcmNlIChtYWtlX3NlbGZfaW5pdCAoKSkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIENhbWwuSW50NjQudG9faW50IChpbnQ2NCB0IChDYW1sLkludDY0Lm9mX2ludCBib3VuZCkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl8zMmJpdHMgdCBib3VuZCA9XG4gICAgKCogTm90IGFsd2F5cyB0cnVlIHdpdGggdGhlIEphdmFTY3JpcHQgYmFja2VuZC4gKilcbiAgICBpZiBib3VuZCA8PSAweDNGRkZGRkZGICgqICgxIGxzbCAzMCkgLSAxICopXG4gICAgdGhlbiBpbnQgdCBib3VuZFxuICAgIGVsc2UgQ2FtbC5JbnQzMi50b19pbnQgKGludDMyIHQgKENhbWwuSW50MzIub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDY0ID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+XG4gICAgICBsb2d4b3JcbiAgICAgICAgKGJpdHMgc3RhdGUpXG4gICAgICAgIChsb2d4b3IgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKSAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgNjApKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDMyID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBDYW1sLkludDY0LnRvX2ludCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSlcbiAgbGV0IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyBzdGF0ZSA9IENhbWwuSW50MzIudG9faW50IChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKVxuXG4gIGxldCBmdWxsX3JhbmdlX2ludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5OYXRpdmVpbnQub2ZfaW50MzIgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgcmFpc2VfY3Jvc3NlZF9ib3VuZHMgbmFtZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCBzdHJpbmdfb2ZfYm91bmQgPVxuICAgIFByaW50Zi5mYWlsd2l0aGZcbiAgICAgIFwiUmFuZG9tLiVzOiBjcm9zc2VkIGJvdW5kcyBbJXMgPiAlc11cIlxuICAgICAgbmFtZVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCBsb3dlcl9ib3VuZClcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgdXBwZXJfYm91bmQpXG4gICAgICAoKVxuICBbQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuICA7O1xuXG4gIGxldCBpbnRfaW5jbCA9XG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnRcIiBsbyBoaSBJbnQudG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBoaSAtIGxvIGluXG4gICAgICBpZiBkaWZmID0gSW50Lm1heF92YWx1ZVxuICAgICAgdGhlbiBsbyArIChmdWxsX3JhbmdlX2ludCBzdGF0ZSBsYW5kIEludC5tYXhfdmFsdWUpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMFxuICAgICAgdGhlbiBsbyArIGludCBzdGF0ZSAoSW50LnN1Y2MgZGlmZilcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgaW50MzJfaW5jbCA9XG4gICAgbGV0IG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQzMlwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwbFxuICAgICAgdGhlbiBhZGQgbG8gKGludDMyIHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfaW5jbCA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuTmF0aXZlaW50IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJuYXRpdmVpbnRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBuXG4gICAgICB0aGVuIGFkZCBsbyAobmF0aXZlaW50IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQ2NF9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDY0IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludDY0XCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBMXG4gICAgICB0aGVuIGFkZCBsbyAoaW50NjQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgKCogUmV0dXJuIGEgdW5pZm9ybWx5IHJhbmRvbSBmbG9hdCBpbiBbMCwgMSkuICopXG4gIGxldCByZWMgcmF3ZmxvYXQgc3RhdGUgPVxuICAgIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBzY2FsZSA9IDB4MXAtMzAgaW5cbiAgICAoKiAyXi0zMCAqKVxuICAgIGxldCByMSA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByMiA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByZXN1bHQgPSAoKHIxICouIHNjYWxlKSArLiByMikgKi4gc2NhbGUgaW5cbiAgICAoKiBXaXRoIHZlcnkgc21hbGwgcHJvYmFiaWxpdHksIHJlc3VsdCBjYW4gcm91bmQgdXAgdG8gMS4wLCBzbyBpbiB0aGF0IGNhc2UsIHdlIGp1c3RcbiAgICAgICB0cnkgYWdhaW4uICopXG4gICAgaWYgcmVzdWx0IDwgMS4wIHRoZW4gcmVzdWx0IGVsc2UgcmF3ZmxvYXQgc3RhdGVcbiAgOztcblxuICBsZXQgZmxvYXQgc3RhdGUgaGkgPSByYXdmbG9hdCBzdGF0ZSAqLiBoaVxuXG4gIGxldCBmbG9hdF9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiZmxvYXRcIiBsbyBoaSBDYW1sLnN0cmluZ19vZl9mbG9hdDtcbiAgICBsbyArLiBmbG9hdCBzdGF0ZSAoaGkgLS4gbG8pXG4gIDs7XG5lbmRcblxubGV0IGRlZmF1bHQgPSBSYW5kb21fcmVwci5tYWtlX2RlZmF1bHQgU3RhdGUuZGVmYXVsdFxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGludCB4ID0gU3RhdGUuaW50IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbnR5cGUgJ2EgdCA9ICdhIGFycmF5IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX2FycmF5XG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gYXJyYXlfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfYXJyYXlcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gYXJyYXlfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbigqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYSBuZXcgaW4tcGxhY2UsIGNvbnN0YW50IGhlYXAgc29ydGluZyBhbGdvcml0aG0gdG8gcmVwbGFjZSB0aGVcbiAgIG9uZSB1c2VkIGJ5IHRoZSBzdGFuZGFyZCBsaWJyYXJpZXMuICBJdHMgb25seSBwdXJwb3NlIGlzIHRvIGJlIGZhc3RlciAoaG9wZWZ1bGx5XG4gICBzdHJpY3RseSBmYXN0ZXIpIHRoYW4gdGhlIGJhc2Ugc29ydCBhbmQgc3RhYmxlX3NvcnQuXG5cbiAgIEF0IGEgaGlnaCBsZXZlbCB0aGUgYWxnb3JpdGhtIGlzOlxuICAgLSBwaWNrIHR3byBwaXZvdCBwb2ludHMgYnk6XG4gICAtIHBpY2sgNSBhcmJpdHJhcnkgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgIC0gc29ydCB0aGVtIHdpdGhpbiB0aGUgYXJyYXlcbiAgIC0gdGFrZSB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIG1pZGRsZSBlbGVtZW50IG9mIHRoZSBzb3J0IGFzIHRoZSBwaXZvdHNcbiAgIC0gc29ydCB0aGUgYXJyYXkgd2l0aDpcbiAgIC0gYWxsIGVsZW1lbnRzIGxlc3MgdGhhbiBwaXZvdDEgdG8gdGhlIGxlZnQgKHJhbmdlIDEpXG4gICAtIGFsbCBlbGVtZW50cyA+PSBwaXZvdDEgYW5kIDw9IHBpdm90MiBpbiB0aGUgbWlkZGxlIChyYW5nZSAyKVxuICAgLSBhbGwgZWxlbWVudHMgPiBwaXZvdDIgdG8gdGhlIHJpZ2h0IChyYW5nZSAzKVxuICAgLSBpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgZXF1YWwsIHRoZW4gdGhlIG1pZGRsZSByYW5nZSBpcyBzb3J0ZWQsIHNvIGlnbm9yZSBpdFxuICAgLSByZWN1cnNlIGludG8gcmFuZ2UgMSwgMiAoaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIHVuZXF1YWwpLCBhbmQgM1xuICAgLSBkdXJpbmcgcmVjdXJzaW9uIHRoZXJlIGFyZSB0d28gaW5mbGVjdGlvbiBwb2ludHM6XG4gICAtIGlmIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHJhbmdlIGlzIHNtYWxsLCB1c2UgaW5zZXJ0aW9uIHNvcnQgdG8gc29ydCBpdFxuICAgLSBpZiB0aGUgc3RhY2sgZGVwdGggaXMgbGFyZ2UsIHNvcnQgdGhlIHJhbmdlIHdpdGggaGVhcC1zb3J0IHRvIGF2b2lkIG5eMiB3b3JzdC1jYXNlXG4gICAgIGJlaGF2aW9yXG5cbiAgIFNlZSB0aGUgZm9sbG93aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uOlxuICAgLSBcIkR1YWwtUGl2b3QgUXVpY2tzb3J0XCIgYnkgVmxhZGltaXIgWWFyb3NsYXZza2l5LlxuICAgICBBdmFpbGFibGUgYXRcbiAgICAgaHR0cDovL3d3dy5rcmljaGUuY29tLmFyL3Jvb3QvcHJvZ3JhbW1pbmcvc3BhY2VUaW1lQ29tcGxleGl0eS9EdWFsUGl2b3RRdWlja3NvcnQucGRmXG4gICAtIFwiUXVpY2tzb3J0IGlzIE9wdGltYWxcIiBieSBTZWRnZXdpY2sgYW5kIEJlbnRsZXkuXG4gICAgIFNsaWRlcyBhdCBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfnJzL3RhbGtzL1F1aWNrc29ydElzT3B0aW1hbC5wZGZcbiAgIC0gaHR0cDovL3d3dy5zb3J0aW5nLWFsZ29yaXRobXMuY29tL3F1aWNrLXNvcnQtMy13YXkgKilcblxubW9kdWxlIFNvcnQgPSBzdHJ1Y3RcbiAgKCogRm9yIHRoZSBzYWtlIG9mIHNwZWVkIHdlIGNvdWxkIHVzZSB1bnNhZmUgZ2V0L3NldCB0aHJvdWdob3V0LCBidXQgc3BlZWQgdGVzdHMgZG9uJ3RcbiAgICAgc2hvdyBhIHNpZ25pZmljYW50IGltcHJvdmVtZW50LiAqKVxuICBsZXQgZ2V0ID0gZ2V0XG4gIGxldCBzZXQgPSBzZXRcblxuICBsZXQgc3dhcCBhcnIgaSBqID1cbiAgICBsZXQgdG1wID0gZ2V0IGFyciBpIGluXG4gICAgc2V0IGFyciBpIChnZXQgYXJyIGopO1xuICAgIHNldCBhcnIgaiB0bXBcbiAgOztcblxuICBtb2R1bGUgdHlwZSBTb3J0ID0gc2lnXG4gICAgdmFsIHNvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGxlZnQ6aW50ICgqIGxlZnRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiByaWdodDppbnQgKCogcmlnaHRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiB1bml0XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5zZXJ0aW9uX3NvcnQgKilcbiAgbW9kdWxlIEluc2VydGlvbl9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgICBbYXJyXSBpcyBzb3J0ZWQgZnJvbSBbbGVmdF0gdG8gW3BvcyAtIDFdLCBpbmNsdXNpdmUgKilcbiAgICAgIGZvciBwb3MgPSBsZWZ0ICsgMSB0byByaWdodCBkb1xuICAgICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4gaS0xXSBpcyBzb3J0ZWRcbiAgICAgICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uIHBvc10gaXMgc29ydGVkIGFuZCBjb250YWlucyBvbmx5IGVsZW1lbnRzID4gdlxuICAgICAgICAgICAzLiAgYXJyW2ldIG1heSBiZSB0aG91Z2h0IG9mIGFzIGNvbnRhaW5pbmcgdlxuXG4gICAgICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFsbG9jYXRlIGEgY2xvc3VyZSwgYnV0IGlzIGxlZnQgaW4gdGhlIGZvclxuICAgICAgICAgICBsb29wIGZvciB0aGUgcmVhZGFiaWxpdHkgb2YgdGhlIGRvY3VtZW50YXRpb24uICopXG4gICAgICAgIGxldCByZWMgbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaSB2ID1cbiAgICAgICAgICBsZXQgaV9uZXh0ID0gaSAtIDEgaW5cbiAgICAgICAgICBpZiBpX25leHQgPj0gbGVmdCAmJiBjb21wYXJlIChnZXQgYXJyIGlfbmV4dCkgdiA+IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIHNldCBhcnIgaSAoZ2V0IGFyciBpX25leHQpO1xuICAgICAgICAgICAgbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaV9uZXh0IHYpXG4gICAgICAgICAgZWxzZSBpXG4gICAgICAgIGluXG4gICAgICAgIGxldCB2ID0gZ2V0IGFyciBwb3MgaW5cbiAgICAgICAgbGV0IGZpbmFsX3BvcyA9IGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIHBvcyB2IGluXG4gICAgICAgIHNldCBhcnIgZmluYWxfcG9zIHZcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlYXBzb3J0ICopXG4gIG1vZHVsZSBIZWFwX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgcm9vdCdzIGNoaWxkcmVuIGFyZSBib3RoIGVpdGhlciByb290cyBvZiBtYXgtaGVhcHMgb3IgPiByaWdodCAqKVxuICAgIGxldCByZWMgaGVhcGlmeSBhcnIgfmNvbXBhcmUgcm9vdCB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHJlbGF0aXZlX3Jvb3QgPSByb290IC0gbGVmdCBpblxuICAgICAgbGV0IGxlZnRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDEgaW5cbiAgICAgIGxldCByaWdodF9jaGlsZCA9ICgyICogcmVsYXRpdmVfcm9vdCkgKyBsZWZ0ICsgMiBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiBsZWZ0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgbGVmdF9jaGlsZCkgKGdldCBhcnIgcm9vdCkgPiAwXG4gICAgICAgIHRoZW4gbGVmdF9jaGlsZFxuICAgICAgICBlbHNlIHJvb3RcbiAgICAgIGluXG4gICAgICBsZXQgbGFyZ2VzdCA9XG4gICAgICAgIGlmIHJpZ2h0X2NoaWxkIDw9IHJpZ2h0ICYmIGNvbXBhcmUgKGdldCBhcnIgcmlnaHRfY2hpbGQpIChnZXQgYXJyIGxhcmdlc3QpID4gMFxuICAgICAgICB0aGVuIHJpZ2h0X2NoaWxkXG4gICAgICAgIGVsc2UgbGFyZ2VzdFxuICAgICAgaW5cbiAgICAgIGlmIGxhcmdlc3QgPD4gcm9vdFxuICAgICAgdGhlbiAoXG4gICAgICAgIHN3YXAgYXJyIHJvb3QgbGFyZ2VzdDtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGFyZ2VzdCB+bGVmdCB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogRWxlbWVudHMgaW4gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhcnJheSBhcmUgYWxyZWFkeSBoZWFwcyBvZiBzaXplIDEuICBXZSBtb3ZlXG4gICAgICAgICB0aHJvdWdoIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSBhcnJheSBmcm9tIGJhY2sgdG8gZnJvbnQgZXhhbWluaW5nIHRoZSBlbGVtZW50IGF0XG4gICAgICAgICBoYW5kLCBhbmQgdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkcmVuLCBmaXhpbmcgdGhlIGhlYXAgcHJvcGVydHkgYXMgd2UgZ28uICopXG4gICAgICBmb3IgaSA9IChsZWZ0ICsgcmlnaHQpIC8gMiBkb3dudG8gbGVmdCBkb1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBpIH5sZWZ0IH5yaWdodFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGJ1aWxkX2hlYXAgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodDtcbiAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4uIGldIGlzIGEgbWF4LWhlYXAgSFxuICAgICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uLiByaWdodF0gaXMgc29ydGVkIChjYWxsIGl0IFMpXG4gICAgICAgICAzLiAgZXZlcnkgZWxlbWVudCBvZiBIIGlzIGxlc3MgdGhhbiBldmVyeSBlbGVtZW50IG9mIFMgKilcbiAgICAgIGZvciBpID0gcmlnaHQgZG93bnRvIGxlZnQgKyAxIGRvXG4gICAgICAgIHN3YXAgYXJyIGxlZnQgaTtcbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgbGVmdCB+bGVmdCB+cmlnaHQ6KGkgLSAxKVxuICAgICAgZG9uZVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50cm9zb3J0ICopXG4gIG1vZHVsZSBJbnRyb19zb3J0IDogc2lnXG4gICAgaW5jbHVkZSBTb3J0XG5cbiAgICB2YWwgZml2ZV9lbGVtZW50X3NvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfmNvbXBhcmUgbTEgbTIgbTMgbTQgbTUgPVxuICAgICAgbGV0IGNvbXBhcmVfYW5kX3N3YXAgaSBqID1cbiAgICAgICAgaWYgY29tcGFyZSAoZ2V0IGFyciBpKSAoZ2V0IGFyciBqKSA+IDAgdGhlbiBzd2FwIGFyciBpIGpcbiAgICAgIGluXG4gICAgICAoKiBPcHRpbWFsIDUtZWxlbWVudCBzb3J0aW5nIG5ldHdvcms6XG5cbiAgICAgICAgIHt2XG4gICAgICAgICAgICAxLS1vLS0tLS1vLS0tLS1vLS0tLS0tLS0tLS0tLS0xXG4gICAgICAgICAgICAgICB8ICAgICB8ICAgICB8XG4gICAgICAgICAgICAyLS1vLS0tLS18LS1vLS18LS0tLS1vLS1vLS0tLS0yXG4gICAgICAgICAgICAgICAgICAgICB8ICB8ICB8ICAgICB8ICB8XG4gICAgICAgICAgICAzLS0tLS0tLS1vLS1vLS18LS1vLS18LS1vLS0tLS0zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB8ICB8XG4gICAgICAgICAgICA0LS0tLS1vLS0tLS0tLS1vLS1vLS18LS0tLS1vLS00XG4gICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICB8XG4gICAgICAgICAgICA1LS0tLS1vLS0tLS0tLS0tLS0tLS1vLS0tLS1vLS01XG4gICAgICAgICAgdn0gKilcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTI7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG00IG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG00O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMyBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTU7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNVxuICAgIDs7XG5cbiAgICAoKiBjaG9vc2UgcGl2b3RzIGZvciB0aGUgYXJyYXkgYnkgc29ydGluZyA1IGVsZW1lbnRzIGFuZCBleGFtaW5pbmcgdGhlIGNlbnRlciB0aHJlZVxuICAgICAgIGVsZW1lbnRzLiAgVGhlIGdvYWwgaXMgdG8gY2hvb3NlIHR3byBwaXZvdHMgdGhhdCB3aWxsIGVpdGhlcjpcbiAgICAgICAtIGJyZWFrIHRoZSByYW5nZSB1cCBpbnRvIDMgZXZlbiBwYXJ0aXRpb25zXG4gICAgICAgICBvclxuICAgICAgIC0gZWxpbWluYXRlIGEgY29tbW9ubHkgYXBwZWFyaW5nIGVsZW1lbnQgYnkgc29ydGluZyBpdCBpbnRvIHRoZSBjZW50ZXIgcGFydGl0aW9uXG4gICAgICAgICBieSBpdHNlbGZcbiAgICAgICAgIFRvIHRoaXMgZW5kIHdlIGxvb2sgYXQgdGhlIGNlbnRlciAzIGVsZW1lbnRzIG9mIHRoZSA1IGFuZCByZXR1cm4gcGFpcnMgb2YgZXF1YWxcbiAgICAgICAgIGVsZW1lbnRzIG9yIHRoZSB3aWRlc3QgcmFuZ2UgKilcbiAgICBsZXQgY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBzaXh0aCA9IChyaWdodCAtIGxlZnQpIC8gNiBpblxuICAgICAgbGV0IG0xID0gbGVmdCArIHNpeHRoIGluXG4gICAgICBsZXQgbTIgPSBtMSArIHNpeHRoIGluXG4gICAgICBsZXQgbTMgPSBtMiArIHNpeHRoIGluXG4gICAgICBsZXQgbTQgPSBtMyArIHNpeHRoIGluXG4gICAgICBsZXQgbTUgPSBtNCArIHNpeHRoIGluXG4gICAgICBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfmNvbXBhcmUgbTEgbTIgbTMgbTQgbTU7XG4gICAgICBsZXQgbTJfdmFsID0gZ2V0IGFyciBtMiBpblxuICAgICAgbGV0IG0zX3ZhbCA9IGdldCBhcnIgbTMgaW5cbiAgICAgIGxldCBtNF92YWwgPSBnZXQgYXJyIG00IGluXG4gICAgICBpZiBjb21wYXJlIG0yX3ZhbCBtM192YWwgPSAwXG4gICAgICB0aGVuIG0yX3ZhbCwgbTNfdmFsLCB0cnVlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgbTNfdmFsIG00X3ZhbCA9IDBcbiAgICAgIHRoZW4gbTNfdmFsLCBtNF92YWwsIHRydWVcbiAgICAgIGVsc2UgbTJfdmFsLCBtNF92YWwsIGZhbHNlXG4gICAgOztcblxuICAgIGxldCBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBwaXZvdDEsIHBpdm90MiwgcGl2b3RzX2VxdWFsID0gY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgbGVmdCA8PSBsIDwgciA8PSByaWdodFxuICAgICAgICAgMi4gIGwgPD0gcCA8PSByXG4gICAgICAgICAzLiAgbCA8PSB4IDwgcCAgICAgaW1wbGllcyBhcnJbeF0gPj0gcGl2b3QxXG4gICAgICAgICBhbmQgYXJyW3hdIDw9IHBpdm90MlxuICAgICAgICAgNC4gIGxlZnQgPD0geCA8IGwgIGltcGxpZXMgYXJyW3hdIDwgcGl2b3QxXG4gICAgICAgICA1LiAgciA8IHggPD0gcmlnaHQgaW1wbGllcyBhcnJbeF0gPiBwaXZvdDIgKilcbiAgICAgIGxldCByZWMgbG9vcCBsIHAgciA9XG4gICAgICAgIGxldCBwdiA9IGdldCBhcnIgcCBpblxuICAgICAgICBpZiBjb21wYXJlIHB2IHBpdm90MSA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc3dhcCBhcnIgcCBsO1xuICAgICAgICAgIGNvbnQgKGwgKyAxKSAocCArIDEpIHIpXG4gICAgICAgIGVsc2UgaWYgY29tcGFyZSBwdiBwaXZvdDIgPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIGxvb3AgaW52YXJpYW50czogIHNhbWUgYXMgdGhvc2Ugb2YgdGhlIG91dGVyIGxvb3AgKilcbiAgICAgICAgICBsZXQgcmVjIHNjYW5fYmFja3dhcmRzIHIgPVxuICAgICAgICAgICAgaWYgciA+IHAgJiYgY29tcGFyZSAoZ2V0IGFyciByKSBwaXZvdDIgPiAwIHRoZW4gc2Nhbl9iYWNrd2FyZHMgKHIgLSAxKSBlbHNlIHJcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCByID0gc2Nhbl9iYWNrd2FyZHMgciBpblxuICAgICAgICAgIHN3YXAgYXJyIHIgcDtcbiAgICAgICAgICBjb250IGwgcCAociAtIDEpKVxuICAgICAgICBlbHNlIGNvbnQgbCAocCArIDEpIHJcbiAgICAgIGFuZCBjb250IGwgcCByID0gaWYgcCA+IHIgdGhlbiBsLCByIGVsc2UgbG9vcCBsIHAgciBpblxuICAgICAgbGV0IGwsIHIgPSBjb250IGxlZnQgbGVmdCByaWdodCBpblxuICAgICAgbCwgciwgcGl2b3RzX2VxdWFsXG4gICAgOztcblxuICAgIGxldCByZWMgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGxlbiA9IHJpZ2h0IC0gbGVmdCArIDEgaW5cbiAgICAgICgqIFRoaXMgdGFrZXMgY2FyZSBvZiBzb21lIGVkZ2UgY2FzZXMsIHN1Y2ggYXMgbGVmdCA+IHJpZ2h0IG9yIHZlcnkgc2hvcnQgYXJyYXlzLFxuICAgICAgICAgc2luY2UgSW5zZXJ0aW9uX3NvcnQuc29ydCBoYW5kbGVzIHRoZXNlIGNhc2VzIHByb3Blcmx5LiAgVGh1cyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICBtYWtlIHN1cmUgdGhhdCBsZWZ0IGFuZCByaWdodCBhcmUgdmFsaWQgaW4gcmVjdXJzaXZlIGNhbGxzLiAqKVxuICAgICAgaWYgbGVuIDw9IDMyXG4gICAgICB0aGVuIEluc2VydGlvbl9zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgICAgZWxzZSBpZiBtYXhfZGVwdGggPCAwXG4gICAgICB0aGVuIEhlYXBfc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbWF4X2RlcHRoID0gbWF4X2RlcHRoIC0gMSBpblxuICAgICAgICBsZXQgbCwgciwgbWlkZGxlX3NvcnRlZCA9IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgaW5cbiAgICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ6KGwgLSAxKTtcbiAgICAgICAgaWYgbm90IG1pZGRsZV9zb3J0ZWQgdGhlbiBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OmwgfnJpZ2h0OnI7XG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQ6KHIgKyAxKSB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGhlYXBfc29ydF9zd2l0Y2hfZGVwdGggPVxuICAgICAgICAoKiBXZSBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXQgYSByZWN1cnNpb24gZGVwdGggb2YgMzIuIEdOVSBpbnRyb3NvcnQgdXNlcyAybGcobikuXG4gICAgICAgICAgIFRoZSBleHBlY3RlZCByZWN1cnNpb24gZGVwdGggZm9yIHBlcmZlY3QgMy13YXkgc3BsaXRzIGlzIGxvZ18zKG4pLlxuXG4gICAgICAgICAgIFVzaW5nIDMyIG1lYW5zIGEgYmFsYW5jZWQgMy13YXkgc3BsaXQgd291bGQgd29yayB1cCB0byAzXjMyIGVsZW1lbnRzIChyb3VnaGx5XG4gICAgICAgICAgIDJeNTAgb3IgMTBeMTUpLiBHTlUgcmVhY2hlcyBhIGRlcHRoIG9mIDMyIGF0IDY1NTM2IGVsZW1lbnRzLlxuXG4gICAgICAgICAgIEZvciBzbWFsbCBhcnJheXMsIHRoaXMgbWFrZXMgdXMgbGVzcyBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0LCBidXQgdGhlXG4gICAgICAgICAgIDMyKk4gY29zdCBiZWZvcmUgd2UgZG8gaXMgbm90IHRoYXQgbXVjaC5cblxuICAgICAgICAgICBGb3IgbGFyZ2UgYXJyYXlzLCB0aGlzIG1lYW5zIHdlIGFyZSBtb3JlIGxpa2VseSB0byBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXRcbiAgICAgICAgICAgc29tZSBwb2ludCBpZiB3ZSBnZXQgc29tZSBiYWQgc3BsaXRzIG9yIGlmIHRoZSBhcnJheSBpcyBodWdlLiBCdXQgdGhhdCdzIG9ubHkgYVxuICAgICAgICAgICBjb25zdGFudCBmYWN0b3IgY29zdCBpbiB0aGUgZmluYWwgc3RhZ2VzIG9mIHJlY3Vyc2lvbi5cblxuICAgICAgICAgICBBbGwgaW4gYWxsLCB0aGlzIHNlZW1zIHRvIGJlIGEgc21hbGwgdHJhZGVvZmYgYW5kIGF2b2lkcyBwYXlpbmcgYSBjb3N0IHRvXG4gICAgICAgICAgIGNvbXB1dGUgYSBsb2dhcml0aG0gYXQgdGhlIHN0YXJ0LiAqKVxuICAgICAgICAzMlxuICAgICAgaW5cbiAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGg6aGVhcF9zb3J0X3N3aXRjaF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5sZXQgc29ydCA/cG9zID9sZW4gYXJyIH5jb21wYXJlID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIGFycilcbiAgaW5cbiAgU29ydC5JbnRyb19zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0OnBvcyB+cmlnaHQ6KHBvcyArIGxlbiAtIDEpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IHRcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBpc19zb3J0ZWQgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID4gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPj0gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IG1lcmdlIGExIGEyIH5jb21wYXJlID1cbiAgbGV0IGwxID0gQXJyYXkubGVuZ3RoIGExIGluXG4gIGxldCBsMiA9IEFycmF5Lmxlbmd0aCBhMiBpblxuICBpZiBsMSA9IDBcbiAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbDIgPSAwXG4gIHRoZW4gY29weSBhMVxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTIgMCkgKHVuc2FmZV9nZXQgYTEgKGwxIC0gMSkpID49IDBcbiAgdGhlbiBhcHBlbmQgYTEgYTJcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGExIDApICh1bnNhZmVfZ2V0IGEyIChsMiAtIDEpKSA+IDBcbiAgdGhlbiBhcHBlbmQgYTIgYTFcbiAgZWxzZSAoXG4gICAgbGV0IGxlbiA9IGwxICsgbDIgaW5cbiAgICBsZXQgbWVyZ2VkID0gY3JlYXRlIH5sZW4gKHVuc2FmZV9nZXQgYTEgMCkgaW5cbiAgICBsZXQgYTFfaW5kZXggPSByZWYgMCBpblxuICAgIGxldCBhMl9pbmRleCA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCB1c2VfYTEgPVxuICAgICAgICBpZiBsMSA9ICFhMV9pbmRleFxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgaWYgbDIgPSAhYTJfaW5kZXhcbiAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgIGVsc2UgY29tcGFyZSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCkgPD0gMFxuICAgICAgaW5cbiAgICAgIGlmIHVzZV9hMVxuICAgICAgdGhlbiAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KTtcbiAgICAgICAgYTFfaW5kZXggOj0gIWExX2luZGV4ICsgMSlcbiAgICAgIGVsc2UgKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCk7XG4gICAgICAgIGEyX2luZGV4IDo9ICFhMl9pbmRleCArIDEpXG4gICAgZG9uZTtcbiAgICBtZXJnZWQpXG47O1xuXG5sZXQgY29weV9tYXRyaXggPSBtYXAgfmY6Y29weVxuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuOztcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwIH5mIHQpKVxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcGkgfmYgdCkpXG5cbmxldCByZXZfaW5wbGFjZSB0ID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICB3aGlsZSAhaSA8ICFqIGRvXG4gICAgc3dhcCB0ICFpICFqO1xuICAgIGluY3IgaTtcbiAgICBkZWNyIGpcbiAgZG9uZVxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IHQgPSBjb3B5IHQgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgYSA6OiBsIC0+XG4gICAgbGV0IGxlbiA9IDEgKyBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbiBhIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgICgqIFdlIHN0YXJ0IGF0IFtsZW4gLSAyXSBiZWNhdXNlIHdlIGFscmVhZHkgcHV0IFthXSBhdCBbdC4obGVuIC0gMSldLiAqKVxuICAgIGZvciBpID0gbGVuIC0gMiBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIHQuKGkpIDwtIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgdFxuOztcblxuKCogW29mX2xpc3RfbWFwXSBhbmQgW29mX2xpc3RfcmV2X21hcF0gYXJlIGJhc2VkIG9uIGZ1bmN0aW9ucyBmcm9tIHRoZSBPQ2FtbFxuICAgZGlzdHJpYnV0aW9uLiAqKVxuXG5sZXQgb2ZfbGlzdF9tYXAgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaGQpO1xuICAgICAgICBmaWxsIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgMSB0bFxuOztcblxubGV0IG9mX2xpc3RfbWFwaSB4cyB+ZiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgaGQgOjogdGwgLT5cbiAgICBsZXQgYSA9IGNyZWF0ZSB+bGVuOigxICsgTGlzdC5sZW5ndGggdGwpIChmIDAgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGEgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaSBoZCk7XG4gICAgICAgIGZpbGwgYSAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIGEgMSB0bFxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcCB4cyB+ZiA9XG4gIGxldCB0ID0gb2ZfbGlzdF9tYXAgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2X21hcGkgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwaSB4cyB+ZiBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByID0gcmVmIFt8fF0gaW5cbiAgbGV0IGsgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbWF0Y2ggZiBpICh1bnNhZmVfZ2V0IHQgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBhIC0+XG4gICAgICBpZiAhayA9IDAgdGhlbiByIDo9IGNyZWF0ZSB+bGVuOihsZW5ndGggdCkgYTtcbiAgICAgIHVuc2FmZV9zZXQgIXIgIWsgYTtcbiAgICAgIGluY3Iga1xuICBkb25lO1xuICBpZiAhayA9IGxlbmd0aCB0IHRoZW4gIXIgZWxzZSBpZiAhayA+IDAgdGhlbiBzdWIgfnBvczowIH5sZW46IWsgIXIgZWxzZSBbfHxdXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIF9pIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9vcHQgdCA9IGZpbHRlcl9tYXAgdCB+ZjpGbi5pZFxuXG5sZXQgcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjIgPVxuICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIHQxIHQyID1cbiAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yXG47O1xuXG5sZXQgaXRlcjJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5pdGVyMl9leG5cIiB0MSB0MjtcbiAgaXRlcmkgdDEgfmY6KGZ1biBpIHgxIC0+IGYgeDEgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5Lm1hcDJfZXhuXCIgdDEgdDI7XG4gIGluaXQgKGxlbmd0aCB0MSkgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgZm9sZDJfZXhuIHQxIHQyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb2xkMl9leG5cIiB0MSB0MjtcbiAgZm9sZGkgdDEgfmluaXQgfmY6KGZ1biBpIGFjIHggLT4gZiBhYyB4ICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxubGV0IGZpbHRlcmkgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxuXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAhaSAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKVxuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHMyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZXhpc3RzMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvcl9hbGwyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPSBsZW5ndGggdDEgPSBsZW5ndGggdDIgJiYgZm9yX2FsbDJfZXhuIHQxIHQyIH5mOmVxdWFsXG5cblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldCB0IGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBmaW5kaV9pbnRlcm5hbCB0IH5mIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBpZl9ub3RfZm91bmQgKClcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGYgIWkgdmFsdWVcbiAgICAgIHRoZW4gKFxuICAgICAgICB2YWx1ZV9mb3VuZCA6PSB2YWx1ZTtcbiAgICAgICAgZm91bmQgOj0gdHJ1ZSlcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiAhZm91bmQgdGhlbiBpZl9mb3VuZCB+aTohaSB+dmFsdWU6IXZhbHVlX2ZvdW5kIGVsc2UgaWZfbm90X2ZvdW5kICgpKVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBTb21lIChpLCB2YWx1ZSkpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpXG47O1xuXG5sZXQgZmluZGlfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZlxuICAgIH5pZl9mb3VuZDooZnVuIH5pIH52YWx1ZSAtPiBpLCB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZGlfZXhuOiBub3QgZm91bmRcIikpKVxuOztcblxubGV0IGZpbmRfZXhuIHQgfmYgPVxuICBmaW5kaV9pbnRlcm5hbFxuICAgIHRcbiAgICB+ZjooZnVuIF9pIHggLT4gZiB4KVxuICAgIH5pZl9mb3VuZDooZnVuIH5pOl8gfnZhbHVlIC0+IHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPSBPcHRpb24ubWFwIChmaW5kaSB0IH5mOihmdW4gX2kgeCAtPiBmIHgpKSB+ZjooZnVuIChfaSwgeCkgLT4geClcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgIWkgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA8PSAxXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVzdWx0ID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgaSA9IHJlZiAxIGluXG4gICAgbGV0IHByZXYgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGN1ciA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZXF1YWwgY3VyICFwcmV2XG4gICAgICB0aGVuIChcbiAgICAgICAgcmVzdWx0IDo9IFNvbWUgKCFwcmV2LCBjdXIpO1xuICAgICAgICBpIDo9IG4pXG4gICAgICBlbHNlIChcbiAgICAgICAgcHJldiA6PSBjdXI7XG4gICAgICAgIGluY3IgaSlcbiAgICBkb25lO1xuICAgICFyZXN1bHQpXG47O1xuXG5sZXQgcmVkdWNlIHQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICAgIGRvbmU7XG4gICAgU29tZSAhcilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHQgfmYgPVxuICBtYXRjaCByZWR1Y2UgdCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcGVybXV0ZSA9IEFycmF5X3Blcm11dGUucGVybXV0ZVxuXG5sZXQgcmFuZG9tX2VsZW1lbnRfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGFycmF5XCJcbiAgZWxzZSB0LihSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAobGVuZ3RoIHQpKVxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICB0cnkgU29tZSAocmFuZG9tX2VsZW1lbnRfZXhuIH5yYW5kb21fc3RhdGUgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHppcCB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDIgdGhlbiBOb25lIGVsc2UgU29tZSAobWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpKVxuOztcblxubGV0IHppcF9leG4gdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyXG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS56aXBfZXhuXCJcbiAgZWxzZSBtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4Milcbjs7XG5cbmxldCB1bnppcCB0ID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuID0gMFxuICB0aGVuIFt8fF0sIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHgsIHkgPSB0LigwKSBpblxuICAgIGxldCByZXMxID0gY3JlYXRlIH5sZW46biB4IGluXG4gICAgbGV0IHJlczIgPSBjcmVhdGUgfmxlbjpuIHkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCB4LCB5ID0gdC4oaSkgaW5cbiAgICAgIHJlczEuKGkpIDwtIHg7XG4gICAgICByZXMyLihpKSA8LSB5XG4gICAgZG9uZTtcbiAgICByZXMxLCByZXMyKVxuOztcblxubGV0IHNvcnRlZF9jb3B5IHQgfmNvbXBhcmUgPVxuICBsZXQgdDEgPSBjb3B5IHQgaW5cbiAgc29ydCB0MSB+Y29tcGFyZTtcbiAgdDFcbjs7XG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBsZXQgYm90aCA9IG1hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIEVpdGhlci5GaXJzdCB4IGVsc2UgRWl0aGVyLlNlY29uZCB4KSBpblxuICBsZXQgdHJ1ZXMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgeCAtPiBTb21lIHhcbiAgICAgIHwgU2Vjb25kIF8gLT4gTm9uZSlcbiAgaW5cbiAgbGV0IGZhbHNlcyA9XG4gICAgZmlsdGVyX21hcCBib3RoIH5mOihmdW5jdGlvblxuICAgICAgfCBGaXJzdCBfIC0+IE5vbmVcbiAgICAgIHwgU2Vjb25kIHggLT4gU29tZSB4KVxuICBpblxuICB0cnVlcywgZmFsc2VzXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biBfaSB4IC0+IGYgeClcbmxldCBsYXN0IHQgPSB0LihsZW5ndGggdCAtIDEpXG5cbigqIENvbnZlcnQgdG8gYSBzZXF1ZW5jZSBidXQgZG9lcyBub3QgYXR0ZW1wdCB0byBwcm90ZWN0IGFnYWluc3QgbW9kaWZpY2F0aW9uXG4gICBpbiB0aGUgYXJyYXkuICopXG5sZXQgdG9fc2VxdWVuY2VfbXV0YWJsZSB0ID1cbiAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT5cbiAgICBpZiBpID49IGxlbmd0aCB0IHRoZW4gU2VxdWVuY2UuU3RlcC5Eb25lIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAodC4oaSksIGkgKyAxKSlcbjs7XG5cbmxldCB0b19zZXF1ZW5jZSB0ID0gdG9fc2VxdWVuY2VfbXV0YWJsZSAoY29weSB0KVxuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgdDEgdDIgPVxuICBpZiBpc19lbXB0eSB0MSB8fCBpc19lbXB0eSB0MlxuICB0aGVuIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gICAgbGV0IG4yID0gbGVuZ3RoIHQyIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbjoobjEgKiBuMikgKHQxLigwKSwgdDIuKDApKSBpblxuICAgIGxldCByID0gcmVmIDAgaW5cbiAgICBmb3IgaTEgPSAwIHRvIG4xIC0gMSBkb1xuICAgICAgZm9yIGkyID0gMCB0byBuMiAtIDEgZG9cbiAgICAgICAgdC4oIXIpIDwtIHQxLihpMSksIHQyLihpMik7XG4gICAgICAgIGluY3IgclxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgdClcbjs7XG5cbmxldCB0cmFuc3Bvc2UgdHQgPVxuICBpZiBsZW5ndGggdHQgPSAwXG4gIHRoZW4gU29tZSBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB3aWR0aCA9IGxlbmd0aCB0dCBpblxuICAgIGxldCBkZXB0aCA9IGxlbmd0aCB0dC4oMCkgaW5cbiAgICBpZiBleGlzdHMgdHQgfmY6KGZ1biB0IC0+IGxlbmd0aCB0IDw+IGRlcHRoKVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgU29tZSAoaW5pdCBkZXB0aCB+ZjooZnVuIGQgLT4gaW5pdCB3aWR0aCB+ZjooZnVuIHcgLT4gdHQuKHcpLihkKSkpKSlcbjs7XG5cbmxldCB0cmFuc3Bvc2VfZXhuIHR0ID1cbiAgbWF0Y2ggdHJhbnNwb3NlIHR0IHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkudHJhbnNwb3NlX2V4blwiXG4gIHwgU29tZSB0dCcgLT4gdHQnXG47O1xuXG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGdldCA9IGdldFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgZW5kKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiB0ID1cbiAgICAgIGlmIGxlbiA9IDBcbiAgICAgIHRoZW4gW3x8XVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgICAgY3JlYXRlIH5sZW4gdC4oMCkpXG4gICAgOztcblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gaXRlciB0IH5mOmludmFyaWFudF9hXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBTb3J0ID0gU29ydFxuZW5kXG4iLCIoKiogQW4gaW50ZXJuYWwtb25seSBtb2R1bGUgZmFjdG9yZWQgb3V0IGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBjb3JlX2FycmF5XG4gICAgYW5kIGNvcmVfbGlzdC4gIENvbnRhaW5zIGNvZGUgZm9yIHBlcm11dGluZyBhbiBhcnJheS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSA/KHBvcyA9IDApID9sZW4gdCA9XG4gICgqIENvcGllZCBmcm9tIFtPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMF0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlIHdoZW4gY29tcGlsaW5nXG4gICAgIHdpdGhvdXQgZmxhbWJkYS4gKilcbiAgbGV0IHRvdGFsX2xlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGwgLT4gbFxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAuY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGxldCBudW1fc3dhcHMgPSBsZW4gLSAxIGluXG4gIGZvciBpID0gbnVtX3N3YXBzIGRvd250byAxIGRvXG4gICAgbGV0IHRoaXNfaSA9IHBvcyArIGkgaW5cbiAgICAoKiBbcmFuZG9tX2ldIGlzIGRyYXduIGZyb20gW3Bvcyx0aGlzX2ldICopXG4gICAgbGV0IHJhbmRvbV9pID0gcG9zICsgUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGkgKyAxKSBpblxuICAgIHN3YXAgdCB0aGlzX2kgcmFuZG9tX2lcbiAgZG9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgY29uc3QgYyBfID0gY1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiB0aGlzIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbQ2FtbC5pZ25vcmVdICopXG5cbmxldCBub24gZiB4ID0gbm90IChmIHgpXG5cbmxldCBmb3JldmVyIGYgPVxuICBsZXQgcmVjIGZvcmV2ZXIgKCkgPVxuICAgIGYgKCk7XG4gICAgZm9yZXZlciAoKVxuICBpblxuICB0cnkgZm9yZXZlciAoKSB3aXRoXG4gIHwgZSAtPiBlXG47O1xuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoZXNlIGZ1bmN0aW9ucyBpcyB0byBwYXNzIGluIGZ1bmN0aW9uYWwgYXJndW1lbnRzIGFuZCBnZXRcbiAgIGZ1bmN0aW9ucyBhcyBhIHJlc3VsdC4gKilcbmxldCBjb21wb3NlIGYgZyB4ID0gZiAoZyB4KVxubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IHJlYyBhcHBseV9uX3RpbWVzIH5uIGYgeCA9IGlmIG4gPD0gMCB0aGVuIHggZWxzZSBhcHBseV9uX3RpbWVzIH5uOihuIC0gMSkgZiAoZiB4KVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgUmVwciA9IEludDYzX2VtdWwuUmVwclxuXG4oKiBJbiBhIHdvcmxkIHdoZXJlIHRoZSBjb21waWxlciB3b3VsZCB1bmRlcnN0YW5kIFtAQGltbWVkaWF0ZTY0XSBhdHRyaWJ1dGVzIG9uIHR5cGVcbiAgIGRlY2xhcmF0aW9ucywgdGhpcyBtb2R1bGUgaXMgaG93IG9uZSB3b3VsZCBwcm9kdWNlIGEgW3R5cGUgdF0gd2l0aCB0aGlzIGF0dHJpYnV0ZS4gKilcbm1vZHVsZSBJbW1lZGlhdGU2NCA6IHNpZ1xuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbW1lZGlhdGUgOiBJbW1lZGlhdGUpIChOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgOiBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuXG4gICAgdmFsIHJlcHIgOiB0IHJlcHJcbiAgZW5kXG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBJbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuICBlbmRcblxuICBtb2R1bGUgTWFrZSAoSW1tZWRpYXRlIDogSW1tZWRpYXRlKSAoTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUpID0gc3RydWN0XG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZTY0XVxuXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcblxuICAgIGxldCByZXByID1cbiAgICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgICAgfCBXNjQgLT4gKENhbWwuT2JqLm1hZ2ljIEltbWVkaWF0ZSA6IHQgcmVwcilcbiAgICAgIHwgVzMyIC0+IChDYW1sLk9iai5tYWdpYyBOb25faW1tZWRpYXRlIDogdCByZXByKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgSW1tZWRpYXRlNjQuTWFrZSAoSW50KSAoSW50NjNfZW11bClcblxubW9kdWxlIEJhY2tlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBJbnRfaW50Zi5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCB0b19pbnQgOiB0IC0+IGludCBvcHRpb25cbiAgICB2YWwgdG9faW50X3RydW5jIDogdCAtPiBpbnRcbiAgICB2YWwgb2ZfaW50MzIgOiBpbnQzMiAtPiB0XG4gICAgdmFsIHRvX2ludDMyIDogdCAtPiBJbnQzMi50IG9wdGlvblxuICAgIHZhbCB0b19pbnQzMl90cnVuYyA6IHQgLT4gSW50MzIudFxuICAgIHZhbCBvZl9pbnQ2NCA6IEludDY0LnQgLT4gdCBvcHRpb25cbiAgICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBJbnQ2NC50IC0+IHRcbiAgICB2YWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IHQgb3B0aW9uXG4gICAgdmFsIHRvX25hdGl2ZWludCA6IHQgLT4gbmF0aXZlaW50IG9wdGlvblxuICAgIHZhbCBvZl9uYXRpdmVpbnRfdHJ1bmMgOiBuYXRpdmVpbnQgLT4gdFxuICAgIHZhbCB0b19uYXRpdmVpbnRfdHJ1bmMgOiB0IC0+IG5hdGl2ZWludFxuICAgIHZhbCBvZl9mbG9hdF91bmNoZWNrZWQgOiBmbG9hdCAtPiB0XG4gICAgdmFsIHJlcHIgOiAodCwgdCkgSW50NjNfZW11bC5SZXByLnRcbiAgICB2YWwgYnN3YXAxNiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDMyIDogdCAtPiB0XG4gICAgdmFsIGJzd2FwNDggOiB0IC0+IHRcbiAgZW5kXG4gIHdpdGggdHlwZSB0IDo9IHRcblxuICBtb2R1bGUgTmF0aXZlID0gc3RydWN0XG4gICAgaW5jbHVkZSBJbnRcblxuICAgIGxldCB0b19pbnQgeCA9IFNvbWUgeFxuICAgIGxldCB0b19pbnRfdHJ1bmMgeCA9IHhcblxuICAgICgqIFtvZl9pbnQzMl9leG5dIGlzIGEgc2FmZSBvcGVyYXRpb24gb24gcGxhdGZvcm1zIHdpdGggNjQtYml0IHdvcmQgc2l6ZXMuICopXG4gICAgbGV0IG9mX2ludDMyID0gb2ZfaW50MzJfZXhuXG4gICAgbGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gdG9fbmF0aXZlaW50IHhcbiAgICBsZXQgdG9fbmF0aXZlaW50IHggPSBTb21lICh0b19uYXRpdmVpbnQgeClcbiAgICBsZXQgcmVwciA9IEludDYzX2VtdWwuUmVwci5JbnRcbiAgICBsZXQgYnN3YXAzMiB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDMyIChJbnQ2NC5vZl9pbnQgdCkpXG4gICAgbGV0IGJzd2FwNDggdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXA0OCAoSW50NjQub2ZfaW50IHQpKVxuICBlbmRcblxuICBsZXQgaW1wbCA6IChtb2R1bGUgUykgPVxuICAgIG1hdGNoIHJlcHIgd2l0aFxuICAgIHwgSW1tZWRpYXRlIC0+IChtb2R1bGUgTmF0aXZlIDogUylcbiAgICB8IE5vbl9pbW1lZGlhdGUgLT4gKG1vZHVsZSBJbnQ2M19lbXVsIDogUylcbiAgOztcbmVuZFxuXG5pbmNsdWRlICh2YWwgQmFja2VuZC5pbXBsIDogQmFja2VuZC5TKVxuXG5tb2R1bGUgT3ZlcmZsb3dfZXhuID0gc3RydWN0XG4gIGxldCAoICsgKSB0IHUgPVxuICAgIGxldCBzdW0gPSB0ICsgdSBpblxuICAgIGlmIGJpdF9vciAoYml0X3hvciB0IHUpIChiaXRfeG9yIHQgKGJpdF9ub3Qgc3VtKSkgPCB6ZXJvXG4gICAgdGhlbiBzdW1cbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICsgKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwic3VtXCIsIHNleHBfb2ZfdCBzdW0gXSlcbiAgOztcblxuICBsZXQgKCAtICkgdCB1ID1cbiAgICBsZXQgZGlmZiA9IHQgLSB1IGluXG4gICAgbGV0IHBvc19kaWZmID0gdCA+IHUgaW5cbiAgICBpZiB0IDw+IHUgJiYgQm9vbC4oIDw+ICkgcG9zX2RpZmYgKGlzX3Bvc2l0aXZlIGRpZmYpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAtICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcImRpZmZcIiwgc2V4cF9vZl90IGRpZmYgXSlcbiAgICBlbHNlIGRpZmZcbiAgOztcblxuICBsZXQgbmVnYXRpdmVfb25lID0gb2ZfaW50ICgtMSlcbiAgbGV0IGRpdl93b3VsZF9vdmVyZmxvdyB0IHUgPSB0ID0gbWluX3ZhbHVlICYmIHUgPSBuZWdhdGl2ZV9vbmVcblxuICBsZXQgKCAqICkgdCB1ID1cbiAgICBsZXQgcHJvZHVjdCA9IHQgKiB1IGluXG4gICAgaWYgdSA8PiB6ZXJvICYmIChkaXZfd291bGRfb3ZlcmZsb3cgcHJvZHVjdCB1IHx8IHByb2R1Y3QgLyB1IDw+IHQpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAqICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90IHByb2R1Y3QgXSlcbiAgICBlbHNlIHByb2R1Y3RcbiAgOztcblxuICBsZXQgKCAvICkgdCB1ID1cbiAgICBpZiBkaXZfd291bGRfb3ZlcmZsb3cgdCB1XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAvICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90ICh0IC8gdSkgXSlcbiAgICBlbHNlIHQgLyB1XG4gIDs7XG5cbiAgbGV0IGFicyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwiYWJzIG92ZXJmbG93XCIgZWxzZSBhYnMgdFxuICBsZXQgbmVnIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJuZWcgb3ZlcmZsb3dcIiBlbHNlIG5lZyB0XG5lbmRcblxubGV0ICgpID0gYXNzZXJ0IChJbnQuKCA9ICkgbnVtX2JpdHMgNjMpXG5cbmxldCByYW5kb21fb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnQgc3RhdGUgKHRvX2ludF9leG4gYm91bmQpKVxuOztcblxubGV0IHJhbmRvbV9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjQgc3RhdGUgKHRvX2ludDY0IGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb20gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX29mX2ludFxuICB8IFczMiAtPiByYW5kb21fb2ZfaW50NjRcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludF9pbmNsIHN0YXRlICh0b19pbnRfZXhuIGxvKSAodG9faW50X2V4biBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0X2luY2wgc3RhdGUgKHRvX2ludDY0IGxvKSAodG9faW50NjQgaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9pbmNsX29mX2ludFxuICB8IFczMiAtPiByYW5kb21faW5jbF9vZl9pbnQ2NFxuOztcblxubGV0IGZsb29yX2xvZzIgdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiB0IHw+IHRvX2ludF9leG4gfD4gSW50LmZsb29yX2xvZzJcbiAgfCBXMzIgLT5cbiAgICBpZiB0IDw9IHplcm9cbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pO1xuICAgIGxldCBmbG9vcl9sb2cyID0gcmVmIChJbnQuKCAtICkgbnVtX2JpdHMgMikgaW5cbiAgICB3aGlsZSBlcXVhbCB6ZXJvIChiaXRfYW5kIHQgKHNoaWZ0X2xlZnQgb25lICFmbG9vcl9sb2cyKSkgZG9cbiAgICAgIGZsb29yX2xvZzIgOj0gSW50LiggLSApICFmbG9vcl9sb2cyIDFcbiAgICBkb25lO1xuICAgICFmbG9vcl9sb2cyXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgUmVwciA9IFJlcHJcblxuICBsZXQgcmVwciA9IHJlcHJcblxuICBtb2R1bGUgRW11bCA9IEludDYzX2VtdWxcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludmFyaWFudF9pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5sZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA6IHVuaXQgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJcIiwgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlXG4gICAgICAgICA7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4blxuICAgICAgICAgOyBcIlwiLCBzZXhwX29mX3QgdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCBjaGVja19maWVsZCB0IGYgZmllbGQgPVxuICB0cnkgZiAoRmllbGQuZ2V0IGZpZWxkIHQpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcInByb2JsZW0gd2l0aCBmaWVsZFwiXG4gICAgICAgICBbIFwiZmllbGRcIiwgc2V4cF9vZl9zdHJpbmcgKEZpZWxkLm5hbWUgZmllbGQpOyBcImV4blwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29tcGFyYWJsZV9pbnRmXG5cbm1vZHVsZSBXaXRoX3plcm8gKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB6ZXJvIDogdFxuICBlbmQpID1cbnN0cnVjdFxuICBvcGVuIFRcblxuICBsZXQgaXNfcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvID4gMFxuICBsZXQgaXNfbm9uX25lZ2F0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+PSAwXG4gIGxldCBpc19uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPCAwXG4gIGxldCBpc19ub25fcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDw9IDBcbiAgbGV0IHNpZ24gdCA9IFNpZ24wLm9mX2ludCAoY29tcGFyZSB0IHplcm8pXG5lbmRcblxubW9kdWxlIFBvbHkgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBQb2x5XG4gIGVuZFxuXG4gIGluY2x1ZGUgUG9seVxuXG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuXG4gIG1vZHVsZSBDID0gc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSlcbiAgZW5kXG5cbiAgaW5jbHVkZSBDXG5lbmRcblxubGV0IGd0IGNtcCBhIGIgPSBjbXAgYSBiID4gMFxubGV0IGx0IGNtcCBhIGIgPSBjbXAgYSBiIDwgMFxubGV0IGdlcSBjbXAgYSBiID0gY21wIGEgYiA+PSAwXG5sZXQgbGVxIGNtcCBhIGIgPSBjbXAgYSBiIDw9IDBcbmxldCBlcXVhbCBjbXAgYSBiID0gY21wIGEgYiA9IDBcbmxldCBub3RfZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPD4gMFxubGV0IG1pbiBjbXAgdCB0JyA9IGlmIGxlcSBjbXAgdCB0JyB0aGVuIHQgZWxzZSB0J1xubGV0IG1heCBjbXAgdCB0JyA9IGlmIGdlcSBjbXAgdCB0JyB0aGVuIHQgZWxzZSB0J1xuXG5tb2R1bGUgSW5maXggKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA6IEluZml4IHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBsZXQgKCA+ICkgYSBiID0gZ3QgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8ICkgYSBiID0gbHQgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA+PSApIGEgYiA9IGdlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw9ICkgYSBiID0gbGVxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPSApIGEgYiA9IGVxdWFsIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD4gKSBhIGIgPSBub3RfZXF1YWwgVC5jb21wYXJlIGEgYlxuZW5kXG5cbm1vZHVsZSBQb2x5bW9ycGhpY19jb21wYXJlIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBQb2x5bW9ycGhpY19jb21wYXJlIHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4IChUKVxuXG4gIGxldCBjb21wYXJlID0gVC5jb21wYXJlXG4gIGxldCBlcXVhbCA9ICggPSApXG4gIGxldCBtaW4gdCB0JyA9IG1pbiBjb21wYXJlIHQgdCdcbiAgbGV0IG1heCB0IHQnID0gbWF4IGNvbXBhcmUgdCB0J1xuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBULmNvbXBhcmF0b3Jfd2l0bmVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJhdG9yLmNvbXBhcmVcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIG1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBQb2x5bW9ycGhpY19jb21wYXJlIChUKVxuICBpbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHQgdCcgPSBjb21wYXJlIHQnIHRcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbiAgTWFrZV91c2luZ19jb21wYXJhdG9yIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbiAgZW5kKVxuXG5tb2R1bGUgSW5oZXJpdCAoQyA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIChUIDogc2lnXG4gICAgICAgICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICAgICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgICAgICBbQEBAZW5kXVxuXG4gICAgICAgICAgdmFsIGNvbXBvbmVudCA6IHQgLT4gQy50XG4gICAgICAgIGVuZCkgPVxuICBNYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgdCB0JyA9IEMuY29tcGFyZSAoVC5jb21wb25lbnQgdCkgKFQuY29tcG9uZW50IHQnKVxuICBlbmQpXG5cbigqIGNvbXBhcmUgW3hdIGFuZCBbeV0gbGV4aWNvZ3JhcGhpY2FsbHkgdXNpbmcgZnVuY3Rpb25zIGluIHRoZSBsaXN0IFtjbXBzXSAqKVxubGV0IGxleGljb2dyYXBoaWMgY21wcyB4IHkgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgY21wIDo6IGNtcHMgLT5cbiAgICAgIGxldCByZXMgPSBjbXAgeCB5IGluXG4gICAgICBpZiByZXMgPSAwIHRoZW4gbG9vcCBjbXBzIGVsc2UgcmVzXG4gICAgfCBbXSAtPiAwXG4gIGluXG4gIGxvb3AgY21wc1xuOztcblxubGV0IGxpZnQgY21wIH5mIHggeSA9IGNtcCAoZiB4KSAoZiB5KVxubGV0IHJldmVyc2UgY21wIHggeSA9IGNtcCB5IHhcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlLktleSAqKVxubW9kdWxlIHR5cGUgS2V5ID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIFZhbHVlcyByZXR1cm5lZCBieSBbaGFzaF0gbXVzdCBiZSBub24tbmVnYXRpdmUuICBBbiBleGNlcHRpb24gd2lsbCBiZSByYWlzZWQgaW4gdGhlXG4gICAgICBjYXNlIHRoYXQgW2hhc2hdIHJldHVybnMgYSBuZWdhdGl2ZSB2YWx1ZS4gKilcbiAgdmFsIGhhc2ggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gICgqKiBUaGlzIGZ1bmN0aW9uIGlzIHNvdW5kIGJ1dCBub3QgY29tcGxldGUsIG1lYW5pbmcgdGhhdCBpZiBpdCByZXR1cm5zIFt0cnVlXSB0aGVuIGl0J3NcbiAgICAgIHNhZmUgdG8gdXNlIHRoZSB0d28gaW50ZXJjaGFuZ2VhYmx5LiAgSWYgaXQncyBbZmFsc2VdLCB5b3UgaGF2ZSBubyBndWFyYW50ZWVzLiAgRm9yXG4gICAgICBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICA+IHV0b3BcbiAgICAgICAgb3BlbiBDb3JlOztcbiAgICAgICAgbGV0IGVxdWFsIChhIDogJ2EgSGFzaHRibF9pbnRmLkhhc2hhYmxlLnQpIGIgPVxuICAgICAgICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgICAgICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgICAgICAgOztcbiAgICAgICAgbGV0IGEgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBsZXQgYiA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGVxdWFsIGEgYjs7ICAoKiBmYWxzZT8hICopXG4gICAgICBdfVxuICAqKVxuICBsZXQgZXF1YWwgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGhhc2hfcGFyYW0gPSBDYW1sLkhhc2h0YmwuaGFzaF9wYXJhbVxuICBsZXQgaGFzaCA9IENhbWwuSGFzaHRibC5oYXNoXG4gIGxldCBwb2x5ID0geyBoYXNoOyBjb21wYXJlID0gUG9seS5jb21wYXJlOyBzZXhwX29mX3QgPSAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB9XG5cbiAgbGV0IG9mX2tleSAodHlwZSBhKSAobW9kdWxlIEtleSA6IEtleSB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICB7IGhhc2ggPSBLZXkuaGFzaDsgY29tcGFyZSA9IEtleS5jb21wYXJlOyBzZXhwX29mX3QgPSBLZXkuc2V4cF9vZl90IH1cbiAgOztcblxuICBsZXQgdG9fa2V5ICh0eXBlIGEpIHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH0gPVxuICAgIChtb2R1bGUgc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCBoYXNoID0gaGFzaFxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgZW5kIDogS2V5XG4gICAgICB3aXRoIHR5cGUgdCA9IGEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBIYXNoYWJsZVxuXG5tb2R1bGUgdHlwZSBIYXNoYWJsZSA9IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBIYXNoYWJsZS50ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICB2YWwgcG9seSA6ICdhIHRcbiAgdmFsIG9mX2tleSA6IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpIC0+ICdhIHRcbiAgdmFsIHRvX2tleSA6ICdhIHQgLT4gKG1vZHVsZSBLZXkgd2l0aCB0eXBlIHQgPSAnYSlcbiAgdmFsIGhhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+ICdhIC0+IGludFxuICB2YWwgaGFzaCA6ICdhIC0+IGludFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlX2ludGZcblxubW9kdWxlIE1ha2UgKFQgOiBBcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IEFyZ193aXRoX2NvbXBhcmF0b3IpID0gc3RydWN0XG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChUKVxuICBpbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXG5cbmxldCBnZXRfcG9zX2xlbiA/cG9zID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIHRyeSBSZXN1bHQuT2sgKGdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgcyAtPiBPcl9lcnJvci5lcnJvcl9zdHJpbmcgc1xuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IGEgc2VhcmNoIGZvciB0aGUgZmlyc3QgKHJlc3AuIGxhc3QpIGVsZW1lbnRcbiAgIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUsIGFzc3VtaW5nIHRoYXQgdGhlIHByZWRpY2F0ZSBpcyBpbmNyZWFzaW5nIG9uXG4gICB0aGUgY29udGFpbmVyLCBtZWFuaW5nIHRoYXQsIGlmIHRoZSBjb250YWluZXIgaXMgW3UxLi4udW5dLCB0aGVyZSBleGlzdHMgYVxuICAgayBzdWNoIHRoYXQgcCh1MSk9Li4uLj1wKHVrKSA9IGZhbHNlIGFuZCBwKHVrKzEpPS4uLi49cCh1bik9IHRydWUuXG4gICBJZiB0aGlzIGsgPSAxIChyZXNwIG4pLCBmaW5kX2xhc3Rfbm90X3NhdGlzZnlpbmcgKHJlc3AgZmluZF9maXJzdF9zYXRpc2Z5aW5nKVxuICAgd2lsbCByZXR1cm4gTm9uZS4gKilcblxubGV0IHJlYyBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICBpZiBsbyA+IGhpXG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHByZWQgKGdldCB0IGxvKVxuICB0aGVuIFNvbWUgbG9cbiAgZWxzZSBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobG8gKyAxKSB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGEgY29udGFpbmVyIFt0XSwgYSBwcmVkaWNhdGUgW3ByZWRdIGFuZCB0d28gaW5kaWNlcyBbbG8gPCBoaV0sIHN1Y2ggdGhhdFxuICAgW3ByZWRdIGlzIGluY3JlYXNpbmcgb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXS5cblxuICAgcmV0dXJuIGEgcmFuZ2UgKGxvLCBoaSkgd2hlcmU6XG4gICAtIGxvIGFuZCBoaSBhcmUgY2xvc2UgZW5vdWdoIHRvZ2V0aGVyIGZvciBhIGxpbmVhciBzZWFyY2hcbiAgIC0gSWYgW3ByZWRdIGlzIG5vdCBjb25zdGFudGx5IFtmYWxzZV0gb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXSwgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgb24gd2hpY2ggW3ByZWRdIGlzIFt0cnVlXSBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uICopXG4oKiBJbnZhcmlhbnQ6IHRoZSBmaXJzdCBlbGVtZW50IHNhdGlzZnlpbmcgW3ByZWRdLCBpZiBpdCBleGlzdHMgaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldICopXG5sZXQgcmVjIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgKCogV2FybmluZzogdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0ZXJtaW5hdGUgaWYgdGhlIGNvbnN0YW50IChjdXJyZW50bHkgOCkgaXNcbiAgICAgc2V0IDw9IDEgKilcbiAgaWYgaGkgLSBsbyA8PSA4XG4gIHRoZW4gbG8sIGhpXG4gIGVsc2UgKFxuICAgIGxldCBtaWQgPSBsbyArICgoaGkgLSBsbykgLyAyKSBpblxuICAgIGlmIHByZWQgKGdldCB0IG1pZClcbiAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQgaXMgYmV0d2VlbiBbbG9dIGFuZCBbbWlkXSAqKVxuICAgIHRoZW5cbiAgICAgIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpOm1pZCB+cHJlZFxuICAgICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50LCBpZiBpdCBleGlzdHMsXG4gICAgICAgICBpcyBiZXR3ZWVuIFttaWQrMV0gYW5kIFtoaV0gKilcbiAgICBlbHNlIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KG1pZCArIDEpIH5oaSB+cHJlZClcbjs7XG5cbmxldCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGxldCBsbyA9IHBvcyBpblxuICBsZXQgaGkgPSBwb3MgKyBsZW4gLSAxIGluXG4gIGxldCBsbywgaGkgPSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCBpblxuICBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGFuIGFycmF5IHdpdGggc2hhcGUgW3RydWUsLi4udHJ1ZSxmYWxzZSwuLi5mYWxzZV0gKGkuZS4sIHRoZSBfcmV2ZXJzZV8gb2Ygd2hhdFxuICAgaXMgZGVzY3JpYmVkIGFib3ZlKSBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdHJ1ZSBvciBOb25lIGlmIHRoZXJlIGFyZSBub1xuICAgdHJ1ZSopXG5sZXQgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfnByZWQgfmdldCB+bGVuZ3RoID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgICgqIFRoZSBsYXN0IHNhdGlzZnlpbmcgaXMgdGhlIG9uZSBqdXN0IGJlZm9yZSB0aGUgZmlyc3Qgbm90IHNhdGlzZnlpbmcgKilcbiAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgfnBvcyB+bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihGbi5ub24gcHJlZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIChwb3MgKyBsZW4gLSAxKVxuICAgICgqIFRoaXMgbWVhbnMgdGhhdCBhbGwgZWxlbWVudHMgc2F0aXNmeSBwcmVkLlxuICAgICAgIFRoZXJlIGlzIGF0IGxlYXN0IGFuIGVsZW1lbnQgYXMgKGxlbiA+IDApICopXG4gICAgfCBTb21lIGkgd2hlbiBpID0gcG9zIC0+IE5vbmUgKCogbm8gZWxlbWVudCBzYXRpc2ZpZXMgcHJlZCAqKVxuICAgIHwgU29tZSBpIC0+IFNvbWUgKGkgLSAxKSlcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+Y29tcGFyZSBob3cgdiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8IDApXG4gIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMClcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnNlZ21lbnRfb2YgaG93ID1cbiAgbGV0IGlzX2xlZnQgeCA9XG4gICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICB8IGBSaWdodCAtPiBmYWxzZVxuICBpblxuICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX2xlZnRcbiAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19yaWdodFxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZV9pbnRmXG5cbm1vZHVsZSB0eXBlIEFyZyA9IHNpZ1xuICB0eXBlICdhIGVsdFxuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgZWx0XG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogQXJnKSA9IHN0cnVjdFxuICBsZXQgZ2V0ID0gVC5nZXRcbiAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIEJpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfmNvbXBhcmUgaG93IHZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+c2VnbWVudF9vZiBob3dcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICdhIGVsdCA9IFQuZWx0XG4gICAgdHlwZSAnYSB0ID0gVC50XG4gIGVuZClcblxubW9kdWxlIE1ha2UxIChUIDogSW5kZXhhYmxlMSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIHR5cGUgJ2EgdCA9ICdhIFQudFxuXG4gICAgbGV0IGdldCA9IFQuZ2V0XG4gICAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCbGl0X2ludGZcblxubW9kdWxlIHR5cGUgU2VxdWVuY2VfZ2VuID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuXG4gICAgKFNyYyA6IFNlcXVlbmNlX2dlbikgKERzdCA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIFNyYy50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgU3JjLnQsICdhIHQpIGJsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IHVuc2FmZV9ibGl0ID0gRHN0LnVuc2FmZV9ibGl0XG5cbiAgbGV0IGJsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6c3JjX3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG5cbiAgICAgIH5wb3M6ZHN0X3Bvc1xuICAgICAgfmxlblxuICAgICAgfnRvdGFsX2xlbmd0aDooRHN0Lmxlbmd0aCBkc3QpO1xuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlblxuICA7O1xuXG4gIGxldCBibGl0b1xuICAgICAgICB+c3JjXG4gICAgICAgID8oc3JjX3BvcyA9IDApXG4gICAgICAgID8oc3JjX2xlbiA9IFNyYy5sZW5ndGggc3JjIC0gc3JjX3BvcylcbiAgICAgICAgfmRzdFxuICAgICAgICA/KGRzdF9wb3MgPSAwKVxuICAgICAgICAoKVxuICAgID1cbiAgICBibGl0IH5zcmMgfnNyY19wb3MgfmxlbjpzcmNfbGVuIH5kc3QgfmRzdF9wb3NcbiAgOztcblxuICAoKiBbc3ViXSBhbmQgW3N1Ym9dIGVuc3VyZSB0aGF0IGV2ZXJ5IHBvc2l0aW9uIG9mIHRoZSBjcmVhdGVkIHNlcXVlbmNlIGlzIHBvcHVsYXRlZCBieVxuICAgICBhbiBlbGVtZW50IG9mIHRoZSBzb3VyY2UgYXJyYXkuICBUaHVzIGV2ZXJ5IGVsZW1lbnQgb2YgW2RzdF0gYmVsb3cgaXMgd2VsbFxuICAgICBkZWZpbmVkLiAqKVxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBsZXQgZHN0ID0gRHN0LmNyZWF0ZV9saWtlIH5sZW4gc3JjIGluXG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3M6cG9zIH5kc3QgfmRzdF9wb3M6MCB+bGVuO1xuICAgIGRzdFxuICA7O1xuXG4gIGxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICAgIHN1YlxuICAgICAgc3JjXG4gICAgICB+cG9zXG4gICAgICB+bGVuOlxuICAgICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICAgIHwgTm9uZSAtPiBTcmMubGVuZ3RoIHNyYyAtIHBvcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTEgKFNlcXVlbmNlIDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIGJsaXRcbiAgZW5kKSA9XG4gIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZTFfZ2VuZXJpYyAoU2VxdWVuY2UgOiBTZXF1ZW5jZTEpID0gTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlIChTZXF1ZW5jZSA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAodCwgdCkgYmxpdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgU2VxdWVuY2UgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSBTZXF1ZW5jZS50XG5cbiAgICBvcGVuIFNlcXVlbmNlXG5cbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcbmVuZFxuXG5tb2R1bGUgTWFrZV9kaXN0aW5jdFxuICAgIChTcmMgOiBTZXF1ZW5jZSkgKERzdCA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiB0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgdW5zYWZlX2JsaXQgOiAoU3JjLnQsIHQpIGJsaXRcbiAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbiAgTWFrZV9nZW5cbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBTcmMudFxuXG4gICAgICBvcGVuIFNyY1xuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IERzdC50XG5cbiAgICAgIG9wZW4gRHN0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgICBlbmQpXG5cbm1vZHVsZSBNYWtlX3RvX3N0cmluZyAoVCA6IHNpZ1xuICAgIHR5cGUgdFxuICBlbmQpXG4gICAgKFRvX2J5dGVzIDogU19kaXN0aW5jdCB3aXRoIHR5cGUgc3JjIDo9IFQudCB3aXRoIHR5cGUgZHN0IDo9IGJ5dGVzKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUb19ieXRlc1xuXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KHN1YiBzcmMgfnBvcyB+bGVuKVxuICA7O1xuXG4gIGxldCBzdWJvID9wb3MgP2xlbiBzcmMgPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWJvID9wb3MgP2xlbiBzcmMpXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbnN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb24gW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9vcHRpb25cblxuICBsZXQgaGFzaF9mb2xkX3QgOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgaGFzaF9mb2xkX29wdGlvblxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICAgIG9wdGlvbl9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgc2V4cF9vZl9vcHRpb25cbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IG9wdGlvbl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmQgOlxuc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvbiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPVxuICB8IE5vbmVcbiAgfCBTb21lIG9mICdhXG5cbmxldCBpc19ub25lID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgdmFsdWVfbWFwIG8gfmRlZmF1bHQgfmYgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBTb21lIHggLT4gZiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0XG47O1xuXG5sZXQgaXRlciBvIH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgYSAtPiBmIGFcbjs7XG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5cbmxldCBjYWxsIHggfmYgPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBmIC0+IGYgeFxuOztcblxubGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGRlZmF1bHRcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IHZhbHVlX2V4biA/aGVyZSA/ZXJyb3IgP21lc3NhZ2UgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPlxuICAgIGxldCBlcnJvciA9XG4gICAgICBtYXRjaCBoZXJlLCBlcnJvciwgbWVzc2FnZSB3aXRoXG4gICAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT4gRXJyb3Iub2Zfc3RyaW5nIFwiT3B0aW9uLnZhbHVlX2V4biBOb25lXCJcbiAgICAgIHwgTm9uZSwgTm9uZSwgU29tZSBtIC0+IEVycm9yLm9mX3N0cmluZyBtXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgTm9uZSAtPiBlXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgU29tZSBtIC0+IEVycm9yLnRhZyBlIH50YWc6bVxuICAgICAgfCBTb21lIHAsIE5vbmUsIE5vbmUgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIFwiT3B0aW9uLnZhbHVlX2V4blwiIHAgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdFxuICAgICAgfCBTb21lIHAsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5jcmVhdGUgbSBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBTb21lIGUsIF8gLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgKHZhbHVlIG1lc3NhZ2UgfmRlZmF1bHQ6XCJcIilcbiAgICAgICAgICAoZSwgcClcbiAgICAgICAgICAoc2V4cF9vZl9wYWlyIEVycm9yLnNleHBfb2ZfdCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90KVxuICAgIGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCB2YWx1ZV9vcl90aHVuayBvIH5kZWZhdWx0ID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IHhcbiAgfCBOb25lIC0+IGRlZmF1bHQgKClcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbfHxdXG4gIHwgU29tZSB4IC0+IFt8IHggfF1cbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSB4IC0+IFsgeCBdXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlOl8gPSB0XG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlOl8gPSB0XG5cbmxldCBzdW0gKHR5cGUgYSkgKG1vZHVsZSBNIDogQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIHZhbHVlX21hcCB0IH5kZWZhdWx0Ok0uemVybyB+ZlxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCAtPiBmIHhcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSBhJyAtPiBlcXVhbCBhIGEnXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIF8gLT4gMVxuOztcblxubGV0IGlzX2VtcHR5ID0gaXNfbm9uZVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBpbml0XG4gIHwgU29tZSB4IC0+IGYgaW5pdCB4XG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgYSAtPiBpZiBmIGEgdGhlbiAxIGVsc2UgMFxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgeCAtPiBpZiBmIHggdGhlbiB0IGVsc2UgTm9uZVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgZXF1YWwgZiB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCwgU29tZSB4JyAtPiBmIHggeCdcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgc29tZSB4ID0gU29tZSB4XG5cbmxldCBmaXJzdF9zb21lIHggeSA9XG4gIG1hdGNoIHggd2l0aFxuICB8IFNvbWUgXyAtPiB4XG4gIHwgTm9uZSAtPiB5XG47O1xuXG5sZXQgc29tZV9pZiBjb25kIHggPSBpZiBjb25kIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuXG5sZXQgbWVyZ2UgYSBiIH5mID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgTm9uZSwgeCB8IHgsIE5vbmUgLT4geFxuICB8IFNvbWUgYSwgU29tZSBiIC0+IFNvbWUgKGYgYSBiKVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU29tZSB2IGFzIG8gd2hlbiBmIHYgLT4gb1xuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHRyeV93aXRoIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gU29tZSAoZiBhKVxuOztcblxubGV0IGFwcGx5IGYgeCA9XG4gIG1hdGNoIGYgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgZiAtPiBtYXAgfmYgeFxuOztcblxubW9kdWxlIE1vbmFkX2FyZyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgcmV0dXJuIHggPSBTb21lIHhcbiAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5cbiAgbGV0IGJpbmQgbyB+ZiA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBmIHhcbiAgOztcbmVuZFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKE1vbmFkX2FyZylcbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoTW9uYWRfYXJnKVxuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlXG5cbm1vZHVsZSBPZl9zZXhwYWJsZVxuICAgIChTZXhwYWJsZSA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiB0IC0+IFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiBTZXhwYWJsZS50IC0+IHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMgd2l0aCB0eXBlIHQgOj0gTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cGFibGUuc2V4cF9vZl90IChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMVxuICAgIChTZXhwYWJsZSA6IFMxKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICdhIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAnYSB0IC0+ICdhIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogJ2EgU2V4cGFibGUudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTJcbiAgICAoU2V4cGFibGUgOiBTMikgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IpIFNleHBhYmxlLnQgLT4gKCdhLCAnYikgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2IgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUzXG4gICAgKFNleHBhYmxlIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgU2V4cGFibGUudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBjX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgKE0udG9fc2V4cGFibGUgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgT2Zfc3RyaW5nYWJsZSAoTSA6IFN0cmluZ2FibGUuUykgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5BdG9tIHMgLT5cbiAgICAgICh0cnkgTS5vZl9zdHJpbmcgcyB3aXRoXG4gICAgICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHApXG4gICAgfCBTZXhwLkxpc3QgXyAtPlxuICAgICAgb2Zfc2V4cF9lcnJvclxuICAgICAgICBcIlNleHBhYmxlLk9mX3N0cmluZ2FibGUudF9vZl9zZXhwIGV4cGVjdGVkIGFuIGF0b20sIGJ1dCBnb3QgYSBsaXN0XCJcbiAgICAgICAgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAoTS50b19zdHJpbmcgdClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEVpdGhlcl9pbnRmXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEVpdGhlcjBcblxubGV0IHN3YXAgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gU2Vjb25kIHhcbiAgfCBTZWNvbmQgeCAtPiBGaXJzdCB4XG47O1xuXG5sZXQgaXNfZmlyc3QgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gdHJ1ZVxuICB8IFNlY29uZCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc2Vjb25kID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IGZhbHNlXG4gIHwgU2Vjb25kIF8gLT4gdHJ1ZVxuOztcblxubGV0IHZhbHVlIChGaXJzdCB4IHwgU2Vjb25kIHgpID0geFxuXG5sZXQgdmFsdWVfbWFwIHQgfmZpcnN0IH5zZWNvbmQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBGaXJzdCB4IC0+IGZpcnN0IHhcbiAgfCBTZWNvbmQgeCAtPiBzZWNvbmQgeFxuOztcblxubGV0IGl0ZXIgPSB2YWx1ZV9tYXBcblxubGV0IG1hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBGaXJzdCAoZmlyc3QgeClcbiAgfCBTZWNvbmQgeCAtPiBTZWNvbmQgKHNlY29uZCB4KVxuOztcblxubGV0IGZpcnN0IHggPSBGaXJzdCB4XG5sZXQgc2Vjb25kIHggPSBTZWNvbmQgeFxuXG5sZXQgZXF1YWwgZXExIGVxMiB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBlcTEgeCB5XG4gIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IGVxMiB4IHlcbiAgfCBGaXJzdCBfLCBTZWNvbmQgXyB8IFNlY29uZCBfLCBGaXJzdCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaW52YXJpYW50IGYgcyA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBmIHhcbiAgfCBTZWNvbmQgeSAtPiBzIHlcbjs7XG5cbm1vZHVsZSBNYWtlX2ZvY3VzZWQgKE0gOiBzaWdcbiAgICB0eXBlICgrJ2EsICsnYikgdFxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICAgIHZhbCBvdGhlciA6ICdiIC0+IChfLCAnYikgdFxuICAgIHZhbCBlaXRoZXIgOiAoJ2EsICdiKSB0IC0+IHJldHVybjooJ2EgLT4gJ2MpIC0+IG90aGVyOignYiAtPiAnYykgLT4gJ2NcblxuICAgIHZhbCBjb21iaW5lXG4gICAgICA6ICAoJ2EsICdkKSB0XG4gICAgICAtPiAoJ2IsICdkKSB0XG4gICAgICAtPiBmOignYSAtPiAnYiAtPiAnYylcbiAgICAgIC0+IG90aGVyOignZCAtPiAnZCAtPiAnZClcbiAgICAgIC0+ICgnYywgJ2QpIHRcblxuICAgIHZhbCBiaW5kIDogKCdhLCAnYikgdCAtPiBmOignYSAtPiAoJ2MsICdiKSB0KSAtPiAoJ2MsICdiKSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuICBvcGVuIFdpdGhfcmV0dXJuXG5cbiAgbGV0IG1hcCB0IH5mID0gYmluZCB0IH5mOihmdW4geCAtPiByZXR1cm4gKGYgeCkpXG5cbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGVuZClcblxuICBtb2R1bGUgQXBwID0gQXBwbGljYXRpdmUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGFwcGx5IHQxIHQyID0gYmluZCB0MSB+ZjooZnVuIGYgLT4gYmluZCB0MiB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKSlcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGVuZClcblxuICBpbmNsdWRlIEFwcFxuXG4gIGxldCBjb21iaW5lX2FsbCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyXG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZXR1cm46KGZ1biBfIC0+IG90aGVyX2xvb3AgZiBhY2MgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8pIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4geCAtPiByZXR1cm5fbG9vcCBmICh4IDo6IGFjYykgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgbyB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIFtdIHRzXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfYWxsX3VuaXQgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4gKCkgLT4gb3RoZXJfbG9vcCBmIGFjYyB0cylcbiAgICAgICAgICB+b3RoZXI6KGZ1biBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2MgbykgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXIgdCB+cmV0dXJuOihmdW4gKCkgLT4gcmV0dXJuX2xvb3AgZiB0cykgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgbyB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIHRzXG4gIDs7XG5cbiAgbGV0IHRvX29wdGlvbiB0ID0gZWl0aGVyIHQgfnJldHVybjpPcHRpb24uc29tZSB+b3RoZXI6KGZ1biBfIC0+IE5vbmUpXG4gIGxldCB2YWx1ZSB0IH5kZWZhdWx0ID0gZWl0aGVyIHQgfnJldHVybjpGbi5pZCB+b3RoZXI6KGZ1biBfIC0+IGRlZmF1bHQpXG5cbiAgbGV0IHdpdGhfcmV0dXJuIGYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gcmV0IC0+IG90aGVyIChmIChXaXRoX3JldHVybi5wcmVwZW5kIHJldCB+ZjpyZXR1cm4pKSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmlyc3QgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gZmlyc3RcbiAgICBsZXQgb3RoZXIgPSBzZWNvbmRcblxuICAgIGxldCBlaXRoZXIgdCB+cmV0dXJuIH5vdGhlciA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRmlyc3QgeCAtPiByZXR1cm4geFxuICAgICAgfCBTZWNvbmQgeSAtPiBvdGhlciB5XG4gICAgOztcblxuICAgIGxldCBjb21iaW5lIHQxIHQyIH5mIH5vdGhlciA9XG4gICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChmIHggeSlcbiAgICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAob3RoZXIgeCB5KVxuICAgICAgfCBTZWNvbmQgeCwgXyB8IF8sIFNlY29uZCB4IC0+IFNlY29uZCB4XG4gICAgOztcblxuICAgIGxldCBiaW5kIHQgfmYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpcnN0IHggLT4gZiB4XG4gICAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbi4gKilcbiAgICAgIHwgU2Vjb25kIF8gYXMgeSAtPiB5XG4gICAgOztcbiAgZW5kKVxuXG5tb2R1bGUgU2Vjb25kID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gICAgbGV0IHJldHVybiA9IHNlY29uZFxuICAgIGxldCBvdGhlciA9IGZpcnN0XG5cbiAgICBsZXQgZWl0aGVyIHQgfnJldHVybiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFNlY29uZCB5IC0+IHJldHVybiB5XG4gICAgICB8IEZpcnN0IHggLT4gb3RoZXIgeFxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAoZiB4IHkpXG4gICAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKG90aGVyIHggeSlcbiAgICAgIHwgRmlyc3QgeCwgXyB8IF8sIEZpcnN0IHggLT4gRmlyc3QgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeCAtPiBmIHhcbiAgICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLCBsaWtlIFtGaXJzdC5iaW5kXSBhYm92ZS4gKilcbiAgICAgIHwgRmlyc3QgXyBhcyB5IC0+IHlcbiAgICA7O1xuICBlbmQpXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2YsICdzKSBfZWl0aGVyID0gKCdmLCAncykgdCA9XG4gICAgfCBGaXJzdCBvZiAnZlxuICAgIHwgU2Vjb25kIG9mICdzXG5lbmRcbiIsImluY2x1ZGUgSW5kZXhlZF9jb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5sZXQgaXRlcmkgfmZvbGQgdCB+ZiA9XG4gIGlnbm9yZVxuICAgIChmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIGkgeCAtPlxuICAgICAgIGYgaSB4O1xuICAgICAgIGkgKyAxKVxuICAgICA6IGludClcbjs7XG5cbmxldCBmb2xkaSB+Zm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgdiAtPlxuICAgIGxldCBhY2MgPSBmICFpIGFjYyB2IGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgYWNjKVxuOztcblxubGV0IGNvdW50aSB+Zm9sZGkgdCB+ZiA9IGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgbiBhIC0+IGlmIGYgaSBhIHRoZW4gbiArIDEgZWxzZSBuKVxuXG5sZXQgZXhpc3RzaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBmb3JfYWxsaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgbm90IChmIGkgeCkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBmaW5kX21hcGkgfml0ZXJpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgZmluZGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gKFNvbWUgKGksIHgpKSk7XG4gICAgTm9uZSlcbjs7XG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IHNpZ1xuICAgIGluY2x1ZGUgQ29udGFpbmVyX2ludGYuTWFrZV9nZW5fYXJnXG5cbiAgICB2YWwgaXRlcmkgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhIHQsICdhIGVsdCkgaXRlcmkgXVxuICAgIHZhbCBmb2xkaSA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAoJ2EgdCwgJ2EgZWx0LCBfKSBmb2xkaSBdXG4gIGVuZCkgOiBHZW5lcmljIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudCB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0ID0gc3RydWN0XG4gIGluY2x1ZGUgQ29udGFpbmVyLk1ha2VfZ2VuIChUKVxuXG4gIGxldCBpdGVyaSA9XG4gICAgbWF0Y2ggVC5pdGVyaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXJpIC0+IGl0ZXJpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlcmkgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBmb2xkaSA9XG4gICAgbWF0Y2ggVC5mb2xkaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGZvbGRpIC0+IGZvbGRpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmluaXQgfmYgLT4gZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9IGNvdW50aSB+Zm9sZGkgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gZXhpc3RzaSB+aXRlcmkgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IGZvcl9hbGxpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZGkgdCB+ZiA9IGZpbmRpIH5pdGVyaSB0IH5mXG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoVClcblxuICAoKiBOb3QgcGFydCBvZiBbQ29udGFpbmVyLkdlbmVyaWNdLiAqKVxuICBsZXQgbWVtID0gQy5tZW1cblxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA9IHN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlMCAoVClcblxuICAoKiBOb3QgcGFydCBvZiBbQ29udGFpbmVyLkdlbmVyaWNdLiAqKVxuICBsZXQgbWVtID0gQy5tZW1cblxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIGVuZClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBtYWludGFpbiB0aGUgcHJvcGVydHkgdGhhdCBhbGwgdmFsdWVzIG9mIHR5cGUgW3RdIGRvIG5vdCBoYXZlIHRoZSB0YWdcbiAgIFtkb3VibGVfYXJyYXlfdGFnXS4gIFNvbWUgZnVuY3Rpb25zIGJlbG93IGFzc3VtZSB0aGlzIGluIG9yZGVyIHRvIGF2b2lkIHRlc3RpbmcgdGhlXG4gICB0YWcsIGFuZCB3aWxsIHNlZ2ZhdWx0IGlmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBob2xkLiAqKVxudHlwZSB0ID0gQ2FtbC5PYmoudCBhcnJheVxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKENhbWwuT2JqLnRhZyAoQ2FtbC5PYmoucmVwciB0KSA8PiBDYW1sLk9iai5kb3VibGVfYXJyYXlfdGFnKVxubGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCAoKiB3b3VsZCBjaGVjayBmb3IgZmxvYXQgYXJyYXlzIGluIDMyIGJpdCwgYnV0IHdoYXRldmVyICopXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIFNleHAuQXRvbVxuICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBbIFwiPE9ial9hcnJheS50IG9mIGxlbmd0aCBcIjsgSW50LnRvX3N0cmluZyAobGVuZ3RoIHQpOyBcIj5cIiBdKVxuOztcblxubGV0IHplcm9fb2JqID0gQ2FtbC5PYmoucmVwciAoMCA6IGludClcblxuKCogV2UgY2FsbCBbQXJyYXkuY3JlYXRlXSB3aXRoIGEgdmFsdWUgdGhhdCBpcyBub3QgYSBmbG9hdCBzbyB0aGF0IHRoZSBhcnJheSBkb2Vzbid0IGdldFxuICAgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxubGV0IGNyZWF0ZV96ZXJvIH5sZW4gPSBBcnJheS5jcmVhdGUgfmxlbiB6ZXJvX29ialxubGV0IGVtcHR5ID0gW3x8XVxuXG50eXBlIG5vdF9hX2Zsb2F0ID1cbiAgfCBOb3RfYV9mbG9hdF8wXG4gIHwgTm90X2FfZmxvYXRfMSBvZiBpbnRcblxubGV0IF9ub3RfYV9mbG9hdF8wID0gTm90X2FfZmxvYXRfMFxubGV0IF9ub3RfYV9mbG9hdF8xID0gTm90X2FfZmxvYXRfMSA0MlxuXG5sZXQgZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAgSXQgaXMgTk9UIG9rIHRvIHVzZSBbaW50IGFycmF5XSBzaW5jZSAoaWZcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBpbmxpbmVkIGFuZCB0aGUgYXJyYXkgY29udGFpbnMgaW4taGVhcCBib3hlZCB2YWx1ZXMpIHdyb25nIHJlZ2lzdGVyXG4gICAgIHR5cGluZyBtYXkgcmVzdWx0LCBsZWFkaW5nIHRvIGEgZmFpbHVyZSB0byByZWdpc3RlciBuZWNlc3NhcnkgR0Mgcm9vdHMuICopXG4gIENhbWwuT2JqLnJlcHIgKChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxuICBDYW1sLk9iai5yZXByXG4gICAgKEFycmF5LnVuc2FmZV9nZXQgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkgaSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIFNhbWUgY29tbWVudCBhcyBbdW5zYWZlX2dldF0uIFN5cy5vcGFxdWVfaWRlbnRpdHkgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb21cbiAgICAgcG90ZW50aWFsbHkgd3JvbmdseSBndWVzc2luZyB0aGUgdHlwZSBvZiB0aGUgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgZWxlbWVudCwgdGhhdFxuICAgICBpcyBwcmV2ZW50IHRoZSBpbXBsaWNhdGlvbjogKE9iai50YWcgb2JqID0gT2JqLmRvdWJsZV90YWcpID0+IChPYmoudGFnIHQgPVxuICAgICBPYmouZG91YmxlX2FycmF5X3RhZykgd2hpY2ggZmxhbWJkYSBoYXMgdHJpZWQgaW4gdGhlIHBhc3QgKGF0IGxlYXN0IHRoYXQncyBhc3N1bWluZ1xuICAgICB0aGUgY29tcGlsZXIgcmVzcGVjdHMgU3lzLm9wYXF1ZV9pZGVudGl0eSwgd2hpY2ggaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KVxuICAgIGlcbiAgICAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIHNhbWUgYXMgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IGJ1dCBzYWZlICopXG4gIChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKVxuICA8LSAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50ID1cbiAgKCogVGhpcyBza2lwcyBbY2FtbF9tb2RpZnldLCB3aGljaCBpcyBPSyBpZiBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlIGludGVnZXJzLiAqKVxuICBBcnJheS51bnNhZmVfc2V0IChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogaW50IGFycmF5KSBpIChTeXMub3BhcXVlX2lkZW50aXR5IGludClcbjs7XG5cbigqIEZvciBbc2V0XSBhbmQgW3Vuc2FmZV9zZXRdLCBpZiBhIHBvaW50ZXIgaXMgaW52b2x2ZWQsIHdlIGZpcnN0IGRvIGEgcGh5c2ljYWwtZXF1YWxpdHlcbiAgIHRlc3QgdG8gc2VlIGlmIHRoZSBwb2ludGVyIGlzIGNoYW5naW5nLiAgSWYgbm90LCB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBbc2V0XSwgd2hpY2hcbiAgIHNhdmVzIGEgY2FsbCB0byBbY2FtbF9tb2RpZnldLiAgV2UgdGhpbmsgdGhpcyBwaHlzaWNhbC1lcXVhbGl0eSB0ZXN0IGlzIHdvcnRoIGl0XG4gICBiZWNhdXNlIGl0IGlzIHZlcnkgY2hlYXAgKGJvdGggdmFsdWVzIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSBmcm9tIHRoZSBbaXNfaW50XSB0ZXN0KVxuICAgYW5kIGJlY2F1c2UgW2NhbWxfbW9kaWZ5XSBpcyBleHBlbnNpdmUuICopXG5cbmxldCBzZXQgdCBpIG9iaiA9XG4gICgqIFdlIHVzZSBbZ2V0XSBmaXJzdCBidXQgdGhlbiB3ZSB1c2UgW0FycmF5LnVuc2FmZV9zZXRdIHNpbmNlIHdlIGtub3cgdGhhdCBbaV0gaXNcbiAgICAgdmFsaWQuICopXG4gIGxldCBvbGRfb2JqID0gZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXQgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGEgPSBnZXQgdCBpIGluXG4gIGxldCBiID0gZ2V0IHQgaiBpblxuICB1bnNhZmVfc2V0IHQgaSBiO1xuICB1bnNhZmVfc2V0IHQgaiBhXG47O1xuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gICgqIElmIHdlIGNhbiwgdXNlIFtBcnJheS5jcmVhdGVdIGRpcmVjdGx5LiAqKVxuICBpZiBDYW1sLk9iai50YWcgeCA8PiBDYW1sLk9iai5kb3VibGVfdGFnXG4gIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4geFxuICBlbHNlIChcbiAgICAoKiBPdGhlcndpc2UgdXNlIFtjcmVhdGVfemVyb10gYW5kIHNldCB0aGUgY29udGVudHMgKilcbiAgICBsZXQgdCA9IGNyZWF0ZV96ZXJvIH5sZW4gaW5cbiAgICBsZXQgeCA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHhcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIG9iaiA9IGNyZWF0ZSB+bGVuOjEgb2JqXG5cbigqIFByZS1jb25kaXRpb246IHQuKGkpIGlzIGFuIGludGVnZXIuICopXG5sZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBvYmogPVxuICBpZiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2VcbiAgICAoKiBbdC4oaSldIGlzIGFuIGludGVnZXIgYW5kIFtvYmpdIGlzIG5vdCwgc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaWYgdGhleSBhcmVcbiAgICAgICBlcXVhbC4gKilcbiAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHVuc2FmZV9zZXRfaW50IHQgaSBpbnQgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50XG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciBpbnQpXG47O1xuXG5sZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgdCBpID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBub3QgKENhbWwuT2JqLmlzX2ludCBvbGRfb2JqKSB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgMClcbjs7XG5cbigqKiBbdW5zYWZlX2JsaXRdIGlzIGxpa2UgW0FycmF5LmJsaXRdLCBleGNlcHQgaXQgdXNlcyBvdXIgb3duIGZvci1sb29wIHRvIGF2b2lkXG4gICAgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZS4gIEl0cyBwZXJmb3JtYW5jZSBpcyBzdGlsbCBub3QgY29tcGFyYWJsZSB0byBhIG1lbWNweS4gKilcbmxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICgqIFdoZW4gW3BoeXNfZXF1YWwgc3JjIGRzdF0sIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBbZHN0X3BvcyA8IHNyY19wb3NdIGFuZCBoYXZlIHRoZVxuICAgICBmb3IgbG9vcCBnbyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGRhdGEgdGhhdCB3ZSBzdGlsbCBuZWVkXG4gICAgIHRvIHJlYWQuICBXaGVuIFtub3QgKHBoeXNfZXF1YWwgc3JjIGRzdCldLCBkb2luZyB0aGlzIGlzIGhhcm1sZXNzLiAgRnJvbSBhXG4gICAgIG1lbW9yeS1wZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSwgaXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciBvbmUgbG9vcHMgdXAgb3IgZG93bi5cbiAgICAgQ29uc3RhbnQtc3RyaWRlIGFjY2VzcywgZm9yd2FyZCBvciBiYWNrd2FyZCwgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIChhdCBsZWFzdCBvblxuICAgICBhbiBpbnRlbCBpNykuICBTbywgd2UgZG9uJ3QgZG8gYSBjaGVjayBmb3IgW3BoeXNfZXF1YWwgc3JjIGRzdF0gYW5kIGFsd2F5cyBsb29wIHVwIGluXG4gICAgIHRoYXQgY2FzZS4gKilcbiAgaWYgZHN0X3BvcyA8IHNyY19wb3NcbiAgdGhlblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbiAgZWxzZVxuICAgIGZvciBpID0gbGVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG47O1xuXG5pbmNsdWRlIEJsaXQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVfemVyb1xuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGVfemVybyB+bGVuOihsZW5ndGggc3JjKSBpblxuICBibGl0byB+c3JjIH5kc3QgKCk7XG4gIGRzdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBXQVJOSU5HOlxuICAgV2UgdXNlIG5vbi1tZW1vcnktc2FmZSB0aGluZ3MgdGhyb3VnaG91dCB0aGUgW1RydXN0ZWRdIG1vZHVsZS5cbiAgIE1vc3Qgb2YgaXQgaXMgb25seSBzYWZlIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHR5cGUgc2lnbmF0dXJlIChlLmcuIGV4cG9zaW5nXG4gICBbdmFsIGNvcHkgOiAnYSB0IC0+ICdiIHRdIHdvdWxkIGJlIGEgYmlnIG1pc3Rha2UpLiAqKVxubW9kdWxlIFRydXN0ZWQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGVfb2JqX2FycmF5IDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzd2FwIDogXyB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX2dldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCB1bnNhZmVfc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHNldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIEJsaXQuYmxpdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgOiBfIHQgLT4gaW50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBPYmpfYXJyYXkudFxuXG4gIGxldCBlbXB0eSA9IE9ial9hcnJheS5lbXB0eVxuICBsZXQgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlX29ial9hcnJheSB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZSB+bGVuIHggPSBPYmpfYXJyYXkuY3JlYXRlIH5sZW4gKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHNpbmdsZXRvbiB4ID0gT2JqX2FycmF5LnNpbmdsZXRvbiAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgc3dhcCB0IGkgaiA9IE9ial9hcnJheS5zd2FwIHQgaSBqXG4gIGxldCBnZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS5nZXQgYXJyIGkpXG4gIGxldCBzZXQgYXJyIGkgeCA9IE9ial9hcnJheS5zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9nZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS51bnNhZmVfZ2V0IGFyciBpKVxuICBsZXQgdW5zYWZlX3NldCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9zZXRfaW50IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnQgYXJyIGkgeFxuXG4gIGxldCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHhcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgbGVuZ3RoID0gT2JqX2FycmF5Lmxlbmd0aFxuICBsZXQgdW5zYWZlX2JsaXQgPSBPYmpfYXJyYXkudW5zYWZlX2JsaXRcbiAgbGV0IGNvcHkgPSBPYmpfYXJyYXkuY29weVxuXG4gIGxldCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID0gT2JqX2FycmF5LnNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgPSBPYmpfYXJyYXkudW5zYWZlX2NsZWFyX2lmX3BvaW50ZXJcbmVuZFxuXG5pbmNsdWRlIFRydXN0ZWRcblxubGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChDYW1sLk9iai50YWcgKENhbWwuT2JqLnJlcHIgdCkgPD4gQ2FtbC5PYmouZG91YmxlX2FycmF5X3RhZylcblxubGV0IGluaXQgbCB+ZiA9XG4gIGlmIGwgPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJVbmlmb3JtX2FycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46bCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG9mX2FycmF5IGFyciA9IGluaXQgfmY6KEFycmF5LnVuc2FmZV9nZXQgYXJyKSAoQXJyYXkubGVuZ3RoIGFycilcbmxldCBtYXAgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKVxubGV0IG1hcGkgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgaSAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpXG5cbmxldCBpdGVyIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBmb2xkaSBhIH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5pbml0IH5mOihnZXQgdCkgKGxlbmd0aCB0KVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgeCAtPiBzZXQgcmVzIGkgeCk7XG4gIHJlc1xuOztcblxuKCogSXQgaXMgbm90IHNhZmUgZm9yIFt0b19hcnJheV0gdG8gYmUgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBjb2RlIHRoYXRcbiAgIHJlbGllcyBvbiBbZmxvYXQgYXJyYXldcyBiZWluZyB1bmJveGVkLCBmb3IgZXhhbXBsZSBpbiBbYmluX3dyaXRlX2FycmF5XS4gKilcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBmYWxzZSBlbHNlIGYgKHVuc2FmZV9nZXQgdCBpKSB8fCBsb29wIHQgfmYgKGkgLSAxKVxuICBpblxuICBsb29wIHQgfmYgKGxlbmd0aCB0IC0gMSlcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiBpID0gaWYgaSA8IDAgdGhlbiB0cnVlIGVsc2UgZiAodW5zYWZlX2dldCB0IGkpICYmIGxvb3AgdCB+ZiAoaSAtIDEpIGluXG4gIGxvb3AgdCB+ZiAobGVuZ3RoIHQgLSAxKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0MSBpblxuICBpZiBsZW5ndGggdDIgPD4gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyX2V4blwiO1xuICBpbml0IGxlbiB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChncmFtbWFyIDogZWx0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGVsdCB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoQXJyYXkudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmluY2x1ZGVcbiAgU2V4cGFibGUuT2Zfc2V4cGFibGUxXG4gICAgKEFycmF5KVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX2FycmF5XG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9hcnJheVxuICAgIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIGVtcHR5XG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgICBjcmVhdGUgfmxlbiAoZ2V0IHQgMCkpXG4gICAgOztcblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHB4X2NvbXBhcmUgW2NvbXBhcmVfYXJyYXldIGJ1dCB1c2VzIG91ciBbdW5zYWZlX2dldF0gYW5kIFtsZW5ndGhdLiAqKVxubGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgYSBiID1cbiAgaWYgcGh5c19lcXVhbCBhIGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIGxldCBsZW5fYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gbGVuZ3RoIGIgaW5cbiAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgIGlmIHJldCA8PiAwXG4gICAgdGhlbiByZXRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgaWYgaSA9IGxlbl9hXG4gICAgICAgIHRoZW4gMFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbCA9IHVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgYW5kIHIgPSB1bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCBsIHIgaW5cbiAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIDApKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogWydhIENoZWFwX29wdGlvbi50XSBpcyBsaWtlIFsnYSBvcHRpb25dLCBidXQgaXQgZG9lc24ndCBib3ggW3NvbWUgX10gdmFsdWVzLlxuXG4gICAgVGhlcmUgYXJlIHNldmVyYWwgdGhpbmdzIHRoYXQgYXJlIHVuc2FmZSBhYm91dCBpdDpcblxuICAgIC0gW2Zsb2F0IHQgYXJyYXldIChvciBhbnkgYXJyYXktYmFja2VkIGNvbnRhaW5lcikgaXMgbm90IG1lbW9yeS1zYWZlXG4gICAgICBiZWNhdXNlIGZsb2F0IGFycmF5IG9wdGltaXphdGlvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB1bmJveGVkIG9wdGlvblxuICAgICAgb3B0aW1pemF0aW9uLiBZb3UgaGF2ZSB0byB1c2UgW1VuaWZvcm1fYXJyYXkudF0gaW5zdGVhZCBvZiBbYXJyYXldLlxuXG4gICAgLSBOZXN0ZWQgb3B0aW9ucyAoWydhIHQgdF0pIGRvbid0IHdvcmsuIFRoZXkgYXJlIGJlbGlldmVkIHRvIGJlXG4gICAgICBtZW1vcnktc2FmZSwgYnV0IG5vdCBwYXJhbWV0cmljLlxuXG4gICAgLSBBIHJlY29yZCB3aXRoIFtmbG9hdCB0XXMgaW4gaXQgc2hvdWxkIGJlIHNhZmUsIGJ1dCBpdCdzIG9ubHkgW3RdIGJlaW5nXG4gICAgICBhYnN0cmFjdCB0aGF0IGdpdmVzIHlvdSBzYWZldHkuIElmIHRoZSBjb21waWxlciB3YXMgc21hcnQgZW5vdWdoIHRvIHBlZWtcbiAgICAgIHRocm91Z2ggdGhlIG1vZHVsZSBzaWduYXR1cmUgdGhlbiBpdCBjb3VsZCBkZWNpZGUgdG8gY29uc3RydWN0IGEgZmxvYXRcbiAgICAgIGFycmF5IGluc3RlYWQuICopXG5tb2R1bGUgQ2hlYXBfb3B0aW9uID0gc3RydWN0XG4gICgqIFRoaXMgaXMgdGFrZW4gZnJvbSBjb3JlLiBSYXRoZXIgdGhhbiBleHBvc2UgaXQgaW4gdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb2YgYmFzZSwganVzdFxuICAgICBrZWVwIGEgY29weSBhcm91bmQgaGVyZS4gKilcbiAgbGV0IHBoeXNfc2FtZSAodHlwZSBhIGIpIChhIDogYSkgKGIgOiBiKSA9IHBoeXNfZXF1YWwgYSAoQ2FtbC5PYmoubWFnaWMgYiA6IGEpXG5cbiAgbW9kdWxlIFQwIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbm9uZSA6IF8gdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBpc19ub25lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfc29tZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgdmFsdWVfdW5zYWZlIDogJ2EgdCAtPiAnYVxuICAgIHZhbCBpdGVyX3NvbWUgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSArJ2EgdFxuXG4gICAgKCogQmVpbmcgYSBwb2ludGVyLCBubyBvbmUgb3V0c2lkZSB0aGlzIG1vZHVsZSBjYW4gY29uc3RydWN0IGEgdmFsdWUgdGhhdCBpc1xuICAgICAgIFtwaHlzX3NhbWVdIGFzIHRoaXMgb25lLlxuXG4gICAgICAgSXQgd291bGQgYmUgc2ltcGxlciB0byB1c2UgdGhpcyB2YWx1ZSBhcyBbbm9uZV0sIGJ1dCB3ZSB1c2UgYW4gaW1tZWRpYXRlIGluc3RlYWRcbiAgICAgICBiZWNhdXNlIGl0IGxldHMgdXMgYXZvaWQgY2FtbF9tb2RpZnkgd2hlbiBzZXR0aW5nIHRvIFtub25lXSwgbWFraW5nIGNlcnRhaW5cbiAgICAgICBiZW5jaG1hcmtzIHNpZ25pZmljYW50bHkgZmFzdGVyIChlLmcuIC4uL2JlbmNoL2FycmF5X3F1ZXVlLmV4ZSkuXG5cbiAgICAgICB0aGlzIGNvZGUgaXMgZHVwbGljYXRlZCBpbiBNb3B0aW9uLCBhbmQgaWYgd2UgZmluZCB5ZXQgYW5vdGhlciBwbGFjZSB3aGVyZSB3ZSB3YW50XG4gICAgICAgaXQgd2Ugc2hvdWxkIHJlY29uc2lkZXIgbWFraW5nIGl0IHNoYXJlZC4gKilcbiAgICBsZXQgbm9uZV9zdWJzdGl0dXRlIDogXyB0ID0gQ2FtbC5PYmoub2JqIChDYW1sLk9iai5uZXdfYmxvY2sgQ2FtbC5PYmouYWJzdHJhY3RfdGFnIDEpXG5cbiAgICBsZXQgbm9uZSA6IF8gdCA9XG4gICAgICAoKiBUaGUgbnVtYmVyIHdhcyBwcm9kdWNlZCBieVxuICAgICAgICAgWzwgL2Rldi91cmFuZG9tIHRyIC1jIC1kICcxMjM0NTY3ODkwYWJjZGVmJyB8IGhlYWQgLWMgMTZdLlxuXG4gICAgICAgICBUaGUgaWRlYSBpcyB0aGF0IGEgcmFuZG9tIG51bWJlciB3aWxsIGhhdmUgbG93ZXIgcHJvYmFiaWxpdHkgdG8gY29sbGlkZSB3aXRoXG4gICAgICAgICBhbnl0aGluZyB0aGFuIGFueSBudW1iZXIgd2UgY2FuIGNob29zZSBvdXJzZWx2ZXMuXG5cbiAgICAgICAgIFdlIGFyZSB1c2luZyBhIHBvbHltb3JwaGljIHZhcmlhbnQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyIGNvbnN0YW50IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgIGlzIGEgY29tcGlsZXIgYnVnIHdoZXJlIGl0IHdyb25nbHkgYXNzdW1lcyB0aGF0IHRoZSByZXN1bHQgb2YgW2lmIF8gdGhlbiBjIGVsc2VcbiAgICAgICAgIHldIGlzIG5vdCBhIHBvaW50ZXIgaWYgW2NdIGlzIGFuIGludGVnZXIgY29tcGlsZS10aW1lIGNvbnN0YW50LiAgVGhpcyBpcyBiZWluZ1xuICAgICAgICAgZml4ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL3B1bGwvNTU1LiAgVGhlIFwibWVtb3J5IGNvcnJ1cHRpb25cIiB0ZXN0XG4gICAgICAgICBiZWxvdyBkZW1vbnN0cmF0ZXMgdGhlIGlzc3VlLiAgKilcbiAgICAgIENhbWwuT2JqLm1hZ2ljIGB4NmU4ZWUzNDc4ZTFkNzQ0OVxuICAgIDs7XG5cbiAgICBsZXQgaXNfbm9uZSB4ID0gcGh5c19lcXVhbCB4IG5vbmVcbiAgICBsZXQgaXNfc29tZSB4ID0gbm90IChwaHlzX2VxdWFsIHggbm9uZSlcblxuICAgIGxldCBzb21lICh0eXBlIGEpICh4IDogYSkgOiBhIHQgPVxuICAgICAgaWYgcGh5c19zYW1lIHggbm9uZSB0aGVuIG5vbmVfc3Vic3RpdHV0ZSBlbHNlIENhbWwuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX3Vuc2FmZSAodHlwZSBhKSAoeCA6IGEgdCkgOiBhID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgeCBub25lX3N1YnN0aXR1dGUgdGhlbiBDYW1sLk9iai5tYWdpYyBub25lIGVsc2UgQ2FtbC5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfZXhuIHggPVxuICAgICAgaWYgaXNfc29tZSB4XG4gICAgICB0aGVuIHZhbHVlX3Vuc2FmZSB4XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiT3B0aW9uX2FycmF5LmdldF9zb21lX2V4bjogdGhlIGVsZW1lbnQgaXMgW05vbmVdXCJcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXJfc29tZSB0IH5mID0gaWYgaXNfc29tZSB0IHRoZW4gZiAodmFsdWVfdW5zYWZlIHQpXG4gIGVuZFxuXG4gIG1vZHVsZSBUMSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcblxuICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IG5vbmVcbiAgICAgIHwgU29tZSB4IC0+IHNvbWUgeFxuICAgIDs7XG5cbiAgICBsZXRbQGlubGluZV0gdG9fb3B0aW9uIHggPSBpZiBpc19zb21lIHggdGhlbiBTb21lICh2YWx1ZV91bnNhZmUgeCkgZWxzZSBOb25lXG4gICAgbGV0IHRvX3NleHBhYmxlID0gdG9fb3B0aW9uXG4gICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfb3B0aW9uXG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKE9wdGlvbi50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuICAgIDs7XG4gIGVuZFxuXG4gIGluY2x1ZGUgVDFcbiAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZTEgKE9wdGlvbikgKFQxKVxuZW5kXG5cbnR5cGUgJ2EgdCA9ICdhIENoZWFwX29wdGlvbi50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMDFfIHhfXzAwM18gLT5cbiAgVW5pZm9ybV9hcnJheS50X29mX3NleHAgKENoZWFwX29wdGlvbi50X29mX3NleHAgX29mX2FfXzAwMV8pIHhfXzAwM19cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwNF8geF9fMDA1XyAtPlxuICBVbmlmb3JtX2FycmF5LnNleHBfb2ZfdCAoQ2hlYXBfb3B0aW9uLnNleHBfb2ZfdCBfb2ZfYV9fMDA0XykgeF9fMDA1X1xuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgVW5pZm9ybV9hcnJheS50X3NleHBfZ3JhbW1hciAoQ2hlYXBfb3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZW1wdHkgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG5sZXQgY3JlYXRlIH5sZW4gPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuIENoZWFwX29wdGlvbi5ub25lXG5sZXQgaW5pdCBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5vZl9vcHRpb24gKGYgaSkpXG5sZXQgaW5pdF9zb21lIG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLnNvbWUgKGYgaSkpXG5sZXQgbGVuZ3RoID0gVW5pZm9ybV9hcnJheS5sZW5ndGhcbmxldFtAaW5saW5lXSBnZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGdldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfbm9uZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBzZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCBzZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCBzZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBzd2FwIHQgaSBqID0gVW5pZm9ybV9hcnJheS5zd2FwIHQgaSBqXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9nZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcblxubGV0IHVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQgaSA9XG4gIENoZWFwX29wdGlvbi52YWx1ZV91bnNhZmUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG47O1xuXG5sZXQgdW5zYWZlX2lzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCB1bnNhZmVfc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHVuc2FmZV9zZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5cbmxldCBjbGVhciB0ID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXRfbm9uZSB0IGlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGlucHV0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBpbnB1dCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgaW5wdXQgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXIgaW5wdXQgfmYgPSBpdGVyaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSB4IC0+IGYgeClcblxubGV0IGZvbGRpIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IGFjYyA6PSBmIGkgIWFjYyBlbGVtKTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgaW5wdXQgfmluaXQgfmYgPSBmb2xkaSBpbnB1dCB+aW5pdCB+ZjooZnVuIChfIDogaW50KSBhY2MgeCAtPiBmIGFjYyB4KVxuXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyLk1ha2VfZ2VuIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2Egb3B0aW9uXG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IG1hcGkgaW5wdXQgfmYgPVxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW46KGxlbmd0aCBpbnB1dCkgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gdW5zYWZlX3NldCBvdXRwdXQgaSAoZiBpIGVsZW0pKTtcbiAgb3V0cHV0XG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSBlbGVtIC0+IGYgZWxlbSlcblxubGV0IG1hcF9zb21lIGlucHV0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dCBpblxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW4gaW5cbiAgbGV0ICgpID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IG9wdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCBpbnB1dCBpIGluXG4gICAgICBDaGVhcF9vcHRpb24uaXRlcl9zb21lIG9wdCB+ZjooZnVuIHggLT4gdW5zYWZlX3NldF9zb21lIG91dHB1dCBpIChmIHgpKVxuICAgIGRvbmVcbiAgaW5cbiAgb3V0cHV0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPSBpbml0IChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG5cbmxldCBvZl9hcnJheV9zb21lIGFycmF5ID1cbiAgaW5pdF9zb21lIChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMV9nZW5lcmljIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgY29weSA9IFVuaWZvcm1fYXJyYXkuY29weVxuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVuc2FmZV9jaGVhcF9vcHRpb24gPSBDaGVhcF9vcHRpb25cbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgY2VpbCA9IENhbWwuY2VpbFxubGV0IGZsb29yID0gQ2FtbC5mbG9vclxubGV0IG1vZF9mbG9hdCA9IENhbWwubW9kX2Zsb2F0XG5sZXQgbW9kZiA9IENhbWwubW9kZlxubGV0IGZsb2F0X29mX3N0cmluZyA9IENhbWwuZmxvYXRfb2Zfc3RyaW5nXG5sZXQgbmFuID0gQ2FtbC5uYW5cbmxldCBpbmZpbml0eSA9IENhbWwuaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBDYW1sLm5lZ19pbmZpbml0eVxubGV0IG1heF9maW5pdGVfdmFsdWUgPSBDYW1sLm1heF9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBDYW1sLmVwc2lsb25fZmxvYXRcbmxldCBjbGFzc2lmeV9mbG9hdCA9IENhbWwuY2xhc3NpZnlfZmxvYXRcbmxldCBhYnNfZmxvYXQgPSBDYW1sLmFic19mbG9hdFxubGV0IGlzX2ludGVnZXIgPSBDYW1sLkZsb2F0LmlzX2ludGVnZXJcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxuXG5sZXQgKCAlLiApIGEgYiA9XG4gICgqIFJhaXNlIGluIGNhc2Ugb2YgYSBuZWdhdGl2ZSBtb2R1bHVzLCBhcyBkb2VzIEludC4oICUgKS4gKilcbiAgaWYgYiA8IDAuXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIiVmICUlICVmIGluIGZsb2F0MC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIiBhIGIgKCk7XG4gIGxldCBtID0gQ2FtbC5tb2RfZmxvYXQgYSBiIGluXG4gICgqIFByb2R1Y2UgYSBub24tbmVnYXRpdmUgcmVzdWx0IGluIGFuYWxvZ3kgd2l0aCBJbnQuKCAlICkuICopXG4gIGlmIG0gPCAwLiB0aGVuIG0gKy4gYiBlbHNlIG1cbjs7XG5cbigqIFRoZSBiaXRzIG9mIElOUklBJ3MgW1BlcnZhc2l2ZXNdIHRoYXQgd2UganVzdCB3YW50IHRvIGV4cG9zZSBpbiBbRmxvYXRdLiBNb3N0IGFyZVxuICAgYWxyZWFkeSBkZXByZWNhdGVkIGluIFtQZXJ2YXNpdmVzXSwgYW5kIGV2ZW50dWFsbHkgYWxsIG9mIHRoZW0gc2hvdWxkIGJlLiAqKVxuaW5jbHVkZSAoXG4gIENhbWwgOlxuICBzaWdcbiAgICBleHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcblxuICAgIGV4dGVybmFsIGxkZXhwXG4gICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgICAgLT4gKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgID0gXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICBlbmQpXG5cbigqIFdlIG5lZWQgdGhpcyBpbmRpcmVjdGlvbiBiZWNhdXNlIHRoZXNlIGFyZSBleHBvc2VkIGFzIFwidmFsXCIgaW5zdGVhZCBvZiBcImV4dGVybmFsXCIgKilcbmxldCBmcmV4cCA9IGZyZXhwXG5sZXQgbGRleHAgPSBsZGV4cFxubGV0IGlzX25hbiB4ID0gKHggOiBmbG9hdCkgPD4geFxuXG4oKiBBbiBvcmRlci1wcmVzZXJ2aW5nIGJpamVjdGlvbiBiZXR3ZWVuIGFsbCBmbG9hdHMgZXhjZXB0IGZvciBOYU5zLCBhbmQgOTkuOTUlIG9mXG4gICBpbnQ2NHMuXG5cbiAgIE5vdGUgd2UgZG9uJ3QgZGlzdGluZ3Vpc2ggMC4gYW5kIC0wLiBhcyBzZXBhcmF0ZSB2YWx1ZXMgaGVyZSwgdGhleSBib3RoIG1hcCB0byAwTCwgd2hpY2hcbiAgIG1hcHMgYmFjayB0byAwLlxuXG4gICBUaGlzIHNob3VsZCB3b3JrIGJvdGggb24gbGl0dGxlLWVuZGlhbiBhbmQgaGlnaC1lbmRpYW4gQ1BVcy4gIFdpa2lwZWRpYSBzYXlzOiBcIm9uXG4gICBtb2Rlcm4gc3RhbmRhcmQgY29tcHV0ZXJzIChpLmUuLCBpbXBsZW1lbnRpbmcgSUVFRSA3NTQpLCBvbmUgbWF5IGluIHByYWN0aWNlIHNhZmVseVxuICAgYXNzdW1lIHRoYXQgdGhlIGVuZGlhbm5lc3MgaXMgdGhlIHNhbWUgZm9yIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYXMgZm9yIGludGVnZXJzXCJcbiAgIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VuZGlhbm5lc3MjRmxvYXRpbmctcG9pbnRfYW5kX2VuZGlhbm5lc3MpLlxuKilcbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0ID1cbiAgaWYgaXNfbmFuIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gKCogYWxzbyBpbmNsdWRlcyAtMC4gKilcbiAgICBTb21lIDBMXG4gIGVsc2UgaWYgdCA+IDAuXG4gIHRoZW4gU29tZSAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQpXG4gIGVsc2UgU29tZSAoQ2FtbC5JbnQ2NC5uZWcgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCAoLS50KSkpXG47O1xuXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIHggPSBPcHRpb24udmFsdWVfZXhuICh0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4KVxuXG5sZXQgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXIgeCA9XG4gIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgeCAwTFxuICB0aGVuIENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyB4XG4gIGVsc2Ugfi0uKENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyAoQ2FtbC5JbnQ2NC5uZWcgeCkpXG47O1xuXG5sZXQgb25lX3VscCBkaXIgdCA9XG4gIG1hdGNoIHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgd2l0aFxuICB8IE5vbmUgLT4gQ2FtbC5uYW5cbiAgfCBTb21lIHggLT5cbiAgICBvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlclxuICAgICAgKENhbWwuSW50NjQuYWRkXG4gICAgICAgICB4XG4gICAgICAgICAobWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICB8IGBVcCAtPiAxTFxuICAgICAgICAgIHwgYERvd24gLT4gLTFMKSlcbjs7XG5cbigqIFt1cHBlcl9ib3VuZF9mb3JfaW50XSBhbmQgW2xvd2VyX2JvdW5kX2Zvcl9pbnRdIGFyZSBmb3IgY2FsY3VsYXRpbmcgdGhlIG1heC9taW4gZmxvYXRcbiAgIHRoYXQgZml0cyBpbiBhIGdpdmVuLXNpemUgaW50ZWdlciB3aGVuIHJvdW5kZWQgdG93YXJkcyAwICh1c2luZyBbaW50X29mX2Zsb2F0XSkuXG5cbiAgIG1heF9pbnQvbWluX2ludCBkZXBlbmQgb24gW251bV9iaXRzXSwgZS5nLiArLy0gMl4zMCwgKy8tIDJeNjIgaWYgMzEtYml0LCA2My1iaXRcbiAgIChyZXNwZWN0aXZlbHkpIHdoaWxlIGZsb2F0IGlzIElFRUUgc3RhbmRhcmQgZm9yIGRvdWJsZSAoNTIgc2lnbmlmaWNhbnQgYml0cykuXG5cbiAgIEluIGFsbCBjYXNlcywgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdFxuICAgW2xvd2VyX2JvdW5kX2Zvcl9pbnQgPD0geCA8PSB1cHBlcl9ib3VuZF9mb3JfaW50XVxuICAgaWZmIFtpbnRfb2ZfZmxvYXQgeF0gZml0cyBpbiBhbiBpbnQgd2l0aCBbbnVtX2JpdHNdIGJpdHMuXG5cbiAgIFsyICoqIChudW1fYml0cyAtIDEpXSBpcyB0aGUgZmlyc3QgZmxvYXQgZ3JlYXRlciB0aGF0IG1heF9pbnQsIHdlIHVzZSB0aGUgcHJlY2VkaW5nXG4gICBmbG9hdCBhcyB1cHBlciBib3VuZC5cblxuICAgWy0gKDIgKiogKG51bV9iaXRzIC0gMSkpXSBpcyBlcXVhbCB0byBtaW5faW50LlxuICAgRm9yIGxvd2VyIGJvdW5kIHdlIGxvb2sgZm9yIHRoZSBzbWFsbGVzdCBmbG9hdCBbZl0gc2F0aXNmeWluZyBbZiA+IG1pbl9pbnQgLSAxXSBzbyB0aGF0XG4gICBbZl0gcm91bmRzIHRvd2FyZCB6ZXJvIHRvIFttaW5faW50XVxuXG4gICBTbyBpbiBwYXJ0aWN1bGFyIHdlIHdpbGwgaGF2ZTpcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IHggPD0gLSAoMiAqKiAoMS14KSldXG4gICBbdXBwZXJfYm91bmRfZm9yX2ludCB4ICA8ICAgIDIgKiogKDEteCkgXVxuKilcbmxldCB1cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzID1cbiAgbGV0IGV4cCA9IENhbWwuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIG9uZV91bHAgYERvd24gKDIuICoqIGV4cClcbjs7XG5cbmxldCBpc194X21pbnVzX29uZV9leGFjdCB4ID1cbiAgKCogW3ggPSB4IC0uIDEuXSBkb2VzIG5vdCB3b3JrIHdpdGggeDg3IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgYmFja2VuZCAod2hpY2ggaXMgdXNlZFxuICAgICBvbiAzMi1iaXQgb2NhbWwpIGJlY2F1c2Ugb2YgODAtYml0IHJlZ2lzdGVyIHByZWNpc2lvbiBvZiBpbnRlcm1lZGlhdGUgY29tcHV0YXRpb25zLlxuXG4gICAgIEFuIGFsdGVybmF0aXZlIHdheSBvZiBjb21wdXRpbmcgdGhpczogW3ggLS4gb25lX3VscCBgRG93biB4IDw9IDEuXSBpcyBhbHNvIHByb25lIHRvXG4gICAgIHRoZSBzYW1lIHByZWNpc2lvbiBpc3N1ZXM6IHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBbeF0gaXMgNjQtYml0LlxuICAqKVxuICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgbm90IChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgeCA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCAoeCAtLiAxLikpXG47O1xuXG5sZXQgbG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBDYW1sLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBsZXQgbWluX2ludF9hc19mbG9hdCA9IH4tLigyLiAqKiBleHApIGluXG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbnVtX2JpdHMgLSAxIDwgNTMgKCogNTMgPSAjYml0cyBpbiB0aGUgZmxvYXQncyBtYW50aXNzYSB3aXRoIHNpZ24gaW5jbHVkZWQgKilcbiAgdGhlbiAoXG4gICAgKCogVGhlIHNtYWxsZXN0IGZsb2F0IHRoYXQgcm91bmRzIHRvd2FyZHMgemVybyB0byBbbWluX2ludF0gaXNcbiAgICAgICBbbWluX2ludCAtIDEgKyBlcHNpbG9uXSAqKVxuICAgIGFzc2VydCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCk7XG4gICAgb25lX3VscCBgVXAgKG1pbl9pbnRfYXNfZmxvYXQgLS4gMS4pKVxuICBlbHNlIChcbiAgICAoKiBbbWluX2ludF9hc19mbG9hdF0gaXMgYWxyZWFkeSB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0uICopXG4gICAgYXNzZXJ0IChub3QgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpKTtcbiAgICBtaW5faW50X2FzX2Zsb2F0KVxuOztcblxuKCogRmxvYXQgY2xhbXBpbmcgaXMgc3RydWN0dXJlZCBzbGlnaHRseSBkaWZmZXJlbnRseSB0aGFuIGNsYW1waW5nIGZvciBvdGhlciB0eXBlcywgc29cbiAgIHRoYXQgd2UgZ2V0IHRoZSBiZWhhdmlvciBvZiBbY2xhbXBfdW5jaGVja2VkIG5hbiB+bWluIH5tYXggPSBuYW5dIChmb3IgYW55IFttaW5dIGFuZFxuICAgW21heF0pIGZvciBmcmVlLlxuKilcbmxldCBjbGFtcF91bmNoZWNrZWQgKHQgOiBmbG9hdCkgfm1pbiB+bWF4ID1cbiAgaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIG1heCA8IHQgdGhlbiBtYXggZWxzZSB0XG47O1xuXG5sZXQgYm94ID1cbiAgKCogUHJldmVudCBwb3RlbnRpYWwgY29uc3RhbnQgZm9sZGluZyBvZiBbKy4gMC5dIGluIHRoZSBuZWFyIG9jYW1sb3B0IGZ1dHVyZS4gKilcbiAgbGV0IHggPSBTeXMwLm9wYXF1ZV9pZGVudGl0eSAwLiBpblxuICBmdW4gZiAtPiBmICsuIHhcbjs7XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydDAuSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG4oKiBDb25zdHJ1Y3QgYSBieXRlIHN0cmluZyBvZiBsZW5ndGggMjU2LCBtYXBwaW5nIGV2ZXJ5IGlucHV0IGNoYXJhY3RlciBjb2RlIHRvXG4gICBpdHMgY29ycmVzcG9uZGluZyBvdXRwdXQgY2hhcmFjdGVyLlxuXG4gICBCZW5jaG1hcmtzIGluZGljYXRlIHRoYXQgdGhpcyBpcyBmYXN0ZXIgdGhhbiB0aGUgbGFtYmRhIChpbmNsdWRpbmcgY29zdCBvZlxuICAgdGhpcyBmdW5jdGlvbiksIGV2ZW4gaWYgdGFyZ2V0L3JlcGxhY2VtZW50IGFyZSBqdXN0IDIgY2hhcmFjdGVycyBlYWNoLlxuXG4gICBSZXR1cm4gTm9uZSBpZiB0aGUgdHJhbnNsYXRpb24gbWFwIGlzIGVxdWl2YWxlbnQgdG8ganVzdCB0aGUgaWRlbnRpdHkuICopXG5sZXQgdHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGxldCB0cl9tYXAgPSBCeXRlcy5jcmVhdGUgMjU2IGluXG4gIGZvciBpID0gMCB0byAyNTUgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAtIDEgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggKFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IGkpXG4gIGRvbmU7XG4gIGxldCBsYXN0X3JlcGxhY2VtZW50ID0gU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQgLSAxKSBpblxuICBmb3JcbiAgICBpID0gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIHRvIFN0cmluZy5sZW5ndGggdGFyZ2V0IC0gMVxuICBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCBsYXN0X3JlcGxhY2VtZW50XG4gIGRvbmU7XG4gIGxldCByZWMgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCBpID1cbiAgICBpZiBpID0gMjU2XG4gICAgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCBpKSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIChpICsgMSlcbiAgaW5cbiAgKCogcXVpY2sgY2hlY2sgb24gdGhlIGZpcnN0IHRhcmdldCBjaGFyYWN0ZXIgd2hpY2ggd2lsbCA5OSUgYmUgdHJ1ZSAqKVxuICBsZXQgZmlyc3RfdGFyZ2V0ID0gdGFyZ2V0LlswXSBpblxuICBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBmaXJzdF90YXJnZXQpKSBmaXJzdF90YXJnZXRcbiAgfHwgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAwXG4gIHRoZW4gU29tZSAoQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dHJfbWFwKVxuICBlbHNlIE5vbmVcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID0gJ2FcblxubGV0IHN0YWdlID0gRm4uaWRcbmxldCB1bnN0YWdlID0gRm4uaWRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBjb252ZXJ0X2ZhaWx1cmUgeCBhIGIgdG9fc3RyaW5nID1cbiAgUHJpbnRmLmZhaWx3aXRoZlxuICAgIFwiY29udmVyc2lvbiBmcm9tICVzIHRvICVzIGZhaWxlZDogJXMgaXMgb3V0IG9mIHJhbmdlXCJcbiAgICBhXG4gICAgYlxuICAgICh0b19zdHJpbmcgeClcbiAgICAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBudW1fYml0c19pbnQgPSBTeXMuaW50X3NpemVfaW5fYml0c1xubGV0IG51bV9iaXRzX2ludDMyID0gMzJcbmxldCBudW1fYml0c19pbnQ2NCA9IDY0XG5sZXQgbnVtX2JpdHNfbmF0aXZlaW50ID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50ID0gNjMgfHwgbnVtX2JpdHNfaW50ID0gMzEgfHwgbnVtX2JpdHNfaW50ID0gMzIpXG5sZXQgbWluX2ludDMyID0gQ2FtbC5JbnQzMi5taW5faW50XG5sZXQgbWF4X2ludDMyID0gQ2FtbC5JbnQzMi5tYXhfaW50XG5sZXQgbWluX2ludDY0ID0gQ2FtbC5JbnQ2NC5taW5faW50XG5sZXQgbWF4X2ludDY0ID0gQ2FtbC5JbnQ2NC5tYXhfaW50XG5sZXQgbWluX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm1pbl9pbnRcbmxldCBtYXhfbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQubWF4X2ludFxubGV0IGludF90b19zdHJpbmcgPSBDYW1sLnN0cmluZ19vZl9pbnRcbmxldCBpbnQzMl90b19zdHJpbmcgPSBDYW1sLkludDMyLnRvX3N0cmluZ1xubGV0IGludDY0X3RvX3N0cmluZyA9IENhbWwuSW50NjQudG9fc3RyaW5nXG5sZXQgbmF0aXZlaW50X3RvX3N0cmluZyA9IENhbWwuTmF0aXZlaW50LnRvX3N0cmluZ1xuXG4oKiBpbnQgPC0+IGludDMyICopXG5cbmxldCBpbnRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnRcIiBcImludDMyXCIgaW50X3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDMyXCIgXCJpbnRcIiBpbnQzMl90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfdHJ1bmMgPSBDYW1sLkludDMyLnRvX2ludFxubGV0IGludF90b19pbnQzMl90cnVuYyA9IENhbWwuSW50MzIub2ZfaW50XG5cbmxldCBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX2ludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX2ludF90cnVuYyBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9faW50X3RydW5jIG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX2ludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQzMiBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50MzIgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnRfdG9faW50MzIgeCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50MzJfdG9faW50IHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50MzJfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBpbnRfdG9faW50MzJfdHJ1bmMgeCBlbHNlIGludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbmxldCBpbnQzMl90b19pbnRfZXhuIHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50MzJfdG9faW50X3RydW5jIHggZWxzZSBpbnQzMl90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfaW50XG5sZXQgaW50NjRfdG9faW50X3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludFxubGV0IG5hdGl2ZWludF90b19pbnRfdHJ1bmMgPSBDYW1sLk5hdGl2ZWludC50b19pbnRcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9fbmF0aXZlaW50IEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX25hdGl2ZWludCBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50X3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQzMlwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludDMyX3RvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnQzMlxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGxldCBtaW4gPSBpbnQzMl90b19pbnQ2NCBtaW5faW50MzIgaW5cbiAgbGV0IG1heCA9IGludDMyX3RvX2ludDY0IG1heF9pbnQzMiBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzIgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIFNvbWUgKGludDY0X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gaW50NjRfdG9faW50MzJfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9XG4gIGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnQzMlwiIG5hdGl2ZWludF90b19zdHJpbmdcbjs7XG5cbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPD0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludDMyX3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludDMyXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX3RydW5jID0gQ2FtbC5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBDYW1sLkludDY0LnRvX25hdGl2ZWludFxubGV0IG5hdGl2ZWludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfbmF0aXZlaW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCA9XG4gIGlmIG51bV9iaXRzX2ludDY0IDw9IG51bV9iaXRzX25hdGl2ZWludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IG5hdGl2ZWludF90b19pbnQ2NCBtaW5fbmF0aXZlaW50IGluXG4gICAgbGV0IG1heCA9IG5hdGl2ZWludF90b19pbnQ2NCBtYXhfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBTb21lIChpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgeFxuICB0aGVuIGludDY0X3RvX25hdGl2ZWludF90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IGludDYzICopXG5cbmxldCBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQ2M1wiIGludDY0X3RvX3N0cmluZ1xuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyA9XG4gIGxldCBtaW4gPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1heF9pbnQ2NCAxIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF9maXRfb25faW50NjNfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiAoKSBlbHNlIGludDY0X3RvX2ludDYzX2ZhaWx1cmUgeFxuOztcblxuKCogc3RyaW5nIGNvbnZlcnNpb25zICopXG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgPVxuICBsZXQgaW5wdXRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpbnB1dCBpblxuICBpZiBpbnB1dF9sZW5ndGggPD0gY2hhcnNfcGVyX2RlbGltaXRlclxuICB0aGVuIGlucHV0XG4gIGVsc2UgKFxuICAgIGxldCBoYXNfc2lnbiA9XG4gICAgICBtYXRjaCBpbnB1dC5bMF0gd2l0aFxuICAgICAgfCAnKycgfCAnLScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgbnVtX2RpZ2l0cyA9IGlmIGhhc19zaWduIHRoZW4gaW5wdXRfbGVuZ3RoIC0gMSBlbHNlIGlucHV0X2xlbmd0aCBpblxuICAgIGxldCBudW1fZGVsaW1pdGVycyA9IChudW1fZGlnaXRzIC0gMSkgLyBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IG91dHB1dF9sZW5ndGggPSBpbnB1dF9sZW5ndGggKyBudW1fZGVsaW1pdGVycyBpblxuICAgIGxldCBvdXRwdXQgPSBCeXRlcy5jcmVhdGUgb3V0cHV0X2xlbmd0aCBpblxuICAgIGxldCBpbnB1dF9wb3MgPSByZWYgKGlucHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG91dHB1dF9wb3MgPSByZWYgKG91dHB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gcmVmIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgZmlyc3RfZGlnaXRfcG9zID0gaWYgaGFzX3NpZ24gdGhlbiAxIGVsc2UgMCBpblxuICAgIHdoaWxlICFpbnB1dF9wb3MgPj0gZmlyc3RfZGlnaXRfcG9zIGRvXG4gICAgICBpZiAhbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGRlbGltaXRlcjtcbiAgICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgICBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIDo9IGNoYXJzX3Blcl9kZWxpbWl0ZXIpO1xuICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBpbnB1dC5bIWlucHV0X3Bvc107XG4gICAgICBkZWNyIGlucHV0X3BvcztcbiAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgIGRlY3IgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlclxuICAgIGRvbmU7XG4gICAgaWYgaGFzX3NpZ24gdGhlbiBCeXRlcy5zZXQgb3V0cHV0IDAgaW5wdXQuWzBdO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0cHV0KVxuOztcblxubGV0IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlciA9XG4gIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlcjozXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzIGlucHV0ID0gaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyOidfJ1xubGV0IHNleHBfb2ZfaW50X3N0eWxlID0gU2V4cC5vZl9pbnRfc3R5bGVcblxubW9kdWxlIE1ha2UgKEkgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBvcGVuIElcblxuICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDNcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBzID0gdG9fc3RyaW5nIHQgaW5cbiAgICBTZXhwLkF0b21cbiAgICAgIChtYXRjaCAhc2V4cF9vZl9pbnRfc3R5bGUgd2l0aFxuICAgICAgIHwgYFVuZGVyc2NvcmVzIC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgcyB+Y2hhcnNfcGVyX2RlbGltaXRlciB+ZGVsaW1pdGVyOidfJ1xuICAgICAgIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaGV4IChJIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgICB2YWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgICB2YWwgemVybyA6IHRcbiAgICB2YWwgKCA8ICkgOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBuZWcgOiB0IC0+IHRcbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFRfaGV4ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gSS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoSS5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gNFxuXG4gICAgbGV0IHRvX3N0cmluZycgP2RlbGltaXRlciB0ID1cbiAgICAgIGxldCBtYWtlX3N1ZmZpeCA9XG4gICAgICAgIG1hdGNoIGRlbGltaXRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBJLnRvX3N0cmluZ1xuICAgICAgICB8IFNvbWUgZGVsaW1pdGVyIC0+XG4gICAgICAgICAgZnVuIHQgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAoSS50b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICAgICAgaW5cbiAgICAgIGlmIEkuKCA8ICkgdCBJLnplcm8gdGhlbiBcIi0weFwiIF4gbWFrZV9zdWZmaXggKEkubmVnIHQpIGVsc2UgXCIweFwiIF4gbWFrZV9zdWZmaXggdFxuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nIHQgPSB0b19zdHJpbmcnIHQgP2RlbGltaXRlcjpOb25lXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPSB0b19zdHJpbmcnIHQgfmRlbGltaXRlclxuXG4gICAgbGV0IGludmFsaWQgc3RyID1cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCIlcy5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiBJLm1vZHVsZV9uYW1lIHN0ciAoKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIHN0ciA9XG4gICAgICBJLm9mX3N0cmluZyAoU3RyaW5nLmZpbHRlciBzdHIgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgJ18nKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgICAgbGV0IG1vZHVsZSBMID0gSGV4X2xleGVyIGluXG4gICAgICBsZXQgbGV4ID0gQ2FtbC5MZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgcmVzdWx0ID0gT3B0aW9uLnRyeV93aXRoIChmdW4gKCkgLT4gTC5wYXJzZV9oZXggbGV4KSBpblxuICAgICAgaWYgbGV4LmxleF9jdXJyX3BvcyA9IGxleC5sZXhfYnVmZmVyX2xlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbnZhbGlkIHN0clxuICAgICAgICB8IFNvbWUgKE5lZyBib2R5KSAtPiBJLm5lZyAob2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICAgIHwgU29tZSAoUG9zIGJvZHkpIC0+IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgZWxzZSBpbnZhbGlkIHN0clxuICAgIDs7XG5cbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgSGV4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBUX2hleFxuICAgIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoVF9oZXgpXG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcbmxldCBuZWdhdGl2ZV9leHBvbmVudCAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJleHBvbmVudCBjYW4gbm90IGJlIG5lZ2F0aXZlXCIgKClcbmxldCBvdmVyZmxvdyAoKSA9IFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJpbnRlZ2VyIG92ZXJmbG93IGluIHBvd1wiICgpXG5cbigqIFRvIGltcGxlbWVudCBbaW50NjRfcG93XSwgd2UgdXNlIEMgY29kZSByYXRoZXIgdGhhbiBPQ2FtbCB0byBlbGltaW5hdGUgYWxsb2NhdGlvbi4gKilcbmV4dGVybmFsIGludF9tYXRoX2ludF9wb3cgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWJcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaW50X21hdGhfaW50NjRfcG93IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWJcIlxuXG5sZXQgaW50X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgaWYgZXhwb25lbnQgPCAwIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMVxuICAmJiAoZXhwb25lbnQgPiA2M1xuICAgICAgfHwgYWJzIGJhc2UgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKGV4cG9uZW50KSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgSW50NjRfd2l0aF9jb21wYXJpc29ucyA9IHN0cnVjdFxuICBpbmNsdWRlIENhbWwuSW50NjRcblxuICBleHRlcm5hbCAoIDwgKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5lbmRcblxuKCogd2UgZG9uJ3QgZG8gW2Fic10gaW4gaW50NjQgY2FzZSB0byBhdm9pZCBhbGxvY2F0aW9uICopXG5sZXQgaW50NjRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgKGJhc2UgPiAxTCB8fCBiYXNlIDwgLTFMKVxuICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgIHx8IChiYXNlID49IDBMXG4gICAgICAgICAgJiYgYmFzZSA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpXG4gICAgICAgICApXG4gICAgICB8fCAoYmFzZSA8IDBMXG4gICAgICAgICAgJiYgYmFzZSA8IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpXG4gICAgICAgICApKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubGV0IGludDYzX3Bvd19vbl9pbnQ2NCBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMUxcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCBhYnMgYmFzZVxuICAgICAgICAgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICApXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlIHRcblxuICBpbmNsdWRlIEZsb2F0YWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBTdHJpbmdhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoICogKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC8gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIH4tICkgOiB0IC0+IHRcblxuICBpbmNsdWRlIENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCBvZl9pbnRfZXhuIDogaW50IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG5lbmRcblxubW9kdWxlIE1ha2UgKFggOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgb3BlbiBYXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gWC5yZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgb25lID0gb2ZfaW50X2V4biAxXG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gICgqKiBmbG9hdCBkaXZpc2lvbiBvZiBpbnRlZ2VycyAqKVxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGxldCByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPSBpIC0gKGkgJSBtb2R1bHVzKVxuXG4gIGxldCByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBpZiByZW1haW5kZXIgPSB6ZXJvIHRoZW4gaSBlbHNlIGkgKyBtb2R1bHVzIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgaWYgaSA9IHplcm9cbiAgICB0aGVuIHplcm9cbiAgICBlbHNlIGlmIGkgPiB6ZXJvXG4gICAgdGhlbiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgZWxzZSByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuXG4gIGxldCByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGxldCBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA9IG1vZHVsdXMgLSByZW1haW5kZXIgaW5cbiAgICBpZiBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA8PSByZW1haW5kZXJcbiAgICB0aGVuIGkgKyBtb2R1bHVzX21pbnVzX3JlbWFpbmRlclxuICAgIGVsc2UgaSAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgbWF0Y2ggZGlyIHdpdGhcbiAgICB8IGBOZWFyZXN0IC0+IHJvdW5kX25lYXJlc3QgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBEb3duIC0+IHJvdW5kX2Rvd24gaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBVcCAtPiByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYFplcm8gLT4gcm91bmRfdG93YXJkc196ZXJvIGkgfnRvX211bHRpcGxlX29mXG4gIDs7XG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGludF9wb3cgPSBpbnRfcG93XG4gIGxldCBpbnQ2NF9wb3cgPSBpbnQ2NF9wb3dcbiAgbGV0IGludDYzX3Bvd19vbl9pbnQ2NCA9IGludDYzX3Bvd19vbl9pbnQ2NFxuXG4gIG1vZHVsZSBQb3dfb3ZlcmZsb3dfYm91bmRzID0gUG93X292ZXJmbG93X2JvdW5kc1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2lnbjBcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFNpZ24wKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTEuXG4gIHwgWmVybyAtPiAwLlxuICB8IFBvcyAtPiAxLlxuOztcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9IG9mX2ludCAodG9faW50IHQgKiB0b19pbnQgdCcpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGF0IHRoZSBlbmQsIGFmdGVyIGFueVxuICAgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc29cbiAgIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpc1xuICAgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTdGFja19pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gW0RlcXVlXSBpbiB0aGF0IGl0IHVzZXMgYW4gYXJyYXkgb2YgWydhXSBhbmRcbiAgIGEgbXV0YWJsZSBbaW50XSB0byBpbmRpY2F0ZSB3aGF0IGluIHRoZSBhcnJheSBpcyB1c2VkLiAgV2UgY2hvb3NlIHRvIGltcGxlbWVudCBbU3RhY2tdXG4gICBkaXJlY3RseSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgW0RlcXVlXSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIEUuZy4gYSBzaW1wbGVcbiAgIG1pY3JvYmVuY2htYXJrIHNob3dzIHRoYXQgcHVzaC9wb3AgaXMgYWJvdXQgMjAlIGZhc3Rlci4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB7IGxlbmd0aCA9IGxlbmd0aF9fMDAzXzsgZWx0cyA9IGVsdHNfXzAwNV8gfSAtPlxuICBsZXQgYm5kc19fMDAyXyA9IFtdIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDZfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMDVfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDNfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgaW5cbiAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwMl9cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbmxldCBzZXhwX29mX3QgPSBgUmVib3VuZF9sYXRlclxubGV0IF8gPSBzZXhwX29mX3RcbmxldCBjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSAoeyBsZW5ndGg7IGVsdHMgfSBhcyB0KSA6IHVuaXQgPVxuICB0cnlcbiAgICBhc3NlcnQgKDAgPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgICBpbnZhcmlhbnRfYSAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGkpXG4gICAgZG9uZTtcbiAgICAoKiBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgdW51c2VkIGVsZW1lbnRzIGFyZSB1bnNldCB0byBhdm9pZCBhIHNwYWNlXG4gICAgICAgbGVhay4gKilcbiAgICBmb3IgaSA9IGxlbmd0aCB0byBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMgLSAxIGRvXG4gICAgICBhc3NlcnQgKG5vdCAoT3B0aW9uX2FycmF5LmlzX3NvbWUgZWx0cyBpKSlcbiAgICBkb25lXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlN0YWNrLmludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgWyBcImV4blwiLCBleG4gfD4gRXhuLnNleHBfb2ZfdDsgXCJzdGFja1wiLCB0IHw+IHNleHBfb2ZfdF9pbnRlcm5hbCBzZXhwX29mX29wYXF1ZSBdKVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSAoKSA6IGEgdCA9IHsgbGVuZ3RoID0gMDsgZWx0cyA9IE9wdGlvbl9hcnJheS5lbXB0eSB9XG5sZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxuKCogVGhlIG9yZGVyIGluIHdoaWNoIGVsZW1lbnRzIGFyZSB2aXNpdGVkIGhhcyBiZWVuIGNob3NlbiBzbyBhcyB0byBiZSBiYWNrd2FyZHNcbiAgIGNvbXBhdGlibGUgd2l0aCBbQ2FtbC5TdGFja10gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICFyIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgZiAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZVxuOztcblxubW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfbGlzdCAodHlwZSBhKSAobCA6IGEgbGlzdCkgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxcbiAgdGhlbiBjcmVhdGUgKClcbiAgZWxzZSAoXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjooMiAqIGxlbmd0aCkgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgZm9yIGkgPSBsZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgT3B0aW9uX2FycmF5LnNldF9zb21lIGVsdHMgaSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHsgbGVuZ3RoOyBlbHRzIH0pXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAoTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHJlc2l6ZSB0IHNpemUgPVxuICBsZXQgYXJyID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOnNpemUgaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfnNyYzp0LmVsdHMgfmRzdDphcnIgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46dC5sZW5ndGg7XG4gIHQuZWx0cyA8LSBhcnJcbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBuZXdfY2FwYWNpdHkgPVxuICBsZXQgbmV3X2NhcGFjaXR5ID0gbWF4IG5ld19jYXBhY2l0eSAobGVuZ3RoIHQpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0IHRoZW4gcmVzaXplIHQgbmV3X2NhcGFjaXR5XG47O1xuXG5sZXQgcHVzaCB0IGEgPVxuICBpZiB0Lmxlbmd0aCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzIHRoZW4gcmVzaXplIHQgKDIgKiAodC5sZW5ndGggKyAxKSk7XG4gIE9wdGlvbl9hcnJheS5zZXRfc29tZSB0LmVsdHMgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgcG9wX25vbmVtcHR5IHQgPVxuICBsZXQgaSA9IHQubGVuZ3RoIC0gMSBpblxuICBsZXQgcmVzdWx0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGk7XG4gIHQubGVuZ3RoIDwtIGk7XG4gIHJlc3VsdFxuOztcblxubGV0IHBvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnBvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgcG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9ub25lbXB0eSB0KVxubGV0IHBvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSBwb3BfZXJyb3IgZWxzZSBwb3Bfbm9uZW1wdHkgdFxubGV0IHRvcF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgKHQubGVuZ3RoIC0gMSlcbmxldCB0b3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay50b3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHRvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3Bfbm9uZW1wdHkgdClcbmxldCB0b3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgdG9wX2Vycm9yIGVsc2UgdG9wX25vbmVtcHR5IHRcbmxldCBjb3B5IHsgbGVuZ3RoOyBlbHRzIH0gPSB7IGxlbmd0aDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jb3B5IGVsdHMgfVxuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDApXG47O1xuXG5sZXQgdW50aWxfZW1wdHkgdCBmID1cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGYgKHBvcF9ub25lbXB0eSB0KTtcbiAgICAgIGxvb3AgKCkpXG4gIGluXG4gIGxvb3AgKClcbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIHB1c2ggdCB4O1xuICB0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoaXMgaXMgbGlmdGVkIG91dCBvZiBbTV0gYmVjYXVzZSBbU291cmNlX2NvZGVfcG9zaXRpb24wXSBleHBvcnRzIFtTdHJpbmcwXVxuICAgYXMgW1N0cmluZ10sIHdoaWNoIGRvZXMgbm90IGV4cG9ydCBhIGhhc2ggZnVuY3Rpb24uICopXG5sZXQgaGFzaF9vdmVycmlkZSB7IENhbWwuTGV4aW5nLnBvc19mbmFtZTsgcG9zX2xudW07IHBvc19ib2w7IHBvc19jbnVtIH0gPVxuICBTdHJpbmcuaGFzaCBwb3NfZm5hbWVcbiAgbHhvciBJbnQuaGFzaCBwb3NfbG51bVxuICBseG9yIEludC5oYXNoIHBvc19ib2xcbiAgbHhvciBJbnQuaGFzaCBwb3NfY251bVxuOztcblxubW9kdWxlIE0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTb3VyY2VfY29kZV9wb3NpdGlvbjBcblxuICBsZXQgaGFzaCA9IGhhc2hfb3ZlcnJpZGVcbmVuZFxuXG5pbmNsdWRlIE1cbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgKE0pXG5cbmxldCBvZl9wb3MgKHBvc19mbmFtZSwgcG9zX2xudW0sIHBvc19jbnVtLCBfKSA9XG4gIHsgcG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgPSAwIH1cbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIHR5cGUgRWx0X3BsYWluID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhvdXRfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IE1hcF9pbnRmLldpdGhfY29tcGFyYXRvclxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gTWFwX2ludGYuV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbm1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50ID0gU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuR2VuZXJpY19waGFudG9tXG5cbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICAoKiogVGhlIFtvcHRpb25zXSB0eXBlIGlzIHVzZWQgdG8gbWFrZSBbQWNjZXNzb3JzX2dlbmVyaWNdIGZsZXhpYmxlIGFzIHRvIHdoZXRoZXIgYVxuICAgICAgY29tcGFyYXRvciBpcyByZXF1aXJlZCB0byBiZSBwYXNzZWQgdG8gY2VydGFpbiBmdW5jdGlvbnMuICopXG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgaW52YXJpYW50cyA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcblxuICAoKiogb3ZlcnJpZGUgW0NvbnRhaW5lcl0ncyBbbWVtXSAqKVxuICB2YWwgbWVtIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+IGJvb2wpIG9wdGlvbnNcblxuICB2YWwgYWRkIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgdW5pb24gOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EgZWx0LCAnYSBlbHQpIEVpdGhlci50IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludCkgb3B0aW9uc1xuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuXG4gIHR5cGUgKCdhLCAnY21wKSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXRcbiAgICAgIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIG5hbWVkIC0+IG9mXzooJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSBuYW1lZCAtPiAoJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudCkgb3B0aW9uc1xuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSBlbHQgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYiAtPiBmOignYSBlbHQgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgZWx0IHwgYFJpZ2h0IG9mICdhIGVsdCB8IGBCb3RoIG9mICdhIGVsdCAqICdhIGVsdCBdIC0+IHVuaXQpXG4gICAgICAtPiB1bml0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCAqICdhIGVsdCBvcHRpb24gKiAoJ2EsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGdyb3VwX2J5XG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSBlbHQgLT4gJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0XG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gJ2EgZWx0IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAna2V5IC0+IGludClcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgICAgLT4gJ2tleVxuICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgIC0+IHNlZ21lbnRfb2Y6KCdhIGVsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAtPiAnYSBlbHQgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiAoJ2EgZWx0LCAnYSBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczAgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzBcblxuICB0eXBlIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IHQgLT4gYm9vbFxuICB2YWwgbWVtIDogdCAtPiBlbHQgLT4gYm9vbFxuICB2YWwgYWRkIDogdCAtPiBlbHQgLT4gdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBlbHQgLT4gdFxuICB2YWwgdW5pb24gOiB0IC0+IHQgLT4gdFxuICB2YWwgaW50ZXIgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGlmZiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6IHQgLT4gdCAtPiAoZWx0LCBlbHQpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgaXNfc3Vic2V0IDogdCAtPiBvZl86dCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiB0IC0+IHQgLT4gYm9vbFxuXG4gIHR5cGUgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogbmFtZWQgLT4gb2ZfOm5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgIHZhbCBlcXVhbCA6IG5hbWVkIC0+IG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gZWx0IC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogdCAtPiBpbml0OidiIC0+IGY6KGVsdCAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICB0XG4gICAgLT4gdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgZWx0IHwgYFJpZ2h0IG9mIGVsdCB8IGBCb3RoIG9mIGVsdCAqIGVsdCBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXIgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiB0ICogdFxuICB2YWwgZWxlbWVudHMgOiB0IC0+IGVsdCBsaXN0XG4gIHZhbCBtaW5fZWx0IDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6IHQgLT4gZWx0XG4gIHZhbCBtYXhfZWx0IDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6IHQgLT4gZWx0XG4gIHZhbCBjaG9vc2UgOiB0IC0+IGVsdCBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiB0IC0+IGVsdFxuICB2YWwgc3BsaXQgOiB0IC0+IGVsdCAtPiB0ICogZWx0IG9wdGlvbiAqIHRcbiAgdmFsIGdyb3VwX2J5IDogdCAtPiBlcXVpdjooZWx0IC0+IGVsdCAtPiBib29sKSAtPiB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0XG4gIHZhbCBudGggOiB0IC0+IGludCAtPiBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiB0IC0+IGludCAtPiB0XG4gIHZhbCB0b190cmVlIDogdCAtPiB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gdFxuICAgIC0+IGVsdCBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICB0XG4gICAgLT4gY29tcGFyZTooZWx0IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGVsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzplbHRcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzplbHRcbiAgICAtPiB0XG4gICAgLT4gdFxuICAgIC0+IChlbHQsIGVsdCkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMxXG5cbiAgdHlwZSAnYSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiBfIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgdW5pb24gOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgaW50ZXIgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgZGlmZiA6ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICdhIHQgLT4gJ2EgdCAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6ICdhIHQgLT4gb2ZfOidhIHQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcblxuICB0eXBlICdhIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6ICdhIG5hbWVkIC0+IG9mXzonYSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiAnYSBuYW1lZCAtPiAnYSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KCdhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBlbGVtZW50cyA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICdhIHQgLT4gJ2FcbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICdhIHQgLT4gJ2FcbiAgdmFsIHNwbGl0IDogJ2EgdCAtPiAnYSAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICB2YWwgZ3JvdXBfYnkgOiAnYSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAnYSB0IC0+IGludCAtPiAnYSB0XG4gIHZhbCB0b190cmVlIDogJ2EgdCAtPiAnYSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICdhIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICdhIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMV9waGFudG9tX2ludmFyaWFudFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdW5pb24gOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gIHR5cGUgKCdhLCAnY21wKSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIG5hbWVkIC0+IG9mXzooJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgbmFtZWQgLT4gKCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYiAtPiBmOignYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgc3BsaXQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3RcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMxX3BoYW50b21faW52YXJpYW50XG5cbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHVuaW9uXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBpbnRlclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWwgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gIHZhbCBpc19zdWJzZXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gb2ZfOignYSwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwgYXJlX2Rpc2pvaW50XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiBvZl86KCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2EgLT4gJ2FjY3VtIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOignYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICB2YWwgc3BsaXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcblxuICB2YWwgZ3JvdXBfYnlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0IGxpc3RcblxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHJlbW92ZV9pbmRleFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBpbnRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbigqKiBDb25zaXN0ZW5jeSBjaGVja3MgKHNhbWUgYXMgaW4gW0NvbnRhaW5lcl0pLiAqKVxubW9kdWxlIENoZWNrX2FjY2Vzc29yc1xuICAgIChUIDogVDIpXG4gICAgKFRyZWUgOiBUMilcbiAgICAoRWx0IDogVDEpXG4gICAgKE5hbWVkIDogVDIpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczAgKE0gOiBBY2Nlc3NvcnMwKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5lbHRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMSAoTSA6IEFjY2Vzc29yczEpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyIChNIDogQWNjZXNzb3JzMikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yIChNIDogQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuICB0eXBlICdhIGVsdFxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXAsICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGxpc3QgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9hcnJheSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICgnYSwgJ2NtcCwgbGVuOmludCAtPiBmOihpbnQgLT4gJ2EgZWx0KSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAoJ2EsIF8sICdhIGVsdCBsaXN0IC0+ICdhIGVsdCBsaXN0KSBvcHRpb25zXG5cbiAgKCoqIFRoZSB0eXBlcyBvZiBbbWFwXSBhbmQgW2ZpbHRlcl9tYXBdIGFyZSBzdWJ0bGUuICBUaGUgaW5wdXQgc2V0LCBbKCdhLCBfKSBzZXRdLFxuICAgICAgcmVmbGVjdHMgdGhlIGZhY3QgdGhhdCB0aGVzZSBmdW5jdGlvbnMgdGFrZSBhIHNldCBvZiAqYW55KiB0eXBlLCB3aXRoIGFueVxuICAgICAgY29tcGFyYXRvciwgd2hpbGUgdGhlIG91dHB1dCBzZXQsIFsoJ2IsICdjbXApIHRdLCByZWZsZWN0cyB0aGF0IHRoZSBvdXRwdXQgc2V0IGhhc1xuICAgICAgdGhlIHBhcnRpY3VsYXIgWydjbXBdIG9mIHRoZSBjcmVhdGlvbiBmdW5jdGlvbi4gIFRoZSBjb21wYXJhdG9yIGNhbiBjb21lIGluIG9uZSBvZlxuICAgICAgdGhyZWUgd2F5cywgZGVwZW5kaW5nIG9uIHdoaWNoIHNldCBtb2R1bGUgaXMgdXNlZFxuXG4gICAgICAtIFtTZXQubWFwXSAtLSBjb21wYXJhdG9yIGNvbWVzIGFzIGFuIGFyZ3VtZW50XG4gICAgICAtIFtTZXQuUG9seS5tYXBdIC0tIGNvbXBhcmF0b3IgaXMgcG9seW1vcnBoaWMgY29tcGFyaXNvblxuICAgICAgLSBbRm9vLlNldC5tYXBdIC0tIGNvbXBhcmF0b3IgaXMgW0Zvby5jb21wYXJhdG9yXSAqKVxuICB2YWwgbWFwIDogKCdiLCAnY21wLCAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBlbHQpIC0+ICgnYiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2IsICdjbXAsICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIGVsdCBvcHRpb24pIC0+ICgnYiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdhLCAnY21wLCAoJ2EgZWx0LCAnY21wKSB0cmVlIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMCA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgdFxuICB0eXBlIHRyZWVcbiAgdHlwZSBlbHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiB0XG4gIHZhbCBzaW5nbGV0b24gOiBlbHQgLT4gdFxuICB2YWwgdW5pb25fbGlzdCA6IHQgbGlzdCAtPiB0XG4gIHZhbCBvZl9saXN0IDogZWx0IGxpc3QgLT4gdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiBlbHQgU2VxdWVuY2UudCAtPiB0XG4gIHZhbCBvZl9hcnJheSA6IGVsdCBhcnJheSAtPiB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogZWx0IGFycmF5IC0+IHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gZWx0KSAtPiB0XG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6IGVsdCBsaXN0IC0+IGVsdCBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiBlbHQpIC0+IHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiBlbHQgb3B0aW9uKSAtPiB0XG4gIHZhbCBvZl90cmVlIDogdHJlZSAtPiB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuICB2YWwgb2ZfbGlzdCA6ICdhIGxpc3QgLT4gJ2EgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAnYSBTZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogJ2EgYXJyYXkgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogJ2EgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAnYSBsaXN0IC0+ICdhIGxpc3RcbiAgdmFsIG1hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBvZl90cmVlIDogJ2EgdHJlZSAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfbGlzdCA6ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICdhIFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAnYSBsaXN0IC0+ICdhIGxpc3RcbiAgdmFsIG1hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICgnYiwgJ2NtcCkgdFxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgZW1wdHkgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc2luZ2xldG9uIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICB2YWwgbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2IsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgXykgc2V0XG4gICAgLT4gZjooJ2EgLT4gJ2IpXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICBjb21wYXJhdG9yOignYiwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCBfKSBzZXRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3RyZWUgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnNcbiAgICAoVCA6IFQyKVxuICAgIChUcmVlIDogVDIpXG4gICAgKEVsdCA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMCAoTSA6IENyZWF0b3JzMCkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5lbHRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMxIChNIDogQ3JlYXRvcnMxKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczIgKE0gOiBDcmVhdG9yczIpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gJ2NtcFxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciAoTSA6IENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gJ2NtcFxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnNfZ2VuZXJpY1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBvcHRpb25zXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIGVsdFxuICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIGNtcFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczBcbiAgICB3aXRoIHR5cGUgdCA6PSB0XG4gICAgd2l0aCB0eXBlIHRyZWUgOj0gdHJlZVxuICAgIHdpdGggdHlwZSBlbHQgOj0gZWx0XG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczFcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMxXG4gICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgIHdpdGggdHlwZSAnYSB0cmVlIDo9ICdhIHRyZWVcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMlxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdCA6IChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2VsdCkgLT4gKCdlbHQsICdjbXApIHQgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2VsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdlbHQpXG4gICAgLT4gKCdlbHQsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190IDogKG1vZHVsZSBDb21wYXJlX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWxfbV9fdCA6IChtb2R1bGUgRXF1YWxfbSkgLT4gKCdlbHQsICdjbXApIHQgLT4gKCdlbHQsICdjbXApIHQgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2VsdCwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcblxuICB2YWwgaGFzaF9tX190IDogKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCBfKSB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNldCA9IHNpZ1xuICAoKiogU2V0cyBiYXNlZCBvbiB7IUNvbXBhcmF0b3IuU30uXG5cbiAgICAgIENyZWF0b3JzIHJlcXVpcmUgYSBjb21wYXJhdG9yIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCBpbiwgd2hlcmVhcyBhY2Nlc3NvcnMgdXNlIHRoZVxuICAgICAgY29tcGFyYXRvciBwcm92aWRlZCBieSB0aGUgaW5wdXQgc2V0LiAqKVxuXG4gICgqKiBUaGUgdHlwZSBvZiBhIHNldC4gIFRoZSBmaXJzdCB0eXBlIHBhcmFtZXRlciBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBhbmRcbiAgICAgIHRoZSBzZWNvbmQgaWRlbnRpZmllcyB0aGUgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0aGF0XG4gICAgICBpcyB1c2VkIGZvciBvcmRlcmluZyBlbGVtZW50cyBpbiB0aGlzIHNldC4gIE1hbnkgb3BlcmF0aW9ucyAoZS5nLiwgeyF1bmlvbn0pLFxuICAgICAgcmVxdWlyZSB0aGF0IHRoZXkgYmUgcGFzc2VkIHNldHMgd2l0aCB0aGUgc2FtZSBlbGVtZW50IHR5cGUgYW5kIHRoZSBzYW1lIGNvbXBhcmF0b3JcbiAgICAgIHR5cGUuICopXG4gIHR5cGUgKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdlbHQsICdjbXApIHQgOj0gKCdlbHQsICdjbXApIHRcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3RzIGludGVybmFsIGludmFyaWFudHMgb2YgdGhlIHNldCBkYXRhIHN0cnVjdHVyZS4gIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjXG4gICAgICB3aXRoIHRoZSBzYW1lIG5vdGlvbiBvZiBjb21wYXJpc29uLiAqKVxuICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgKCoqIENyZWF0ZXMgYW4gZW1wdHkgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IgdGhhdCBjb250YWlucyBvbmx5IHRoZSBwcm92aWRlZFxuICAgICAgZWxlbWVudC4gKilcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogUmV0dXJucyB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIHNldC4gW08oMSldLiAqKVxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG5cbiAgKCoqIFtpc19lbXB0eSB0XSBpcyBbdHJ1ZV0gaWZmIFt0XSBpcyBlbXB0eS4gIFtPKDEpXS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbWVtIHQgYV0gcmV0dXJucyBbdHJ1ZV0gaWZmIFthXSBpcyBpbiBbdF0uICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcblxuICAoKiogW2FkZCB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIGFkZGVkIHRvIFt0XSwgb3IgcmV0dXJucyBbdF0gaWYgW21lbSB0IGFdLlxuICAgICAgW08obG9nIG4pXS4gKilcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3JlbW92ZSB0IGFdIHJldHVybnMgYSBuZXcgc2V0IHdpdGggW2FdIHJlbW92ZWQgZnJvbSBbdF0gaWYgW21lbSB0IGFdLCBvciByZXR1cm5zIFt0XVxuICAgICAgb3RoZXJ3aXNlLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uIHQxIHQyXSByZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgdHdvIHNldHMuICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3VuaW9uIGMgbGlzdF0gcmV0dXJucyB0aGUgdW5pb24gb2YgYWxsIHRoZSBzZXRzIGluIFtsaXN0XS4gIFRoZVxuICAgICAgW2NvbXBhcmF0b3JdIGFyZ3VtZW50IGlzIHJlcXVpcmVkIGZvciB0aGUgY2FzZSB3aGVyZSBbbGlzdF0gaXMgZW1wdHkuXG4gICAgICBbTyhtYXgoTGlzdC5sZW5ndGggbGlzdCwgbiBsb2cgbikpXSwgd2hlcmUgW25dIGlzIHRoZSBzdW0gb2Ygc2l6ZXMgb2YgdGhlIGlucHV0IHNldHMuICopXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2NtcCkgdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbaW50ZXIgdDEgdDJdIGNvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2Ygc2V0cyBbdDFdIGFuZCBbdDJdLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildLiAqKVxuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbZGlmZiB0MSB0Ml0gY29tcHV0ZXMgdGhlIHNldCBkaWZmZXJlbmNlIFt0MSAtIHQyXSwgaS5lLiwgdGhlIHNldCBjb250YWluaW5nIGFsbFxuICAgICAgZWxlbWVudHMgaW4gW3QxXSB0aGF0IGFyZSBub3QgaW4gW3QyXS4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0Ml0gcmV0dXJucyBhIHNlcXVlbmNlIG9mIGNoYW5nZXMgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLiBJdCBpc1xuICAgICAgaW50ZW5kZWQgdG8gYmUgZWZmaWNpZW50IGluIHRoZSBjYXNlIHdoZXJlIFt0MV0gYW5kIFt0Ml0gc2hhcmUgYSBsYXJnZSBhbW91bnQgb2ZcbiAgICAgIHN0cnVjdHVyZS4gKilcbiAgdmFsIHN5bW1ldHJpY19kaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtjb21wYXJlX2RpcmVjdCB0MSB0Ml0gY29tcGFyZXMgdGhlIHNldHMgW3QxXSBhbmQgW3QyXS4gIEl0IHJldHVybnMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICBhcyBbY29tcGFyZV0sIGJ1dCB1bmxpa2UgY29tcGFyZSwgZG9lc24ndCByZXF1aXJlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgaW4gZm9yIHRoZVxuICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBzZXQuICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIHNldHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgcykuY29tcGFyZV0gb2YgdGhlIHNldCBbc10gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnYSBIYXNoLmZvbGRlciAtPiAoJ2EsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAoKiogW2VxdWFsIHQxIHQyXSByZXR1cm5zIFt0cnVlXSBpZmYgdGhlIHR3byBzZXRzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMuICBbTyhsZW5ndGggdDEgK1xuICAgICAgbGVuZ3RoIHQyKV0gKilcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFtleGlzdHMgdCB+Zl0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZXJlIGV4aXN0cyBhbiBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhXS4gIFtPKG4pXSxcbiAgICAgIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbZiBhXS4gKilcbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFtmb3JfYWxsIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiBmb3IgYWxsIFthXSBpbiBbdF0sIFtmIGFdLiAgW08obildLCBidXQgcmV0dXJucyBhc1xuICAgICAgc29vbiBhcyBpdCBmaW5kcyBhbiBbYV0gZm9yIHdoaWNoIFtub3QgKGYgYSldLiAqKVxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFtjb3VudCB0XSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgW3RdIGZvciB3aGljaCBbZl0gcmV0dXJucyBbdHJ1ZV0uXG4gICAgICBbTyhuKV0uICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogW3N1bSB0XSByZXR1cm5zIHRoZSBzdW0gb2YgW2YgdF0gZm9yIGVhY2ggW3RdIGluIHRoZSBzZXQuXG4gICAgICBbTyhuKV0uICopXG4gIHZhbCBzdW1cbiAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gKCdhLCBfKSB0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgKCoqIFtmaW5kIHQgZl0gcmV0dXJucyBhbiBlbGVtZW50IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgdHJ1ZSwgd2l0aCBubyBndWFyYW50ZWUgYXNcbiAgICAgIHRvIHdoaWNoIGVsZW1lbnQgaXMgcmV0dXJuZWQuICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgYSBzdWl0YWJsZSBlbGVtZW50IGlzXG4gICAgICBmb3VuZC4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtmaW5kX21hcCB0IGZdIHJldHVybnMgW2JdIGZvciBzb21lIFthXSBpbiBbdF0gZm9yIHdoaWNoIFtmIGEgPSBTb21lIGJdLiAgSWYgbm8gc3VjaFxuICAgICAgW2FdIGV4aXN0cywgdGhlbiBbZmluZF0gcmV0dXJucyBbTm9uZV0uICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzIHNvb24gYXMgYSBzdWl0YWJsZVxuICAgICAgZWxlbWVudCBpcyBmb3VuZC4gKilcbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIExpa2UgW2ZpbmRdLCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBmYWlsdXJlLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcblxuICAoKiogW250aCB0IGldIHJldHVybnMgdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgb2YgW3RdLCBpbiBbTyhsb2cgbildIHRpbWUuICBUaGVcbiAgICAgIHNtYWxsZXN0IGVsZW1lbnQgaGFzIFtpID0gMF0uICBSZXR1cm5zIFtOb25lXSBpZiBbaSA8IDBdIG9yIFtpID49IGxlbmd0aCB0XS4gKilcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtyZW1vdmVfaW5kZXggdCBpXSByZXR1cm5zIGEgdmVyc2lvbiBvZiBbdF0gd2l0aCB0aGUgW2lddGggc21hbGxlc3QgZWxlbWVudCByZW1vdmVkLFxuICAgICAgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlIHNtYWxsZXN0IGVsZW1lbnQgaGFzIFtpID0gMF0uICBSZXR1cm5zIFt0XSBpZiBbaSA8IDBdIG9yXG4gICAgICBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXApIHQgLT4gaW50IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbaXNfc3Vic2V0IHQxIH5vZl86dDJdIHJldHVybnMgdHJ1ZSBpZmYgW3QxXSBpcyBhIHN1YnNldCBvZiBbdDJdLiAqKVxuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbYXJlX2Rpc2pvaW50IHQxIHQyXSByZXR1cm5zIFt0cnVlXSBpZmYgW2lzX2VtcHR5IChpbnRlciB0MSB0MildLCBidXQgaXMgbW9yZVxuICAgICAgZWZmaWNpZW50LiAqKVxuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFtOYW1lZF0gYWxsb3dzIHRoZSB2YWxpZGF0aW9uIG9mIHN1YnNldCBhbmQgZXF1YWxpdHkgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIHNldHMuICBBXG4gICAgICBbTmFtZWQudF0gaXMgYSByZWNvcmQgb2YgYSBzZXQgYW5kIGEgbmFtZSwgd2hlcmUgdGhlIG5hbWUgaXMgdXNlZCBpbiBlcnJvciBtZXNzYWdlcyxcbiAgICAgIGFuZCBbTmFtZWQuaXNfc3Vic2V0XSBhbmQgW05hbWVkLmVxdWFsXSB2YWxpZGF0ZSBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHNcbiAgICAgIHJlc3BlY3RpdmVseS5cblxuICAgICAgVGhlIGVycm9yIG1lc3NhZ2UgZm9yLCBlLmcuLFxuICAgICAge1tcbiAgICAgICAgTmFtZWQuaXNfc3Vic2V0IHsgc2V0ID0gc2V0MTsgbmFtZSA9IFwic2V0MVwiIH0gfm9mXzp7c2V0ID0gc2V0MjsgbmFtZSA9IFwic2V0MlwiIH1cbiAgICAgIF19XG5cbiAgICAgIGxvb2tzIGxpa2VcbiAgICAgIHt2XG4gICAgICAgIChcInNldDEgaXMgbm90IGEgc3Vic2V0IG9mIHNldDJcIiAoaW52YWxpZF9lbGVtZW50cyAoLi4uZWxlbWVudHMgb2Ygc2V0MSAtIHNldDIuLi4pKSlcbiAgICAgdn1cblxuICAgICAgc28gW25hbWVdIHNob3VsZCBiZSBhIG5vdW4gcGhyYXNlIHRoYXQgZG9lc24ndCBzb3VuZCBhd2t3YXJkIGluIHRoZSBhYm92ZSBlcnJvclxuICAgICAgbWVzc2FnZS4gIEV2ZW4gdGhvdWdoIGl0IGFkZHMgdmVyYm9zaXR5LCBjaG9vc2luZyBbbmFtZV1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgcGhyYXNlXG4gICAgICBcInRoZSBzZXQgb2ZcIiBvZnRlbiBtYWtlcyB0aGUgZXJyb3IgbWVzc2FnZSBzb3VuZCBtb3JlIG5hdHVyYWwuXG4gICopXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHNldCA6ICgnYSwgJ2NtcCkgdFxuICAgICAgOyBuYW1lIDogc3RyaW5nXG4gICAgICB9XG5cbiAgICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIFtPayAoKV0gaWYgW3QxXSBpcyBhIHN1YnNldCBvZiBbdDJdIGFuZCBhXG4gICAgICAgIGh1bWFuLXJlYWRhYmxlIGVycm9yIG90aGVyd2lzZS4gICopXG4gICAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgZXF1YWwgdG8gW3QyXSBhbmQgYSBodW1hbi1yZWFkYWJsZVxuICAgICAgICBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gICgqKiBUaGUgbGlzdCBvciBhcnJheSBnaXZlbiB0byBbb2ZfbGlzdF0gYW5kIFtvZl9hcnJheV0gbmVlZCBub3QgYmUgc29ydGVkLiAqKVxuICB2YWwgb2ZfbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt0b19saXN0XSBhbmQgW3RvX2FycmF5XSBwcm9kdWNlIHNlcXVlbmNlcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGFjY29yZGluZyB0byB0aGVcbiAgICAgIGNvbXBhcmF0b3IuICopXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogQ3JlYXRlIHNldCBmcm9tIHNvcnRlZCBhcnJheS4gIFRoZSBpbnB1dCBtdXN0IGJlIHNvcnRlZCAoZWl0aGVyIGluIGFzY2VuZGluZyBvclxuICAgICAgZGVzY2VuZGluZyBvcmRlciBhcyBnaXZlbiBieSB0aGUgY29tcGFyYXRvcikgYW5kIGNvbnRhaW4gbm8gZHVwbGljYXRlcywgb3RoZXJ3aXNlIHRoZVxuICAgICAgcmVzdWx0IGlzIGFuIGVycm9yLiAgVGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBmdW5jdGlvbiBpcyBbTyhuKV0uICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFNpbWlsYXIgdG8gW29mX3NvcnRlZF9hcnJheV0sIGJ1dCB3aXRob3V0IGNoZWNraW5nIHRoZSBpbnB1dCBhcnJheS4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgYyB+bGVuIH5mXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgY1xuICAgICAgKEFycmF5LmluaXQgbGVuIH5mKV0sIHdpdGggdGhlIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gdGhhdCBhIGRlY3JlYXNpbmcgb3JkZXIgaXMgbm90XG4gICAgICBzdXBwb3J0ZWQuICBUaGUgYWR2YW50YWdlIGlzIG5vdCByZXF1aXJpbmcgeW91IHRvIGFsbG9jYXRlIGFuIGludGVybWVkaWF0ZSBhcnJheS4gIFtmXVxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCAwLCAxLCAuLi4gW2xlbiAtIDFdLCBpbiBvcmRlci4gKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3N0YWJsZV9kZWR1cF9saXN0XSBpcyBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBbTGlzdF0gbW9kdWxlIGJlY2F1c2UgdGhlXG4gICAgICBpbXBsZW1lbnRhdGlvbiByZWxpZXMgY3J1Y2lhbGx5IG9uIHNldHMsIGFuZCBiZWNhdXNlIGRvaW5nIHNvIGFsbG93cyBvbmUgdG8gYXZvaWQgdXNlc1xuICAgICAgb2YgcG9seW1vcnBoaWMgY29tcGFyaXNvbiBieSBpbnN0YW50aWF0aW5nIHRoZSBmdW5jdG9yIGF0IGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uXG4gICAgICBvZiBbQ29tcGFyYXRvcl0gYW5kIHVzaW5nIHRoZSByZXN1bHRpbmcgW3N0YWJsZV9kZWR1cF9saXN0XS4gKilcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGxpc3QgLT4gJ2EgbGlzdFxuXG4gICgqKiBbbWFwIGMgdCB+Zl0gcmV0dXJucyBhIG5ldyBzZXQgY3JlYXRlZCBieSBhcHBseWluZyBbZl0gdG8gZXZlcnkgZWxlbWVudCBpblxuICAgICAgW3RdLiAgVGhlIHJldHVybmVkIHNldCBpcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgW2NvbXBhcmF0b3JdLiAgW08obiBsb2cgbildLiAqKVxuICB2YWwgbWFwIDogKCdiLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgeyFtYXB9LCBleGNlcHQgZWxlbWVudHMgZm9yIHdoaWNoIFtmXSByZXR1cm5zIFtOb25lXSB3aWxsIGJlIGRyb3BwZWQuICAqKVxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2IsICdjbXApIHRcblxuICAoKiogW2ZpbHRlciB0IH5mXSByZXR1cm5zIHRoZSBzdWJzZXQgb2YgW3RdIGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICBbTyhuIGxvZ1xuICAgICAgbildLiAqKVxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSBmb2xkcyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgc2V0IGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdC4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvXG4gICAgICBsYXJnZXN0LCBzaG9ydCBjaXJjdWl0aW5nIHRoZSBmb2xkIGlmIFtmIGFjY3VtIHhdIGlzIGFuIFtFcnJvciBfXSAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cblxuICAoKiogTGlrZSB7IWZvbGR9LCBleGNlcHQgdGhhdCBpdCBnb2VzIGZyb20gdGhlIGxhcmdlc3QgdG8gdGhlIHNtYWxsZXN0IGVsZW1lbnQuICopXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhIC0+ICdhY2N1bSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbaXRlciB0IH5mXSBjYWxscyBbZl0gb24gZXZlcnkgZWxlbWVudCBvZiBbdF0sIGdvaW5nIGluIG9yZGVyIGZyb20gdGhlIHNtYWxsZXN0IHRvXG4gICAgICBsYXJnZXN0LiAgKilcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlIHR3byBzZXRzIHNpZGUgYnkgc2lkZS4gIENvbXBsZXhpdHkgaXMgW08obStuKV0gd2hlcmUgW21dIGFuZCBbbl0gYXJlIHRoZSBzaXplc1xuICAgICAgb2YgdGhlIHR3byBpbnB1dCBzZXRzLiAgQXMgYW4gZXhhbXBsZSwgd2l0aCB0aGUgaW5wdXRzIFswOyAxXSBhbmQgWzE7IDJdLCBbZl0gd2lsbCBiZVxuICAgICAgY2FsbGVkIHdpdGggW2BMZWZ0IDBdOyBbYEJvdGggKDEsIDEpXTsgYW5kIFtgUmlnaHQgMl0uICopXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIGlmIFthLCBiID0gcGFydGl0aW9uX3RmIHNldCB+Zl0gdGhlbiBbYV0gaXMgdGhlIGVsZW1lbnRzIG9uIHdoaWNoIFtmXSBwcm9kdWNlZCBbdHJ1ZV0sXG4gICAgICBhbmQgW2JdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZXMgW2ZhbHNlXS4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcblxuICAoKiogU2FtZSBhcyB7IXRvX2xpc3R9LiAqKVxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBzZXQuICBbTyhsb2cgbildLiAqKVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1pbl9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFJldHVybnMgdGhlIGxhcmdlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gICopXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshbWF4X2VsdH0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogcmV0dXJucyBhbiBhcmJpdHJhcnkgZWxlbWVudCwgb3IgW05vbmVdIGlmIHRoZSBzZXQgaXMgZW1wdHkuICopXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFjaG9vc2V9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIFtzcGxpdCB0IHhdIHByb2R1Y2VzIGEgdHJpcGxlIFsodDEsIG1heWJlX3gsIHQyKV0gd2hlcmUgW3QxXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzXG4gICAgICBzdHJpY3RseSBsZXNzIHRoYW4gW3hdLCBbbWF5YmVfeF0gaXMgdGhlIG1lbWJlciAoaWYgYW55KSBvZiBbdF0gd2hpY2ggY29tcGFyZXMgZXF1YWxcbiAgICAgIHRvIFt4XSwgYW5kIFt0Ml0gaXMgdGhlIHNldCBvZiBlbGVtZW50cyBzdHJpY3RseSBsYXJnZXIgdGhhbiBbeF0uICopXG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcblxuICAoKiogaWYgW2VxdWl2XSBpcyBhbiBlcXVpdmFsZW5jZSBwcmVkaWNhdGUsIHRoZW4gW2dyb3VwX2J5IHNldCB+ZXF1aXZdIHByb2R1Y2VzIGEgbGlzdFxuICAgICAgb2YgZXF1aXZhbGVuY2UgY2xhc3NlcyAoaS5lLiwgYSBzZXQtdGhlb3JldGljIHF1b3RpZW50KS4gIEUuZy4sXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBjaGFycyA9IFNldC5vZl9saXN0IFsnQSc7ICdhJzsgJ2InOyAnYyddIGluXG4gICAgICAgIGxldCBlcXVpdiBjIGMnID0gQ2hhci5lcXVhbCAoQ2hhci51cHBlcmNhc2UgYykgKENoYXIudXBwZXJjYXNlIGMnKSBpblxuICAgICAgICBncm91cF9ieSBjaGFycyB+ZXF1aXZcbiAgICAgIF19XG5cbiAgICAgIHByb2R1Y2VzOlxuXG4gICAgICB7W1xuICAgICAgICBbU2V0Lm9mX2xpc3QgWydBJzsnYSddOyBTZXQuc2luZ2xldG9uICdiJzsgU2V0LnNpbmdsZXRvbiAnYyddXG4gICAgICBdfVxuXG4gICAgICBbZ3JvdXBfYnldIHJ1bnMgaW4gTyhuXjIpIHRpbWUsIHNvIGlmIHlvdSBoYXZlIGEgY29tcGFyaXNvbiBmdW5jdGlvbiwgaXQncyB1c3VhbGx5XG4gICAgICBtdWNoIGZhc3RlciB0byB1c2UgW1NldC5vZl9saXN0XS4gKilcbiAgdmFsIGdyb3VwX2J5IDogKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdFxuXG4gICgqKiBbdG9fc2VxdWVuY2UgdF0gY29udmVydHMgdGhlIHNldCBbdF0gdG8gYSBzZXF1ZW5jZSBvZiB0aGUgZWxlbWVudHMgYmV0d2VlblxuICAgICAgW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZCBbbGVzc19vcl9lcXVhbF90b10gaW5jbHVzaXZlIGluIHRoZSBvcmRlciBpbmRpY2F0ZWQgYnlcbiAgICAgIFtvcmRlcl0uICBJZiBbZ3JlYXRlcl9vcl9lcXVhbF90byA+IGxlc3Nfb3JfZXF1YWxfdG9dIHRoZSBzZXF1ZW5jZSBpcyBlbXB0eS4gIENvc3QgaXNcbiAgICAgIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSBmb3IgZWFjaCBlbGVtZW50IHByb2R1Y2VkLiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgZWxlbWVudCBpbiBbdF0gc3BlY2lmaWVkIGJ5XG4gICAgICBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBzZWdtZW50cyBhc1xuICAgICAgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGVmdCBzZWdtZW50LFxuICAgICAgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LiAgSXQgcmV0dXJuc1xuICAgICAgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFByb2R1Y2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgdHdvIHNldHMgYmV0d2VlbiBbZ3JlYXRlcl9vcl9lcXVhbF90b10gYW5kXG4gICAgICBbbGVzc19vcl9lcXVhbF90b10gaW4gW29yZGVyXSwgbm90aW5nIHdoZXRoZXIgZWFjaCBlbGVtZW50IGFwcGVhcnMgaW4gdGhlIGxlZnQgc2V0LFxuICAgICAgdGhlIHJpZ2h0IHNldCwgb3IgYm90aC4gIEluIHRoZSBib3RoIGNhc2UsIGJvdGggZWxlbWVudHMgYXJlIHJldHVybmVkLCBpbiBjYXNlIHRoZVxuICAgICAgY2FsbGVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuIGVsZW1lbnRzIHRoYXQgYXJlIGVxdWFsIHRvIHRoZSBzZXRzJyBjb21wYXJhdG9yLiAgUnVuc1xuICAgICAgaW4gTyhsZW5ndGggdCArIGxlbmd0aCB0JykuICopXG4gIG1vZHVsZSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgU2VxdWVuY2UuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQudCA9XG4gICAgICB8IExlZnQgb2YgJ2FcbiAgICAgIHwgUmlnaHQgb2YgJ2JcbiAgICAgIHwgQm90aCBvZiAnYSAqICdiXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IFNldC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfc2V0ID0gKFN0cmluZy50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBTZXQudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW1NldC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3MsXG4gICAgICBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLiAqKVxuICBtb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICgqKiBBIHBvbHltb3JwaGljIFNldC4gKilcbiAgbW9kdWxlIFBvbHkgOiBTX3BvbHkgd2l0aCB0eXBlICdlbHQgdCA9ICgnZWx0LCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5cbiAgKCoqIFVzaW5nIGNvbXBhcmF0b3IgaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW1NldF0sIGV4Y2VwdCB0aGUgZnVuY3Rpb25zXG4gICAgICB0YWtlIGEgW35jb21wYXJhdG9yOignZWx0LCAnY21wKSBDb21wYXJhdG9yLnRdIHdoZXJlIHRoZSBmdW5jdGlvbnMgYXQgdGhlIHRvcGxldmVsIG9mXG4gICAgICBbU2V0XSB0YWtlcyBhIFsoJ2VsdCwgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnZWx0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgKCoqIEEgW1RyZWUudF0gY29udGFpbnMganVzdCB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZSB0aGF0IGEgc2V0IGlzIGJhc2VkIG9uLCB3aXRob3V0XG4gICAgICAgICAgaW5jbHVkaW5nIHRoZSBjb21wYXJhdG9yLiAgQWNjb3JkaW5nbHksIGFueSBvcGVyYXRpb24gb24gYSBbVHJlZS50XSBtdXN0IGFsc28gdGFrZVxuICAgICAgICAgIGFzIGFuIGFyZ3VtZW50IHRoZSBjb3JyZXNwb25kaW5nIGNvbXBhcmF0b3IuICopXG4gICAgICB0eXBlICgnYSwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2VsdClcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICAgIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgICAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgICAgIHsgdHJlZSA6ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgICAgIH1cblxuICAgICAgICB2YWwgaXNfc3Vic2V0XG4gICAgICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IG9mXzooJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICAgICB2YWwgZXF1YWxcbiAgICAgICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgICBlbmRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHNldCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudFxuICAgICAgICB3aXRoIG1vZHVsZSBOYW1lZCA6PSBOYW1lZFxuXG4gICAgICB2YWwgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA6IChfLCBfKSB0XG4gICAgZW5kXG5cbiAgICBpbmNsdWRlXG4gICAgICBBY2Nlc3NvcnMyXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50XG5cbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdlbHQgSGFzaC5mb2xkZXIgLT4gKCdlbHQsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiB7MiBNb2R1bGVzIGFuZCBtb2R1bGUgdHlwZXMgZm9yIGV4dGVuZGluZyBbU2V0XX1cblxuICAgICAgRm9yIHVzZSBpbiBleHRlbnNpb25zIG9mIEJhc2UsIGxpa2UgW0NvcmVdLiAqKVxuXG4gIG1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBXaXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbiAgbW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IFdpdGhvdXRfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMCA9IEFjY2Vzc29yczBcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IEFjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IEFjY2Vzc29yczJcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgPSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMCA9IENyZWF0b3JzMFxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBDcmVhdG9yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gQ3JlYXRvcnMyXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgPSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczBcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID1cbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBFbHRfcGxhaW4gPSBFbHRfcGxhaW5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V0X2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEVtcHR5XG4gICAgKCogKExlYWYgeCkgaXMgdGhlIHNhbWUgYXMgKE5vZGUgKEVtcHR5LCB4LCBFbXB0eSwgMSwgMSkpIGJ1dCB1c2VzIGxlc3Mgc3BhY2UuICopXG4gICAgfCBMZWFmIG9mICdhXG4gICAgKCogZmlyc3QgaW50IGlzIGhlaWdodCwgc2Vjb25kIGlzIHN1Yi10cmVlIHNpemUgKilcbiAgICB8IE5vZGUgb2YgJ2EgdCAqICdhICogJ2EgdCAqIGludCAqIGludFxuXG4gIHR5cGUgJ2EgdHJlZSA9ICdhIHRcblxuICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZSBjaGlsZHJlbiBkaWZmZXIgYnlcbiAgICAgYXQgbW9zdCAyLiAqKVxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzID1cbiAgICBsZXQgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdiA9XG4gICAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgfCBTb21lIGxvd2VyIC0+IGNvbXBhcmVfZWx0IGxvd2VyIHYgPCAwKVxuICAgICAgJiZcbiAgICAgIG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFNvbWUgdXBwZXIgLT4gY29tcGFyZV9lbHQgdiB1cHBlciA8IDBcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgICB8IExlYWYgdiAtPiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIGgsIG4pIC0+XG4gICAgICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICAgIGFicyAoaGwgLSBocikgPD0gMlxuICAgICAgICAmJiBoID0gbWF4IGhsIGhyICsgMVxuICAgICAgICAmJiBuID0gbGVuZ3RoIGwgKyBsZW5ndGggciArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIHYpIGNvbXBhcmVfZWx0IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSB2KSB1cHBlciBjb21wYXJlX2VsdCByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9lbHQgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9lbHQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2VcbiAgOztcblxuICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgbGV0IGhsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGxldCBociA9XG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaCA9IGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxIGluXG4gICAgaWYgaCA9IDFcbiAgICB0aGVuIExlYWYgdlxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNsID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGxldCBzciA9XG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBOb2RlIChsLCB2LCByLCBoLCBzbCArIHNyICsgMSkpXG4gIDs7XG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuU2V0IG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrID0gZiBpIGluXG4gICAgICAgIExlYWYga1xuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgRW1wdHlcbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgbGV0IGtyID0gZiAoaSArIDIpIGluXG4gICAgICAgIGNyZWF0ZSAoTGVhZiBrbCkgayAoTGVhZiBrcilcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgICgqIFdlIGRvbid0IGNoZWNrIGlmIHRoZSBhcnJheSBpcyBzb3J0ZWQgb3Iga2V5cyBhcmUgZHVwbGljYXRlZCwgYmVjYXVzZSB0aGF0XG4gICAgICAgICBjaGVja2luZyBpcyBzbG93ZXIgdGhhbiB0aGUgd2hvbGUgW29mX3NvcnRlZF9hcnJheV0gZnVuY3Rpb24gKilcbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDIgfHwgY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHRcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdClcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2VsdCBhcnJheS4oaSkgYXJyYXkuKGkgKyAxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGVsZW1lbnRzIGFyZSBub3Qgb3JkZXJlZFwiKVxuICAgICAgICBkb25lO1xuICAgICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0KSlcbiAgOztcblxuICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgbGV0IGJhbCBsIHYgciA9XG4gICAgbGV0IGhsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGxldCBociA9XG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChsKT5oKHIpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIChsbCwgbHYsIGxyLCBfLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyXG4gICAgICAgIHRoZW4gY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgbHJ2IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IGxsKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IEVtcHR5KSBscnYgKGNyZWF0ZSBFbXB0eSB2IHIpXG4gICAgICAgICAgfCBOb2RlIChscmwsIGxydiwgbHJyLCBfLCBfKSAtPiBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogYmVjYXVzZSBoKHIpPmgobCkrMiBhbmQgaChsZWFmKT0xICopXG4gICAgICB8IE5vZGUgKHJsLCBydiwgcnIsIF8sIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmxcbiAgICAgICAgdGhlbiBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTGVhZiBybHYgLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgcnIpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IEVtcHR5KSBybHYgKGNyZWF0ZSBFbXB0eSBydiBycilcbiAgICAgICAgICB8IE5vZGUgKHJsbCwgcmx2LCBybHIsIF8sIF8pIC0+IGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycikpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgICAgbGV0IHNsID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGxldCBzciA9XG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBpZiBoID0gMSB0aGVuIExlYWYgdiBlbHNlIE5vZGUgKGwsIHYsIHIsIGgsIHNsICsgc3IgKyAxKSlcbiAgOztcblxuICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICBleGNlcHRpb24gU2FtZVxuXG4gIGxldCBhZGQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBMZWFmIHhcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gcmFpc2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gY3JlYXRlIChMZWFmIHgpIHYgRW1wdHlcbiAgICAgICAgZWxzZSBjcmVhdGUgRW1wdHkgdiAoTGVhZiB4KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJhaXNlIFNhbWUgZWxzZSBpZiBjIDwgMCB0aGVuIGJhbCAoYXV4IGwpIHYgciBlbHNlIGJhbCBsIHYgKGF1eCByKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZFxuICAgICByLiAqKVxuICBsZXQgcmVjIGpvaW4gbCB2IHIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBsLCByIHdpdGhcbiAgICB8IEVtcHR5LCBfIC0+IGFkZCByIHYgfmNvbXBhcmVfZWx0XG4gICAgfCBfLCBFbXB0eSAtPiBhZGQgbCB2IH5jb21wYXJlX2VsdFxuICAgIHwgTGVhZiBsdiwgXyAtPiBhZGQgKGFkZCByIHYgfmNvbXBhcmVfZWx0KSBsdiB+Y29tcGFyZV9lbHRcbiAgICB8IF8sIExlYWYgcnYgLT4gYWRkIChhZGQgbCB2IH5jb21wYXJlX2VsdCkgcnYgfmNvbXBhcmVfZWx0XG4gICAgfCBOb2RlIChsbCwgbHYsIGxyLCBsaCwgXyksIE5vZGUgKHJsLCBydiwgcnIsIHJoLCBfKSAtPlxuICAgICAgaWYgbGggPiByaCArIDJcbiAgICAgIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgciB+Y29tcGFyZV9lbHQpXG4gICAgICBlbHNlIGlmIHJoID4gbGggKyAyXG4gICAgICB0aGVuIGJhbCAoam9pbiBsIHYgcmwgfmNvbXBhcmVfZWx0KSBydiByclxuICAgICAgZWxzZSBjcmVhdGUgbCB2IHJcbiAgOztcblxuICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IHwgTm9kZSAoRW1wdHksIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICAgIHwgTm9kZSAobCwgXywgXywgXywgXykgLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwic2V0Lm1sLlRyZWUwLlNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgYWNjID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB2YWx1ZSAtPiBmIGFjYyB2YWx1ZVxuICAgICAgfCBOb2RlIChsZWZ0LCB2YWx1ZSwgcmlnaHQsIF8sIF8pIC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiBsZWZ0IGFjYyB3aXRoXG4gICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiBhY2MgdmFsdWUgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgICAgfCBDb250aW51ZSBhIC0+IGZvbGRfdW50aWxfaGVscGVyIH5mIHJpZ2h0IGEpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgdCBpbml0IHdpdGhcbiAgICB8IENvbnRpbnVlIHggLT4gZmluaXNoIHhcbiAgICB8IFN0b3AgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiB8IE5vZGUgKF8sIHYsIEVtcHR5LCBfLCBfKSAtPiBTb21lIHZcbiAgICB8IE5vZGUgKF8sIF8sIHIsIF8sIF8pIC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgKEVtcHR5LCBfLCByLCBfLCBfKSAtPiByXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBiYWwgdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcbiAgbGV0IGNvbmNhdCB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gam9pbiB0MSAobWluX2VsdF9leG4gdDIpIChyZW1vdmVfbWluX2VsdCB0MikgfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgc3BsaXQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRW1wdHksIE5vbmUsIEVtcHR5XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEVtcHR5LCBTb21lIHYsIEVtcHR5XG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgTGVhZiB2XG4gICAgICAgIGVsc2UgTGVhZiB2LCBOb25lLCBFbXB0eVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIGwsIFNvbWUgdiwgclxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsbCwgbWF5YmVfZWx0LCBybCA9IHNwbGl0IGwgaW5cbiAgICAgICAgICBsbCwgbWF5YmVfZWx0LCBqb2luIHJsIHYgciB+Y29tcGFyZV9lbHQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsciwgbWF5YmVfZWx0LCByciA9IHNwbGl0IHIgaW5cbiAgICAgICAgICBqb2luIGwgdiBsciB+Y29tcGFyZV9lbHQsIG1heWJlX2VsdCwgcnIpXG4gICAgaW5cbiAgICBzcGxpdCB0XG4gIDs7XG5cbiAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgcmVjIG1lbSB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHYgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMFxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMCB8fCBtZW0gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiB4ID0gTGVhZiB4XG5cbiAgbGV0IHJlbW92ZSB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBTYW1lXG4gICAgICB8IExlYWYgdiAtPiBpZiBjb21wYXJlX2VsdCB4IHYgPSAwIHRoZW4gRW1wdHkgZWxzZSByYWlzZSBTYW1lXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6XyA9XG4gICAgbGV0IHJlYyBhdXggdCBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBTYW1lXG4gICAgICB8IExlYWYgXyAtPiBpZiBpID0gMCB0aGVuIEVtcHR5IGVsc2UgcmFpc2UgU2FtZVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGJhbCAoYXV4IGwgaSkgdiByXG4gICAgICAgIGVsc2UgYmFsIGwgdiAoYXV4IHIgKGkgLSBsX3NpemUgLSAxKSlcbiAgICBpblxuICAgIHRyeSBhdXggdCBpIHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gIGxldCB1bmlvbiBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIHQgfCB0LCBFbXB0eSAtPiB0XG4gICAgICAgIHwgTGVhZiB2MSwgXyAtPiB1bmlvbiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHMyXG4gICAgICAgIHwgXywgTGVhZiB2MiAtPiB1bmlvbiBzMSAoTm9kZSAoRW1wdHksIHYyLCBFbXB0eSwgMSwgMSkpXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgaDEsIF8pLCBOb2RlIChsMiwgdjIsIHIyLCBoMiwgXykgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMlxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMVxuICAgICAgICAgICAgdGhlbiBhZGQgczEgdjIgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGwyLCBfLCByMiA9IHNwbGl0IHMyIHYxIH5jb21wYXJlX2VsdCBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKSB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgZWxzZSBpZiBoMSA9IDFcbiAgICAgICAgICB0aGVuIGFkZCBzMiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsMSwgXywgcjEgPSBzcGxpdCBzMSB2MiB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICB1bmlvbiBzMSBzMlxuICA7O1xuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIHhzID1cbiAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIExpc3QuZm9sZCB4cyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjIHggLT4gdW5pb24gYWMgKHRvX3RyZWUgeCkgfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlciBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IChMZWFmIGVsdCBhcyBzaW5nbGV0b24pLCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIChMZWFmIGVsdCBhcyBzaW5nbGV0b24pIC0+XG4gICAgICAgICAgaWYgbWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0IHRoZW4gc2luZ2xldG9uIGVsc2UgRW1wdHlcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgfCBsMiwgU29tZSB2MSwgcjIgLT4gam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMikgfmNvbXBhcmVfZWx0KSlcbiAgICBpblxuICAgIGludGVyIHMxIHMyXG4gIDs7XG5cbiAgbGV0IGRpZmYgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBFbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gLT4gRW1wdHlcbiAgICAgICAgfCB0MSwgRW1wdHkgLT4gdDFcbiAgICAgICAgfCBMZWFmIHYxLCB0MiAtPiBkaWZmIChOb2RlIChFbXB0eSwgdjEsIEVtcHR5LCAxLCAxKSkgdDJcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpIH5jb21wYXJlX2VsdFxuICAgICAgICAgICB8IGwyLCBTb21lIF8sIHIyIC0+IGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICBkaWZmIHMxIHMyXG4gIDs7XG5cbiAgbW9kdWxlIEVudW0gPSBzdHJ1Y3RcbiAgICB0eXBlIGluY3JlYXNpbmdcbiAgICB0eXBlIGRlY3JlYXNpbmdcblxuICAgIHR5cGUgKCdhLCAnZGlyZWN0aW9uKSB0ID1cbiAgICAgIHwgRW5kXG4gICAgICB8IE1vcmUgb2YgJ2EgKiAnYSB0cmVlICogKCdhLCAnZGlyZWN0aW9uKSB0XG5cbiAgICBsZXQgcmVjIGNvbnMgcyAoZSA6IChfLCBpbmNyZWFzaW5nKSB0KSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgdiAtPiBNb3JlICh2LCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gY29ucyBsIChNb3JlICh2LCByLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb25zX3JpZ2h0IHMgKGUgOiAoXywgZGVjcmVhc2luZykgdCkgOiAoXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHYgLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGNvbnNfcmlnaHQgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl9zZXQgcyA6IChfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyBzIEVuZFxuICAgIGxldCBvZl9zZXRfcmlnaHQgcyA6IChfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCBzIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB2IC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBFbXB0eSwgMSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChfLCB2LCByLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gbG9vcCBsIChNb3JlICh2LCByLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBzdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgdiAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgRW1wdHksIDEsIDEpKSBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgXywgXywgXykgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGxvb3AgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2VsdCBlMSBlMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgZTEgZTIgPVxuICAgICAgICBtYXRjaCBlMSwgZTIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCByMSwgZTEpLCBNb3JlICh2MiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGlmIHBoeXNfZXF1YWwgcjEgcjJcbiAgICAgICAgICB0aGVuIGxvb3AgZTEgZTJcbiAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKVxuICAgICAgaW5cbiAgICAgIGxvb3AgZTEgZTJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBpdGVyIH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+ICgpXG4gICAgICB8IE1vcmUgKGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgIGYgYTtcbiAgICAgICAgaXRlciAoY29ucyB0cmVlIGVudW0pIH5mXG4gICAgOztcblxuICAgIGxldCBpdGVyMiBjb21wYXJlX2VsdCB0MSB0MiB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+ICgpXG4gICAgICAgIHwgRW5kLCBfIC0+IGl0ZXIgdDIgfmY6KGZ1biBhIC0+IGYgKGBSaWdodCBhKSlcbiAgICAgICAgfCBfLCBFbmQgLT4gaXRlciB0MSB+ZjooZnVuIGEgLT4gZiAoYExlZnQgYSkpXG4gICAgICAgIHwgTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBCb3RoIChhMSwgYTIpKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYExlZnQgYTEpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBmIChgUmlnaHQgYTIpO1xuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICAgIGxldCBzdGVwIHN0YXRlIDogKChfLCBfKSBFaXRoZXIudCwgXykgU2VxdWVuY2UuU3RlcC50ID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IERvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGVsdCwgdHJlZSwgZW51bSkgLT4gWWllbGQgKFNlY29uZCBlbHQsIChFbmQsIGNvbnMgdHJlZSBlbnVtKSlcbiAgICAgICAgfCBNb3JlIChlbHQsIHRyZWUsIGVudW0pLCBFbmQgLT4gWWllbGQgKEZpcnN0IGVsdCwgKGNvbnMgdHJlZSBlbnVtLCBFbmQpKVxuICAgICAgICB8IChNb3JlIChhMSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9XG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgICAgdGhlbiBlbnVtMSwgZW51bTJcbiAgICAgICAgICAgICAgZWxzZSBjb25zIHRyZWUxIGVudW0xLCBjb25zIHRyZWUyIGVudW0yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU2tpcCBuZXh0X3N0YXRlKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiBZaWVsZCAoRmlyc3QgYTEsIChjb25zIHRyZWUxIGVudW0xLCByaWdodCkpXG4gICAgICAgICAgZWxzZSBZaWVsZCAoU2Vjb25kIGEyLCAobGVmdCwgY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6KG9mX3NldCB0MSwgb2Zfc2V0IHQyKSB+ZjpzdGVwXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoaywgRW51bS5jb25zIHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fZWx0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3NldCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKGssIEVudW0uY29uc19yaWdodCB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXRfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfZWx0IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIGVsdCAtPiBhZGQgdCBlbHQgfmNvbXBhcmVfZWx0XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBsZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0OmdyZWF0ZXJfb3JfZXF1YWxfdG8gdFxuICAgIHwgYERlY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgZ3JlYXRlcl9vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgc25kKSBpblxuICAgICAgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpsZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIHZcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgciB+ZlxuICA7O1xuXG4gIGxldCByZWMgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSB4IGFzIGVsdCB3aGVuIGNvbXBhcmUgeCB2ID0gMCAtPiBlbHRcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMClcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IHggPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHRcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmcpXG4gICAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICAgICAgdCdcbiAgICA9XG4gICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdClcbiAgICAgICh0b19zZXF1ZW5jZSBjb21wYXJhdG9yIH5vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0JylcbiAgICAgIH5jb21wYXJlOlxuICAgICAgICAobWF0Y2ggb3JkZXIgd2l0aFxuICAgICAgICAgfCBgSW5jcmVhc2luZyAtPiBjb21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIHwgYERlY3JlYXNpbmcgLT4gRm4uZmxpcCBjb21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPVxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMilcbiAgOztcblxuICBsZXQgaXRlcjIgczEgczIgfmNvbXBhcmVfZWx0ID0gRW51bS5pdGVyMiBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMilcbiAgbGV0IGVxdWFsIHMxIHMyIH5jb21wYXJlX2VsdCA9IGNvbXBhcmUgY29tcGFyZV9lbHQgczEgczIgPSAwXG5cbiAgbGV0IGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBpc19zdWJzZXQgczEgfm9mXzpzMiA9XG4gICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgfCBFbXB0eSwgXyAtPiB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IExlYWYgdjEsIHQyIC0+IG1lbSB0MiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIExlYWYgdjIgLT5cbiAgICAgICAgKG1hdGNoIGwxLCByMSB3aXRoXG4gICAgICAgICB8IEVtcHR5LCBFbXB0eSAtPlxuICAgICAgICAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkbid0IG9jY3VyIGluIHByYWN0aWNlIGJlY2F1c2Ugd2Ugc2hvdWxkIGhhdmUgY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgYSBMZWFmIHJhdGhlciB0aGFuIGEgTm9kZSB3aXRoIHR3byBFbXB0eSBzdWJ0cmVlcyAqKVxuICAgICAgICAgICBjb21wYXJlX2VsdCB2MSB2MiA9IDBcbiAgICAgICAgIHwgXywgXyAtPiBmYWxzZSlcbiAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIChOb2RlIChsMiwgdjIsIHIyLCBfLCBfKSBhcyB0MikgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgcGh5c19lcXVhbCBzMSBzMiB8fCAoaXNfc3Vic2V0IGwxIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86cjIpXG4gICAgICAgICAgKCogTm90ZSB0aGF0IGhlaWdodCBhbmQgc2l6ZSBkb24ndCBtYXR0ZXIgaGVyZS4gKilcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGlzX3N1YnNldCAoTm9kZSAobDEsIHYxLCBFbXB0eSwgMCwgMCkpIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86dDJcbiAgICAgICAgZWxzZSBpc19zdWJzZXQgKE5vZGUgKEVtcHR5LCB2MSwgcjEsIDAsIDApKSB+b2ZfOnIyICYmIGlzX3N1YnNldCBsMSB+b2ZfOnQyXG4gICAgaW5cbiAgICBpc19zdWJzZXQgczEgfm9mXzpzMlxuICA7O1xuXG4gIGxldCByZWMgYXJlX2Rpc2pvaW50IHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBlbHQsIG90aGVyX3NldCB8IG90aGVyX3NldCwgTGVhZiBlbHQgLT4gbm90IChtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQpXG4gICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgdDIgLT5cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICB8IGwyLCBOb25lLCByMiAtPlxuICAgICAgICAgIGFyZV9kaXNqb2ludCBsMSBsMiB+Y29tcGFyZV9lbHQgJiYgYXJlX2Rpc2pvaW50IHIxIHIyIH5jb21wYXJlX2VsdFxuICAgICAgICB8IF8sIFNvbWUgXywgXyAtPiBmYWxzZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID1cbiAgICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBMZWFmIHYgLT4gZiB2XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGl0ZXIgbDtcbiAgICAgICAgZiB2O1xuICAgICAgICBpdGVyIHJcbiAgICBpblxuICAgIGl0ZXIgdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgcmVjIGZvbGQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIGFjY3UgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZCB+ZiByIH5pbml0OihmIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkgdilcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9lbGVtIHN0YXRlIHQgPVxuICAgIGZvbGQgdCB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKSB+ZjpoYXNoX2ZvbGRfZWxlbVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuXG4gIGxldCByZWMgZm9sZF9yaWdodCBzIH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IGYgdiBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBmb2xkX3JpZ2h0IH5mIGwgfmluaXQ6KGYgdiAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCByZWMgZm9yX2FsbCB0IH5mOnAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2ICYmIGZvcl9hbGwgfmY6cCBsICYmIGZvcl9hbGwgfmY6cCByXG4gIDs7XG5cbiAgbGV0IHJlYyBleGlzdHMgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHYgLT4gcCB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBwIHYgfHwgZXhpc3RzIH5mOnAgbCB8fCBleGlzdHMgfmY6cCByXG4gIDs7XG5cbiAgbGV0IGZpbHRlciBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGZpbHQgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+IGlmIHAgdiB0aGVuIGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0IGVsc2UgYWNjdVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBmaWx0IChmaWx0IChpZiBwIHYgdGhlbiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdCBlbHNlIGFjY3UpIGwpIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgc1xuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgZmlsdCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGZpbHRcbiAgICAgICAgICAoZmlsdFxuICAgICAgICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgICAgICAgICBsKVxuICAgICAgICAgIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgc1xuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBwYXJ0ICgodCwgZikgYXMgYWNjdSkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPiBpZiBwIHYgdGhlbiBhZGQgdCB2IH5jb21wYXJlX2VsdCwgZiBlbHNlIHQsIGFkZCBmIHYgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIHBhcnQgKHBhcnQgKGlmIHAgdiB0aGVuIGFkZCB0IHYgfmNvbXBhcmVfZWx0LCBmIGVsc2UgdCwgYWRkIGYgdiB+Y29tcGFyZV9lbHQpIGwpIHJcbiAgICBpblxuICAgIHBhcnQgKEVtcHR5LCBFbXB0eSkgc1xuICA7O1xuXG4gIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IHYgOjogYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcbiAgOztcblxuICBsZXQgZWxlbWVudHMgcyA9IGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgbGV0IGNob29zZSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBTb21lIHZcbiAgICB8IE5vZGUgKF8sIHYsIF8sIF8sIF8pIC0+IFNvbWUgdlxuICA7O1xuXG4gIGxldCBjaG9vc2VfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTZXQuY2hvb3NlX2V4bjogZW1wdHkgc2V0XCIpIGluXG4gICAgbGV0IGNob29zZV9leG4gdCA9XG4gICAgICBtYXRjaCBjaG9vc2UgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IFNvbWUgdiAtPiB2XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgY2hvb3NlX2V4blxuICA7O1xuXG4gIGxldCBvZl9saXN0IGxzdCB+Y29tcGFyZV9lbHQgPVxuICAgIExpc3QuZm9sZCBsc3QgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlIH5jb21wYXJlX2VsdCA9XG4gICAgU2VxdWVuY2UuZm9sZCBzZXF1ZW5jZSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgdG9fbGlzdCBzID0gZWxlbWVudHMgc1xuXG4gIGxldCBvZl9hcnJheSBhIH5jb21wYXJlX2VsdCA9XG4gICAgQXJyYXkuZm9sZCBhIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gICgqIGZhc3RlciBidXQgZXF1aXZhbGVudCB0byBbQXJyYXkub2ZfbGlzdCAodG9fbGlzdCB0KV0gKilcbiAgbGV0IHRvX2FycmF5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IFt8fF1cbiAgICB8IExlYWYgdiAtPiBbfCB2IHxdXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgbGV0IHJlcyA9IEFycmF5LmNyZWF0ZSB+bGVuOnMgdiBpblxuICAgICAgbGV0IHBvc19yZWYgPSByZWYgMCBpblxuICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgKCogSW52YXJpYW50OiBvbiBlbnRyeSBhbmQgb24gZXhpdCB0byBbbG9vcF0sICFwb3NfcmVmIGlzIHRoZSBuZXh0XG4gICAgICAgICAgIGF2YWlsYWJsZSBjZWxsIGluIHRoZSBhcnJheS4gKilcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IExlYWYgdiAtPlxuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgICBsb29wIGw7XG4gICAgICAgICAgcmVzLighcG9zX3JlZikgPC0gdjtcbiAgICAgICAgICBpbmNyIHBvc19yZWY7XG4gICAgICAgICAgbG9vcCByXG4gICAgICBpblxuICAgICAgbG9vcCBsO1xuICAgICAgKCogcmVzLighcG9zX3JlZikgaXMgYWxyZWFkeSBpbml0aWFsaXplZCAoYnkgQXJyYXkuY3JlYXRlIH5sZW46YWJvdmUpLiAqKVxuICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgbG9vcCByO1xuICAgICAgcmVzXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mIH5jb21wYXJlX2VsdCA9IGZvbGQgdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCAoZiB4KSB+Y29tcGFyZV9lbHQpXG5cbiAgbGV0IGdyb3VwX2J5IHNldCB+ZXF1aXYgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGxvb3Agc2V0IGVxdWl2X2NsYXNzZXMgPVxuICAgICAgaWYgaXNfZW1wdHkgc2V0XG4gICAgICB0aGVuIGVxdWl2X2NsYXNzZXNcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeCA9IGNob29zZV9leG4gc2V0IGluXG4gICAgICAgIGxldCBlcXVpdl94LCBub3RfZXF1aXZfeCA9XG4gICAgICAgICAgcGFydGl0aW9uX3RmIHNldCB+ZjooZnVuIGVsdCAtPiBwaHlzX2VxdWFsIHggZWx0IHx8IGVxdWl2IHggZWx0KSB+Y29tcGFyZV9lbHRcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCBub3RfZXF1aXZfeCAoZXF1aXZfeCA6OiBlcXVpdl9jbGFzc2VzKSlcbiAgICBpblxuICAgIGxvb3Agc2V0IFtdXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gU29tZSB2XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggZmluZCBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbmQgciB+ZlxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX21hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBmIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAobWF0Y2ggZiB2IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIChtYXRjaCBmaW5kX21hcCBsIH5mIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgciB+ZlxuICAgICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcikpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2V0LmZpbmRfZXhuIGZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgZWxlbWVudFwiXG4gICAgfCBTb21lIGUgLT4gZVxuICA7O1xuXG4gIGxldCByZWMgbnRoIHQgaSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgaSA9IDAgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBzKSAtPlxuICAgICAgaWYgaSA+PSBzXG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbF9zaXplID0gbGVuZ3RoIGwgaW5cbiAgICAgICAgbGV0IGMgPSBQb2x5LmNvbXBhcmUgaSBsX3NpemUgaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBudGggbCBpIGVsc2UgaWYgYyA9IDAgdGhlbiBTb21lIHYgZWxzZSBudGggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgbG9vcCB4cyBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuID1cbiAgICAgIG1hdGNoIHhzIHdpdGhcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgbGVmdG92ZXJzXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGlmIG1lbSBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0XG4gICAgICAgIHRoZW4gbG9vcCB0bCBsZWZ0b3ZlcnMgYWxyZWFkeV9zZWVuXG4gICAgICAgIGVsc2UgbG9vcCB0bCAoaGQgOjogbGVmdG92ZXJzKSAoYWRkIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHQpXG4gICAgaW5cbiAgICBsb29wIHhzIFtdIGVtcHR5XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgYV9vZl9zZXhwIHNleHAgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuTGlzdCBsc3QgLT5cbiAgICAgIGxldCBlbHRfbHN0ID0gTGlzdC5tYXAgbHN0IH5mOmFfb2Zfc2V4cCBpblxuICAgICAgbGV0IHNldCA9IG9mX2xpc3QgZWx0X2xzdCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGxlbmd0aCBzZXQgPSBMaXN0Lmxlbmd0aCBsc3RcbiAgICAgIHRoZW4gc2V0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHNldCA9IHJlZiBlbXB0eSBpblxuICAgICAgICBMaXN0Lml0ZXIyX2V4biBsc3QgZWx0X2xzdCB+ZjooZnVuIGVsX3NleHAgZWwgLT5cbiAgICAgICAgICBpZiBtZW0gIXNldCBlbCB+Y29tcGFyZV9lbHRcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBkdXBsaWNhdGUgZWxlbWVudCBpbiBzZXRcIiBlbF9zZXhwXG4gICAgICAgICAgZWxzZSBzZXQgOj0gYWRkICFzZXQgZWwgfmNvbXBhcmVfZWx0KTtcbiAgICAgICAgYXNzZXJ0IGZhbHNlKVxuICAgIHwgc2V4cCAtPiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biBlbCBhY2MgLT4gc2V4cF9vZl9hIGVsIDo6IGFjYykpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgdHJlZSA6ICdhIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgbGV0IGlzX3N1YnNldCAoc3Vic2V0IDogXyB0KSB+b2ZfOihzdXBlcnNldCA6IF8gdCkgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdCA9XG4gICAgICBsZXQgaW52YWxpZF9lbGVtZW50cyA9IGRpZmYgc3Vic2V0LnRyZWUgc3VwZXJzZXQudHJlZSB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGlmIGlzX2VtcHR5IGludmFsaWRfZWxlbWVudHNcbiAgICAgIHRoZW4gT2sgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaW52YWxpZF9lbGVtZW50c19zZXhwID0gc2V4cF9vZl90IHNleHBfb2ZfZWx0IGludmFsaWRfZWxlbWVudHMgaW5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAoc3Vic2V0Lm5hbWUgXiBcIiBpcyBub3QgYSBzdWJzZXQgb2YgXCIgXiBzdXBlcnNldC5uYW1lKVxuICAgICAgICAgICAgIFsgXCJpbnZhbGlkX2VsZW1lbnRzXCIsIGludmFsaWRfZWxlbWVudHNfc2V4cCBdKSlcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHMxIHMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxuICAgICAgICBbIGlzX3N1YnNldCBzMSB+b2ZfOnMyIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgOyBpc19zdWJzZXQgczIgfm9mXzpzMSB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIF1cbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPVxuICB7ICgqIFtjb21wYXJhdG9yXSBpcyB0aGUgZmlyc3QgZmllbGQgc28gdGhhdCBwb2x5bW9ycGhpYyBlcXVhbGl0eSBmYWlscyBvbiBhIG1hcCBkdWVcbiAgICAgICB0byB0aGUgZnVuY3Rpb25hbCB2YWx1ZSBpbiB0aGUgY29tcGFyYXRvci5cbiAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgcG9seW1vcnBoaWMgW2NvbXBhcmVdOiB0aGF0IHN0aWxsIHByb2R1Y2VzXG4gICAgICAgbm9uc2Vuc2UuICopXG4gICAgY29tcGFyYXRvciA6ICgnYSwgJ2NvbXBhcmF0b3IpIENvbXBhcmF0b3IudFxuICA7IHRyZWUgOiAnYSBUcmVlMC50XG4gIH1cblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlID0gJ2EgVHJlZTAudFxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBjb21wYXJhdG9yIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvciB9XG5sZXQgY29tcGFyZV9lbHQgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCBpbnZhcmlhbnRzIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0LnRyZWVcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0LnRyZWVcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdC50cmVlXG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHQudHJlZVxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0LnRyZWVcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0LnRyZWVcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEudHJlZSBiLnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBhKVxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQudHJlZSB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0LnRyZWUgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0LnRyZWUgfmZcbiAgbGV0IG1lbSB0IGEgPSBUcmVlMC5tZW0gdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgZmlsdGVyIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IGFkZCB0IGEgPSBsaWtlIHQgKFRyZWUwLmFkZCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgcmVtb3ZlIHQgYSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLnVuaW9uIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGludGVyIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuaW50ZXIgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmRpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY29tcGFyZV9lbHQgdDEpIHQxLnRyZWUgdDIudHJlZVxuICBsZXQgZXF1YWwgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgbGV0IGlzX3N1YnNldCB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdC50cmVlIH5vZl86b2ZfLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuXG4gIGxldCBhcmVfZGlzam9pbnQgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyBzZXQgOiAoJ2EsICdjbXApIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgbGV0IHRvX25hbWVkX3RyZWUgeyBzZXQ7IG5hbWUgfSA9IHsgVHJlZTAuTmFtZWQudHJlZSA9IHNldC50cmVlOyBuYW1lIH1cblxuICAgIGxldCBpc19zdWJzZXQgKHN1YnNldCA6IChfLCBfKSB0KSB+b2ZfOihzdXBlcnNldCA6IChfLCBfKSB0KSA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgKHRvX25hbWVkX3RyZWUgc3Vic2V0KVxuICAgICAgICB+b2ZfOih0b19uYW1lZF90cmVlIHN1cGVyc2V0KVxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHN1YnNldC5zZXQpXG4gICAgICAgIH5zZXhwX29mX2VsdDpzdWJzZXQuc2V0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB0MSB0MiA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0IFsgaXNfc3Vic2V0IHQxIH5vZl86dDI7IGlzX3N1YnNldCB0MiB+b2ZfOnQxIF1cbiAgICA7O1xuICBlbmRcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIGxldCB0cmVlX3QsIHRyZWVfZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlX3QsIGxpa2UgdCB0cmVlX2ZcbiAgOztcblxuICBsZXQgc3BsaXQgdCBhID1cbiAgICBsZXQgdHJlZTEsIGIsIHRyZWUyID0gVHJlZTAuc3BsaXQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgYiwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IHQgfmVxdWl2ID1cbiAgICBMaXN0Lm1hcCAoVHJlZTAuZ3JvdXBfYnkgdC50cmVlIH5lcXVpdiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKSB+ZjoobGlrZSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQudHJlZSBpXG4gIGxldCByZW1vdmVfaW5kZXggdCBpID0gbGlrZSB0IChUcmVlMC5yZW1vdmVfaW5kZXggdC50cmVlIGkgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIHQuY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gICAgICB0Jy50cmVlXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBzdGF0ZSB0LnRyZWVcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG5sZXQgY29tcGFyZSBfIF8gdDEgdDIgPSBjb21wYXJlX2RpcmVjdCB0MSB0MlxuXG5tb2R1bGUgVHJlZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2EsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGNlIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcikgYV9vZl9zZXhwIHNleHBcbiAgOztcblxuICBsZXQgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA9IFRyZWUwLmVtcHR5XG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvcjpfID0gZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gZSA9IFRyZWUwLnNpbmdsZXRvbiBlXG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG4gIGxldCBpbnZhcmlhbnRzIH5jb21wYXJhdG9yIHQgPSBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHRcbiAgbGV0IGVsZW1lbnRzIHQgPSBUcmVlMC5lbGVtZW50cyB0XG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBjaG9vc2UgdCA9IFRyZWUwLmNob29zZSB0XG4gIGxldCBjaG9vc2VfZXhuIHQgPSBUcmVlMC5jaG9vc2VfZXhuIHRcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdFxuICBsZXQgdG9fYXJyYXkgdCA9IFRyZWUwLnRvX2FycmF5IHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdCB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBUcmVlMC5maW5kX21hcCB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfdW50aWwgdCB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5pbml0IH5mXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlciB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHBhcnRpdGlvbl90ZiB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAucGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgYSBiIH5mID0gVHJlZTAuaXRlcjIgYSBiIH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5tZW0gdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5hZGQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5yZW1vdmUgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAudW5pb24gdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaW50ZXIgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5pbnRlciB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBkaWZmIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY2UgY29tcGFyYXRvcikgdDEgdDJcbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQgfm9mXyA9IFRyZWUwLmlzX3N1YnNldCB0IH5vZl8gfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBhcmVfZGlzam9pbnQgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYSA9XG4gICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6XyB+bGVuIH5mID1cbiAgICBUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhID0gVHJlZTAub2Zfc29ydGVkX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAudW5pb25fbGlzdCBsIH50b190cmVlOkZuLmlkIH5jb21wYXJhdG9yXG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IGdyb3VwX2J5IH5jb21wYXJhdG9yIHQgfmVxdWl2ID0gVHJlZTAuZ3JvdXBfYnkgdCB+ZXF1aXYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdCBpXG4gIGxldCByZW1vdmVfaW5kZXggfmNvbXBhcmF0b3IgdCBpID0gVHJlZTAucmVtb3ZlX2luZGV4IHQgaSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdFxuICBsZXQgdG9fdHJlZSB0ID0gdFxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvcjpfIHQgPSB0XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnID1cbiAgICBUcmVlMC5tZXJnZV90b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0IHQnXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVHJlZTAuTmFtZWRcblxuICAgIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdDEgfm9mXzp0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5pc19zdWJzZXRcbiAgICAgICAgdDFcbiAgICAgICAgfm9mXzp0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgICBUcmVlMC5OYW1lZC5lcXVhbFxuICAgICAgICB0MVxuICAgICAgICB0MlxuICAgICAgICB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gICAgICAgIH5zZXhwX29mX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcbiAgZW5kXG5lbmRcblxubW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZVxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC50X29mX3NleHBfZGlyZWN0IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLmNvbXBhcmUgYV9vZl9zZXhwIHNleHApXG4gIDs7XG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA9IHsgY29tcGFyYXRvciA9IEVsdC5jb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuZW1wdHkgfVxuICBlbmRcblxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5zaW5nbGV0b24gZSB9XG5cbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAudW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSBsKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBsZXQgdHJlZSA9XG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgeyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZiA9XG4gICAgb2ZfdHJlZSB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZilcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5Nb25hZF9pbmZpeC4oXG4gICAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICA+PnwgZnVuIHRyZWUgLT4geyBjb21wYXJhdG9yOyB0cmVlIH0pXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgfmNvbXBhcmF0b3IgbCA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG1hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yXG4gICAgOyB0cmVlID0gVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfVxuICA7O1xuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbnR5cGUgKCdlbHQsICdjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcblxubGV0IGNvbXBhcmF0b3JfcyAodHlwZSBrIGNtcCkgdCA6IChrLCBjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGtcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcFxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3JcbiAgZW5kKVxuOztcblxubGV0IHRvX2NvbXBhcmF0b3IgKHR5cGUgZWx0IGNtcCkgKChtb2R1bGUgTSkgOiAoZWx0LCBjbXApIGNvbXBhcmF0b3IpID0gTS5jb21wYXJhdG9yXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IHVuaW9uX2xpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci51bmlvbl9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBtIH5sZW4gfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIH5sZW4gfmZcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2xpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9zZXF1ZW5jZSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IHN0YWJsZV9kZWR1cF9saXN0IG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iuc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG1hcCBtIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG5sZXQgZmlsdGVyX21hcCBtIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLmZpbHRlcl9tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuXG5tb2R1bGUgTSAoRWx0IDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgICAgICh0eXBlIGVsdCBjbXApXG4gICAgICAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOkVsdC5jb21wYXJhdG9yIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdClcbiAgOiAoZWx0LCBfKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGVsdCkgc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEVsdC5oYXNoX2ZvbGRfdCBzdGF0ZVxuOztcblxubGV0IGhhc2hfbV9fdCBmb2xkZXIgdCA9XG4gIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9tX190IGZvbGRlciAoSGFzaC5jcmVhdGUgKCkpIHQgaW5cbiAgSGFzaC5nZXRfaGFzaF92YWx1ZSBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSBzZXQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgJ2VsdCB0cmVlID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdHJlZVxuICB0eXBlIG5vbnJlYyAnZWx0IG5hbWVkID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgTmFtZWQudFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvclxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgdW5pb25fbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci51bmlvbl9saXN0IH5jb21wYXJhdG9yIGFcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2Zfc2VxdWVuY2UgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcCB+Y29tcGFyYXRvciBhIH5mXG4gIGxldCBmaWx0ZXJfbWFwIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLmZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgb2ZfdHJlZSB0cmVlID0geyBjb21wYXJhdG9yOyB0cmVlIH1cbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgcmVmIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX3JlZlxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID0gZXF1YWxfcmVmXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSByZWZfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9yZWZcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IHJlZl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmQgOlxuc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxuKCogSW4gdGhlIGRlZmluaXRpb24gb2YgW3RdLCB3ZSBkbyBub3QgaGF2ZSBbW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1dIGJlY2F1c2VcbiAgIGluIGdlbmVyYWwsIHN5bnRheCBleHRlbnNpb25zIHRlbmQgdG8gdXNlIHRoZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGF2YWlsYWJsZSByYXRoZXIgdGhhblxuICAgdXNpbmcgdGhlIGFsaWFzLiAgSGVyZSB0aGF0IHdvdWxkIGxlYWQgdG8gdXNlIHRoZSByZWNvcmQgcmVwcmVzZW50YXRpb24gWyB7IG11dGFibGVcbiAgIGNvbnRlbnRzIDogJ2EgfSBdIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBkaWZmZXJlbnQgKGFuZCB1bndhbnRlZCkgYmVoYXZpb3IuICAqKVxudHlwZSAnYSB0ID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG5leHRlcm5hbCBjcmVhdGUgOiAnYSAtPiAnYSB0ID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSB0IC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHQgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbmxldCBzd2FwIHQxIHQyID1cbiAgbGV0IHRtcCA9ICF0MSBpblxuICB0MSA6PSAhdDI7XG4gIHQyIDo9IHRtcFxuOztcblxubGV0IHJlcGxhY2UgdCBmID0gdCA6PSBmICF0XG5cbmxldCBzZXRfdGVtcG9yYXJpbHkgdCBhIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSAhdCBpblxuICB0IDo9IGE7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gdCA6PSByZXN0b3JlX3RvKVxuOztcblxubW9kdWxlIEFuZF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUIDogJ2EgcmVmICogJ2EgLT4gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBzZXQgKFQgKHIsIGEpKSA9IHIgOj0gYVxuICBsZXQgc2V0cyB0cyA9IExpc3QuaXRlciB0cyB+ZjpzZXRcbiAgbGV0IHNuYXBzaG90IChUIChyLCBfKSkgPSBUIChyLCAhcilcbiAgbGV0IHNuYXBzaG90cyB0cyA9IExpc3QubWFwIHRzIH5mOnNuYXBzaG90XG5lbmRcblxubGV0IHNldHNfdGVtcG9yYXJpbHkgYW5kX3ZhbHVlcyB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gQW5kX3ZhbHVlLnNuYXBzaG90cyBhbmRfdmFsdWVzIGluXG4gIEFuZF92YWx1ZS5zZXRzIGFuZF92YWx1ZXM7XG4gIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gQW5kX3ZhbHVlLnNldHMgcmVzdG9yZV90bylcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuXG4oKiBbdF0gc3RvcmVzIHRoZSBbdC5sZW5ndGhdIHF1ZXVlIGVsZW1lbnRzIGF0IGNvbnNlY3V0aXZlIGluY3JlYXNpbmcgaW5kaWNlcyBvZiBbdC5lbHRzXSxcbiAgIG1vZCB0aGUgY2FwYWNpdHkgb2YgW3RdLCB3aGljaCBpcyBbT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAgVGhlIGNhcGFjaXR5IGlzXG4gICByZXF1aXJlZCB0byBiZSBhIHBvd2VyIG9mIHR3byAodXNlci1yZXF1ZXN0ZWQgY2FwYWNpdGllcyBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdFxuICAgcG93ZXIpLCBzbyB0aGF0IG1vZCBjYW4gcXVpY2tseSBiZSBjb21wdXRlZCB1c2luZyBbbGFuZCB0Lm1hc2tdLCB3aGVyZSBbdC5tYXNrID1cbiAgIGNhcGFjaXR5IHQgLSAxXS4gIFNvLCBxdWV1ZSBlbGVtZW50IFtpXSBpcyBhdCBbdC5lbHRzLiggKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFzayApXS5cblxuICAgW251bV9tdXRhdGlvbnNdIGlzIHVzZWQgdG8gZGV0ZWN0IG1vZGlmaWNhdGlvbiBkdXJpbmcgaXRlcmF0aW9uLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIG51bV9tdXRhdGlvbnMgOiBpbnRcbiAgOyBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBtYXNrIDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxX1xuICAgIHsgbnVtX211dGF0aW9ucyA9IG51bV9tdXRhdGlvbnNfXzAwM19cbiAgICA7IGZyb250ID0gZnJvbnRfXzAwNV9cbiAgICA7IG1hc2sgPSBtYXNrX18wMDdfXG4gICAgOyBsZW5ndGggPSBsZW5ndGhfXzAwOV9cbiAgICA7IGVsdHMgPSBlbHRzX18wMTFfXG4gICAgfSAtPlxuICAgIGxldCBibmRzX18wMDJfID0gW10gaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMTJfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMTFfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDEyXyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAxMF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwOV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAxMF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9pbnQgbWFza19fMDA3XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFza1wiOyBhcmdfXzAwOF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDZfID0gc2V4cF9vZl9pbnQgZnJvbnRfXzAwNV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImZyb250XCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBudW1fbXV0YXRpb25zX18wMDNfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJudW1fbXV0YXRpb25zXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDJfXG47O1xuXG5bQEBAZW5kXVxuXG5tb2R1bGUgdHlwZSBTID0gUXVldWVfaW50Zi5TXG5cbmxldCBpbmNfbnVtX211dGF0aW9ucyB0ID0gdC5udW1fbXV0YXRpb25zIDwtIHQubnVtX211dGF0aW9ucyArIDFcbmxldCBjYXBhY2l0eSB0ID0gdC5tYXNrICsgMVxubGV0IGVsdHNfaW5kZXggdCBpID0gKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFza1xubGV0IHVuc2FmZV9nZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfaXNfc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfaXNfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIGEgPSBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpIGFcbmxldCB1bnNhZmVfdW5zZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxuXG5sZXQgY2hlY2tfaW5kZXhfZXhuIHQgaSA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gdC5sZW5ndGhcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiUXVldWUgaW5kZXggb3V0IG9mIGJvdW5kc1wiXG4gICAgICAgICBbIFwiaW5kZXhcIiwgaSB8PiBJbnQuc2V4cF9vZl90OyBcImxlbmd0aFwiLCB0Lmxlbmd0aCB8PiBJbnQuc2V4cF9vZl90IF0pXG47O1xuXG5sZXQgZ2V0IHQgaSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIHVuc2FmZV9nZXQgdCBpXG47O1xuXG5sZXQgc2V0IHQgaSBhID1cbiAgY2hlY2tfaW5kZXhfZXhuIHQgaTtcbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgdW5zYWZlX3NldCB0IGkgYVxuOztcblxubGV0IGlzX2VtcHR5IHQgPSB0Lmxlbmd0aCA9IDBcbmxldCBsZW5ndGggeyBsZW5ndGg7IF8gfSA9IGxlbmd0aFxuXG5sZXQgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9ucyA9XG4gIGlmIHQubnVtX211dGF0aW9ucyA8PiBudW1fbXV0YXRpb25zXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIm11dGF0aW9uIG9mIHF1ZXVlIGR1cmluZyBpdGVyYXRpb25cIlxuICAgICAgICAgWyBcIlwiLCB0IHw+IHNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSBdKVxuOztcblxubGV0IGNvbXBhcmUgPVxuICBsZXQgcmVjIHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgcG9zIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDIgPVxuICAgIG1hdGNoIHBvcyA9IGxlbjEsIHBvcyA9IGxlbjIgd2l0aFxuICAgIHwgdHJ1ZSwgdHJ1ZSAtPiAwXG4gICAgfCB0cnVlLCBmYWxzZSAtPiAtMVxuICAgIHwgZmFsc2UsIHRydWUgLT4gMVxuICAgIHwgZmFsc2UsIGZhbHNlIC0+XG4gICAgICBsZXQgeCA9IGNvbXBhcmVfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDIgbXV0MjtcbiAgICAgIChtYXRjaCB4IHdpdGhcbiAgICAgICB8IDAgLT4gdW5zYWZlX2NvbXBhcmVfZnJvbSBjb21wYXJlX2VsdCAocG9zICsgMSkgfnQxIH50MiB+bGVuMSB+bGVuMiB+bXV0MSB+bXV0MlxuICAgICAgIHwgbiAtPiBuKVxuICBpblxuICBmdW4gY29tcGFyZV9lbHQgdDEgdDIgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHQxIHQyXG4gICAgdGhlbiAwXG4gICAgZWxzZVxuICAgICAgdW5zYWZlX2NvbXBhcmVfZnJvbVxuICAgICAgICBjb21wYXJlX2VsdFxuICAgICAgICAwXG4gICAgICAgIH50MVxuICAgICAgICB+dDJcbiAgICAgICAgfmxlbjE6dDEubGVuZ3RoXG4gICAgICAgIH5sZW4yOnQyLmxlbmd0aFxuICAgICAgICB+bXV0MTp0MS5udW1fbXV0YXRpb25zXG4gICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBlcXVhbCA9XG4gIGxldCByZWMgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IHBvcyB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW4gPVxuICAgIHBvcyA9IGxlblxuICAgIHx8XG4gICAgbGV0IGIgPSBlcXVhbF9lbHQgKHVuc2FmZV9nZXQgdDEgcG9zKSAodW5zYWZlX2dldCB0MiBwb3MpIGluXG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgYiAmJiB1bnNhZmVfZXF1YWxfZnJvbSBlcXVhbF9lbHQgKHBvcyArIDEpIH50MSB+dDIgfm11dDEgfm11dDIgfmxlblxuICBpblxuICBmdW4gZXF1YWxfZWx0IHQxIHQyIC0+XG4gICAgcGh5c19lcXVhbCB0MSB0MlxuICAgIHx8XG4gICAgbGV0IGxlbjEgPSB0MS5sZW5ndGggaW5cbiAgICBsZXQgbGVuMiA9IHQyLmxlbmd0aCBpblxuICAgIGxlbjEgPSBsZW4yXG4gICAgJiYgdW5zYWZlX2VxdWFsX2Zyb21cbiAgICAgICAgIGVxdWFsX2VsdFxuICAgICAgICAgMFxuICAgICAgICAgfnQxXG4gICAgICAgICB+dDJcbiAgICAgICAgIH5sZW46bGVuMVxuICAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICAgfm11dDI6dDIubnVtX211dGF0aW9uc1xuOztcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbGV0IHsgbnVtX211dGF0aW9uczsgbWFzayA9IF87IGVsdHM7IGZyb250OyBsZW5ndGggfSA9IHQgaW5cbiAgYXNzZXJ0IChmcm9udCA+PSAwKTtcbiAgYXNzZXJ0IChmcm9udCA8IGNhcGFjaXR5IHQpO1xuICBsZXQgY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGFzc2VydCAoY2FwYWNpdHkgPSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICBhc3NlcnQgKGNhcGFjaXR5ID49IDEpO1xuICBhc3NlcnQgKEludC5pc19wb3cyIGNhcGFjaXR5KTtcbiAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5KTtcbiAgZm9yIGkgPSAwIHRvIGNhcGFjaXR5IC0gMSBkb1xuICAgIGlmIGkgPCB0Lmxlbmd0aFxuICAgIHRoZW4gKFxuICAgICAgaW52YXJpYW50X2EgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMpXG4gICAgZWxzZSBhc3NlcnQgKG5vdCAodW5zYWZlX2lzX3NldCB0IGkpKVxuICBkb25lXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpID9jYXBhY2l0eSAoKSA6IGEgdCA9XG4gIGxldCBjYXBhY2l0eSA9XG4gICAgbWF0Y2ggY2FwYWNpdHkgd2l0aFxuICAgIHwgTm9uZSAtPiAxXG4gICAgfCBTb21lIGNhcGFjaXR5IC0+XG4gICAgICBpZiBjYXBhY2l0eSA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcImNhbm5vdCBoYXZlIHF1ZXVlIHdpdGggbmVnYXRpdmUgY2FwYWNpdHlcIlxuICAgICAgICAgICAgIFsgXCJjYXBhY2l0eVwiLCBjYXBhY2l0eSB8PiBJbnQuc2V4cF9vZl90IF0pXG4gICAgICBlbHNlIGlmIGNhcGFjaXR5ID0gMFxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIEludC5jZWlsX3BvdzIgY2FwYWNpdHlcbiAgaW5cbiAgeyBudW1fbXV0YXRpb25zID0gMFxuICA7IGZyb250ID0gMFxuICA7IG1hc2sgPSBjYXBhY2l0eSAtIDFcbiAgOyBsZW5ndGggPSAwXG4gIDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpjYXBhY2l0eVxuICB9XG47O1xuXG5sZXQgYmxpdF90b19hcnJheSB+c3JjIGRzdCA9XG4gIGFzc2VydCAoc3JjLmxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGRzdCk7XG4gIGxldCBmcm9udF9sZW4gPSBJbnQubWluIHNyYy5sZW5ndGggKGNhcGFjaXR5IHNyYyAtIHNyYy5mcm9udCkgaW5cbiAgbGV0IHJlc3RfbGVuID0gc3JjLmxlbmd0aCAtIGZyb250X2xlbiBpblxuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOmZyb250X2xlbiB+c3JjOnNyYy5lbHRzIH5zcmNfcG9zOnNyYy5mcm9udCB+ZHN0IH5kc3RfcG9zOjA7XG4gIE9wdGlvbl9hcnJheS5ibGl0IH5sZW46cmVzdF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6ZnJvbnRfbGVuXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgZGVzaXJlZF9jYXBhY2l0eSA9XG4gICgqIFdlIGFsbG93IGFyZ3VtZW50cyBsZXNzIHRoYW4gMSB0byBbc2V0X2NhcGFjaXR5XSwgYnV0IHRyYW5zbGF0ZSB0aGVtIHRvIDEgdG8gc2ltcGxpZnlcbiAgICAgdGhlIGNvZGUgdGhhdCByZWxpZXMgb24gdGhlIGFycmF5IGxlbmd0aCBiZWluZyBhIHBvd2VyIG9mIDIuICopXG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBuZXdfY2FwYWNpdHkgPSBJbnQuY2VpbF9wb3cyIChtYXggMSAobWF4IGRlc2lyZWRfY2FwYWNpdHkgdC5sZW5ndGgpKSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdFxuICB0aGVuIChcbiAgICBsZXQgZHN0ID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOm5ld19jYXBhY2l0eSBpblxuICAgIGJsaXRfdG9fYXJyYXkgfnNyYzp0IGRzdDtcbiAgICB0LmZyb250IDwtIDA7XG4gICAgdC5tYXNrIDwtIG5ld19jYXBhY2l0eSAtIDE7XG4gICAgdC5lbHRzIDwtIGRzdClcbjs7XG5cbmxldCBlbnF1ZXVlIHQgYSA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eSB0ICgyICogdC5sZW5ndGgpO1xuICB1bnNhZmVfc2V0IHQgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgZGVxdWV1ZV9ub25lbXB0eSB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IGVsdHMgPSB0LmVsdHMgaW5cbiAgbGV0IGZyb250ID0gdC5mcm9udCBpblxuICBsZXQgcmVzID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGZyb250IGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSBlbHRzIGZyb250O1xuICB0LmZyb250IDwtIGVsdHNfaW5kZXggdCAxO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIHJlc1xuOztcblxubGV0IGRlcXVldWVfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGRlcXVldWVfbm9uZW1wdHkgdFxubGV0IGRlcXVldWUgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZGVxdWV1ZV9ub25lbXB0eSB0KVxubGV0IGZyb250X25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgdC5mcm9udFxubGV0IGxhc3Rfbm9uZW1wdHkgdCA9IHVuc2FmZV9nZXQgdCAodC5sZW5ndGggLSAxKVxubGV0IHBlZWsgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZnJvbnRfbm9uZW1wdHkgdClcbmxldCBwZWVrX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBmcm9udF9ub25lbXB0eSB0XG5sZXQgbGFzdCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChsYXN0X25vbmVtcHR5IHQpXG5sZXQgbGFzdF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgbGFzdF9ub25lbXB0eSB0XG5cbmxldCBjbGVhciB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPiAwXG4gIHRoZW4gKFxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHVuc2FmZV91bnNldCB0IGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgdC5mcm9udCA8LSAwKVxuOztcblxubGV0IGJsaXRfdHJhbnNmZXIgfnNyYyB+ZHN0ID9sZW4gKCkgPVxuICBpbmNfbnVtX211dGF0aW9ucyBzcmM7XG4gIGluY19udW1fbXV0YXRpb25zIGRzdDtcbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gc3JjLmxlbmd0aFxuICAgIHwgU29tZSBsZW4gLT5cbiAgICAgIGlmIGxlbiA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcIlF1ZXVlLmJsaXRfdHJhbnNmZXI6IG5lZ2F0aXZlIGxlbmd0aFwiXG4gICAgICAgICAgICAgWyBcImxlbmd0aFwiLCBsZW4gfD4gSW50LnNleHBfb2ZfdCBdKTtcbiAgICAgIG1pbiBsZW4gc3JjLmxlbmd0aFxuICBpblxuICBpZiBsZW4gPiAwXG4gIHRoZW4gKFxuICAgIHNldF9jYXBhY2l0eSBkc3QgKG1heCAoY2FwYWNpdHkgZHN0KSAoZHN0Lmxlbmd0aCArIGxlbikpO1xuICAgIGxldCBkc3Rfc3RhcnQgPSBkc3QuZnJvbnQgKyBkc3QubGVuZ3RoIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICgqIFRoaXMgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiBzaW1wbHkgW2VucXVldWUgZHN0IChkZXF1ZXVlX25vbmVtcHR5IHNyYyldICopXG4gICAgICBsZXQgc3JjX2kgPSAoc3JjLmZyb250ICsgaSkgbGFuZCBzcmMubWFzayBpblxuICAgICAgbGV0IGRzdF9pID0gKGRzdF9zdGFydCArIGkpIGxhbmQgZHN0Lm1hc2sgaW5cbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWVcbiAgICAgICAgZHN0LmVsdHNcbiAgICAgICAgZHN0X2lcbiAgICAgICAgKE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHNyYy5lbHRzIHNyY19pKTtcbiAgICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgc3JjLmVsdHMgc3JjX2lcbiAgICBkb25lO1xuICAgIGRzdC5sZW5ndGggPC0gZHN0Lmxlbmd0aCArIGxlbjtcbiAgICBzcmMuZnJvbnQgPC0gKHNyYy5mcm9udCArIGxlbikgbGFuZCBzcmMubWFzaztcbiAgICBzcmMubGVuZ3RoIDwtIHNyYy5sZW5ndGggLSBsZW4pXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIHNldF9jYXBhY2l0eSB0IChJbnQubWF4IChjYXBhY2l0eSB0KSAodC5sZW5ndGggKyBMaXN0Lmxlbmd0aCBsKSk7XG4gIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeClcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gICAgbGV0IHIgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICAgIGRvbmU7XG4gICAgIXIpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGEgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgYSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYylcbjs7XG5cblxuKCogW2l0ZXJdIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGJlY2F1c2UgaW1wbGVtZW50aW5nIGl0IGluIHRlcm1zIG9mIFtmb2xkXSBpc1xuICAgc2xvd2VyLiAqKVxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVzdWx0ID0gcmVmIFtdIGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgcmVzdWx0IDo9IHVuc2FmZV9nZXQgdCBpIDo6ICFyZXN1bHRcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICBlbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5cblxuKCogRm9yIFtjb25jYXRfbWFwXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl0sIHdlIGRvbid0IGNyZWF0ZSBbdF9yZXN1bHRdIHdpdGggW3RdJ3NcbiAgIGNhcGFjaXR5IGJlY2F1c2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyBtYW55IGVsZW1lbnRzIFt0X3Jlc3VsdF0gd2lsbCB1bHRpbWF0ZWx5IGhvbGQuICopXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlciB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlcmkgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlIH5jYXBhY2l0eTpzcmMubGVuZ3RoICgpIGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QuZWx0cztcbiAgZHN0Lmxlbmd0aCA8LSBzcmMubGVuZ3RoO1xuICBkc3Rcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OihMaXN0Lmxlbmd0aCBsKSAoKSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG4oKiBUaGUgcXVldWUgW3RdIHJldHVybmVkIGJ5IFtjcmVhdGVdIHdpbGwgaGF2ZSBbdC5sZW5ndGggPSAwXSwgW3QuZnJvbnQgPSAwXSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IEludC5jZWlsX3BvdzIgbGVuXS4gIFNvLCB3ZSBvbmx5IGhhdmUgdG8gc2V0IFt0Lmxlbmd0aF0gdG8gW2xlbl0gYWZ0ZXJcbiAgIHRoZSBibGl0IHRvIG1haW50YWluIGFsbCB0aGUgaW52YXJpYW50czogW3QubGVuZ3RoXSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICBpbiB0aGUgcXVldWUsIFt0LmZyb250XSBpcyB0aGUgYXJyYXkgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAqKVxubGV0IGluaXQgbGVuIH5mID1cbiAgaWYgbGVuIDwgMFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIlF1ZXVlLmluaXQ6IG5lZ2F0aXZlIGxlbmd0aFwiIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTpsZW4gKCkgaW5cbiAgYXNzZXJ0IChPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyA+PSBsZW4pO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIGkgKGYgaSlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gbGVuO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkudW5zYWZlX2dldCBhKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IHQubGVuZ3RoIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IG1hcCB0YSB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdGEubnVtX211dGF0aW9ucyBpblxuICBsZXQgdGIgPSBjcmVhdGUgfmNhcGFjaXR5OnRhLmxlbmd0aCAoKSBpblxuICB0Yi5sZW5ndGggPC0gdGEubGVuZ3RoO1xuICBmb3IgaSA9IDAgdG8gdGEubGVuZ3RoIC0gMSBkb1xuICAgIGxldCBiID0gZiAodW5zYWZlX2dldCB0YSBpKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0YSBudW1fbXV0YXRpb25zO1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdGIuZWx0cyBpIGJcbiAgZG9uZTtcbiAgdGJcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIG1hcCB0IH5mOihmdW4gYSAtPlxuICAgIGxldCByZXN1bHQgPSBmICFpIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICByZXN1bHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgeDtcbiAgdFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHRvX2xpc3QgdCB8PiBMaXN0LnNleHBfb2ZfdCBzZXhwX29mX2FcbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBMaXN0LnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCB8PiBvZl9saXN0XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcbiIsIm9wZW4hIEltcG9ydDBcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbC5RdWV1ZS50XG5cbmxldCBjcmVhdGUgPSBDYW1sLlF1ZXVlLmNyZWF0ZVxubGV0IGNsZWFyID0gQ2FtbC5RdWV1ZS5jbGVhclxubGV0IGNvcHkgPSBDYW1sLlF1ZXVlLmNvcHlcbmxldCBpc19lbXB0eSA9IENhbWwuUXVldWUuaXNfZW1wdHlcbmxldCBsZW5ndGggPSBDYW1sLlF1ZXVlLmxlbmd0aFxubGV0IHBlZWsgPSBDYW1sLlF1ZXVlLnBlZWtcbmxldCBwb3AgPSBDYW1sLlF1ZXVlLnBvcFxubGV0IHB1c2ggPSBDYW1sLlF1ZXVlLnB1c2hcbmxldCB0cmFuc2ZlciA9IENhbWwuUXVldWUudHJhbnNmZXJcbmxldCBpdGVyIHQgfmYgPSBDYW1sLlF1ZXVlLml0ZXIgZiB0XG5sZXQgZm9sZCB0IH5pbml0IH5mID0gQ2FtbC5RdWV1ZS5mb2xkIGYgaW5pdCB0XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgTGlua2VkX3F1ZXVlMFxuXG5sZXQgZW5xdWV1ZSB0IHggPSBMaW5rZWRfcXVldWUwLnB1c2ggeCB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBvcCB0KVxubGV0IGRlcXVldWVfZXhuID0gTGlua2VkX3F1ZXVlMC5wb3BcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG4gIGVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9sZGkgPSBDLmZvbGRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5sZXQgaXRlcmkgPSBDLml0ZXJpXG5sZXQgdHJhbnNmZXIgfnNyYyB+ZHN0ID0gTGlua2VkX3F1ZXVlMC50cmFuc2ZlciBzcmMgZHN0XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBlbnF1ZXVlIHJlcyAoZiBhKSk7XG4gIHJlc1xuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBlbnF1ZXVlIHJlcyAoZiBpIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlciBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXJpIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGxpc3QgPSBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBBcnJheS5pdGVyIGFycmF5IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBpbml0IGxlbiB+ZiA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgZW5xdWV1ZSB0IChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggbGVuZ3RoIHQgd2l0aFxuICB8IDAgLT4gW3x8XVxuICB8IGxlbiAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbiAocGVla19leG4gdCkgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlciB0IH5mOihmdW4gdiAtPlxuICAgICAgYXJyLighaSkgPC0gdjtcbiAgICAgIGluY3IgaSk7XG4gICAgYXJyXG47O1xuXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAobGlzdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgc2luZ2xldG9uIGEgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgYTtcbiAgdFxuOztcbiIsIigqIEEgZmV3IHNtYWxsIHRoaW5ncyBjb3BpZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBCYXNlIGJlY2F1c2UgdGhleSBkZXBlbmQgb24gdXMsIHNvIHdlXG4gICBjYW4ndCB1c2UgdGhlbS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIEl0cyBpbXBvcnRhbnQgdGhhdCBFbXB0eSBoYXZlIG5vIGFyZ3MuIEl0J3MgdGVtcHRpbmcgdG8gbWFrZSB0aGlzIHR5cGUgYSByZWNvcmRcbiAgIChlLmcuIHRvIGhvbGQgdGhlIGNvbXBhcmUgZnVuY3Rpb24pLCBidXQgYSBsb3Qgb2YgbWVtb3J5IGlzIHNhdmVkIGJ5IEVtcHR5IGJlaW5nIGFuXG4gICBpbW1lZGlhdGUsIHNpbmNlIGFsbCB1bnVzZWQgYnVja2V0cyBpbiB0aGUgaGFzaHRibCBkb24ndCB1c2UgYW55IG1lbW9yeSAoYmVzaWRlcyB0aGVcbiAgIGFycmF5IGNlbGwpICopXG50eXBlICgnaywgJ3YpIHQgPVxuICB8IEVtcHR5XG4gIHwgTm9kZSBvZlxuICAgICAgeyBtdXRhYmxlIGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICA7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgOyBtdXRhYmxlIGhlaWdodCA6IGludFxuICAgICAgOyBtdXRhYmxlIHJpZ2h0IDogKCdrLCAndikgdFxuICAgICAgfVxuICB8IExlYWYgb2ZcbiAgICAgIHsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICB9XG5cbmxldCBlbXB0eSA9IEVtcHR5XG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gdHJ1ZVxuICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuOztcblxubGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IExlYWYgXyAtPiAxXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodDsgcmlnaHQgPSBfIH0gLT4gaGVpZ2h0XG47O1xuXG5sZXQgaW52YXJpYW50IGNvbXBhcmUgPVxuICBsZXQgbGVnYWxfbGVmdF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgbGVmdF9rZXkga2V5IDwgMClcbiAgaW5cbiAgbGV0IGxlZ2FsX3JpZ2h0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIHJpZ2h0X2tleSBrZXkgPiAwKVxuICBpblxuICBsZXQgcmVjIGludiA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSB8IExlYWYgXyAtPiAoKVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGs7IHZhbHVlID0gXzsgaGVpZ2h0ID0gaDsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGhsLCBociA9IGhlaWdodCBsZWZ0LCBoZWlnaHQgcmlnaHQgaW5cbiAgICAgIGludiBsZWZ0O1xuICAgICAgaW52IHJpZ2h0O1xuICAgICAgbGVnYWxfbGVmdF9rZXkgayBsZWZ0O1xuICAgICAgbGVnYWxfcmlnaHRfa2V5IGsgcmlnaHQ7XG4gICAgICBhc3NlcnQgKGggPSBJbnQubWF4IGhsIGhyICsgMSk7XG4gICAgICBhc3NlcnQgKGFicyAoaGwgLSBocikgPD0gMilcbiAgaW5cbiAgaW52XG47O1xuXG5sZXQgaW52YXJpYW50IHQgfmNvbXBhcmUgPSBpbnZhcmlhbnQgY29tcGFyZSB0XG5cbigqIEluIHRoZSBmb2xsb3dpbmcgY29tbWVudHMsXG4gICAndCBpcyBiYWxhbmNlZCcgbWVhbnMgdGhhdCAnaW52YXJpYW50IHQnIGRvZXMgbm90XG4gICByYWlzZSBhbiBleGNlcHRpb24uICBUaGlzIGltcGxpZXMgb2YgY291cnNlIHRoYXQgZWFjaCBub2RlJ3MgaGVpZ2h0IGZpZWxkIGlzXG4gICBjb3JyZWN0LlxuICAgJ3QgaXMgYmFsYW5jZWFibGUnIG1lYW5zIHRoYXQgaGVpZ2h0IG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBvZiB0XG4gICBkaWZmZXIgYnkgYXQgbW9zdCAzLiAqKVxuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBoYXZlIGNvcnJlY3QgaGVpZ2h0c1xuICAgQHBvc3Q6IG91dHB1dCBoYXMgdGhlIGNvcnJlY3QgaGVpZ2h0ICopXG5sZXQgdXBkYXRlX2hlaWdodCA9IGZ1bmN0aW9uXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IG9sZF9oZWlnaHQ7IHJpZ2h0IH0gYXMgeCkgLT5cbiAgICBsZXQgbmV3X2hlaWdodCA9IEludC5tYXggKGhlaWdodCBsZWZ0KSAoaGVpZ2h0IHJpZ2h0KSArIDEgaW5cbiAgICBpZiBuZXdfaGVpZ2h0IDw+IG9sZF9oZWlnaHQgdGhlbiB4LmhlaWdodCA8LSBuZXdfaGVpZ2h0XG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBhcmUgYmFsYW5jZWRcbiAgIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwb3N0OiBvdXRwdXQgaXMgYmFsYW5jZWQgKGluIHBhcnRpY3VsYXIsIGhlaWdodCBpcyBjb3JyZWN0KSAqKVxubGV0IGJhbGFuY2UgdHJlZSA9XG4gIG1hdGNoIHRyZWUgd2l0aFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IHRyZWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByb290X25vZGUpIC0+XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxlZnRcbiAgICBhbmQgaHIgPSBoZWlnaHQgcmlnaHQgaW5cbiAgICAoKiArIDIgaXMgY3JpdGljYWxseSBpbXBvcnRhbnQsIGxvd2VyaW5nIGl0IHRvIDEgd2lsbCBicmVhayB0aGUgTGVhZlxuICAgICAgIGFzc3VtcHRpb25zIGluIHRoZSBjb2RlIGJlbG93LCBhbmQgd2lsbCBmb3JjZSB1cyB0byBwcm9tb3RlIGxlYWYgbm9kZXMgaW5cbiAgICAgICB0aGUgYmFsYW5jZSByb3V0aW5lLiBJdCdzIGFsc28gZmFzdGVyLCBzaW5jZSBpdCB3aWxsIGJhbGFuY2UgbGVzcyBvZnRlbi5cbiAgICAgICBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBjb2RlIGlzIGRlbGljYXRlLiAgVGhlIHVwZGF0ZV9oZWlnaHQgY2FsbHMgbXVzdFxuICAgICAgIG9jY3VyIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzaW5jZSB1cGRhdGVfaGVpZ2h0IGFzc3VtZXMgaXRzIGNoaWxkcmVuIGhhdmVcbiAgICAgICB0aGUgY29ycmVjdCBoZWlnaHRzLiAgKilcbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbGVmdCB3aXRoXG4gICAgICAoKiBJdCBjYW5ub3QgYmUgYSBsZWFmLCBiZWNhdXNlIGV2ZW4gaWYgcmlnaHQgaXMgZW1wdHksIGEgbGVhZlxuICAgICAgICAgaXMgb25seSBoZWlnaHQgMSAqKVxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSBsZWZ0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyBsZWZ0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCBsZWZ0X25vZGVfbGVmdCA+PSBoZWlnaHQgbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgIGxlZnQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGlmIHJpZ2h0IGlzIGEgbGVhZiwgdGhlbiBsZWZ0IG11c3QgYmUgZW1wdHkuIFRoYXQgbWVhbnNcbiAgICAgICAgICAgICBoZWlnaHQgaXMgMi4gRXZlbiBpZiBociBpcyBlbXB0eSB3ZSBzdGlsbCBjYW4ndCBnZXQgaGVyZS4gKilcbiAgICAgICAgICBtYXRjaCBsZWZ0X25vZGVfcmlnaHQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBscl9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gbHJfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgbHJfbm9kZSkgLT5cbiAgICAgICAgICAgIGxlZnRfbm9kZS5yaWdodCA8LSBscl9sZWZ0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLmxlZnQgPC0gbHJfcmlnaHQ7XG4gICAgICAgICAgICBscl9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgICBscl9ub2RlLmxlZnQgPC0gbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdF9ub2RlX3JpZ2h0O1xuICAgICAgICAgICAgbGVmdF9ub2RlX3JpZ2h0KSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSByaWdodCBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICBtYXRjaCByaWdodCB3aXRoXG4gICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBOb2RlXG4gICAgICAgICAgKHsgbGVmdCA9IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSByaWdodF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgcmlnaHRfbm9kZSkgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJpZ2h0X25vZGVfcmlnaHQgPj0gaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBzZWUgYWJvdmUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgICAgICBtYXRjaCByaWdodF9ub2RlX2xlZnQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBybF9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gcmxfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICAgcmxfbm9kZSkgLT5cbiAgICAgICAgICAgIHJpZ2h0X25vZGUubGVmdCA8LSBybF9yaWdodDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSBybF9sZWZ0O1xuICAgICAgICAgICAgcmxfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgICBybF9ub2RlLnJpZ2h0IDwtIHJpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHRfbm9kZV9sZWZ0O1xuICAgICAgICAgICAgcmlnaHRfbm9kZV9sZWZ0KSlcbiAgICBlbHNlIChcbiAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgIHRyZWUpXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAocmlnaHQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5sZXQgc2V0X2xlZnQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCBsZWZ0IHRyZWUgdGhlbiAoKSBlbHNlIHIubGVmdCA8LSB0cmVlO1xuICAgIHVwZGF0ZV9oZWlnaHQgbm9kZVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAobGVmdCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9yaWdodCBub2RlIHRyZWUgPVxuICBsZXQgdHJlZSA9IGJhbGFuY2UgdHJlZSBpblxuICBtYXRjaCBub2RlIHdpdGhcbiAgfCBOb2RlICh7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcikgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHJpZ2h0IHRyZWUgdGhlbiAoKSBlbHNlIHIucmlnaHQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdCBpcyBiYWxhbmNlZC5cbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWQsIHdpdGggbmV3IG5vZGUgaW5zZXJ0ZWRcbiAgIEBwb3N0OiAhYWRkZWQgPSB0cnVlIGlmZiB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IHRyZWUgY2hhbmdlZC4gICopXG5sZXQgYWRkID1cbiAgbGV0IHJlYyBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBMZWFmICh7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsnIGsgaW5cbiAgICAgICgqIFRoaXMgY29tcGFyZSBpcyByZXZlcnNlZCBvbiBwdXJwb3NlLCB3ZSBhcmUgcHJldGVuZGluZ1xuICAgICAgICAgdGhhdCB0aGUgbGVhZiB3YXMganVzdCBpbnNlcnRlZCBpbnN0ZWFkIG9mIHRoZSBvdGhlciB3YXlcbiAgICAgICAgIHJvdW5kLCB0aGF0IHdheSB3ZSBvbmx5IGFsbG9jYXRlIG9uZSBub2RlLiAqKVxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdjtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZGRlZCA6PSB0cnVlO1xuICAgICAgICBpZiBjIDwgMFxuICAgICAgICB0aGVuIE5vZGUgeyBsZWZ0ID0gdDsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IEVtcHR5IH1cbiAgICAgICAgZWxzZSBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gdCB9KVxuICAgIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRlZCA6PSBmYWxzZTtcbiAgICAgICAgaWYgcmVwbGFjZSB0aGVuIHIudmFsdWUgPC0gdilcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gc2V0X2xlZnQgdCAoYWRkIGxlZnQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdilcbiAgICAgIGVsc2Ugc2V0X3JpZ2h0IHQgKGFkZCByaWdodCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2KTtcbiAgICAgIHRcbiAgaW5cbiAgZnVuIHQgfnJlcGxhY2UgfmNvbXBhcmUgfmFkZGVkIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQgdCA9IGFkZCB0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrZXkgZGF0YSBpblxuICAgIGlmICFhZGRlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHRcbjs7XG5cbmxldCByZWMgZmlyc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IGZpcnN0IGxcbjs7XG5cbmxldCByZWMgbGFzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT4gU29tZSAoaywgdilcbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSByIH0gLT4gbGFzdCByXG47O1xuXG5cbmxldFtAaW5saW5lIGFsd2F5c10gcmVjIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMlxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9ub3RfZm91bmRcbiAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlIGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgaWYgYyA9IDBcbiAgICB0aGVuIGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6aycgfmRhdGE6diBhcmcxIGFyZzJcbiAgICBlbHNlXG4gICAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgIChpZiBjIDwgMCB0aGVuIGxlZnQgZWxzZSByaWdodClcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAga1xuICAgICAgICBhcmcxXG4gICAgICAgIGFyZzJcbiAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgIH5pZl9mb3VuZFxuICAgICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCBkYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgKCkgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSAoKSAoKSA9IGlmX25vdF9mb3VuZCBrZXkgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICAoKVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCBkYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCBkYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyID0gaWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICBiXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kID1cbiAgbGV0IGlmX2ZvdW5kIHYgPSBTb21lIHYgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gTm9uZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtID1cbiAgbGV0IGlmX2ZvdW5kIF8gPSB0cnVlIGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IGZhbHNlIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCByZW1vdmUgPVxuICBsZXQgcmVjIG1pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiBfIC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gbWluX2VsdCBsZWZ0XG4gIGluXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IExlYWYgXyAtPiBFbXB0eSAoKiBUaGlzIG11c3QgYmUgdGhlIHJvb3QgKilcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPiByaWdodFxuICAgIHwgTm9kZSB7IGxlZnQgPSBMZWFmIF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+XG4gICAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIG5vZGUgLT5cbiAgICAgIHNldF9sZWZ0IG5vZGUgRW1wdHk7XG4gICAgICB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIChyZW1vdmVfbWluX2VsdCBsZWZ0KTtcbiAgICAgIHRyZWVcbiAgaW5cbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHRyZWUgPSBtaW5fZWx0IHQyIGluXG4gICAgICAobWF0Y2ggdHJlZSB3aXRoXG4gICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgICAgICAgbGV0IHQyID0gYmFsYW5jZSAocmVtb3ZlX21pbl9lbHQgdDIpIGluXG4gICAgICAgICBOb2RlXG4gICAgICAgICAgIHsgbGVmdCA9IHQxXG4gICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgICA7IHZhbHVlID0gdlxuICAgICAgICAgICA7IGhlaWdodCA9IEludC5tYXggKGhlaWdodCB0MSkgKGhlaWdodCB0MikgKyAxXG4gICAgICAgICAgIDsgcmlnaHQgPSB0MlxuICAgICAgICAgICB9XG4gICAgICAgfCBOb2RlIF8gYXMgbm9kZSAtPlxuICAgICAgICAgc2V0X3JpZ2h0IG5vZGUgKHJlbW92ZV9taW5fZWx0IHQyKTtcbiAgICAgICAgIHNldF9sZWZ0IG5vZGUgdDE7XG4gICAgICAgICBub2RlKVxuICBpblxuICBsZXQgcmVjIHJlbW92ZSB0IHJlbW92ZWQgY29tcGFyZSBrID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrJyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVkIDo9IHRydWU7XG4gICAgICAgIEVtcHR5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICAgIHQpXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBtZXJnZSBsZWZ0IHJpZ2h0KVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHNldF9sZWZ0IHQgKHJlbW92ZSBsZWZ0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgICAgIGVsc2UgKFxuICAgICAgICBzZXRfcmlnaHQgdCAocmVtb3ZlIHJpZ2h0IHJlbW92ZWQgY29tcGFyZSBrKTtcbiAgICAgICAgdClcbiAgaW5cbiAgZnVuIHQgfnJlbW92ZWQgfmNvbXBhcmUgayAtPiBiYWxhbmNlIChyZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgaylcbjs7XG5cbmxldCByZWMgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gaW5pdFxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YSBpbml0XG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gRW1wdHlcbiAgICAgIH0gLT4gZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IEVtcHR5XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH1cbiAgICAgIH0gLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSBpbml0KVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfSB9XG4gICAgLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfVxuICAgIC0+IGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdCkpIH5mXG4gIHwgTm9kZSB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgZm9sZCByaWdodCB+aW5pdDooZiB+a2V5IH5kYXRhIChmb2xkIGxlZnQgfmluaXQgfmYpKSB+ZlxuOztcblxubGV0IHJlYyBpdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGl0ZXIgbGVmdCB+ZjtcbiAgICBmIH5rZXkgfmRhdGE7XG4gICAgaXRlciByaWdodCB+ZlxuOztcblxubGV0IHJlYyBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+ICgpXG4gIHwgTGVhZiAoeyBrZXk7IHZhbHVlIH0gYXMgdCkgLT4gdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleTsgdmFsdWU7IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgdCkgLT5cbiAgICBtYXBpX2lucGxhY2UgfmYgbGVmdDtcbiAgICB0LnZhbHVlIDwtIGYgfmtleSB+ZGF0YTp2YWx1ZTtcbiAgICBtYXBpX2lucGxhY2UgfmYgcmlnaHRcbjs7XG5cbmxldCBjaG9vc2VfZXhuID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbQXZsdHJlZS5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pXG4gIHwgTGVhZiB7IGtleTsgdmFsdWU7IF8gfSB8IE5vZGUgeyBrZXk7IHZhbHVlOyBfIH0gLT4ga2V5LCB2YWx1ZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCdWZmZXJfaW50ZlxuaW5jbHVkZSBDYW1sLkJ1ZmZlclxuXG5sZXQgY29udGVudHNfYnl0ZXMgPSB0b19ieXRlc1xubGV0IGFkZF9zdWJzdHJpbmcgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJzdHJpbmcgdCBzIHBvcyBsZW5cbmxldCBhZGRfc3ViYnl0ZXMgdCBzIH5wb3MgfmxlbiA9IGFkZF9zdWJieXRlcyB0IHMgcG9zIGxlblxubGV0IHNleHBfb2ZfdCB0ID0gc2V4cF9vZl9zdHJpbmcgKGNvbnRlbnRzIHQpXG5cbm1vZHVsZSBUb19ieXRlcyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQnl0ZXMudFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBCeXRlcy5jcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoXG5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgICAgIENhbWwuQnVmZmVyLmJsaXQgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG4gICAgICA7O1xuICAgIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKENhbWwuQnVmZmVyKSAoVG9fYnl0ZXMpXG4iXX0=
