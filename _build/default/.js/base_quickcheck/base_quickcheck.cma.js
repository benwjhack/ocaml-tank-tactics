// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_get_1=runtime.caml_ba_get_1,
     caml_ba_get_2=runtime.caml_ba_get_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_layout=runtime.caml_ba_layout,
     caml_check_bound=runtime.caml_check_bound,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_div=runtime.caml_int64_div,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_shift_right=runtime.caml_int64_shift_right,
     caml_int64_shift_right_unsigne=runtime.caml_int64_shift_right_unsigned,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int64_xor=runtime.caml_int64_xor,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_mul=runtime.caml_mul,
     caml_notequal=runtime.caml_notequal,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_update_dummy=runtime.caml_update_dummy;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Base_quickcheck_Observer_o=
      caml_string_of_jsbytes("Base_quickcheck.Observer.observe: size < 0"),
     cst_Float_uniform_exclusive_bo=
      caml_string_of_jsbytes("Float.uniform_exclusive: bounds are not finite"),
     cst_Float_uniform_exclusive_re=
      caml_string_of_jsbytes
       ("Float.uniform_exclusive: requested range is empty"),
     cst_Base_quickcheck_Generator_$5=
      caml_string_of_jsbytes
       ("Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty"),
     cst_Base_quickcheck_Generator_$2=
      caml_string_of_jsbytes
       ("Base_quickcheck.Generator.of_weighted_list: weight is not finite"),
     cst_Base_quickcheck_Generator_$3=
      caml_string_of_jsbytes
       ("Base_quickcheck.Generator.of_weighted_list: weight is negative"),
     cst_Base_quickcheck_Generator_$1=
      caml_string_of_jsbytes
       ("Base_quickcheck.Generator.of_weighted_list: empty list"),
     cst_Base_quickcheck_Generator_$4=
      caml_string_of_jsbytes
       ("Base_quickcheck.Generator.of_weighted_list: total weight is zero"),
     cst_Base_quickcheck_Generator_$0=
      caml_string_of_jsbytes("Base_quickcheck.Generator.of_list: empty list"),
     cst_Base_quickcheck_Generator_=
      caml_string_of_jsbytes("Base_quickcheck.Generator.generate: size < 0"),
     cst_dim2=caml_string_of_jsbytes("dim2"),
     cst_dim1=caml_string_of_jsbytes("dim1"),
     cst_Base_quickcheck_Test_run_t=
      caml_string_of_jsbytes("Base_quickcheck.Test.run: test failed"),
     cst_Base_quickcheck_Test_run_i=
      caml_string_of_jsbytes
       ("Base_quickcheck.Test.run: insufficient size values for test count"),
     cst=caml_string_of_jsbytes("..."),
     names=
      [0,
       caml_string_of_jsbytes("seed"),
       [0,
        caml_string_of_jsbytes("test_count"),
        [0,
         caml_string_of_jsbytes("shrink_count"),
         [0,caml_string_of_jsbytes("sizes"),0]]]],
     cst_sizes=caml_string_of_jsbytes("sizes"),
     cst_shrink_count=caml_string_of_jsbytes("shrink_count"),
     cst_test_count=caml_string_of_jsbytes("test_count"),
     cst_seed=caml_string_of_jsbytes("seed"),
     Base=global_data.Base,
     Base_Array=global_data.Base__Array,
     Stdlib_Bigarray=global_data.Stdlib__Bigarray,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Base_Map=global_data.Base__Map,
     Base_Sequence=global_data.Base__Sequence,
     Base_Set=global_data.Base__Set,
     Base_List=global_data.Base__List,
     Base_String=global_data.Base__String,
     Base_Float=global_data.Base__Float,
     Splittable_random=global_data.Splittable_random,
     Base_Int63=global_data.Base__Int63,
     Base_Char=global_data.Base__Char,
     Base_Lazy=global_data.Base__Lazy,
     Base_Int=global_data.Base__Int,
     Base_Either=global_data.Base__Either,
     Base_Option=global_data.Base__Option,
     Assert_failure=global_data.Assert_failure,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Base_Error=global_data.Base__Error,
     Base_Hash=global_data.Base__Hash,
     Base_Staged=global_data.Base__Staged,
     Base_Applicative=global_data.Base__Applicative,
     Base_Monad=global_data.Base__Monad,
     Base_Int32=global_data.Base__Int32,
     Base_Int64=global_data.Base__Int64,
     Base_Nativeint=global_data.Base__Nativeint,
     Base_Bytes=global_data.Base__Bytes,
     Base_Field=global_data.Base__Field,
     Base_Backtrace=global_data.Base__Backtrace,
     Base_Or_error=global_data.Base__Or_error,
     Base_Random=global_data.Base__Random,
     Base_Bool=global_data.Base__Bool,
     Base_quickcheck=[0];
    caml_register_global(80,Base_quickcheck,"Base_quickcheck__");
    var Base_quickcheck_With_basic_typ=[0];
    caml_register_global
     (81,Base_quickcheck_With_basic_typ,"Base_quickcheck__With_basic_types");
    var
     _c_=[0,caml_string_of_jsbytes("size")],
     _aN_=[0,0,0],
     _aI_=[0,caml_string_of_jsbytes("upper_bound")],
     _aJ_=[0,caml_string_of_jsbytes("lower_bound")],
     _aK_=[0,caml_string_of_jsbytes("upper_bound")],
     _aL_=[0,caml_string_of_jsbytes("lower_bound")],
     _p_=[0,0],
     _o_=[0,1],
     _n_=[0,caml_string_of_jsbytes("src/generator.ml"),198,4],
     _m_=[0,caml_string_of_jsbytes("src/generator.ml"),225,6],
     _l_=[0,caml_string_of_jsbytes("src/generator.ml"),160,14],
     _j_=[0,caml_string_of_jsbytes("weight")],
     _k_=[0,caml_string_of_jsbytes("weight")],
     _d_=[0,caml_string_of_jsbytes("size")],
     _be_=[0,0],
     _bf_=[0,caml_string_of_jsbytes("error")],
     _bg_=[0,caml_string_of_jsbytes("input")],
     _bc_=[0,0],
     _bd_=[0,0],
     _ba_=[0,caml_string_of_jsbytes("number_of_size_values")],
     _bb_=[0,caml_string_of_jsbytes("test_count")],
     _a4_=[0,caml_string_of_jsbytes("sizes")],
     _a5_=[0,caml_string_of_jsbytes("shrink_count")],
     _a6_=[0,caml_string_of_jsbytes("test_count")],
     _a7_=[0,caml_string_of_jsbytes("seed")],
     _aU_=[0,caml_string_of_jsbytes("Deterministic")],
     _aV_=[0,caml_string_of_jsbytes("Nondeterministic")],
     _a8_=[0,104758188],
     _a9_=[0,104758188],
     _a$_=[0,caml_string_of_jsbytes("an arbitrary but deterministic string")],
     _bh_=[0,0];
    function offset(param){return param?1:0}
    var Layout=[0,offset];
    function iteri(t,f)
     {var
       _g0_=caml_ba_layout(t),
       offset=caml_call1(Layout[1],_g0_),
       _g2_=caml_ba_dim_1(t) - 1 | 0,
       _g1_=0;
      if(_g2_ >= 0)
       {var i=_g1_;
        for(;;)
         {caml_call2(f,i + offset | 0,caml_ba_get_1(t,i + offset | 0));
          var _g3_=i + 1 | 0;
          if(_g2_ !== i){var i=_g3_;continue}
          break}}
      return 0}
    function init(kind,layout,dim,f)
     {var t=caml_call3(Stdlib_Bigarray[19][1],kind,layout,dim);
      iteri
       (t,
        function(i,param){return runtime.caml_ba_set_1(t,i,caml_call1(f,i))});
      return t}
    function fold(t,init,f)
     {var init$0=[0,init];
      iteri
       (t,
        function(i,param)
         {var _gZ_=caml_ba_get_1(t,i);
          init$0[1] = caml_call2(f,init$0[1],_gZ_);
          return 0});
      return init$0[1]}
    function to_array(t)
     {var _gW_=caml_ba_layout(t),offset=caml_call1(Layout[1],_gW_);
      function _gX_(i){return caml_ba_get_1(t,i + offset | 0)}
      var _gY_=caml_ba_dim_1(t);
      return caml_call2(Base_Array[27],_gY_,_gX_)}
    function sexp_of_t(sexp_of_elt,sexp_of_pack,sexp_of_layout,t)
     {var x_001=to_array(t);return caml_call2(Base[90],sexp_of_elt,x_001)}
    function hash_fold(hash_fold_elt,state,t)
     {var _gV_=caml_ba_dim_1(t),state$0=caml_call2(Base[116],state,_gV_);
      return fold(t,state$0,hash_fold_elt)}
    function iteri$0(t,f)
     {var
       _gO_=caml_ba_layout(t),
       offset=caml_call1(Layout[1],_gO_),
       _gQ_=caml_ba_dim_1(t) - 1 | 0,
       _gP_=0;
      if(_gQ_ >= 0)
       {var i=_gP_;
        for(;;)
         {var _gS_=caml_ba_dim_2(t) - 1 | 0,_gR_=0;
          if(_gS_ >= 0)
           {var j=_gR_;
            for(;;)
             {caml_call3
               (f,
                i + offset | 0,
                j + offset | 0,
                caml_ba_get_2(t,i + offset | 0,j + offset | 0));
              var _gU_=j + 1 | 0;
              if(_gS_ !== j){var j=_gU_;continue}
              break}}
          var _gT_=i + 1 | 0;
          if(_gQ_ !== i){var i=_gT_;continue}
          break}}
      return 0}
    function init$0(kind,layout,dim1,dim2,f)
     {var t=caml_call4(Stdlib_Bigarray[20][1],kind,layout,dim1,dim2);
      iteri$0
       (t,
        function(i,j,param)
         {return runtime.caml_ba_set_2(t,i,j,caml_call2(f,i,j))});
      return t}
    function fold$0(t,init,f)
     {var init$0=[0,init];
      iteri$0
       (t,
        function(param,_gN_,elt)
         {init$0[1] = caml_call2(f,init$0[1],elt);return 0});
      return init$0[1]}
    function to_array$0(t)
     {var _gI_=caml_ba_layout(t),offset=caml_call1(Layout[1],_gI_);
      function _gJ_(i)
       {function _gL_(j)
         {return caml_ba_get_2(t,i + offset | 0,j + offset | 0)}
        var _gM_=caml_ba_dim_2(t);
        return caml_call2(Base_Array[27],_gM_,_gL_)}
      var _gK_=caml_ba_dim_1(t);
      return caml_call2(Base_Array[27],_gK_,_gJ_)}
    function sexp_of_t$0(sexp_of_elt,sexp_of_pack,sexp_of_layout,t)
     {var x_002=to_array$0(t),_gH_=caml_call1(Base[90],sexp_of_elt);
      return caml_call2(Base[90],_gH_,x_002)}
    function hash_fold$0(hash_fold_elt,state,t)
     {var
       _gF_=caml_ba_dim_1(t),
       state$0=caml_call2(Base[116],state,_gF_),
       _gG_=caml_ba_dim_2(t),
       state$1=caml_call2(Base[116],state$0,_gG_);
      return fold$0(t,state$1,hash_fold_elt)}
    var
     _a_=[0,sexp_of_t$0,init$0,iteri$0,fold$0,to_array$0,hash_fold$0],
     _b_=[0,sexp_of_t,init,iteri,fold,to_array,hash_fold],
     Base_quickcheck_Bigarray_helpe=[0,Layout,_b_,_a_];
    caml_register_global
     (85,Base_quickcheck_Bigarray_helpe,"Base_quickcheck__Bigarray_helpers");
    function create(f){return f}
    function observe(t,x,size,hash)
     {if(0 <= size)return caml_call3(t,x,size,hash);
      var
       _gD_=[0,[1,[0,_c_,[0,caml_call1(Base[119],size),0]]],0],
       _gE_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Observer_o),
          _gD_]];
      return caml_call1(Base[202],_gE_)}
    function quickcheck_observer_unit(param,_gC_,hash){return hash}
    var include=[0,quickcheck_observer_unit,create,observe];
    caml_register_global(87,include,"Base_quickcheck__Observer0");
    function create$0(f){return caml_call1(Base_Staged[1],f)}
    function generate(t,size,random)
     {if(0 <= size)return caml_call3(Base_Staged[2],t,size,random);
      var
       _gA_=[0,[1,[0,_d_,[0,caml_call1(Base[119],size),0]]],0],
       _gB_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_),
          _gA_]];
      return caml_call1(Base[202],_gB_)}
    var size=create$0(function(size,param){return size});
    function fn(dom,rng)
     {return create$0
              (function(size,random)
                {var random$0=caml_call1(Splittable_random[1][5],random);
                 return function(x)
                  {var
                    hash=observe(dom,x,size,caml_call1(Base_Hash[7],0)),
                    random=caml_call1(Splittable_random[1][4],random$0),
                    _gz_=caml_call1(Base_Hash[9],hash);
                   caml_call2(Splittable_random[1][3],random,_gz_);
                   return generate(rng,size,random)}})}
    function with_size(t,size)
     {return create$0(function(param,random){return generate(t,size,random)})}
    function perturb(t,salt)
     {return create$0
              (function(size,random)
                {caml_call2(Splittable_random[1][3],random,salt);
                 return generate(t,size,random)})}
    function filter_map(t,f)
     {function loop(size,random)
       {var size$0=size;
        for(;;)
         {var x=generate(t,size$0,random),match=caml_call1(f,x);
          if(match){var y=match[1];return y}
          var size$1=size$0 + 1 | 0,size$0=size$1}}
      return create$0(loop)}
    function filter(t,f)
     {return filter_map(t,function(x){return caml_call1(f,x)?[0,x]:0})}
    function return$0(x){return create$0(function(param,_gy_){return x})}
    function map(t,f)
     {return create$0
              (function(size,random)
                {return caml_call1(f,generate(t,size,random))})}
    function apply(tf,tx)
     {return create$0
              (function(size,random)
                {var f=generate(tf,size,random),x=generate(tx,size,random);
                 return caml_call1(f,x)})}
    function bind(t,f)
     {return create$0
              (function(size,random)
                {var x=generate(t,size,random);
                 return generate(caml_call1(f,x),size,random)})}
    function all(list)
     {return create$0
              (function(size,random)
                {function _gw_(_gx_){return generate(_gx_,size,random)}
                 return caml_call2(Base_List[76],list,_gw_)})}
    function all_unit(list)
     {return create$0
              (function(size,random)
                {function _gu_(_gv_){return generate(_gv_,size,random)}
                 return caml_call2(Base_List[9],list,_gu_)})}
    var
     map$0=[0,-198771759,map],
     For_applicative=caml_call1(Base_Applicative[5],[0,return$0,apply,map$0]),
     both=For_applicative[3],
     map2=For_applicative[9],
     map3=For_applicative[10],
     include$0=For_applicative[13],
     symbol=include$0[1],
     symbol$0=include$0[2],
     symbol$1=include$0[3],
     map$1=[0,-198771759,map],
     For_monad=caml_call1(Base_Monad[1],[0,bind,return$0,map$1]),
     _f_=For_monad[7],
     _g_=For_monad[3],
     _e_=For_monad[8],
     _h_=_g_[1],
     _i_=_g_[2];
    function of_list(list)
     {if(caml_call1(Base_List[8],list))
       {var
         _gt_=
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$0);
        caml_call1(Base_Error[30],_gt_)}
      var
       array=caml_call1(Base_Array[39],list),
       hi=array.length - 1 - 1 | 0,
       lo=0;
      return create$0
              (function(param,random)
                {var index=caml_call3(Splittable_random[3],random,lo,hi);
                 return caml_check_bound(array,index)[1 + index]})}
    function union(list){return caml_call1(_f_,of_list(list))}
    function of_weighted_list(alist)
     {if(caml_call1(Base_List[8],alist))
       {var
         _gl_=
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$1);
        caml_call1(Base_Error[30],_gl_)}
      var
       match=caml_call1(Base_List[92],alist),
       values=match[2],
       weights=match[1],
       value_array=caml_call1(Base_Array[39],values);
      function _gm_(param){return 0.}
      var array=caml_call2(Base_Array[27],value_array.length - 1,_gm_);
      function _gn_(index,acc,weight)
       {if(1 - caml_call1(Base_Float[84],weight))
         {var
           _gp_=[0,[1,[0,_j_,[0,caml_call1(Base[112],weight),0]]],0],
           _gq_=
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$2),
              _gp_]];
          caml_call1(Base_Error[30],_gq_)}
        if(caml_call2(Base_Float[13],weight,0.))
         {var
           _gr_=[0,[1,[0,_k_,[0,caml_call1(Base[112],weight),0]]],0],
           _gs_=
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$3),
              _gr_]];
          caml_call1(Base_Error[30],_gs_)}
        var cumulative=caml_call2(Base[190],acc,weight);
        runtime.caml_array_set(array,index,cumulative);
        return cumulative}
      var sum=caml_call3(Base_List[99],weights,0.,_gn_);
      if(caml_call2(Base_Float[10],sum,0.))
       {var
         _go_=
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$4);
        caml_call1(Base_Error[30],_go_)}
      return create$0
              (function(param,random)
                {var
                  choice=caml_call3(Splittable_random[8],random,0.,sum),
                  match=
                   caml_call6
                    (Base_Array[5],0,0,array,Base_Float[16],926943384,choice);
                 if(! match)throw [0,Assert_failure,_l_];
                 var index=match[1];
                 return caml_check_bound(value_array,index)[1 + index]})}
    function weighted_union(alist)
     {return caml_call1(_f_,of_weighted_list(alist))}
    function of_lazy(lazy_t)
     {return create$0
              (function(size,random)
                {var
                  _gj_=caml_obj_tag(lazy_t),
                  _gk_=
                   250 === _gj_
                    ?lazy_t[1]
                    :246 === _gj_?caml_call1(CamlinternalLazy[2],lazy_t):lazy_t;
                 return generate(_gk_,size,random)})}
    function fixed_point(of_generator)
     {var lazy_t=[];
      caml_update_dummy
       (lazy_t,
        [246,function(_gi_){return caml_call1(of_generator,of_lazy(lazy_t))}]);
      var _gh_=caml_obj_tag(lazy_t);
      return 250 === _gh_
              ?lazy_t[1]
              :246 === _gh_?caml_call1(CamlinternalLazy[2],lazy_t):lazy_t}
    function weighted_recursive_union(nonrec_list,f)
     {return fixed_point
              (function(self)
                {function _ga_(param)
                  {var t=param[2],w=param[1];
                   function _gg_(n){return with_size(t,n - 1 | 0)}
                   return [0,w,caml_call2(For_monad[11][4][2],size,_gg_)]}
                 var
                  _gb_=caml_call1(f,self),
                  rec_list=caml_call2(Base_List[76],_gb_,_ga_),
                  _gc_=caml_call1(Base_List[8],nonrec_list),
                  _gd_=_gc_ || caml_call1(Base_List[8],rec_list);
                 if(_gd_)
                  {var
                    _ge_=
                     caml_call1
                      (Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Generator_$5);
                   caml_call1(Base[202],_ge_)}
                 var
                  nonrec_gen=weighted_union(nonrec_list),
                  rec_gen=
                   weighted_union(caml_call2(Base[178],nonrec_list,rec_list));
                 function _gf_(param){return 0 === param?nonrec_gen:rec_gen}
                 return caml_call2(For_monad[11][4][2],size,_gf_)})}
    function recursive_union(nonrec_list,f)
     {function weighted(list)
       {function _f$_(t){return [0,1.,t]}
        return caml_call2(Base_List[76],list,_f$_)}
      function _f__(self){return weighted(caml_call1(f,self))}
      return weighted_recursive_union(weighted(nonrec_list),_f__)}
    function sizes(opt,_fW_,param)
     {if(opt)var sth=opt[1],min_length=sth;else var min_length=0;
      if(_fW_)
       var sth$0=_fW_[1],max_length=sth$0;
      else
       var max_length=Base_Int[60];
      return create$0
              (function(size,random)
                {if(min_length > max_length)throw [0,Assert_failure,_n_];
                 var
                  upper_bound=min_length + size | 0,
                  max_length$0=
                   min_length <= upper_bound
                    ?caml_call2(Base[189],max_length,upper_bound)
                    :max_length,
                  len=
                   caml_call3
                    (Splittable_random[10][1],random,min_length,max_length$0);
                 if(0 === len)return 0;
                 function _fX_(param){return 0}
                 var
                  sizes=caml_call2(Base_Array[27],len,_fX_),
                  remaining=size - (len - min_length | 0) | 0,
                  max_index=len - 1 | 0,
                  _fY_=1;
                 if(remaining >= 1)
                  {var for$0=_fY_;
                   for(;;)
                    {var
                      index=
                       caml_call3(Splittable_random[10][1],random,0,max_index),
                      _f5_=caml_check_bound(sizes,index)[1 + index] + 1 | 0;
                     caml_check_bound(sizes,index)[1 + index] = _f5_;
                     var _f6_=for$0 + 1 | 0;
                     if(remaining !== for$0){var for$0=_f6_;continue}
                     break}}
                 var _f0_=max_index - 1 | 0,_fZ_=0;
                 if(_f0_ >= 0)
                  {var i=_fZ_;
                   for(;;)
                    {var j=caml_call3(Splittable_random[3],random,i,max_index);
                     caml_call3(Base_Array[74],sizes,i,j);
                     var _f4_=i + 1 | 0;
                     if(_f0_ !== i){var i=_f4_;continue}
                     break}}
                 var _f1_=len - min_length | 0;
                 function _f2_(_f9_){return _f9_}
                 function _f3_(_f8_,_f7_){return _f8_ + _f7_ | 0}
                 if
                  ((caml_call3
                     (Base_Array[16],[0,Base_Int[74],_f3_],sizes,_f2_)
                    +
                    _f1_
                    |
                    0)
                   ===
                   size)
                  return caml_call1(Base_Array[19],sizes);
                 throw [0,Assert_failure,_m_]})}
    var
     quickcheck_generator_unit=caml_call1(For_monad[11][1],0),
     quickcheck_generator_bool=
      create$0
       (function(param,random){return caml_call1(Splittable_random[2],random)});
    function quickcheck_generator_option(value_t)
     {var _fV_=[0,map(value_t,Base_Option[20]),0];
      return union([0,caml_call1(For_monad[11][1],0),_fV_])}
    function either(fst_t,snd_t)
     {var _fU_=[0,map(snd_t,Base_Either[18]),0];
      return union([0,map(fst_t,Base_Either[17]),_fU_])}
    function result(ok_t,err_t)
     {function _fT_(param)
       {if(0 === param[0]){var ok=param[1];return [0,ok]}
        var err=param[1];
        return [1,err]}
      return map(either(ok_t,err_t),_fT_)}
    function list_generic(min_length,max_length,elt_gen)
     {function _fQ_(sizes)
       {function _fS_(size){return with_size(elt_gen,size)}
        return all(caml_call2(Base_List[76],sizes,_fS_))}
      var _fR_=sizes(min_length,max_length,0);
      return caml_call2(For_monad[11][4][2],_fR_,_fQ_)}
    function quickcheck_generator_list(elt_gen)
     {return list_generic(0,0,elt_gen)}
    function list_non_empty(elt_gen){return list_generic(_o_,0,elt_gen)}
    function list_with_length(elt_gen,length)
     {return list_generic([0,length],[0,length],elt_gen)}
    function list_filtered(elts)
     {var
       elts$0=caml_call1(Base_Array[39],elts),
       length_of_input=elts$0.length - 1;
      return create$0
              (function(param,random)
                {var
                  length_of_output=
                   caml_call3(Splittable_random[3],random,0,length_of_input);
                 function _fJ_(_fP_){return _fP_}
                 var
                  indices=caml_call2(Base_Array[27],length_of_input,_fJ_),
                  _fL_=length_of_output - 1 | 0,
                  _fK_=0;
                 if(_fL_ >= 0)
                  {var i=_fK_;
                   for(;;)
                    {var
                      j=
                       caml_call3
                        (Splittable_random[3],random,i,length_of_input - 1 | 0);
                     caml_call3(Base_Array[74],indices,i,j);
                     var _fN_=i + 1 | 0;
                     if(_fL_ !== i){var i=_fN_;continue}
                     break}}
                 caml_call4
                  (Base_Array[49],
                   _p_,
                   [0,length_of_output],
                   indices,
                   Base_Int[13]);
                 function _fM_(i)
                  {var _fO_=caml_check_bound(indices,i)[1 + i];
                   return caml_check_bound(elts$0,_fO_)[1 + _fO_]}
                 return caml_call2(Base_List[123],length_of_output,_fM_)})}
    function list_permutations(list)
     {return create$0
              (function(param,random)
                {var
                  array=caml_call1(Base_Array[39],list),
                  _fH_=array.length - 1 - 1 | 0,
                  _fG_=1;
                 if(_fH_ >= 1)
                  {var i=_fG_;
                   for(;;)
                    {var j=caml_call3(Splittable_random[3],random,0,i);
                     caml_call3(Base_Array[74],array,i,j);
                     var _fI_=i + 1 | 0;
                     if(_fH_ !== i){var i=_fI_;continue}
                     break}}
                 return caml_call1(Base_Array[19],array)})}
    function quickcheck_generator_array(t)
     {var _fF_=Base_Array[39];return map(quickcheck_generator_list(t),_fF_)}
    function quickcheck_generator_ref(t)
     {return map(t,function(_fE_){return [0,_fE_]})}
    function quickcheck_generator_lazy_t(t){return map(t,Base_Lazy[21])}
    function char_uniform_inclusive(lo,hi)
     {return create$0
              (function(param,random)
                {var
                  _fB_=caml_call1(Base_Char[29],hi),
                  _fC_=caml_call1(Base_Char[29],lo),
                  _fD_=caml_call3(Splittable_random[3],random,_fC_,_fB_);
                 return caml_call1(Base_Char[32],_fD_)})}
    var
     char_uppercase=char_uniform_inclusive(65,90),
     char_lowercase=char_uniform_inclusive(97,122),
     char_digit=char_uniform_inclusive(48,57),
     char_print_uniform=char_uniform_inclusive(32,126),
     char_uniform=char_uniform_inclusive(Base_Char[50],Base_Char[51]),
     char_alpha=union([0,char_lowercase,[0,char_uppercase,0]]),
     char_alphanum=
      weighted_union([0,[0,52.,char_alpha],[0,[0,10.,char_digit],0]]),
     char_whitespace=
      of_list(caml_call2(Base_List[54],Base_Char[1],Base_Char[42])),
     char_print=
      weighted_union
       ([0,[0,10.,char_alphanum],[0,[0,1.,char_print_uniform],0]]),
     _q_=[0,[0,1.,caml_call1(For_monad[11][1],Base_Char[51])],0],
     quickcheck_generator_char=
      weighted_union
       ([0,
         [0,100.,char_print],
         [0,
          [0,10.,char_uniform],
          [0,[0,1.,caml_call1(For_monad[11][1],Base_Char[50])],_q_]]]);
    function small_int(allow_zero)
     {return create$0
              (function(size,random)
                {var
                  lower_bound=allow_zero?0:1,
                  upper_bound=size + 1 | 0,
                  weighted_low=
                   caml_call3
                    (Splittable_random[10][1],
                     random,
                     0,
                     upper_bound - lower_bound | 0),
                  weighted_high=upper_bound - weighted_low | 0;
                 return weighted_high})}
    var
     small_positive_or_zero_int=small_int(1),
     small_strictly_positive_int=small_int(0);
    function For_integer(Integer)
     {function uniform_inclusive(lo,hi)
       {return create$0
                (function(param,random)
                  {return caml_call3(Integer[96],random,lo,hi)})}
      function log_uniform_inclusive(lo,hi)
       {return create$0
                (function(param,random)
                  {return caml_call3(Integer[97],random,lo,hi)})}
      function non_uniform(f,lo,hi)
       {var
         _fz_=[0,[0,0.9,caml_call2(f,lo,hi)],0],
         _fA_=[0,[0,0.05,caml_call1(For_monad[11][1],hi)],_fz_];
        return weighted_union
                ([0,[0,0.05,caml_call1(For_monad[11][1],lo)],_fA_])}
      function inclusive(_fx_,_fy_)
       {return non_uniform(uniform_inclusive,_fx_,_fy_)}
      function log_inclusive(_fv_,_fw_)
       {return non_uniform(log_uniform_inclusive,_fv_,_fw_)}
      var
       uniform_all=uniform_inclusive(Integer[85],Integer[84]),
       let_syntax_004=log_inclusive(Integer[38],Integer[84]);
      function _ft_(param)
       {var magnitude=param[2],negative=param[1];
        return negative?caml_call1(Integer[70],magnitude):magnitude}
      var
       _fu_=
        caml_call2
         (For_monad[11][4][4],quickcheck_generator_bool,let_syntax_004),
       all=caml_call2(For_monad[11][4][3],_fu_,_ft_);
      return [0,
              uniform_inclusive,
              log_uniform_inclusive,
              non_uniform,
              inclusive,
              log_inclusive,
              uniform_all,
              all]}
    var
     t_sexp_grammar=Base_Int[1],
     of_float=Base_Int[2],
     to_float=Base_Int[3],
     of_int_exn=Base_Int[4],
     to_int_exn=Base_Int[5],
     hash_fold_t=Base_Int[6],
     hash=Base_Int[7],
     t_of_sexp=Base_Int[8],
     sexp_of_t$1=Base_Int[9],
     of_string=Base_Int[10],
     to_string=Base_Int[11],
     equal=Base_Int[12],
     compare=Base_Int[13],
     min=Base_Int[14],
     max=Base_Int[15],
     ascending=Base_Int[16],
     descending=Base_Int[17],
     between=Base_Int[18],
     clamp_exn=Base_Int[19],
     clamp=Base_Int[20],
     comparator=Base_Int[21],
     pp=Base_Int[22],
     hashable=Base_Int[23],
     is_positive=Base_Int[24],
     is_non_negative=Base_Int[25],
     is_negative=Base_Int[26],
     is_non_positive=Base_Int[27],
     sign=Base_Int[28],
     invariant=Base_Int[29],
     Hex=Base_Int[30],
     to_string_hum=Base_Int[31],
     one=Base_Int[32],
     minus_one=Base_Int[33],
     rem=Base_Int[34],
     round=Base_Int[35],
     round_towards_zero=Base_Int[36],
     round_down=Base_Int[37],
     round_up=Base_Int[38],
     round_nearest=Base_Int[39],
     succ=Base_Int[40],
     pred=Base_Int[41],
     pow=Base_Int[42],
     bit_and=Base_Int[43],
     bit_or=Base_Int[44],
     bit_xor=Base_Int[45],
     bit_not=Base_Int[46],
     popcount=Base_Int[47],
     shift_left=Base_Int[48],
     shift_right=Base_Int[49],
     decr=Base_Int[50],
     incr=Base_Int[51],
     of_int32_exn=Base_Int[52],
     to_int32_exn=Base_Int[53],
     of_int64_exn=Base_Int[54],
     to_int64=Base_Int[55],
     of_nativeint_exn=Base_Int[56],
     to_nativeint_exn=Base_Int[57],
     of_float_unchecked=Base_Int[58],
     num_bits=Base_Int[59],
     max_value=Base_Int[60],
     min_value=Base_Int[61],
     shift_right_logical=Base_Int[62],
     ceil_pow2=Base_Int[63],
     floor_pow2=Base_Int[64],
     ceil_log2=Base_Int[65],
     floor_log2=Base_Int[66],
     is_pow2=Base_Int[67],
     clz=Base_Int[68],
     ctz=Base_Int[69],
     O=Base_Int[70],
     symbol$2=Base_Int[71],
     lnot=Base_Int[72],
     abs=Base_Int[73],
     zero=Base_Int[74],
     symbol$3=Base_Int[75],
     symbol$4=Base_Int[76],
     symbol$5=Base_Int[77],
     uniform=Splittable_random[3],
     log_uniform=Splittable_random[10][1];
    function _r_(_fs_,_fr_){return _fs_ >>> _fr_ | 0}
    function _s_(_fq_,_fp_){return _fq_ >> _fp_}
    function _t_(_fo_,_fn_){return _fo_ << _fn_}
    var _u_=O[2];
    function _v_(_fm_,_fl_){return _fm_ ^ _fl_}
    function _w_(_fk_,_fj_){return _fk_ | _fj_}
    function _x_(_fi_,_fh_){return _fi_ & _fh_}
    var _y_=O[7],_z_=O[6],_A_=O[5],_B_=O[4];
    function _C_(_fg_){return - _fg_ | 0}
    var _D_=O[3];
    function _E_(_ff_,_fe_){return _ff_ !== _fe_?1:0}
    function _F_(_fd_,_fc_){return _fd_ < _fc_?1:0}
    function _G_(_fb_,_fa_){return _fa_ < _fb_?1:0}
    function _H_(_e$_,_e__){return _e$_ === _e__?1:0}
    function _I_(_e9_,_e8_){return _e9_ <= _e8_?1:0}
    function _J_(_e7_,_e6_){return _e6_ <= _e7_?1:0}
    var _K_=O[1];
    function _L_(_e5_){return - _e5_ | 0}
    var _M_=caml_div,_N_=caml_mul;
    function _O_(_e4_,_e3_){return _e4_ - _e3_ | 0}
    var
     _P_=
      [0,
       function(_e2_,_e1_){return _e2_ + _e1_ | 0},
       _O_,
       _N_,
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_];
    function _Q_(_e0_,_eZ_){return _e0_ >>> _eZ_ | 0}
    function _R_(_eY_,_eX_){return _eY_ >> _eX_}
    function _S_(_eW_,_eV_){return _eW_ << _eV_}
    function _T_(_eU_,_eT_){return _eU_ ^ _eT_}
    function _U_(_eS_,_eR_){return _eS_ | _eR_}
    function _V_(_eQ_,_eP_){return _eQ_ & _eP_}
    var _W_=caml_div;
    function _X_(_eO_){return - _eO_ | 0}
    function _Y_(_eN_){return - _eN_ | 0}
    var _Z_=caml_mul;
    function ___(_eM_,_eL_){return _eM_ - _eL_ | 0}
    function _$_(_eK_,_eJ_){return _eK_ + _eJ_ | 0}
    function _aa_(_eI_,_eH_){return _eI_ !== _eH_?1:0}
    function _ab_(_eG_,_eF_){return _eG_ < _eF_?1:0}
    function _ac_(_eE_,_eD_){return _eD_ < _eE_?1:0}
    function _ad_(_eC_,_eB_){return _eC_ === _eB_?1:0}
    function _ae_(_eA_,_ez_){return _eA_ <= _ez_?1:0}
    var
     For_int=
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t$1,
         of_string,
         to_string,
         function(_ey_,_ex_){return _ex_ <= _ey_?1:0},
         _ae_,
         _ad_,
         _ac_,
         _ab_,
         _aa_,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         _$_,
         ___,
         _Z_,
         symbol$2,
         _Y_,
         _X_,
         symbol$4,
         symbol$3,
         _W_,
         rem,
         symbol$5,
         _V_,
         _U_,
         _T_,
         lnot,
         _S_,
         _R_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _Q_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _P_,
         uniform,
         log_uniform]),
     quickcheck_generator_int=For_int[7],
     int_uniform=For_int[6],
     int_inclusive=For_int[4],
     int_uniform_inclusive=For_int[1],
     int_log_inclusive=For_int[5],
     int_log_uniform_inclusive=For_int[2],
     t_sexp_grammar$0=Base_Int32[1],
     of_float$0=Base_Int32[2],
     to_float$0=Base_Int32[3],
     of_int_exn$0=Base_Int32[4],
     to_int_exn$0=Base_Int32[5],
     hash_fold_t$0=Base_Int32[6],
     hash$0=Base_Int32[7],
     t_of_sexp$0=Base_Int32[8],
     sexp_of_t$2=Base_Int32[9],
     of_string$0=Base_Int32[10],
     to_string$0=Base_Int32[11],
     symbol$6=Base_Int32[12],
     symbol$7=Base_Int32[13],
     symbol$8=Base_Int32[14],
     symbol$9=Base_Int32[15],
     symbol$10=Base_Int32[16],
     symbol$11=Base_Int32[17],
     equal$0=Base_Int32[18],
     compare$0=Base_Int32[19],
     min$0=Base_Int32[20],
     max$0=Base_Int32[21],
     ascending$0=Base_Int32[22],
     descending$0=Base_Int32[23],
     between$0=Base_Int32[24],
     clamp_exn$0=Base_Int32[25],
     clamp$0=Base_Int32[26],
     comparator$0=Base_Int32[27],
     pp$0=Base_Int32[28],
     hashable$0=Base_Int32[29],
     is_positive$0=Base_Int32[30],
     is_non_negative$0=Base_Int32[31],
     is_negative$0=Base_Int32[32],
     is_non_positive$0=Base_Int32[33],
     sign$0=Base_Int32[34],
     invariant$0=Base_Int32[35],
     Hex$0=Base_Int32[36],
     to_string_hum$0=Base_Int32[37],
     zero$0=Base_Int32[38],
     one$0=Base_Int32[39],
     minus_one$0=Base_Int32[40],
     symbol$12=Base_Int32[41],
     symbol$13=Base_Int32[42],
     symbol$14=Base_Int32[43],
     symbol$15=Base_Int32[44],
     neg=Base_Int32[45],
     symbol$16=Base_Int32[46],
     symbol$17=Base_Int32[47],
     symbol$18=Base_Int32[48],
     symbol$19=Base_Int32[49],
     rem$0=Base_Int32[50],
     symbol$20=Base_Int32[51],
     land=Base_Int32[52],
     lor=Base_Int32[53],
     lxor=Base_Int32[54],
     lnot$0=Base_Int32[55],
     lsl=Base_Int32[56],
     asr=Base_Int32[57],
     round$0=Base_Int32[58],
     round_towards_zero$0=Base_Int32[59],
     round_down$0=Base_Int32[60],
     round_up$0=Base_Int32[61],
     round_nearest$0=Base_Int32[62],
     abs$0=Base_Int32[63],
     succ$0=Base_Int32[64],
     pred$0=Base_Int32[65],
     pow$0=Base_Int32[66],
     bit_and$0=Base_Int32[67],
     bit_or$0=Base_Int32[68],
     bit_xor$0=Base_Int32[69],
     bit_not$0=Base_Int32[70],
     popcount$0=Base_Int32[71],
     shift_left$0=Base_Int32[72],
     shift_right$0=Base_Int32[73],
     decr$0=Base_Int32[74],
     incr$0=Base_Int32[75],
     of_int32_exn$0=Base_Int32[76],
     to_int32_exn$0=Base_Int32[77],
     of_int64_exn$0=Base_Int32[78],
     to_int64$0=Base_Int32[79],
     of_nativeint_exn$0=Base_Int32[80],
     to_nativeint_exn$0=Base_Int32[81],
     of_float_unchecked$0=Base_Int32[82],
     num_bits$0=Base_Int32[83],
     max_value$0=Base_Int32[84],
     min_value$0=Base_Int32[85],
     lsr=Base_Int32[86],
     shift_right_logical$0=Base_Int32[87],
     ceil_pow2$0=Base_Int32[88],
     floor_pow2$0=Base_Int32[89],
     ceil_log2$0=Base_Int32[90],
     floor_log2$0=Base_Int32[91],
     is_pow2$0=Base_Int32[92],
     clz$0=Base_Int32[93],
     ctz$0=Base_Int32[94],
     O$0=Base_Int32[95],
     uniform$0=Splittable_random[4],
     log_uniform$0=Splittable_random[10][2],
     For_int32=
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$2,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
     quickcheck_generator_int32=For_int32[7],
     int32_uniform=For_int32[6],
     int32_inclusive=For_int32[4],
     int32_uniform_inclusive=For_int32[1],
     int32_log_inclusive=For_int32[5],
     int32_log_uniform_inclusive=For_int32[2],
     t_sexp_grammar$1=Base_Int63[1],
     of_float$1=Base_Int63[2],
     to_float$1=Base_Int63[3],
     of_int_exn$1=Base_Int63[4],
     to_int_exn$1=Base_Int63[5],
     hash_fold_t$1=Base_Int63[6],
     hash$1=Base_Int63[7],
     t_of_sexp$1=Base_Int63[8],
     sexp_of_t$3=Base_Int63[9],
     of_string$1=Base_Int63[10],
     to_string$1=Base_Int63[11],
     symbol$21=Base_Int63[12],
     symbol$22=Base_Int63[13],
     symbol$23=Base_Int63[14],
     symbol$24=Base_Int63[15],
     symbol$25=Base_Int63[16],
     symbol$26=Base_Int63[17],
     equal$1=Base_Int63[18],
     compare$1=Base_Int63[19],
     min$1=Base_Int63[20],
     max$1=Base_Int63[21],
     ascending$1=Base_Int63[22],
     descending$1=Base_Int63[23],
     between$1=Base_Int63[24],
     clamp_exn$1=Base_Int63[25],
     clamp$1=Base_Int63[26],
     comparator$1=Base_Int63[27],
     pp$1=Base_Int63[28],
     hashable$1=Base_Int63[29],
     is_positive$1=Base_Int63[30],
     is_non_negative$1=Base_Int63[31],
     is_negative$1=Base_Int63[32],
     is_non_positive$1=Base_Int63[33],
     sign$1=Base_Int63[34],
     invariant$1=Base_Int63[35],
     Hex$1=Base_Int63[36],
     to_string_hum$1=Base_Int63[37],
     zero$1=Base_Int63[38],
     one$1=Base_Int63[39],
     minus_one$1=Base_Int63[40],
     symbol$27=Base_Int63[41],
     symbol$28=Base_Int63[42],
     symbol$29=Base_Int63[43],
     symbol$30=Base_Int63[44],
     neg$0=Base_Int63[45],
     symbol$31=Base_Int63[46],
     symbol$32=Base_Int63[47],
     symbol$33=Base_Int63[48],
     symbol$34=Base_Int63[49],
     rem$1=Base_Int63[50],
     symbol$35=Base_Int63[51],
     land$0=Base_Int63[52],
     lor$0=Base_Int63[53],
     lxor$0=Base_Int63[54],
     lnot$1=Base_Int63[55],
     lsl$0=Base_Int63[56],
     asr$0=Base_Int63[57],
     round$1=Base_Int63[58],
     round_towards_zero$1=Base_Int63[59],
     round_down$1=Base_Int63[60],
     round_up$1=Base_Int63[61],
     round_nearest$1=Base_Int63[62],
     abs$1=Base_Int63[63],
     succ$1=Base_Int63[64],
     pred$1=Base_Int63[65],
     pow$1=Base_Int63[66],
     bit_and$1=Base_Int63[67],
     bit_or$1=Base_Int63[68],
     bit_xor$1=Base_Int63[69],
     bit_not$1=Base_Int63[70],
     popcount$1=Base_Int63[71],
     shift_left$1=Base_Int63[72],
     shift_right$1=Base_Int63[73],
     decr$1=Base_Int63[74],
     incr$1=Base_Int63[75],
     of_int32_exn$1=Base_Int63[76],
     to_int32_exn$1=Base_Int63[77],
     of_int64_exn$1=Base_Int63[78],
     to_int64$1=Base_Int63[79],
     of_nativeint_exn$1=Base_Int63[80],
     to_nativeint_exn$1=Base_Int63[81],
     of_float_unchecked$1=Base_Int63[82],
     num_bits$1=Base_Int63[83],
     max_value$1=Base_Int63[84],
     min_value$1=Base_Int63[85],
     lsr$0=Base_Int63[86],
     shift_right_logical$1=Base_Int63[87],
     ceil_pow2$1=Base_Int63[88],
     floor_pow2$1=Base_Int63[89],
     ceil_log2$1=Base_Int63[90],
     is_pow2$1=Base_Int63[91],
     clz$1=Base_Int63[92],
     ctz$1=Base_Int63[93],
     O$1=Base_Int63[94],
     floor_log2$1=Base_Int63[113],
     uniform$1=Splittable_random[5],
     log_uniform$1=Splittable_random[10][3],
     For_int63=
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$3,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
     int63=For_int63[7],
     int63_uniform=For_int63[6],
     int63_inclusive=For_int63[4],
     int63_uniform_inclusive=For_int63[1],
     int63_log_inclusive=For_int63[5],
     int63_log_uniform_inclusive=For_int63[2],
     t_sexp_grammar$2=Base_Int64[1],
     of_float$2=Base_Int64[2],
     to_float$2=Base_Int64[3],
     of_int_exn$2=Base_Int64[4],
     to_int_exn$2=Base_Int64[5],
     hash_fold_t$2=Base_Int64[6],
     hash$2=Base_Int64[7],
     t_of_sexp$2=Base_Int64[8],
     sexp_of_t$4=Base_Int64[9],
     of_string$2=Base_Int64[10],
     to_string$2=Base_Int64[11],
     equal$2=Base_Int64[12],
     compare$2=Base_Int64[13],
     min$2=Base_Int64[14],
     max$2=Base_Int64[15],
     ascending$2=Base_Int64[16],
     descending$2=Base_Int64[17],
     between$2=Base_Int64[18],
     clamp_exn$2=Base_Int64[19],
     clamp$2=Base_Int64[20],
     comparator$2=Base_Int64[21],
     pp$2=Base_Int64[22],
     hashable$2=Base_Int64[23],
     is_positive$2=Base_Int64[24],
     is_non_negative$2=Base_Int64[25],
     is_negative$2=Base_Int64[26],
     is_non_positive$2=Base_Int64[27],
     sign$2=Base_Int64[28],
     invariant$2=Base_Int64[29],
     Hex$2=Base_Int64[30],
     to_string_hum$2=Base_Int64[31],
     one$2=Base_Int64[32],
     minus_one$2=Base_Int64[33],
     rem$2=Base_Int64[34],
     round$2=Base_Int64[35],
     round_towards_zero$2=Base_Int64[36],
     round_down$2=Base_Int64[37],
     round_up$2=Base_Int64[38],
     round_nearest$2=Base_Int64[39],
     succ$2=Base_Int64[40],
     pred$2=Base_Int64[41],
     pow$2=Base_Int64[42],
     bit_and$2=Base_Int64[43],
     bit_or$2=Base_Int64[44],
     bit_xor$2=Base_Int64[45],
     bit_not$2=Base_Int64[46],
     popcount$2=Base_Int64[47],
     shift_left$2=Base_Int64[48],
     shift_right$2=Base_Int64[49],
     decr$2=Base_Int64[50],
     incr$2=Base_Int64[51],
     of_int32_exn$2=Base_Int64[52],
     to_int32_exn$2=Base_Int64[53],
     of_int64_exn$2=Base_Int64[54],
     to_int64$2=Base_Int64[55],
     of_nativeint_exn$2=Base_Int64[56],
     to_nativeint_exn$2=Base_Int64[57],
     of_float_unchecked$2=Base_Int64[58],
     num_bits$2=Base_Int64[59],
     max_value$2=Base_Int64[60],
     min_value$2=Base_Int64[61],
     shift_right_logical$2=Base_Int64[62],
     ceil_pow2$2=Base_Int64[63],
     floor_pow2$2=Base_Int64[64],
     ceil_log2$2=Base_Int64[65],
     floor_log2$2=Base_Int64[66],
     is_pow2$2=Base_Int64[67],
     clz$2=Base_Int64[68],
     ctz$2=Base_Int64[69],
     O$2=Base_Int64[70],
     symbol$36=Base_Int64[71],
     lnot$2=Base_Int64[72],
     abs$2=Base_Int64[73],
     zero$2=Base_Int64[74],
     symbol$37=Base_Int64[75],
     symbol$38=Base_Int64[76],
     symbol$39=Base_Int64[77],
     uniform$2=Splittable_random[6],
     log_uniform$2=Splittable_random[10][4],
     For_int64=
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$4,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
     quickcheck_generator_int64=For_int64[7],
     int64_uniform=For_int64[6],
     int64_inclusive=For_int64[4],
     int64_uniform_inclusive=For_int64[1],
     int64_log_inclusive=For_int64[5],
     int64_log_uniform_inclusive=For_int64[2],
     t_sexp_grammar$3=Base_Nativeint[1],
     of_float$3=Base_Nativeint[2],
     to_float$3=Base_Nativeint[3],
     of_int_exn$3=Base_Nativeint[4],
     to_int_exn$3=Base_Nativeint[5],
     hash_fold_t$3=Base_Nativeint[6],
     hash$3=Base_Nativeint[7],
     t_of_sexp$3=Base_Nativeint[8],
     sexp_of_t$5=Base_Nativeint[9],
     of_string$3=Base_Nativeint[10],
     to_string$3=Base_Nativeint[11],
     symbol$40=Base_Nativeint[12],
     symbol$41=Base_Nativeint[13],
     symbol$42=Base_Nativeint[14],
     symbol$43=Base_Nativeint[15],
     symbol$44=Base_Nativeint[16],
     symbol$45=Base_Nativeint[17],
     equal$3=Base_Nativeint[18],
     compare$3=Base_Nativeint[19],
     min$3=Base_Nativeint[20],
     max$3=Base_Nativeint[21],
     ascending$3=Base_Nativeint[22],
     descending$3=Base_Nativeint[23],
     between$3=Base_Nativeint[24],
     clamp_exn$3=Base_Nativeint[25],
     clamp$3=Base_Nativeint[26],
     comparator$3=Base_Nativeint[27],
     pp$3=Base_Nativeint[28],
     hashable$3=Base_Nativeint[29],
     is_positive$3=Base_Nativeint[30],
     is_non_negative$3=Base_Nativeint[31],
     is_negative$3=Base_Nativeint[32],
     is_non_positive$3=Base_Nativeint[33],
     sign$3=Base_Nativeint[34],
     invariant$3=Base_Nativeint[35],
     Hex$3=Base_Nativeint[36],
     to_string_hum$3=Base_Nativeint[37],
     zero$3=Base_Nativeint[38],
     one$3=Base_Nativeint[39],
     minus_one$3=Base_Nativeint[40],
     symbol$46=Base_Nativeint[41],
     symbol$47=Base_Nativeint[42],
     symbol$48=Base_Nativeint[43],
     symbol$49=Base_Nativeint[44],
     neg$1=Base_Nativeint[45],
     symbol$50=Base_Nativeint[46],
     symbol$51=Base_Nativeint[47],
     symbol$52=Base_Nativeint[48],
     symbol$53=Base_Nativeint[49],
     rem$3=Base_Nativeint[50],
     symbol$54=Base_Nativeint[51],
     land$1=Base_Nativeint[52],
     lor$1=Base_Nativeint[53],
     lxor$1=Base_Nativeint[54],
     lnot$3=Base_Nativeint[55],
     lsl$1=Base_Nativeint[56],
     asr$1=Base_Nativeint[57],
     round$3=Base_Nativeint[58],
     round_towards_zero$3=Base_Nativeint[59],
     round_down$3=Base_Nativeint[60],
     round_up$3=Base_Nativeint[61],
     round_nearest$3=Base_Nativeint[62],
     abs$3=Base_Nativeint[63],
     succ$3=Base_Nativeint[64],
     pred$3=Base_Nativeint[65],
     pow$3=Base_Nativeint[66],
     bit_and$3=Base_Nativeint[67],
     bit_or$3=Base_Nativeint[68],
     bit_xor$3=Base_Nativeint[69],
     bit_not$3=Base_Nativeint[70],
     popcount$3=Base_Nativeint[71],
     shift_left$3=Base_Nativeint[72],
     shift_right$3=Base_Nativeint[73],
     decr$3=Base_Nativeint[74],
     incr$3=Base_Nativeint[75],
     of_int32_exn$3=Base_Nativeint[76],
     to_int32_exn$3=Base_Nativeint[77],
     of_int64_exn$3=Base_Nativeint[78],
     to_int64$3=Base_Nativeint[79],
     of_nativeint_exn$3=Base_Nativeint[80],
     to_nativeint_exn$3=Base_Nativeint[81],
     of_float_unchecked$3=Base_Nativeint[82],
     num_bits$3=Base_Nativeint[83],
     max_value$3=Base_Nativeint[84],
     min_value$3=Base_Nativeint[85],
     lsr$1=Base_Nativeint[86],
     shift_right_logical$3=Base_Nativeint[87],
     ceil_pow2$3=Base_Nativeint[88],
     floor_pow2$3=Base_Nativeint[89],
     ceil_log2$3=Base_Nativeint[90],
     floor_log2$3=Base_Nativeint[91],
     is_pow2$3=Base_Nativeint[92],
     clz$3=Base_Nativeint[93],
     ctz$3=Base_Nativeint[94],
     O$3=Base_Nativeint[95],
     uniform$3=Splittable_random[7],
     log_uniform$3=Splittable_random[10][5],
     For_nativeint=
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$5,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
     quickcheck_generator_nativeint=For_nativeint[7],
     _af_=For_nativeint[6],
     _ag_=For_nativeint[4],
     _ah_=For_nativeint[1],
     _ai_=For_nativeint[5],
     _aj_=For_nativeint[2],
     float_zero_exponent=caml_call1(Base_Float[121],0.),
     float_zero_mantissa=caml_call1(Base_Float[122],0.),
     float_max_positive_subnormal_v=
      caml_call2(Base_Float[51],759637122,Base_Float[47]),
     float_subnormal_exponent=caml_call1(Base_Float[121],Base_Float[46]),
     float_min_subnormal_mantissa=caml_call1(Base_Float[122],Base_Float[46]),
     float_max_subnormal_mantissa=
      caml_call1(Base_Float[122],float_max_positive_subnormal_v),
     _ak_=Base_Float[45],
     lower_bound=caml_call1(Base_Float[121],Base_Float[47]),
     upper_bound=caml_call1(Base_Float[121],_ak_),
     float_max_nan_mantissa=caml_call1(Base_Float[122],_ak_),
     float_inf_exponent=caml_call1(Base_Float[121],Base_Float[33]),
     float_inf_mantissa=caml_call1(Base_Float[122],Base_Float[33]),
     float_nan_exponent=caml_call1(Base_Float[121],Base_Float[32]),
     float_min_nan_mantissa=caml_call1(Base_Int63[64],float_inf_mantissa),
     float_num_mantissa_bits=52;
    function _al_(num_bits)
     {function _et_(bits)
       {return caml_call2(Base_Int63[72],bits,52 - num_bits | 0)}
      var
       _eu_=caml_call2(Base_Int63[72],Base_Int63[39],num_bits),
       _ev_=caml_call1(Base_Int63[65],_eu_),
       _ew_=caml_call2(For_int63[4],Base_Int63[38],_ev_);
      return caml_call2(For_monad[11][4][3],_ew_,_et_)}
    var
     _am_=caml_call2(For_int[1],0,float_num_mantissa_bits),
     float_normal_mantissa=caml_call2(For_monad[11][4][2],_am_,_al_),
     upper_bound$0=caml_call1(Base_Float[121],1.),
     _ar_=0;
    function _an_(offset){return upper_bound$0 + offset | 0}
    var
     _ao_=caml_call2(For_int[5],0,upper_bound - upper_bound$0 | 0),
     _as_=[0,caml_call2(For_monad[11][4][3],_ao_,_an_),_ar_];
    function _ap_(offset){return upper_bound$0 - offset | 0}
    var
     _aq_=caml_call2(For_int[5],0,upper_bound$0 - lower_bound | 0),
     float_exponent=union([0,caml_call2(For_monad[11][4][3],_aq_,_ap_),_as_]);
    function _at_(negative)
     {return caml_call3
              (Base_Float[119],
               negative,
               float_zero_exponent,
               float_zero_mantissa)}
    var
     float_zero=caml_call2(For_monad[11][4][3],quickcheck_generator_bool,_at_),
     let_syntax_012=caml_call1(For_monad[11][1],float_subnormal_exponent),
     let_syntax_013=
      caml_call2
       (For_int63[5],
        float_min_subnormal_mantissa,
        float_max_subnormal_mantissa);
    function _au_(param)
     {var
       match=param[2],
       mantissa=match[2],
       exponent=match[1],
       negative=param[1];
      return caml_call3(Base_Float[119],negative,exponent,mantissa)}
    var
     _av_=caml_call2(For_monad[11][4][4],let_syntax_012,let_syntax_013),
     _aw_=caml_call2(For_monad[11][4][4],quickcheck_generator_bool,_av_),
     float_subnormal=caml_call2(For_monad[11][4][3],_aw_,_au_);
    function _ax_(param)
     {var
       match=param[2],
       mantissa=match[2],
       exponent=match[1],
       negative=param[1];
      return caml_call3(Base_Float[119],negative,exponent,mantissa)}
    var
     _ay_=caml_call2(For_monad[11][4][4],float_exponent,float_normal_mantissa),
     _az_=caml_call2(For_monad[11][4][4],quickcheck_generator_bool,_ay_),
     float_normal=caml_call2(For_monad[11][4][3],_az_,_ax_);
    function _aA_(negative)
     {return caml_call3
              (Base_Float[119],negative,float_inf_exponent,float_inf_mantissa)}
    var
     float_infinite=
      caml_call2(For_monad[11][4][3],quickcheck_generator_bool,_aA_),
     let_syntax_021=caml_call1(For_monad[11][1],float_nan_exponent),
     let_syntax_022=
      caml_call2(For_int63[4],float_min_nan_mantissa,float_max_nan_mantissa);
    function _aB_(param)
     {var
       match=param[2],
       mantissa=match[2],
       exponent=match[1],
       negative=param[1];
      return caml_call3(Base_Float[119],negative,exponent,mantissa)}
    var
     _aC_=caml_call2(For_monad[11][4][4],let_syntax_021,let_syntax_022),
     _aD_=caml_call2(For_monad[11][4][4],quickcheck_generator_bool,_aC_),
     float_nan=caml_call2(For_monad[11][4][3],_aD_,_aB_);
    function float_of_class(c)
     {switch(c)
       {case 0:return float_infinite;
        case 1:return float_nan;
        case 2:return float_normal;
        case 3:return float_subnormal;
        default:return float_zero}}
    function float_matching_classes(filter)
     {function _eq_(c)
       {if(! caml_call1(filter,c))return 0;
        var _er_=float_of_class(c);
        switch(c)
         {case 0:var _es_=1.;break;
          case 1:var _es_=1.;break;
          case 2:var _es_=100.;break;
          case 3:var _es_=10.;break;
          default:var _es_=1.}
        return [0,[0,_es_,_er_]]}
      return weighted_union
              (caml_call2(Base_List[126],Base_Float[113][2],_eq_))}
    var
     float_finite=
      float_matching_classes(function(param){return 2 <= param?1:0}),
     float_without_nan=
      float_matching_classes(function(param){return 1 === param?0:1}),
     quickcheck_generator_float=
      float_matching_classes(function(param){return 1}),
     float_finite_non_zero=
      float_matching_classes(function(param){return 1 < param - 2 >>> 0?0:1});
    function _aE_(t){return caml_call1(Base_Float[102],t)}
    var
     float_strictly_positive=
      caml_call2(For_monad[11][4][3],float_finite_non_zero,_aE_);
    function _aF_(t)
     {var _ep_=caml_call1(Base_Float[102],t);
      return caml_call1(Base[196],_ep_)}
    var
     float_strictly_negative=
      caml_call2(For_monad[11][4][3],float_finite_non_zero,_aF_);
    function _aG_(t){return caml_call1(Base_Float[102],t)}
    var
     float_positive_or_zero=
      caml_call2(For_monad[11][4][3],float_finite,_aG_);
    function _aH_(t)
     {var _eo_=caml_call1(Base_Float[102],t);
      return caml_call1(Base[196],_eo_)}
    var
     float_negative_or_zero=
      caml_call2(For_monad[11][4][3],float_finite,_aH_);
    function float_uniform_exclusive(lower_bound,upper_bound)
     {var
       _eg_=1 - caml_call1(Base_Float[84],lower_bound),
       _eh_=_eg_ || 1 - caml_call1(Base_Float[84],upper_bound);
      if(_eh_)
       {var
         _ei_=[0,[1,[0,_aI_,[0,caml_call1(Base[112],upper_bound),0]]],0],
         _ej_=[0,[1,[0,_aJ_,[0,caml_call1(Base[112],lower_bound),0]]],_ei_],
         _ek_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Float_uniform_exclusive_bo),
            _ej_]];
        caml_call1(Base[202],_ek_)}
      var
       lower_inclusive=caml_call2(Base_Float[51],19067,lower_bound),
       upper_inclusive=caml_call2(Base_Float[51],759637122,upper_bound);
      if(caml_call2(Base_Float[103][11],lower_inclusive,upper_inclusive))
       {var
         _el_=[0,[1,[0,_aK_,[0,caml_call1(Base[112],upper_bound),0]]],0],
         _em_=[0,[1,[0,_aL_,[0,caml_call1(Base[112],lower_bound),0]]],_el_],
         _en_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Float_uniform_exclusive_re),
            _em_]];
        caml_call1(Base[202],_en_)}
      return create$0
              (function(param,random)
                {return caml_call3
                         (Splittable_random[8],
                          random,
                          lower_inclusive,
                          upper_inclusive)})}
    function float_inclusive(lower_bound,upper_bound)
     {if(caml_call2(Base_Float[15],lower_bound,upper_bound))
       return caml_call1(For_monad[11][1],lower_bound);
      var _ec_=caml_call2(Base_Float[51],19067,lower_bound);
      if(caml_call2(Base_Float[11],_ec_,upper_bound))
       {var _ed_=[0,caml_call1(For_monad[11][1],upper_bound),0];
        return union([0,caml_call1(For_monad[11][1],lower_bound),_ed_])}
      var
       _ee_=[0,[0,0.9,float_uniform_exclusive(lower_bound,upper_bound)],0],
       _ef_=[0,[0,0.05,caml_call1(For_monad[11][1],upper_bound)],_ee_];
      return weighted_union
              ([0,[0,0.05,caml_call1(For_monad[11][1],lower_bound)],_ef_])}
    function string_with_length_of(char_gen,length)
     {var _eb_=list_with_length(char_gen,length);
      return map(_eb_,Base_String[123])}
    function string_of(char_gen)
     {return bind
              (small_positive_or_zero_int,
               function(length){return string_with_length_of(char_gen,length)})}
    function string_non_empty_of(char_gen)
     {return bind
              (small_strictly_positive_int,
               function(length){return string_with_length_of(char_gen,length)})}
    var
     quickcheck_generator_string=string_of(quickcheck_generator_char),
     string_non_empty=string_non_empty_of(quickcheck_generator_char);
    function string_with_length(length)
     {return string_with_length_of(quickcheck_generator_char,length)}
    var
     quickcheck_generator_bytes=
      map(quickcheck_generator_string,Base_Bytes[25]);
    function sexp_of(atom)
     {return fixed_point
              (function(self)
                {function _d7_(size)
                  {function _d8_(param)
                    {if(0 === param)
                      {var _d__=function(atom){return [0,atom]};
                       return caml_call2(For_monad[11][4][3],atom,_d__)}
                     function _d$_(list){return [1,list]}
                     var _ea_=quickcheck_generator_list(self);
                     return caml_call2(For_monad[11][4][3],_ea_,_d$_)}
                   var _d9_=caml_call2(For_int[2],0,size + 1 | 0);
                   return caml_call2(For_monad[11][4][2],_d9_,_d8_)}
                 return caml_call2(For_monad[11][4][2],size,_d7_)})}
    var sexp=sexp_of(quickcheck_generator_string);
    function map_tree_using_comparator(comparator,key_gen,data_gen)
     {function _d1_(keys)
       {var keys$0=caml_call2(Base_List[114],keys,comparator[1]);
        function _d3_(data)
         {var
           _d5_=caml_call2(Base_List[95],keys$0,data),
           _d6_=caml_call2(Base_Map[104][3][9],comparator,_d5_);
          return caml_call1(For_monad[11][1],_d6_)}
        var _d4_=list_with_length(data_gen,caml_call1(Base_List[7],keys$0));
        return caml_call2(For_monad[11][4][2],_d4_,_d3_)}
      var _d2_=quickcheck_generator_list(key_gen);
      return caml_call2(For_monad[11][4][2],_d2_,_d1_)}
    function set_tree_using_comparator(comparator,elt_gen)
     {var _d0_=caml_call1(Base_Set[74][3][54],comparator);
      return map(quickcheck_generator_list(elt_gen),_d0_)}
    function map_t_m(m,key_gen,data_gen)
     {var
       comparator=m[1],
       _dZ_=map_tree_using_comparator(comparator,key_gen,data_gen);
      return map(_dZ_,caml_call1(Base_Map[104][95],comparator))}
    function set_t_m(m,elt_gen)
     {var comparator=m[1],_dY_=set_tree_using_comparator(comparator,elt_gen);
      return map(_dY_,caml_call1(Base_Set[74][64],comparator))}
    function bigarray1(t,kind,layout)
     {function _dU_(elts)
       {var
         elts$0=caml_call1(Base_Array[39],elts),
         dim=elts$0.length - 1,
         offset=caml_call1(Layout[1],layout);
        function _dW_(i)
         {var _dX_=i - offset | 0;
          return caml_check_bound(elts$0,_dX_)[1 + _dX_]}
        return caml_call4(_b_[2],kind,layout,dim,_dW_)}
      var _dV_=quickcheck_generator_list(t);
      return caml_call2(For_monad[11][4][3],_dV_,_dU_)}
    var
     bigstring=bigarray1(quickcheck_generator_char,12,0),
     float32_vec=bigarray1(quickcheck_generator_float,0,1),
     float64_vec=bigarray1(quickcheck_generator_float,1,1);
    function _aM_(max_total_size)
     {if(0 === max_total_size)return caml_call1(For_monad[11][1],_aN_);
      function _dN_(a)
       {function _dP_(b)
         {function _dT_(param){return param?[0,a,b]:[0,b,a]}
          return caml_call2
                  (For_monad[11][4][3],quickcheck_generator_bool,_dT_)}
        var max_b=caml_div(max_total_size,a);
        function _dQ_(b_weighted_low){return max_b - b_weighted_low | 0}
        var
         _dR_=caml_call2(int_log_uniform_inclusive,0,max_b),
         _dS_=caml_call2(For_monad[11][4][3],_dR_,_dQ_);
        return caml_call2(For_monad[11][4][2],_dS_,_dP_)}
      var _dO_=caml_call2(int_log_uniform_inclusive,1,max_total_size);
      return caml_call2(For_monad[11][4][2],_dO_,_dN_)}
    var bigarray2_dim=caml_call2(For_monad[11][4][2],size,_aM_);
    function bigarray2(t,kind,layout)
     {function _dH_(param)
       {var dim2=param[2],dim1=param[1];
        function _dI_(elts)
         {var
           elts$0=caml_call2(Base_Array[78],elts,Base_Array[39]),
           offset=caml_call1(Layout[1],layout);
          function _dK_(i,j)
           {var _dL_=j - offset | 0,_dM_=i - offset | 0;
            return caml_check_bound
                     (caml_check_bound(elts$0,_dM_)[1 + _dM_],_dL_)
                    [1 + _dL_]}
          return caml_call5(_a_[2],kind,layout,dim1,dim2,_dK_)}
        var _dJ_=list_with_length(list_with_length(t,dim2),dim1);
        return caml_call2(For_monad[11][4][3],_dJ_,_dI_)}
      return caml_call2(For_monad[11][4][2],bigarray2_dim,_dH_)}
    var
     float32_mat=bigarray2(quickcheck_generator_float,0,1),
     float64_mat=bigarray2(quickcheck_generator_float,1,1);
    function coverage(Cmp)
     {return function(sample)
       {function _dE_(counts,value)
         {function _dG_(param)
           {if(! param)return 1;var prev=param[1];return prev + 1 | 0}
          return caml_call3(Base_Map[35],counts,value,_dG_)}
        var _dF_=caml_call1(Base_Map[6],Cmp);
        return caml_call3(Base_Sequence[8],sample,_dF_,_dE_)}}
    function monitor(t,f)
     {return map(t,function(value){caml_call1(f,value);return value})}
    var
     Debug=[0,coverage,monitor],
     Base_quickcheck_Generator=
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       int63,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       sexp,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       _h_,
       _i_,
       For_monad[3],
       bind,
       return$0,
       map,
       _f_,
       _e_,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       _af_,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       _ag_,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       _ah_,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       _aj_,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       _ai_,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create$0,
       generate,
       Debug];
    caml_register_global
     (112,Base_quickcheck_Generator,"Base_quickcheck__Generator");
    function quickcheck_shrinker_float(param){return Base_Sequence[38]}
    function create$1(_dD_){return _dD_}
    function shrink(_dC_){return _dC_}
    function map$2(t,f,f_inverse)
     {return function(x)
       {var _dB_=caml_call1(t,caml_call1(f_inverse,x));
        return caml_call2(Base_Sequence[32],_dB_,f)}}
    function filter$0(t,f)
     {return function(x)
       {var _dA_=caml_call1(t,x);return caml_call2(Base_Sequence[51],_dA_,f)}}
    function filter_map$0(t,f,f_inverse)
     {return function(x)
       {var _dz_=caml_call1(t,caml_call1(f_inverse,x));
        return caml_call2(Base_Sequence[78],_dz_,f)}}
    function of_lazy$0(lazy_t)
     {return function(x)
       {var
         _dv_=
          [246,
           function(_dw_)
            {var
              _dx_=caml_obj_tag(lazy_t),
              _dy_=
               250 === _dx_
                ?lazy_t[1]
                :246 === _dx_?caml_call1(CamlinternalLazy[2],lazy_t):lazy_t;
             return caml_call1(_dy_,x)}];
        return caml_call1(Base_Sequence[105],_dv_)}}
    function fixed_point$0(of_shrinker)
     {var lazy_t=[];
      caml_update_dummy
       (lazy_t,
        [246,function(_du_){return caml_call1(of_shrinker,of_lazy$0(lazy_t))}]);
      return of_lazy$0(lazy_t)}
    function both$0(fst_t,snd_t)
     {return function(param)
       {var snd=param[2],fst=param[1],_dn_=0;
        function _do_(snd){return [0,fst,snd]}
        var
         _dp_=caml_call1(snd_t,snd),
         _dq_=[0,caml_call2(Base_Sequence[32],_dp_,_do_),_dn_];
        function _dr_(fst){return [0,fst,snd]}
        var
         _ds_=caml_call1(fst_t,fst),
         _dt_=[0,caml_call2(Base_Sequence[32],_ds_,_dr_),_dq_];
        return caml_call1(Base_Sequence[68],_dt_)}}
    function float64_vec$0(src)
     {var dim=caml_ba_dim_1(src);
      if(0 === dim)return Base_Sequence[38];
      var
       kind=caml_ba_kind(src),
       layout=caml_ba_layout(src),
       offset=caml_call1(Layout[1],layout);
      function _dl_(to_skip)
       {var to_skip$0=to_skip + offset | 0;
        function _dm_(i)
         {var i$0=i < to_skip$0?i:i + 1 | 0;return caml_ba_get_1(src,i$0)}
        return caml_call4(_b_[2],kind,layout,dim - 1 | 0,_dm_)}
      return caml_call2(Base_Sequence[77],dim,_dl_)}
    function dim2(r){return r[2]}
    function dim1(r){return r[1]}
    function _aO_(r,v){return [0,r[1],v]}
    var _aP_=0,dim2$0=[0,function(param){return 0},cst_dim2,_aP_,dim2,_aO_];
    function _aQ_(r,v){return [0,v,r[2]]}
    var _aR_=0,dim1$0=[0,function(param){return 0},cst_dim1,_aR_,dim1,_aQ_];
    function shrink$0(field,src)
     {var
       _dh_=caml_ba_dim_2(src),
       dims=[0,caml_ba_dim_1(src),_dh_],
       match=caml_call2(Base_Field[3],field,dims);
      if(0 === match)return Base_Sequence[38];
      var
       kind=caml_ba_kind(src),
       layout=caml_ba_layout(src),
       offset=caml_call1(Layout[1],layout),
       match$0=caml_call3(Base_Field[6],field,dims,Base_Int[41]),
       dim2=match$0[2],
       dim1=match$0[1];
      function _di_(to_skip)
       {var to_skip$0=to_skip + offset | 0;
        function skip(i){return i < to_skip$0?i:i + 1 | 0}
        function _dk_(dim1,dim2)
         {var
           match=caml_call3(Base_Field[6],field,[0,dim1,dim2],skip),
           dim2$0=match[2],
           dim1$0=match[1];
          return caml_ba_get_2(src,dim1$0,dim2$0)}
        return caml_call5(_a_[2],kind,layout,dim1,dim2,_dk_)}
      var _dj_=caml_call2(Base_Field[3],field,dims);
      return caml_call2(Base_Sequence[77],_dj_,_di_)}
    function float64_mat$0(src)
     {var _df_=[0,shrink$0(dim2$0,src),0],_dg_=[0,shrink$0(dim1$0,src),_df_];
      return caml_call1(Base_Sequence[68],_dg_)}
    function quickcheck_shrinker_option(value_t)
     {return function(param)
       {if(! param)return Base_Sequence[38];
        var
         value=param[1],
         _db_=Base_Option[20],
         _dc_=caml_call1(value_t,value),
         _dd_=caml_call2(Base_Sequence[32],_dc_,_db_),
         _de_=caml_call1(Base_Sequence[99],0);
        return caml_call2(Base_Sequence[63],_de_,_dd_)}}
    function quickcheck_shrinker_list(elt_t)
     {return fixed_point$0
              (function(list_t)
                {return function(param)
                  {if(! param)return Base_Sequence[38];
                   var tail=param[2],head=param[1],_c5_=0;
                   function _c6_(tail){return [0,head,tail]}
                   var
                    _c7_=caml_call1(list_t,tail),
                    _c8_=[0,caml_call2(Base_Sequence[32],_c7_,_c6_),_c5_];
                   function _c9_(head){return [0,head,tail]}
                   var
                    _c__=caml_call1(elt_t,head),
                    _c$_=[0,caml_call2(Base_Sequence[32],_c__,_c9_),_c8_],
                    _da_=[0,caml_call1(Base_Sequence[99],tail),_c$_];
                   return caml_call1(Base_Sequence[68],_da_)}})}
    var
     _aS_=Base_String[16],
     _aT_=Base_String[123],
     quickcheck_shrinker_string=
      map$2(quickcheck_shrinker_list(quickcheck_shrinker_float),_aT_,_aS_),
     quickcheck_shrinker_bytes=
      map$2(quickcheck_shrinker_string,Base_Bytes[25],Base_Bytes[26]);
    function quickcheck_shrinker_array(t)
     {var _c3_=Base_Array[19],_c4_=Base_Array[39];
      return map$2(quickcheck_shrinker_list(t),_c4_,_c3_)}
    function quickcheck_shrinker_ref(t)
     {function _c0_(_c2_){return _c2_[1]}
      return map$2(t,function(_c1_){return [0,_c1_]},_c0_)}
    function quickcheck_shrinker_lazy_t(t)
     {function _cX_(_cY_)
       {var _cZ_=caml_obj_tag(_cY_);
        return 250 === _cZ_
                ?_cY_[1]
                :246 === _cZ_?caml_call1(CamlinternalLazy[2],_cY_):_cY_}
      return map$2(t,Base_Lazy[21],_cX_)}
    var
     sexp$0=
      fixed_point$0
       (function(shrinker)
         {return function(param)
           {if(0 === param[0])return Base_Sequence[38];
            var
             l=param[1],
             _cV_=caml_call1(quickcheck_shrinker_list(shrinker),l),
             _cW_=Base_Sequence[32],
             shrink_list=caml_call2(_cW_,_cV_,function(l){return [1,l]}),
             shrink_tree=caml_call1(Base_Sequence[104],l);
            return caml_call1
                    (Base_Sequence[68],[0,shrink_list,[0,shrink_tree,0]])}});
    function either$0(fst_t,snd_t)
     {return function(either)
       {if(0 === either[0])
         {var fst=either[1],_cR_=Base_Either[17],_cS_=caml_call1(fst_t,fst);
          return caml_call2(Base_Sequence[32],_cS_,_cR_)}
        var snd=either[1],_cT_=Base_Either[18],_cU_=caml_call1(snd_t,snd);
        return caml_call2(Base_Sequence[32],_cU_,_cT_)}}
    function result$0(ok_t,err_t)
     {function _cP_(param)
       {if(0 === param[0]){var ok=param[1];return [0,ok]}
        var err=param[1];
        return [1,err]}
      function _cQ_(param)
       {if(0 === param[0]){var ok=param[1];return [0,ok]}
        var err=param[1];
        return [1,err]}
      return map$2(either$0(ok_t,err_t),_cQ_,_cP_)}
    function map_tree_using_comparator$0(comparator,key_t,data_t)
     {return function(tree)
       {var alist=caml_call2(Base_Map[104][3][66],0,tree);
        function _cF_(param)
         {var k=param[1];
          return caml_call3(Base_Map[104][3][39],comparator,tree,k)}
        var
         _cG_=caml_call1(Base_Sequence[104],alist),
         drop_keys=caml_call2(Base_Sequence[32],_cG_,_cF_);
        function _cH_(param)
         {var
           data=param[2],
           key=param[1],
           tree$0=caml_call3(Base_Map[104][3][39],comparator,tree,key);
          function _cN_(smaller_key)
           {var
             match=
              caml_call4
               (Base_Map[104][3][29],comparator,tree$0,smaller_key,data);
            if(typeof match === "number")return 0;
            var tree=match[2];
            return [0,tree]}
          var _cO_=caml_call1(key_t,key);
          return caml_call2(Base_Sequence[78],_cO_,_cN_)}
        var
         _cI_=caml_call2(Base_List[76],alist,_cH_),
         shrink_keys=caml_call1(Base_Sequence[68],_cI_);
        function _cJ_(param)
         {var data=param[2],key=param[1];
          function _cL_(smaller_data)
           {return caml_call4
                    (Base_Map[104][3][31],comparator,tree,key,smaller_data)}
          var _cM_=caml_call1(data_t,data);
          return caml_call2(Base_Sequence[32],_cM_,_cL_)}
        var
         _cK_=caml_call2(Base_List[76],alist,_cJ_),
         shrink_data=caml_call1(Base_Sequence[68],_cK_);
        return caml_call1
                (Base_Sequence[68],
                 [0,drop_keys,[0,shrink_keys,[0,shrink_data,0]]])}}
    function set_tree_using_comparator$0(comparator,elt_t)
     {return function(tree)
       {var list=caml_call1(Base_Set[74][3][15],tree);
        function _cz_(elt)
         {return caml_call3(Base_Set[74][3][20],comparator,tree,elt)}
        var
         _cA_=caml_call1(Base_Sequence[104],list),
         drop_elts=caml_call2(Base_Sequence[32],_cA_,_cz_);
        function _cB_(elt)
         {var tree$0=caml_call3(Base_Set[74][3][20],comparator,tree,elt);
          function _cD_(smaller_elt)
           {var
             match=
              caml_call3(Base_Set[74][3][18],comparator,tree$0,smaller_elt);
            return match
                    ?0
                    :[0,
                      caml_call3
                       (Base_Set[74][3][19],comparator,tree$0,smaller_elt)]}
          var _cE_=caml_call1(elt_t,elt);
          return caml_call2(Base_Sequence[78],_cE_,_cD_)}
        var
         _cC_=caml_call2(Base_List[76],list,_cB_),
         shrink_elts=caml_call1(Base_Sequence[68],_cC_);
        return caml_call1(Base_Sequence[68],[0,drop_elts,[0,shrink_elts,0]])}}
    function map_t(key_t,data_t)
     {return function(map_t)
       {var
         comparator=caml_call1(Base_Map[5],map_t),
         _cx_=Base_Map[104][68],
         _cy_=caml_call1(Base_Map[104][95],comparator),
         t=
          map$2
           (map_tree_using_comparator$0(comparator,key_t,data_t),_cy_,_cx_);
        return caml_call1(t,map_t)}}
    function set_t(elt_t)
     {return function(set_t)
       {var
         comparator=caml_call1(Base_Set[4],set_t),
         _cv_=Base_Set[74][47],
         _cw_=caml_call1(Base_Set[74][64],comparator),
         t=map$2(set_tree_using_comparator$0(comparator,elt_t),_cw_,_cv_);
        return caml_call1(t,set_t)}}
    var
     Base_quickcheck_Shrinker=
      [0,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       sexp$0,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       both$0,
       either$0,
       result$0,
       float64_vec$0,
       float64_vec$0,
       float64_vec$0,
       float64_mat$0,
       float64_mat$0,
       map_t,
       set_t,
       map_tree_using_comparator$0,
       set_tree_using_comparator$0,
       map$2,
       filter$0,
       filter_map$0,
       fixed_point$0,
       of_lazy$0,
       create$1,
       shrink];
    caml_register_global
     (114,Base_quickcheck_Shrinker,"Base_quickcheck__Shrinker");
    var Base_quickcheck_Test_intf=[0];
    caml_register_global
     (115,Base_quickcheck_Test_intf,"Base_quickcheck__Test_intf");
    function sexp_of_t$6(param)
     {if(! param)return _aV_;
      var arg0_001=param[1],res0_002=caml_call1(Base[164],arg0_001);
      return [1,[0,_aU_,[0,res0_002,0]]]}
    var Seed=[0,sexp_of_t$6];
    function sizes$0(r){return r[4]}
    function shrink_count(r){return r[3]}
    function test_count(r){return r[2]}
    function seed(r){return r[1]}
    function _aW_(r,v){return [0,r[1],r[2],r[3],v]}
    var
     _aX_=0,
     sizes$1=[0,function(param){return 0},cst_sizes,_aX_,sizes$0,_aW_];
    function _aY_(r,v){return [0,r[1],r[2],v,r[4]]}
    var
     _aZ_=0,
     shrink_count$0=
      [0,function(param){return 0},cst_shrink_count,_aZ_,shrink_count,_aY_];
    function _a0_(r,v){return [0,r[1],v,r[3],r[4]]}
    var
     _a1_=0,
     test_count$0=
      [0,function(param){return 0},cst_test_count,_a1_,test_count,_a0_];
    function _a2_(r,v){return [0,v,r[2],r[3],r[4]]}
    var _a3_=0,seed$0=[0,function(param){return 0},cst_seed,_a3_,seed,_a2_];
    function make_creator
     (seed_fun,test_count_fun,shrink_count_fun,sizes_fun,compile_acc)
     {var
       match=caml_call2(seed_fun,seed$0,compile_acc),
       compile_acc$0=match[2],
       seed_gen=match[1],
       match$0=caml_call2(test_count_fun,test_count$0,compile_acc$0),
       compile_acc$1=match$0[2],
       test_count_gen=match$0[1],
       match$1=caml_call2(shrink_count_fun,shrink_count$0,compile_acc$1),
       compile_acc$2=match$1[2],
       shrink_count_gen=match$1[1],
       match$2=caml_call2(sizes_fun,sizes$1,compile_acc$2),
       compile_acc$3=match$2[2],
       sizes_gen=match$2[1];
      return [0,
              function(acc)
               {var
                 seed=caml_call1(seed_gen,acc),
                 test_count=caml_call1(test_count_gen,acc),
                 shrink_count=caml_call1(shrink_count_gen,acc),
                 sizes=caml_call1(sizes_gen,acc);
                return [0,seed,test_count,shrink_count,sizes]},
              compile_acc$3]}
    function create$2(seed,test_count,shrink_count,sizes)
     {return [0,seed,test_count,shrink_count,sizes]}
    function map$3(seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _cs_=caml_call1(sizes_fun,sizes$1),
       _ct_=caml_call1(shrink_count_fun,shrink_count$0),
       _cu_=caml_call1(test_count_fun,test_count$0);
      return [0,caml_call1(seed_fun,seed$0),_cu_,_ct_,_cs_]}
    function iter(seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {caml_call1(seed_fun,seed$0);
      caml_call1(test_count_fun,test_count$0);
      caml_call1(shrink_count_fun,shrink_count$0);
      return caml_call1(sizes_fun,sizes$1)}
    function fold$1(init,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {return caml_call2
              (sizes_fun,
               caml_call2
                (shrink_count_fun,
                 caml_call2
                  (test_count_fun,
                   caml_call2(seed_fun,init,seed$0),
                   test_count$0),
                 shrink_count$0),
               sizes$1)}
    function map_poly(record)
     {var
       _cp_=[0,caml_call1(record[1],sizes$1),0],
       _cq_=[0,caml_call1(record[1],shrink_count$0),_cp_],
       _cr_=[0,caml_call1(record[1],test_count$0),_cq_];
      return [0,caml_call1(record[1],seed$0),_cr_]}
    function for_all(seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _cm_=caml_call1(seed_fun,seed$0),
       _cn_=_cm_?caml_call1(test_count_fun,test_count$0):_cm_,
       _co_=_cn_?caml_call1(shrink_count_fun,shrink_count$0):_cn_;
      return _co_?caml_call1(sizes_fun,sizes$1):_co_}
    function exists(seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _cl_=caml_call1(seed_fun,seed$0),
       _cj_=_cl_ || caml_call1(test_count_fun,test_count$0),
       _ck_=_cj_ || caml_call1(shrink_count_fun,shrink_count$0);
      return _ck_?_ck_:caml_call1(sizes_fun,sizes$1)}
    function to_list(seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _cg_=[0,caml_call1(sizes_fun,sizes$1),0],
       _ch_=[0,caml_call1(shrink_count_fun,shrink_count$0),_cg_],
       _ci_=[0,caml_call1(test_count_fun,test_count$0),_ch_];
      return [0,caml_call1(seed_fun,seed$0),_ci_]}
    function iter$0(record,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {caml_call3(seed_fun,seed$0,record,record[1]);
      caml_call3(test_count_fun,test_count$0,record,record[2]);
      caml_call3(shrink_count_fun,shrink_count$0,record,record[3]);
      return caml_call3(sizes_fun,sizes$1,record,record[4])}
    function fold$2
     (record,init,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var _cd_=record[4],_ce_=record[3],_cf_=record[2];
      return caml_call4
              (sizes_fun,
               caml_call4
                (shrink_count_fun,
                 caml_call4
                  (test_count_fun,
                   caml_call4(seed_fun,init,seed$0,record,record[1]),
                   test_count$0,
                   record,
                   _cf_),
                 shrink_count$0,
                 record,
                 _ce_),
               sizes$1,
               record,
               _cd_)}
    function for_all$0
     (record,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _ca_=caml_call3(seed_fun,seed$0,record,record[1]),
       _cb_=_ca_?caml_call3(test_count_fun,test_count$0,record,record[2]):_ca_,
       _cc_=
        _cb_?caml_call3(shrink_count_fun,shrink_count$0,record,record[3]):_cb_;
      return _cc_?caml_call3(sizes_fun,sizes$1,record,record[4]):_cc_}
    function exists$0
     (record,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _b$_=caml_call3(seed_fun,seed$0,record,record[1]),
       _b9_=_b$_ || caml_call3(test_count_fun,test_count$0,record,record[2]),
       _b__=
        _b9_
        ||
        caml_call3(shrink_count_fun,shrink_count$0,record,record[3]);
      return _b__?_b__:caml_call3(sizes_fun,sizes$1,record,record[4])}
    function to_list$0
     (record,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _b6_=[0,caml_call3(sizes_fun,sizes$1,record,record[4]),0],
       _b7_=
        [0,caml_call3(shrink_count_fun,shrink_count$0,record,record[3]),_b6_],
       _b8_=[0,caml_call3(test_count_fun,test_count$0,record,record[2]),_b7_];
      return [0,caml_call3(seed_fun,seed$0,record,record[1]),_b8_]}
    function map$4(record,seed_fun,test_count_fun,shrink_count_fun,sizes_fun)
     {var
       _b3_=caml_call3(sizes_fun,sizes$1,record,record[4]),
       _b4_=caml_call3(shrink_count_fun,shrink_count$0,record,record[3]),
       _b5_=caml_call3(test_count_fun,test_count$0,record,record[2]);
      return [0,caml_call3(seed_fun,seed$0,record,record[1]),_b5_,_b4_,_b3_]}
    function set_all_mutable_fields(record)
     {caml_call1(Base_Field[1][1],record);return 0}
    var
     Direct=
      [0,
       iter$0,
       fold$2,
       for_all$0,
       exists$0,
       to_list$0,
       map$4,
       set_all_mutable_fields];
    function sexp_of_t$7(param)
     {var
       sizes_010=param[4],
       shrink_count_008=param[3],
       test_count_006=param[2],
       seed_004=param[1],
       _b2_=Base[119],
       match=caml_call2(Base_Sequence[88],sizes_010,100),
       suffix=match[2],
       prefix=match[1],
       prefix$0=caml_call2(Base_List[76],prefix,_b2_),
       match$0=caml_call1(Base_Sequence[6],suffix),
       bnds_003=0,
       suffix$0=match$0?0:[0,caml_call1(Sexplib0_Sexp_conv[7],cst),0],
       arg_011=[1,caml_call2(Base[178],prefix$0,suffix$0)],
       bnds_003$0=[0,[1,[0,_a4_,[0,arg_011,0]]],bnds_003],
       arg_009=caml_call1(Base[119],shrink_count_008),
       bnds_003$1=[0,[1,[0,_a5_,[0,arg_009,0]]],bnds_003$0],
       arg_007=caml_call1(Base[119],test_count_006),
       bnds_003$2=[0,[1,[0,_a6_,[0,arg_007,0]]],bnds_003$1],
       arg_005=caml_call1(Seed[1],seed_004),
       bnds_003$3=[0,[1,[0,_a7_,[0,arg_005,0]]],bnds_003$2];
      return [1,bnds_003$3]}
    var
     _a__=caml_call5(Base_List[121],0,_a9_,_a8_,0,30),
     default_config=[0,_a$_,10000,10000,caml_call1(Base_Sequence[97],_a__)],
     lazy_nondeterministic_state=
      [246,function(_b1_){return caml_call2(Base_Random[18][3],0,0)}];
    function with_sample(f,opt,_bX_,generator)
     {if(opt)var sth=opt[1],config=sth;else var config=default_config;
      if(_bX_)var sth$0=_bX_[1],examples=sth$0;else var examples=0;
      var match=config[1];
      if(match)
       var
        string=match[1],
        _bP_=runtime.Base_hash_string(string),
        random=caml_call1(Splittable_random[1][2],_bP_);
      else
       var
        _bQ_=caml_obj_tag(lazy_nondeterministic_state),
        _bR_=
         250 === _bQ_
          ?lazy_nondeterministic_state[1]
          :246 === _bQ_
            ?caml_call1(CamlinternalLazy[2],lazy_nondeterministic_state)
            :lazy_nondeterministic_state,
        random=caml_call1(Splittable_random[1][1],_bR_);
      function _bS_(param)
       {var
         number_of_size_values=param[2],
         sizes=param[1],
         match=config[2] <= number_of_size_values?1:0;
        if(match)return 0;
        var match$0=caml_call1(Base_Sequence[39],sizes);
        if(match$0)
         {var match$1=match$0[1],remaining_sizes=match$1[2],size=match$1[1];
          return [0,
                  [0,size,[0,remaining_sizes,number_of_size_values + 1 | 0]]]}
        var
         _bY_=
          [0,[1,[0,_ba_,[0,caml_call1(Base[119],number_of_size_values),0]]],0],
         _bZ_=[0,[1,[0,_bb_,[0,caml_call1(Base[119],config[2]),0]]],_bY_],
         _b0_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Test_run_i),
            _bZ_]];
        return caml_call1(Base[202],_b0_)}
      var
       _bT_=caml_call2(Base_Sequence[42],[0,config[4],0],_bS_),
       _bU_=Base_Sequence[32],
       _bV_=
        caml_call2
         (_bU_,_bT_,function(size){return generate(generator,size,random)}),
       _bW_=caml_call1(Base_Sequence[104],examples),
       sequence=caml_call2(Base_Sequence[63],_bW_,_bV_);
      return caml_call1(f,sequence)}
    function result$1(f,opt,_bK_,m)
     {if(opt)var sth=opt[1],config=sth;else var config=default_config;
      if(_bK_)var sth$0=_bK_[1],examples=sth$0;else var examples=0;
      var _bL_=m[2],_bM_=[0,examples],_bN_=[0,config];
      return with_sample
              (function(sequence)
                {function _bO_(param,input)
                  {var match=caml_call1(f,input);
                   if(0 === match[0])return _bc_;
                   var error=match[1];
                   return [1,[0,input,error]]}
                 var match$2=caml_call3(Base_Sequence[9],sequence,0,_bO_);
                 if(0 === match$2[0])return _bd_;
                 var
                  match$3=match$2[1],
                  error$1=match$3[2],
                  input$0=match$3[1],
                  shrinker=m[3],
                  shrink_count$1=config[3],
                  alternates$2=caml_call1(shrinker,input$0),
                  shrink_count=shrink_count$1,
                  alternates=alternates$2,
                  input=input$0,
                  error=error$1;
                 for(;;)
                  {if(0 !== shrink_count)
                    {var
                      shrink_count$0=shrink_count - 1 | 0,
                      match=caml_call1(Base_Sequence[39],alternates);
                     if(match)
                      {var
                        match$0=match[1],
                        alternates$0=match$0[2],
                        alternate=match$0[1],
                        match$1=caml_call1(f,alternate);
                       if(0 === match$1[0])
                        {var shrink_count=shrink_count$0,alternates=alternates$0;
                         continue}
                       var
                        error$0=match$1[1],
                        alternates$1=caml_call1(shrinker,alternate),
                        shrink_count=shrink_count$0,
                        alternates=alternates$1,
                        input=alternate,
                        error=error$0;
                       continue}}
                   return [1,[0,input,error]]}},
               _bN_,
               _bM_,
               _bL_)}
    function run(f,config,examples,M)
     {function f$0(x)
       {function _bI_(param){return caml_call1(f,x)}
        var _bJ_=[0,caml_call1(Base_Backtrace[6][1],0)];
        return caml_call2(Base_Or_error[29],_bJ_,_bI_)}
      var match=result$1(f$0,config,examples,M);
      if(0 === match[0])return _be_;
      var
       match$0=match[1],
       error=match$0[2],
       input=match$0[1],
       _bF_=[0,[1,[0,_bf_,[0,caml_call1(Base_Error[6],error),0]]],0],
       _bG_=[0,[1,[0,_bg_,[0,caml_call1(M[1],input),0]]],_bF_],
       _bH_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Base_quickcheck_Test_run_t),
          _bG_]];
      return caml_call1(Base_Or_error[35],_bH_)}
    function with_sample_exn(f,config,examples,generator)
     {function f$0(x)
       {function _bE_(param){return caml_call1(f,x)}
        return caml_call2(Base_Or_error[28],0,_bE_)}
      var _bD_=with_sample(f$0,config,examples,generator);
      return caml_call1(Base_Or_error[31],_bD_)}
    function run_exn(f,config,examples,testable)
     {function f$0(x)
       {function _bB_(param){return caml_call1(f,x)}
        var _bC_=[0,caml_call1(Base_Backtrace[6][1],0)];
        return caml_call2(Base_Or_error[28],_bC_,_bB_)}
      var _bA_=run(f$0,config,examples,testable);
      return caml_call1(Base_Or_error[31],_bA_)}
    var
     Base_quickcheck_Test=
      [0,
       [0,
        Seed,
        sizes$0,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$1,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold$1,
         make_creator,
         create$2,
         map$3,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$7],
       default_config,
       run,
       run_exn,
       result$1,
       with_sample,
       with_sample_exn];
    caml_register_global(119,Base_quickcheck_Test,"Base_quickcheck__Test");
    function unmap(t,f)
     {return function(x,size,hash)
       {return observe(t,caml_call1(f,x),size,hash)}}
    function of_hash_fold(f)
     {return function(x,param,hash){return caml_call2(f,hash,x)}}
    function of_lazy$1(lazy_t)
     {return function(x,size,hash)
       {var
         _by_=caml_obj_tag(lazy_t),
         _bz_=
          250 === _by_
           ?lazy_t[1]
           :246 === _by_?caml_call1(CamlinternalLazy[2],lazy_t):lazy_t;
        return observe(_bz_,x,size,hash)}}
    function fixed_point$1(wrap)
     {var lazy_t=[];
      caml_update_dummy
       (lazy_t,
        [246,function(_bx_){return caml_call1(wrap,of_lazy$1(lazy_t))}]);
      return of_lazy$1(lazy_t)}
    var
     quickcheck_observer_bool=of_hash_fold(Base_Bool[3]),
     quickcheck_observer_char=of_hash_fold(Base_Char[3]),
     quickcheck_observer_int=of_hash_fold(Base_Int[6]),
     quickcheck_observer_int32=of_hash_fold(Base_Int32[6]),
     int63$0=of_hash_fold(Base_Int63[6]),
     quickcheck_observer_int64=of_hash_fold(Base_Int64[6]),
     quickcheck_observer_nativeint=of_hash_fold(Base_Nativeint[6]),
     quickcheck_observer_float=of_hash_fold(Base_Float[4]),
     quickcheck_observer_string=of_hash_fold(Base_String[26]),
     sexp$1=of_hash_fold(Base[84][1]),
     bigstring$0=of_hash_fold(caml_call1(_b_[6],Base[101])),
     float32_vec$0=of_hash_fold(caml_call1(_b_[6],Base[109])),
     float64_vec$1=of_hash_fold(caml_call1(_b_[6],Base[109])),
     float32_mat$0=of_hash_fold(caml_call1(_a_[6],Base[109])),
     float64_mat$1=of_hash_fold(caml_call1(_a_[6],Base[109])),
     quickcheck_observer_bytes=
      unmap(quickcheck_observer_string,Base_Bytes[26]);
    function either$1(fst_t,snd_t)
     {return function(either,size,hash)
       {if(0 === either[0])
         {var fst=either[1];
          return observe(fst_t,fst,size,caml_call2(Base[116],hash,1))}
        var snd=either[1];
        return observe(snd_t,snd,size,caml_call2(Base[116],hash,2))}}
    function result$2(ok_t,err_t)
     {function _bw_(param)
       {if(0 === param[0]){var ok=param[1];return [0,ok]}
        var err=param[1];
        return [1,err]}
      return unmap(either$1(ok_t,err_t),_bw_)}
    function both$1(fst_t,snd_t)
     {return function(param,size,hash)
       {var
         snd=param[2],
         fst=param[1],
         hash$0=observe(fst_t,fst,size,hash),
         hash$1=observe(snd_t,snd,size,hash$0);
        return hash$1}}
    function quickcheck_observer_option(value_t)
     {function _bv_(param)
       {if(! param)return _bh_;var value=param[1];return [1,value]}
      return unmap(either$1(quickcheck_observer_unit,value_t),_bv_)}
    function quickcheck_observer_list(elt_t)
     {return function(list,size,hash)
       {var
         _bs_=caml_call1(Base_Hash[9],hash),
         random=caml_call1(Splittable_random[1][2],_bs_),
         length=caml_call1(Base_List[7],list),
         sizes$0=generate(sizes([0,length],[0,length],0),size,random);
        function _bt_(hash,elt,size)
         {return observe(elt_t,elt,size,caml_call2(Base[116],hash,1))}
        var _bu_=caml_call2(Base[116],hash,0);
        return caml_call4(Base_List[46],list,sizes$0,_bu_,_bt_)}}
    function quickcheck_observer_array(t)
     {var _br_=Base_Array[19];return unmap(quickcheck_observer_list(t),_br_)}
    function quickcheck_observer_ref(t)
     {return unmap(t,function(_bq_){return _bq_[1]})}
    function quickcheck_observer_lazy_t(t)
     {return unmap
              (t,
               function(_bo_)
                {var _bp_=caml_obj_tag(_bo_);
                 return 250 === _bp_
                         ?_bo_[1]
                         :246 === _bp_?caml_call1(CamlinternalLazy[2],_bo_):_bo_})}
    function fn$0(dom,rng)
     {return function(f,size,hash)
       {var
         _bm_=caml_call1(Base_Hash[9],hash),
         random=caml_call1(Splittable_random[1][2],_bm_),
         sizes$0=generate(sizes(0,0,0),size * 2 | 0,random);
        function _bn_(hash,size)
         {var x=generate(dom,size,random);
          return observe(rng,caml_call1(f,x),size,hash)}
        return caml_call3(Base_List[10],sizes$0,hash,_bn_)}}
    function map_tree(key_obs,data_obs)
     {var arg=Base_Map[104][3][66];
      function _bl_(eta){return caml_call2(arg,0,eta)}
      return unmap(quickcheck_observer_list(both$1(key_obs,data_obs)),_bl_)}
    function set_tree(elt_obs)
     {var _bk_=Base_Set[74][3][15];
      return unmap(quickcheck_observer_list(elt_obs),_bk_)}
    function map_t$0(key_obs,data_obs)
     {var _bj_=Base_Map[104][68];
      return unmap(map_tree(key_obs,data_obs),_bj_)}
    function set_t$0(elt_obs)
     {var _bi_=Base_Set[74][47];return unmap(set_tree(elt_obs),_bi_)}
    var
     Base_quickcheck_Observer=
      [0,
       quickcheck_observer_unit,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       int63$0,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       sexp$1,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       both$1,
       either$1,
       result$2,
       bigstring$0,
       float32_vec$0,
       float64_vec$1,
       float32_mat$0,
       float64_mat$1,
       fn$0,
       map_t$0,
       set_t$0,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point$1,
       of_lazy$1,
       create,
       observe];
    caml_register_global
     (121,Base_quickcheck_Observer,"Base_quickcheck__Observer");
    var
     include$1=
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
    caml_register_global(122,include$1,"Base_quickcheck__Export");
    var
     Private=[0],
     Base_quickcheck$0=
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
    caml_register_global(123,Base_quickcheck$0,"Base_quickcheck");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm5hbWVzIiwib2Zmc2V0IiwiaXRlcmkiLCJ0IiwiZiIsImkiLCJpbml0Iiwia2luZCIsImxheW91dCIsImRpbSIsImZvbGQiLCJpbml0JDAiLCJ0b19hcnJheSIsInNleHBfb2ZfdCIsInNleHBfb2ZfZWx0Iiwic2V4cF9vZl9wYWNrIiwic2V4cF9vZl9sYXlvdXQiLCJ4XzAwMSIsImhhc2hfZm9sZCIsImhhc2hfZm9sZF9lbHQiLCJzdGF0ZSIsInN0YXRlJDAiLCJpdGVyaSQwIiwiaiIsImRpbTEiLCJkaW0yIiwiZm9sZCQwIiwiZWx0IiwidG9fYXJyYXkkMCIsInNleHBfb2ZfdCQwIiwieF8wMDIiLCJoYXNoX2ZvbGQkMCIsInN0YXRlJDEiLCJ4Iiwic2l6ZSIsImhhc2giLCJjcmVhdGUkMCIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5IiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsInN1bSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwidyIsIm4iLCJyZWNfbGlzdCIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInZhbHVlX3QiLCJlaXRoZXIiLCJmc3RfdCIsInNuZF90IiwicmVzdWx0Iiwib2tfdCIsImVycl90Iiwib2siLCJlcnIiLCJsaXN0X2dlbmVyaWMiLCJlbHRfZ2VuIiwibGlzdF9ub25fZW1wdHkiLCJsaXN0X3dpdGhfbGVuZ3RoIiwibGVuZ3RoIiwibGlzdF9maWx0ZXJlZCIsImVsdHMiLCJlbHRzJDAiLCJsZW5ndGhfb2ZfaW5wdXQiLCJsZW5ndGhfb2Zfb3V0cHV0IiwiaW5kaWNlcyIsImxpc3RfcGVybXV0YXRpb25zIiwiY2hhcl91bmlmb3JtX2luY2x1c2l2ZSIsImNoYXJfdXBwZXJjYXNlIiwiY2hhcl9sb3dlcmNhc2UiLCJjaGFyX2RpZ2l0IiwiY2hhcl9wcmludF91bmlmb3JtIiwiY2hhcl91bmlmb3JtIiwiY2hhcl9hbHBoYSIsImNoYXJfYWxwaGFudW0iLCJjaGFyX3doaXRlc3BhY2UiLCJjaGFyX3ByaW50Iiwic21hbGxfaW50IiwiYWxsb3dfemVybyIsImxvd2VyX2JvdW5kIiwid2VpZ2h0ZWRfbG93Iiwid2VpZ2h0ZWRfaGlnaCIsInNtYWxsX3Bvc2l0aXZlX29yX3plcm9faW50Iiwic21hbGxfc3RyaWN0bHlfcG9zaXRpdmVfaW50IiwidW5pZm9ybV9pbmNsdXNpdmUiLCJsb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJub25fdW5pZm9ybSIsImluY2x1c2l2ZSIsImxvZ19pbmNsdXNpdmUiLCJ1bmlmb3JtX2FsbCIsImxldF9zeW50YXhfMDA0IiwibWFnbml0dWRlIiwibmVnYXRpdmUiLCJ1bmlmb3JtIiwibG9nX3VuaWZvcm0iLCJpbnRfdW5pZm9ybSIsImludF9pbmNsdXNpdmUiLCJpbnRfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnRfbG9nX2luY2x1c2l2ZSIsImludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJ1bmlmb3JtJDAiLCJsb2dfdW5pZm9ybSQwIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJzeW1ib2wkMzYiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInVuaWZvcm0kMiIsImxvZ191bmlmb3JtJDIiLCJpbnQ2NF91bmlmb3JtIiwiaW50NjRfaW5jbHVzaXZlIiwiaW50NjRfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfaW5jbHVzaXZlIiwiaW50NjRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIiwidW5pZm9ybSQzIiwibG9nX3VuaWZvcm0kMyIsImZsb2F0X3plcm9fZXhwb25lbnQiLCJmbG9hdF96ZXJvX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX3N1Ym5vcm1hbF92IiwiZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50IiwiZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSIsImZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfbmFuX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X251bV9tYW50aXNzYV9iaXRzIiwibnVtX2JpdHMiLCJiaXRzIiwiZmxvYXRfbm9ybWFsX21hbnRpc3NhIiwidXBwZXJfYm91bmQkMCIsImZsb2F0X2V4cG9uZW50IiwiZmxvYXRfemVybyIsImxldF9zeW50YXhfMDEyIiwibGV0X3N5bnRheF8wMTMiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiZmxvYXRfc3Vibm9ybWFsIiwiZmxvYXRfbm9ybWFsIiwiZmxvYXRfaW5maW5pdGUiLCJsZXRfc3ludGF4XzAyMSIsImxldF9zeW50YXhfMDIyIiwiZmxvYXRfbmFuIiwiZmxvYXRfb2ZfY2xhc3MiLCJjIiwiZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyIsImZsb2F0X2Zpbml0ZSIsImZsb2F0X3dpdGhvdXRfbmFuIiwiZmxvYXRfZmluaXRlX25vbl96ZXJvIiwiZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUiLCJmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSIsImZsb2F0X3Bvc2l0aXZlX29yX3plcm8iLCJmbG9hdF9uZWdhdGl2ZV9vcl96ZXJvIiwiZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUiLCJsb3dlcl9pbmNsdXNpdmUiLCJ1cHBlcl9pbmNsdXNpdmUiLCJmbG9hdF9pbmNsdXNpdmUiLCJzdHJpbmdfd2l0aF9sZW5ndGhfb2YiLCJjaGFyX2dlbiIsInN0cmluZ19vZiIsInN0cmluZ19ub25fZW1wdHlfb2YiLCJzdHJpbmdfbm9uX2VtcHR5Iiwic3RyaW5nX3dpdGhfbGVuZ3RoIiwic2V4cF9vZiIsImF0b20iLCJzZXhwIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImNvbXBhcmF0b3IiLCJrZXlfZ2VuIiwiZGF0YV9nZW4iLCJrZXlzIiwia2V5cyQwIiwiZGF0YSIsInNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJtYXBfdF9tIiwibSIsInNldF90X20iLCJiaWdhcnJheTEiLCJiaWdzdHJpbmciLCJmbG9hdDMyX3ZlYyIsImZsb2F0NjRfdmVjIiwibWF4X3RvdGFsX3NpemUiLCJhIiwiYiIsIm1heF9iIiwiYl93ZWlnaHRlZF9sb3ciLCJiaWdhcnJheTJfZGltIiwiYmlnYXJyYXkyIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImNvdmVyYWdlIiwiQ21wIiwic2FtcGxlIiwiY291bnRzIiwidmFsdWUiLCJwcmV2IiwibW9uaXRvciIsImNyZWF0ZSQxIiwic2hyaW5rIiwibWFwJDIiLCJmX2ludmVyc2UiLCJmaWx0ZXIkMCIsImZpbHRlcl9tYXAkMCIsIm9mX2xhenkkMCIsImZpeGVkX3BvaW50JDAiLCJvZl9zaHJpbmtlciIsImJvdGgkMCIsInNuZCIsImZzdCIsImZsb2F0NjRfdmVjJDAiLCJzcmMiLCJ0b19za2lwIiwidG9fc2tpcCQwIiwiaSQwIiwiciIsInYiLCJkaW0yJDAiLCJkaW0xJDAiLCJzaHJpbmskMCIsImZpZWxkIiwiZGltcyIsInNraXAiLCJmbG9hdDY0X21hdCQwIiwiZWx0X3QiLCJsaXN0X3QiLCJ0YWlsIiwiaGVhZCIsInNleHAkMCIsInNocmlua2VyIiwibCIsInNocmlua19saXN0Iiwic2hyaW5rX3RyZWUiLCJlaXRoZXIkMCIsInJlc3VsdCQwIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciQwIiwia2V5X3QiLCJkYXRhX3QiLCJ0cmVlIiwiayIsImRyb3Bfa2V5cyIsImtleSIsInRyZWUkMCIsInNtYWxsZXJfa2V5Iiwic2hyaW5rX2tleXMiLCJzbWFsbGVyX2RhdGEiLCJzaHJpbmtfZGF0YSIsInNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IkMCIsImRyb3BfZWx0cyIsInNtYWxsZXJfZWx0Iiwic2hyaW5rX2VsdHMiLCJtYXBfdCIsInNldF90Iiwic2V4cF9vZl90JDYiLCJhcmcwXzAwMSIsInJlczBfMDAyIiwic2l6ZXMkMCIsInNocmlua19jb3VudCIsInRlc3RfY291bnQiLCJzZWVkIiwic2l6ZXMkMSIsInNocmlua19jb3VudCQwIiwidGVzdF9jb3VudCQwIiwic2VlZCQwIiwibWFrZV9jcmVhdG9yIiwic2VlZF9mdW4iLCJ0ZXN0X2NvdW50X2Z1biIsInNocmlua19jb3VudF9mdW4iLCJzaXplc19mdW4iLCJjb21waWxlX2FjYyIsImNvbXBpbGVfYWNjJDAiLCJzZWVkX2dlbiIsImNvbXBpbGVfYWNjJDEiLCJ0ZXN0X2NvdW50X2dlbiIsImNvbXBpbGVfYWNjJDIiLCJzaHJpbmtfY291bnRfZ2VuIiwiY29tcGlsZV9hY2MkMyIsInNpemVzX2dlbiIsImNyZWF0ZSQyIiwibWFwJDMiLCJpdGVyIiwiZm9sZCQxIiwibWFwX3BvbHkiLCJyZWNvcmQiLCJmb3JfYWxsIiwiZXhpc3RzIiwidG9fbGlzdCIsIml0ZXIkMCIsImZvbGQkMiIsImZvcl9hbGwkMCIsImV4aXN0cyQwIiwidG9fbGlzdCQwIiwibWFwJDQiLCJzZXRfYWxsX211dGFibGVfZmllbGRzIiwic2V4cF9vZl90JDciLCJzaXplc18wMTAiLCJzaHJpbmtfY291bnRfMDA4IiwidGVzdF9jb3VudF8wMDYiLCJzZWVkXzAwNCIsInN1ZmZpeCIsInByZWZpeCIsInByZWZpeCQwIiwiYm5kc18wMDMiLCJzdWZmaXgkMCIsImFyZ18wMTEiLCJibmRzXzAwMyQwIiwiYXJnXzAwOSIsImJuZHNfMDAzJDEiLCJhcmdfMDA3IiwiYm5kc18wMDMkMiIsImFyZ18wMDUiLCJibmRzXzAwMyQzIiwiZGVmYXVsdF9jb25maWciLCJsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUiLCJ3aXRoX3NhbXBsZSIsImdlbmVyYXRvciIsImNvbmZpZyIsImV4YW1wbGVzIiwic3RyaW5nIiwibnVtYmVyX29mX3NpemVfdmFsdWVzIiwicmVtYWluaW5nX3NpemVzIiwic2VxdWVuY2UiLCJyZXN1bHQkMSIsImlucHV0IiwiZXJyb3IiLCJlcnJvciQxIiwiaW5wdXQkMCIsInNocmlua19jb3VudCQxIiwiYWx0ZXJuYXRlcyQyIiwiYWx0ZXJuYXRlcyIsImFsdGVybmF0ZXMkMCIsImFsdGVybmF0ZSIsImVycm9yJDAiLCJhbHRlcm5hdGVzJDEiLCJydW4iLCJNIiwiZiQwIiwid2l0aF9zYW1wbGVfZXhuIiwicnVuX2V4biIsInRlc3RhYmxlIiwidW5tYXAiLCJvZl9oYXNoX2ZvbGQiLCJvZl9sYXp5JDEiLCJmaXhlZF9wb2ludCQxIiwid3JhcCIsImludDYzJDAiLCJzZXhwJDEiLCJiaWdzdHJpbmckMCIsImZsb2F0MzJfdmVjJDAiLCJmbG9hdDY0X3ZlYyQxIiwiZmxvYXQzMl9tYXQkMCIsImZsb2F0NjRfbWF0JDEiLCJlaXRoZXIkMSIsInJlc3VsdCQyIiwiYm90aCQxIiwiaGFzaCQwIiwiaGFzaCQxIiwiZm4kMCIsIm1hcF90cmVlIiwia2V5X29icyIsImRhdGFfb2JzIiwic2V0X3RyZWUiLCJlbHRfb2JzIiwibWFwX3QkMCIsInNldF90JDAiXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZV9xdWlja2NoZWNrL3Rlc3QubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZV9xdWlja2NoZWNrL2JpZ2FycmF5X2hlbHBlcnMubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyMC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlX3F1aWNrY2hlY2svZ2VuZXJhdG9yLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL29jYW1sL2ludDY0Lm1saSIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iYXNlX3F1aWNrY2hlY2svc2hyaW5rZXIubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyLm1sIl0sIm1hcHBpbmdzIjoiOzs7OztJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTBCT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNyQkQsdUNBRXNCO0lBRnRCO2FBU0FFLE1B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QixTQU1NQyxRQUFRQyxlQUNpRDtJQWhFdkQsU0FtRVJJLFFBQU1GO01BQVUsMEJBQU0sT0E1RnRCdEIsTUFzRkFxQixTQU1NQyxjQUFrRTtJQW5FaEU7Ozs7Ozs7Ozs7O09BWFJqQjs7OztPQUtBQzs7Ozs7O09BcUJBUTtPQWJBRjtPQU9BQztPQWRBTjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQTZDQU07T0FtQkFNO09BSUFDO09BVkFOO09BSUFHO09BckZBcEI7T0FEQUQ7T0FJQUc7T0FGQUQ7OztJQXVCUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5pbmNsdWRlIFRlc3RfaW50ZlxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIG1vZHVsZSBTZWVkID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTm9uZGV0ZXJtaW5pc3RpY1xuICAgICAgfCBEZXRlcm1pbmlzdGljIG9mIHN0cmluZ1xuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIG1vZHVsZSBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgc2VxdWVuY2UgPVxuICAgICAgbGV0IHByZWZpeCwgc3VmZml4ID0gU2VxdWVuY2Uuc3BsaXRfbiBzZXF1ZW5jZSAxMDAgaW5cbiAgICAgIGxldCBwcmVmaXggPSBMaXN0Lm1hcCBwcmVmaXggfmY6c2V4cF9vZl9lbHQgaW5cbiAgICAgIGxldCBzdWZmaXggPVxuICAgICAgICBtYXRjaCBTZXF1ZW5jZS5pc19lbXB0eSBzdWZmaXggd2l0aFxuICAgICAgICB8IHRydWUgLT4gW11cbiAgICAgICAgfCBmYWxzZSAtPiBbIFslbWVzc2FnZSBcIi4uLlwiXSBdXG4gICAgICBpblxuICAgICAgU2V4cC5MaXN0IChwcmVmaXggQCBzdWZmaXgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IHNlZWQgOiBTZWVkLnRcbiAgICA7IHRlc3RfY291bnQgOiBpbnRcbiAgICA7IHNocmlua19jb3VudCA6IGludFxuICAgIDsgc2l6ZXMgOiBpbnQgUG90ZW50aWFsbHlfaW5maW5pdGVfc2VxdWVuY2UudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuZW5kXG5cbmxldCBkZWZhdWx0X2NvbmZpZyA6IENvbmZpZy50ID1cbiAgeyBzZWVkID0gRGV0ZXJtaW5pc3RpYyBcImFuIGFyYml0cmFyeSBidXQgZGV0ZXJtaW5pc3RpYyBzdHJpbmdcIlxuICA7IHRlc3RfY291bnQgPSAxMF8wMDBcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIExheW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBCaWdhcnJheS5sYXlvdXRcblxuICBsZXQgb2Zmc2V0IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICB8IEJpZ2FycmF5LkZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICB8IEJpZ2FycmF5LkNfbGF5b3V0IC0+IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkxLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkxLmRpbSB0IC0gMSBkb1xuICAgICAgZiAoaSArIG9mZnNldCkgdC57aSArIG9mZnNldH1cbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0gfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSAoXyA6IGVsdCkgLT4gdC57aX0gPC0gZiBpKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IGluaXQgOj0gZiAhaW5pdCB0LntpfSk7XG4gICAgIWluaXRcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTEuZGltIHQpIH5mOihmdW4gaSAtPiB0LntpICsgb2Zmc2V0fSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5MS5kaW0gdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBCaWdhcnJheS5BcnJheTIudFxuXG4gIGxldCBpdGVyaSB0IH5mID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIGZvciBpID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMSB0IC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQgLSAxIGRvXG4gICAgICAgIGYgKGkgKyBvZmZzZXQpIChqICsgb2Zmc2V0KSB0LntpICsgb2Zmc2V0LCBqICsgb2Zmc2V0fVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaW5pdCAodHlwZSBlbHQpIChraW5kIDogKGVsdCwgXykgQmlnYXJyYXkua2luZCkgbGF5b3V0IGRpbTEgZGltMiB+ZiA9XG4gICAgbGV0IHQgPSBCaWdhcnJheS5BcnJheTIuY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIGogKF8gOiBlbHQpIC0+IHQue2ksIGp9IDwtIGYgaSBqKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIChfIDogaW50KSAoXyA6IGludCkgZWx0IC0+IGluaXQgOj0gZiAhaW5pdCBlbHQpO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTIubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgfmY6KGZ1biBpIC0+XG4gICAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTIuZGltMiB0KSB+ZjooZnVuIGogLT4gdC57aSArIG9mZnNldCwgaiArIG9mZnNldH0pKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgX3NleHBfb2ZfcGFjayBfc2V4cF9vZl9sYXlvdXQgdCA9XG4gICAgWyVzZXhwICh0b19hcnJheSB0IDogZWx0IGFycmF5IGFycmF5KV1cbiAgOztcblxuICBsZXQgaGFzaF9mb2xkIGhhc2hfZm9sZF9lbHQgc3RhdGUgdCA9XG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgaW5cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTIuZGltMiB0KSBpblxuICAgIGZvbGQgdCB+aW5pdDpzdGF0ZSB+ZjpoYXNoX2ZvbGRfZWx0XG4gIDs7XG5lbmRcbiIsIm9wZW4hIEJhc2VcblxudHlwZSAnYSB0ID0gJ2EgLT4gc2l6ZTppbnQgLT4gaGFzaDpIYXNoLnN0YXRlIC0+IEhhc2guc3RhdGVcblxubGV0IGNyZWF0ZSBmIDogXyB0ID0gZlxuXG5sZXQgb2JzZXJ2ZSAodCA6IF8gdCkgeCB+c2l6ZSB+aGFzaCA9XG4gIGlmIHNpemUgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suT2JzZXJ2ZXIub2JzZXJ2ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gIGVsc2UgdCB4IH5zaXplIH5oYXNoXG47O1xuXG5sZXQgb3BhcXVlIF8gfnNpemU6XyB+aGFzaCA9IGhhc2hcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIFQgOiBzaWdcbiAgdHlwZSArJ2EgdFxuXG4gIHZhbCBjcmVhdGUgOiAoc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIGdlbmVyYXRlIDogJ2EgdCAtPiBzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYSkgU3RhZ2VkLnRcblxuICBsZXQgY3JlYXRlIGYgOiBfIHQgPSBTdGFnZWQuc3RhZ2UgZlxuXG4gIGxldCBnZW5lcmF0ZSAodCA6IF8gdCkgfnNpemUgfnJhbmRvbSA9XG4gICAgaWYgc2l6ZSA8IDBcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5nZW5lcmF0ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gICAgZWxzZSBTdGFnZWQudW5zdGFnZSB0IH5zaXplIH5yYW5kb21cbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IHNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tOl8gLT4gc2l6ZSlcblxubGV0IGZuIGRvbSBybmcgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnNwbGl0IHJhbmRvbSBpblxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgaGFzaCA9IE9ic2VydmVyMC5vYnNlcnZlIGRvbSB4IH5zaXplIH5oYXNoOihIYXNoLmFsbG9jICgpKSBpblxuICAgICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLmNvcHkgcmFuZG9tIGluXG4gICAgICBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5wZXJ0dXJiIHJhbmRvbSAoSGFzaC5nZXRfaGFzaF92YWx1ZSBoYXNoKTtcbiAgICAgIGdlbmVyYXRlIHJuZyB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IHdpdGhfc2l6ZSB0IH5zaXplID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSlcblxubGV0IHBlcnR1cmIgdCBzYWx0ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnBlcnR1cmIgcmFuZG9tIHNhbHQ7XG4gICAgZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB+c2l6ZSB+cmFuZG9tID1cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgfCBTb21lIHkgLT4geVxuICAgIHwgTm9uZSAtPiBsb29wIH5zaXplOihzaXplICsgMSkgfnJhbmRvbVxuICBpblxuICBjcmVhdGUgbG9vcFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxubGV0IHJldHVybiB4ID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tOl8gLT4geClcbmxldCBtYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gZiAoZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFwcGx5IHRmIHR4ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCBmID0gZ2VuZXJhdGUgdGYgfnNpemUgfnJhbmRvbSBpblxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdHggfnNpemUgfnJhbmRvbSBpblxuICAgIGYgeClcbjs7XG5cbmxldCBiaW5kIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20gaW5cbiAgICBnZW5lcmF0ZSAoZiB4KSB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGFsbCBsaXN0ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBMaXN0Lm1hcCBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFsbF91bml0IGxpc3QgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QuaXRlciBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcbjs7XG5cbm1vZHVsZSBGb3JfYXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBhcHBseSA9IGFwcGx5XG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGJvdGggPSBGb3JfYXBwbGljYXRpdmUuYm90aFxubGV0IG1hcDIgPSBGb3JfYXBwbGljYXRpdmUubWFwMlxubGV0IG1hcDMgPSBGb3JfYXBwbGljYXRpdmUubWFwM1xuXG5tb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBGb3JfYXBwbGljYXRpdmUuQXBwbGljYXRpdmVfaW5maXhcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW5maXhcblxubW9kdWxlIEZvcl9tb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGlnbm9yZV9tID0gRm9yX21vbmFkLmlnbm9yZV9tXG5sZXQgam9pbiA9IEZvcl9tb25hZC5qb2luXG5cbm1vZHVsZSBNb25hZF9pbmZpeCA9IEZvcl9tb25hZC5Nb25hZF9pbmZpeFxuaW5jbHVkZSBNb25hZF9pbmZpeFxubW9kdWxlIExldF9zeW50YXggPSBGb3JfbW9uYWQuTGV0X3N5bnRheFxub3BlbiBMZXRfc3ludGF4XG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxpc3RcbiAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2ZfbGlzdDogZW1wdHkgbGlzdFwiXTtcbiAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gIGxldCBsbyA9IDAgaW5cbiAgbGV0IGhpID0gQXJyYXkubGVuZ3RoIGFycmF5IC0gMSBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbyB+aGkgaW5cbiAgICBhcnJheS4oaW5kZXgpKVxuOztcblxubGV0IHVuaW9uIGxpc3QgPSBqb2luIChvZl9saXN0IGxpc3QpXG5cbmxldCBvZl93ZWlnaHRlZF9saXN0IGFsaXN0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSBhbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgd2VpZ2h0cywgdmFsdWVzID0gTGlzdC51bnppcCBhbGlzdCBpblxuICBsZXQgdmFsdWVfYXJyYXkgPSBBcnJheS5vZl9saXN0IHZhbHVlcyBpblxuICBsZXQgdG90YWxfd2VpZ2h0LCBjdW11bGF0aXZlX3dlaWdodF9hcnJheSA9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHZhbHVlX2FycmF5KSB+ZjooZnVuIF8gLT4gMC4pIGluXG4gICAgbGV0IHN1bSA9XG4gICAgICBMaXN0LmZvbGRpIHdlaWdodHMgfmluaXQ6MC4gfmY6KGZ1biBpbmRleCBhY2Mgd2VpZ2h0IC0+XG4gICAgICAgIGlmIG5vdCAoRmxvYXQuaXNfZmluaXRlIHdlaWdodClcbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5vdCBmaW5pdGVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBpZiBGbG9hdC4oIDwgKSB3ZWlnaHQgMC5cbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5lZ2F0aXZlXCJcbiAgICAgICAgICAgICAgICAod2VpZ2h0IDogZmxvYXQpXTtcbiAgICAgICAgbGV0IGN1bXVsYXRpdmUgPSBhY2MgKy4gd2VpZ2h0IGluXG4gICAgICAgIGFycmF5LihpbmRleCkgPC0gY3VtdWxhdGl2ZTtcbiAgICAgICAgY3VtdWxhdGl2ZSlcbiAgICBpblxuICAgIGlmIEZsb2F0LiggPD0gKSBzdW0gMC5cbiAgICB0aGVuXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogdG90YWwgd2VpZ2h0IGlzIHplcm9cIl07XG4gICAgc3VtLCBhcnJheVxuICBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgY2hvaWNlID0gU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzowLiB+aGk6dG90YWxfd2VpZ2h0IGluXG4gICAgbWF0Y2hcbiAgICAgIEFycmF5LmJpbmFyeV9zZWFyY2hcbiAgICAgICAgY3VtdWxhdGl2ZV93ZWlnaHRfYXJyYXlcbiAgICAgICAgfmNvbXBhcmU6RmxvYXQuY29tcGFyZVxuICAgICAgICBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgICAgIGNob2ljZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgaW5kZXggLT4gdmFsdWVfYXJyYXkuKGluZGV4KVxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgd2VpZ2h0ZWRfdW5pb24gYWxpc3QgPSBqb2luIChvZl93ZWlnaHRlZF9saXN0IGFsaXN0KVxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBnZW5lcmF0ZSAoZm9yY2UgbGF6eV90KSB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2ZfZ2VuZXJhdG9yID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9nZW5lcmF0b3IgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgZm9yY2UgbGF6eV90XG47O1xuXG5sZXQgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0IHJlY19saXN0ID1cbiAgICAgIExpc3QubWFwIChmIHNlbGYpIH5mOihmdW4gKHcsIHQpIC0+XG4gICAgICAgICggd1xuICAgICAgICAsIGxldCViaW5kIG4gPSBzaXplIGluXG4gICAgICAgICAgd2l0aF9zaXplIH5zaXplOihuIC0gMSkgdCApKVxuICAgIGluXG4gICAgaWYgTGlzdC5pc19lbXB0eSBub25yZWNfbGlzdCB8fCBMaXN0LmlzX2VtcHR5IHJlY19saXN0XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iud2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uOiBsaXN0cyBtdXN0IGJlIG5vbi1lbXB0eVwiXTtcbiAgICBsZXQgbm9ucmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIG5vbnJlY19saXN0IGluXG4gICAgbGV0IHJlY19nZW4gPSB3ZWlnaHRlZF91bmlvbiAobm9ucmVjX2xpc3QgQCByZWNfbGlzdCkgaW5cbiAgICBtYXRjaCViaW5kIHNpemUgd2l0aFxuICAgIHwgMCAtPiBub25yZWNfZ2VuXG4gICAgfCBfIC0+IHJlY19nZW4pXG47O1xuXG5sZXQgcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgbGV0IHdlaWdodGVkIGxpc3QgPSBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gdCAtPiAxLiwgdCkgaW5cbiAgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uICh3ZWlnaHRlZCBub25yZWNfbGlzdCkgfmY6KGZ1biBzZWxmIC0+IHdlaWdodGVkIChmIHNlbGYpKVxuOztcblxubGV0IHNpemVzID8obWluX2xlbmd0aCA9IDApID8obWF4X2xlbmd0aCA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGFzc2VydCAobWluX2xlbmd0aCA8PSBtYXhfbGVuZ3RoKTtcbiAgICBsZXQgdXBwZXJfYm91bmQgPSBtaW5fbGVuZ3RoICsgc2l6ZSBpblxuICAgIGxldCBtYXhfbGVuZ3RoID1cbiAgICAgIGlmIHVwcGVyX2JvdW5kID49IG1pbl9sZW5ndGggKCogZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdyAqKVxuICAgICAgdGhlbiBtaW4gbWF4X2xlbmd0aCB1cHBlcl9ib3VuZFxuICAgICAgZWxzZSBtYXhfbGVuZ3RoXG4gICAgaW5cbiAgICAoKiBwaWNrIGEgbGVuZ3RoLCB3ZWlnaHRlZCBsb3cgc28gdGhhdCBtb3N0IG9mIHRoZSBzaXplIGlzIHNwZW50IG9uIGVsZW1lbnRzICopXG4gICAgbGV0IGxlbiA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOm1pbl9sZW5ndGggfmhpOm1heF9sZW5ndGggaW5cbiAgICAoKiBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgcmV0dXJuIGFuIGVtcHR5IGFycmF5LCBvdGhlcndpc2UgcmV0dXJuIGEgbm9uLWVtcHR5IGFycmF5XG4gICAgICAgd2l0aCB0aGUgc2l6ZSBkaXN0cmlidXRlZCBhbW9uZyB0aGUgZWxlbWVudHMgKilcbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNpemVzID0gQXJyYXkuaW5pdCBsZW4gfmY6KGZ1biBfIC0+IDApIGluXG4gICAgICBsZXQgcmVtYWluaW5nID0gc2l6ZSAtIChsZW4gLSBtaW5fbGVuZ3RoKSBpblxuICAgICAgbGV0IG1heF9pbmRleCA9IGxlbiAtIDEgaW5cbiAgICAgIGZvciBfID0gMSB0byByZW1haW5pbmcgZG9cbiAgICAgICAgKCogcGljayBhbiBpbmRleCwgd2VpZ2h0ZWQgbG93IHNvIHRoYXQgd2Ugc2VlIHVuYmFsYW5jZWQgZGlzdHJpYnV0aW9ucyBvZnRlbiAqKVxuICAgICAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzowIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgc2l6ZXMuKGluZGV4KSA8LSBzaXplcy4oaW5kZXgpICsgMVxuICAgICAgZG9uZTtcbiAgICAgICgqIHBlcm11dGUgdGhlIGFycmF5IHNvIHRoYXQgbm8gaW5kZXggaXMgZmF2b3JlZCBvdmVyIGFub3RoZXIgKilcbiAgICAgIGZvciBpID0gMCB0byBtYXhfaW5kZXggLSAxIGRvXG4gICAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86aSB+aGk6bWF4X2luZGV4IGluXG4gICAgICAgIEFycmF5LnN3YXAgc2l6ZXMgaSBqXG4gICAgICBkb25lO1xuICAgICAgYXNzZXJ0IChBcnJheS5zdW0gKG1vZHVsZSBJbnQpIHNpemVzIH5mOkZuLmlkICsgKGxlbiAtIG1pbl9sZW5ndGgpID0gc2l6ZSk7XG4gICAgICBBcnJheS50b19saXN0IHNpemVzKSlcbjs7XG5cbmxldCB1bml0ID0gcmV0dXJuICgpXG5sZXQgYm9vbCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBTcGxpdHRhYmxlX3JhbmRvbS5ib29sIHJhbmRvbSlcbmxldCBvcHRpb24gdmFsdWVfdCA9IHVuaW9uIFsgcmV0dXJuIE5vbmU7IG1hcCB2YWx1ZV90IH5mOk9wdGlvbi5yZXR1cm4gXVxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9IHVuaW9uIFsgbWFwIGZzdF90IH5mOkVpdGhlci5maXJzdDsgbWFwIHNuZF90IH5mOkVpdGhlci5zZWNvbmQgXVxuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgfCBTZWNvbmQgZXJyIC0+IEVycm9yIGVycilcbjs7XG5cbmxldCBsaXN0X2dlbmVyaWMgP21pbl9sZW5ndGggP21heF9sZW5ndGggZWx0X2dlbiA9XG4gIGxldCViaW5kIHNpemVzID0gc2l6ZXMgP21pbl9sZW5ndGggP21heF9sZW5ndGggKCkgaW5cbiAgTGlzdC5tYXAgc2l6ZXMgfmY6KGZ1biBzaXplIC0+IHdpdGhfc2l6ZSB+c2l6ZSBlbHRfZ2VuKSB8PiBhbGxcbjs7XG5cbmxldCBsaXN0IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgZWx0X2dlblxubGV0IGxpc3Rfbm9uX2VtcHR5IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgfm1pbl9sZW5ndGg6MSBlbHRfZ2VuXG5cbmxldCBsaXN0X3dpdGhfbGVuZ3RoIGVsdF9nZW4gfmxlbmd0aCA9XG4gIGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDpsZW5ndGggfm1heF9sZW5ndGg6bGVuZ3RoIGVsdF9nZW5cbjs7XG5cbmxldCBsaXN0X2ZpbHRlcmVkIGVsdHMgPVxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgbGVuZ3RoX29mX2lucHV0ID0gQXJyYXkubGVuZ3RoIGVsdHMgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGxlbmd0aF9vZl9vdXRwdXQgPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzowIH5oaTpsZW5ndGhfb2ZfaW5wdXQgaW5cbiAgICBsZXQgaW5kaWNlcyA9IEFycmF5LmluaXQgbGVuZ3RoX29mX2lucHV0IH5mOkZuLmlkIGluXG4gICAgKCogQ2hvb3NlIFtsZW5ndGhfb2Zfb3V0cHV0XSByYW5kb20gdmFsdWVzIGluIHRoZSBwcmVmaXggb2YgW2luZGljZXNdLiAqKVxuICAgIGZvciBpID0gMCB0byBsZW5ndGhfb2Zfb3V0cHV0IC0gMSBkb1xuICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaToobGVuZ3RoX29mX2lucHV0IC0gMSkgaW5cbiAgICAgIEFycmF5LnN3YXAgaW5kaWNlcyBpIGpcbiAgICBkb25lO1xuICAgICgqIFNvcnQgdGhlIGNob3NlbiBpbmRpY2VzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byByZW9yZGVyIHRoZW0uICopXG4gICAgQXJyYXkuc29ydCBpbmRpY2VzIH5wb3M6MCB+bGVuOmxlbmd0aF9vZl9vdXRwdXQgfmNvbXBhcmU6SW50LmNvbXBhcmU7XG4gICAgKCogUmV0dXJuIHRoZSBjaG9zZW4gZWxlbWVudHMuICopXG4gICAgTGlzdC5pbml0IGxlbmd0aF9vZl9vdXRwdXQgfmY6KGZ1biBpIC0+IGVsdHMuKGluZGljZXMuKGkpKSkpXG47O1xuXG5sZXQgbGlzdF9wZXJtdXRhdGlvbnMgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBhcnJheSA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmkgaW5cbiAgICAgIEFycmF5LnN3YXAgYXJyYXkgaSBqXG4gICAgZG9uZTtcbiAgICBBcnJheS50b19saXN0IGFycmF5KVxuOztcblxubGV0IGFycmF5IHQgPSBtYXAgKGxpc3QgdCkgfmY6QXJyYXkub2ZfbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbFxuXG5sZXQgY2hhcl91bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOihDaGFyLnRvX2ludCBsbykgfmhpOihDaGFyLnRvX2ludCBoaSlcbiAgICB8PiBDaGFyLnVuc2FmZV9vZl9pbnQpXG47O1xuXG5sZXQgY2hhcl91cHBlcmNhc2UgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICdBJyAnWidcbmxldCBjaGFyX2xvd2VyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ2EnICd6J1xubGV0IGNoYXJfZGlnaXQgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcwJyAnOSdcbmxldCBjaGFyX3ByaW50X3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcgJyAnfidcbmxldCBjaGFyX3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIENoYXIubWluX3ZhbHVlIENoYXIubWF4X3ZhbHVlXG5sZXQgY2hhcl9hbHBoYSA9IHVuaW9uIFsgY2hhcl9sb3dlcmNhc2U7IGNoYXJfdXBwZXJjYXNlIF1cblxubGV0IGNoYXJfYWxwaGFudW0gPVxuICB3ZWlnaHRlZF91bmlvblxuICAgICgqIE1vc3QgcGVvcGxlIHByb2JhYmx5IGV4cGVjdCB0aGlzIHRvIGJlIGEgdW5pZm9ybSBkaXN0cmlidXRpb24sIG5vdCB3ZWlnaHRlZFxuICAgICAgIHRvd2FyZCBkaWdpdHMgbGlrZSB3ZSB3b3VsZCBnZXQgd2l0aCBbdW5pb25dIChzaW5jZSB0aGVyZSBhcmUgZmV3ZXIgZGlnaXRzIHRoYW5cbiAgICAgICBsZXR0ZXJzKS4gKilcbiAgICBbIDUyLiwgY2hhcl9hbHBoYTsgMTAuLCBjaGFyX2RpZ2l0IF1cbjs7XG5cbmxldCBjaGFyX3doaXRlc3BhY2UgPSBvZl9saXN0IChMaXN0LmZpbHRlciBDaGFyLmFsbCB+ZjpDaGFyLmlzX3doaXRlc3BhY2UpXG5sZXQgY2hhcl9wcmludCA9IHdlaWdodGVkX3VuaW9uIFsgMTAuLCBjaGFyX2FscGhhbnVtOyAxLiwgY2hhcl9wcmludF91bmlmb3JtIF1cblxubGV0IGNoYXIgPVxuICB3ZWlnaHRlZF91bmlvblxuICAgIFsgMTAwLiwgY2hhcl9wcmludFxuICAgIDsgMTAuLCBjaGFyX3VuaWZvcm1cbiAgICA7IDEuLCByZXR1cm4gQ2hhci5taW5fdmFsdWVcbiAgICA7IDEuLCByZXR1cm4gQ2hhci5tYXhfdmFsdWVcbiAgICBdXG47O1xuXG4oKiBQcm9kdWNlcyBhIG51bWJlciBmcm9tIDAgb3IgMSB0byBzaXplICsgMSwgd2VpZ2h0ZWQgaGlnaC4gV2UgaGF2ZSBmb3VuZCB0aGlzXG4gICBkaXN0cmlidXRpb24gZW1waXJpY2FsbHkgdXNlZnVsIGZvciBzdHJpbmcgbGVuZ3Rocy4gKilcbmxldCBzbWFsbF9pbnQgfmFsbG93X3plcm8gPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGxvd2VyX2JvdW5kID0gaWYgYWxsb3dfemVybyB0aGVuIDAgZWxzZSAxIGluXG4gICAgbGV0IHVwcGVyX2JvdW5kID0gc2l6ZSArIDEgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfbG93ID1cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOih1cHBlcl9ib3VuZCAtIGxvd2VyX2JvdW5kKVxuICAgIGluXG4gICAgbGV0IHdlaWdodGVkX2hpZ2ggPSB1cHBlcl9ib3VuZCAtIHdlaWdodGVkX2xvdyBpblxuICAgIHdlaWdodGVkX2hpZ2gpXG47O1xuXG5sZXQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgPSBzbWFsbF9pbnQgfmFsbG93X3plcm86dHJ1ZVxubGV0IHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzpmYWxzZVxuXG5tb2R1bGUgdHlwZSBJbnRfd2l0aF9yYW5kb20gPSBzaWdcbiAgaW5jbHVkZSBJbnQuU1xuXG4gIHZhbCB1bmlmb3JtIDogU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiBsbzp0IC0+IGhpOnQgLT4gdFxuICB2YWwgbG9nX3VuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG5lbmRcblxubW9kdWxlIEZvcl9pbnRlZ2VyIChJbnRlZ2VyIDogSW50X3dpdGhfcmFuZG9tKSA9IHN0cnVjdFxuICBsZXQgdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLnVuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IGxvZ191bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IEludGVnZXIubG9nX3VuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IG5vbl91bmlmb3JtIGYgbG8gaGkgPVxuICAgIHdlaWdodGVkX3VuaW9uIFsgMC4wNSwgcmV0dXJuIGxvOyAwLjA1LCByZXR1cm4gaGk7IDAuOSwgZiBsbyBoaSBdXG4gIDs7XG5cbiAgbGV0IGluY2x1c2l2ZSA9IG5vbl91bmlmb3JtIHVuaWZvcm1faW5jbHVzaXZlXG4gIGxldCBsb2dfaW5jbHVzaXZlID0gbm9uX3VuaWZvcm0gbG9nX3VuaWZvcm1faW5jbHVzaXZlXG4gIGxldCB1bmlmb3JtX2FsbCA9IHVuaWZvcm1faW5jbHVzaXZlIEludGVnZXIubWluX3ZhbHVlIEludGVnZXIubWF4X3ZhbHVlXG5cbiAgbGV0IGFsbCA9XG4gICAgWyVtYXBcbiAgICAgIGxldCBuZWdhdGl2ZSA9IGJvb2xcbiAgICAgIGFuZCBtYWduaXR1ZGUgPSBsb2dfaW5jbHVzaXZlIEludGVnZXIuemVybyBJbnRlZ2VyLm1heF92YWx1ZSBpblxuICAgICAgaWYgbmVnYXRpdmUgdGhlbiBJbnRlZ2VyLmJpdF9ub3QgbWFnbml0dWRlIGVsc2UgbWFnbml0dWRlXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGb3JfaW50ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludFxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludFxuICBlbmQpXG5cbmxldCBpbnQgPSBGb3JfaW50LmFsbFxubGV0IGludF91bmlmb3JtID0gRm9yX2ludC51bmlmb3JtX2FsbFxubGV0IGludF9pbmNsdXNpdmUgPSBGb3JfaW50LmluY2x1c2l2ZVxubGV0IGludF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZVxubGV0IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDMyID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50MzJcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50MzJcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQzMlxuICBlbmQpXG5cbmxldCBpbnQzMiA9IEZvcl9pbnQzMi5hbGxcbmxldCBpbnQzMl91bmlmb3JtID0gRm9yX2ludDMyLnVuaWZvcm1fYWxsXG5sZXQgaW50MzJfaW5jbHVzaXZlID0gRm9yX2ludDMyLmluY2x1c2l2ZVxubGV0IGludDMyX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfaW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDYzID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjNcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2M1xuICBlbmQpXG5cbmxldCBpbnQ2MyA9IEZvcl9pbnQ2My5hbGxcbmxldCBpbnQ2M191bmlmb3JtID0gRm9yX2ludDYzLnVuaWZvcm1fYWxsXG5sZXQgaW50NjNfaW5jbHVzaXZlID0gRm9yX2ludDYzLmluY2x1c2l2ZVxubGV0IGludDYzX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDY0ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2NFxuICBlbmQpXG5cbmxldCBpbnQ2NCA9IEZvcl9pbnQ2NC5hbGxcbmxldCBpbnQ2NF91bmlmb3JtID0gRm9yX2ludDY0LnVuaWZvcm1fYWxsXG5sZXQgaW50NjRfaW5jbHVzaXZlID0gRm9yX2ludDY0LmluY2x1c2l2ZVxubGV0IGludDY0X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX25hdGl2ZWludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE5hdGl2ZWludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5uYXRpdmVpbnRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5uYXRpdmVpbnRcbiAgZW5kKVxuXG5sZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5hbGxcbmxldCBuYXRpdmVpbnRfdW5pZm9ybSA9IEZvcl9uYXRpdmVpbnQudW5pZm9ybV9hbGxcbmxldCBuYXRpdmVpbnRfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmxvZ19pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBmbG9hdF96ZXJvX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCAwLlxubGV0IGZsb2F0X3plcm9fbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIDAuXG5cbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID1cbiAgRmxvYXQub25lX3VscCBgRG93biBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gRmxvYXQubWF4X2Zpbml0ZV92YWx1ZVxubGV0IGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X2luZl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQuaW5maW5pdHlcbmxldCBmbG9hdF9pbmZfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfbmFuX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5uYW5cbmxldCBmbG9hdF9taW5fbmFuX21hbnRpc3NhID0gSW50NjMuc3VjYyBmbG9hdF9pbmZfbWFudGlzc2FcbmxldCBmbG9hdF9tYXhfbmFuX21hbnRpc3NhID0gZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYVxubGV0IGZsb2F0X251bV9tYW50aXNzYV9iaXRzID0gNTJcblxuKCogV2Ugd2VpZ2h0IG1hbnRpc3NhcyBzbyB0aGF0IFwiaW50ZWdlci1saWtlXCIgdmFsdWVzLCBhbmQgdmFsdWVzIHdpdGggb25seSBhIGZldyBkaWdpdHNcbiAgIHBhc3QgdGhlIGRlY2ltYWwsIGFyZSByZWFzb25hYmx5IGNvbW1vbi4gKilcbmxldCBmbG9hdF9ub3JtYWxfbWFudGlzc2EgPVxuICBsZXQlYmluZCBudW1fYml0cyA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmUgMCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBpblxuICBsZXQlbWFwIGJpdHMgPVxuICAgIEZvcl9pbnQ2My5pbmNsdXNpdmUgSW50NjMuemVybyAoSW50NjMucHJlZCAoSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHMpKVxuICBpblxuICBJbnQ2My5zaGlmdF9sZWZ0IGJpdHMgKEludC4oIC0gKSBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBudW1fYml0cylcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9sb3cgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQlbWFwIG9mZnNldCA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZSAwIChJbnQuKCAtICkgdXBwZXJfYm91bmQgbG93ZXJfYm91bmQpIGluXG4gIEludC4oICsgKSBsb3dlcl9ib3VuZCBvZmZzZXRcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCAtICkgdXBwZXJfYm91bmQgb2Zmc2V0XG47O1xuXG4oKiBXZSB3ZWlnaHQgZXhwb25lbnRzIHN1Y2ggdGhhdCB2YWx1ZXMgbmVhciAxIGFyZSBtb3JlIGxpa2VseS4gKilcbmxldCBmbG9hdF9leHBvbmVudCA9XG4gIGxldCBtaWRwb2ludCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMS4gaW5cbiAgdW5pb25cbiAgICBbIGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2hpZ2ggZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCBtaWRwb2ludFxuICAgIDsgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IG1pZHBvaW50IGZsb2F0X21heF9ub3JtYWxfZXhwb25lbnRcbiAgICBdXG47O1xuXG5sZXQgZmxvYXRfemVybyA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF96ZXJvX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X3plcm9fbWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9zdWJub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSByZXR1cm4gZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9XG4gICAgRm9yX2ludDYzLmxvZ19pbmNsdXNpdmUgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhXG4gIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25vcm1hbCA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IGZsb2F0X2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9IGZsb2F0X25vcm1hbF9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9pbmZpbml0ZSA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF9pbmZfZXhwb25lbnRcbiAgICB+bWFudGlzc2E6ZmxvYXRfaW5mX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfbmFuID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X25hbl9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBGb3JfaW50NjMuaW5jbHVzaXZlIGZsb2F0X21pbl9uYW5fbWFudGlzc2EgZmxvYXRfbWF4X25hbl9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9vZl9jbGFzcyBjID1cbiAgbWF0Y2ggKGMgOiBGbG9hdC5DbGFzcy50KSB3aXRoXG4gIHwgWmVybyAtPiBmbG9hdF96ZXJvXG4gIHwgU3Vibm9ybWFsIC0+IGZsb2F0X3N1Ym5vcm1hbFxuICB8IE5vcm1hbCAtPiBmbG9hdF9ub3JtYWxcbiAgfCBJbmZpbml0ZSAtPiBmbG9hdF9pbmZpbml0ZVxuICB8IE5hbiAtPiBmbG9hdF9uYW5cbjs7XG5cbmxldCBmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gMS5cbiAgfCBTdWJub3JtYWwgLT4gMTAuXG4gIHwgTm9ybWFsIC0+IDEwMC5cbiAgfCBJbmZpbml0ZSAtPiAxLlxuICB8IE5hbiAtPiAxLlxuOztcblxubGV0IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgZmlsdGVyID1cbiAgTGlzdC5maWx0ZXJfbWFwIEZsb2F0LkNsYXNzLmFsbCB+ZjooZnVuIGMgLT5cbiAgICBpZiBmaWx0ZXIgYyB0aGVuIFNvbWUgKGZsb2F0X3dlaWdodF9vZl9jbGFzcyBjLCBmbG9hdF9vZl9jbGFzcyBjKSBlbHNlIE5vbmUpXG4gIHw+IHdlaWdodGVkX3VuaW9uXG47O1xuXG5sZXQgZmxvYXRfZmluaXRlID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgLT4gdHJ1ZVxuICAgIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfd2l0aG91dF9uYW4gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgWmVybyB8IFN1Ym5vcm1hbCB8IE5vcm1hbCB8IEluZmluaXRlIC0+IHRydWVcbiAgICB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdCA9IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1biBfIC0+IHRydWUpXG5cbmxldCBmbG9hdF9maW5pdGVfbm9uX3plcm8gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IFplcm8gfCBJbmZpbml0ZSB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X3N0cmljdGx5X25lZ2F0aXZlID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlX25vbl96ZXJvIGluXG4gIH4tLihGbG9hdC5hYnMgdClcbjs7XG5cbmxldCBmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlIGluXG4gIEZsb2F0LmFicyB0XG47O1xuXG5sZXQgZmxvYXRfbmVnYXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIGlmIChub3QgKEZsb2F0LmlzX2Zpbml0ZSBsb3dlcl9ib3VuZCkpIHx8IG5vdCAoRmxvYXQuaXNfZmluaXRlIHVwcGVyX2JvdW5kKVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IGJvdW5kcyBhcmUgbm90IGZpbml0ZVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgbGV0IGxvd2VyX2luY2x1c2l2ZSA9IEZsb2F0Lm9uZV91bHAgYFVwIGxvd2VyX2JvdW5kIGluXG4gIGxldCB1cHBlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBEb3duIHVwcGVyX2JvdW5kIGluXG4gIGlmIGxvd2VyX2luY2x1c2l2ZSA+IHVwcGVyX2luY2x1c2l2ZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IHJlcXVlc3RlZCByYW5nZSBpcyBlbXB0eVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzpsb3dlcl9pbmNsdXNpdmUgfmhpOnVwcGVyX2luY2x1c2l2ZSlcbjs7XG5cbmxldCBmbG9hdF9pbmNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBpZiBGbG9hdC5lcXVhbCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICB0aGVuIHJldHVybiBsb3dlcl9ib3VuZFxuICBlbHNlIGlmIEZsb2F0LiggPSApIChGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCkgdXBwZXJfYm91bmRcbiAgdGhlbiB1bmlvbiBbIHJldHVybiBsb3dlcl9ib3VuZDsgcmV0dXJuIHVwcGVyX2JvdW5kIF1cbiAgZWxzZVxuICAgIHdlaWdodGVkX3VuaW9uXG4gICAgICBbIDAuMDUsIHJldHVybiBsb3dlcl9ib3VuZFxuICAgICAgOyAwLjA1LCByZXR1cm4gdXBwZXJfYm91bmRcbiAgICAgIDsgMC45LCBmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICAgICAgXVxuOztcblxubGV0IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoID1cbiAgbGlzdF93aXRoX2xlbmd0aCBjaGFyX2dlbiB+bGVuZ3RoIHw+IG1hcCB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0XG47O1xuXG5sZXQgc3RyaW5nX29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhcl9nZW4gPVxuICBiaW5kIHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZyA9IHN0cmluZ19vZiBjaGFyXG5sZXQgc3RyaW5nX25vbl9lbXB0eSA9IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhclxubGV0IHN0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoID0gc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXIgfmxlbmd0aFxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmdcblxubGV0IHNleHBfb2YgYXRvbSA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCViaW5kIHNpemUgPSBzaXplIGluXG4gICAgKCogY2hvb3NlIGEgbnVtYmVyIHdlaWdodGVkIGxvdyBzbyB3ZSBoYXZlIGEgZGVjcmVhc2luZywgYnV0IG5vdCB2YW5pc2hpbmcsIGNoYW5jZVxuICAgICAgIHRvIGdlbmVyYXRlIGF0b21zIGFzIHNpemUgZ3Jvd3MgKilcbiAgICBtYXRjaCViaW5kIEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgKHNpemUgKyAxKSB3aXRoXG4gICAgKCogZ2VuZXJhdGUgYW4gYXRvbSB1c2luZyB0aGUgZ2l2ZW4gc2l6ZSAqKVxuICAgIHwgMCAtPlxuICAgICAgbGV0JW1hcCBhdG9tID0gYXRvbSBpblxuICAgICAgU2V4cC5BdG9tIGF0b21cbiAgICAoKiByZWx5aW5nIG9uIFtMaXN0Lmdlbl0gdG8gZGlzdHJpYnV0ZSBbc2l6ZV0gb3ZlciBzdWItc2V4cHMgKilcbiAgICB8IF8gLT5cbiAgICAgIGxldCVtYXAgbGlzdCA9IGxpc3Qgc2VsZiBpblxuICAgICAgU2V4cC5MaXN0IGxpc3QpXG47O1xuXG5sZXQgc2V4cCA9IHNleHBfb2Ygc3RyaW5nXG5cbmxldCBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQlYmluZCBrZXlzID0gbGlzdCBrZXlfZ2VuIGluXG4gIGxldCBrZXlzID0gTGlzdC5kZWR1cF9hbmRfc29ydCBrZXlzIH5jb21wYXJlOmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gIGxldCViaW5kIGRhdGEgPSBsaXN0X3dpdGhfbGVuZ3RoIGRhdGFfZ2VuIH5sZW5ndGg6KExpc3QubGVuZ3RoIGtleXMpIGluXG4gIHJldHVybiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgKExpc3QuemlwX2V4biBrZXlzIGRhdGEpKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlbiA9XG4gIG1hcCAobGlzdCBlbHRfZ2VuKSB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9saXN0IH5jb21wYXJhdG9yKVxuOztcblxubGV0IGNvbXBhcmF0b3Jfb2ZfbVxuICAgICAgKHR5cGUgYSBjKVxuICAgICAgKG1vZHVsZSBNIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjKVxuICA9XG4gIE0uY29tcGFyYXRvclxuOztcblxubGV0IG1hcF90X20gbSBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW5cbiAgfD4gbWFwIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IHNldF90X20gbSBlbHRfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW5cbiAgfD4gbWFwIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IGJpZ2FycmF5MSB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JW1hcCBlbHRzID0gbGlzdCB0IGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBkaW0gPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IGRpbSB+ZjooZnVuIGkgLT4gZWx0cy4oaSAtIG9mZnNldCkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gYmlnYXJyYXkxIGNoYXIgQ2hhciBDX2xheW91dFxubGV0IGZsb2F0MzJfdmVjID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X3ZlYyA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbmxldCBiaWdhcnJheTJfZGltID1cbiAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgfCAwIC0+IHJldHVybiAoMCwgMClcbiAgfCBtYXhfdG90YWxfc2l6ZSAtPlxuICAgIGxldCViaW5kIGEgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZV0sIHdlaWdodGVkIGxvdyB0byBnaXZlIHRoZSBvdGhlclxuICAgICAgICAgZGltZW5zaW9uIGEgZ29vZCBjaGFuY2Ugb2YgYmVpbmcgY29tcGFyYXRpdmVseSBoaWdoICopXG4gICAgICBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgbWF4X3RvdGFsX3NpemVcbiAgICBpblxuICAgIGxldCViaW5kIGIgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZSAvIGFdLCB3ZWlnaHRlZCBoaWdoIHRvIHJlYWNoIGNsb3NlIHRvXG4gICAgICAgICBbbWF4X3RvdGFsX3NpemVdIG1vc3Qgb2YgdGhlIHRpbWUgKilcbiAgICAgIGxldCBtYXhfYiA9IG1heF90b3RhbF9zaXplIC8gYSBpblxuICAgICAgbGV0JW1hcCBiX3dlaWdodGVkX2xvdyA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCBtYXhfYiBpblxuICAgICAgbWF4X2IgLSBiX3dlaWdodGVkX2xvd1xuICAgIGluXG4gICAgKCogYXZvaWQgYW55IHNrZXcgb2YgYSB2cyBiIGJ5IHJhbmRvbWx5IHN3YXBwaW5nICopXG4gICAgaWYlbWFwIGJvb2wgdGhlbiBhLCBiIGVsc2UgYiwgYVxuOztcblxubGV0IGJpZ2FycmF5MiB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JWJpbmQgZGltMSwgZGltMiA9IGJpZ2FycmF5Ml9kaW0gaW5cbiAgbGV0JW1hcCBlbHRzID0gbGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTEgKGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0yIHQpIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdF9tYXAgfmY6QXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmluaXQga2luZCBsYXlvdXQgZGltMSBkaW0yIH5mOihmdW4gaSBqIC0+XG4gICAgZWx0cy4oaSAtIG9mZnNldCkuKGogLSBvZmZzZXQpKVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBEZWJ1ZyA9IHN0cnVjdFxuICBsZXQgY292ZXJhZ2VcbiAgICAgICAgKHR5cGUgayBjbXApXG4gICAgICAgIChtb2R1bGUgQ21wIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICAgIHNhbXBsZVxuICAgID1cbiAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICBzYW1wbGVcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBDbXApKVxuICAgICAgfmY6KGZ1biBjb3VudHMgdmFsdWUgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBjb3VudHMgdmFsdWUgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2ICsgMSkpXG4gIDs7XG5cbiAgbGV0IG1vbml0b3IgdCB+ZiA9XG4gICAgbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPlxuICAgICAgZiB2YWx1ZTtcbiAgICAgIHZhbHVlKVxuICA7O1xuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIG9wZXJhdGlvbnMgb24gdGhlIHR5cGUgW2ludDY0XSBvZlxuICAgc2lnbmVkIDY0LWJpdCBpbnRlZ2Vycy4gIFVubGlrZSB0aGUgYnVpbHQtaW4gW2ludF0gdHlwZSxcbiAgIHRoZSB0eXBlIFtpbnQ2NF0gaXMgZ3VhcmFudGVlZCB0byBiZSBleGFjdGx5IDY0LWJpdCB3aWRlIG9uIGFsbFxuICAgcGxhdGZvcm1zLiAgQWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvdmVyIFtpbnQ2NF0gYXJlIHRha2VuXG4gICBtb2R1bG8gMnteNjR9XG5cbiAgIFBlcmZvcm1hbmNlIG5vdGljZTogdmFsdWVzIG9mIHR5cGUgW2ludDY0XSBvY2N1cHkgbW9yZSBtZW1vcnlcbiAgIHNwYWNlIHRoYW4gdmFsdWVzIG9mIHR5cGUgW2ludF0sIGFuZCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb25cbiAgIFtpbnQ2NF0gYXJlIGdlbmVyYWxseSBzbG93ZXIgdGhhbiB0aG9zZSBvbiBbaW50XS4gIFVzZSBbaW50NjRdXG4gICBvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGV4YWN0IDY0LWJpdCBhcml0aG1ldGljLlxuXG4gICAgTGl0ZXJhbHMgZm9yIDY0LWJpdCBpbnRlZ2VycyBhcmUgc3VmZml4ZWQgYnkgTDpcbiAgICB7W1xuICAgICAgbGV0IHplcm86IGludDY0ID0gMExcbiAgICAgIGxldCBvbmU6IGludDY0ID0gMUxcbiAgICAgIGxldCBtX29uZTogaW50NjQgPSAtMUxcbiAgICBdfVxuKilcblxudmFsIHplcm8gOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAwLiAqKVxuXG52YWwgb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMS4gKilcblxudmFsIG1pbnVzX29uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIC0xLiAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG4oKiogVW5hcnkgbmVnYXRpb24uICopXG5cbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbigqKiBBZGRpdGlvbi4gKilcblxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuKCoqIFN1YnRyYWN0aW9uLiAqKVxuXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG4oKiogTXVsdGlwbGljYXRpb24uICopXG5cbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbigqKiBJbnRlZ2VyIGRpdmlzaW9uLlxuICAgQHJhaXNlIERpdmlzaW9uX2J5X3plcm8gaWYgdGhlIHNlY29uZFxuICAgYXJndW1lbnQgaXMgemVyby4gIFRoaXMgZGl2aXNpb24gcm91bmRzIHRoZSByZWFsIHF1b3RpZW50IG9mXG4gICBpdHMgYXJndW1lbnRzIHRvd2FyZHMgemVybywgYXMgc3BlY2lmaWVkIGZvciB7IVN0ZGxpYi4oLyl9LiAqKVxuXG52YWwgdW5zaWduZWRfZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshZGl2fSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuKCoqIEludGVnZXIgcmVtYWluZGVyLiAgSWYgW3ldIGlzIG5vdCB6ZXJvLCB0aGUgcmVzdWx0XG4gICBvZiBbSW50NjQucmVtIHggeV0gc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICBbeCA9IEludDY0LmFkZCAoSW50NjQubXVsIChJbnQ2NC5kaXYgeCB5KSB5KSAoSW50NjQucmVtIHggeSldLlxuICAgSWYgW3kgPSAwXSwgW0ludDY0LnJlbSB4IHldIHJhaXNlcyBbRGl2aXNpb25fYnlfemVyb10uICopXG5cbnZhbCB1bnNpZ25lZF9yZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFyZW19LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG52YWwgc3VjYyA6IGludDY0IC0+IGludDY0XG4oKiogU3VjY2Vzc29yLiAgW0ludDY0LnN1Y2MgeF0gaXMgW0ludDY0LmFkZCB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBwcmVkIDogaW50NjQgLT4gaW50NjRcbigqKiBQcmVkZWNlc3Nvci4gIFtJbnQ2NC5wcmVkIHhdIGlzIFtJbnQ2NC5zdWIgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgYWJzIDogaW50NjQgLT4gaW50NjRcbigqKiBSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIGl0cyBhcmd1bWVudC4gKilcblxudmFsIG1heF9pbnQgOiBpbnQ2NFxuKCoqIFRoZSBncmVhdGVzdCByZXByZXNlbnRhYmxlIDY0LWJpdCBpbnRlZ2VyLCAye142M30gLSAxLiAqKVxuXG52YWwgbWluX2ludCA6IGludDY0XG4oKiogVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIC0ye142M30uICopXG5cbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbigqKiBCaXR3aXNlIGxvZ2ljYWwgYW5kLiAqKVxuXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBvci4gKilcblxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBleGNsdXNpdmUgb3IuICopXG5cbnZhbCBsb2dub3QgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIEJpdHdpc2UgbG9naWNhbCBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG4oKiogW0ludDY0LnNoaWZ0X2xlZnQgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSBsZWZ0IGJ5IFt5XSBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuKCoqIFtJbnQ2NC5zaGlmdF9yaWdodCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhbiBhcml0aG1ldGljIHNoaWZ0OiB0aGUgc2lnbiBiaXQgb2YgW3hdIGlzIHJlcGxpY2F0ZWRcbiAgIGFuZCBpbnNlcnRlZCBpbiB0aGUgdmFjYXRlZCBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSByaWdodCBieSBbeV0gYml0cy5cbiAgIFRoaXMgaXMgYSBsb2dpY2FsIHNoaWZ0OiB6ZXJvZXMgYXJlIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHNcbiAgIHJlZ2FyZGxlc3Mgb2YgdGhlIHNpZ24gb2YgW3hdLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBpbnRlZ2VyICh0eXBlIFtpbnRdKSB0byBhIDY0LWJpdCBpbnRlZ2VyXG4gICAgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYW5cbiAgIGludGVnZXIgKHR5cGUgW2ludF0pLiAgT24gNjQtYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteNjN9LCBpLmUuIHRoZSBoaWdoLW9yZGVyIGJpdCBpcyBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMX0sIGkuZS4gdGhlIHRvcCAzMyBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICopXG5cbnZhbCB1bnNpZ25lZF90b19pbnQgOiBpbnQ2NCAtPiBpbnQgb3B0aW9uXG4oKiogU2FtZSBhcyB7IXRvX2ludH0sIGJ1dCBpbnRlcnByZXRzIHRoZSBhcmd1bWVudCBhcyBhbiB7ZSB1bnNpZ25lZH0gaW50ZWdlci5cbiAgICBSZXR1cm5zIFtOb25lXSBpZiB0aGUgdW5zaWduZWQgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGNhbm5vdCBmaXQgaW50byBhblxuICAgIFtpbnRdLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIDY0LWJpdCBpbnRlZ2VyLFxuICAgZGlzY2FyZGluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0ICh0cnVuY2F0ZSB0b3dhcmRzIDApLlxuICAgSWYgdGhlIHRydW5jYXRlZCBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgb3V0c2lkZSB0aGUgcmFuZ2VcbiAgIFxcW3shSW50NjQubWluX2ludH0sIHshSW50NjQubWF4X2ludH1cXF0sIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQsIGFuZFxuICAgYW4gdW5zcGVjaWZpZWQsIHBsYXRmb3JtLWRlcGVuZGVudCBpbnRlZ2VyIGlzIHJldHVybmVkLiAqKVxuXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyIHRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLiAqKVxuXG5cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gMzItYml0IGludGVnZXIgKHR5cGUgW2ludDMyXSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgMzItYml0IGludGVnZXIgKHR5cGUgW2ludDMyXSkuIFRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMyfSwgaS5lLiB0aGUgdG9wIDMyIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gICopXG5cbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gbmF0aXZlIGludGVnZXIgKHR5cGUgW25hdGl2ZWludF0pXG4gICB0byBhIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pLiAqKVxuXG5leHRlcm5hbCB0b19uYXRpdmVpbnQgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pIHRvIGFcbiAgIG5hdGl2ZSBpbnRlZ2VyLiAgT24gMzItYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LiAgT24gNjQtYml0IHBsYXRmb3JtcyxcbiAgIHRoZSBjb252ZXJzaW9uIGlzIGV4YWN0LiAqKVxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBzdHJpbmcgdG8gYSA2NC1iaXQgaW50ZWdlci5cbiAgIFRoZSBzdHJpbmcgaXMgcmVhZCBpbiBkZWNpbWFsIChieSBkZWZhdWx0LCBvciBpZiB0aGUgc3RyaW5nXG4gICBiZWdpbnMgd2l0aCBbMHVdKSBvciBpbiBoZXhhZGVjaW1hbCwgb2N0YWwgb3IgYmluYXJ5IGlmIHRoZVxuICAgc3RyaW5nIGJlZ2lucyB3aXRoIFsweF0sIFswb10gb3IgWzBiXSByZXNwZWN0aXZlbHkuXG5cbiAgIFRoZSBbMHVdIHByZWZpeCByZWFkcyB0aGUgaW5wdXQgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBpbiB0aGUgcmFuZ2VcbiAgIFtbMCwgMipJbnQ2NC5tYXhfaW50KzFdXS4gIElmIHRoZSBpbnB1dCBleGNlZWRzIHshSW50NjQubWF4X2ludH1cbiAgIGl0IGlzIGNvbnZlcnRlZCB0byB0aGUgc2lnbmVkIGludGVnZXJcbiAgIFtJbnQ2NC5taW5faW50ICsgaW5wdXQgLSBJbnQ2NC5tYXhfaW50IC0gMV0uXG5cbiAgIFRoZSBbX10gKHVuZGVyc2NvcmUpIGNoYXJhY3RlciBjYW4gYXBwZWFyIGFueXdoZXJlIGluIHRoZSBzdHJpbmdcbiAgIGFuZCBpcyBpZ25vcmVkLlxuICAgQHJhaXNlIEZhaWx1cmUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBub3RcbiAgIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciwgb3IgaWYgdGhlIGludGVnZXIgcmVwcmVzZW50ZWRcbiAgIGV4Y2VlZHMgdGhlIHJhbmdlIG9mIGludGVnZXJzIHJlcHJlc2VudGFibGUgaW4gdHlwZSBbaW50NjRdLiAqKVxuXG52YWwgb2Zfc3RyaW5nX29wdDogc3RyaW5nIC0+IGludDY0IG9wdGlvblxuKCoqIFNhbWUgYXMgW29mX3N0cmluZ10sIGJ1dCByZXR1cm4gW05vbmVdIGluc3RlYWQgb2YgcmFpc2luZy5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgdG9fc3RyaW5nIDogaW50NjQgLT4gc3RyaW5nXG4oKiogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXRzIGFyZ3VtZW50LCBpbiBkZWNpbWFsLiAqKVxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGZsb2F0IGFjY29yZGluZ1xuICAgdG8gdGhlIElFRUUgNzU0IGZsb2F0aW5nLXBvaW50ICdkb3VibGUgZm9ybWF0JyBiaXQgbGF5b3V0LlxuICAgQml0IDYzIG9mIHRoZSByZXN1bHQgcmVwcmVzZW50cyB0aGUgc2lnbiBvZiB0aGUgZmxvYXQ7XG4gICBiaXRzIDYyIHRvIDUyIHJlcHJlc2VudCB0aGUgKGJpYXNlZCkgZXhwb25lbnQ7IGJpdHMgNTEgdG8gMFxuICAgcmVwcmVzZW50IHRoZSBtYW50aXNzYS4gKilcblxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBSZXR1cm4gdGhlIGZsb2F0aW5nLXBvaW50IG51bWJlciB3aG9zZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbixcbiAgIGFjY29yZGluZyB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQsXG4gICBpcyB0aGUgZ2l2ZW4gW2ludDY0XS4gKilcblxudHlwZSB0ID0gaW50NjRcbigqKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgNjQtYml0IGludGVnZXJzLiAqKVxuXG52YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuKCoqIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciA2NC1iaXQgaW50ZWdlcnMsIHdpdGggdGhlIHNhbWUgc3BlY2lmaWNhdGlvbiBhc1xuICAgIHshU3RkbGliLmNvbXBhcmV9LiAgQWxvbmcgd2l0aCB0aGUgdHlwZSBbdF0sIHRoaXMgZnVuY3Rpb24gW2NvbXBhcmVdXG4gICAgYWxsb3dzIHRoZSBtb2R1bGUgW0ludDY0XSB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnQgdG8gdGhlIGZ1bmN0b3JzXG4gICAgeyFTZXQuTWFrZX0gYW5kIHshTWFwLk1ha2V9LiAqKVxuXG52YWwgdW5zaWduZWRfY29tcGFyZTogdCAtPiB0IC0+IGludFxuKCoqIFNhbWUgYXMgeyFjb21wYXJlfSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBpbnRlcnByZXRlZCBhcyB7ZSB1bnNpZ25lZH1cbiAgICA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbnZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbigqKiBUaGUgZXF1YWwgZnVuY3Rpb24gZm9yIGludDY0cy5cbiAgICBAc2luY2UgNC4wMy4wICopXG5cbnZhbCBtaW46IHQgLT4gdCAtPiB0XG4oKiogUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gYXJndW1lbnRzLlxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBtYXg6IHQgLT4gdCAtPiB0XG4oKiogUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoZSB0d28gYXJndW1lbnRzLlxuICAgIEBzaW5jZSA0LjEzLjBcbiAqKVxuXG4oKiovKiopXG5cbigqKiB7MSBEZXByZWNhdGVkIGZ1bmN0aW9uc30gKilcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZyA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSBQcmludGYuc3ByaW50ZiB3aXRoIGEgWyVMLi4uXSBmb3JtYXQgaW5zdGVhZC5cIl1cbigqKiBEbyBub3QgdXNlIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbi4gIEluc3RlYWQsXG4gICB1c2VkIHshUHJpbnRmLnNwcmludGZ9IHdpdGggYSBbJUwuLi5dIGZvcm1hdC4gKilcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIFQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGF0b21pYyA6IF8gdFxuICB2YWwgY3JlYXRlIDogKCdhIC0+ICdhIFNlcXVlbmNlLnQpIC0+ICdhIHRcbiAgdmFsIHNocmluayA6ICdhIHQgLT4gJ2EgLT4gJ2EgU2VxdWVuY2UudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIC0+ICdhIFNlcXVlbmNlLnRcblxuICBsZXQgYXRvbWljIF8gPSBTZXF1ZW5jZS5lbXB0eVxuICBsZXQgY3JlYXRlID0gRm4uaWRcbiAgbGV0IHNocmluayA9IEZuLmlkXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBtYXAgdCB+ZiB+Zl9pbnZlcnNlID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5tYXAgfmYgKHNocmluayB0IChmX2ludmVyc2UgeCkpKVxubGV0IGZpbHRlciB0IH5mID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXIgfmYgKHNocmluayB0IHgpKVxuXG5sZXQgZmlsdGVyX21hcCB0IH5mIH5mX2ludmVyc2UgPVxuICBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLmZpbHRlcl9tYXAgfmYgKHNocmluayB0IChmX2ludmVyc2UgeCkpKVxuOztcblxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5vZl9sYXp5IChsYXp5IChzaHJpbmsgKGZvcmNlIGxhenlfdCkgeCkpKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2Zfc2hyaW5rZXIgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKG9mX3Nocmlua2VyIChvZl9sYXp5IGxhenlfdCkpIGluXG4gIG9mX2xhenkgbGF6eV90XG47O1xuXG5sZXQgYm90aCBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIChmc3QsIHNuZCkgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgWyBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOihmdW4gZnN0IC0+IGZzdCwgc25kKVxuICAgICAgOyBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOihmdW4gc25kIC0+IGZzdCwgc25kKVxuICAgICAgXSlcbjs7XG5cbmxldCB1bml0ID0gYXRvbWljXG5sZXQgYm9vbCA9IGF0b21pY1xubGV0IGNoYXIgPSBhdG9taWNcbmxldCBpbnQgPSBhdG9taWNcbmxldCBpbnQzMiA9IGF0b21pY1xubGV0IGludDYzID0gYXRvbWljXG5sZXQgaW50NjQgPSBhdG9taWNcbmxldCBuYXRpdmVpbnQgPSBhdG9taWNcbmxldCBmbG9hdCA9IGF0b21pY1xuXG5sZXQgYmlnYXJyYXkxIHNyYyA9XG4gIGxldCBkaW0gPSBCaWdhcnJheS5BcnJheTEuZGltIHNyYyBpblxuICBtYXRjaCBkaW0gd2l0aFxuICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgfCBfIC0+XG4gICAgbGV0IGtpbmQgPSBCaWdhcnJheS5BcnJheTEua2luZCBzcmMgaW5cbiAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkxLmxheW91dCBzcmMgaW5cbiAgICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICAgIFNlcXVlbmNlLmluaXQgZGltIH5mOihmdW4gdG9fc2tpcCAtPlxuICAgICAgbGV0IHRvX3NraXAgPSB0b19za2lwICsgb2Zmc2V0IGluXG4gICAgICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IChkaW0gLSAxKSB+ZjooZnVuIGkgLT5cbiAgICAgICAgc3JjLntpZiBpIDwgdG9fc2tpcCB0aGVuIGkgZWxzZSBpICsgMX0pKVxuOztcblxubGV0IGJpZ3N0cmluZyA9IGNyZWF0ZSBiaWdhcnJheTFcbmxldCBmbG9hdDMyX3ZlYyA9IGNyZWF0ZSBiaWdhcnJheTFcbmxldCBmbG9hdDY0X3ZlYyA9IGNyZWF0ZSBiaWdhcnJheTFcblxubGV0IGJpZ2FycmF5MiA9XG4gIGxldCBtb2R1bGUgRGltcyA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IGRpbTEgOiBpbnRcbiAgICAgIDsgZGltMiA6IGludFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgIGxldCBjcmVhdGUgYSA9IEJpZ2FycmF5LkFycmF5Mi57IGRpbTEgPSBkaW0xIGE7IGRpbTIgPSBkaW0yIGEgfVxuICBlbmRcbiAgaW5cbiAgbGV0IHNocmluayBmaWVsZCBzcmMgPVxuICAgIGxldCBkaW1zID0gRGltcy5jcmVhdGUgc3JjIGluXG4gICAgbWF0Y2ggRmllbGQuZ2V0IGZpZWxkIGRpbXMgd2l0aFxuICAgIHwgMCAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgXyAtPlxuICAgICAgbGV0IGtpbmQgPSBCaWdhcnJheS5BcnJheTIua2luZCBzcmMgaW5cbiAgICAgIGxldCBsYXlvdXQgPSBCaWdhcnJheS5BcnJheTIubGF5b3V0IHNyYyBpblxuICAgICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICAgIGxldCAoeyBkaW0xOyBkaW0yIH0gOiBEaW1zLnQpID0gRmllbGQubWFwIGZpZWxkIGRpbXMgfmY6SW50LnByZWQgaW5cbiAgICAgIFNlcXVlbmNlLmluaXQgKEZpZWxkLmdldCBmaWVsZCBkaW1zKSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgICAgbGV0IHRvX3NraXAgPSB0b19za2lwICsgb2Zmc2V0IGluXG4gICAgICAgIGxldCBza2lwIGkgPSBpZiBpIDwgdG9fc2tpcCB0aGVuIGkgZWxzZSBpICsgMSBpblxuICAgICAgICBCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5pbml0IGtpbmQgbGF5b3V0IGRpbTEgZGltMiB+ZjooZnVuIGRpbTEgZGltMiAtPlxuICAgICAgICAgIGxldCAoeyBkaW0xOyBkaW0yIH0gOiBEaW1zLnQpID0gRmllbGQubWFwIGZpZWxkIHsgZGltMTsgZGltMiB9IH5mOnNraXAgaW5cbiAgICAgICAgICBzcmMue2RpbTEsIGRpbTJ9KSlcbiAgaW5cbiAgZnVuIHNyYyAtPlxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluIFsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTEgc3JjOyBzaHJpbmsgRGltcy5GaWVsZHMuZGltMiBzcmMgXVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gY3JlYXRlIGJpZ2FycmF5MlxubGV0IGZsb2F0NjRfbWF0ID0gY3JlYXRlIGJpZ2FycmF5MlxuXG5sZXQgb3B0aW9uIHZhbHVlX3QgPVxuICBjcmVhdGUgKGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFNlcXVlbmNlLmVtcHR5XG4gICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICBTZXF1ZW5jZS5hcHBlbmRcbiAgICAgICAgKFNlcXVlbmNlLnNpbmdsZXRvbiBOb25lKVxuICAgICAgICAoU2VxdWVuY2UubWFwIH5mOk9wdGlvbi5yZXR1cm4gKHNocmluayB2YWx1ZV90IHZhbHVlKSkpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGZpeGVkX3BvaW50IChmdW4gbGlzdF90IC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBbXSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgICBbIFNlcXVlbmNlLnNpbmdsZXRvbiB0YWlsXG4gICAgICAgICAgOyBTZXF1ZW5jZS5tYXAgKHNocmluayBlbHRfdCBoZWFkKSB+ZjooZnVuIGhlYWQgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgbGlzdF90IHRhaWwpIH5mOihmdW4gdGFpbCAtPiBoZWFkIDo6IHRhaWwpXG4gICAgICAgICAgXSkpXG47O1xuXG5sZXQgc3RyaW5nID0gbWFwIChsaXN0IGNoYXIpIH5mOlN0cmluZy5vZl9jaGFyX2xpc3QgfmZfaW52ZXJzZTpTdHJpbmcudG9fbGlzdFxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmcgfmZfaW52ZXJzZTpCeXRlcy50b19zdHJpbmdcbmxldCBhcnJheSB0ID0gbWFwIChsaXN0IHQpIH5mOkFycmF5Lm9mX2xpc3QgfmZfaW52ZXJzZTpBcnJheS50b19saXN0XG5sZXQgcmVmIHQgPSBtYXAgdCB+ZjpSZWYuY3JlYXRlIH5mX2ludmVyc2U6UmVmLiggISApXG5sZXQgbGF6eV90IHQgPSBtYXAgdCB+ZjpMYXp5LmZyb21fdmFsIH5mX2ludmVyc2U6TGF6eS5mb3JjZVxuXG5sZXQgc2V4cCA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2hyaW5rZXIgLT5cbiAgICBjcmVhdGUgKGZ1bmN0aW9uXG4gICAgICB8IFNleHAuQXRvbSBfIC0+IFNlcXVlbmNlLmVtcHR5XG4gICAgICB8IFNleHAuTGlzdCBsIC0+XG4gICAgICAgIGxldCBzaHJpbmtfbGlzdCA9XG4gICAgICAgICAgc2hyaW5rIChsaXN0IHNocmlua2VyKSBsIHw+IFNlcXVlbmNlLm1hcCB+ZjooZnVuIGwgLT4gU2V4cC5MaXN0IGwpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzaHJpbmtfdHJlZSA9IFNlcXVlbmNlLm9mX2xpc3QgbCBpblxuICAgICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmlua19saXN0OyBzaHJpbmtfdHJlZSBdKSlcbjs7XG5cbmxldCBlaXRoZXIgZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biBlaXRoZXIgLT5cbiAgICBtYXRjaCAoZWl0aGVyIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgZnN0IC0+IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGZzdF90IGZzdCkgfmY6RWl0aGVyLmZpcnN0XG4gICAgfCBTZWNvbmQgc25kIC0+IFNlcXVlbmNlLm1hcCAoc2hyaW5rIHNuZF90IHNuZCkgfmY6RWl0aGVyLnNlY29uZClcbjs7XG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIG1hcFxuICAgIChlaXRoZXIgb2tfdCBlcnJfdClcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3Qgb2sgLT4gT2sgb2tcbiAgICAgIHwgU2Vjb25kIGVyciAtPiBFcnJvciBlcnIpXG4gICAgfmZfaW52ZXJzZTooZnVuY3Rpb25cbiAgICAgIHwgT2sgb2sgLT4gRmlyc3Qgb2tcbiAgICAgIHwgRXJyb3IgZXJyIC0+IFNlY29uZCBlcnIpXG47O1xuXG5sZXQgbWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfdCBkYXRhX3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGFsaXN0ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS50b19hbGlzdCB0cmVlIGluXG4gICAgbGV0IGRyb3Bfa2V5cyA9XG4gICAgICBTZXF1ZW5jZS5tYXAgKFNlcXVlbmNlLm9mX2xpc3QgYWxpc3QpIH5mOihmdW4gKGssIF8pIC0+XG4gICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgaylcbiAgICBpblxuICAgIGxldCBzaHJpbmtfa2V5cyA9XG4gICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgICAoTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICBsZXQgdHJlZSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUga2V5IGluXG4gICAgICAgICAgIFNlcXVlbmNlLmZpbHRlcl9tYXAgKHNocmluayBrZXlfdCBrZXkpIH5mOihmdW4gc21hbGxlcl9rZXkgLT5cbiAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5hZGQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5OnNtYWxsZXJfa2V5IH5kYXRhXG4gICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgIHwgYE9rIHRyZWUgLT4gU29tZSB0cmVlXG4gICAgICAgICAgICAgfCBgRHVwbGljYXRlIC0+IE5vbmUpKSlcbiAgICBpblxuICAgIGxldCBzaHJpbmtfZGF0YSA9XG4gICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgICAoTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICBTZXF1ZW5jZS5tYXAgKHNocmluayBkYXRhX3QgZGF0YSkgfmY6KGZ1biBzbWFsbGVyX2RhdGEgLT5cbiAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnNldCB+Y29tcGFyYXRvciB0cmVlIH5rZXkgfmRhdGE6c21hbGxlcl9kYXRhKSkpXG4gICAgaW5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIGRyb3Bfa2V5czsgc2hyaW5rX2tleXM7IHNocmlua19kYXRhIF0pXG47O1xuXG5sZXQgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIHRyZWUgLT5cbiAgICBsZXQgbGlzdCA9IFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdCB0cmVlIGluXG4gICAgbGV0IGRyb3BfZWx0cyA9XG4gICAgICBTZXF1ZW5jZS5tYXAgKFNlcXVlbmNlLm9mX2xpc3QgbGlzdCkgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2VsdHMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGxpc3QgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGVsdCBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsgZWx0X3QgZWx0KSB+ZjooZnVuIHNtYWxsZXJfZWx0IC0+XG4gICAgICAgICAgICAgbWF0Y2ggU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5tZW0gfmNvbXBhcmF0b3IgdHJlZSBzbWFsbGVyX2VsdCB3aXRoXG4gICAgICAgICAgICAgfCB0cnVlIC0+IE5vbmVcbiAgICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgICBTb21lIChTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLmFkZCB0cmVlIH5jb21wYXJhdG9yIHNtYWxsZXJfZWx0KSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2VsdHM7IHNocmlua19lbHRzIF0pXG47O1xuXG5sZXQgbWFwX3Qga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gbWFwX3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG1hcF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV90IGRhdGFfdClcbiAgICAgICAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5mX2ludmVyc2U6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuICAgIGluXG4gICAgc2hyaW5rIHQgbWFwX3QpXG47O1xuXG5sZXQgc2V0X3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBzZXRfdCAtPlxuICAgIGxldCBjb21wYXJhdG9yID0gU2V0LmNvbXBhcmF0b3Igc2V0X3QgaW5cbiAgICBsZXQgdCA9XG4gICAgICBtYXBcbiAgICAgICAgKHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QpXG4gICAgICAgIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IHNldF90KVxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iXX0=
