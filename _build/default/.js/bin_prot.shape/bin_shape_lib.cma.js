// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Free_type_variable_Vid=
      caml_string_of_jsbytes("Free type variable: '%{Vid}"),
     cst_Free_type_variable=caml_string_of_jsbytes("Free type variable: '"),
     cst_apply_incorrect_type_appli=
      caml_string_of_jsbytes("apply, incorrect type application arity"),
     cst_top_level=caml_string_of_jsbytes("top-level"),
     cst_impossible_lookup_group_un=
      caml_string_of_jsbytes
       ("impossible: lookup_group, unbound type-identifier: %{Tid}"),
     cst_impossible_lookup_group_un$0=
      caml_string_of_jsbytes
       ("impossible: lookup_group, unbound type-identifier: "),
     cst_Exp=caml_string_of_jsbytes("Exp"),
     cst_exp=caml_string_of_jsbytes("exp"),
     cst_Exp$0=caml_string_of_jsbytes("Exp"),
     cst_exp$0=caml_string_of_jsbytes("exp"),
     cst_annotate$1=caml_string_of_jsbytes("annotate"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_tuple$1=caml_string_of_jsbytes("tuple"),
     cst_record$1=caml_string_of_jsbytes("record"),
     cst_variant$1=caml_string_of_jsbytes("variant"),
     cst_poly_variant$1=caml_string_of_jsbytes("poly_variant"),
     cst_application$1=caml_string_of_jsbytes("application"),
     cst_rec_app$1=caml_string_of_jsbytes("rec_app"),
     cst_var$1=caml_string_of_jsbytes("var"),
     cst_annotate=caml_string_of_jsbytes("annotate"),
     cst_Annotate=caml_string_of_jsbytes("Annotate"),
     cst_Application=caml_string_of_jsbytes("Application"),
     cst_Base=caml_string_of_jsbytes("Base"),
     cst_Poly_variant=caml_string_of_jsbytes("Poly_variant"),
     cst_Rec_app=caml_string_of_jsbytes("Rec_app"),
     cst_Record=caml_string_of_jsbytes("Record"),
     cst_Tuple=caml_string_of_jsbytes("Tuple"),
     cst_Var=caml_string_of_jsbytes("Var"),
     cst_Variant=caml_string_of_jsbytes("Variant"),
     cst_application=caml_string_of_jsbytes("application"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_poly_variant=caml_string_of_jsbytes("poly_variant"),
     cst_rec_app=caml_string_of_jsbytes("rec_app"),
     cst_record=caml_string_of_jsbytes("record"),
     cst_tuple=caml_string_of_jsbytes("tuple"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_variant=caml_string_of_jsbytes("variant"),
     cst_annotate$0=caml_string_of_jsbytes("annotate"),
     cst_Annotate$0=caml_string_of_jsbytes("Annotate"),
     cst_Application$0=caml_string_of_jsbytes("Application"),
     cst_Base$0=caml_string_of_jsbytes("Base"),
     cst_Poly_variant$0=caml_string_of_jsbytes("Poly_variant"),
     cst_Rec_app$0=caml_string_of_jsbytes("Rec_app"),
     cst_Record$0=caml_string_of_jsbytes("Record"),
     cst_Tuple$0=caml_string_of_jsbytes("Tuple"),
     cst_Var$0=caml_string_of_jsbytes("Var"),
     cst_Variant$0=caml_string_of_jsbytes("Variant"),
     cst_application$0=caml_string_of_jsbytes("application"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_poly_variant$0=caml_string_of_jsbytes("poly_variant"),
     cst_rec_app$0=caml_string_of_jsbytes("rec_app"),
     cst_record$0=caml_string_of_jsbytes("record"),
     cst_tuple$0=caml_string_of_jsbytes("tuple"),
     cst_var$0=caml_string_of_jsbytes("var"),
     cst_variant$0=caml_string_of_jsbytes("variant"),
     cst_some=caml_string_of_jsbytes("some"),
     cst_none=caml_string_of_jsbytes("none"),
     cst_sorted=caml_string_of_jsbytes("sorted"),
     cst_sorted$0=caml_string_of_jsbytes("sorted"),
     cst_Location_s=caml_string_of_jsbytes("%{Location}: %s"),
     error_source_026=
      caml_string_of_jsbytes("shape/src/bin_shape.ml.Sorted_table.t"),
     error_source_042=
      caml_string_of_jsbytes
       ("shape/src/bin_shape.ml.Canonical_exp_constructor.t"),
     error_source_206=
      caml_string_of_jsbytes("shape/src/bin_shape.ml.Canonical_full.Exp1.t0"),
     cst_Bin_shape_lib_Bin_shape_Fo=
      caml_string_of_jsbytes
       ("Bin_shape_lib.Bin_shape.For_typerep.Not_a_tuple"),
     Assert_failure=global_data.Assert_failure,
     Base_List=global_data.Base__List,
     Base=global_data.Base,
     Base_Option=global_data.Base__Option,
     Base_Map=global_data.Base__Map,
     Base_Comparator=global_data.Base__Comparator,
     Ppx_compare_lib=global_data.Ppx_compare_lib,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Base_String=global_data.Base__String,
     Base_Int=global_data.Base__Int,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Base_Printf=global_data.Base__Printf,
     Md5_lib=global_data.Md5_lib,
     Bin_shape_lib=[0];
    caml_register_global(120,Bin_shape_lib,"Bin_shape_lib");
    var
     sexp_of_t=Base_String[28],
     of_string=Base_String[29],
     to_string=Base_String[30],
     t_of_sexp=Base_String[27],
     sexp_of_t$0=Base_String[28],
     of_string$0=Base_String[29],
     to_string$0=Base_String[30],
     compare=Base_String[37],
     _N_=
      [0,
       caml_string_of_jsbytes
        ("shape/src/bin_shape.ml.For_typerep.Not_a_tuple")],
     _O_=[0,caml_string_of_jsbytes("_none_"),0,-1],
     _J_=[0,0],
     _K_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("The shape for an inherited type is not described as a polymorphic-variant: "),
        [2,0,0]],
       caml_string_of_jsbytes
        ("The shape for an inherited type is not described as a polymorphic-variant: %s")],
     _y_=[0,caml_string_of_jsbytes("Annotate")],
     _z_=[0,caml_string_of_jsbytes("Base")],
     _A_=[0,caml_string_of_jsbytes("Record")],
     _B_=[0,caml_string_of_jsbytes("Variant")],
     _C_=[0,caml_string_of_jsbytes("Tuple")],
     _D_=[0,caml_string_of_jsbytes("Poly_variant")],
     _E_=[0,caml_string_of_jsbytes("Var")],
     _F_=[0,caml_string_of_jsbytes("Rec_app")],
     _G_=[0,caml_string_of_jsbytes("Top_app")],
     _x_=[0,0],
     _u_=[0,caml_string_of_jsbytes("members")],
     _v_=[0,caml_string_of_jsbytes("loc")],
     _w_=[0,caml_string_of_jsbytes("gid")],
     _s_=[0,caml_string_of_jsbytes("Constr")],
     _t_=[0,caml_string_of_jsbytes("Inherit")],
     _r_=[0,caml_string_of_jsbytes("Exp")],
     _q_=[0,caml_string_of_jsbytes("...")],
     _h_=[0,caml_string_of_jsbytes("Annotate")],
     _i_=[0,caml_string_of_jsbytes("Base")],
     _j_=[0,caml_string_of_jsbytes("Tuple")],
     _k_=[0,caml_string_of_jsbytes("Record")],
     _l_=[0,caml_string_of_jsbytes("Variant")],
     _m_=[0,caml_string_of_jsbytes("Poly_variant")],
     _n_=[0,caml_string_of_jsbytes("Application")],
     _o_=[0,caml_string_of_jsbytes("Rec_app")],
     _p_=[0,caml_string_of_jsbytes("Var")],
     _g_=[0,caml_string_of_jsbytes("")],
     _f_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Different shapes for duplicated polymorphic constructor: `"),
        [2,0,0]],
       caml_string_of_jsbytes
        ("Different shapes for duplicated polymorphic constructor: `%s")],
     _e_=[0,17724,0],
     _d_=[0,caml_string_of_jsbytes("sorted")],
     _c_=[0,caml_string_of_jsbytes("shape/src/bin_shape.ml"),33,2],
     _a_=[11,caml_string_of_jsbytes(": "),[2,0,0]],
     _b_=[0,0];
    function eval_fail(loc,fmt)
     {function _b9_(s)
       {var
         _b__=
          [0,
           [24,
            _b_,
            function(param,custom_printf_001)
             {return caml_call1(to_string,custom_printf_001)},
            _a_],
           cst_Location_s],
         _b$_=caml_call3(Base_Printf[2],_b__,loc,s);
        return caml_call1(Base[200],_b$_)}
      return caml_call2(Base_Printf[4],_b9_,fmt)}
    function equal_option(equal,a,b)
     {if(a)
       {if(b){var y=b[1],x=a[1];return caml_call2(equal,x,y)}}
      else
       if(! b)return 1;
      return 0}
    function create(loc,eq,xs$1)
     {function _b7_(param,_b8_)
       {var s2=_b8_[1],s1=param[1];return caml_call2(Base_String[37],s1,s2)}
      var param$0=caml_call2(Base_List[62],xs$1,_b7_);
      if(param$0)
       {var
         xs$0=param$0[2],
         match$0=param$0[1],
         value$0=match$0[2],
         key$0=match$0[1],
         acc$1=[0,[0,key$0,value$0],0],
         acc=acc$1,
         last_key=key$0,
         last_value=value$0,
         param=xs$0;
        for(;;)
         {if(param)
           {var xs=param[2],match=param[1],value=match[2],key=match[1];
            if(! caml_call2(Base_String[33],last_key,key))
             {var
               acc$0=[0,[0,key,value],acc],
               acc=acc$0,
               last_key=key,
               last_value=value,
               param=xs;
              continue}
            if(caml_call2(eq,last_value,value)){var param=xs;continue}
            var match$1=[0,-1062743954,key]}
          else
           var match$1=[0,17724,caml_call1(Base_List[38],acc)];
          break}}
      else
       var match$1=_e_;
      if(17724 <= match$1[1]){var sorted=match$1[2];return [0,sorted]}
      var s=match$1[2];
      return caml_call2(eval_fail(loc,_f_),s,0)}
    function map(t,f)
     {function _b6_(param)
       {var v=param[2],k=param[1];return [0,k,caml_call1(f,v)]}
      return [0,caml_call2(Base_List[76],t[1],_b6_)]}
    var
     compare$0=Md5_lib[1],
     to_binary=Md5_lib[3],
     to_hex=Md5_lib[6],
     of_hex_exn=Md5_lib[7],
     string=Md5_lib[8];
    function to_md5(t){return t}
    function of_md5(t){return t}
    function sexp_of_t$1(t)
     {var _b5_=caml_call1(to_hex,t);return caml_call1(Base[164],_b5_)}
    function t_of_sexp$0(s)
     {return caml_call1(of_hex_exn,caml_call1(Base[163],s))}
    function uuid(u){return caml_call1(string,caml_call1(to_string$0,u))}
    function int$0(x){return caml_call1(string,caml_call1(Base_Int[11],x))}
    function pair(x,y)
     {var _b3_=caml_call1(to_binary,y),_b4_=caml_call1(to_binary,x);
      return caml_call1(string,caml_call2(Base[197],_b4_,_b3_))}
    function list(l)
     {var _b2_=caml_call2(Base_List[76],l,to_binary);
      return caml_call1(string,caml_call2(Base_String[54],_g_,_b2_))}
    function constructor(s,l)
     {var _b1_=caml_call1(to_binary,list(l));
      return caml_call1(string,caml_call2(Base[197],s,_b1_))}
    function t_of_sexp$1(of_a_039,sexp_044)
     {if(0 === sexp_044[0])
       {var
         _bJ_=sexp_044[1],
         _bK_=caml_string_compare(_bJ_,cst_annotate),
         switch$0=0;
        if(0 <= _bK_)
         if(0 < _bK_)
          if(caml_string_notequal(_bJ_,cst_application))
           if(caml_string_notequal(_bJ_,cst_base))
            if(caml_string_notequal(_bJ_,cst_poly_variant))
             if(caml_string_notequal(_bJ_,cst_rec_app))
              if(caml_string_notequal(_bJ_,cst_record))
               if(caml_string_notequal(_bJ_,cst_tuple))
                if(caml_string_notequal(_bJ_,cst_var))
                 {if(! caml_string_notequal(_bJ_,cst_variant))switch$0 = 5}
                else
                 switch$0 = 9;
               else
                switch$0 = 3;
              else
               switch$0 = 4;
             else
              switch$0 = 8;
            else
             switch$0 = 6;
           else
            switch$0 = 2;
          else
           switch$0 = 7;
         else
          switch$0 = 1;
        else
         if(caml_string_notequal(_bJ_,cst_Annotate))
          if(caml_string_notequal(_bJ_,cst_Application))
           if(caml_string_notequal(_bJ_,cst_Base))
            if(caml_string_notequal(_bJ_,cst_Poly_variant))
             if(caml_string_notequal(_bJ_,cst_Rec_app))
              if(caml_string_notequal(_bJ_,cst_Record))
               if(caml_string_notequal(_bJ_,cst_Tuple))
                if(caml_string_notequal(_bJ_,cst_Var))
                 {if(! caml_string_notequal(_bJ_,cst_Variant))switch$0 = 5}
                else
                 switch$0 = 9;
               else
                switch$0 = 3;
              else
               switch$0 = 4;
             else
              switch$0 = 8;
            else
             switch$0 = 6;
           else
            switch$0 = 2;
          else
           switch$0 = 7;
         else
          switch$0 = 1;
        switch(switch$0)
         {case 1:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 2:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 3:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 4:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 5:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 6:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 7:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 8:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044);
          case 9:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_042,sexp_044)
          }}
      else
       {var _bL_=sexp_044[1];
        if(! _bL_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_042,sexp_044);
        var _bM_=_bL_[1];
        if(0 !== _bM_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_042,sexp_044);
        var
         _bN_=_bM_[1],
         _bO_=caml_string_compare(_bN_,cst_annotate$0),
         switch$1=0;
        if(0 <= _bO_)
         if(0 < _bO_)
          if(caml_string_notequal(_bN_,cst_application$0))
           if(caml_string_notequal(_bN_,cst_base$0))
            if(caml_string_notequal(_bN_,cst_poly_variant$0))
             if(caml_string_notequal(_bN_,cst_rec_app$0))
              if(caml_string_notequal(_bN_,cst_record$0))
               if(caml_string_notequal(_bN_,cst_tuple$0))
                if(caml_string_notequal(_bN_,cst_var$0))
                 {if(! caml_string_notequal(_bN_,cst_variant$0))switch$1 = 5}
                else
                 switch$1 = 9;
               else
                switch$1 = 3;
              else
               switch$1 = 4;
             else
              switch$1 = 8;
            else
             switch$1 = 6;
           else
            switch$1 = 2;
          else
           switch$1 = 7;
         else
          switch$1 = 1;
        else
         if(caml_string_notequal(_bN_,cst_Annotate$0))
          if(caml_string_notequal(_bN_,cst_Application$0))
           if(caml_string_notequal(_bN_,cst_Base$0))
            if(caml_string_notequal(_bN_,cst_Poly_variant$0))
             if(caml_string_notequal(_bN_,cst_Rec_app$0))
              if(caml_string_notequal(_bN_,cst_Record$0))
               if(caml_string_notequal(_bN_,cst_Tuple$0))
                if(caml_string_notequal(_bN_,cst_Var$0))
                 {if(! caml_string_notequal(_bN_,cst_Variant$0))switch$1 = 5}
                else
                 switch$1 = 9;
               else
                switch$1 = 3;
              else
               switch$1 = 4;
             else
              switch$1 = 8;
            else
             switch$1 = 6;
           else
            switch$1 = 2;
          else
           switch$1 = 7;
         else
          switch$1 = 1;
        switch(switch$1)
         {case 1:
           var sexp_args_046=_bL_[2];
           if(sexp_args_046)
            {var _bU_=sexp_args_046[2];
             if(_bU_ && ! _bU_[2])
              {var
                arg1_048=_bU_[1],
                arg0_047=sexp_args_046[1],
                res0_049=caml_call1(t_of_sexp,arg0_047),
                res1_050=caml_call1(of_a_039,arg1_048);
               return [0,res0_049,res1_050]}}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 2:
           var sexp_args_053=_bL_[2];
           if(sexp_args_053)
            {var _bS_=sexp_args_053[2];
             if(_bS_ && ! _bS_[2])
              {var
                arg1_055=_bS_[1],
                arg0_054=sexp_args_053[1],
                res0_056=caml_call1(t_of_sexp,arg0_054),
                res1_057=caml_call2(Base[138],of_a_039,arg1_055);
               return [1,res0_056,res1_057]}}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 3:
           var sexp_args_060=_bL_[2];
           if(sexp_args_060 && ! sexp_args_060[2])
            {var
              arg0_061=sexp_args_060[1],
              res0_062=caml_call2(Base[138],of_a_039,arg0_061);
             return [2,res0_062]}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 4:
           var sexp_args_065=_bL_[2];
           if(sexp_args_065 && ! sexp_args_065[2])
            {var
              arg0_071=sexp_args_065[1],
              _bQ_=
               function(sexp_070)
                {if(1 === sexp_070[0])
                  {var _bZ_=sexp_070[1];
                   if(_bZ_)
                    {var _b0_=_bZ_[2];
                     if(_b0_ && ! _b0_[2])
                      {var
                        arg1_067=_b0_[1],
                        arg0_066=_bZ_[1],
                        res0_068=caml_call1(Base[163],arg0_066),
                        res1_069=caml_call1(of_a_039,arg1_067);
                       return [0,res0_068,res1_069]}}}
                 return caml_call3
                         (Sexplib0_Sexp_conv_error[2],error_source_042,2,sexp_070)},
              res0_072=caml_call2(Base[138],_bQ_,arg0_071);
             return [3,res0_072]}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 5:
           var sexp_args_075=_bL_[2];
           if(sexp_args_075 && ! sexp_args_075[2])
            {var
              arg0_081=sexp_args_075[1],
              _bP_=
               function(sexp_080)
                {if(1 === sexp_080[0])
                  {var _bX_=sexp_080[1];
                   if(_bX_)
                    {var _bY_=_bX_[2];
                     if(_bY_ && ! _bY_[2])
                      {var
                        arg1_077=_bY_[1],
                        arg0_076=_bX_[1],
                        res0_078=caml_call1(Base[163],arg0_076),
                        res1_079=caml_call2(Base[138],of_a_039,arg1_077);
                       return [0,res0_078,res1_079]}}}
                 return caml_call3
                         (Sexplib0_Sexp_conv_error[2],error_source_042,2,sexp_080)},
              res0_082=caml_call2(Base[138],_bP_,arg0_081);
             return [4,res0_082]}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 6:
           var sexp_args_085=_bL_[2];
           if(sexp_args_085 && ! sexp_args_085[2])
            {var
              arg0_086=sexp_args_085[1],
              of_a_010=caml_call1(Base[151],of_a_039);
             if(0 === arg0_086[0])
              var
               res0_087=
                caml_call2
                 (Sexplib0_Sexp_conv_error[16],error_source_026,arg0_086);
             else
              {var
                field_sexps_013=arg0_086[1],
                sorted_014=[0,0],
                duplicates_016=[0,0],
                extra_017=[0,0],
                param=field_sexps_013;
               for(;;)
                {if(param)
                  {var _bC_=param[1];
                   if(1 === _bC_[0])
                    {var _bD_=_bC_[1];
                     if(_bD_)
                      {var _bE_=_bD_[1];
                       if(0 === _bE_[0])
                        {var _bF_=_bD_[2],_bG_=_bE_[1],switch$2=0;
                         if(! _bF_ || ! _bF_[2])switch$2 = 1;
                         if(switch$2)
                          {var tail_029=param[2];
                           if(caml_string_notequal(_bG_,cst_sorted))
                            {if(Sexplib0_Sexp_conv[26][1])
                              extra_017[1] = [0,_bG_,extra_017[1]]}
                           else
                            if(sorted_014[1])
                             duplicates_016[1] = [0,_bG_,duplicates_016[1]];
                            else
                             {if(_bF_)
                               {if(_bF_[2])throw [0,Assert_failure,_c_];
                                var x_030=_bF_[1],field_sexp_019=x_030}
                              else
                               var
                                field_sexp_019=
                                 caml_call2
                                  (Sexplib0_Sexp_conv_error[10],error_source_026,arg0_086);
                              var
                               _bH_=
                                function(sexp_025)
                                 {if(1 === sexp_025[0])
                                   {var _bV_=sexp_025[1];
                                    if(_bV_)
                                     {var _bW_=_bV_[2];
                                      if(_bW_ && ! _bW_[2])
                                       {var
                                         arg1_022=_bW_[1],
                                         arg0_021=_bV_[1],
                                         res0_023=caml_call1(Base[163],arg0_021),
                                         res1_024=caml_call1(of_a_010,arg1_022);
                                        return [0,res0_023,res1_024]}}}
                                  return caml_call3
                                          (Sexplib0_Sexp_conv_error[2],error_source_026,2,sexp_025)},
                               fvalue_027=caml_call2(Base[138],_bH_,field_sexp_019);
                              sorted_014[1] = [0,fvalue_027]}
                           var param=tail_029;
                           continue}}}}
                   caml_call2
                    (Sexplib0_Sexp_conv_error[10],error_source_026,_bC_)}
                 if(duplicates_016[1])
                  var
                   res0_087=
                    caml_call3
                     (Sexplib0_Sexp_conv_error[12],
                      error_source_026,
                      duplicates_016[1],
                      arg0_086);
                 else
                  if(extra_017[1])
                   var
                    res0_087=
                     caml_call3
                      (Sexplib0_Sexp_conv_error[13],
                       error_source_026,
                       extra_017[1],
                       arg0_086);
                  else
                   {var _bI_=sorted_014[1];
                    if(_bI_)
                     var sorted_015=_bI_[1],res0_087=[0,sorted_015];
                    else
                     var
                      res0_087=
                       caml_call3
                        (Sexplib0_Sexp_conv_error[15],
                         error_source_026,
                         arg0_086,
                         [0,[0,0 === sorted_014[1]?1:0,cst_sorted$0],0])}
                 break}}
             return [5,res0_087]}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 7:
           var sexp_args_090=_bL_[2];
           if(sexp_args_090)
            {var _bT_=sexp_args_090[2];
             if(_bT_ && ! _bT_[2])
              {var
                arg1_092=_bT_[1],
                arg0_091=sexp_args_090[1],
                res0_093=caml_call1(of_a_039,arg0_091),
                res1_094=caml_call2(Base[138],of_a_039,arg1_092);
               return [6,res0_093,res1_094]}}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 8:
           var sexp_args_097=_bL_[2];
           if(sexp_args_097)
            {var _bR_=sexp_args_097[2];
             if(_bR_ && ! _bR_[2])
              {var
                arg1_099=_bR_[1],
                arg0_098=sexp_args_097[1],
                res0_100=caml_call1(Base[118],arg0_098),
                res1_101=caml_call2(Base[138],of_a_039,arg1_099);
               return [7,res0_100,res1_101]}}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044);
          case 9:
           var sexp_args_104=_bL_[2];
           if(sexp_args_104 && ! sexp_args_104[2])
            {var
              arg0_105=sexp_args_104[1],
              res0_106=caml_call1(Base[118],arg0_105);
             return [8,res0_106]}
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],error_source_042,_bN_,sexp_044)
          }}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_042,sexp_044)}
    function sexp_of_t$2(of_a_108,param)
     {switch(param[0])
       {case 0:
         var
          arg1_110=param[2],
          arg0_109=param[1],
          res0_111=caml_call1(sexp_of_t$0,arg0_109),
          res1_112=caml_call1(of_a_108,arg1_110);
         return [1,[0,_h_,[0,res0_111,[0,res1_112,0]]]];
        case 1:
         var
          arg1_114=param[2],
          arg0_113=param[1],
          res0_115=caml_call1(sexp_of_t$0,arg0_113),
          res1_116=caml_call2(Base[139],of_a_108,arg1_114);
         return [1,[0,_i_,[0,res0_115,[0,res1_116,0]]]];
        case 2:
         var
          arg0_117=param[1],
          res0_118=caml_call2(Base[139],of_a_108,arg0_117);
         return [1,[0,_j_,[0,res0_118,0]]];
        case 3:
         var
          arg0_123=param[1],
          _bA_=
           function(param)
            {var
              arg1_120=param[2],
              arg0_119=param[1],
              res0_121=caml_call1(Base[164],arg0_119),
              res1_122=caml_call1(of_a_108,arg1_120);
             return [1,[0,res0_121,[0,res1_122,0]]]},
          res0_124=caml_call2(Base[139],_bA_,arg0_123);
         return [1,[0,_k_,[0,res0_124,0]]];
        case 4:
         var
          arg0_129=param[1],
          _bB_=
           function(param)
            {var
              arg1_126=param[2],
              arg0_125=param[1],
              res0_127=caml_call1(Base[164],arg0_125),
              res1_128=caml_call2(Base[139],of_a_108,arg1_126);
             return [1,[0,res0_127,[0,res1_128,0]]]},
          res0_130=caml_call2(Base[139],_bB_,arg0_129);
         return [1,[0,_l_,[0,res0_130,0]]];
        case 5:
         var
          arg0_131=param[1],
          of_a_031=caml_call1(Base[152],of_a_108),
          sorted_033=arg0_131[1],
          bnds_032=0,
          _bz_=
           function(param)
            {var
              arg1_036=param[2],
              arg0_035=param[1],
              res0_037=caml_call1(Base[164],arg0_035),
              res1_038=caml_call1(of_a_031,arg1_036);
             return [1,[0,res0_037,[0,res1_038,0]]]},
          arg_034=caml_call2(Base[139],_bz_,sorted_033),
          bnds_032$0=[0,[1,[0,_d_,[0,arg_034,0]]],bnds_032],
          res0_132=[1,bnds_032$0];
         return [1,[0,_m_,[0,res0_132,0]]];
        case 6:
         var
          arg1_134=param[2],
          arg0_133=param[1],
          res0_135=caml_call1(of_a_108,arg0_133),
          res1_136=caml_call2(Base[139],of_a_108,arg1_134);
         return [1,[0,_n_,[0,res0_135,[0,res1_136,0]]]];
        case 7:
         var
          arg1_138=param[2],
          arg0_137=param[1],
          res0_139=caml_call1(Base[119],arg0_137),
          res1_140=caml_call2(Base[139],of_a_108,arg1_138);
         return [1,[0,_o_,[0,res0_139,[0,res1_140,0]]]];
        default:
         var arg0_141=param[1],res0_142=caml_call1(Base[119],arg0_141);
         return [1,[0,_p_,[0,res0_142,0]]]}}
    function map$0(x,f)
     {switch(x[0])
       {case 0:var x$0=x[2],u=x[1];return [0,u,caml_call1(f,x$0)];
        case 1:var xs=x[2],s=x[1];return [1,s,caml_call2(Base_List[76],xs,f)];
        case 2:var xs$0=x[1];return [2,caml_call2(Base_List[76],xs$0,f)];
        case 3:
         var
          l=x[1],
          _bu_=
           function(param)
            {var x=param[2],s=param[1];return [0,s,caml_call1(f,x)]};
         return [3,caml_call2(Base_List[76],l,_bu_)];
        case 4:
         var
          l$0=x[1],
          _bv_=
           function(param)
            {var xs=param[2],s=param[1];
             return [0,s,caml_call2(Base_List[76],xs,f)]};
         return [4,caml_call2(Base_List[76],l$0,_bv_)];
        case 5:
         var t=x[1],_bw_=Base_Option[21];
         return [5,map(t,function(_by_){return caml_call2(_bw_,_by_,f)})];
        case 6:
         var l$1=x[2],x$1=x[1],_bx_=caml_call2(Base_List[76],l$1,f);
         return [6,caml_call1(f,x$1),_bx_];
        case 7:
         var l$2=x[2],t$0=x[1];return [7,t$0,caml_call2(Base_List[76],l$2,f)];
        default:var v=x[1];return [8,v]}}
    function to_string$1(t)
     {var _bt_=sexp_of_t$2(function(param){return _q_},t);
      return caml_call1(Base[84][15],_bt_)}
    function digest_layer(param)
     {switch(param[0])
       {case 0:
         var x=param[2],u=param[1];
         return constructor(cst_annotate$1,[0,uuid(u),[0,x,0]]);
        case 1:
         var l=param[2],u$0=param[1],_bj_=[0,list(l),0];
         return constructor(cst_base$1,[0,uuid(u$0),_bj_]);
        case 2:
         var l$0=param[1];return constructor(cst_tuple$1,[0,list(l$0),0]);
        case 3:
         var
          l$1=param[1],
          _bk_=0,
          _bl_=
           function(param)
            {var t=param[2],s=param[1];return pair(caml_call1(string,s),t)};
         return constructor
                 (cst_record$1,
                  [0,list(caml_call2(Base_List[76],l$1,_bl_)),_bk_]);
        case 4:
         var
          l$2=param[1],
          _bm_=0,
          _bn_=
           function(param)
            {var l=param[2],s=param[1],_bs_=list(l);
             return pair(caml_call1(string,s),_bs_)};
         return constructor
                 (cst_variant$1,
                  [0,list(caml_call2(Base_List[76],l$2,_bn_)),_bm_]);
        case 5:
         var
          table=param[1],
          _bo_=0,
          _bp_=
           function(param)
            {var y=param[2],x$0=param[1];
             if(y)
              var x=y[1],_br_=constructor(cst_some,[0,x,0]);
             else
              var _br_=constructor(cst_none,0);
             return pair(caml_call1(string,x$0),_br_)};
         return constructor
                 (cst_poly_variant$1,
                  [0,list(caml_call2(Base_List[76],table[1],_bp_)),_bo_]);
        case 6:
         var l$3=param[2],x$0=param[1];
         return constructor(cst_application$1,[0,x$0,[0,list(l$3),0]]);
        case 7:
         var l$4=param[2],n=param[1],_bq_=[0,list(l$4),0];
         return constructor(cst_rec_app$1,[0,int$0(n),_bq_]);
        default:
         var n$0=param[1];return constructor(cst_var$1,[0,int$0(n$0),0])}}
    function to_digest(param){var x=param[1];return x}
    function to_digest$0(x)
     {switch(x[0])
       {case 0:var x$0=x[1];return digest_layer([5,x$0]);
        case 1:var match=x[1],x$1=match[2];return x$1;
        default:var x$2=x[1];return x$2}}
    function equal(x,y)
     {var _bi_=to_digest$0(y);
      return 0 === caml_call2(compare$0,to_digest$0(x),_bi_)?1:0}
    function opaque(x){return [2,to_digest$0(x)]}
    function create$0(x)
     {var x$0=map$0(x,to_digest$0),desc=to_string$1(x$0);
      switch(x$0[0])
       {case 0:return [1,[0,desc,digest_layer(x$0)]];
        case 1:return [1,[0,desc,digest_layer(x$0)]];
        case 5:var l=x$0[1];return [0,l];
        case 6:return [1,[0,desc,digest_layer(x$0)]];
        case 7:return [1,[0,desc,digest_layer(x$0)]];
        default:return [1,[0,desc,digest_layer(x$0)]]}}
    function var$0(x){return create$0([8,x])}
    function apply(def,l){return create$0([6,def,l])}
    function recurse(tid,l){return create$0([7,tid,l])}
    function get_poly_variant(x)
     {if(1 === x[0]){var match=x[1],desc=match[1];return [1,desc]}
      var l=x[1],_bf_=Base_Option[21];
      function _bg_(x){return [2,x]}
      return [0,map(l,function(_bh_){return caml_call2(_bf_,_bh_,_bg_)})]}
    var Def=[0];
    function annotate(u,x){return create$0([0,u,x])}
    function basetype(u,l){return create$0([1,u,l])}
    function tuple(l){return create$0([2,l])}
    function poly_variant(loc,l)
     {return create$0
              ([5,
                create
                 (loc,
                  function(_bd_,_be_){return equal_option(equal,_bd_,_be_)},
                  l)])}
    function var$1(x){return create$0([8,x])}
    function apply$0(x,l){return create$0([6,x,l])}
    function recurse$0(t,l){return create$0([7,t,l])}
    function define(x){return x}
    function record(l){return create$0([3,l])}
    function variant(l){return create$0([4,l])}
    function create$1(e){return [0,to_digest$0(e)]}
    var
     Canonical_digest=
      [0,
       to_digest,
       [0,var$0,recurse,apply,opaque,get_poly_variant],
       Def,
       [0,
        annotate,
        basetype,
        tuple,
        poly_variant,
        var$1,
        recurse$0,
        apply$0,
        define,
        record,
        variant,
        create$1]];
    function compare$1(a_198,b_199)
     {if(caml_call2(Ppx_compare_lib[1],a_198,b_199))return 0;
      var b_201=b_199[1],a_200=a_198[1];
      function cmp_a(a_202,b_203){return compare$1(a_202,b_203)}
      if(caml_call2(Ppx_compare_lib[1],a_200,b_201))return 0;
      var switch$0=0;
      switch(a_200[0])
       {case 0:
         var _aV_=a_200[1];
         if(0 !== b_201[0])return -1;
         var
          b_149=b_201[2],
          b_147=b_201[1],
          a_148=a_200[2],
          n=caml_call2(compare,_aV_,b_147);
         return 0 === n?cmp_a(a_148,b_149):n;
        case 1:
         var _aW_=a_200[2],_aX_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:
            var
             b_153=b_201[2],
             b_151=b_201[1],
             n$0=caml_call2(compare,_aX_,b_151);
            if(0 !== n$0)return n$0;
            var _aY_=function(a_154,b_155){return cmp_a(a_154,b_155)};
            return caml_call3(Base[135],_aY_,_aW_,b_153);
           default:return -1}
         break;
        case 2:
         var _aZ_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:
            var
             b_157=b_201[1],
             _a0_=function(a_158,b_159){return cmp_a(a_158,b_159)};
            return caml_call3(Base[135],_a0_,_aZ_,b_157);
           default:return -1}
         break;
        case 3:
         var _a1_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:
            var
             b_161=b_201[1],
             _a2_=
              function(a_162,b_163)
               {var
                 t_165=a_162[2],
                 t_164=a_162[1],
                 t_167=b_163[2],
                 t_166=b_163[1],
                 n=caml_call2(Base[159],t_164,t_166);
                return 0 === n?cmp_a(t_165,t_167):n};
            return caml_call3(Base[135],_a2_,_a1_,b_161);
           default:return -1}
         break;
        case 4:
         var _a3_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:switch$0 = 3;break;
           case 4:
            var
             b_169=b_201[1],
             _a4_=
              function(a_170,b_171)
               {var
                 t_173=a_170[2],
                 t_172=a_170[1],
                 t_175=b_171[2],
                 t_174=b_171[1],
                 n=caml_call2(Base[159],t_172,t_174);
                if(0 !== n)return n;
                function _bc_(a_176,b_177){return cmp_a(a_176,b_177)}
                return caml_call3(Base[135],_bc_,t_173,t_175)};
            return caml_call3(Base[135],_a4_,_a3_,b_169);
           default:return -1}
         break;
        case 5:
         var _a5_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:switch$0 = 3;break;
           case 4:switch$0 = 4;break;
           case 5:
            var b_179=b_201[1];
            if(caml_call2(Ppx_compare_lib[1],_a5_,b_179))return 0;
            var
             _aS_=b_179[1],
             _aT_=_a5_[1],
             _aU_=
              function(a_004,b_005)
               {var
                 t_007=a_004[2],
                 t_006=a_004[1],
                 t_009=b_005[2],
                 t_008=b_005[1],
                 n=caml_call2(Base[159],t_006,t_008);
                if(0 !== n)return n;
                function _bb_(a_182,b_183){return cmp_a(a_182,b_183)}
                return caml_call3(Base[148],_bb_,t_007,t_009)};
            return caml_call3(Base[135],_aU_,_aT_,_aS_);
           default:return -1}
         break;
        case 6:
         var _a6_=a_200[2],_a7_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:switch$0 = 3;break;
           case 4:switch$0 = 4;break;
           case 5:switch$0 = 5;break;
           case 6:
            var b_187=b_201[2],b_185=b_201[1],n$1=cmp_a(_a7_,b_185);
            if(0 !== n$1)return n$1;
            var _a8_=function(a_188,b_189){return cmp_a(a_188,b_189)};
            return caml_call3(Base[135],_a8_,_a6_,b_187);
           default:return -1}
         break;
        case 7:
         var _a9_=a_200[2],_a__=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:switch$0 = 3;break;
           case 4:switch$0 = 4;break;
           case 5:switch$0 = 5;break;
           case 6:switch$0 = 6;break;
           case 7:
            var
             b_193=b_201[2],
             b_191=b_201[1],
             n$2=caml_call2(Base[114],_a__,b_191);
            if(0 !== n$2)return n$2;
            var _a$_=function(a_194,b_195){return cmp_a(a_194,b_195)};
            return caml_call3(Base[135],_a$_,_a9_,b_193);
           default:return -1}
         break;
        default:
         var _ba_=a_200[1];
         switch(b_201[0])
          {case 0:break;
           case 1:switch$0 = 1;break;
           case 2:switch$0 = 2;break;
           case 3:switch$0 = 3;break;
           case 4:switch$0 = 4;break;
           case 5:switch$0 = 5;break;
           case 6:switch$0 = 6;break;
           case 7:return 1;
           default:var b_197=b_201[1];return caml_call2(Base[114],_ba_,b_197)}}
      switch(switch$0)
       {case 0:return 1;
        case 1:return 1;
        case 2:return 1;
        case 3:return 1;
        case 4:return 1;
        case 5:return 1;
        default:return 1}}
    var t_of_sexp$2=function _aR_(_aQ_){return _aR_.fun(_aQ_)};
    runtime.caml_update_dummy
     (t_of_sexp$2,
      function(sexp_208)
       {if(0 === sexp_208[0])
         {var _aM_=sexp_208[1],switch$0=0;
          if
           (caml_string_notequal(_aM_,cst_Exp)
            &&
            caml_string_notequal(_aM_,cst_exp))
           switch$0 = 1;
          if(! switch$0)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_206,sexp_208)}
        else
         {var _aN_=sexp_208[1];
          if(! _aN_)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[7],error_source_206,sexp_208);
          var _aO_=_aN_[1];
          if(0 !== _aO_[0])
           return caml_call2
                   (Sexplib0_Sexp_conv_error[6],error_source_206,sexp_208);
          var _aP_=_aO_[1],switch$1=0;
          if
           (caml_string_notequal(_aP_,cst_Exp$0)
            &&
            caml_string_notequal(_aP_,cst_exp$0))
           switch$1 = 1;
          if(! switch$1)
           {var sexp_args_210=_aN_[2];
            if(sexp_args_210 && ! sexp_args_210[2])
             {var
               arg0_211=sexp_args_210[1],
               res0_212=t_of_sexp$1(t_of_sexp$2,arg0_211);
              return [0,res0_212]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_206,_aP_,sexp_208)}}
        return caml_call2
                (Sexplib0_Sexp_conv_error[8],error_source_206,sexp_208)});
    function sexp_of_t$3(param)
     {var arg0_213=param[1],res0_214=sexp_of_t$2(sexp_of_t$3,arg0_213);
      return [1,[0,_r_,[0,res0_214,0]]]}
    function equal_t0(x,y){return 0 === compare$1(x,y)?1:0}
    function var$2(x){return [0,[8,x]]}
    function apply$1(d,xs){return [0,[6,d,xs]]}
    function recurse$1(r,xs){return [0,[7,r,xs]]}
    function get_poly_variant$0(param)
     {var _aL_=param[1];
      if(5 !== _aL_[0])return [1,to_string$1(_aL_)];
      var tab=_aL_[1];
      return [0,tab]}
    function opaque$0(t){return t}
    function to_digest$1(param)
     {var e=param[1];return digest_layer(map$0(e,to_digest$1))}
    function to_digest$2(e){return to_digest$1(e)}
    function annotate$0(u,x){return [0,[0,u,x]]}
    function basetype$0(u,xs){return [0,[1,u,xs]]}
    function tuple$0(xs){return [0,[2,xs]]}
    function poly_variant$0(loc,xs)
     {return [0,
              [5,
               create
                (loc,
                 function(_aJ_,_aK_){return equal_option(equal_t0,_aJ_,_aK_)},
                 xs)]]}
    function var$3(n){return [0,[8,n]]}
    function recurse$2(r,xs){return recurse$1(r,xs)}
    function apply$2(d,xs){return apply$1(d,xs)}
    function define$0(x){return x}
    function record$0(xs){return [0,[3,xs]]}
    function variant$0(xs){return [0,[4,xs]]}
    function create$2(exp){return exp}
    var
     Create=
      [0,
       annotate$0,
       basetype$0,
       tuple$0,
       poly_variant$0,
       var$3,
       recurse$2,
       apply$2,
       define$0,
       record$0,
       variant$0,
       create$2];
    function to_string_hum(t)
     {var _aI_=sexp_of_t$3(t);return caml_call2(Base[84][13],0,_aI_)}
    var
     Def$0=[0],
     Exp1=[0,var$2,recurse$1,apply$1,opaque$0,get_poly_variant$0],
     sexp_of_t$4=Base_String[28],
     of_string$1=Base_String[29],
     to_string$2=Base_String[30],
     symbol=Base_String[33],
     compare$2=Base_String[37],
     equal$0=Base_String[121],
     sexp_of_t$5=Base_String[28],
     of_string$2=Base_String[29],
     to_string$3=Base_String[30],
     comparator=Base_String[45],
     compare$3=Base[114],
     sexp_of_t$6=Base[119],
     r=[0,0];
    function group(loc,trips)
     {var u=r[1];
      r[1] = 1 + u | 0;
      function _aH_(param)
       {var t=param[3],vs=param[2],x=param[1];return [0,x,[0,vs,t]]}
      var members=caml_call2(Base_List[76],trips,_aH_);
      return [0,u,loc,members]}
    function lookup(g,tid)
     {var match=caml_call3(Base_List[129][5],g[3],symbol,tid);
      if(match){var scheme=match[1];return scheme}
      var
       _aE_=0,
       _aF_=0,
       _aG_=
        [0,
         [11,
          cst_impossible_lookup_group_un$0,
          [24,
           _x_,
           function(param,custom_printf_285)
            {return caml_call1(to_string$2,custom_printf_285)},
           _aF_]],
         cst_impossible_lookup_group_un];
      return caml_call2(eval_fail(g[2],_aG_),tid,_aE_)}
    function annotate$1(v0,v1){return [0,v0,v1]}
    function basetype$1(v0,v1){return [1,v0,v1]}
    function record$1(v0){return [2,v0]}
    function variant$1(v0){return [3,v0]}
    function tuple$1(v0){return [4,v0]}
    function rec_app(v0,v1){return [7,v0,v1]}
    function top_app(v0,v1,v2){return [8,v0,v1,v2]}
    function of_a_269(param)
     {switch(param[0])
       {case 0:
         var
          arg1_287=param[2],
          arg0_286=param[1],
          res0_288=caml_call1(sexp_of_t$0,arg0_286),
          res1_289=of_a_269(arg1_287);
         return [1,[0,_y_,[0,res0_288,[0,res1_289,0]]]];
        case 1:
         var
          arg1_291=param[2],
          arg0_290=param[1],
          res0_292=caml_call1(sexp_of_t$0,arg0_290),
          res1_293=caml_call2(Base[139],of_a_269,arg1_291);
         return [1,[0,_z_,[0,res0_292,[0,res1_293,0]]]];
        case 2:
         var
          arg0_298=param[1],
          _aB_=
           function(param)
            {var
              arg1_295=param[2],
              arg0_294=param[1],
              res0_296=caml_call1(Base[164],arg0_294),
              res1_297=of_a_269(arg1_295);
             return [1,[0,res0_296,[0,res1_297,0]]]},
          res0_299=caml_call2(Base[139],_aB_,arg0_298);
         return [1,[0,_A_,[0,res0_299,0]]];
        case 3:
         var
          arg0_304=param[1],
          _aC_=
           function(param)
            {var
              arg1_301=param[2],
              arg0_300=param[1],
              res0_302=caml_call1(Base[164],arg0_300),
              res1_303=caml_call2(Base[139],of_a_269,arg1_301);
             return [1,[0,res0_302,[0,res1_303,0]]]},
          res0_305=caml_call2(Base[139],_aC_,arg0_304);
         return [1,[0,_B_,[0,res0_305,0]]];
        case 4:
         var
          arg0_306=param[1],
          res0_307=caml_call2(Base[139],of_a_269,arg0_306);
         return [1,[0,_C_,[0,res0_307,0]]];
        case 5:
         var
          arg0_312=param[1],
          arg1_309=arg0_312[2],
          arg0_308=arg0_312[1],
          res0_310=caml_call1(sexp_of_t,arg0_308),
          _aD_=
           function(param)
            {if(-59723313 <= param[1])
              {var
                v_245=param[2],
                arg1_247=v_245[2],
                arg0_246=v_245[1],
                res0_248=caml_call1(Base[164],arg0_246),
                res1_249=caml_call2(Base[152],of_a_269,arg1_247);
               return [1,[0,_s_,[0,[1,[0,res0_248,[0,res1_249,0]]],0]]]}
             var
              v_250=param[2],
              arg1_252=v_250[2],
              arg0_251=v_250[1],
              res0_253=caml_call1(sexp_of_t,arg0_251),
              res1_254=of_a_269(arg1_252);
             return [1,[0,_t_,[0,[1,[0,res0_253,[0,res1_254,0]]],0]]]},
          res1_311=caml_call2(Base[139],_aD_,arg1_309),
          res0_313=[1,[0,res0_310,[0,res1_311,0]]];
         return [1,[0,_D_,[0,res0_313,0]]];
        case 6:
         var
          arg0_318=param[1],
          arg1_315=arg0_318[2],
          arg0_314=arg0_318[1],
          res0_316=caml_call1(sexp_of_t,arg0_314),
          res1_317=caml_call1(sexp_of_t$5,arg1_315),
          res0_319=[1,[0,res0_316,[0,res1_317,0]]];
         return [1,[0,_E_,[0,res0_319,0]]];
        case 7:
         var
          arg1_321=param[2],
          arg0_320=param[1],
          res0_322=caml_call1(sexp_of_t$4,arg0_320),
          res1_323=caml_call2(Base[139],of_a_269,arg1_321);
         return [1,[0,_F_,[0,res0_322,[0,res1_323,0]]]];
        default:
         var
          arg2_326=param[3],
          arg1_325=param[2],
          arg0_324=param[1],
          members_275=arg0_324[3],
          loc_273=arg0_324[2],
          gid_271=arg0_324[1],
          bnds_270=0,
          _aA_=
           function(param)
            {var
              arg1_282=param[2],
              arg0_281=param[1],
              res0_283=caml_call1(sexp_of_t$4,arg0_281),
              arg1_278=arg1_282[2],
              arg0_277=arg1_282[1],
              res0_279=caml_call2(Base[139],sexp_of_t$5,arg0_277),
              res1_280=of_a_269(arg1_278),
              res1_284=[1,[0,res0_279,[0,res1_280,0]]];
             return [1,[0,res0_283,[0,res1_284,0]]]},
          arg_276=caml_call2(Base[139],_aA_,members_275),
          bnds_270$0=[0,[1,[0,_u_,[0,arg_276,0]]],bnds_270],
          arg_274=caml_call1(sexp_of_t,loc_273),
          bnds_270$1=[0,[1,[0,_v_,[0,arg_274,0]]],bnds_270$0],
          arg_272=caml_call1(sexp_of_t$6,gid_271),
          bnds_270$2=[0,[1,[0,_w_,[0,arg_272,0]]],bnds_270$1],
          res0_327=[1,bnds_270$2],
          res1_328=caml_call1(sexp_of_t$4,arg1_325),
          res2_329=caml_call2(Base[139],of_a_269,arg2_326);
         return [1,[0,_G_,[0,res0_327,[0,res1_328,[0,res2_329,0]]]]]}}
    function constr(s,t){return [0,-59723313,[0,s,t]]}
    function inherit(loc,t){return [0,-72987685,[0,loc,t]]}
    function var$4(loc,t){return [6,[0,loc,t]]}
    function poly_variant$1(loc,xs){return [5,[0,loc,xs]]}
    function is_cyclic_0(via_VR,group,tid)
     {var set=[0,0];
      function visited(tid)
       {return caml_call3(Base_List[6],set[1],tid,equal$0)}
      function trav(param)
       {var param$0=param;
        for(;;)
         {switch(param$0[0])
           {case 0:var param$1=param$0[2],param$0=param$1;continue;
            case 1:var ts=param$0[2];break;
            case 2:
             var xs=param$0[1];
             if(! via_VR)return 0;
             var _aw_=function(param){var t=param[2];return trav(t)};
             return caml_call2(Base_List[9],xs,_aw_);
            case 3:
             var xs$0=param$0[1];
             if(! via_VR)return 0;
             var
              _ax_=
               function(param)
                {var ts=param[2];return caml_call2(Base_List[9],ts,trav)};
             return caml_call2(Base_List[9],xs$0,_ax_);
            case 4:var ts=param$0[1];break;
            case 5:
             var
              match=param$0[1],
              cs=match[2],
              _ay_=
               function(param)
                {if(-59723313 > param[1])
                  {var match=param[2],t$0=match[2];return trav(t$0)}
                 var _az_=param[2][2];
                 if(! _az_)return 0;
                 var t=_az_[1];
                 return trav(t)};
             return caml_call2(Base_List[9],cs,_ay_);
            case 6:return 0;
            case 7:
             var ts$0=param$0[2],tid=param$0[1];
             if(! visited(tid)){set[1] = [0,tid,set[1]];trav_tid(tid)}
             return caml_call2(Base_List[9],ts$0,trav);
            default:var ts=param$0[3]}
          return caml_call2(Base_List[9],ts,trav)}}
      function trav_tid(tid)
       {var match=lookup(group,tid),body=match[2];return trav(body)}
      trav_tid(tid);
      var res=visited(tid);
      return res}
    var _H_=1,_I_=0;
    function Evaluation(Canonical)
     {var _Q_=Base_List[10],_R_=caml_call1(Base_Map[6],[0,comparator]);
      function _S_(t,param)
       {var v=param[2],k=param[1];return caml_call3(Base_Map[28],t,k,v)}
      function create(_av_){return caml_call3(_Q_,_av_,_R_,_S_)}
      function lookup$0(t,k){return caml_call2(Base_Map[36],t,k)}
      var Venv=[0,lookup$0,create],Applicand=[0];
      function compare(a_330,b_331)
       {var
         t_333=a_330[2],
         t_332=a_330[1],
         t_335=b_331[2],
         t_334=b_331[1],
         n=caml_call2(compare$3,t_332,t_334);
        return 0 === n?caml_call2(compare$2,t_333,t_335):n}
      function sexp_of_t(param)
       {var
         arg1_337=param[2],
         arg0_336=param[1],
         res0_338=caml_call1(sexp_of_t$6,arg0_336),
         res1_339=caml_call1(sexp_of_t$4,arg1_337);
        return [1,[0,res0_338,[0,res1_339,0]]]}
      var
       T=[0,compare,sexp_of_t],
       include=caml_call1(Base_Comparator[5],T),
       comparator$0=include[1];
      function find(t,k){return caml_call2(Base_Map[36],t,k)}
      var empty=caml_call1(Base_Map[6],[0,comparator$0]);
      function extend(t,k,v){return caml_call3(Base_Map[28],t,k,v)}
      var Tenv=[0,find,empty,extend];
      function return$0(x,param,tenv){return x}
      function bind(t,f,depth,tenv)
       {var x=caml_call2(t,depth,tenv);
        return caml_call2(caml_call1(f,x),depth,tenv)}
      function look_env(key,param,tenv)
       {var result=caml_call2(Tenv[1],tenv,key);
        function _au_(param){var x=param[2];return [0,x]}
        return caml_call2(Base_Option[21],result,_au_)}
      function extend_new_tid(key,def_t,depth,tenv)
       {var
         value=[0,-271630457,depth],
         tenv$0=caml_call3(Tenv[3],tenv,key,value);
        return [1,caml_call2(def_t,depth + 1 | 0,tenv$0)]}
      function exec(t){return caml_call2(t,0,Tenv[2])}
      var
       Defining=[0,return$0,bind,look_env,extend_new_tid,exec],
       symbol_bind=Defining[2],
       return$1=Defining[1];
      function sequence_defining(xs,f)
       {function loop(acc_ys,param)
         {if(! param)
           return caml_call1(return$1,caml_call1(Base_List[38],acc_ys));
          var xs=param[2],x=param[1];
          function _at_(y){return loop([0,y,acc_ys],xs)}
          return caml_call2(symbol_bind,caml_call1(f,x),_at_)}
        return loop(0,xs)}
      function _T_(group,venv,t)
       {switch(t[0])
         {case 0:
           var
            t$0=t[2],
            s=t[1],
            _af_=
             function(v)
              {return caml_call1(return$1,caml_call2(Canonical[4][1],s,v))};
           return caml_call2(symbol_bind,_T_(group,venv,t$0),_af_);
          case 1:
           var
            ts=t[2],
            s$0=t[1],
            _ag_=
             function(vs)
              {return caml_call1(return$1,caml_call2(Canonical[4][2],s$0,vs))};
           return caml_call2(symbol_bind,eval_list(group,venv,ts),_ag_);
          case 2:
           var
            binds=t[1],
            _ah_=
             function(binds)
              {return caml_call1(return$1,caml_call1(Canonical[4][9],binds))};
           return caml_call2
                   (symbol_bind,
                    sequence_defining
                     (binds,
                      function(param)
                       {var x=param[2],s=param[1];
                        function _as_(y){return caml_call1(return$1,[0,s,y])}
                        return caml_call2(symbol_bind,_T_(group,venv,x),_as_)}),
                    _ah_);
          case 3:
           var
            alts=t[1],
            _ai_=
             function(alts)
              {return caml_call1(return$1,caml_call1(Canonical[4][10],alts))};
           return caml_call2
                   (symbol_bind,
                    sequence_defining
                     (alts,
                      function(param)
                       {var xs=param[2],s=param[1];
                        function _ar_(ys){return caml_call1(return$1,[0,s,ys])}
                        return caml_call2(symbol_bind,eval_list(group,venv,xs),_ar_)}),
                    _ai_);
          case 4:
           var
            ts$0=t[1],
            _aj_=
             function(vs)
              {return caml_call1(return$1,caml_call1(Canonical[4][3],vs))};
           return caml_call2(symbol_bind,eval_list(group,venv,ts$0),_aj_);
          case 5:
           var
            match=t[1],
            cs=match[2],
            loc=match[1],
            _ak_=
             function(xss)
              {var _aq_=caml_call1(Base_List[138],xss);
               return caml_call1
                       (return$1,caml_call2(Canonical[4][4],loc,_aq_))};
           return caml_call2
                   (symbol_bind,
                    sequence_defining
                     (cs,
                      function(_ap_){return eval_poly_constr(group,venv,_ap_)}),
                    _ak_);
          case 6:
           var
            match$0=t[1],
            vid=match$0[2],
            loc$0=match$0[1],
            match$1=caml_call2(Venv[1],venv,vid);
           if(match$1){var x=match$1[1];return caml_call1(return$1,x)}
           var _al_=0,_am_=0;
           return caml_call2
                   (eval_fail
                     (loc$0,
                      [0,
                       [11,
                        cst_Free_type_variable,
                        [24,
                         _J_,
                         function(param,custom_printf_340)
                          {return caml_call1(to_string$3,custom_printf_340)},
                         _am_]],
                       cst_Free_type_variable_Vid]),
                    vid,
                    _al_);
          case 7:
           var
            args=t[2],
            tid=t[1],
            _an_=function(args){return eval_app(group,tid,args)};
           return caml_call2(symbol_bind,eval_list(group,venv,args),_an_);
          default:
           var
            args$0=t[3],
            tid$0=t[2],
            in_group=t[1],
            _ao_=function(args){return eval_app(in_group,tid$0,args)};
           return caml_call2(symbol_bind,eval_list(group,venv,args$0),_ao_)}}
      function eval_list(group,venv,ts)
       {return sequence_defining
                (ts,function(_ae_){return _T_(group,venv,_ae_)})}
      function eval_poly_constr(group,venv,c)
       {if(-59723313 > c[1])
         {var
           match=c[2],
           t$0=match[2],
           loc=match[1],
           _ad_=
            function(v)
             {var match=caml_call1(Canonical[2][5],v);
              if(0 === match[0])
               {var tab=match[1];return caml_call1(return$1,tab[1])}
              var desc=match[1];
              return caml_call2(eval_fail(loc,_K_),desc,0)};
          return caml_call2(symbol_bind,_T_(group,venv,t$0),_ad_)}
        var _$_=c[2],_aa_=_$_[2],_ab_=_$_[1];
        if(! _aa_)return caml_call1(return$1,[0,[0,_ab_,0],0]);
        var t=_aa_[1];
        function _ac_(v)
         {return caml_call1
                  (return$1,[0,[0,_ab_,[0,caml_call1(Canonical[2][4],v)]],0])}
        return caml_call2(symbol_bind,_T_(group,venv,t),_ac_)}
      function eval_definition(group,formals,body)
       {function _Y_(i,x){return [0,x,caml_call1(Canonical[2][1],i)]}
        var
         _Z_=caml_call2(Base_List[96],formals,_Y_),
         venv=caml_call1(Venv[2],_Z_);
        function ___(v)
         {return caml_call1(return$1,caml_call1(Canonical[4][8],v))}
        return caml_call2(symbol_bind,_T_(group,venv,body),___)}
      function eval_app(group,tid,args)
       {var
         gid=group[1],
         match=lookup(group,tid),
         body=match[2],
         formals=match[1];
        switch(body[0])
         {case 2:
          case 3:var record_or_normal_variant=1;break;
          default:var record_or_normal_variant=0}
        var
         cyclic=is_cyclic_0(_H_,group,tid),
         cyclic_no_VR=is_cyclic_0(_I_,group,tid),
         switch$0=0;
        if(record_or_normal_variant && cyclic)switch$0 = 1;
        if(! switch$0 && ! cyclic_no_VR)
         {var match$0=caml_call2(Base_List[94],formals,args);
          if(match$0)
           var x=match$0[1],venv=caml_call1(Venv[2],x);
          else
           var venv=caml_call1(Base[200],cst_apply_incorrect_type_appli);
          return _T_(group,venv,body)}
        function _V_(param)
         {if(0 === param[0])
           {var r=param[1];
            return caml_call1(return$1,caml_call2(Canonical[2][2],r,args))}
          var def=param[1];
          return caml_call1(return$1,caml_call2(Canonical[2][3],def,args))}
        function _W_(param)
         {if(param){var recurse=param[1];return caml_call1(return$1,recurse)}
          var _X_=eval_definition(group,formals,body);
          return caml_call2(Defining[4],[0,gid,tid],_X_)}
        return caml_call2
                (symbol_bind,
                 caml_call2
                  (symbol_bind,caml_call1(Defining[3],[0,gid,tid]),_W_),
                 _V_)}
      function eval$0(t)
       {var
         group$0=group(caml_call1(of_string,cst_top_level),0),
         venv=caml_call1(Venv[2],0),
         _U_=_T_(group$0,venv,t),
         v=caml_call1(Defining[5],_U_);
        return caml_call1(Canonical[4][11],v)}
      return [0,
              Venv,
              Applicand,
              Tenv,
              Defining,
              symbol_bind,
              return$1,
              sequence_defining,
              eval_list,
              eval_poly_constr,
              eval_definition,
              eval_app,
              eval$0]}
    var
     Exp=[0],
     include=Evaluation([0,to_digest$2,Exp1,Def$0,Create]),
     _L_=include[12],
     Evaluation_to_digest=Evaluation(Canonical_digest);
    function eval_to_digest(exp)
     {var _P_=caml_call1(Evaluation_to_digest[12],exp);
      return caml_call1(Canonical_digest[1],_P_)}
    function eval_to_digest_string(exp)
     {return caml_call1(to_hex,eval_to_digest(exp))}
    var
     Not_a_tuple=
      [248,cst_Bin_shape_lib_Bin_shape_Fo,runtime.caml_fresh_oo_id(0)];
    function _M_(param)
     {if(param[1] !== Not_a_tuple)throw [0,Assert_failure,_O_];
      var arg0_341=param[2],res0_342=of_a_269(arg0_341);
      return [1,[0,_N_,[0,res0_342,0]]]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Not_a_tuple,_M_);
    function deconstruct_tuple_exn(t)
     {if(4 !== t[0])throw [0,Not_a_tuple,t];var ts=t[1];return ts}
    var
     Bin_shape_lib_Bin_shape=
      [0,
       of_a_269,
       [0,of_string$1],
       [0,of_string$2],
       [0,of_string],
       [0,of_string$0],
       group,
       tuple$1,
       record$1,
       variant$1,
       constr,
       inherit,
       poly_variant$1,
       rec_app,
       top_app,
       var$4,
       basetype$1,
       annotate$1,
       [0,compare$0,t_of_sexp$0,sexp_of_t$1,to_hex,to_md5,of_md5],
       [0,
        compare$1,
        sexp_of_t$3,
        to_string_hum,
        to_digest$2,
        Exp,
        Def$0,
        [0,
         Create[1],
         Create[2],
         Create[3],
         Create[4],
         Create[5],
         Create[7],
         Create[6],
         Create[8],
         Create[9],
         Create[10],
         Create[11]]],
       _L_,
       eval_to_digest,
       eval_to_digest_string,
       [0,deconstruct_tuple_exn]];
    caml_register_global
     (134,Bin_shape_lib_Bin_shape,"Bin_shape_lib__Bin_shape");
    var Bin_shape_lib_Std=[0];
    caml_register_global(135,Bin_shape_lib_Std,"Bin_shape_lib__Std");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiaW5fc2hhcGVfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJvcl9zb3VyY2VfMDI2IiwiZXJyb3Jfc291cmNlXzA0MiIsImVycm9yX3NvdXJjZV8yMDYiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJ0X29mX3NleHAiLCJzZXhwX29mX3QkMCIsIm9mX3N0cmluZyQwIiwidG9fc3RyaW5nJDAiLCJjb21wYXJlIiwiZXZhbF9mYWlsIiwibG9jIiwiZm10IiwicyIsImN1c3RvbV9wcmludGZfMDAxIiwiZXF1YWxfb3B0aW9uIiwiZXF1YWwiLCJhIiwiYiIsInkiLCJ4IiwiY3JlYXRlIiwiZXEiLCJ4cyQxIiwiczIiLCJzMSIsInBhcmFtJDAiLCJ4cyQwIiwidmFsdWUkMCIsImtleSQwIiwieHMiLCJ2YWx1ZSIsImtleSIsInNvcnRlZCIsIm1hcCIsInQiLCJmIiwidiIsImsiLCJ0b19tZDUiLCJvZl9tZDUiLCJzZXhwX29mX3QkMSIsInRfb2Zfc2V4cCQwIiwidXVpZCIsInUiLCJpbnQkMCIsInBhaXIiLCJsaXN0IiwibCIsImNvbnN0cnVjdG9yIiwidF9vZl9zZXhwJDEiLCJvZl9hXzAzOSIsInNleHBfMDQ0Iiwic2V4cF9hcmdzXzA0NiIsImFyZzFfMDQ4IiwiYXJnMF8wNDciLCJyZXMwXzA0OSIsInJlczFfMDUwIiwic2V4cF9hcmdzXzA1MyIsImFyZzFfMDU1IiwiYXJnMF8wNTQiLCJyZXMwXzA1NiIsInJlczFfMDU3Iiwic2V4cF9hcmdzXzA2MCIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJzZXhwX2FyZ3NfMDY1IiwiYXJnMF8wNzEiLCJzZXhwXzA3MCIsImFyZzFfMDY3IiwiYXJnMF8wNjYiLCJyZXMwXzA2OCIsInJlczFfMDY5IiwicmVzMF8wNzIiLCJzZXhwX2FyZ3NfMDc1IiwiYXJnMF8wODEiLCJzZXhwXzA4MCIsImFyZzFfMDc3IiwiYXJnMF8wNzYiLCJyZXMwXzA3OCIsInJlczFfMDc5IiwicmVzMF8wODIiLCJzZXhwX2FyZ3NfMDg1IiwiYXJnMF8wODYiLCJvZl9hXzAxMCIsInJlczBfMDg3IiwiZmllbGRfc2V4cHNfMDEzIiwic29ydGVkXzAxNCIsImR1cGxpY2F0ZXNfMDE2IiwiZXh0cmFfMDE3IiwidGFpbF8wMjkiLCJ4XzAzMCIsImZpZWxkX3NleHBfMDE5Iiwic2V4cF8wMjUiLCJhcmcxXzAyMiIsImFyZzBfMDIxIiwicmVzMF8wMjMiLCJyZXMxXzAyNCIsImZ2YWx1ZV8wMjciLCJzb3J0ZWRfMDE1Iiwic2V4cF9hcmdzXzA5MCIsImFyZzFfMDkyIiwiYXJnMF8wOTEiLCJyZXMwXzA5MyIsInJlczFfMDk0Iiwic2V4cF9hcmdzXzA5NyIsImFyZzFfMDk5IiwiYXJnMF8wOTgiLCJyZXMwXzEwMCIsInJlczFfMTAxIiwic2V4cF9hcmdzXzEwNCIsImFyZzBfMTA1IiwicmVzMF8xMDYiLCJzZXhwX29mX3QkMiIsIm9mX2FfMTA4IiwiYXJnMV8xMTAiLCJhcmcwXzEwOSIsInJlczBfMTExIiwicmVzMV8xMTIiLCJhcmcxXzExNCIsImFyZzBfMTEzIiwicmVzMF8xMTUiLCJyZXMxXzExNiIsImFyZzBfMTE3IiwicmVzMF8xMTgiLCJhcmcwXzEyMyIsImFyZzFfMTIwIiwiYXJnMF8xMTkiLCJyZXMwXzEyMSIsInJlczFfMTIyIiwicmVzMF8xMjQiLCJhcmcwXzEyOSIsImFyZzFfMTI2IiwiYXJnMF8xMjUiLCJyZXMwXzEyNyIsInJlczFfMTI4IiwicmVzMF8xMzAiLCJhcmcwXzEzMSIsIm9mX2FfMDMxIiwic29ydGVkXzAzMyIsImJuZHNfMDMyIiwiYXJnMV8wMzYiLCJhcmcwXzAzNSIsInJlczBfMDM3IiwicmVzMV8wMzgiLCJhcmdfMDM0IiwiYm5kc18wMzIkMCIsInJlczBfMTMyIiwiYXJnMV8xMzQiLCJhcmcwXzEzMyIsInJlczBfMTM1IiwicmVzMV8xMzYiLCJhcmcxXzEzOCIsImFyZzBfMTM3IiwicmVzMF8xMzkiLCJyZXMxXzE0MCIsImFyZzBfMTQxIiwicmVzMF8xNDIiLCJtYXAkMCIsIngkMCIsImwkMCIsImwkMSIsIngkMSIsImwkMiIsInQkMCIsInRvX3N0cmluZyQxIiwiZGlnZXN0X2xheWVyIiwidSQwIiwidGFibGUiLCJsJDMiLCJsJDQiLCJuIiwibiQwIiwidG9fZGlnZXN0IiwidG9fZGlnZXN0JDAiLCJ4JDIiLCJvcGFxdWUiLCJjcmVhdGUkMCIsImRlc2MiLCJ2YXIkMCIsImFwcGx5IiwiZGVmIiwicmVjdXJzZSIsInRpZCIsImdldF9wb2x5X3ZhcmlhbnQiLCJhbm5vdGF0ZSIsImJhc2V0eXBlIiwidHVwbGUiLCJwb2x5X3ZhcmlhbnQiLCJ2YXIkMSIsImFwcGx5JDAiLCJyZWN1cnNlJDAiLCJkZWZpbmUiLCJyZWNvcmQiLCJ2YXJpYW50IiwiY3JlYXRlJDEiLCJlIiwiY29tcGFyZSQxIiwiYV8xOTgiLCJiXzE5OSIsImJfMjAxIiwiYV8yMDAiLCJjbXBfYSIsImFfMjAyIiwiYl8yMDMiLCJiXzE0OSIsImJfMTQ3IiwiYV8xNDgiLCJiXzE1MyIsImJfMTUxIiwiYV8xNTQiLCJiXzE1NSIsImJfMTU3IiwiYV8xNTgiLCJiXzE1OSIsImJfMTYxIiwiYV8xNjIiLCJiXzE2MyIsInRfMTY1IiwidF8xNjQiLCJ0XzE2NyIsInRfMTY2IiwiYl8xNjkiLCJhXzE3MCIsImJfMTcxIiwidF8xNzMiLCJ0XzE3MiIsInRfMTc1IiwidF8xNzQiLCJhXzE3NiIsImJfMTc3IiwiYl8xNzkiLCJhXzAwNCIsImJfMDA1IiwidF8wMDciLCJ0XzAwNiIsInRfMDA5IiwidF8wMDgiLCJhXzE4MiIsImJfMTgzIiwiYl8xODciLCJiXzE4NSIsIm4kMSIsImFfMTg4IiwiYl8xODkiLCJiXzE5MyIsImJfMTkxIiwibiQyIiwiYV8xOTQiLCJiXzE5NSIsImJfMTk3IiwidF9vZl9zZXhwJDIiLCJzZXhwXzIwOCIsInNleHBfYXJnc18yMTAiLCJhcmcwXzIxMSIsInJlczBfMjEyIiwic2V4cF9vZl90JDMiLCJhcmcwXzIxMyIsInJlczBfMjE0IiwiZXF1YWxfdDAiLCJ2YXIkMiIsImFwcGx5JDEiLCJkIiwicmVjdXJzZSQxIiwiciIsImdldF9wb2x5X3ZhcmlhbnQkMCIsInRhYiIsIm9wYXF1ZSQwIiwidG9fZGlnZXN0JDEiLCJ0b19kaWdlc3QkMiIsImFubm90YXRlJDAiLCJiYXNldHlwZSQwIiwidHVwbGUkMCIsInBvbHlfdmFyaWFudCQwIiwidmFyJDMiLCJyZWN1cnNlJDIiLCJhcHBseSQyIiwiZGVmaW5lJDAiLCJyZWNvcmQkMCIsInZhcmlhbnQkMCIsImNyZWF0ZSQyIiwiZXhwIiwidG9fc3RyaW5nX2h1bSIsInNleHBfb2ZfdCQ0Iiwib2Zfc3RyaW5nJDEiLCJ0b19zdHJpbmckMiIsInN5bWJvbCIsImNvbXBhcmUkMiIsImVxdWFsJDAiLCJzZXhwX29mX3QkNSIsIm9mX3N0cmluZyQyIiwidG9fc3RyaW5nJDMiLCJjb21wYXJhdG9yIiwiY29tcGFyZSQzIiwic2V4cF9vZl90JDYiLCJncm91cCIsInRyaXBzIiwidnMiLCJtZW1iZXJzIiwibG9va3VwIiwiZyIsInNjaGVtZSIsImN1c3RvbV9wcmludGZfMjg1IiwiYW5ub3RhdGUkMSIsInYwIiwidjEiLCJiYXNldHlwZSQxIiwicmVjb3JkJDEiLCJ2YXJpYW50JDEiLCJ0dXBsZSQxIiwicmVjX2FwcCIsInRvcF9hcHAiLCJ2MiIsIm9mX2FfMjY5IiwiYXJnMV8yODciLCJhcmcwXzI4NiIsInJlczBfMjg4IiwicmVzMV8yODkiLCJhcmcxXzI5MSIsImFyZzBfMjkwIiwicmVzMF8yOTIiLCJyZXMxXzI5MyIsImFyZzBfMjk4IiwiYXJnMV8yOTUiLCJhcmcwXzI5NCIsInJlczBfMjk2IiwicmVzMV8yOTciLCJyZXMwXzI5OSIsImFyZzBfMzA0IiwiYXJnMV8zMDEiLCJhcmcwXzMwMCIsInJlczBfMzAyIiwicmVzMV8zMDMiLCJyZXMwXzMwNSIsImFyZzBfMzA2IiwicmVzMF8zMDciLCJhcmcwXzMxMiIsImFyZzFfMzA5IiwiYXJnMF8zMDgiLCJyZXMwXzMxMCIsInZfMjQ1IiwiYXJnMV8yNDciLCJhcmcwXzI0NiIsInJlczBfMjQ4IiwicmVzMV8yNDkiLCJ2XzI1MCIsImFyZzFfMjUyIiwiYXJnMF8yNTEiLCJyZXMwXzI1MyIsInJlczFfMjU0IiwicmVzMV8zMTEiLCJyZXMwXzMxMyIsImFyZzBfMzE4IiwiYXJnMV8zMTUiLCJhcmcwXzMxNCIsInJlczBfMzE2IiwicmVzMV8zMTciLCJyZXMwXzMxOSIsImFyZzFfMzIxIiwiYXJnMF8zMjAiLCJyZXMwXzMyMiIsInJlczFfMzIzIiwiYXJnMl8zMjYiLCJhcmcxXzMyNSIsImFyZzBfMzI0IiwibWVtYmVyc18yNzUiLCJsb2NfMjczIiwiZ2lkXzI3MSIsImJuZHNfMjcwIiwiYXJnMV8yODIiLCJhcmcwXzI4MSIsInJlczBfMjgzIiwiYXJnMV8yNzgiLCJhcmcwXzI3NyIsInJlczBfMjc5IiwicmVzMV8yODAiLCJyZXMxXzI4NCIsImFyZ18yNzYiLCJibmRzXzI3MCQwIiwiYXJnXzI3NCIsImJuZHNfMjcwJDEiLCJhcmdfMjcyIiwiYm5kc18yNzAkMiIsInJlczBfMzI3IiwicmVzMV8zMjgiLCJyZXMyXzMyOSIsImNvbnN0ciIsImluaGVyaXQiLCJ2YXIkNCIsInBvbHlfdmFyaWFudCQxIiwiaXNfY3ljbGljXzAiLCJ2aWFfVlIiLCJzZXQiLCJ2aXNpdGVkIiwidHJhdiIsInBhcmFtJDEiLCJ0cyIsImNzIiwidHMkMCIsInRyYXZfdGlkIiwiYm9keSIsInJlcyIsImxvb2t1cCQwIiwiYV8zMzAiLCJiXzMzMSIsInRfMzMzIiwidF8zMzIiLCJ0XzMzNSIsInRfMzM0IiwiYXJnMV8zMzciLCJhcmcwXzMzNiIsInJlczBfMzM4IiwicmVzMV8zMzkiLCJmaW5kIiwiZW1wdHkiLCJleHRlbmQiLCJyZXR1cm4kMCIsInRlbnYiLCJiaW5kIiwiZGVwdGgiLCJsb29rX2VudiIsInJlc3VsdCIsImV4dGVuZF9uZXdfdGlkIiwiZGVmX3QiLCJ0ZW52JDAiLCJleGVjIiwic3ltYm9sX2JpbmQiLCJyZXR1cm4kMSIsInNlcXVlbmNlX2RlZmluaW5nIiwibG9vcCIsImFjY195cyIsInZlbnYiLCJzJDAiLCJldmFsX2xpc3QiLCJiaW5kcyIsImFsdHMiLCJ5cyIsInhzcyIsImV2YWxfcG9seV9jb25zdHIiLCJ2aWQiLCJsb2MkMCIsImN1c3RvbV9wcmludGZfMzQwIiwiYXJncyIsImV2YWxfYXBwIiwiYXJncyQwIiwidGlkJDAiLCJpbl9ncm91cCIsImMiLCJldmFsX2RlZmluaXRpb24iLCJmb3JtYWxzIiwiaSIsImdpZCIsInJlY29yZF9vcl9ub3JtYWxfdmFyaWFudCIsImN5Y2xpYyIsImN5Y2xpY19ub19WUiIsImV2YWwkMCIsImdyb3VwJDAiLCJldmFsX3RvX2RpZ2VzdCIsImV2YWxfdG9fZGlnZXN0X3N0cmluZyIsImRlY29uc3RydWN0X3R1cGxlX2V4biJdLCJzb3VyY2VzIjpbIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9iaW5fcHJvdC9zaGFwZS9iaW5fc2hhcGUubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvb2NhbWwvc3RyaW5nLm1saSJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBZ0NFQTs7S0FtRUFDOzs7S0FtT0VDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NyVElDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthREhKUSxVQUFVQyxJQUFJQztNQUNoQixjQUFxQkM7UUFBSzs7Ozs7MkJBQTBCQztnQ0NFOUNWLFVERjhDVSxrQkFBaUI7OztTQUFsQyxvQ0FEdkJILElBQ1NFO1FBQWMsaUNBQXlDO01BQTVFLHNDQURnQkQsSUFDaUU7YUFHL0VHLGFBQWFDLE1BQU1DLEVBQUVDO01BQ3ZCLEdBRHFCRDtXQUFFQyxPQUlSQyxFQUpRRCxLQUloQkUsRUFKY0gsdUJBQU5ELE1BSVJJLEVBQVFEOztPQURDLEtBSE9ELEVBR1A7TUFEaUIsUUFFSjthQThCekJHLE9BQU9WLElBQUtXLEdBQUdDO01BQ2pC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LDJCQUFabkssRUFuQlJrTDtjQW9CR3JRO1VBQWMsa0JBOUc3QnNQLFNBOEc2QiwyQkFBZHRQLElBcEJIcVEsTUFvQmdEO1FBUDFEO1VBQ0ksVUFDZ0IsSUFBWHBRLGlCQUFXLGtCQXpHdEJxUCxTQXlHV3JQO1VBRThCLFFBdkJ6QzBRLGdCQU1FekosTUFFRTBKLFFBQVNqRDtVQWU0QixpQ0FoQnJDbUQsSUFESTVRLFNBaUJzRTtRQUo1RTtpQkF4R0ZtUDtpQkF3R0U7bUJBeEdGQSxZQXdHRSwwQkFaRXlCLElBREk1UTtxQkEyQmU7TUEvSmIsU0FtS1ZnUixPQUNFcGE7UUFDVTtpQkFoUlpvUSxNQWdSa0IsV0NodEJoQnBTO1NEaXRCUztTQUNXLFFBRmxCcWMsUUFDQXpCLEtBRkY1WTtTQUdNOzJDQUFKRSxFQUNxQjtNQXhLZjs7Ozs7Y0F5Q1ZxWTtjQUNBQztjQUVBQztjQTBEQUs7Y0FHQUs7Y0FxQkFVO2NBS0FMO2NBZ0NBWTtJQXpObUM7OzJCQXZNL0IxTDtLQXVNK0I7O2FBOE9yQzRMLGVBQWVoTDtNQUFtQyw0Q0FBbkNBO01BQW1DLDBDQUErQjtJQTlPNUMsU0ErT3JDaUwsc0JBQXNCakw7TUFBb0IseUJBRDFDZ0wsZUFDc0JoTCxLQUF3QztJQS9PekI7Ozs7TTtxQ0E5RmhDZ0M7OzthQWtWSGtKLHNCQUFzQnhhO01BQ3hCLFNBRHdCQSxLQUdqQixxQkFIaUJBLEdBRVYsSUFBTnlXLEdBRmdCelcsS0FFVixPQUFOeVcsRUFDb0I7Ozs7T0FyVnZCbkY7VUN2WkQ3Qjs7OztPRGdjRlc7T0FkSmM7OztPQWtCSTZFO09BQ0FDO09BRUFFO09BckJKL0U7O09Bb0JJOEU7T0FFQWxGO09BdEJKSDtvQkFoWElyUSxZQURBRCxtQkFGQUYsT0FDQUM7O1FBNE9KNko7O1FBSUFxRjtRQUZRYjs7Ozs7Ozs7Ozs7Ozs7OztPQXFiTjRMO09BQ0FDO1VBS0VDOzs7OztVIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG5tb2R1bGUgTG9jYXRpb24gOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubW9kdWxlIFV1aWQgOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubGV0IGV2YWxfZmFpbCBsb2MgZm10ID1cbiAgUHJpbnRmLmtzcHJpbnRmIChmdW4gcyAtPiBmYWlsd2l0aCAoUHJpbnRmLnNwcmludGYgIVwiJXtMb2NhdGlvbn06ICVzXCIgbG9jIHMpKSBmbXRcbjs7XG5cbmxldCBlcXVhbF9vcHRpb24gZXF1YWwgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgU29tZSBfLCBOb25lIHwgTm9uZSwgU29tZSBfIC0+IGZhbHNlXG4gIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4LCBTb21lIHkgLT4gZXF1YWwgeCB5XG47O1xuXG5tb2R1bGUgU29ydGVkX3RhYmxlIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIHZhbCBjcmVhdGUgOiBMb2NhdGlvbi50IC0+IGVxOignYSAtPiAnYSAtPiBib29sKSAtPiAoc3RyaW5nICogJ2EpIGxpc3QgLT4gJ2EgdFxuICB2YWwgZXhwb3NlIDogJ2EgdCAtPiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSB7IHNvcnRlZCA6IChzdHJpbmcgKiAnYSkgbGlzdCB9IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgbGV0IG1lcmdlX2NoZWNrX2FkamFjZW50X2R1cHNcbiAgICA6ICBlcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKHN0cmluZyAqICdhKSBsaXN0XG4gICAgICAtPiBbIGBPayBvZiAoc3RyaW5nICogJ2EpIGxpc3QgfCBgTWlzbWF0Y2ggb2Ygc3RyaW5nIF1cbiAgICA9XG4gICAgZnVuIH5lcSAtPlxuICAgIGxldCByZWMgbG9vcCBhY2Mgfmxhc3Rfa2V5IH5sYXN0X3ZhbHVlID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYE9rIChMaXN0LnJldiBhY2MpXG4gICAgICB8IChrZXksIHZhbHVlKSA6OiB4cyAtPlxuICAgICAgICBpZiBTdHJpbmcuKGxhc3Rfa2V5ID0ga2V5KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgZXEgbGFzdF92YWx1ZSB2YWx1ZSB0aGVuIGxvb3AgYWNjIH5sYXN0X2tleSB+bGFzdF92YWx1ZSB4cyBlbHNlIGBNaXNtYXRjaCBrZXlcbiAgICAgICAgZWxzZSBsb29wICgoa2V5LCB2YWx1ZSkgOjogYWNjKSB+bGFzdF9rZXk6a2V5IH5sYXN0X3ZhbHVlOnZhbHVlIHhzXG4gICAgaW5cbiAgICBmdW5jdGlvblxuICAgIHwgW10gLT4gYE9rIFtdXG4gICAgfCAoa2V5LCB2YWx1ZSkgOjogeHMgLT4gbG9vcCBbIGtleSwgdmFsdWUgXSB+bGFzdF9rZXk6a2V5IH5sYXN0X3ZhbHVlOnZhbHVlIHhzXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBsb2MgfmVxIHhzID1cbiAgICBsZXQgc29ydGVkID0gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKHMxLCBfKSAoczIsIF8pIC0+IFN0cmluZy5jb21wYXJlIHMxIHMyKSB4cyBpblxuICAgIG1hdGNoIG1lcmdlX2NoZWNrX2FkamFjZW50X2R1cHMgfmVxIHNvcnRlZCB3aXRoXG4gICAgfCBgT2sgc29ydGVkIC0+IHsgc29ydGVkIH1cbiAgICB8IGBNaXNtYXRjaCBzIC0+XG4gICAgICBldmFsX2ZhaWwgbG9jIFwiRGlmZmVyZW50IHNoYXBlcyBmb3IgZHVwbGljYXRlZCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3RvcjogYCVzXCIgcyAoKVxuICA7O1xuXG4gIGxldCBleHBvc2UgdCA9IHQuc29ydGVkXG4gIGxldCBtYXAgdCB+ZiA9IHsgc29ydGVkID0gTGlzdC5tYXAgdC5zb3J0ZWQgfmY6KGZ1biAoaywgdikgLT4gaywgZiB2KSB9XG5lbmRcblxubW9kdWxlIERpZ2VzdCA6IHNpZ1xuICB0eXBlIHQgPSBNZDVfbGliLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICB2YWwgdG9fbWQ1IDogdCAtPiBNZDVfbGliLnRcbiAgdmFsIG9mX21kNSA6IE1kNV9saWIudCAtPiB0XG4gIHZhbCB0b19oZXggOiB0IC0+IHN0cmluZ1xuICB2YWwgY29uc3RydWN0b3IgOiBzdHJpbmcgLT4gdCBsaXN0IC0+IHRcbiAgdmFsIGxpc3QgOiB0IGxpc3QgLT4gdFxuICB2YWwgcGFpciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdHJpbmcgOiBzdHJpbmcgLT4gdFxuICB2YWwgdXVpZCA6IFV1aWQudCAtPiB0XG4gIHZhbCBpbnQgOiBpbnQgLT4gdFxuICB2YWwgb3B0aW9uIDogdCBvcHRpb24gLT4gdFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgTWQ1X2xpYlxuXG4gIGxldCB0b19tZDUgdCA9IHRcbiAgbGV0IG9mX21kNSB0ID0gdFxuICBsZXQgc2V4cF9vZl90IHQgPSB0IHw+IHRvX2hleCB8PiBzZXhwX29mX3N0cmluZ1xuICBsZXQgdF9vZl9zZXhwIHMgPSBzIHw+IHN0cmluZ19vZl9zZXhwIHw+IG9mX2hleF9leG5cbiAgbGV0IHV1aWQgdSA9IHN0cmluZyAoVXVpZC50b19zdHJpbmcgdSlcbiAgbGV0IGludCB4ID0gc3RyaW5nIChJbnQudG9fc3RyaW5nIHgpXG4gIGxldCBwYWlyIHggeSA9IHN0cmluZyAodG9fYmluYXJ5IHggXiB0b19iaW5hcnkgeSlcbiAgbGV0IGxpc3QgbCA9IHN0cmluZyAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgKExpc3QubWFwIH5mOnRvX2JpbmFyeSBsKSlcbiAgbGV0IGNvbnN0cnVjdG9yIHMgbCA9IHN0cmluZyAocyBeIHRvX2JpbmFyeSAobGlzdCBsKSlcblxuICBsZXQgb3B0aW9uID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gY29uc3RydWN0b3IgXCJub25lXCIgW11cbiAgICB8IFNvbWUgeCAtPiBjb25zdHJ1Y3RvciBcInNvbWVcIiBbIHggXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yID0gc3RydWN0XG4gICgqIFsnYSB0XSBpcyBhIG5vbi1yZWN1cnNpdmUgdHlwZSwgdXNlZCB0byByZXByZXNlbnQgMS1sYXllciBvZiBleHByZXNzaW9uLiAgVGhlXG4gICAgIHJlY3Vyc2l2ZSBrbm90IGlzIHRpZWQgYmVsb3cgaW4gW0Nhbm9uaWNhbF9mdWxsLkV4cC50XS4gKilcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEFubm90YXRlIG9mIFV1aWQudCAqICdhXG4gICAgfCBCYXNlIG9mIFV1aWQudCAqICdhIGxpc3RcbiAgICB8IFR1cGxlIG9mICdhIGxpc3RcbiAgICB8IFJlY29yZCBvZiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgICB8IFZhcmlhbnQgb2YgKHN0cmluZyAqICdhIGxpc3QpIGxpc3RcbiAgICAoKiBQb2x5bW9ycGhpYyB2YXJpYW50cyBhcmUgaW5zZW5zaXRpdmUgdG8gdGhlIG9yZGVyIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGxpc3RlZCAqKVxuICAgIHwgUG9seV92YXJpYW50IG9mICdhIG9wdGlvbiBTb3J0ZWRfdGFibGUudFxuICAgICgqIExlZnQtaGFuZC1zaWRlIG9mIFtBcHBsaWNhdGlvbl0gaXMgYSBwb3RlbnRpYWxseSByZWN1cnNpdmUgZGVmaW5pdGlvbjogaXRcbiAgICAgICBjYW4gcmVmZXIgdG8gaXRzZWxmIHVzaW5nIFtSZWNfYXBwIChpLCBfKV0gd2hlcmUgW2ldIGlzIHRoZSBkZXB0aCBvZiB0aGlzXG4gICAgICAgYXBwbGljYXRpb24gbm9kZSAoaG93IG1hbnkgYXBwbGljYXRpb24gbm9kZXMgYXJlIGFib3ZlIGl0KS5cbiAgICAgICBJdCBhbHNvIGhhcyBpdHMgb3duIHNjb3BlIG9mIHR5cGUgdmFyaWFibGVzIHNvIGl0IGNhbiBub3QgcmVmZXIgdG8gdHlwZSB2YXJpYWJsZXNcbiAgICAgICBvZiB0aGUgZW5jbG9zaW5nIHNjb3BlLlxuICAgICopXG4gICAgfCBBcHBsaWNhdGlvbiBvZiAnYSAqICdhIGxpc3RcbiAgICB8IFJlY19hcHAgb2YgaW50ICogJ2EgbGlzdFxuICAgIHwgVmFyIG9mIGludFxuICBbQEBkZXJpdmluZyBzZXhwLCBjb21wYXJlXVxuXG4gIGxldCBtYXAgeCB+ZiA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBBbm5vdGF0ZSAodSwgeCkgLT4gQW5ub3RhdGUgKHUsIGYgeClcbiAgICB8IEJhc2UgKHMsIHhzKSAtPiBCYXNlIChzLCBMaXN0Lm1hcCB+ZiB4cylcbiAgICB8IFR1cGxlIHhzIC0+IFR1cGxlIChMaXN0Lm1hcCB+ZiB4cylcbiAgICB8IFJlY29yZCBsIC0+IFJlY29yZCAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCB4KSAtPiBzLCBmIHgpKVxuICAgIHwgVmFyaWFudCBsIC0+IFZhcmlhbnQgKExpc3QubWFwIGwgfmY6KGZ1biAocywgeHMpIC0+IHMsIExpc3QubWFwIH5mIHhzKSlcbiAgICB8IFBvbHlfdmFyaWFudCB0IC0+IFBvbHlfdmFyaWFudCAoU29ydGVkX3RhYmxlLm1hcCB0IH5mOihPcHRpb24ubWFwIH5mKSlcbiAgICB8IEFwcGxpY2F0aW9uICh4LCBsKSAtPiBBcHBsaWNhdGlvbiAoZiB4LCBMaXN0Lm1hcCB+ZiBsKVxuICAgIHwgUmVjX2FwcCAodCwgbCkgLT4gUmVjX2FwcCAodCwgTGlzdC5tYXAgfmYgbClcbiAgICB8IFZhciB2IC0+IFZhciB2XG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gU2V4cC50b19zdHJpbmcgKHNleHBfb2ZfdCAoZnVuIF8gLT4gQXRvbSBcIi4uLlwiKSB0KVxuZW5kXG5cbm1vZHVsZSBDcmVhdGVfZGlnZXN0IDogc2lnXG4gICgqIERpZ2VzdCB2YXJpb3VzIGV4cHJlc3Npb24gZm9ybXMgKilcblxuICB2YWwgZGlnZXN0X2xheWVyIDogRGlnZXN0LnQgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci50IC0+IERpZ2VzdC50XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGRpZ2VzdF9sYXllciA9IGZ1bmN0aW9uXG4gICAgfCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLkFubm90YXRlICh1LCB4KSAtPlxuICAgICAgRGlnZXN0LmNvbnN0cnVjdG9yIFwiYW5ub3RhdGVcIiBbIERpZ2VzdC51dWlkIHU7IHggXVxuICAgIHwgQmFzZSAodSwgbCkgLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwiYmFzZVwiIFsgRGlnZXN0LnV1aWQgdTsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBUdXBsZSBsIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcInR1cGxlXCIgWyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFJlY29yZCBsIC0+XG4gICAgICBEaWdlc3QuY29uc3RydWN0b3JcbiAgICAgICAgXCJyZWNvcmRcIlxuICAgICAgICBbIERpZ2VzdC5saXN0IChMaXN0Lm1hcCBsIH5mOihmdW4gKHMsIHQpIC0+IERpZ2VzdC5wYWlyIChEaWdlc3Quc3RyaW5nIHMpIHQpKSBdXG4gICAgfCBWYXJpYW50IGwgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvclxuICAgICAgICBcInZhcmlhbnRcIlxuICAgICAgICBbIERpZ2VzdC5saXN0XG4gICAgICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCBsKSAtPiBEaWdlc3QucGFpciAoRGlnZXN0LnN0cmluZyBzKSAoRGlnZXN0Lmxpc3QgbCkpKVxuICAgICAgICBdXG4gICAgfCBQb2x5X3ZhcmlhbnQgdGFibGUgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvclxuICAgICAgICBcInBvbHlfdmFyaWFudFwiXG4gICAgICAgIFsgRGlnZXN0Lmxpc3RcbiAgICAgICAgICAgIChMaXN0Lm1hcCAoU29ydGVkX3RhYmxlLmV4cG9zZSB0YWJsZSkgfmY6KGZ1biAoeCwgeSkgLT5cbiAgICAgICAgICAgICAgIERpZ2VzdC5wYWlyIChEaWdlc3Quc3RyaW5nIHgpIChEaWdlc3Qub3B0aW9uIHkpKSlcbiAgICAgICAgXVxuICAgIHwgQXBwbGljYXRpb24gKHgsIGwpIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcImFwcGxpY2F0aW9uXCIgWyB4OyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFJlY19hcHAgKG4sIGwpIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcInJlY19hcHBcIiBbIERpZ2VzdC5pbnQgbjsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBWYXIgbiAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJ2YXJcIiBbIERpZ2VzdC5pbnQgbiBdXG4gIDs7XG5lbmRcblxubW9kdWxlIFZpc2liaWxpdHkgPSBzdHJ1Y3RcbiAgdHlwZSB2aXNpYmxlID0gVmlzaWJsZVxuICB0eXBlIG9wYXF1ZSA9IE9wYXF1ZVxuXG4gIGxldCBfID0gVmlzaWJsZVxuICBsZXQgXyA9IE9wYXF1ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIENhbm9uaWNhbCA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9fZGlnZXN0IDogdCAtPiBEaWdlc3QudFxuXG4gIG1vZHVsZSBFeHAxIDogc2lnXG4gICAgdHlwZSBfIHRcblxuICAgIHZhbCB2YXIgOiBpbnQgLT4gXyB0XG4gICAgdmFsIHJlY3Vyc2UgOiBpbnQgLT4gXyB0IGxpc3QgLT4gXyB0XG4gICAgdmFsIGFwcGx5IDogJ2EgdCAtPiAnYSB0IGxpc3QgLT4gXyB0XG4gICAgdmFsIG9wYXF1ZSA6IF8gdCAtPiBWaXNpYmlsaXR5Lm9wYXF1ZSB0XG5cbiAgICB2YWwgZ2V0X3BvbHlfdmFyaWFudFxuICAgICAgOiAgVmlzaWJpbGl0eS52aXNpYmxlIHRcbiAgICAgIC0+IChWaXNpYmlsaXR5Lm9wYXF1ZSB0IG9wdGlvbiBTb3J0ZWRfdGFibGUudCwgc3RyaW5nKSBSZXN1bHQudFxuICBlbmRcblxuICBtb2R1bGUgRGVmIDogc2lnXG4gICAgdHlwZSB0ID0gVmlzaWJpbGl0eS52aXNpYmxlIEV4cDEudFxuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlIDogc2lnXG4gICAgdmFsIGFubm90YXRlIDogVXVpZC50IC0+IF8gRXhwMS50IC0+IF8gRXhwMS50XG4gICAgdmFsIGJhc2V0eXBlIDogVXVpZC50IC0+IF8gRXhwMS50IGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgdHVwbGUgOiBfIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHBvbHlfdmFyaWFudCA6IExvY2F0aW9uLnQgLT4gKHN0cmluZyAqIF8gRXhwMS50IG9wdGlvbikgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCB2YXIgOiBpbnQgLT4gXyBFeHAxLnRcbiAgICB2YWwgcmVjdXJzZSA6IGludCAtPiBfIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIGFwcGx5IDogJ2EgRXhwMS50IC0+ICdhIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIGRlZmluZSA6IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnQgLT4gRGVmLnRcbiAgICB2YWwgcmVjb3JkIDogKHN0cmluZyAqIF8gRXhwMS50KSBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHZhcmlhbnQgOiAoc3RyaW5nICogXyBFeHAxLnQgbGlzdCkgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCBjcmVhdGUgOiBfIEV4cDEudCAtPiB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWxfZGlnZXN0IDogQ2Fub25pY2FsID0gc3RydWN0XG4gIHR5cGUgdCA9IENhbm9uaWNhbCBvZiBEaWdlc3QudFxuXG4gIGxldCB0b19kaWdlc3QgKENhbm9uaWNhbCB4KSA9IHhcblxuICBtb2R1bGUgQ0QgPSBDcmVhdGVfZGlnZXN0XG5cbiAgbW9kdWxlIEV4cDEgPSBzdHJ1Y3RcbiAgICB0eXBlIG9wYXF1ZSA9IERpZ2VzdC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBQb2x5X3ZhcmlhbnQgb2Ygb3BhcXVlIG9wdGlvbiBTb3J0ZWRfdGFibGUudFxuICAgICAgfCBOb25fcG9seV92YXJpYW50IG9mIChzdHJpbmcgKiBvcGFxdWUpXG4gICAgICB8IE9wYXF1ZSA6IG9wYXF1ZSAtPiBWaXNpYmlsaXR5Lm9wYXF1ZSB0XG5cbiAgICBsZXQgdG9fZGlnZXN0ICh0eXBlIGEpICh4IDogYSB0KSA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgT3BhcXVlIHggLT4geFxuICAgICAgfCBOb25fcG9seV92YXJpYW50IChfLCB4KSAtPiB4XG4gICAgICB8IFBvbHlfdmFyaWFudCB4IC0+IENELmRpZ2VzdF9sYXllciAoUG9seV92YXJpYW50IHgpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCAodHlwZSBhKSAoeCA6IGEgdCkgKHkgOiBhIHQpID1cbiAgICAgIERpZ2VzdC5jb21wYXJlICh0b19kaWdlc3QgeCkgKHRvX2RpZ2VzdCB5KSA9IDBcbiAgICA7O1xuXG4gICAgbGV0IG9wYXF1ZSB4ID0gT3BhcXVlICh0b19kaWdlc3QgeClcblxuICAgIGxldCBjcmVhdGUgeCA9XG4gICAgICBsZXQgeCA9IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IubWFwIH5mOnRvX2RpZ2VzdCB4IGluXG4gICAgICBsZXQgZGVzYyA9IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudG9fc3RyaW5nIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlBvbHlfdmFyaWFudCBsIC0+IFBvbHlfdmFyaWFudCBsXG4gICAgICB8IEJhc2UgXyAtPiBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICAgIHwgQW5ub3RhdGUgXyAtPlxuICAgICAgICAoKiBJdCdzIHVuc2FmZSB0byB1c2UgZGVyaXZpbmcgYmluX2lvIHdoZW4gaW5oZXJpdGluZyBmcm9tIGEgcG9seW1vcnBoaWMgdmFyaWFudFxuICAgICAgICAgICB0aGF0IGhhcyBhIGN1c3RvbSBiaW5faW8uICBJZiB3ZSBmb3JiaWQgdGhhdCwgd2UgY2FuIGhhcHBpbHkgcmVqZWN0IGhlcmVcbiAgICAgICAgICAgYW55dGhpbmcgdGhhdCdzIGFubm90YXRlZC4gKilcbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IEFwcGxpY2F0aW9uIF8gLT5cbiAgICAgICAgKCogQXBwbGljYXRpb24gY2FuIHJlYWxseSBiZSBhIHBvbHktdmFyaWFudCB5b3UgY2FuIGluaGVyaXQgZnJvbSEgIEJ1dCBpdCdzIGFcbiAgICAgICAgICAgcmFyZSBzaXR1YXRpb24gdGhhdCBtb3N0bHkgKG9ubHk/KSBhcmlzZXMgd2l0aCBpbmhlcml0YW5jZSBmcm9tIHJlY3Vyc2l2ZVxuICAgICAgICAgICBwb2x5bW9ycGljIHZhcmlhbnRzLCB3aGljaCB3ZSd2ZSBub3Qgc2VlbiBhbnl3aGVyZSB5ZXQuICBTbyB3ZSByZWplY3QgaXQuICopXG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgICAgfCBSZWNfYXBwIF8gLT5cbiAgICAgICAgKCogWW91IGNhbiBvbmx5IGdldCB0aGUgW1JlY19hcHBdIGNvbnN0cnVjdG9yIGZvciB0eXBlLXJlZmVyZW5jZXMgd2l0aGluIHRoZVxuICAgICAgICAgICBtdXR1YWwgZ3JvdXAgYmVpbmcgZGVmaW5lZC4gUmVmZXJlbmNlcyB3aGljaFxuICAgICAgICAgICBmb2xsb3cgYWZ0ZXIgdGhlIGN1cnJlbnQgZ3JvdXAgd2lsbCBhbHdheXMgYmUgW0FwcGxpY2F0aW9uXXMuXG5cbiAgICAgICAgICAgQW5kIHNpbmNlIG9jYW1sIHJlamVjdHMgcmVmZXJlbmNlcyBpbiBgaW5oZXJpdGFuY2UnIHBvc2l0aW9uIHRvIHR5cGVzIHdpdGhpblxuICAgICAgICAgICB0aGUgY3VycmVudCBncm91cCAoc2VlIGV4YW1wbGUpIHdpdGg6XG5cbiAgICAgICAgICAgRXJyb3I6IFRoZSB0eXBlIGNvbnN0cnVjdG9yIHRcbiAgICAgICAgICAgaXMgbm90IHlldCBjb21wbGV0ZWx5IGRlZmluZWRcblxuICAgICAgICAgICB0aGVuIGl0cyBvayB0byBzYXkgdGhhdCBhIHJlYy1hcHAgaXMgc29tZXRoaW5nIHRoYXQgY2FuJ3QgYmUgaW5oZXJpdGVkIGZyb20gYW5kXG4gICAgICAgICAgIHJldHVybiBbTm9uX3BvbHlfdmFyaWFudF0uXG5cbiAgICAgICAgICAgQW5kIHVubGlrZSB0aGUgW0FwcGxpY2F0aW9uXSBjYXNlLCBpdCBzaG91bGQgbmV2ZXIgYmUgcG9zc2libGUgdG8gc2VlXG4gICAgICAgICAgIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGUgW2Rlc2NdID0gW1JlY19hcHBdLlxuXG4gICAgICAgICAgIEV4YW1wbGU6IFt0eXBlIHQgPSBbYGEgb2YgWyB8IHRdIF1dXG4gICAgICAgICAgIEhlcmUsIFt8IHRdIHdvdWxkIGJlIGFuIGV4YW1wbGUgb2YgaW5oZXJpdGFuY2UgZnJvbSBhIFJlY19hcHAsIHdoaWNoXG4gICAgICAgICAgIGlzIHJlamVjdGVkIGJ5IHRoZSBjb21waWxlci5cbiAgICAgICAgKilcbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IFZhciBfIHwgVHVwbGUgXyB8IFJlY29yZCBfIHwgVmFyaWFudCBfIC0+XG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgIDs7XG5cbiAgICBsZXQgdmFyIHggPSBjcmVhdGUgKFZhciB4KVxuICAgIGxldCBhcHBseSBkZWYgbCA9IGNyZWF0ZSAoQXBwbGljYXRpb24gKGRlZiwgbCkpXG4gICAgbGV0IHJlY3Vyc2UgdGlkIGwgPSBjcmVhdGUgKFJlY19hcHAgKHRpZCwgbCkpXG5cbiAgICBsZXQgZ2V0X3BvbHlfdmFyaWFudCAoeCA6IFZpc2liaWxpdHkudmlzaWJsZSB0KSA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgXykgLT4gRXJyb3IgZGVzY1xuICAgICAgfCBQb2x5X3ZhcmlhbnQgbCAtPiBPayAoU29ydGVkX3RhYmxlLm1hcCB+ZjooT3B0aW9uLm1hcCB+ZjooZnVuIHggLT4gT3BhcXVlIHgpKSBsKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBEZWYgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBWaXNpYmlsaXR5LnZpc2libGUgRXhwMS50XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgYW5ub3RhdGUgdSB4ID0gRXhwMS5jcmVhdGUgKEFubm90YXRlICh1LCB4KSlcbiAgICBsZXQgYmFzZXR5cGUgdSBsID0gRXhwMS5jcmVhdGUgKEJhc2UgKHUsIGwpKVxuICAgIGxldCB0dXBsZSBsID0gRXhwMS5jcmVhdGUgKFR1cGxlIGwpXG5cbiAgICBsZXQgcG9seV92YXJpYW50IGxvYyBsID1cbiAgICAgIEV4cDEuY3JlYXRlIChQb2x5X3ZhcmlhbnQgKFNvcnRlZF90YWJsZS5jcmVhdGUgbG9jIH5lcTooZXF1YWxfb3B0aW9uIEV4cDEuZXF1YWwpIGwpKVxuICAgIDs7XG5cbiAgICBsZXQgdmFyIHggPSBFeHAxLmNyZWF0ZSAoVmFyIHgpXG4gICAgbGV0IGFwcGx5IHggbCA9IEV4cDEuY3JlYXRlIChBcHBsaWNhdGlvbiAoeCwgbCkpXG4gICAgbGV0IHJlY3Vyc2UgdCBsID0gRXhwMS5jcmVhdGUgKFJlY19hcHAgKHQsIGwpKVxuICAgIGxldCBkZWZpbmUgeCA9IHhcbiAgICBsZXQgcmVjb3JkIGwgPSBFeHAxLmNyZWF0ZSAoUmVjb3JkIGwpXG4gICAgbGV0IHZhcmlhbnQgbCA9IEV4cDEuY3JlYXRlIChWYXJpYW50IGwpXG4gICAgbGV0IGNyZWF0ZSBlID0gQ2Fub25pY2FsIChFeHAxLnRvX2RpZ2VzdCBlKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ2Fub25pY2FsX2Z1bGwgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgaW5jbHVkZSBDYW5vbmljYWwgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCB0b19zdHJpbmdfaHVtIDogdCAtPiBzdHJpbmdcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgQ0QgPSBDcmVhdGVfZGlnZXN0XG5cbiAgbW9kdWxlIEV4cDEgPSBzdHJ1Y3RcbiAgICB0eXBlIHQwID0gRXhwIG9mIHQwIENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gICAgbGV0IGVxdWFsX3QwIHggeSA9IGNvbXBhcmVfdDAgeCB5ID0gMFxuXG4gICAgdHlwZSAnYSB0ID0gdDAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICAgIGxldCB2YXIgeCA9IEV4cCAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5WYXIgeClcbiAgICBsZXQgYXBwbHkgZCB4cyA9IEV4cCAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5BcHBsaWNhdGlvbiAoZCwgeHMpKVxuICAgIGxldCByZWN1cnNlIHIgeHMgPSBFeHAgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuUmVjX2FwcCAociwgeHMpKVxuXG4gICAgbGV0IHBvbHlfdmFyaWFudCBsb2MgeHMgPVxuICAgICAgRXhwXG4gICAgICAgIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlBvbHlfdmFyaWFudFxuICAgICAgICAgICAoU29ydGVkX3RhYmxlLmNyZWF0ZSBsb2MgfmVxOihlcXVhbF9vcHRpb24gZXF1YWxfdDApIHhzKSlcbiAgICA7O1xuXG4gICAgbGV0IGdldF9wb2x5X3ZhcmlhbnQgPSBmdW5jdGlvblxuICAgICAgfCBFeHAgKFBvbHlfdmFyaWFudCB0YWIpIC0+IE9rIHRhYlxuICAgICAgfCBFeHAgY2MgLT4gRXJyb3IgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudG9fc3RyaW5nIGNjKVxuICAgIDs7XG5cbiAgICBsZXQgb3BhcXVlIHQgPSB0XG5cbiAgICBsZXQgcmVjIHRvX2RpZ2VzdCA9IGZ1bmN0aW9uXG4gICAgICB8IEV4cCBlIC0+IENELmRpZ2VzdF9sYXllciAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5tYXAgfmY6dG9fZGlnZXN0IGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIERlZiA9IHN0cnVjdFxuICAgICgqIEEgW0RlZi50XSBpcyBhbiBleHByZXNzaW9uIHdoaWNoIG1heSBiZSBhcHBsaWVkICopXG4gICAgdHlwZSB0ID0gRXhwMS50MCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuICBlbmRcblxuICAoKiBBIGNhbm9uaWNhbCBzaGFwZSBbdF0gaXMgYW4gW0V4cDEudF0uICopXG4gIHR5cGUgdCA9IEV4cDEudDAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgdG9fZGlnZXN0IGUgPSBFeHAxLnRvX2RpZ2VzdCBlXG5cbiAgbW9kdWxlIENyZWF0ZSA9IHN0cnVjdFxuICAgIGxldCBhbm5vdGF0ZSB1IHggPSBFeHAxLkV4cCAoQW5ub3RhdGUgKHUsIHgpKVxuICAgIGxldCBiYXNldHlwZSB1IHhzID0gRXhwMS5FeHAgKEJhc2UgKHUsIHhzKSlcbiAgICBsZXQgdHVwbGUgeHMgPSBFeHAxLkV4cCAoVHVwbGUgeHMpXG4gICAgbGV0IHBvbHlfdmFyaWFudCBsb2MgeHMgPSBFeHAxLnBvbHlfdmFyaWFudCBsb2MgeHNcbiAgICBsZXQgdmFyIG4gPSBFeHAxLkV4cCAoVmFyIG4pXG4gICAgbGV0IHJlY3Vyc2UgciB4cyA9IEV4cDEucmVjdXJzZSByIHhzXG4gICAgbGV0IGFwcGx5IGQgeHMgPSBFeHAxLmFwcGx5IGQgeHNcbiAgICBsZXQgZGVmaW5lIHggPSB4XG4gICAgbGV0IHJlY29yZCB4cyA9IEV4cDEuRXhwIChSZWNvcmQgeHMpXG4gICAgbGV0IHZhcmlhbnQgeHMgPSBFeHAxLkV4cCAoVmFyaWFudCB4cylcbiAgICBsZXQgY3JlYXRlIGV4cCA9IGV4cFxuICBlbmRcblxuICBsZXQgdG9fc3RyaW5nX2h1bSB0ID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX3QgdClcbmVuZFxuXG5tb2R1bGUgVGlkIDogc2lnXG4gIGluY2x1ZGUgSWRlbnRpZmlhYmxlLlNcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuZW5kXG5cbm1vZHVsZSBWaWQgOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubW9kdWxlIEdpZCA6IHNpZ1xuICAoKiB1bmlxdWUgZ3JvdXAtaWQsIHVzZWQgYXMga2V5IGZvciBUZW52IGJlbG93ICopXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBsZXQgciA9IHJlZiAwXG5cbiAgbGV0IGNyZWF0ZSAoKSA9XG4gICAgbGV0IHUgPSAhciBpblxuICAgIHIgOj0gMSArIHU7XG4gICAgdVxuICA7O1xuZW5kXG5cbm1vZHVsZSBFeHByZXNzaW9uID0gc3RydWN0XG4gIHR5cGUgJ3QgcG9seV9jb25zdHIgPVxuICAgIFsgYENvbnN0ciBvZiBzdHJpbmcgKiAndCBvcHRpb25cbiAgICB8IGBJbmhlcml0IG9mIExvY2F0aW9uLnQgKiAndFxuICAgIF1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBtb2R1bGUgR3JvdXAgOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIHZhbCBjcmVhdGUgOiBMb2NhdGlvbi50IC0+IChUaWQudCAqIFZpZC50IGxpc3QgKiAnYSkgbGlzdCAtPiAnYSB0XG4gICAgdmFsIGlkIDogJ2EgdCAtPiBHaWQudFxuICAgIHZhbCBsb29rdXAgOiAnYSB0IC0+IFRpZC50IC0+IFZpZC50IGxpc3QgKiAnYVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBnaWQgOiBHaWQudFxuICAgICAgOyBsb2MgOiBMb2NhdGlvbi50XG4gICAgICA7IG1lbWJlcnMgOiAoVGlkLnQgKiAoVmlkLnQgbGlzdCAqICdhKSkgbGlzdFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBsZXQgY3JlYXRlIGxvYyB0cmlwcyA9XG4gICAgICBsZXQgZ2lkID0gR2lkLmNyZWF0ZSAoKSBpblxuICAgICAgbGV0IG1lbWJlcnMgPSBMaXN0Lm1hcCB0cmlwcyB+ZjooZnVuICh4LCB2cywgdCkgLT4geCwgKHZzLCB0KSkgaW5cbiAgICAgIHsgZ2lkOyBsb2M7IG1lbWJlcnMgfVxuICAgIDs7XG5cbiAgICBsZXQgaWQgZyA9IGcuZ2lkXG5cbiAgICBsZXQgbG9va3VwIGcgdGlkID1cbiAgICAgIG1hdGNoIExpc3QuQXNzb2MuZmluZCBnLm1lbWJlcnMgfmVxdWFsOlRpZC4oID0gKSB0aWQgd2l0aFxuICAgICAgfCBTb21lIHNjaGVtZSAtPiBzY2hlbWVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBldmFsX2ZhaWxcbiAgICAgICAgICBnLmxvY1xuICAgICAgICAgICFcImltcG9zc2libGU6IGxvb2t1cF9ncm91cCwgdW5ib3VuZCB0eXBlLWlkZW50aWZpZXI6ICV7VGlkfVwiXG4gICAgICAgICAgdGlkXG4gICAgICAgICAgKClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHwgQW5ub3RhdGUgb2YgVXVpZC50ICogdFxuICAgIHwgQmFzZSBvZiBVdWlkLnQgKiB0IGxpc3RcbiAgICB8IFJlY29yZCBvZiAoc3RyaW5nICogdCkgbGlzdFxuICAgIHwgVmFyaWFudCBvZiAoc3RyaW5nICogdCBsaXN0KSBsaXN0XG4gICAgfCBUdXBsZSBvZiB0IGxpc3RcbiAgICB8IFBvbHlfdmFyaWFudCBvZiAoTG9jYXRpb24udCAqIHQgcG9seV9jb25zdHIgbGlzdClcbiAgICB8IFZhciBvZiAoTG9jYXRpb24udCAqIFZpZC50KVxuICAgIHwgUmVjX2FwcCBvZiBUaWQudCAqIHQgbGlzdFxuICAgIHwgVG9wX2FwcCBvZiB0IEdyb3VwLnQgKiBUaWQudCAqIHQgbGlzdFxuICBbQEBkZXJpdmluZyB2YXJpYW50cywgc2V4cF9vZl1cblxuICB0eXBlIGdyb3VwID0gdCBHcm91cC50XG5cbiAgbGV0IGdyb3VwID0gR3JvdXAuY3JlYXRlXG5cbiAgdHlwZSBwb2x5X3ZhcmlhbnRfcm93ID0gdCBwb2x5X2NvbnN0clxuXG4gIGxldCBjb25zdHIgcyB0ID0gYENvbnN0ciAocywgdClcbiAgbGV0IGluaGVyaXRfIGxvYyB0ID0gYEluaGVyaXQgKGxvYywgdClcbiAgbGV0IHZhciBsb2MgdCA9IFZhciAobG9jLCB0KVxuICBsZXQgcG9seV92YXJpYW50IGxvYyB4cyA9IFBvbHlfdmFyaWFudCAobG9jLCB4cylcbiAgbGV0IGJhc2V0eXBlID0gYmFzZVxuXG4gICgqIFwiVlJcIiBzdGFuZHMgZm9yIFwidmFyaWFudCBvciByZWNvcmRcIiAqKVxuXG4gIGxldCBpc19jeWNsaWNfMCB+KHZpYV9WUiA6IGJvb2wpIDogZ3JvdXAgLT4gVGlkLnQgLT4gYm9vbCA9XG4gICAgZnVuIGdyb3VwIHRpZCAtPlxuICAgIGxldCBzZXQgPSByZWYgW10gaW5cbiAgICBsZXQgdmlzaXRlZCB0aWQgPSBMaXN0Lm1lbSAhc2V0IHRpZCB+ZXF1YWw6VGlkLmVxdWFsIGluXG4gICAgbGV0IGFkZCB0aWQgPSBzZXQgOj0gdGlkIDo6ICFzZXQgaW5cbiAgICBsZXQgcmVjIHRyYXYgPSBmdW5jdGlvblxuICAgICAgKCogV2UgbG9vayBmb3IgY3ljbGVzIGJ5IHRyYXZlcnNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0eXBlLWV4cHJlc3Npb25zICopXG4gICAgICB8IEFubm90YXRlIChfLCB0KSAtPiB0cmF2IHRcbiAgICAgIHwgQmFzZSAoXywgdHMpIHwgVHVwbGUgdHMgfCBUb3BfYXBwIChfLCBfLCB0cykgLT4gTGlzdC5pdGVyIHRzIH5mOnRyYXZcbiAgICAgICgqIC4uaW5jbHVkaW5nIHBvbHktdmFyaWFudHMgKilcbiAgICAgIHwgUG9seV92YXJpYW50IChfLCBjcykgLT5cbiAgICAgICAgTGlzdC5pdGVyIGNzIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgYENvbnN0ciAoXywgTm9uZSkgLT4gKClcbiAgICAgICAgICB8IGBDb25zdHIgKF8sIFNvbWUgdCkgLT4gdHJhdiB0XG4gICAgICAgICAgfCBgSW5oZXJpdCAoX2xvYywgdCkgLT4gdHJhdiB0KVxuICAgICAgKCogLi4gYW5kIHJlY29yZHMgJiAobm9ybWFsKSB2YXJpYW50cyAqKVxuICAgICAgfCBSZWNvcmQgeHMgLT4gaWYgdmlhX1ZSIHRoZW4gTGlzdC5pdGVyIHhzIH5mOihmdW4gKF8sIHQpIC0+IHRyYXYgdCkgZWxzZSAoKVxuICAgICAgfCBWYXJpYW50IHhzIC0+XG4gICAgICAgIGlmIHZpYV9WUiB0aGVuIExpc3QuaXRlciB4cyB+ZjooZnVuIChfLCB0cykgLT4gTGlzdC5pdGVyIH5mOnRyYXYgdHMpIGVsc2UgKClcbiAgICAgICgqIFdlIGRvbnQgZm9sbG93IHR5cGUtdmFycyAqKVxuICAgICAgfCBWYXIgXyAtPiAoKVxuICAgICAgKCogdHJhdmVyc2UgKHJlY3Vyc2l2ZSkgdHlwZS1hcHBzIHdoZW4gZmlyc3QgZW5jb3VudGVyZWQgKilcbiAgICAgIHwgUmVjX2FwcCAodGlkLCB0cykgLT5cbiAgICAgICAgaWYgdmlzaXRlZCB0aWRcbiAgICAgICAgdGhlbiAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBhZGQgdGlkO1xuICAgICAgICAgIHRyYXZfdGlkIHRpZCk7XG4gICAgICAgIExpc3QuaXRlciB0cyB+Zjp0cmF2XG4gICAgYW5kIHRyYXZfdGlkIHRpZCA9XG4gICAgICBsZXQgXywgYm9keSA9IEdyb3VwLmxvb2t1cCBncm91cCB0aWQgaW5cbiAgICAgIHRyYXYgYm9keVxuICAgIGluXG4gICAgdHJhdl90aWQgdGlkO1xuICAgIGxldCByZXMgPSB2aXNpdGVkIHRpZCBpblxuICAgICgqbGV0IF9zcyA9IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiAoTGlzdC5tYXAgKCFzZXQpIH5mOihzcHJpbnRmICFcIiV7VGlkfVwiKSkgaW4qKVxuICAgICgqUHJpbnRmLnByaW50ZiAhXCJpc19jeWxpYzogJXtUaWR9IC0tPiAoJXMpICViICAtLSAlcyUhXCIgdGlkIF9zcyByZXMgKEdyb3VwLmxvYyBncm91cCk7KilcbiAgICByZXNcbiAgOztcblxuICBsZXQgaXNfY3ljbGljID0gaXNfY3ljbGljXzAgfnZpYV9WUjp0cnVlXG4gIGxldCBpc19jeWNsaWNfd2l0aF9ub19pbnRlcnZlbmluZ19WUiA9IGlzX2N5Y2xpY18wIH52aWFfVlI6ZmFsc2VcbmVuZFxuXG5pbmNsdWRlIEV4cHJlc3Npb25cblxubW9kdWxlIEV2YWx1YXRpb24gKENhbm9uaWNhbCA6IENhbm9uaWNhbCkgPSBzdHJ1Y3RcbiAgKCogW1ZlbnYudF1cbiAgICAgRW52aXJvbm1lbnQgZm9yIHJlc29sdmluZyB0eXBlLXZhcnMgKilcbiAgbW9kdWxlIFZlbnYgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBsb29rdXAgOiB0IC0+IFZpZC50IC0+IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IG9wdGlvblxuICAgIHZhbCBjcmVhdGUgOiAoVmlkLnQgKiBWaXNpYmlsaXR5LnZpc2libGUgQ2Fub25pY2FsLkV4cDEudCkgbGlzdCAtPiB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IE1hcC5NKFZpZCkudFxuXG4gICAgbGV0IGNyZWF0ZSA9XG4gICAgICBMaXN0LmZvbGRcbiAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIFZpZCkpXG4gICAgICAgIH5mOihmdW4gdCAoaywgdikgLT4gTWFwLnNldCB+a2V5OmsgfmRhdGE6diB0KVxuICAgIDs7XG5cbiAgICBsZXQgbG9va3VwIHQgayA9IE1hcC5maW5kIHQga1xuICBlbmRcblxuICBtb2R1bGUgQXBwbGljYW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgUmVjdXJzaW9uX2xldmVsIG9mIGludFxuICAgICAgfCBEZWZpbml0aW9uIG9mIENhbm9uaWNhbC5EZWYudFxuICBlbmRcblxuICAoKiBbVGVudi50XVxuICAgICBFbnZpcm9ubWVudCBmb3IgcmVzb2x2aW5nIHR5cGUtZGVmaW5pdGlvbnMgKilcbiAgbW9kdWxlIFRlbnYgOiBzaWdcbiAgICB0eXBlIGtleSA9IEdpZC50ICogVGlkLnRcbiAgICB0eXBlIHRcblxuICAgIHZhbCBmaW5kIDogdCAtPiBrZXkgLT4gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIG9wdGlvblxuICAgIHZhbCBlbXB0eSA6IHRcbiAgICB2YWwgZXh0ZW5kIDogdCAtPiBrZXkgLT4gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIC0+IHRcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gR2lkLnQgKiBUaWQudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuICAgICAgZW5kXG5cbiAgICAgIGluY2x1ZGUgVFxuICAgICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gICAgZW5kXG5cbiAgICB0eXBlIGtleSA9IEtleS50XG4gICAgdHlwZSB0ID0gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIE1hcC5NKEtleSkudFxuXG4gICAgbGV0IGZpbmQgdCBrID0gTWFwLmZpbmQgdCBrXG4gICAgbGV0IGVtcHR5ID0gTWFwLmVtcHR5IChtb2R1bGUgS2V5KVxuICAgIGxldCBleHRlbmQgdCBrIHYgPSBNYXAuc2V0IH5rZXk6ayB+ZGF0YTp2IHRcbiAgZW5kXG5cbiAgKCogW0RlZmluaW5nLnRdXG4gICAgIE1vbmFkIGZvciBtYW5hZ2luZyB1bi1yb2xsaW5nIGRlcHRoLCBhbmQgbWFpbnRhaW5nIGEgW1RlbnYudF0gKilcbiAgbW9kdWxlIERlZmluaW5nIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICAgIHZhbCBsb29rX2VudiA6IFRlbnYua2V5IC0+IEFwcGxpY2FuZC50IG9wdGlvbiB0XG4gICAgdmFsIGV4dGVuZF9uZXdfdGlkIDogVGVudi5rZXkgLT4gQ2Fub25pY2FsLkRlZi50IHQgLT4gQXBwbGljYW5kLnQgdFxuICAgIHZhbCBleGVjIDogJ2EgdCAtPiAnYVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSBkZXB0aDppbnQgLT4gVGVudi50IC0+ICdhXG5cbiAgICBsZXQgcmV0dXJuIHggfmRlcHRoOl8gX3RlbnYgPSB4XG5cbiAgICBsZXQgYmluZCB0IGYgfmRlcHRoIHRlbnYgPVxuICAgICAgbGV0IHggPSB0IH5kZXB0aCB0ZW52IGluXG4gICAgICAoZiB4KSB+ZGVwdGggdGVudlxuICAgIDs7XG5cbiAgICBsZXQgbG9va19lbnYga2V5IH5kZXB0aDpfIHRlbnYgPVxuICAgICAgbGV0IHJlc3VsdCA9IFRlbnYuZmluZCB0ZW52IGtleSBpblxuICAgICAgT3B0aW9uLm1hcCB+ZjooZnVuIChgUmVjdXJzaW9uX2xldmVsIHgpIC0+IEFwcGxpY2FuZC5SZWN1cnNpb25fbGV2ZWwgeCkgcmVzdWx0XG4gICAgOztcblxuICAgIGxldCBleHRlbmRfbmV3X3RpZCBrZXkgZGVmX3QgfmRlcHRoIHRlbnYgPVxuICAgICAgQXBwbGljYW5kLkRlZmluaXRpb25cbiAgICAgICAgKGxldCB2YWx1ZSA9IGBSZWN1cnNpb25fbGV2ZWwgZGVwdGggaW5cbiAgICAgICAgIGxldCB0ZW52ID0gVGVudi5leHRlbmQgdGVudiBrZXkgdmFsdWUgaW5cbiAgICAgICAgIGRlZl90IH5kZXB0aDooZGVwdGggKyAxKSB0ZW52KVxuICAgIDs7XG5cbiAgICBsZXQgZXhlYyB0ID0gdCB+ZGVwdGg6MCBUZW52LmVtcHR5XG4gIGVuZFxuXG4gIHR5cGUgJ2EgZGVmaW5pbmcgPSAnYSBEZWZpbmluZy50XG5cbiAgbGV0ICggPj49ICkgPSBEZWZpbmluZy5iaW5kXG4gIGxldCByZXR1cm4gPSBEZWZpbmluZy5yZXR1cm5cblxuICBsZXQgc2VxdWVuY2VfZGVmaW5pbmcgOiAnYSBsaXN0IC0+IGY6KCdhIC0+ICdiIGRlZmluaW5nKSAtPiAnYiBsaXN0IGRlZmluaW5nID1cbiAgICBmdW4geHMgfmYgLT5cbiAgICBsZXQgcmVjIGxvb3AgYWNjX3lzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiBhY2NfeXMpXG4gICAgICB8IHggOjogeHMgLT4gZiB4ID4+PSBmdW4geSAtPiBsb29wICh5IDo6IGFjY195cykgeHNcbiAgICBpblxuICAgIGxvb3AgW10geHNcbiAgOztcblxuICAoKlxuICAgICBTaGFwZSBldmFsdWF0aW9uLlxuXG4gICAgIFNoYXBlcyBhcmUgZXZhbHVhdGVkIHRvIGNhbm9uaWNhbC1zaGFwZSAoZXhwcmVzc2lvbnMpLCB3aXRoIGFkZGl0aW9uYWwgZGVmcyBjb2xsZWN0ZWRcbiAgICAgaW4gdGhlIFtkZWZpbmluZ10gbW9uYWQsIHdoaWNoIGFsc28gbWFuYWdlcyBnZW5lcmF0aW9uL21hcHBpbmcgdG8gW0Nhbm9uaWNhbC5UaWQudF1cblxuICAgICBUaGVyZSBpcyBkb3dud2FyZHMgY29udGV4dCBvZiBbZ3JvdXBdIGFuZCBbVmVudi50XVxuICAgICBUaGUgKGN1cnJlbnQpIFtncm91cF0gY2hhbmdlcyB3aGVuIHRoZSBjYXNlIGZvciBbVG9wX2FwcF0gY2FsbHMgW2V2YWxfYXBwXS5cblxuICAgICBUaGUgY3VycmVudCBbVmVudi50XSBpcyBhYmFuZG9uZWQgd2hlbiBbZXZhbF9hcHBdIGlzIGNhbGxlZCwgYW5kIHRoZW4gcmUtY3JlYXRlZCBhZnRlclxuICAgICB0aGUgZGVjaXNpb24gaGFzIGJlZW4gbWFkZSB0byBlaXRoZXIgaW5saW5lIHRoZSB0eXBlLWFwcGxpY2F0aW9uLCBvciBtYWtlIGEgcmVmZXJlbmNlXG4gICAgIHRvIGEgdHlwZS1kZWZpbml0aW9uLCB3aGljaCBpcyBjcmVhdGVkIGF0IG1vc3Qgb25jZSBmb3IgZWFjaCAoR2lkLnQgKiBUaWQudCkuXG5cbiAgICAgV2UgbWFrZSBhIHR5cGUtZGVmaW5pdGlvbiBhbHdheXMgZm9yIFJlY29yZHMgYW5kIFZhcmlhbnRzLCBhbmQgaW4gYWRkaXRpb24gZm9yIGFueVxuICAgICBvdGhlciBjeWNsaWMgdHlwZS1kZWZpbml0aW9uLlxuICAqKVxuXG4gIGxldCByZWMgZXZhbCA6IGdyb3VwIC0+IFZlbnYudCAtPiB0IC0+IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IGRlZmluaW5nID1cbiAgICBmdW4gZ3JvdXAgdmVudiB0IC0+XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgUmVjb3JkIGJpbmRzIC0+XG4gICAgICAgIHNlcXVlbmNlX2RlZmluaW5nIGJpbmRzIH5mOihmdW4gKHMsIHgpIC0+XG4gICAgICAgICAgZXZhbCBncm91cCB2ZW52IHggPj49IGZ1biB5IC0+IHJldHVybiAocywgeSkpXG4gICAgICAgID4+PSBmdW4gYmluZHMgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLnJlY29yZCBiaW5kcylcbiAgICAgIHwgVmFyaWFudCBhbHRzIC0+XG4gICAgICAgIHNlcXVlbmNlX2RlZmluaW5nIGFsdHMgfmY6KGZ1biAocywgeHMpIC0+XG4gICAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgeHMgPj49IGZ1biB5cyAtPiByZXR1cm4gKHMsIHlzKSlcbiAgICAgICAgPj49IGZ1biBhbHRzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS52YXJpYW50IGFsdHMpXG4gICAgICB8IFZhciAobG9jLCB2aWQpIC0+XG4gICAgICAgIChtYXRjaCBWZW52Lmxvb2t1cCB2ZW52IHZpZCB3aXRoXG4gICAgICAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuICAgICAgICAgfCBOb25lIC0+IGV2YWxfZmFpbCBsb2MgIVwiRnJlZSB0eXBlIHZhcmlhYmxlOiAnJXtWaWR9XCIgdmlkICgpKVxuICAgICAgfCBBbm5vdGF0ZSAocywgdCkgLT5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IHQgPj49IGZ1biB2IC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5hbm5vdGF0ZSBzIHYpXG4gICAgICB8IEJhc2UgKHMsIHRzKSAtPlxuICAgICAgICBldmFsX2xpc3QgZ3JvdXAgdmVudiB0cyA+Pj0gZnVuIHZzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5iYXNldHlwZSBzIHZzKVxuICAgICAgfCBUdXBsZSB0cyAtPiBldmFsX2xpc3QgZ3JvdXAgdmVudiB0cyA+Pj0gZnVuIHZzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS50dXBsZSB2cylcbiAgICAgIHwgVG9wX2FwcCAoaW5fZ3JvdXAsIHRpZCwgYXJncykgLT5cbiAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgYXJnc1xuICAgICAgICA+Pj0gZnVuIGFyZ3MgLT5cbiAgICAgICAgKCogYXJncyBldmFsdWF0ZWQgaW4gY3VycmVudCBncm91cCAqKVxuICAgICAgICBldmFsX2FwcCBpbl9ncm91cCB0aWQgYXJnc1xuICAgICAgKCogZ3JvdXAgY2hhbmdlZCBoZXJlICopXG4gICAgICB8IFJlY19hcHAgKHRpZCwgYXJncykgLT5cbiAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgYXJncyA+Pj0gZnVuIGFyZ3MgLT4gZXZhbF9hcHAgZ3JvdXAgdGlkIGFyZ3NcbiAgICAgIHwgUG9seV92YXJpYW50IChsb2MsIGNzKSAtPlxuICAgICAgICBzZXF1ZW5jZV9kZWZpbmluZyB+ZjooZXZhbF9wb2x5X2NvbnN0ciBncm91cCB2ZW52KSBjc1xuICAgICAgICA+Pj0gZnVuIHhzcyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUucG9seV92YXJpYW50IGxvYyAoTGlzdC5jb25jYXQgeHNzKSlcblxuICBhbmQgZXZhbF9saXN0IDogZ3JvdXAgLT4gVmVudi50IC0+IHQgbGlzdCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgbGlzdCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIHZlbnYgdHMgLT4gc2VxdWVuY2VfZGVmaW5pbmcgdHMgfmY6KGV2YWwgZ3JvdXAgdmVudilcblxuICBhbmQgZXZhbF9wb2x5X2NvbnN0clxuICAgIDogIGdyb3VwIC0+IFZlbnYudCAtPiB0IHBvbHlfY29uc3RyXG4gICAgICAtPiAoc3RyaW5nICogVmlzaWJpbGl0eS5vcGFxdWUgQ2Fub25pY2FsLkV4cDEudCBvcHRpb24pIGxpc3QgZGVmaW5pbmdcbiAgICA9XG4gICAgZnVuIGdyb3VwIHZlbnYgYyAtPlxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8IGBDb25zdHIgKHMsIE5vbmUpIC0+IHJldHVybiBbIHMsIE5vbmUgXVxuICAgICAgfCBgQ29uc3RyIChzLCBTb21lIHQpIC0+XG4gICAgICAgIGV2YWwgZ3JvdXAgdmVudiB0ID4+PSBmdW4gdiAtPiByZXR1cm4gWyBzLCBTb21lIChDYW5vbmljYWwuRXhwMS5vcGFxdWUgdikgXVxuICAgICAgfCBgSW5oZXJpdCAobG9jLCB0KSAtPlxuICAgICAgICBldmFsIGdyb3VwIHZlbnYgdFxuICAgICAgICA+Pj0gZnVuIHYgLT5cbiAgICAgICAgKG1hdGNoIENhbm9uaWNhbC5FeHAxLmdldF9wb2x5X3ZhcmlhbnQgdiB3aXRoXG4gICAgICAgICB8IE9rIHRhYiAtPiByZXR1cm4gKFNvcnRlZF90YWJsZS5leHBvc2UgdGFiKVxuICAgICAgICAgfCBFcnJvciBkZXNjIC0+XG4gICAgICAgICAgIGV2YWxfZmFpbFxuICAgICAgICAgICAgIGxvY1xuICAgICAgICAgICAgIFwiVGhlIHNoYXBlIGZvciBhbiBpbmhlcml0ZWQgdHlwZSBpcyBub3QgZGVzY3JpYmVkIGFzIGEgcG9seW1vcnBoaWMtdmFyaWFudDogJXNcIlxuICAgICAgICAgICAgIGRlc2NcbiAgICAgICAgICAgICAoKSlcblxuICBhbmQgZXZhbF9kZWZpbml0aW9uIDogZ3JvdXAgLT4gVmlkLnQgbGlzdCAtPiB0IC0+IENhbm9uaWNhbC5EZWYudCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIGZvcm1hbHMgYm9keSAtPlxuICAgICAgbGV0IHZlbnYgPSBWZW52LmNyZWF0ZSAoTGlzdC5tYXBpIGZvcm1hbHMgfmY6KGZ1biBpIHggLT4geCwgQ2Fub25pY2FsLkV4cDEudmFyIGkpKSBpblxuICAgICAgZXZhbCBncm91cCB2ZW52IGJvZHkgPj49IGZ1biB2IC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5kZWZpbmUgdilcblxuICBhbmQgZXZhbF9hcHAgOiBncm91cCAtPiBUaWQudCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgbGlzdCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgZGVmaW5pbmcgPVxuICAgIGZ1biBncm91cCB0aWQgYXJncyAtPlxuICAgICAgbGV0IGdpZCA9IEdyb3VwLmlkIGdyb3VwIGluXG4gICAgICBsZXQgZm9ybWFscywgYm9keSA9IEdyb3VwLmxvb2t1cCBncm91cCB0aWQgaW5cbiAgICAgIGxldCByZWNvcmRfb3Jfbm9ybWFsX3ZhcmlhbnQgPVxuICAgICAgICBtYXRjaCBib2R5IHdpdGhcbiAgICAgICAgfCBSZWNvcmQgXyB8IFZhcmlhbnQgXyAtPiB0cnVlXG4gICAgICAgIHwgVHVwbGUgXyB8IEFubm90YXRlIF8gfCBCYXNlIF8gfCBQb2x5X3ZhcmlhbnQgXyB8IFZhciBfIHwgUmVjX2FwcCBfIHwgVG9wX2FwcCBfIC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgY3ljbGljID0gaXNfY3ljbGljIGdyb3VwIHRpZCBpblxuICAgICAgbGV0IGN5Y2xpY19ub19WUiA9IGlzX2N5Y2xpY193aXRoX25vX2ludGVydmVuaW5nX1ZSIGdyb3VwIHRpZCBpblxuICAgICAgaWYgKHJlY29yZF9vcl9ub3JtYWxfdmFyaWFudCAmJiBjeWNsaWMpIHx8IGN5Y2xpY19ub19WUlxuICAgICAgdGhlblxuICAgICAgICBEZWZpbmluZy5sb29rX2VudiAoZ2lkLCB0aWQpXG4gICAgICAgID4+PSAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgcmVjdXJzZSAtPiByZXR1cm4gcmVjdXJzZVxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgRGVmaW5pbmcuZXh0ZW5kX25ld190aWQgKGdpZCwgdGlkKSAoZXZhbF9kZWZpbml0aW9uIGdyb3VwIGZvcm1hbHMgYm9keSkpXG4gICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICB8IFJlY3Vyc2lvbl9sZXZlbCByIC0+IHJldHVybiAoQ2Fub25pY2FsLkV4cDEucmVjdXJzZSByIGFyZ3MpXG4gICAgICAgIHwgRGVmaW5pdGlvbiBkZWYgLT4gcmV0dXJuIChDYW5vbmljYWwuRXhwMS5hcHBseSBkZWYgYXJncylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdmVudiA9XG4gICAgICAgICAgbWF0Y2ggTGlzdC56aXAgZm9ybWFscyBhcmdzIHdpdGhcbiAgICAgICAgICB8IE9rIHggLT4gVmVudi5jcmVhdGUgeFxuICAgICAgICAgIHwgVW5lcXVhbF9sZW5ndGhzIC0+IGZhaWx3aXRoIFwiYXBwbHksIGluY29ycmVjdCB0eXBlIGFwcGxpY2F0aW9uIGFyaXR5XCJcbiAgICAgICAgaW5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IGJvZHkpXG4gIDs7XG5cbiAgKCogdG9wIGxldmVsIGVudHJ5IHBvaW50IGZvciBldmFsdWF0aW9uICopXG4gIGxldCBldmFsIDogdCAtPiBDYW5vbmljYWwudCA9XG4gICAgZnVuIHQgLT5cbiAgICAgIGxldCBncm91cCA9IGdyb3VwIChMb2NhdGlvbi5vZl9zdHJpbmcgXCJ0b3AtbGV2ZWxcIikgW10gaW5cbiAgICAgIGxldCB2ZW52ID0gVmVudi5jcmVhdGUgW10gaW5cbiAgICAgIGxldCB2ID0gRGVmaW5pbmcuZXhlYyAoZXZhbCBncm91cCB2ZW52IHQpIGluXG4gICAgICBDYW5vbmljYWwuQ3JlYXRlLmNyZWF0ZSB2XG4gIDs7XG5lbmRcblxubW9kdWxlIENhbm9uaWNhbCA9IHN0cnVjdFxuICBpbmNsdWRlIENhbm9uaWNhbF9mdWxsXG5cbiAgbW9kdWxlIEV4cCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFdmFsdWF0aW9uIChDYW5vbmljYWxfZnVsbClcbm1vZHVsZSBDYW5vbmljYWxfc2VsZWN0ZWQgPSBDYW5vbmljYWxfZGlnZXN0XG5tb2R1bGUgRXZhbHVhdGlvbl90b19kaWdlc3QgPSBFdmFsdWF0aW9uIChDYW5vbmljYWxfc2VsZWN0ZWQpXG5cbmxldCBldmFsX3RvX2RpZ2VzdCBleHAgPSBDYW5vbmljYWxfc2VsZWN0ZWQudG9fZGlnZXN0IChFdmFsdWF0aW9uX3RvX2RpZ2VzdC5ldmFsIGV4cClcbmxldCBldmFsX3RvX2RpZ2VzdF9zdHJpbmcgZXhwID0gRGlnZXN0LnRvX2hleCAoZXZhbF90b19kaWdlc3QgZXhwKVxuXG5tb2R1bGUgRm9yX3R5cGVyZXAgPSBzdHJ1Y3RcbiAgZXhjZXB0aW9uIE5vdF9hX3R1cGxlIG9mIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZGVjb25zdHJ1Y3RfdHVwbGVfZXhuIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgVHVwbGUgdHMgLT4gdHNcbiAgICB8IF8gLT4gcmFpc2UgKE5vdF9hX3R1cGxlIHQpXG4gIDs7XG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTk9URTpcbiAgIElmIHRoaXMgZmlsZSBpcyBzdHJpbmdMYWJlbHMubWxpLCBydW4gdG9vbHMvc3luY19zdGRsaWJfZG9jcyBhZnRlciBlZGl0aW5nXG4gICBpdCB0byBnZW5lcmF0ZSBzdHJpbmcubWxpLlxuXG4gICBJZiB0aGlzIGZpbGUgaXMgc3RyaW5nLm1saSwgZG8gbm90IGVkaXQgaXQgZGlyZWN0bHkgLS0gZWRpdFxuICAgc3RyaW5nTGFiZWxzLm1saSBpbnN0ZWFkLlxuICopXG5cbigqKiBTdHJpbmdzLlxuXG4gICAgQSBzdHJpbmcgW3NdIG9mIGxlbmd0aCBbbl0gaXMgYW4gaW5kZXhhYmxlIGFuZCBpbW11dGFibGUgc2VxdWVuY2VcbiAgICBvZiBbbl0gYnl0ZXMuIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMgdGhlc2UgYnl0ZXMgYXJlIHJlZmVycmVkIHRvXG4gICAgYXMgY2hhcmFjdGVycy5cblxuICAgIFRoZSBzZW1hbnRpY3Mgb2Ygc3RyaW5nIGZ1bmN0aW9ucyBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICAgaW5kaWNlcyBhbmQgcG9zaXRpb25zLiBUaGVzZSBhcmUgZGVwaWN0ZWQgYW5kIGRlc2NyaWJlZFxuICAgIGFzIGZvbGxvd3MuXG5cbnt2XG5wb3NpdGlvbnMgIDAgICAxICAgMiAgIDMgICA0ICAgIG4tMSAgICBuXG4gICAgICAgICAgICstLS0rLS0tKy0tLSstLS0rICAgICArLS0tLS0rXG4gIGluZGljZXMgIHwgMCB8IDEgfCAyIHwgMyB8IC4uLiB8IG4tMSB8XG4gICAgICAgICAgICstLS0rLS0tKy0tLSstLS0rICAgICArLS0tLS0rXG52fVxuICAgIHt1bFxuICAgIHstIEFuIHtlIGluZGV4fSBbaV0gb2YgW3NdIGlzIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIFxcW1swXTtbbi0xXVxcXS5cbiAgICAgICBJdCByZXByZXNlbnRzIHRoZSBbaV10aCBieXRlIChjaGFyYWN0ZXIpIG9mIFtzXSB3aGljaCBjYW4gYmVcbiAgICAgICBhY2Nlc3NlZCB1c2luZyB0aGUgY29uc3RhbnQgdGltZSBzdHJpbmcgaW5kZXhpbmcgb3BlcmF0b3JcbiAgICAgICBbcy5baV1dLn1cbiAgICB7LSBBIHtlIHBvc2l0aW9ufSBbaV0gb2YgW3NdIGlzIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlXG4gICAgICAgXFxbWzBdO1tuXVxcXS4gSXQgcmVwcmVzZW50cyBlaXRoZXIgdGhlIHBvaW50IGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICAgICB0aGUgc3RyaW5nLCBvciB0aGUgcG9pbnQgYmV0d2VlbiB0d28gaW5kaWNlcywgb3IgdGhlIHBvaW50IGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLiBUaGUgW2lddGggYnl0ZSBpbmRleCBpcyBiZXR3ZWVuIHBvc2l0aW9uXG4gICAgICAgW2ldIGFuZCBbaSsxXS59fVxuXG4gICAgVHdvIGludGVnZXJzIFtzdGFydF0gYW5kIFtsZW5dIGFyZSBzYWlkIHRvIGRlZmluZSBhIHtlIHZhbGlkXG4gICAgc3Vic3RyaW5nfSBvZiBbc10gaWYgW2xlbiA+PSAwXSBhbmQgW3N0YXJ0XSwgW3N0YXJ0K2xlbl0gYXJlXG4gICAgcG9zaXRpb25zIG9mIFtzXS5cblxuICAgIHtiIFVuaWNvZGUgdGV4dC59IFN0cmluZ3MgYmVpbmcgYXJiaXRyYXJ5IHNlcXVlbmNlcyBvZiBieXRlcywgdGhleVxuICAgIGNhbiBob2xkIGFueSBraW5kIG9mIHRleHR1YWwgZW5jb2RpbmcuIEhvd2V2ZXIgdGhlIHJlY29tbWVuZGVkXG4gICAgZW5jb2RpbmcgZm9yIHN0b3JpbmcgVW5pY29kZSB0ZXh0IGluIE9DYW1sIHN0cmluZ3MgaXMgVVRGLTguIFRoaXNcbiAgICBpcyB0aGUgZW5jb2RpbmcgdXNlZCBieSBVbmljb2RlIGVzY2FwZXMgaW4gc3RyaW5nIGxpdGVyYWxzLiBGb3JcbiAgICBleGFtcGxlIHRoZSBzdHJpbmcgW1wiXFx1ezFGNDJCfVwiXSBpcyB0aGUgVVRGLTggZW5jb2Rpbmcgb2YgdGhlXG4gICAgVW5pY29kZSBjaGFyYWN0ZXIgVSsxRjQyQi5cblxuICAgIHtiIFBhc3QgbXV0YWJpbGl0eS59IE9DYW1sIHN0cmluZ3MgdXNlZCB0byBiZSBtb2RpZmlhYmxlIGluIHBsYWNlLFxuICAgIGZvciBpbnN0YW5jZSB2aWEgdGhlIHshU3RyaW5nLnNldH0gYW5kIHshU3RyaW5nLmJsaXR9XG4gICAgZnVuY3Rpb25zLiBUaGlzIHVzZSBpcyBub3dhZGF5cyBvbmx5IHBvc3NpYmxlIHdoZW4gdGhlIGNvbXBpbGVyIGlzXG4gICAgcHV0IGluIFwidW5zYWZlLXN0cmluZ1wiIG1vZGUgYnkgZ2l2aW5nIHRoZSBbLXVuc2FmZS1zdHJpbmddXG4gICAgY29tbWFuZC1saW5lIG9wdGlvbi4gVGhpcyBjb21wYXRpYmlsaXR5IG1vZGUgbWFrZXMgdGhlIHR5cGVzXG4gICAgW3N0cmluZ10gYW5kIFtieXRlc10gKHNlZSB7IUJ5dGVzLnR9KSBpbnRlcmNoYW5nZWFibGUgc28gdGhhdFxuICAgIGZ1bmN0aW9ucyBleHBlY3RpbmcgYnl0ZSBzZXF1ZW5jZXMgY2FuIGFsc28gYWNjZXB0IHN0cmluZ3MgYXNcbiAgICBhcmd1bWVudHMgYW5kIG1vZGlmeSB0aGVtLlxuXG4gICAgVGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gW2J5dGVzXSBhbmQgW3N0cmluZ10gd2FzIGludHJvZHVjZWQgaW5cbiAgICBPQ2FtbCA0LjAyLCBhbmQgdGhlIFwidW5zYWZlLXN0cmluZ1wiIGNvbXBhdGliaWxpdHkgbW9kZSB3YXMgdGhlXG4gICAgZGVmYXVsdCB1bnRpbCBPQ2FtbCA0LjA1LiBTdGFydGluZyB3aXRoIDQuMDYsIHRoZSBjb21wYXRpYmlsaXR5XG4gICAgbW9kZSBpcyBvcHQtaW47IHdlIGludGVuZCB0byByZW1vdmUgdGhlIG9wdGlvbiBpbiB0aGUgZnV0dXJlLlxuXG4gICAgVGhlIGxhYmVsZWQgdmVyc2lvbiBvZiB0aGlzIG1vZHVsZSBjYW4gYmUgdXNlZCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gICAgeyFTdGRMYWJlbHN9IG1vZHVsZS5cbiopXG5cbigqKiB7MTpzdHJpbmdzIFN0cmluZ3N9ICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuKCoqIFRoZSB0eXBlIGZvciBzdHJpbmdzLiAqKVxuXG52YWwgbWFrZSA6IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuKCoqIFttYWtlIG4gY10gaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIFtuXSB3aXRoIGVhY2ggaW5kZXggaG9sZGluZyB0aGVcbiAgICBjaGFyYWN0ZXIgW2NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW24gPCAwXSBvciBbbiA+IF17IVN5cy5tYXhfc3RyaW5nX2xlbmd0aH0uICopXG5cbnZhbCBpbml0IDogaW50IC0+IChpbnQgLT4gY2hhcikgLT4gc3RyaW5nXG4oKiogW2luaXQgbiBmXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW25dIHdpdGggaW5kZXhcbiAgICBbaV0gaG9sZGluZyB0aGUgY2hhcmFjdGVyIFtmIGldIChjYWxsZWQgaW4gaW5jcmVhc2luZyBpbmRleCBvcmRlcikuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS5cbiAgICBAc2luY2UgNC4wMi4wICopXG5cbnZhbCBlbXB0eSA6IHN0cmluZ1xuKCoqIFRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgb2ZfYnl0ZXMgOiBieXRlcyAtPiBzdHJpbmdcbigqKiBSZXR1cm4gYSBuZXcgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuIGJ5dGVcbiAgICBzZXF1ZW5jZS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCB0b19ieXRlcyA6IHN0cmluZyAtPiBieXRlc1xuKCoqIFJldHVybiBhIG5ldyBieXRlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuXG4gICAgc3RyaW5nLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuKCoqIFtsZW5ndGggc10gaXMgdGhlIGxlbmd0aCAobnVtYmVyIG9mIGJ5dGVzL2NoYXJhY3RlcnMpIG9mIFtzXS4gKilcblxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbigqKiBbZ2V0IHMgaV0gaXMgdGhlIGNoYXJhY3RlciBhdCBpbmRleCBbaV0gaW4gW3NdLiBUaGlzIGlzIHRoZSBzYW1lXG4gICAgYXMgd3JpdGluZyBbcy5baV1dLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIG5vdCBhbiBpbmRleCBvZiBbc10uICopXG5cbigqKiB7MTpjb25jYXQgQ29uY2F0ZW5hdGluZ31cblxuICAgIHtiIE5vdGUufSBUaGUgeyFTdGRsaWIuKCBeICl9IGJpbmFyeSBvcGVyYXRvciBjb25jYXRlbmF0ZXMgdHdvXG4gICAgc3RyaW5ncy4gKilcblxudmFsIGNvbmNhdCA6IHN0cmluZyAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbigqKiBbY29uY2F0IHNlcCBzc10gY29uY2F0ZW5hdGVzIHRoZSBsaXN0IG9mIHN0cmluZ3MgW3NzXSwgaW5zZXJ0aW5nXG4gICAgdGhlIHNlcGFyYXRvciBzdHJpbmcgW3NlcF0gYmV0d2VlbiBlYWNoLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhhblxuICAgIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy4gKilcblxudmFsIGNhdCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW2NhdCBzMSBzMl0gY29uY2F0ZW5hdGVzIHMxIGFuZCBzMiAoW3MxIF4gczJdKS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIHRoZSByZXN1bHQgaXMgbG9uZ2VyIHRoZW5cbiAgICB0aGFuIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbigqKiB7MTpwcmVkaWNhdGVzIFByZWRpY2F0ZXMgYW5kIGNvbXBhcmlzb25zfSAqKVxuXG52YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFtlcXVhbCBzMCBzMV0gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtzMF0gYW5kIFtzMV0gYXJlIGNoYXJhY3Rlci13aXNlXG4gICAgZXF1YWwuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxudmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4oKiogW2NvbXBhcmUgczAgczFdIHNvcnRzIFtzMF0gYW5kIFtzMV0gaW4gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyLiBbY29tcGFyZV1cbiAgICBiZWhhdmVzIGxpa2UgeyFTdGRsaWIuY29tcGFyZX0gb24gc3RyaW5ncyBidXQgbWF5IGJlIG1vcmUgZWZmaWNpZW50LiAqKVxuXG52YWwgc3RhcnRzX3dpdGggOlxuICBwcmVmaXggKCogY29tbWVudCB0aHdhcnRzIHRvb2xzL3N5bmNfc3RkbGliX2RvY3MgKikgOnN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtzdGFydHNfd2l0aCBdW35dW3ByZWZpeCBzXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW3NdIHN0YXJ0cyB3aXRoXG4gICAgW3ByZWZpeF0uXG5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBlbmRzX3dpdGggOlxuICBzdWZmaXggKCogY29tbWVudCB0aHdhcnRzIHRvb2xzL3N5bmNfc3RkbGliX2RvY3MgKikgOnN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtlbmRzX3dpdGggc3VmZml4IHNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbc10gZW5kcyB3aXRoIFtzdWZmaXhdLlxuXG4gICAgQHNpbmNlIDQuMTMuMCAqKVxuXG52YWwgY29udGFpbnNfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBib29sXG4oKiogW2NvbnRhaW5zX2Zyb20gcyBzdGFydCBjXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW2NdIGFwcGVhcnMgaW4gW3NdXG4gICAgYWZ0ZXIgcG9zaXRpb24gW3N0YXJ0XS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtzdGFydF0gaXMgbm90IGEgdmFsaWQgcG9zaXRpb24gaW4gW3NdLiAqKVxuXG52YWwgcmNvbnRhaW5zX2Zyb20gOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gYm9vbFxuKCoqIFtyY29udGFpbnNfZnJvbSBzIHN0b3AgY10gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtjXSBhcHBlYXJzIGluIFtzXVxuICAgIGJlZm9yZSBwb3NpdGlvbiBbc3RvcCsxXS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtzdG9wIDwgMF0gb3IgW3N0b3ArMV0gaXMgbm90IGEgdmFsaWRcbiAgICBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCBjb250YWlucyA6IHN0cmluZyAtPiBjaGFyIC0+IGJvb2xcbigqKiBbY29udGFpbnMgcyBjXSBpcyB7IVN0cmluZy5jb250YWluc19mcm9tfVsgcyAwIGNdLiAqKVxuXG4oKiogezE6ZXh0cmFjdCBFeHRyYWN0aW5nIHN1YnN0cmluZ3N9ICopXG5cbnZhbCBzdWIgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiBzdHJpbmdcbigqKiBbc3ViIHMgcG9zIGxlbl0gaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIFtsZW5dLCBjb250YWluaW5nIHRoZVxuICAgIHN1YnN0cmluZyBvZiBbc10gdGhhdCBzdGFydHMgYXQgcG9zaXRpb24gW3Bvc10gYW5kIGhhcyBsZW5ndGhcbiAgICBbbGVuXS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtwb3NdIGFuZCBbbGVuXSBkbyBub3QgZGVzaWduYXRlIGEgdmFsaWRcbiAgICBzdWJzdHJpbmcgb2YgW3NdLiAqKVxuXG52YWwgc3BsaXRfb25fY2hhciA6IGNoYXIgLT4gc3RyaW5nIC0+IHN0cmluZyBsaXN0XG4oKiogW3NwbGl0X29uX2NoYXIgc2VwIHNdIGlzIHRoZSBsaXN0IG9mIGFsbCAocG9zc2libHkgZW1wdHkpXG4gICAgc3Vic3RyaW5ncyBvZiBbc10gdGhhdCBhcmUgZGVsaW1pdGVkIGJ5IHRoZSBjaGFyYWN0ZXIgW3NlcF0uXG5cbiAgICBUaGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgc3BlY2lmaWVkIGJ5IHRoZSBmb2xsb3dpbmcgaW52YXJpYW50czpcbiAgICB7dWxcbiAgICB7LSBUaGUgbGlzdCBpcyBub3QgZW1wdHkufVxuICAgIHstIENvbmNhdGVuYXRpbmcgaXRzIGVsZW1lbnRzIHVzaW5nIFtzZXBdIGFzIGEgc2VwYXJhdG9yIHJldHVybnMgYVxuICAgICAgc3RyaW5nIGVxdWFsIHRvIHRoZSBpbnB1dCAoW2NvbmNhdCAobWFrZSAxIHNlcClcbiAgICAgIChzcGxpdF9vbl9jaGFyIHNlcCBzKSA9IHNdKS59XG4gICAgey0gTm8gc3RyaW5nIGluIHRoZSByZXN1bHQgY29udGFpbnMgdGhlIFtzZXBdIGNoYXJhY3Rlci59fVxuXG4gICAgQHNpbmNlIDQuMDQuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxuKCoqIHsxOnRyYW5zZm9ybWluZyBUcmFuc2Zvcm1pbmd9ICopXG5cbnZhbCBtYXAgOiAoY2hhciAtPiBjaGFyKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW21hcCBmIHNdIGlzIHRoZSBzdHJpbmcgcmVzdWx0aW5nIGZyb20gYXBwbHlpbmcgW2ZdIHRvIGFsbCB0aGVcbiAgICBjaGFyYWN0ZXJzIG9mIFtzXSBpbiBpbmNyZWFzaW5nIG9yZGVyLlxuXG4gICAgQHNpbmNlIDQuMDAuMCAqKVxuXG52YWwgbWFwaSA6IChpbnQgLT4gY2hhciAtPiBjaGFyKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW21hcGkgZiBzXSBpcyBsaWtlIHshbWFwfSBidXQgdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgaXMgYWxzb1xuICAgIHBhc3NlZCB0byBbZl0uXG5cbiAgICBAc2luY2UgNC4wMi4wICopXG5cbnZhbCBmb2xkX2xlZnQgOiAoJ2EgLT4gY2hhciAtPiAnYSkgLT4gJ2EgLT4gc3RyaW5nIC0+ICdhXG4oKiogW2ZvbGRfbGVmdCBmIHggc10gY29tcHV0ZXMgW2YgKC4uLiAoZiAoZiB4IHMuWzBdKSBzLlsxXSkgLi4uKSBzLltuLTFdXSxcbiAgICB3aGVyZSBbbl0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIFtzXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBmb2xkX3JpZ2h0IDogKGNoYXIgLT4gJ2EgLT4gJ2EpIC0+IHN0cmluZyAtPiAnYSAtPiAnYVxuKCoqIFtmb2xkX3JpZ2h0IGYgcyB4XSBjb21wdXRlcyBbZiBzLlswXSAoZiBzLlsxXSAoIC4uLiAoZiBzLltuLTFdIHgpIC4uLikpXSxcbiAgICB3aGVyZSBbbl0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIFtzXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBmb3JfYWxsIDogKGNoYXIgLT4gYm9vbCkgLT4gc3RyaW5nIC0+IGJvb2xcbigqKiBbZm9yX2FsbCBwIHNdIGNoZWNrcyBpZiBhbGwgY2hhcmFjdGVycyBpbiBbc10gc2F0aXNmeSB0aGUgcHJlZGljYXRlIFtwXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBleGlzdHMgOiAoY2hhciAtPiBib29sKSAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtleGlzdHMgcCBzXSBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBvZiBbc10gc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGVcbiAgICBbcF0uXG4gICAgQHNpbmNlIDQuMTMuMCAqKVxuXG52YWwgdHJpbSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbdHJpbSBzXSBpcyBbc10gd2l0aG91dCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiBXaGl0ZXNwYWNlXG4gICAgY2hhcmFjdGVycyBhcmU6IFsnICddLCBbJ1xceDBDJ10gKGZvcm0gZmVlZCksIFsnXFxuJ10sIFsnXFxyJ10sIGFuZCBbJ1xcdCddLlxuXG4gICAgQHNpbmNlIDQuMDAuMCAqKVxuXG52YWwgZXNjYXBlZCA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbZXNjYXBlZCBzXSBpcyBbc10gd2l0aCBzcGVjaWFsIGNoYXJhY3RlcnMgcmVwcmVzZW50ZWQgYnkgZXNjYXBlXG4gICAgc2VxdWVuY2VzLCBmb2xsb3dpbmcgdGhlIGxleGljYWwgY29udmVudGlvbnMgb2YgT0NhbWwuXG5cbiAgICBBbGwgY2hhcmFjdGVycyBvdXRzaWRlIHRoZSBVUy1BU0NJSSBwcmludGFibGUgcmFuZ2UgXFxbMHgyMDsweDdFXFxdIGFyZVxuICAgIGVzY2FwZWQsIGFzIHdlbGwgYXMgYmFja3NsYXNoICgweDJGKSBhbmQgZG91YmxlLXF1b3RlICgweDIyKS5cblxuICAgIFRoZSBmdW5jdGlvbiB7IVNjYW5mLnVuZXNjYXBlZH0gaXMgYSBsZWZ0IGludmVyc2Ugb2YgW2VzY2FwZWRdLFxuICAgIGkuZS4gW1NjYW5mLnVuZXNjYXBlZCAoZXNjYXBlZCBzKSA9IHNdIGZvciBhbnkgc3RyaW5nIFtzXSAodW5sZXNzXG4gICAgW2VzY2FwZWQgc10gZmFpbHMpLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhhblxuICAgIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy4gKilcblxudmFsIHVwcGVyY2FzZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbdXBwZXJjYXNlX2FzY2lpIHNdIGlzIFtzXSB3aXRoIGFsbCBsb3dlcmNhc2UgbGV0dGVyc1xuICAgIHRyYW5zbGF0ZWQgdG8gdXBwZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCBsb3dlcmNhc2VfYXNjaWkgOiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW2xvd2VyY2FzZV9hc2NpaSBzXSBpcyBbc10gd2l0aCBhbGwgdXBwZXJjYXNlIGxldHRlcnMgdHJhbnNsYXRlZFxuICAgIHRvIGxvd2VyY2FzZSwgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG52YWwgY2FwaXRhbGl6ZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbY2FwaXRhbGl6ZV9hc2NpaSBzXSBpcyBbc10gd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIHNldCB0b1xuICAgIHVwcGVyY2FzZSwgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG52YWwgdW5jYXBpdGFsaXplX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt1bmNhcGl0YWxpemVfYXNjaWkgc10gaXMgW3NdIHdpdGggdGhlIGZpcnN0IGNoYXJhY3RlciBzZXQgdG8gbG93ZXJjYXNlLFxuICAgIHVzaW5nIHRoZSBVUy1BU0NJSSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxuKCoqIHsxOnRyYXZlcnNpbmcgVHJhdmVyc2luZ30gKilcblxudmFsIGl0ZXIgOiAoY2hhciAtPiB1bml0KSAtPiBzdHJpbmcgLT4gdW5pdFxuKCoqIFtpdGVyIGYgc10gYXBwbGllcyBmdW5jdGlvbiBbZl0gaW4gdHVybiB0byBhbGwgdGhlIGNoYXJhY3RlcnMgb2YgW3NdLlxuICAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW2Ygcy5bMF07IGYgcy5bMV07IC4uLjsgZiBzLltsZW5ndGggcyAtIDFdOyAoKV0uICopXG5cbnZhbCBpdGVyaSA6IChpbnQgLT4gY2hhciAtPiB1bml0KSAtPiBzdHJpbmcgLT4gdW5pdFxuKCoqIFtpdGVyaV0gaXMgbGlrZSB7IWl0ZXJ9LCBidXQgdGhlIGZ1bmN0aW9uIGlzIGFsc28gZ2l2ZW4gdGhlXG4gICAgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXIgaW5kZXguXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbigqKiB7MTpzZWFyY2hpbmcgU2VhcmNoaW5nfSAqKVxuXG52YWwgaW5kZXhfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnRcbigqKiBbaW5kZXhfZnJvbSBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIFtjXSBpblxuICAgIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0uXG5cbiAgICBAcmFpc2UgTm90X2ZvdW5kIGlmIFtjXSBkb2VzIG5vdCBvY2N1ciBpbiBbc10gYWZ0ZXIgcG9zaXRpb24gW2ldLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cblxudmFsIGluZGV4X2Zyb21fb3B0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbaW5kZXhfZnJvbV9vcHQgcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBbY11cbiAgICBpbiBbc10gYWZ0ZXIgcG9zaXRpb24gW2ldIChpZiBhbnkpLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgcmluZGV4X2Zyb20gOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50XG4oKiogW3JpbmRleF9mcm9tIHMgaSBjXSBpcyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBbY10gaW5cbiAgICBbc10gYmVmb3JlIHBvc2l0aW9uIFtpKzFdLlxuXG4gICAgQHJhaXNlIE5vdF9mb3VuZCBpZiBbY10gZG9lcyBub3Qgb2NjdXIgaW4gW3NdIGJlZm9yZSBwb3NpdGlvbiBbaSsxXS5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaSsxXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCByaW5kZXhfZnJvbV9vcHQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtyaW5kZXhfZnJvbV9vcHQgcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIFtjXVxuICAgIGluIFtzXSBiZWZvcmUgcG9zaXRpb24gW2krMV0gKGlmIGFueSkuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaSsxXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uXG4gICAgQHNpbmNlIDQuMDUgKilcblxudmFsIGluZGV4IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50XG4oKiogW2luZGV4IHMgY10gaXMgeyFTdHJpbmcuaW5kZXhfZnJvbX1bIHMgMCBjXS4gKilcblxudmFsIGluZGV4X29wdCA6IHN0cmluZyAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbaW5kZXhfb3B0IHMgY10gaXMgeyFTdHJpbmcuaW5kZXhfZnJvbV9vcHR9WyBzIDAgY10uXG5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgcmluZGV4IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50XG4oKiogW3JpbmRleCBzIGNdIGlzIHshU3RyaW5nLnJpbmRleF9mcm9tfVsgcyAobGVuZ3RoIHMgLSAxKSBjXS4gKilcblxudmFsIHJpbmRleF9vcHQgOiBzdHJpbmcgLT4gY2hhciAtPiBpbnQgb3B0aW9uXG4oKiogW3JpbmRleF9vcHQgcyBjXSBpcyB7IVN0cmluZy5yaW5kZXhfZnJvbV9vcHR9WyBzIChsZW5ndGggcyAtIDEpIGNdLlxuXG4gICAgQHNpbmNlIDQuMDUgKilcblxuKCoqIHsxIFN0cmluZ3MgYW5kIFNlcXVlbmNlc30gKilcblxudmFsIHRvX3NlcSA6IHQgLT4gY2hhciBTZXEudFxuKCoqIFt0b19zZXEgc10gaXMgYSBzZXF1ZW5jZSBtYWRlIG9mIHRoZSBzdHJpbmcncyBjaGFyYWN0ZXJzIGluXG4gICAgaW5jcmVhc2luZyBvcmRlci4gSW4gW1widW5zYWZlLXN0cmluZ1wiXSBtb2RlLCBtb2RpZmljYXRpb25zIG9mIHRoZSBzdHJpbmdcbiAgICBkdXJpbmcgaXRlcmF0aW9uIHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZSBzZXF1ZW5jZS5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbnZhbCB0b19zZXFpIDogdCAtPiAoaW50ICogY2hhcikgU2VxLnRcbigqKiBbdG9fc2VxaSBzXSBpcyBsaWtlIHshdG9fc2VxfSBidXQgYWxzbyB0dXBsZXMgdGhlIGNvcnJlc3BvbmRpbmcgaW5kZXguXG5cbiAgICBAc2luY2UgNC4wNyAqKVxuXG52YWwgb2Zfc2VxIDogY2hhciBTZXEudCAtPiB0XG4oKiogW29mX3NlcSBzXSBpcyBhIHN0cmluZyBtYWRlIG9mIHRoZSBzZXF1ZW5jZSdzIGNoYXJhY3RlcnMuXG5cbiAgICBAc2luY2UgNC4wNyAqKVxuXG4oKiogezE6dXRmIFVURiBkZWNvZGluZyBhbmQgdmFsaWRhdGlvbnN9XG5cbiAgICBAc2luY2UgNC4xNCAqKVxuXG4oKiogezI6dXRmXzggVVRGLTh9ICopXG5cbnZhbCBnZXRfdXRmXzhfdWNoYXIgOiB0IC0+IGludCAtPiBVY2hhci51dGZfZGVjb2RlXG4oKiogW2dldF91dGZfOF91Y2hhciBiIGldIGRlY29kZXMgYW4gVVRGLTggY2hhcmFjdGVyIGF0IGluZGV4IFtpXSBpblxuICAgIFtiXS4gKilcblxudmFsIGlzX3ZhbGlkX3V0Zl84IDogdCAtPiBib29sXG4oKiogW2lzX3ZhbGlkX3V0Zl84IGJdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbYl0gY29udGFpbnMgdmFsaWRcbiAgICBVVEYtOCBkYXRhLiAqKVxuXG4oKiogezI6dXRmXzE2YmUgVVRGLTE2QkV9ICopXG5cbnZhbCBnZXRfdXRmXzE2YmVfdWNoYXIgOiB0IC0+IGludCAtPiBVY2hhci51dGZfZGVjb2RlXG4oKiogW2dldF91dGZfMTZiZV91Y2hhciBiIGldIGRlY29kZXMgYW4gVVRGLTE2QkUgY2hhcmFjdGVyIGF0IGluZGV4XG4gICAgW2ldIGluIFtiXS4gKilcblxudmFsIGlzX3ZhbGlkX3V0Zl8xNmJlIDogdCAtPiBib29sXG4oKiogW2lzX3ZhbGlkX3V0Zl8xNmJlIGJdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbYl0gY29udGFpbnMgdmFsaWRcbiAgICBVVEYtMTZCRSBkYXRhLiAqKVxuXG4oKiogezI6dXRmXzE2bGUgVVRGLTE2TEV9ICopXG5cbnZhbCBnZXRfdXRmXzE2bGVfdWNoYXIgOiB0IC0+IGludCAtPiBVY2hhci51dGZfZGVjb2RlXG4oKiogW2dldF91dGZfMTZsZV91Y2hhciBiIGldIGRlY29kZXMgYW4gVVRGLTE2TEUgY2hhcmFjdGVyIGF0IGluZGV4XG4gICAgW2ldIGluIFtiXS4gKilcblxudmFsIGlzX3ZhbGlkX3V0Zl8xNmxlIDogdCAtPiBib29sXG4oKiogW2lzX3ZhbGlkX3V0Zl8xNmxlIGJdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbYl0gY29udGFpbnMgdmFsaWRcbiAgICBVVEYtMTZMRSBkYXRhLiAqKVxuXG4oKiogezE6ZGVwcmVjYXRlZCBEZXByZWNhdGVkIGZ1bmN0aW9uc30gKilcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlIEJ5dGVzLmNyZWF0ZS9CeXRlc0xhYmVscy5jcmVhdGUgaW5zdGVhZC5cIl1cbigqKiBbY3JlYXRlIG5dIHJldHVybnMgYSBmcmVzaCBieXRlIHNlcXVlbmNlIG9mIGxlbmd0aCBbbl0uXG4gICAgVGhlIHNlcXVlbmNlIGlzIHVuaW5pdGlhbGl6ZWQgYW5kIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcy5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS5cblxuICAgIEBkZXByZWNhdGVkIFRoaXMgaXMgYSBkZXByZWNhdGVkIGFsaWFzIG9mXG4gICAgeyFCeXRlcy5jcmVhdGV9L3shQnl0ZXNMYWJlbHMuY3JlYXRlfS4gKilcblxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgQnl0ZXMuc2V0L0J5dGVzTGFiZWxzLnNldCBpbnN0ZWFkLlwiXVxuKCoqIFtzZXQgcyBuIGNdIG1vZGlmaWVzIGJ5dGUgc2VxdWVuY2UgW3NdIGluIHBsYWNlLFxuICAgIHJlcGxhY2luZyB0aGUgYnl0ZSBhdCBpbmRleCBbbl0gd2l0aCBbY10uXG4gICAgWW91IGNhbiBhbHNvIHdyaXRlIFtzLltuXSA8LSBjXSBpbnN0ZWFkIG9mIFtzZXQgcyBuIGNdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtuXSBpcyBub3QgYSB2YWxpZCBpbmRleCBpbiBbc10uXG5cbiAgICBAZGVwcmVjYXRlZCBUaGlzIGlzIGEgZGVwcmVjYXRlZCBhbGlhcyBvZlxuICAgIHshQnl0ZXMuc2V0fS97IUJ5dGVzTGFiZWxzLnNldH0uICopXG5cbnZhbCBibGl0IDpcbiAgc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbigqKiBbYmxpdCBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5dIGNvcGllcyBbbGVuXSBieXRlc1xuICAgIGZyb20gdGhlIHN0cmluZyBbc3JjXSwgc3RhcnRpbmcgYXQgaW5kZXggW3NyY19wb3NdLFxuICAgIHRvIGJ5dGUgc2VxdWVuY2UgW2RzdF0sIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBudW1iZXIgW2RzdF9wb3NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3NyY19wb3NdIGFuZCBbbGVuXSBkbyBub3RcbiAgICBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbc3JjXSwgb3IgaWYgW2RzdF9wb3NdIGFuZCBbbGVuXVxuICAgIGRvIG5vdCBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbZHN0XS4gKilcblxudmFsIGNvcHkgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJTdHJpbmdzIG5vdyBpbW11dGFibGU6IG5vIG5lZWQgdG8gY29weVwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGdpdmVuIHN0cmluZy5cblxuICAgIEBkZXByZWNhdGVkIEJlY2F1c2Ugc3RyaW5ncyBhcmUgaW1tdXRhYmxlLCBpdCBkb2Vzbid0IG1ha2UgbXVjaFxuICAgIHNlbnNlIHRvIG1ha2UgaWRlbnRpY2FsIGNvcGllcyBvZiB0aGVtLiAqKVxuXG52YWwgZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgQnl0ZXMuZmlsbC9CeXRlc0xhYmVscy5maWxsIGluc3RlYWQuXCJdXG4oKiogW2ZpbGwgcyBwb3MgbGVuIGNdIG1vZGlmaWVzIGJ5dGUgc2VxdWVuY2UgW3NdIGluIHBsYWNlLFxuICAgIHJlcGxhY2luZyBbbGVuXSBieXRlcyBieSBbY10sIHN0YXJ0aW5nIGF0IFtwb3NdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtwb3NdIGFuZCBbbGVuXSBkbyBub3RcbiAgICBkZXNpZ25hdGUgYSB2YWxpZCBzdWJzdHJpbmcgb2YgW3NdLlxuXG4gICAgQGRlcHJlY2F0ZWQgVGhpcyBpcyBhIGRlcHJlY2F0ZWQgYWxpYXMgb2ZcbiAgICB7IUJ5dGVzLmZpbGx9L3shQnl0ZXNMYWJlbHMuZmlsbH0uICopXG5cbnZhbCB1cHBlcmNhc2UgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRcbiAgICBcIlVzZSBTdHJpbmcudXBwZXJjYXNlX2FzY2lpL1N0cmluZ0xhYmVscy51cHBlcmNhc2VfYXNjaWkgaW5zdGVhZC5cIl1cbigqKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBhcmd1bWVudCwgd2l0aCBhbGwgbG93ZXJjYXNlIGxldHRlcnNcbiAgICB0cmFuc2xhdGVkIHRvIHVwcGVyY2FzZSwgaW5jbHVkaW5nIGFjY2VudGVkIGxldHRlcnMgb2YgdGhlIElTT1xuICAgIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG52YWwgbG93ZXJjYXNlIDogc3RyaW5nIC0+IHN0cmluZ1xuICBbQEBvY2FtbC5kZXByZWNhdGVkXG4gICAgXCJVc2UgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaS9TdHJpbmdMYWJlbHMubG93ZXJjYXNlX2FzY2lpIGluc3RlYWQuXCJdXG4oKiogUmV0dXJuIGEgY29weSBvZiB0aGUgYXJndW1lbnQsIHdpdGggYWxsIHVwcGVyY2FzZSBsZXR0ZXJzXG4gICAgdHJhbnNsYXRlZCB0byBsb3dlcmNhc2UsIGluY2x1ZGluZyBhY2NlbnRlZCBsZXR0ZXJzIG9mIHRoZSBJU09cbiAgICBMYXRpbi0xICg4ODU5LTEpIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAZGVwcmVjYXRlZCBGdW5jdGlvbnMgb3BlcmF0aW5nIG9uIExhdGluLTEgY2hhcmFjdGVyIHNldCBhcmUgZGVwcmVjYXRlZC4gKilcblxudmFsIGNhcGl0YWxpemUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRcbiAgICBcIlVzZSBTdHJpbmcuY2FwaXRhbGl6ZV9hc2NpaS9TdHJpbmdMYWJlbHMuY2FwaXRhbGl6ZV9hc2NpaSBpbnN0ZWFkLlwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50LCB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvIHVwcGVyY2FzZSxcbiAgICB1c2luZyB0aGUgSVNPIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC4uXG5cbiAgICBAZGVwcmVjYXRlZCBGdW5jdGlvbnMgb3BlcmF0aW5nIG9uIExhdGluLTEgY2hhcmFjdGVyIHNldCBhcmUgZGVwcmVjYXRlZC4gKilcblxudmFsIHVuY2FwaXRhbGl6ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZFxuICAgIFwiVXNlIFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkvU3RyaW5nTGFiZWxzLnVuY2FwaXRhbGl6ZV9hc2NpaSBpbnN0ZWFkLlwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50LCB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvIGxvd2VyY2FzZSxcbiAgICB1c2luZyB0aGUgSVNPIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG4oKiogezEgQmluYXJ5IGRlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIHNlY3Rpb24gYmluYXJ5IGRlY29kZSBpbnRlZ2VycyBmcm9tIHN0cmluZ3MuXG5cbiAgICBBbGwgZm9sbG93aW5nIGZ1bmN0aW9ucyByYWlzZSBbSW52YWxpZF9hcmd1bWVudF0gaWYgdGhlIGNoYXJhY3RlcnNcbiAgICBuZWVkZWQgYXQgaW5kZXggW2ldIHRvIGRlY29kZSB0aGUgaW50ZWdlciBhcmUgbm90IGF2YWlsYWJsZS5cblxuICAgIExpdHRsZS1lbmRpYW4gKHJlc3AuIGJpZy1lbmRpYW4pIGVuY29kaW5nIG1lYW5zIHRoYXQgbGVhc3RcbiAgICAocmVzcC4gbW9zdCkgc2lnbmlmaWNhbnQgYnl0ZXMgYXJlIHN0b3JlZCBmaXJzdC4gIEJpZy1lbmRpYW4gaXNcbiAgICBhbHNvIGtub3duIGFzIG5ldHdvcmsgYnl0ZSBvcmRlci4gIE5hdGl2ZS1lbmRpYW4gZW5jb2RpbmcgaXNcbiAgICBlaXRoZXIgbGl0dGxlLWVuZGlhbiBvciBiaWctZW5kaWFuIGRlcGVuZGluZyBvbiB7IVN5cy5iaWdfZW5kaWFufS5cblxuICAgIDMyLWJpdCBhbmQgNjQtYml0IGludGVnZXJzIGFyZSByZXByZXNlbnRlZCBieSB0aGUgW2ludDMyXSBhbmRcbiAgICBbaW50NjRdIHR5cGVzLCB3aGljaCBjYW4gYmUgaW50ZXJwcmV0ZWQgZWl0aGVyIGFzIHNpZ25lZCBvclxuICAgIHVuc2lnbmVkIG51bWJlcnMuXG5cbiAgICA4LWJpdCBhbmQgMTYtYml0IGludGVnZXJzIGFyZSByZXByZXNlbnRlZCBieSB0aGUgW2ludF0gdHlwZSxcbiAgICB3aGljaCBoYXMgbW9yZSBiaXRzIHRoYW4gdGhlIGJpbmFyeSBlbmNvZGluZy4gIFRoZXNlIGV4dHJhIGJpdHNcbiAgICBhcmUgc2lnbi1leHRlbmRlZCAob3IgemVyby1leHRlbmRlZCkgZm9yIGZ1bmN0aW9ucyB3aGljaCBkZWNvZGUgOC1iaXRcbiAgICBvciAxNi1iaXQgaW50ZWdlcnMgYW5kIHJlcHJlc2VudGVkIHRoZW0gd2l0aCBbaW50XSB2YWx1ZXMuXG4qKVxuXG52YWwgZ2V0X3VpbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQ4IGIgaV0gaXMgW2JdJ3MgdW5zaWduZWQgOC1iaXQgaW50ZWdlciBzdGFydGluZyBhdCBjaGFyYWN0ZXJcbiAgICBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDggOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50OCBiIGldIGlzIFtiXSdzIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IGNoYXJhY3RlclxuICAgIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQxNl9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF91aW50MTZfYmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfdWludDE2X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X3VpbnQxNl9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF91aW50MTZfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50MTZfbmUgYiBpXSBpcyBbYl0ncyBuYXRpdmUtZW5kaWFuIHNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDE2X2JlIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X2ludDE2X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQxNl9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF9pbnQxNl9sZSBiIGldIGlzIFtiXSdzIGxpdHRsZS1lbmRpYW4gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyXG4oKiogW2dldF9pbnQzMl9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gMzItYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQzMl9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzJcbigqKiBbZ2V0X2ludDMyX2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiAzMi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDMyX2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMlxuKCoqIFtnZXRfaW50MzJfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIDMyLWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0XG4oKiogW2dldF9pbnQ2NF9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gNjQtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQ2NF9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjRcbigqKiBbZ2V0X2ludDY0X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiA2NC1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDY0X2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NFxuKCoqIFtnZXRfaW50NjRfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIDY0LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbigqKi8qKilcblxuKCogVGhlIGZvbGxvd2luZyBpcyBmb3Igc3lzdGVtIHVzZSBvbmx5LiBEbyBub3QgY2FsbCBkaXJlY3RseS4gKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT5cbiAgICB1bml0ID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuICBbQEBvY2FtbC5kZXByZWNhdGVkXVxuIl19
