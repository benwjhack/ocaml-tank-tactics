// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_snd=caml_string_of_jsbytes("snd"),
     cst_fst=caml_string_of_jsbytes("fst"),
     cst_validation_errors=caml_string_of_jsbytes("validation errors"),
     cst$0=caml_string_of_jsbytes(""),
     cst_Exception_raised_during_va=
      caml_string_of_jsbytes("Exception raised during validation"),
     cst_Validate=caml_string_of_jsbytes("Validate"),
     cst_validate=caml_string_of_jsbytes("validate"),
     cst_validate_src_validate_ml=
      caml_string_of_jsbytes("validate/src/validate.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_validate$0=caml_string_of_jsbytes("validate"),
     cst_validate$1=caml_string_of_jsbytes("validate"),
     cst_Validate$0=caml_string_of_jsbytes("Validate"),
     Base_Maybe_bound=global_data.Base__Maybe_bound,
     Assert_failure=global_data.Assert_failure,
     Base_Printf=global_data.Base__Printf,
     Base_List=global_data.Base__List,
     Base_Int=global_data.Base__Int,
     Base_Staged=global_data.Base__Staged,
     Base_Field=global_data.Base__Field,
     Base_Or_error=global_data.Base__Or_error,
     Base=global_data.Base,
     Base_Error=global_data.Base__Error,
     Base_String=global_data.Base__String,
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime;
    caml_call1(Ppx_module_timer_runtime[4],cst_Validate);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_validate);
    caml_call1(Expect_test_collector[5][1],cst_validate_src_validate_ml);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_validate$0,cst);
    var
     _c_=[0,caml_string_of_jsbytes("validate/src/validate.ml"),154,20],
     _d_=
      [0,
       [11,
        caml_string_of_jsbytes("value "),
        [2,0,[11,caml_string_of_jsbytes(" < bound "),[2,0,0]]]],
       caml_string_of_jsbytes("value %s < bound %s")],
     _e_=
      [0,
       [11,
        caml_string_of_jsbytes("value "),
        [2,0,[11,caml_string_of_jsbytes(" <= bound "),[2,0,0]]]],
       caml_string_of_jsbytes("value %s <= bound %s")],
     _f_=[0,caml_string_of_jsbytes("validate/src/validate.ml"),159,20],
     _g_=
      [0,
       [11,
        caml_string_of_jsbytes("value "),
        [2,0,[11,caml_string_of_jsbytes(" > bound "),[2,0,0]]]],
       caml_string_of_jsbytes("value %s > bound %s")],
     _h_=
      [0,
       [11,
        caml_string_of_jsbytes("value "),
        [2,0,[11,caml_string_of_jsbytes(" >= bound "),[2,0,0]]]],
       caml_string_of_jsbytes("value %s >= bound %s")],
     _b_=[0,0],
     _a_=[0,caml_string_of_jsbytes(".")],
     pass=0;
    function fails(message,a,sexp_of_a)
     {return [0,[0,0,caml_call5(Base_Error[17],0,0,message,a,sexp_of_a)],0]}
    function fail(message)
     {return [0,[0,0,caml_call1(Base_Error[12],message)],0]}
    function failf(format){return caml_call2(Base_Printf[4],fail,format)}
    function fail_s(sexp){return [0,[0,0,caml_call1(Base_Error[18],sexp)],0]}
    function combine(t1,t2){return caml_call2(Base[178],t1,t2)}
    var of_list=Base_List[138];
    function name(name,t)
     {if(! t)return 0;
      function _P_(param)
       {var error=param[2],path=param[1];return [0,[0,name,path],error]}
      return caml_call2(Base_List[76],t,_P_)}
    function name_list(n,l){return name(n,caml_call1(of_list,l))}
    function fail_fn(message,param){return fail(message)}
    function pass_bool(param){return pass}
    function pass_unit(param){return pass}
    function protect(f,v)
     {try
       {var _O_=caml_call1(f,v);return _O_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var _N_=[0,[0,cst$0,caml_call1(Base[106],exn)],0];
        return fail_s
                (caml_call2(Base[84][7],cst_Exception_raised_during_va,_N_))}}
    function try_with(f)
     {var _M_=0;
      return protect(function(param){caml_call1(f,0);return pass},_M_)}
    function path_string(path){return caml_call2(Base_String[54],_a_,path)}
    function errors(t)
     {function _J_(param)
       {var
         error=param[2],
         path=param[1],
         _K_=path_string(path),
         _L_=caml_call2(Base_Error[20],error,_K_);
        return caml_call1(Base_Error[9],_L_)}
      return caml_call2(Base_List[76],t,_J_)}
    function result(t)
     {if(caml_call1(Base_List[8],t))return _b_;
      function _F_(x_005)
       {function _I_(param)
         {var
           arg1_002=param[2],
           arg0_001=param[1],
           res0_003=caml_call1(Base[164],arg0_001),
           res1_004=caml_call1(Base_Error[6],arg1_002);
          return [1,[0,res0_003,[0,res1_004,0]]]}
        return caml_call2(Base_List[4],_I_,x_005)}
      function _G_(param)
       {var error=param[2],path=param[1];return [0,path_string(path),error]}
      var _H_=caml_call2(Base_List[76],t,_G_);
      return caml_call5(Base_Or_error[34],0,0,cst_validation_errors,_H_,_F_)}
    function maybe_raise(t)
     {var _E_=result(t);return caml_call1(Base_Or_error[31],_E_)}
    function valid_or_error(check,x)
     {function _C_(param){return x}
      var _D_=result(protect(check,x));
      return caml_call2(Base_Or_error[43],_D_,_C_)}
    function field_direct(check,fld,record,v)
     {var result=protect(check,v);
      return name(caml_call1(Base_Field[2],fld),result)}
    function field(check,record,fld)
     {var v=caml_call2(Base_Field[3],fld,record);
      return field_direct(check,fld,record,v)}
    function field_folder(check,record)
     {return function(acc,fld){return [0,field(check,record,fld),acc]}}
    function field_direct_folder(check)
     {function _B_(acc,fld,record,v)
       {var result=field_direct(check,fld,record,v);
        return result?[0,result,acc]:acc}
      return caml_call1(Base_Staged[1],_B_)}
    function all(checks,v)
     {var checks$0=checks,errs=0;
      for(;;)
       {if(! checks$0)
         return caml_call1(of_list,caml_call1(Base_List[38],errs));
        var checks$1=checks$0[2],check=checks$0[1],err=protect(check,v);
        if(err)
         {var errs$0=[0,err,errs],checks$0=checks$1,errs=errs$0;continue}
        var checks$0=checks$1}}
    function of_result(f)
     {function _z_(v)
       {var match=caml_call1(f,v);
        if(0 === match[0])return pass;
        var error=match[1];
        return fail(error)}
      return function(_A_){return protect(_z_,_A_)}}
    function of_error(f)
     {function _x_(v)
       {var match=caml_call1(f,v);
        if(0 === match[0])return pass;
        var error=match[1];
        return [0,[0,0,error],0]}
      return function(_y_){return protect(_x_,_y_)}}
    function booltest(f,if_false)
     {function _v_(v){return caml_call1(f,v)?pass:fail(if_false)}
      return function(_w_){return protect(_v_,_w_)}}
    function pair(fst,snd,param)
     {var
       snd_value=param[2],
       fst_value=param[1],
       _u_=[0,name(cst_snd,protect(snd,snd_value)),0];
      return caml_call1(of_list,[0,name(cst_fst,protect(fst,fst_value)),_u_])}
    function list_indexed(check,list)
     {function _s_(i,el)
       {var _t_=protect(check,el);
        return name(caml_call1(Base_Int[11],i + 1 | 0),_t_)}
      return caml_call1(of_list,caml_call2(Base_List[96],list,_s_))}
    function list(extract_name,check,list)
     {function _r_(el)
       {var t=protect(check,el);
        return t
                ?protect
                  (function(t){return name(caml_call1(extract_name,el),t)},t)
                :0}
      return caml_call1(of_list,caml_call2(Base_List[76],list,_r_))}
    function alist(name,f,list$0)
     {function _q_(param){var x=param[2];return caml_call1(f,x)}
      return list
              (function(param){var key=param[1];return caml_call1(name,key)},
               _q_,
               list$0)}
    function first_failure(t1,t2){return caml_call1(Base_List[8],t1)?t2:t1}
    function of_error_opt(param)
     {if(! param)return pass;var error=param[1];return fail(error)}
    function bounded(name,lower,upper,compare,x)
     {var match=caml_call4(Base_Maybe_bound[16],lower,upper,x,compare);
      switch(match)
       {case 0:
         if(typeof lower === "number")throw [0,Assert_failure,_c_];
         if(0 === lower[0])
          {var incl=lower[1],_i_=caml_call1(name,incl),_j_=caml_call1(name,x);
           return fail(caml_call3(Base_Printf[2],_d_,_j_,_i_))}
         var excl=lower[1],_k_=caml_call1(name,excl),_l_=caml_call1(name,x);
         return fail(caml_call3(Base_Printf[2],_e_,_l_,_k_));
        case 1:return pass;
        default:
         if(typeof upper === "number")throw [0,Assert_failure,_f_];
         if(0 === upper[0])
          {var
            incl$0=upper[1],
            _m_=caml_call1(name,incl$0),
            _n_=caml_call1(name,x);
           return fail(caml_call3(Base_Printf[2],_g_,_n_,_m_))}
         var
          excl$0=upper[1],
          _o_=caml_call1(name,excl$0),
          _p_=caml_call1(name,x);
         return fail(caml_call3(Base_Printf[2],_h_,_p_,_o_))}}
    function symbol(t1,t2){return combine(t1,t2)}
    var Infix=[0,symbol];
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_validate$1);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Validate$0);
    var
     Validate=
      [0,
       pass,
       fail,
       fails,
       fail_s,
       failf,
       combine,
       of_list,
       name,
       name_list,
       fail_fn,
       pass_bool,
       pass_unit,
       protect,
       try_with,
       result,
       errors,
       maybe_raise,
       valid_or_error,
       field,
       field_direct,
       field_folder,
       field_direct_folder,
       all,
       of_result,
       of_error,
       booltest,
       pair,
       list_indexed,
       list,
       first_failure,
       of_error_opt,
       alist,
       bounded,
       Infix];
    runtime.caml_register_global(35,Validate,"Validate");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ2YWxpZGF0ZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicGFzcyIsImZhaWxzIiwibWVzc2FnZSIsImEiLCJzZXhwX29mX2EiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJmYWlsX3MiLCJzZXhwIiwiY29tYmluZSIsInQxIiwidDIiLCJvZl9saXN0IiwibmFtZSIsInQiLCJlcnJvciIsInBhdGgiLCJuYW1lX2xpc3QiLCJuIiwibCIsImZhaWxfZm4iLCJwYXNzX2Jvb2wiLCJwYXNzX3VuaXQiLCJwcm90ZWN0IiwiZiIsInYiLCJleG4iLCJ0cnlfd2l0aCIsInBhdGhfc3RyaW5nIiwiZXJyb3JzIiwicmVzdWx0IiwieF8wMDUiLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsIm1heWJlX3JhaXNlIiwidmFsaWRfb3JfZXJyb3IiLCJjaGVjayIsIngiLCJmaWVsZF9kaXJlY3QiLCJmbGQiLCJyZWNvcmQiLCJmaWVsZCIsImZpZWxkX2ZvbGRlciIsImFjYyIsImZpZWxkX2RpcmVjdF9mb2xkZXIiLCJhbGwiLCJjaGVja3MiLCJjaGVja3MkMCIsImVycnMiLCJjaGVja3MkMSIsImVyciIsImVycnMkMCIsIm9mX3Jlc3VsdCIsIm9mX2Vycm9yIiwiYm9vbHRlc3QiLCJpZl9mYWxzZSIsInBhaXIiLCJmc3QiLCJzbmQiLCJzbmRfdmFsdWUiLCJmc3RfdmFsdWUiLCJsaXN0X2luZGV4ZWQiLCJsaXN0IiwiaSIsImVsIiwiZXh0cmFjdF9uYW1lIiwiYWxpc3QiLCJsaXN0JDAiLCJrZXkiLCJmaXJzdF9mYWlsdXJlIiwib2ZfZXJyb3Jfb3B0IiwiYm91bmRlZCIsImxvd2VyIiwidXBwZXIiLCJjb21wYXJlIiwiaW5jbCIsImV4Y2wiLCJpbmNsJDAiLCJleGNsJDAiLCJzeW1ib2wiXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvY29yZS92YWxpZGF0ZS92YWxpZGF0ZS5tbCJdLCJtYXBwaW5ncyI6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QUEyQzthQUV6RDhEO01BQWUsV0FDUCxPQXBJUnpFLEtBcUljLElBQVRnQixlQUFTLE9BL0hkWCxLQStIS1csTUFBbUI7YUFHeEIwRCxRQUFTNUQsS0FBTTZELE1BQU9DLE1BQU9DLFFBQVFyQztNQUNqQywwQ0FEV21DLE1BQU9DLE1BQWVwQyxFQUFScUM7TUFDekI7O1NBR0osVUFKZUYsbUJBS0M7U0FEaEIsU0FKZUE7V0FNQyxTQU5EQSxTQU1xRCxlQU4zRDdELEtBTURnRSxNQUFtRCxlQU5sRGhFLEtBQTRCMEI7V0FNaEIsT0F4SXJCbkMsS0F3SXFCO1NBQ0wsU0FQRHNFLFNBT3NELGVBUDVEN0QsS0FPRGlFLE1BQW9ELGVBUG5EakUsS0FBNEIwQjtTQU9oQixPQXpJckJuQyxLQXlJcUI7ZUFMVCxPQTFJWkw7O1NBaUpBLFVBVHNCNEUsbUJBVU47U0FEaEIsU0FUc0JBO1dBV047bUJBWE1BO1lBVzhDLGVBWDNEOUQsS0FXRGtFO1lBQW1ELGVBWGxEbEUsS0FBNEIwQjtXQVdoQixPQTdJckJuQyxLQTZJcUI7U0FDTDtpQkFaTXVFO1VBWStDLGVBWjVEOUQsS0FZRG1FO1VBQW9ELGVBWm5EbkUsS0FBNEIwQjtTQVloQixPQTlJckJuQyxLQThJcUIsd0NBQTZEO2FBSWhGNkUsT0FBT3ZFLEdBQUdDLElBQUssT0EvSWpCRixRQStJU0MsR0FBR0MsR0FBa0I7aUJBQTVCc0U7Ozs7Ozs7O09BeEpGbEY7T0FNQUs7T0FKQUo7T0FNQU87T0FEQUY7T0FFQUk7T0FDQUc7T0FFQUM7T0FNQUk7T0FDQUc7T0FDQUM7T0FDQUM7T0FFQUM7T0FNQUk7T0F5QkFHO09BZkFEO09BaUJBTztPQUNBQztPQU9BTTtPQUxBSDtPQVVBSTtPQUtBRTtPQU9BQztPQVlBTztPQU9BQztPQU9BQztPQUVBRTtPQUlBSztPQUtBQztPQVdBTztPQUVBQztPQUhBSjtPQVFBSzs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuIEJhc2VcblxuKCoqIEVhY2ggc2luZ2xlX2Vycm9yIGlzIGEgcGF0aCBpbmRpY2F0aW5nIHRoZSBsb2NhdGlvbiB3aXRoaW4gdGhlIGRhdGFzdHJ1Y3R1cmUgaW5cbiAgICBxdWVzdGlvbiB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZCwgYWxvbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlLiAqKVxudHlwZSBzaW5nbGVfZXJyb3IgPVxuICB7IHBhdGggOiBzdHJpbmcgbGlzdFxuICA7IGVycm9yIDogRXJyb3IudFxuICB9XG5cbnR5cGUgdCA9IHNpbmdsZV9lcnJvciBsaXN0XG50eXBlICdhIGNoZWNrID0gJ2EgLT4gdFxuXG5sZXQgcGFzcyA6IHQgPSBbXVxuXG5sZXQgZmFpbHMgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFsgeyBwYXRoID0gW107IGVycm9yID0gRXJyb3IuY3JlYXRlIG1lc3NhZ2UgYSBzZXhwX29mX2EgfSBdXG47O1xuXG5sZXQgZmFpbCBtZXNzYWdlID0gWyB7IHBhdGggPSBbXTsgZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgbWVzc2FnZSB9IF1cbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcbmxldCBmYWlsX3Mgc2V4cCA9IFsgeyBwYXRoID0gW107IGVycm9yID0gRXJyb3IuY3JlYXRlX3Mgc2V4cCB9IF1cbmxldCBjb21iaW5lIHQxIHQyID0gdDEgQCB0MlxubGV0IG9mX2xpc3QgPSBMaXN0LmNvbmNhdFxuXG5sZXQgbmFtZSBuYW1lIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXSAoKiB3aGVuIHN1Y2Nlc3NmdWwsIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIGEgY2xvc3VyZSBmb3IgW35mXSwgYmVsb3cgKilcbiAgfCBfIC0+IExpc3QubWFwIHQgfmY6KGZ1biB7IHBhdGg7IGVycm9yIH0gLT4geyBwYXRoID0gbmFtZSA6OiBwYXRoOyBlcnJvciB9KVxuOztcblxubGV0IG5hbWVfbGlzdCBuIGwgPSBuYW1lIG4gKG9mX2xpc3QgbClcbmxldCBmYWlsX2ZuIG1lc3NhZ2UgXyA9IGZhaWwgbWVzc2FnZVxubGV0IHBhc3NfYm9vbCAoXyA6IGJvb2wpID0gcGFzc1xubGV0IHBhc3NfdW5pdCAoXyA6IHVuaXQpID0gcGFzc1xuXG5sZXQgcHJvdGVjdCBmIHYgPVxuICB0cnkgZiB2IHdpdGhcbiAgfCBleG4gLT5cbiAgICBmYWlsX3MgKFNleHAubWVzc2FnZSBcIkV4Y2VwdGlvbiByYWlzZWQgZHVyaW5nIHZhbGlkYXRpb25cIiBbIFwiXCIsIHNleHBfb2ZfZXhuIGV4biBdKVxuOztcblxubGV0IHRyeV93aXRoIGYgPVxuICBwcm90ZWN0XG4gICAgKGZ1biAoKSAtPlxuICAgICAgIGYgKCk7XG4gICAgICAgcGFzcylcbiAgICAoKVxuOztcblxubGV0IHBhdGhfc3RyaW5nIHBhdGggPSBTdHJpbmcuY29uY2F0IH5zZXA6XCIuXCIgcGF0aFxuXG5sZXQgZXJyb3JzIHQgPVxuICBMaXN0Lm1hcCB0IH5mOihmdW4geyBwYXRoOyBlcnJvciB9IC0+XG4gICAgRXJyb3IudG9fc3RyaW5nX2h1bSAoRXJyb3IudGFnIGVycm9yIH50YWc6KHBhdGhfc3RyaW5nIHBhdGgpKSlcbjs7XG5cbmxldCByZXN1bHRfZmFpbCB0ID1cbiAgT3JfZXJyb3IuZXJyb3JcbiAgICBcInZhbGlkYXRpb24gZXJyb3JzXCJcbiAgICAoTGlzdC5tYXAgdCB+ZjooZnVuIHsgcGF0aDsgZXJyb3IgfSAtPiBwYXRoX3N0cmluZyBwYXRoLCBlcnJvcikpXG4gICAgWyVzZXhwX29mOiAoc3RyaW5nICogRXJyb3IudCkgTGlzdC50XVxuW0BAY29sZF1cbjs7XG5cbigqKiBbcmVzdWx0XSBpcyBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5saW5lZCAtLSBjYWxsaW5nIFtyZXN1bHRfZmFpbF0sXG4gICAgd2hpY2ggaXMgbm90IGlubGluZWFibGUsIGlzIGtleSB0byB0aGlzLiAqKVxubGV0IHJlc3VsdCB0ID0gaWYgTGlzdC5pc19lbXB0eSB0IHRoZW4gT2sgKCkgZWxzZSByZXN1bHRfZmFpbCB0XG5cbmxldCBtYXliZV9yYWlzZSB0ID0gT3JfZXJyb3Iub2tfZXhuIChyZXN1bHQgdClcbmxldCB2YWxpZF9vcl9lcnJvciBjaGVjayB4ID0gT3JfZXJyb3IubWFwIChyZXN1bHQgKHByb3RlY3QgY2hlY2sgeCkpIH5mOihmdW4gKCkgLT4geClcblxubGV0IGZpZWxkX2RpcmVjdCBjaGVjayBmbGQgX3JlY29yZCB2ID1cbiAgbGV0IHJlc3VsdCA9IHByb3RlY3QgY2hlY2sgdiBpblxuICBuYW1lIChGaWVsZC5uYW1lIGZsZCkgcmVzdWx0XG47O1xuXG5sZXQgZmllbGQgY2hlY2sgcmVjb3JkIGZsZCA9XG4gIGxldCB2ID0gRmllbGQuZ2V0IGZsZCByZWNvcmQgaW5cbiAgZmllbGRfZGlyZWN0IGNoZWNrIGZsZCByZWNvcmQgdlxuOztcblxubGV0IGZpZWxkX2ZvbGRlciBjaGVjayByZWNvcmQgPVxuICAoKTtcbiAgZnVuIGFjYyBmbGQgLT4gZmllbGQgY2hlY2sgcmVjb3JkIGZsZCA6OiBhY2Ncbjs7XG5cbmxldCBmaWVsZF9kaXJlY3RfZm9sZGVyIGNoZWNrID1cbiAgU3RhZ2VkLnN0YWdlIChmdW4gYWNjIGZsZCByZWNvcmQgdiAtPlxuICAgIG1hdGNoIGZpZWxkX2RpcmVjdCBjaGVjayBmbGQgcmVjb3JkIHYgd2l0aFxuICAgIHwgW10gLT4gYWNjICgqIEF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgbGlzdCBpbiB0aGUgc3VjY2VzcyBjYXNlICopXG4gICAgfCByZXN1bHQgLT4gcmVzdWx0IDo6IGFjYylcbjs7XG5cbmxldCBhbGwgY2hlY2tzIHYgPVxuICBsZXQgcmVjIGxvb3AgY2hlY2tzIHYgZXJycyA9XG4gICAgbWF0Y2ggY2hlY2tzIHdpdGhcbiAgICB8IFtdIC0+IGVycnNcbiAgICB8IGNoZWNrIDo6IGNoZWNrcyAtPlxuICAgICAgKG1hdGNoIHByb3RlY3QgY2hlY2sgdiB3aXRoXG4gICAgICAgfCBbXSAtPiBsb29wIGNoZWNrcyB2IGVycnNcbiAgICAgICB8IGVyciAtPiBsb29wIGNoZWNrcyB2IChlcnIgOjogZXJycykpXG4gIGluXG4gIG9mX2xpc3QgKExpc3QucmV2IChsb29wIGNoZWNrcyB2IFtdKSlcbjs7XG5cbmxldCBvZl9yZXN1bHQgZiA9XG4gIHByb3RlY3QgKGZ1biB2IC0+XG4gICAgbWF0Y2ggZiB2IHdpdGhcbiAgICB8IE9rICgpIC0+IHBhc3NcbiAgICB8IEVycm9yIGVycm9yIC0+IGZhaWwgZXJyb3IpXG47O1xuXG5sZXQgb2ZfZXJyb3IgZiA9XG4gIHByb3RlY3QgKGZ1biB2IC0+XG4gICAgbWF0Y2ggZiB2IHdpdGhcbiAgICB8IE9rICgpIC0+IHBhc3NcbiAgICB8IEVycm9yIGVycm9yIC0+IFsgeyBwYXRoID0gW107IGVycm9yIH0gXSlcbjs7XG5cbmxldCBib29sdGVzdCBmIH5pZl9mYWxzZSA9IHByb3RlY3QgKGZ1biB2IC0+IGlmIGYgdiB0aGVuIHBhc3MgZWxzZSBmYWlsIGlmX2ZhbHNlKVxuXG5sZXQgcGFpciB+ZnN0IH5zbmQgKGZzdF92YWx1ZSwgc25kX3ZhbHVlKSA9XG4gIG9mX2xpc3QgWyBuYW1lIFwiZnN0XCIgKHByb3RlY3QgZnN0IGZzdF92YWx1ZSk7IG5hbWUgXCJzbmRcIiAocHJvdGVjdCBzbmQgc25kX3ZhbHVlKSBdXG47O1xuXG5sZXQgbGlzdF9pbmRleGVkIGNoZWNrIGxpc3QgPVxuICBMaXN0Lm1hcGkgbGlzdCB+ZjooZnVuIGkgZWwgLT4gbmFtZSAoSW50LnRvX3N0cmluZyAoaSArIDEpKSAocHJvdGVjdCBjaGVjayBlbCkpXG4gIHw+IG9mX2xpc3Rcbjs7XG5cbmxldCBsaXN0IH5uYW1lOmV4dHJhY3RfbmFtZSBjaGVjayBsaXN0ID1cbiAgTGlzdC5tYXAgbGlzdCB+ZjooZnVuIGVsIC0+XG4gICAgbWF0Y2ggcHJvdGVjdCBjaGVjayBlbCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgdCAtPlxuICAgICAgKCogZXh0cmEgbGV2ZWwgb2YgcHJvdGVjdGlvbiBpbiBjYXNlIGV4dHJhY3RfbmFtZSB0aHJvd3MgYW4gZXhjZXB0aW9uICopXG4gICAgICBwcm90ZWN0IChmdW4gdCAtPiBuYW1lIChleHRyYWN0X25hbWUgZWwpIHQpIHQpXG4gIHw+IG9mX2xpc3Rcbjs7XG5cbmxldCBhbGlzdCB+bmFtZSBmIGxpc3QnID0gbGlzdCAoZnVuIChfLCB4KSAtPiBmIHgpIGxpc3QnIH5uYW1lOihmdW4gKGtleSwgXykgLT4gbmFtZSBrZXkpXG5sZXQgZmlyc3RfZmFpbHVyZSB0MSB0MiA9IGlmIExpc3QuaXNfZW1wdHkgdDEgdGhlbiB0MiBlbHNlIHQxXG5cbmxldCBvZl9lcnJvcl9vcHQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gcGFzc1xuICB8IFNvbWUgZXJyb3IgLT4gZmFpbCBlcnJvclxuOztcblxubGV0IGJvdW5kZWQgfm5hbWUgfmxvd2VyIH51cHBlciB+Y29tcGFyZSB4ID1cbiAgbWF0Y2ggTWF5YmVfYm91bmQuY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSB4IHdpdGhcbiAgfCBJbl9yYW5nZSAtPiBwYXNzXG4gIHwgQmVsb3dfbG93ZXJfYm91bmQgLT5cbiAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgfCBJbmNsIGluY2wgLT4gZmFpbCAoUHJpbnRmLnNwcmludGYgXCJ2YWx1ZSAlcyA8IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgaW5jbCkpXG4gICAgIHwgRXhjbCBleGNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPD0gYm91bmQgJXNcIiAobmFtZSB4KSAobmFtZSBleGNsKSkpXG4gIHwgQWJvdmVfdXBwZXJfYm91bmQgLT5cbiAgICAobWF0Y2ggdXBwZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgfCBJbmNsIGluY2wgLT4gZmFpbCAoUHJpbnRmLnNwcmludGYgXCJ2YWx1ZSAlcyA+IGJvdW5kICVzXCIgKG5hbWUgeCkgKG5hbWUgaW5jbCkpXG4gICAgIHwgRXhjbCBleGNsIC0+IGZhaWwgKFByaW50Zi5zcHJpbnRmIFwidmFsdWUgJXMgPj0gYm91bmQgJXNcIiAobmFtZSB4KSAobmFtZSBleGNsKSkpXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggKysgKSB0MSB0MiA9IGNvbWJpbmUgdDEgdDJcbmVuZFxuIl19
