// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_attempt_to_compute_balance=
      caml_string_of_jsbytes
       ("attempt to compute balanced reducer with unset elements"),
     cst_attempt_to_access_negative=
      caml_string_of_jsbytes
       ("attempt to access negative index in balanced reducer"),
     cst_attempt_to_access_out_of_b=
      caml_string_of_jsbytes
       ("attempt to access out of bounds index in balanced reducer"),
     cst_non_positive_number_of_lea=
      caml_string_of_jsbytes
       ("non-positive number of leaves in balanced reducer"),
     cst_Balanced_reducer=caml_string_of_jsbytes("Balanced_reducer"),
     cst_balanced_reducer=caml_string_of_jsbytes("balanced_reducer"),
     cst_balanced_reducer_src_balan=
      caml_string_of_jsbytes("balanced_reducer/src/balanced_reducer.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_balanced_reducer$0=caml_string_of_jsbytes("balanced_reducer"),
     cst_balanced_reducer$1=caml_string_of_jsbytes("balanced_reducer"),
     cst_Balanced_reducer$0=caml_string_of_jsbytes("Balanced_reducer"),
     Base_Option_array=global_data.Base__Option_array,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Base=global_data.Base,
     Base_Int=global_data.Base__Int,
     Assert_failure=global_data.Assert_failure,
     Base_List=global_data.Base__List,
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime;
    caml_call1(Ppx_module_timer_runtime[4],cst_Balanced_reducer);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_balanced_reducer);
    caml_call1(Expect_test_collector[5][1],cst_balanced_reducer_src_balan);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_balanced_reducer$0,cst);
    var
     _i_=[0,caml_string_of_jsbytes("balanced_reducer")],
     _e_=[0,caml_string_of_jsbytes("index")],
     _f_=[0,caml_string_of_jsbytes("length")],
     _g_=[0,caml_string_of_jsbytes("index")],
     _d_=[0,caml_string_of_jsbytes("_")],
     _c_=[0,caml_string_of_jsbytes("num_leaves")],
     _a_=
      [0,
       caml_string_of_jsbytes("balanced_reducer/src/balanced_reducer.ml"),
       76,
       9],
     _b_=
      [0,
       caml_string_of_jsbytes("balanced_reducer/src/balanced_reducer.ml"),
       78,
       6];
    function left_child_index(parent_index)
     {return (parent_index * 2 | 0) + 1 | 0}
    function num_branches(t){return t[2] - 1 | 0}
    function index_is_leaf(t,i){return num_branches(t) <= i?1:0}
    function leaf_index(t,i)
     {var
       offset_from_start_of_leaves_in=i + t[3] | 0,
       rotated_index=
        offset_from_start_of_leaves_in < t[2]
         ?offset_from_start_of_leaves_in
         :offset_from_start_of_leaves_in - t[2] | 0;
      return rotated_index + num_branches(t) | 0}
    function sexp_of_t(sexp_of_a,t)
     {function _C_(i)
       {var _E_=leaf_index(t,i);
        return caml_call2(Base_Option_array[33],t[1],_E_)}
      var
       x_001=caml_call2(Base_List[123],t[2],_C_),
       _D_=caml_call1(Base[152],sexp_of_a);
      return caml_call2(Base[139],_D_,x_001)}
    function invariant(invariant_a,t)
     {var data=t[1],_x_=caml_call1(Base_Option_array[6],data) - 1 | 0,_w_=0;
      if(_x_ >= 0)
       {var i$0=_w_;
        for(;;)
         {var match=caml_call2(Base_Option_array[33],data,i$0);
          if(match){var a=match[1];caml_call1(invariant_a,a)}
          var _B_=i$0 + 1 | 0;
          if(_x_ !== i$0){var i$0=_B_;continue}
          break}}
      var _z_=num_branches(t) - 1 | 0,_y_=0;
      if(_z_ >= 0)
       {var i=_y_;
        for(;;)
         {var
           left=left_child_index(i),
           right=left + 1 | 0,
           left_is_none=caml_call2(Base_Option_array[35],data,left),
           right_is_none=caml_call2(Base_Option_array[35],data,right);
          if(caml_call2(Base_Option_array[36],data,i))
           {var switch$0=0;
            if(! left_is_none && ! right_is_none)switch$0 = 1;
            if(! switch$0)throw [0,Assert_failure,_a_]}
          else
           if
            (!
             index_is_leaf(t,left)
             &&
             !
             index_is_leaf(t,right)
             &&
             !
             left_is_none
             &&
             !
             right_is_none)
            throw [0,Assert_failure,_b_];
          var _A_=i + 1 | 0;
          if(_z_ !== i){var i=_A_;continue}
          break}}
      return 0}
    function create_exn(opt,param,num_leaves,reduce)
     {if(opt)
       var sth=opt[1],sexp_of_a=sth;
      else
       var sexp_of_a=function(param){return _d_};
      if(num_leaves < 1)
       {var
         _u_=[0,[1,[0,_c_,[0,caml_call1(Base[119],num_leaves),0]]],0],
         _v_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_non_positive_number_of_lea),
            _u_]];
        caml_call1(Base[202],_v_)}
      var
       num_branches=num_leaves - 1 | 0,
       num_leaves_not_in_bottom_level=
        caml_call1(Base_Int[63],num_leaves)
        -
        num_leaves
        |
        0,
       data=caml_call1(Base_Option_array[5],num_branches + num_leaves | 0);
      return [0,
              data,
              num_leaves,
              num_leaves_not_in_bottom_level,
              reduce,
              sexp_of_a]}
    function validate_index(t,i)
     {if(i < 0)
       {var
         _o_=[0,[1,[0,_e_,[0,caml_call1(Base[119],i),0]]],0],
         _p_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_attempt_to_access_negative),
            _o_]];
        caml_call1(Base[202],_p_)}
      var length=t[2],_q_=length <= i?1:0;
      if(! _q_)return _q_;
      var
       _r_=[0,[1,[0,_f_,[0,caml_call1(Base[119],length),0]]],0],
       _s_=[0,[1,[0,_g_,[0,caml_call1(Base[119],i),0]]],_r_],
       _t_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_attempt_to_access_out_of_b),
          _s_]];
      return caml_call1(Base[202],_t_)}
    function set_exn(t,i,a)
     {validate_index(t,i);
      var data=t[1],i$0=[0,leaf_index(t,i)];
      caml_call3(Base_Option_array[42],data,i$0[1],a);
      for(;;)
       {if(0 === i$0[1])return 0;
        var parent=(i$0[1] - 1 | 0) / 2 | 0;
        if(caml_call2(Base_Option_array[35],data,parent))
         i$0[1] = 0;
        else
         {caml_call2(Base_Option_array[50],data,parent);i$0[1] = parent}}}
    function get_exn(t,i)
     {validate_index(t,i);
      var _n_=leaf_index(t,i);
      return caml_call2(Base_Option_array[34],t[1],_n_)}
    function _h_(t,i)
     {if(caml_call2(Base_Option_array[36],t[1],i))
       return caml_call2(Base_Option_array[38],t[1],i);
      var left=left_child_index(i),right=left + 1 | 0;
      if(caml_call1(Base_Option_array[6],t[1]) <= left)
       {var
         sexp_of_a=t[5],
         _j_=[0,[1,[0,_i_,[0,sexp_of_t(sexp_of_a,t),0]]],0],
         _k_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_attempt_to_compute_balance),
            _j_]];
        caml_call1(Base[202],_k_)}
      var _l_=_h_(t,right),_m_=_h_(t,left),a=caml_call2(t[4],_m_,_l_);
      caml_call3(Base_Option_array[49],t[1],i,a);
      return a}
    function compute_exn(t){return _h_(t,0)}
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_balanced_reducer$1);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Balanced_reducer$0);
    var
     Balanced_reducer=
      [0,sexp_of_t,invariant,create_exn,set_exn,get_exn,compute_exn];
    runtime.caml_register_global(29,Balanced_reducer,"Balanced_reducer");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYWxhbmNlZF9yZWR1Y2VyLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJsZWZ0X2NoaWxkX2luZGV4IiwicGFyZW50X2luZGV4IiwibnVtX2JyYW5jaGVzIiwidCIsImluZGV4X2lzX2xlYWYiLCJpIiwibGVhZl9pbmRleCIsIm9mZnNldF9mcm9tX3N0YXJ0X29mX2xlYXZlc19pbiIsInJvdGF0ZWRfaW5kZXgiLCJzZXhwX29mX3QiLCJzZXhwX29mX2EiLCJ4XzAwMSIsImludmFyaWFudCIsImludmFyaWFudF9hIiwiZGF0YSIsImkkMCIsImEiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0X2lzX25vbmUiLCJyaWdodF9pc19ub25lIiwiY3JlYXRlX2V4biIsIm9wdCIsIm51bV9sZWF2ZXMiLCJyZWR1Y2UiLCJzdGgiLCJudW1fbGVhdmVzX25vdF9pbl9ib3R0b21fbGV2ZWwiLCJ2YWxpZGF0ZV9pbmRleCIsImxlbmd0aCIsInNldF9leG4iLCJwYXJlbnQiLCJnZXRfZXhuIiwiY29tcHV0ZV9leG4iXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvY29yZV9rZXJuZWwvYmFsYW5jZWRfcmVkdWNlci9iYWxhbmNlZF9yZWR1Y2VyLm1sIl0sIm1hcHBpbmdzIjoiOzs7OztJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUFtQ0lBLGlCQUFrQkM7TUFBZSxRQUFmQSw2QkFBcUM7YUFLdkRDLGFBQWFDLEdBQUksT0FBSkEsWUFBb0I7YUFDakNDLGNBQWNELEVBQUVFLEdBQVMsT0FEekJILGFBQ2NDLE1BQUVFLEtBQXVCO2FBSXZDQyxXQUFXSCxFQUFFRTtNQUdmO3NDQUhlQSxJQUFGRjtPQUdiO1FBQ01JLGlDQUpPSjtVQUlQSTsyQ0FKT0o7TUFVRyxPQVBaSyxnQkFSRk4sYUFLV0MsTUFVaUI7YUFLNUJNLFVBQVVDLFVBQVVQO01BRFIsYUFBNkJFO1FBREYsUUFidkNDLFdBZW9CSCxFQURxQkU7UUFERix3Q0FFbkJGLFNBRHNDO01BQXBDO3VDQUNGQTtnQ0FBVk87c0NBQWtDQzthQUU1Q0MsVUFBVUMsWUFBWVY7TUFDeEIsU0FEd0JBLEtBRVgsb0NBRFRXLGNBQUo7TUFDYTtZQUFiQztRQUNFO1VBQU0sMkNBRkpELEtBQ0pDO1VBQ1EsVUFFTSxJQUFMQyxXQUFLLFdBTEZILFlBS0hHO1VBRkQsUUFEUkQ7OztNQURBLElBTWEsSUE3QlhiLGFBc0JzQkMsV0FPeEI7TUFBYTtZQUFiRTtRQUNFO1VBQVc7Z0JBbkNYTCxpQkFrQ0ZLO1dBRWMsTUFEUlk7V0FFZSw4Q0FUakJILEtBT0VHO1dBR2dCLCtDQVZsQkgsS0FRRUk7VUFHRCxvQ0FYREosS0FNSlQ7O2lCQUdNYyxrQkFDQUM7Ozs7O2FBaENKaEIsY0FxQnNCRCxFQVFsQmM7OzthQTdCSmIsY0FxQnNCRCxFQVNsQmU7OzthQUNBQzs7O2FBQ0FDOztVQUhPLFFBRGJmOzs7Y0FVSTthQUdGZ0IsV0FBYUMsVUFBbUNDLFdBQVlDO01BQzlELEdBRGVGO1dBQXVCRyxJQUF2QkgsaUJBQXVCRzs7V0FBdkJmLDBCO1NBQW1DYTs7Ozs7Ozs7UUFHaEQ7TUFDbUY7b0JBSm5DQTtPQU1iO2dDQU5hQTs7Ozs7T0FPdkMscUNBRlByQixlQUw4Q3FCO01BT3ZDO2NBQVBUO2NBUDhDUztjQU05Q0c7Y0FOMERGO2NBQS9DZCxVQVF3RDthQUdyRWlCLGVBQWV4QixFQUFFRTtNQUNuQixHQURtQkE7Ozs7Ozs7O1FBR2pCO01BQ29GLFdBSnJFRixLQUlxRSxJQUNsRnlCLFVBTGV2QjtNQUltRTs7Z0RBQ2xGdUI7Z0RBTGV2Qjs7Ozs7O3NDQVlJO2FBR3JCd0IsUUFBUTFCLEVBQUVFLEVBQUVXO01BQ2QsZUFEVWIsRUFBRUU7TUFDWixTQURVRixLQUdFLE9BbEVWRyxXQStEUUgsRUFBRUU7TUFJWixpQ0FGSVMsS0FDQUMsT0FIVUM7O2lCQUdWRDtRQTdFMEIsSUFnRnhCZSxRQUhGZjtRQUlDLG9DQUxERCxLQUlFZ0I7U0FFQzs7VUFFSCxpQ0FSQWhCLEtBSUVnQixRQUlGLFNBSkVBLFFBTUY7YUFHRkMsUUFBUTVCLEVBQUVFO01BQ1osZUFEVUYsRUFBRUU7TUFFcUIsUUFoRi9CQyxXQThFUUgsRUFBRUU7TUFFcUIsd0NBRnZCRixTQUV1QztpQkFHL0JBLEVBQUVFO01BQ2pCLG9DQURlRixLQUFFRTtPQUVmLHdDQUZhRixLQUFFRTtNQUlQLFNBakdYTCxpQkE2RmtCSyxHQUtOLE1BRFJZO01BRU8sbUNBTktkLFNBSVpjO1FBR0M7bUJBUFdkOzZCQXBFaEJNLFVBNkVNQyxVQVRVUDs7Ozs7O1FBVWQ7TUFOUyxJQVUyQixRQWR0QkEsRUFLWmUsT0FTYSxRQWREZixFQUlaYyxNQVVJLGFBZFFkO01BZWhCLGlDQWZnQkEsS0FBRUUsRUFjZFc7TUFDSixPQURJQSxDQUVGO2FBR0ZnQixZQUFZN0IsR0FBSSxXQUFKQSxJQUFtQjs7Ozs7OztTQXZGL0JNLFVBRUFHLFVBb0JBUyxXQTBCQVEsUUFlQUUsUUF3QkFDOztVIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG4oKiBUaGUgW2RhdGFdIGFycmF5IGlzIGFuIGltcGxpY2l0IGJpbmFyeSB0cmVlIHdpdGggW2NoaWxkcmVuX2xlbmd0aCAqIDIgLSAxXSBub2RlcyxcbiAgIHdpdGggZWFjaCBub2RlIGJlaW5nIHRoZSBzdW0gb2YgdGhlIHR3byBjaGlsZCBub2RlcyBhbmQgdGhlIHJvb3Qgbm9kZSBiZWluZyB0aGUgMHRoXG4gICBub2RlLiAgVGhlIGxlYXZlcyBvZiB0aGUgdHJlZSBhcmUgdGhlIGxhc3QgW251bV9sZWF2ZXNdIG5vZGVzLlxuXG4gICBUaGUgY2hpbGRyZW4gYXJlIG5vdCBuZWNlc3NhcmlseSBhbGwgYXQgdGhlIHNhbWUgbGV2ZWwgb2YgdGhlIHRyZWUuIEZvciBpbnN0YW5jZSBpZlxuICAgeW91IGhhdmUgMyBjaGlsZHJlbiBbfCBhOyBiOyBjIHxdOlxuXG4gICB7dlxuICAgICAgICAgIG9cbiAgICAgICAgIC8gXFxcbiAgICAgICAgbyAgIGNcbiAgICAgICAvIFxcXG4gICAgICBhICAgYlxuICAgdn1cblxuICAgV2Ugd2FudCB0aGlzIHRyZWUgdG8gYmUgcmVwcmVzZW50YXRlZCBhcyBbfCBvOyBvOyBjOyBhOyBiIHxdLCBpLmUuIHdlIG5lZWQgdG8gYXBwbHlcbiAgIGZpcnN0IGEgcm90YXRpb24gdGhlbiBhIHRyYW5zbGF0aW9uIHRvIGNvbnZlcnQgYW4gaW5kZXggaW4gW3wgYTsgYjsgYyB8XSB0byBhIChsZWFmKVxuICAgaW5kZXggaW4gW3wgbzsgbzsgYzsgYTsgYiB8XS4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgZGF0YSA6ICdhIE9wdGlvbl9hcnJheS50XG4gIDsgbnVtX2xlYXZlcyA6IGludFxuICA7IG51bV9sZWF2ZXNfbm90X2luX2JvdHRvbV9sZXZlbCA6IGludFxuICA7IHJlZHVjZSA6ICdhIC0+ICdhIC0+ICdhXG4gIDsgc2V4cF9vZl9hIDogJ2EgLT4gU2V4cC50XG4gIH1cblxubGV0IGxlbmd0aCB0ID0gdC5udW1fbGVhdmVzXG5cbigqIHt2XG4gICAgIHBhcmVudDogICAgICAwICAxICAyICAzICA0ICA1ICA2ICA3ICA4ICA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IC4uLlxuICAgICBsZWZ0IGNoaWxkOiAgMSAgMyAgNSAgNyAgOSAxMSAxMyAxNSAxNyAxOSAyMSAyMyAyNSAyNyAyOSAzMSAzMyAzNSAzNyAzOSAuLi5cbiAgICAgcmlnaHQgY2hpbGQ6IDIgIDQgIDYgIDggMTAgMTIgMTQgMTYgMTggMjAgMjIgMjQgMjYgMjggMzAgMzIgMzQgMzYgMzggNDAgLi4uIHZ9ICopXG5sZXQgcGFyZW50X2luZGV4IH5jaGlsZF9pbmRleCA9IChjaGlsZF9pbmRleCAtIDEpIC8gMlxubGV0IGxlZnRfY2hpbGRfaW5kZXggfnBhcmVudF9pbmRleCA9IChwYXJlbnRfaW5kZXggKiAyKSArIDFcbmxldCByaWdodF9jaGlsZF9pbmRleCB+bGVmdF9jaGlsZF9pbmRleCA9IGxlZnRfY2hpbGRfaW5kZXggKyAxXG5cbigqIFRoZSBmaXJzdCBbbnVtX2xlYXZlcy0xXSBlbGVtZW50cyBhcmUgaW50ZXJuYWwgbm9kZXMgb2YgdGhlIHRyZWUuICBUaGUgbmV4dFxuICAgW251bV9sZWF2ZXNdIGVsZW1lbnRzIGFyZSB0aGUgbGVhdmVzLiAqKVxubGV0IG51bV9icmFuY2hlcyB0ID0gdC5udW1fbGVhdmVzIC0gMVxubGV0IGluZGV4X2lzX2xlYWYgdCBpID0gaSA+PSBudW1fYnJhbmNoZXMgdFxuXG4oKiBUaGUgdHJlZSBpcyBjb21wbGV0ZSwgYnV0IG5vdCBuZWNlc3NhcmlseSBwZXJmZWN0LCBzbyB3ZSBwZXJmb3JtIHNvbWUgcm90YXRpb24gb2YgdGhlXG4gICBsZWF2ZXMgdG8gZW5zdXJlIHRoYXQgb3VyIHJlZHVjdGlvbnMgcHJlc2VydmUgb3JkZXJpbmcuICopXG5sZXQgbGVhZl9pbmRleCB0IGkgPVxuICAoKiBUaGUgdHJlZSBsYXlvdXQgaXMgbGV2ZWwgb3JkZXIuICBBbnkgbGVhdmVzIGluIHRoZSBzZWNvbmQgdG8gbGFzdCBsZXZlbCBuZWVkIHRvIG9jY3VyXG4gICAgIGluIHRoZSBhcnJheSBiZWZvcmUgdGhlIGxlYXZlcyBpbiB0aGUgYm90dG9tIGxldmVsLiAqKVxuICBsZXQgcm90YXRlZF9pbmRleCA9XG4gICAgbGV0IG9mZnNldF9mcm9tX3N0YXJ0X29mX2xlYXZlc19pbl9hcnJheSA9IGkgKyB0Lm51bV9sZWF2ZXNfbm90X2luX2JvdHRvbV9sZXZlbCBpblxuICAgIGlmIG9mZnNldF9mcm9tX3N0YXJ0X29mX2xlYXZlc19pbl9hcnJheSA8IHQubnVtX2xlYXZlc1xuICAgIHRoZW4gb2Zmc2V0X2Zyb21fc3RhcnRfb2ZfbGVhdmVzX2luX2FycmF5XG4gICAgZWxzZSBvZmZzZXRfZnJvbV9zdGFydF9vZl9sZWF2ZXNfaW5fYXJyYXkgLSB0Lm51bV9sZWF2ZXNcbiAgaW5cbiAgKCogVGhlIGxlYXZlcyBvY2N1ciBhZnRlciB0aGUgYnJhbmNoZXMgaW4gdGhlIGFycmF5LiAqKVxuICByb3RhdGVkX2luZGV4ICsgbnVtX2JyYW5jaGVzIHRcbjs7XG5cbmxldCBnZXRfbGVhZiB0IGkgPSBPcHRpb25fYXJyYXkuZ2V0IHQuZGF0YSAobGVhZl9pbmRleCB0IGkpXG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IGdldF9sZWFmIHQgaSlcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBbJXNleHAgKHRvX2xpc3QgdCA6IGEgb3B0aW9uIGxpc3QpXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBsZXQgZGF0YSA9IHQuZGF0YSBpblxuICBmb3IgaSA9IDAgdG8gT3B0aW9uX2FycmF5Lmxlbmd0aCBkYXRhIC0gMSBkb1xuICAgIG1hdGNoIE9wdGlvbl9hcnJheS5nZXQgZGF0YSBpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPiBpbnZhcmlhbnRfYSBhXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudW1fYnJhbmNoZXMgdCAtIDEgZG9cbiAgICBsZXQgbGVmdCA9IGxlZnRfY2hpbGRfaW5kZXggfnBhcmVudF9pbmRleDppIGluXG4gICAgbGV0IHJpZ2h0ID0gcmlnaHRfY2hpbGRfaW5kZXggfmxlZnRfY2hpbGRfaW5kZXg6bGVmdCBpblxuICAgIGxldCBsZWZ0X2lzX25vbmUgPSBPcHRpb25fYXJyYXkuaXNfbm9uZSBkYXRhIGxlZnQgaW5cbiAgICBsZXQgcmlnaHRfaXNfbm9uZSA9IE9wdGlvbl9hcnJheS5pc19ub25lIGRhdGEgcmlnaHQgaW5cbiAgICBpZiBPcHRpb25fYXJyYXkuaXNfc29tZSBkYXRhIGlcbiAgICB0aGVuIGFzc2VydCAobm90IChsZWZ0X2lzX25vbmUgfHwgcmlnaHRfaXNfbm9uZSkpXG4gICAgZWxzZVxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgaW5kZXhfaXNfbGVhZiB0IGxlZnQgfHwgaW5kZXhfaXNfbGVhZiB0IHJpZ2h0IHx8IGxlZnRfaXNfbm9uZSB8fCByaWdodF9pc19ub25lKVxuICBkb25lXG47O1xuXG5sZXQgY3JlYXRlX2V4biA/KHNleHBfb2ZfYSA9IFslc2V4cF9vZjogX10pICgpIH5sZW46bnVtX2xlYXZlcyB+cmVkdWNlID1cbiAgaWYgbnVtX2xlYXZlcyA8IDFcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIm5vbi1wb3NpdGl2ZSBudW1iZXIgb2YgbGVhdmVzIGluIGJhbGFuY2VkIHJlZHVjZXJcIiAobnVtX2xlYXZlcyA6IGludCldO1xuICBsZXQgbnVtX2JyYW5jaGVzID0gbnVtX2xlYXZlcyAtIDEgaW5cbiAgbGV0IG51bV9sZWF2ZXNfbm90X2luX2JvdHRvbV9sZXZlbCA9IEludC5jZWlsX3BvdzIgbnVtX2xlYXZlcyAtIG51bV9sZWF2ZXMgaW5cbiAgbGV0IGRhdGEgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46KG51bV9icmFuY2hlcyArIG51bV9sZWF2ZXMpIGluXG4gIHsgZGF0YTsgbnVtX2xlYXZlczsgbnVtX2xlYXZlc19ub3RfaW5fYm90dG9tX2xldmVsOyByZWR1Y2U7IHNleHBfb2ZfYSB9XG47O1xuXG5sZXQgdmFsaWRhdGVfaW5kZXggdCBpID1cbiAgaWYgaSA8IDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcImF0dGVtcHQgdG8gYWNjZXNzIG5lZ2F0aXZlIGluZGV4IGluIGJhbGFuY2VkIHJlZHVjZXJcIiB+aW5kZXg6KGkgOiBpbnQpXTtcbiAgbGV0IGxlbmd0aCA9IHQubnVtX2xlYXZlcyBpblxuICBpZiBpID49IGxlbmd0aFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiYXR0ZW1wdCB0byBhY2Nlc3Mgb3V0IG9mIGJvdW5kcyBpbmRleCBpbiBiYWxhbmNlZCByZWR1Y2VyXCJcbiAgICAgICAgICB+aW5kZXg6KGkgOiBpbnQpXG4gICAgICAgICAgKGxlbmd0aCA6IGludCldXG47O1xuXG5sZXQgc2V0X2V4biB0IGkgYSA9XG4gIHZhbGlkYXRlX2luZGV4IHQgaTtcbiAgbGV0IGRhdGEgPSB0LmRhdGEgaW5cbiAgbGV0IGkgPSByZWYgKGxlYWZfaW5kZXggdCBpKSBpblxuICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgZGF0YSAhaSBhO1xuICB3aGlsZSAhaSA8PiAwIGRvXG4gICAgbGV0IHBhcmVudCA9IHBhcmVudF9pbmRleCB+Y2hpbGRfaW5kZXg6IWkgaW5cbiAgICBpZiBPcHRpb25fYXJyYXkuaXNfbm9uZSBkYXRhIHBhcmVudFxuICAgIHRoZW4gaSA6PSAwXG4gICAgZWxzZSAoXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIGRhdGEgcGFyZW50O1xuICAgICAgaSA6PSBwYXJlbnQpXG4gIGRvbmVcbjs7XG5cbmxldCBnZXRfZXhuIHQgaSA9XG4gIHZhbGlkYXRlX2luZGV4IHQgaTtcbiAgT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmRhdGEgKGxlYWZfaW5kZXggdCBpKVxuOztcblxubGV0IHJlYyBjb21wdXRlX2V4biB0IGkgPVxuICBpZiBPcHRpb25fYXJyYXkuaXNfc29tZSB0LmRhdGEgaVxuICB0aGVuIE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZGF0YSBpXG4gIGVsc2UgKFxuICAgIGxldCBsZWZ0ID0gbGVmdF9jaGlsZF9pbmRleCB+cGFyZW50X2luZGV4OmkgaW5cbiAgICBsZXQgcmlnaHQgPSByaWdodF9jaGlsZF9pbmRleCB+bGVmdF9jaGlsZF9pbmRleDpsZWZ0IGluXG4gICAgaWYgbGVmdCA+PSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZGF0YVxuICAgIHRoZW4gKFxuICAgICAgKCogSWYgd2UgZ2V0IGhlcmUsIHRoZSBwYXJlbnQgd2FzIGFuIHVuc2V0IGxlYWYuICopXG4gICAgICBsZXQgc2V4cF9vZl9hID0gdC5zZXhwX29mX2EgaW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJhdHRlbXB0IHRvIGNvbXB1dGUgYmFsYW5jZWQgcmVkdWNlciB3aXRoIHVuc2V0IGVsZW1lbnRzXCJcbiAgICAgICAgICAgIH5iYWxhbmNlZF9yZWR1Y2VyOih0IDogYSB0KV0pO1xuICAgIGxldCBhID0gdC5yZWR1Y2UgKGNvbXB1dGVfZXhuIHQgbGVmdCkgKGNvbXB1dGVfZXhuIHQgcmlnaHQpIGluXG4gICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmRhdGEgaSBhO1xuICAgIGEpXG47O1xuXG5sZXQgY29tcHV0ZV9leG4gdCA9IGNvbXB1dGVfZXhuIHQgMFxuIl19
