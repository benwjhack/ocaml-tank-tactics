// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_cannot_remove_from_a_diffe=
      caml_string_of_jsbytes("cannot remove from a different heap"),
     cst_Heap_value_exn_node_was_re=
      caml_string_of_jsbytes("Heap.value_exn: node was removed from the heap"),
     cst_Heap_top_exn_called_on_an_=
      caml_string_of_jsbytes("Heap.top_exn called on an empty heap"),
     cst_Pairing_heap=caml_string_of_jsbytes("Pairing_heap"),
     cst_pairing_heap=caml_string_of_jsbytes("pairing_heap"),
     cst_pairing_heap_src_pairing_h=
      caml_string_of_jsbytes("pairing_heap/src/pairing_heap.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_pairing_heap$0=caml_string_of_jsbytes("pairing_heap"),
     cst_pairing_heap$1=caml_string_of_jsbytes("pairing_heap"),
     cst_Pairing_heap$0=caml_string_of_jsbytes("Pairing_heap"),
     Core=global_data.Core,
     Core_Array=global_data.Core__Array,
     Core_List=global_data.Core__List,
     Assert_failure=global_data.Assert_failure,
     Core_Option=global_data.Core__Option,
     Tuple_pool=global_data.Tuple_pool,
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime,
     Core_Int=global_data.Core__Int,
     Base_Container=global_data.Base__Container;
    caml_call1(Ppx_module_timer_runtime[4],cst_Pairing_heap);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_pairing_heap);
    caml_call1(Expect_test_collector[5][1],cst_pairing_heap_src_pairing_h);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_pairing_heap$0,cst);
    var
     empty=Tuple_pool[3][4],
     is_empty=Tuple_pool[3][5],
     equal=Tuple_pool[3][7],
     _d_=[0,caml_string_of_jsbytes("pairing_heap/src/pairing_heap.ml"),239,10],
     _e_=[0,caml_string_of_jsbytes("pairing_heap/src/pairing_heap.ml"),237,8],
     _f_=[0,caml_string_of_jsbytes("pairing_heap/src/pairing_heap.ml"),246,2],
     _a_=[0,caml_string_of_jsbytes("pairing_heap/src/pairing_heap.ml"),110,4],
     dummy_id=-1;
    function child(t,pool)
     {return caml_call3(Tuple_pool[32],pool,t,Tuple_pool[2][4])}
    function sibling(t,pool)
     {return caml_call3(Tuple_pool[32],pool,t,Tuple_pool[2][5])}
    function prev(t,pool)
     {return caml_call3(Tuple_pool[32],pool,t,Tuple_pool[2][6])}
    function id(t,pool)
     {return caml_call3(Tuple_pool[32],pool,t,Tuple_pool[2][7])}
    function set_child(t,v,pool)
     {return caml_call4(Tuple_pool[34],pool,t,Tuple_pool[2][4],v)}
    function set_sibling(t,v,pool)
     {return caml_call4(Tuple_pool[34],pool,t,Tuple_pool[2][5],v)}
    function set_prev(t,v,pool)
     {return caml_call4(Tuple_pool[34],pool,t,Tuple_pool[2][6],v)}
    function value_exn(t,pool)
     {if(caml_call1(is_empty,t))throw [0,Assert_failure,_a_];
      return caml_call3(Tuple_pool[32],pool,t,Tuple_pool[2][3])}
    function allocate(value,pool,id)
     {var
       _Q_=caml_call1(empty,0),
       _R_=caml_call1(empty,0),
       _S_=caml_call1(empty,0);
      return caml_call6(Tuple_pool[21],pool,value,_S_,_R_,_Q_,id)}
    function free(t,pool){return caml_call2(Tuple_pool[16],pool,t)}
    function disconnect_sibling(t,pool)
     {var sibling$0=sibling(t,pool);
      if(1 - caml_call1(is_empty,sibling$0))
       {set_sibling(t,caml_call1(empty,0),pool);
        set_prev(sibling$0,caml_call1(empty,0),pool)}
      return sibling$0}
    function disconnect_child(t,pool)
     {var child$0=child(t,pool);
      if(1 - caml_call1(is_empty,child$0))
       {set_child(t,caml_call1(empty,0),pool);
        set_prev(child$0,caml_call1(empty,0),pool)}
      return child$0}
    function detach(t,pool)
     {var _L_=1 - caml_call1(is_empty,t);
      if(_L_)
       {var prev$0=prev(t,pool),_M_=1 - caml_call1(is_empty,prev$0);
        if(_M_)
         {var
           relation_to_prev=
            caml_call2(equal,t,child(prev$0,pool))?-977688164:-560648958;
          set_prev(t,caml_call1(empty,0),pool);
          var sibling=disconnect_sibling(t,pool);
          if(-560648958 <= relation_to_prev)
           set_sibling(prev$0,sibling,pool);
          else
           set_child(prev$0,sibling,pool);
          var _N_=1 - caml_call1(is_empty,sibling);
          if(_N_)return set_prev(sibling,prev$0,pool);
          var _O_=_N_}
        else
         var _O_=_M_;
        var _P_=_O_}
      else
       var _P_=_L_;
      return _P_}
    function create(capacity)
     {var
       _I_=caml_call1(Tuple_pool[3][4],0),
       _J_=caml_call1(Tuple_pool[3][4],0),
       _K_=[0,0,caml_call1(Tuple_pool[3][4],0),_J_,_I_,dummy_id];
      return caml_call3(Tuple_pool[9],Tuple_pool[1][21],capacity,_K_)}
    var _b_=Core_Int[90],_c_=Core_Int[60];
    function invariant(param,t)
     {if
       (!
        caml_call1(is_empty,t[3])
        &&
        !
        caml_call1(is_empty,sibling(t[3],t[2])))
       throw [0,Assert_failure,_f_];
      var
       _G_=caml_call1(empty,0),
       to_visit$1=[0,[0,t[3],_G_,0],0],
       to_visit=to_visit$1;
      for(;;)
       {if(! to_visit)return 0;
        var
         rest=to_visit[2],
         match=to_visit[1],
         maybe_parent_value=match[3],
         expected_prev=match[2],
         node=match[1];
        if(caml_call1(is_empty,node)){var to_visit=rest;continue}
        var this_value=value_exn(node,t[2]);
        if(! caml_call2(equal,prev(node,t[2]),expected_prev))
         throw [0,Assert_failure,_e_];
        var
         _E_=
          function(this_value)
            {return function(parent_value)
              {var _H_=caml_call2(t[1],parent_value,this_value);
               if(caml_call2(Core[89],_H_,0))return 0;
               throw [0,Assert_failure,_d_]}}
           (this_value);
        caml_call2(Core_Option[41],maybe_parent_value,_E_);
        var
         _F_=[0,[0,sibling(node,t[2]),node,maybe_parent_value],rest],
         to_visit$0=[0,[0,child(node,t[2]),node,[0,this_value]],_F_],
         to_visit=to_visit$0}}
    function create$0(opt,cmp,param)
     {if(opt)var sth=opt[1],min_size=sth;else var min_size=1;
      var _D_=caml_call1(empty,0);
      return [0,cmp,create(min_size),_D_,0]}
    function copy(param)
     {var
       cmp=param[1],
       pool$0=param[2],
       root$0=param[3],
       num_of_allocated_nodes=param[4],
       pool=create(caml_call1(Tuple_pool[11],pool$0));
      function copy_node(node,to_visit)
       {if(caml_call1(is_empty,node))return [0,caml_call1(empty,0),to_visit];
        var
         _B_=id(node,pool$0),
         new_node=allocate(value_exn(node,pool$0),pool,_B_),
         _C_=[0,[0,new_node,-560648958,sibling(node,pool$0)],to_visit],
         to_visit$0=[0,[0,new_node,-977688164,child(node,pool$0)],_C_];
        return [0,new_node,to_visit$0]}
      var
       match$1=copy_node(root$0,0),
       to_visit$1=match$1[2],
       root=match$1[1],
       to_visit=to_visit$1;
      for(;;)
       {if(! to_visit)return [0,cmp,pool,root,num_of_allocated_nodes];
        var
         rest=to_visit[2],
         match=to_visit[1],
         node_to_copy=match[3],
         slot=match[2],
         node_to_update=match[1],
         match$0=copy_node(node_to_copy,rest),
         to_visit$0=match$0[2],
         new_node=match$0[1];
        if(-560648958 <= slot)
         set_sibling(node_to_update,new_node,pool);
        else
         set_child(node_to_update,new_node,pool);
        if(1 - caml_call1(is_empty,new_node))
         set_prev(new_node,node_to_update,pool);
        var to_visit=to_visit$0}}
    function merge(t,root1,root2)
     {if(caml_call1(is_empty,root1))return root2;
      if(caml_call1(is_empty,root2))return root1;
      function add_child(t,node,child)
       {var _A_=t[2],current_child=disconnect_child(node,_A_);
        set_sibling(child,current_child,_A_);
        if(1 - caml_call1(is_empty,current_child))
         set_prev(current_child,child,_A_);
        set_child(node,child,_A_);
        set_prev(child,node,_A_);
        return node}
      var
       v1=value_exn(root1,t[2]),
       v2=value_exn(root2,t[2]),
       _z_=caml_call2(t[1],v1,v2);
      return caml_call2(Core[92],_z_,0)
              ?add_child(t,root1,root2)
              :add_child(t,root2,root1)}
    function top_exn(t)
     {return caml_call1(is_empty,t[3])
              ?caml_call1(Core[6],cst_Heap_top_exn_called_on_an_)
              :value_exn(t[3],t[2])}
    function top(t){return caml_call1(is_empty,t[3])?0:[0,top_exn(t)]}
    function add_node(t,v)
     {if(caml_call1(Tuple_pool[14],t[2]))
       t[2] = caml_call2(Tuple_pool[13],0,t[2]);
      t[4] = t[4] + 1 | 0;
      var _y_=caml_call1(_c_,t[4]),node=allocate(v,t[2],_y_);
      t[3] = merge(t,t[3],node);
      return node}
    function add(t,v){add_node(t,v);return 0}
    var max_stack_depth=1000;
    function loop(t,depth,head$1)
     {if(! caml_call2(Core[88],depth,max_stack_depth))
       {if(caml_call1(is_empty,head$1))return head$1;
        var next1$0=disconnect_sibling(head$1,t[2]);
        if(caml_call1(is_empty,next1$0))return head$1;
        var
         next2=disconnect_sibling(next1$0,t[2]),
         _x_=loop(t,depth + 1 | 0,next2);
        return merge(t,merge(t,head$1,next1$0),_x_)}
      var acc=0,head=head$1;
      for(;;)
       {if(caml_call1(is_empty,head))
         var match=acc;
        else
         {var next1=disconnect_sibling(head,t[2]);
          if(! caml_call1(is_empty,next1))
           {var
             head$0=disconnect_sibling(next1,t[2]),
             acc$0=[0,merge(t,head,next1),acc],
             acc=acc$0,
             head=head$0;
            continue}
          var match=[0,head,acc]}
        if(! match)return caml_call1(empty,0);
        var _v_=match[1];
        if(! match[2])return _v_;
        var xs=match[2],_w_=function(acc,heap){return merge(t,acc,heap)};
        return caml_call3(Core_List[10],xs,_v_,_w_)}}
    function remove_non_empty(t,node)
     {var pool=t[2];
      detach(node,pool);
      var
       head=disconnect_child(node,pool),
       merged_children=loop(t,0,head),
       new_root=
        caml_call2(equal,t[3],node)
         ?merged_children
         :merge(t,t[3],merged_children);
      free(node,pool);
      t[3] = new_root;
      return 0}
    function remove_top(t)
     {var _u_=1 - caml_call1(is_empty,t[3]);
      return _u_?remove_non_empty(t,t[3]):_u_}
    function clear(t)
     {var _r_=1 - caml_call1(is_empty,t[3]);
      if(_r_)
       {var _s_=t[2],node=t[3];
        for(;;)
         {var node$0=child(node,_s_),sibling$0=sibling(node,_s_);
          if(! caml_call1(is_empty,node$0)){var node=node$0;continue}
          if(! caml_call1(is_empty,sibling$0)){var node=sibling$0;continue}
          var prev$0=prev(node,_s_);
          detach(node,_s_);
          free(node,_s_);
          if(1 - caml_call1(is_empty,prev$0)){var node=prev$0;continue}
          t[3] = caml_call1(empty,0);
          var _t_=0;
          break}}
      else
       var _t_=_r_;
      return _t_}
    function pop_exn(t){var r=top_exn(t);remove_top(t);return r}
    function pop(t){return caml_call1(is_empty,t[3])?0:[0,pop_exn(t)]}
    function pop_if(t,f)
     {var match=top(t);
      if(! match)return 0;
      var v=match[1];
      return caml_call1(f,v)?(remove_top(t),[0,v]):0}
    function fold(t,acc,f)
     {var pool=t[2],to_visit$1=[0,t[3],0],acc$0=acc,to_visit=to_visit$1;
      for(;;)
       {if(! to_visit)return acc$0;
        var rest=to_visit[2],node=to_visit[1];
        if(caml_call1(is_empty,node)){var to_visit=rest;continue}
        var
         _q_=[0,child(node,pool),rest],
         to_visit$0=[0,sibling(node,pool),_q_],
         acc$1=caml_call2(f,acc$0,value_exn(node,pool)),
         acc$0=acc$1,
         to_visit=to_visit$0}}
    function iter(t,f)
     {var pool=t[2],to_visit$1=[0,t[3],0],to_visit=to_visit$1;
      for(;;)
       {if(! to_visit)return 0;
        var rest=to_visit[2],node=to_visit[1];
        if(caml_call1(is_empty,node)){var to_visit=rest;continue}
        caml_call1(f,value_exn(node,pool));
        var
         _p_=[0,child(node,pool),rest],
         to_visit$0=[0,sibling(node,pool),_p_],
         to_visit=to_visit$0}}
    function length(t){return caml_call1(Tuple_pool[12],t[2])}
    var
     iter$0=[0,-198771759,iter],
     length$0=[0,-198771759,length],
     C=caml_call1(Base_Container[16],[0,fold,iter$0,length$0]);
    function is_empty$0(t){return caml_call1(is_empty,t[3])}
    var
     mem=C[1],
     exists=C[8],
     for_all=C[9],
     count=C[10],
     sum=C[11],
     find=C[12],
     find_map=C[13],
     to_list=C[14],
     to_array=C[15],
     min_elt=C[16],
     max_elt=C[17],
     fold_result=C[6],
     fold_until=C[7];
    function of_array(arr,cmp)
     {var t=create$0([0,arr.length - 1],cmp,0);
      function _o_(v){return add(t,v)}
      caml_call2(Core_Array[22],arr,_o_);
      return t}
    function of_list(l,cmp){return of_array(caml_call1(Core_Array[52],l),cmp)}
    function sexp_of_t(f,t)
     {var
       _l_=t[1],
       _m_=caml_call1(to_array,t),
       _n_=caml_call2(Core_Array[111],_m_,_l_);
      return caml_call2(Core_Array[16],f,_n_)}
    function is_node_valid(t)
     {var _k_=t[2];return caml_call2(_b_,id(t[1],t[3][2]),_k_)}
    function value_exn$0(t)
     {return is_node_valid(t)
              ?value_exn(t[1],t[3][2])
              :caml_call1(Core[6],cst_Heap_value_exn_node_was_re)}
    function sexp_of_t$0(sexp_of_a,t)
     {var _j_=is_node_valid(t)?[0,value_exn(t[1],t[3][2])]:0;
      return caml_call2(Core[454],sexp_of_a,_j_)}
    function remove(t,token)
     {if(! caml_call2(Core[246],t,token[3]))
       return caml_call1(Core[6],cst_cannot_remove_from_a_diffe);
      var _h_=1 - caml_call1(is_empty,token[1]);
      if(_h_)
       {if(is_node_valid(token))remove_non_empty(t,token[1]);
        token[1] = caml_call1(empty,0);
        var _i_=0}
      else
       var _i_=_h_;
      return _i_}
    function add_removable(t,v)
     {var node=add_node(t,v);return [0,node,id(node,t[2]),t]}
    function update(t,token,v){remove(t,token);return add_removable(t,v)}
    function find_elt(t,f)
     {var nodes$1=[0,t[3],0],nodes=nodes$1;
      for(;;)
       {if(! nodes)return 0;
        var rest=nodes[2],node=nodes[1];
        if(caml_call1(is_empty,node)){var nodes=rest;continue}
        if(caml_call1(f,value_exn(node,t[2])))
         return [0,[0,node,id(node,t[2]),t]];
        var
         _g_=[0,child(node,t[2]),rest],
         nodes$0=[0,sibling(node,t[2]),_g_],
         nodes=nodes$0}}
    function value(t,heap){return value_exn(t,heap[2])}
    var Elt=[0,value];
    function update$0(t,elt,v){remove_non_empty(t,elt);return add_node(t,v)}
    var Unsafe=[0,Elt,add_node,remove_non_empty,update$0];
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_pairing_heap$1);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Pairing_heap$0);
    var
     Pairing_heap=
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       copy,
       [0,sexp_of_t$0,value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
    runtime.caml_register_global(26,Pairing_heap,"Pairing_heap");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVtcHR5IiwiaXNfZW1wdHkiLCJlcXVhbCIsImR1bW15X2lkIiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwic2libGluZyQwIiwiZGlzY29ubmVjdF9jaGlsZCIsImNoaWxkJDAiLCJkZXRhY2giLCJwcmV2JDAiLCJyZWxhdGlvbl90b19wcmV2IiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJpbnZhcmlhbnQiLCJ0b192aXNpdCQxIiwidG9fdmlzaXQiLCJyZXN0IiwibWF5YmVfcGFyZW50X3ZhbHVlIiwiZXhwZWN0ZWRfcHJldiIsIm5vZGUiLCJ0aGlzX3ZhbHVlIiwicGFyZW50X3ZhbHVlIiwidG9fdmlzaXQkMCIsImNyZWF0ZSQwIiwib3B0IiwiY21wIiwic3RoIiwibWluX3NpemUiLCJjb3B5IiwicG9vbCQwIiwicm9vdCQwIiwibnVtX29mX2FsbG9jYXRlZF9ub2RlcyIsImNvcHlfbm9kZSIsIm5ld19ub2RlIiwicm9vdCIsIm5vZGVfdG9fY29weSIsInNsb3QiLCJub2RlX3RvX3VwZGF0ZSIsIm1lcmdlIiwicm9vdDEiLCJyb290MiIsImFkZF9jaGlsZCIsImN1cnJlbnRfY2hpbGQiLCJ2MSIsInYyIiwidG9wX2V4biIsInRvcCIsImFkZF9ub2RlIiwiYWRkIiwibWF4X3N0YWNrX2RlcHRoIiwibG9vcCIsImRlcHRoIiwiaGVhZCQxIiwibmV4dDEkMCIsIm5leHQyIiwiYWNjIiwiaGVhZCIsIm5leHQxIiwiaGVhZCQwIiwiYWNjJDAiLCJ4cyIsImhlYXAiLCJyZW1vdmVfbm9uX2VtcHR5IiwibWVyZ2VkX2NoaWxkcmVuIiwibmV3X3Jvb3QiLCJyZW1vdmVfdG9wIiwiY2xlYXIiLCJub2RlJDAiLCJwb3BfZXhuIiwiciIsInBvcCIsInBvcF9pZiIsImYiLCJmb2xkIiwiYWNjJDEiLCJpdGVyIiwibGVuZ3RoIiwiaXRlciQwIiwibGVuZ3RoJDAiLCJpc19lbXB0eSQwIiwibWVtIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJvZl9hcnJheSIsImFyciIsIm9mX2xpc3QiLCJsIiwic2V4cF9vZl90IiwiaXNfbm9kZV92YWxpZCIsInZhbHVlX2V4biQwIiwic2V4cF9vZl90JDAiLCJzZXhwX29mX2EiLCJyZW1vdmUiLCJ0b2tlbiIsImFkZF9yZW1vdmFibGUiLCJ1cGRhdGUiLCJmaW5kX2VsdCIsIm5vZGVzJDEiLCJub2RlcyIsIm5vZGVzJDAiLCJ1cGRhdGUkMCIsImVsdCJdLCJzb3VyY2VzIjpbIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9jb3JlX2tlcm5lbC9wYWlyaW5nX2hlYXAvcGFpcmluZ19oZWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7OztJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E4Rk1BO0tBQ0FDO0tBQ0FDOzs7OztLQVRBQzthQVdBQyxNQUFNQyxFQUFHQztNQUFPLGlDQUFQQSxLQUFIRCxtQkFBc0M7YUFDNUNFLFFBQVFGLEVBQUdDO01BQU8saUNBQVBBLEtBQUhELG1CQUFzQzthQUM5Q0csS0FBS0gsRUFBR0M7TUFBTyxpQ0FBUEEsS0FBSEQsbUJBQXNDO2FBQzNDSSxHQUFHSixFQUFHQztNQUFPLGlDQUFQQSxLQUFIRCxtQkFBc0M7YUFHekNLLFVBQVVMLEVBQUVNLEVBQUdMO01BQU8saUNBQVBBLEtBQUxELG1CQUFFTSxFQUF3QzthQUNwREMsWUFBWVAsRUFBRU0sRUFBR0w7TUFBTyxpQ0FBUEEsS0FBTEQsbUJBQUVNLEVBQXdD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T0FzREFrQjtPQUNBQztPQVhBWDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQXRSQTNFO09BdVJBNEU7T0FDQUM7T0FuUUFuRTtPQXVRQXNFO09BTUFFO09Bdk5BakQ7T0FOQUQ7T0FjQUc7T0FrR0FpQjtPQWtCQUM7T0FhQUk7T0FOQUY7T0FRQUc7T0F6TEEzQztVQTZSRXdFLFlBTkFEO09Ba0JGSztPQVRBRjtPQWNBRztPQUtBQzs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcbm1vZHVsZSBQb2ludGVyID0gUG9vbC5Qb2ludGVyXG5cbigqIFRoaXMgcG9vbCBob2xkcyBub2RlcyB0aGF0IHdvdWxkIGJlIHJlcHJlc2VudGVkIG1vcmUgdHJhZGl0aW9uYWxseSBhczpcblxuICAge1tcbiAgICAgdHlwZSAnYSB0ID1cbiAgICAgICB8IEVtcHR5XG4gICAgICAgfCBIZWFwIG9mICdhICogJ2EgdCBsaXN0IF19XG5cbiAgIFdlIHdpbGwgcmVwcmVzZW50IHRoZW0gYXMgYSBsZWZ0LWNoaWxkLCByaWdodC1zaWJsaW5nIHRyZWUgaW4gYSB0cmlwbGV0XG4gICAodmFsdWUgKiBsZWZ0X2NoaWxkICogcmlnaHRfc2libGluZykuICBUaGUgbGVmdCBjaGlsZCBhbmQgYWxsIHJpZ2h0IHNpYmxpbmdzXG4gICBvZiB0aGUgbGVmdCBjaGlsZCBmb3JtIGEgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJoZWFwcyBvZiBhIGdpdmVuIGhlYXA6XG5cbiAgIHt2XG4gICAgICAgICBBXG4gICAgICAgIC9cbiAgICAgICBCIC0+IEMgLT4gRCAtPiBFIC0+IEZcbiAgICAgIC8gICAgICAgICAvICAgICAgICAgL1xuICAgICBHICAgICAgICAgSC0+SS0+SiAgIEstPkxcbiAgIHZ9ICopXG5cbm1vZHVsZSBOb2RlIDogc2lnXG4gICgqIEV4cG9zaW5nIFtwcml2YXRlIGludF0gaXMgYSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCwgYmVjYXVzZSBpdCBhbGxvd3NcbiAgICAgdGhlIGNvbXBpbGVyIHRvIHNraXAgdGhlIHdyaXRlIGJhcnJpZXIuICopXG5cbiAgdHlwZSAnYSB0ID0gcHJpdmF0ZSBpbnRcblxuICBtb2R1bGUgSWQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIGVuZFxuXG4gIG1vZHVsZSBQb29sIDogc2lnXG4gICAgdHlwZSAnYSBub2RlID0gJ2EgdFxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNyZWF0ZSA6IG1pbl9zaXplOmludCAtPiAnYSB0XG4gICAgdmFsIGlzX2Z1bGwgOiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgZ3JvdyA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSBub2RlIC0+ICdhIG5vZGUgKiAnYSB0XG4gIGVuZFxuXG4gICgqKiBbYWxsb2NhdGUgdiB+cG9vbF0gYWxsb2NhdGVzIGEgbmV3IG5vZGUgZnJvbSB0aGUgcG9vbCB3aXRoIG5vIGNoaWxkIG9yIHNpYmxpbmcgKilcbiAgdmFsIGFsbG9jYXRlIDogJ2EgLT4gcG9vbDonYSBQb29sLnQgLT4gaWQ6SWQudCAtPiAnYSB0XG5cbiAgKCoqIFtmcmVlIHQgfnBvb2xdIGZyZWVzIFt0XSBmb3IgcmV1c2UuICBJdCBpcyBhbiBlcnJvciB0byBhY2Nlc3MgW3RdIGFmdGVyIHRoaXMuICopXG4gIHZhbCBmcmVlIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5cbiAgKCoqIGEgc3BlY2lhbCBbdF0gdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBub2RlICopXG4gIHZhbCBlbXB0eSA6IHVuaXQgLT4gJ2EgdFxuXG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuXG4gICgqKiBbdmFsdWVfZXhuIHQgfnBvb2xdIHJldHVybiB0aGUgdmFsdWUgb2YgW3RdLCByYWlzZSBpZiBbaXNfZW1wdHkgdF0gKilcbiAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2FcblxuICB2YWwgaWQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IElkLnRcbiAgdmFsIGNoaWxkIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG4gIHZhbCBzaWJsaW5nIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFtwcmV2IHRdIGlzIGVpdGhlciB0aGUgcGFyZW50IG9mIFt0XSBvciB0aGUgc2libGluZyBpbW1lZGlhdGVseSBsZWZ0IG9mIFt0XSAqKVxuICB2YWwgcHJldiA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbYWRkX2NoaWxkIHQgfmNoaWxkIH5wb29sXSBBZGQgYSBjaGlsZCB0byBbdF0sIHByZXNlcnZpbmcgZXhpc3RpbmcgY2hpbGRyZW4gYXNcbiAgICAgIHNpYmxpbmdzIG9mIFtjaGlsZF0uIFt0XSBhbmQgW2NoaWxkXSBzaG91bGQgbm90IGJlIGVtcHR5IGFuZCBbY2hpbGRdIHNob3VsZCBoYXZlIG5vXG4gICAgICBzaWJsaW5nIGFuZCBoYXZlIG5vIHByZXYgbm9kZS4gKilcbiAgdmFsIGFkZF9jaGlsZCA6ICdhIHQgLT4gY2hpbGQ6J2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiB1bml0XG5cbiAgKCoqIGRpc2Nvbm5lY3QgYW5kIHJldHVybiB0aGUgc2libGluZyAqKVxuICB2YWwgZGlzY29ubmVjdF9zaWJsaW5nIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIGRpc2Nvbm5lY3QgYW5kIHJldHVybiB0aGUgY2hpbGQgKilcbiAgdmFsIGRpc2Nvbm5lY3RfY2hpbGQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW2RldGFjaCB0IH5wb29sXSByZW1vdmVzIFt0XSBmcm9tIHRoZSB0cmVlLCBhZGp1c3RpbmcgcG9pbnRlcnMgYXJvdW5kIGl0LiBBZnRlclxuICAgICAgW2RldGFjaF0sIFt0XSBpcyB0aGUgcm9vdCBvZiBhIHN0YW5kYWxvbmUgaGVhcCwgd2hpY2ggaXMgZGV0YWNoZWQgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgIGhlYXAuICopXG4gIHZhbCBkZXRhY2ggOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgSWQgPSBJbnRcblxuICBsZXQgZHVtbXlfaWQgOiBJZC50ID0gLTFcblxuICB0eXBlICdhIG5vZGUgPVxuICAgICgnYSwgJ2Egbm9kZSBQb2ludGVyLnQsICdhIG5vZGUgUG9pbnRlci50LCAnYSBub2RlIFBvaW50ZXIudCwgSWQudCkgUG9vbC5TbG90cy50NVxuXG4gIHR5cGUgJ2EgdCA9ICdhIG5vZGUgUG9pbnRlci50XG5cbiAgbGV0IGVtcHR5ID0gUG9pbnRlci5udWxsXG4gIGxldCBpc19lbXB0eSA9IFBvaW50ZXIuaXNfbnVsbFxuICBsZXQgZXF1YWwgPSBQb2ludGVyLnBoeXNfZXF1YWxcbiAgbGV0IHZhbHVlIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQwXG4gIGxldCBjaGlsZCB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MVxuICBsZXQgc2libGluZyB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50MlxuICBsZXQgcHJldiB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50M1xuICBsZXQgaWQgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDRcblxuICAoKiBsZXQgc2V0X3ZhbHVlICAgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MCB2ICopXG4gIGxldCBzZXRfY2hpbGQgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MSB2XG4gIGxldCBzZXRfc2libGluZyB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQyIHZcbiAgbGV0IHNldF9wcmV2IHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDMgdlxuXG4gIGxldCB2YWx1ZV9leG4gdCB+cG9vbCA9XG4gICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IHQpKTtcbiAgICB2YWx1ZSB0IH5wb29sXG4gIDs7XG5cbiAgbGV0IGFsbG9jYXRlIHZhbHVlIH5wb29sIH5pZCA9IFBvb2wubmV3NSBwb29sIHZhbHVlIChlbXB0eSAoKSkgKGVtcHR5ICgpKSAoZW1wdHkgKCkpIGlkXG4gIGxldCBmcmVlIHQgfnBvb2wgPSBQb29sLnVuc2FmZV9mcmVlIHBvb2wgdFxuXG4gIGxldCBkaXNjb25uZWN0X3NpYmxpbmcgdCB+cG9vbCA9XG4gICAgbGV0IHNpYmxpbmcgPSBzaWJsaW5nIHQgfnBvb2wgaW5cbiAgICBpZiBub3QgKGlzX2VtcHR5IHNpYmxpbmcpXG4gICAgdGhlbiAoXG4gICAgICBzZXRfc2libGluZyB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICBzZXRfcHJldiBzaWJsaW5nIChlbXB0eSAoKSkgfnBvb2wpO1xuICAgIHNpYmxpbmdcbiAgOztcblxuICBsZXQgZGlzY29ubmVjdF9jaGlsZCB0IH5wb29sID1cbiAgICBsZXQgY2hpbGQgPSBjaGlsZCB0IH5wb29sIGluXG4gICAgaWYgbm90IChpc19lbXB0eSBjaGlsZClcbiAgICB0aGVuIChcbiAgICAgIHNldF9jaGlsZCB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICBzZXRfcHJldiBjaGlsZCAoZW1wdHkgKCkpIH5wb29sKTtcbiAgICBjaGlsZFxuICA7O1xuXG4gIGxldCBhZGRfY2hpbGQgdCB+Y2hpbGQ6bmV3X2NoaWxkIH5wb29sID1cbiAgICAoKiBhc3NlcnRpb25zIHdlIHdvdWxkIG1ha2UsIGJ1dCBmb3Igc3BlZWQ6XG4gICAgICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IHQpKTtcbiAgICAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgbmV3X2NoaWxkKSk7XG4gICAgICAgYXNzZXJ0IChpc19lbXB0eSAoc2libGluZyBuZXdfY2hpbGQgfnBvb2wpKTtcbiAgICAgICBhc3NlcnQgKGlzX2VtcHR5IChwcmV2IG5ld19jaGlsZCB+cG9vbCkpO1xuICAgICopXG4gICAgbGV0IGN1cnJlbnRfY2hpbGQgPSBkaXNjb25uZWN0X2NoaWxkIHQgfnBvb2wgaW5cbiAgICAoKiBhZGQgW25ld19jaGlsZF0gdG8gdGhlIGxpc3Qgb2YgW3RdJ3MgY2hpbGRyZW4gKHdoaWNoIG1heSBiZSBlbXB0eSkgKilcbiAgICBzZXRfc2libGluZyBuZXdfY2hpbGQgY3VycmVudF9jaGlsZCB+cG9vbDtcbiAgICBpZiBub3QgKGlzX2VtcHR5IGN1cnJlbnRfY2hpbGQpIHRoZW4gc2V0X3ByZXYgY3VycmVudF9jaGlsZCBuZXdfY2hpbGQgfnBvb2w7XG4gICAgc2V0X2NoaWxkIHQgbmV3X2NoaWxkIH5wb29sO1xuICAgIHNldF9wcmV2IG5ld19jaGlsZCB0IH5wb29sXG4gIDs7XG5cbiAgbGV0IGRldGFjaCB0IH5wb29sID1cbiAgICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcHJldiA9IHByZXYgdCB+cG9vbCBpblxuICAgICAgaWYgbm90IChpc19lbXB0eSBwcmV2KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCByZWxhdGlvbl90b19wcmV2ID0gaWYgZXF1YWwgdCAoY2hpbGQgcHJldiB+cG9vbCkgdGhlbiBgY2hpbGQgZWxzZSBgc2libGluZyBpblxuICAgICAgICBzZXRfcHJldiB0IChlbXB0eSAoKSkgfnBvb2w7XG4gICAgICAgIGxldCBzaWJsaW5nID0gZGlzY29ubmVjdF9zaWJsaW5nIHQgfnBvb2wgaW5cbiAgICAgICAgKG1hdGNoIHJlbGF0aW9uX3RvX3ByZXYgd2l0aFxuICAgICAgICAgfCBgY2hpbGQgLT4gc2V0X2NoaWxkIHByZXYgc2libGluZyB+cG9vbFxuICAgICAgICAgfCBgc2libGluZyAtPiBzZXRfc2libGluZyBwcmV2IHNpYmxpbmcgfnBvb2wpO1xuICAgICAgICBpZiBub3QgKGlzX2VtcHR5IHNpYmxpbmcpIHRoZW4gc2V0X3ByZXYgc2libGluZyBwcmV2IH5wb29sKSlcbiAgOztcblxuICBtb2R1bGUgUG9vbCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIG5vZGUgUG9vbC50XG4gICAgdHlwZSBub25yZWMgJ2Egbm9kZSA9ICdhIG5vZGUgUG9pbnRlci50XG5cbiAgICBsZXQgY3JlYXRlICh0eXBlIGEpIH5taW5fc2l6ZTpjYXBhY2l0eSA6IGEgdCA9XG4gICAgICBQb29sLmNyZWF0ZVxuICAgICAgICBQb29sLlNsb3RzLnQ1XG4gICAgICAgIH5jYXBhY2l0eVxuICAgICAgICB+ZHVtbXk6XG4gICAgICAgICAgKCAoT2JqLm1hZ2ljIE5vbmUgOiBhKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgZHVtbXlfaWQgKVxuICAgIDs7XG5cbiAgICBsZXQgaXNfZnVsbCB0ID0gUG9vbC5pc19mdWxsIHRcbiAgICBsZXQgbGVuZ3RoIHQgPSBQb29sLmxlbmd0aCB0XG4gICAgbGV0IGdyb3cgdCA9IFBvb2wuZ3JvdyB0XG5cbiAgICBsZXQgY29weSB0IHN0YXJ0ID1cbiAgICAgIGxldCB0JyA9IGNyZWF0ZSB+bWluX3NpemU6KFBvb2wuY2FwYWNpdHkgdCkgaW5cbiAgICAgIGxldCBjb3B5X25vZGUgbm9kZSB0b192aXNpdCA9XG4gICAgICAgIGlmIGlzX2VtcHR5IG5vZGVcbiAgICAgICAgdGhlbiBlbXB0eSAoKSwgdG9fdmlzaXRcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogd2UgdXNlIHRoZSBzYW1lIGlkLCBidXQgdGhhdCdzIG9rIHNpbmNlIGlkcyBzaG91bGQgYmUgdW5pcXVlIHBlciBoZWFwICopXG4gICAgICAgICAgbGV0IG5ld19ub2RlID1cbiAgICAgICAgICAgIGFsbG9jYXRlICh2YWx1ZV9leG4gbm9kZSB+cG9vbDp0KSB+cG9vbDp0JyB+aWQ6KGlkIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCB0b192aXNpdCA9XG4gICAgICAgICAgICAobmV3X25vZGUsIGBjaGlsZCwgY2hpbGQgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgICAgOjogKG5ld19ub2RlLCBgc2libGluZywgc2libGluZyBub2RlIH5wb29sOnQpXG4gICAgICAgICAgICA6OiB0b192aXNpdFxuICAgICAgICAgIGluXG4gICAgICAgICAgbmV3X25vZGUsIHRvX3Zpc2l0KVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IChub2RlX3RvX3VwZGF0ZSwgc2xvdCwgbm9kZV90b19jb3B5KSA6OiByZXN0IC0+XG4gICAgICAgICAgbGV0IG5ld19ub2RlLCB0b192aXNpdCA9IGNvcHlfbm9kZSBub2RlX3RvX2NvcHkgcmVzdCBpblxuICAgICAgICAgIChtYXRjaCBzbG90IHdpdGhcbiAgICAgICAgICAgfCBgY2hpbGQgLT4gc2V0X2NoaWxkIG5vZGVfdG9fdXBkYXRlIG5ld19ub2RlIH5wb29sOnQnXG4gICAgICAgICAgIHwgYHNpYmxpbmcgLT4gc2V0X3NpYmxpbmcgbm9kZV90b191cGRhdGUgbmV3X25vZGUgfnBvb2w6dCcpO1xuICAgICAgICAgIGlmIG5vdCAoaXNfZW1wdHkgbmV3X25vZGUpIHRoZW4gc2V0X3ByZXYgbmV3X25vZGUgbm9kZV90b191cGRhdGUgfnBvb2w6dCc7XG4gICAgICAgICAgbG9vcCB0b192aXNpdFxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfc3RhcnQsIHRvX3Zpc2l0ID0gY29weV9ub2RlIHN0YXJ0IFtdIGluXG4gICAgICBsb29wIHRvX3Zpc2l0O1xuICAgICAgbmV3X3N0YXJ0LCB0J1xuICAgIDs7XG4gIGVuZFxuZW5kXG5cbnR5cGUgJ2EgdCA9XG4gIHsgKCogY21wIGlzIHBsYWNlZCBmaXJzdCB0byBzaG9ydC1jaXJjdWl0IHBvbHltb3JwaGljIGNvbXBhcmUgKilcbiAgICBjbXAgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBtdXRhYmxlIHBvb2wgOiAnYSBOb2RlLlBvb2wudFxuICA7ICgqIGludmFyaWFudDogIFtyb290XSBuZXZlciBoYXMgYSBzaWJsaW5nICopXG4gICAgbXV0YWJsZSByb290IDogJ2EgTm9kZS50XG4gIDsgbXV0YWJsZSBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIDogaW50XG4gIH1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCAobm9kZSwgZXhwZWN0ZWRfcHJldiwgbWF5YmVfcGFyZW50X3ZhbHVlKSA6OiByZXN0IC0+XG4gICAgICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgbm9kZSlcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgdGhpc192YWx1ZSA9IE5vZGUudmFsdWVfZXhuIG5vZGUgfnBvb2w6dC5wb29sIGluXG4gICAgICAgIGFzc2VydCAoTm9kZS5lcXVhbCAoTm9kZS5wcmV2IG5vZGUgfnBvb2w6dC5wb29sKSBleHBlY3RlZF9wcmV2KTtcbiAgICAgICAgT3B0aW9uLml0ZXIgbWF5YmVfcGFyZW50X3ZhbHVlIH5mOihmdW4gcGFyZW50X3ZhbHVlIC0+XG4gICAgICAgICAgYXNzZXJ0ICh0LmNtcCBwYXJlbnRfdmFsdWUgdGhpc192YWx1ZSA8PSAwKSk7XG4gICAgICAgIGxvb3BcbiAgICAgICAgICAoKE5vZGUuY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wsIG5vZGUsIFNvbWUgdGhpc192YWx1ZSlcbiAgICAgICAgICAgOjogKE5vZGUuc2libGluZyBub2RlIH5wb29sOnQucG9vbCwgbm9kZSwgbWF5YmVfcGFyZW50X3ZhbHVlKVxuICAgICAgICAgICA6OiByZXN0KSlcbiAgICAgIGVsc2UgbG9vcCByZXN0XG4gIGluXG4gIGFzc2VydCAoTm9kZS5pc19lbXB0eSB0LnJvb3QgfHwgTm9kZS5pc19lbXB0eSAoTm9kZS5zaWJsaW5nIHQucm9vdCB+cG9vbDp0LnBvb2wpKTtcbiAgbG9vcCBbIHQucm9vdCwgTm9kZS5lbXB0eSAoKSwgTm9uZSBdXG47O1xuXG5sZXQgY3JlYXRlID8obWluX3NpemUgPSAxKSB+Y21wICgpID1cbiAgeyBjbXBcbiAgOyBwb29sID0gTm9kZS5Qb29sLmNyZWF0ZSB+bWluX3NpemVcbiAgOyByb290ID0gTm9kZS5lbXB0eSAoKVxuICA7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgPSAwXG4gIH1cbjs7XG5cbmxldCBjb3B5IHsgY21wOyBwb29sOyByb290OyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIH0gPVxuICBsZXQgcm9vdCwgcG9vbCA9IE5vZGUuUG9vbC5jb3B5IHBvb2wgcm9vdCBpblxuICB7IGNtcDsgcG9vbDsgcm9vdDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyB9XG47O1xuXG5sZXQgYWxsb2NhdGUgdCB2ID1cbiAgaWYgTm9kZS5Qb29sLmlzX2Z1bGwgdC5wb29sIHRoZW4gdC5wb29sIDwtIE5vZGUuUG9vbC5ncm93IHQucG9vbDtcbiAgdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzIDwtIHQubnVtX29mX2FsbG9jYXRlZF9ub2RlcyArIDE7XG4gIE5vZGUuYWxsb2NhdGUgdiB+cG9vbDp0LnBvb2wgfmlkOihOb2RlLklkLm9mX2ludCB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMpXG47O1xuXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIG1hdGNoIHJvb3QxLCByb290MiB3aXRoXG4gICAgIHwgTm9uZSwgaCB8IGgsIE5vbmUgLT4gaFxuICAgICB8IFNvbWUgKE5vZGUgKHYxLCBjaGlsZHJlbjEpKSwgU29tZSAoTm9kZSAodjIsIGNoaWxkcmVuMikpIC0+XG4gICAgICAgaWYgdjEgPCB2MlxuICAgICAgIHRoZW4gU29tZSAoTm9kZSAodjEsIHJvb3QyIDo6IGNoaWxkcmVuMSkpXG4gICAgICAgZWxzZSBTb21lIChOb2RlICh2Miwgcm9vdDEgOjogY2hpbGRyZW4yKSlcbiAgIF19XG5cbiAgIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBuZWl0aGVyIHJvb3QgaGFzIGEgcHJldiBub2RlICh1c3VhbGx5IGJlY2F1c2UgdGhlIGlucHV0cyBjb21lXG4gICBmcm9tIFtkaXNjb25uZWN0XypdIG9yIGFyZSB0aGUgdG9wIG9mIHRoZSBoZWFwIG9yIGFyZSB0aGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24pLiAqKVxubGV0IG1lcmdlIHQgcm9vdDEgcm9vdDIgPVxuICBpZiBOb2RlLmlzX2VtcHR5IHJvb3QxXG4gIHRoZW4gcm9vdDJcbiAgZWxzZSBpZiBOb2RlLmlzX2VtcHR5IHJvb3QyXG4gIHRoZW4gcm9vdDFcbiAgZWxzZSAoXG4gICAgbGV0IGFkZF9jaGlsZCB0IG5vZGUgfmNoaWxkID1cbiAgICAgIE5vZGUuYWRkX2NoaWxkIG5vZGUgfnBvb2w6dC5wb29sIH5jaGlsZDtcbiAgICAgIG5vZGVcbiAgICBpblxuICAgIGxldCB2MSA9IE5vZGUudmFsdWVfZXhuIHJvb3QxIH5wb29sOnQucG9vbCBpblxuICAgIGxldCB2MiA9IE5vZGUudmFsdWVfZXhuIHJvb3QyIH5wb29sOnQucG9vbCBpblxuICAgIGlmIHQuY21wIHYxIHYyIDwgMFxuICAgIHRoZW4gYWRkX2NoaWxkIHQgcm9vdDEgfmNoaWxkOnJvb3QyXG4gICAgZWxzZSBhZGRfY2hpbGQgdCByb290MiB+Y2hpbGQ6cm9vdDEpXG47O1xuXG5sZXQgdG9wX2V4biB0ID1cbiAgaWYgTm9kZS5pc19lbXB0eSB0LnJvb3RcbiAgdGhlbiBmYWlsd2l0aCBcIkhlYXAudG9wX2V4biBjYWxsZWQgb24gYW4gZW1wdHkgaGVhcFwiXG4gIGVsc2UgTm9kZS52YWx1ZV9leG4gdC5yb290IH5wb29sOnQucG9vbFxuOztcblxubGV0IHRvcCB0ID0gaWYgTm9kZS5pc19lbXB0eSB0LnJvb3QgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX2V4biB0KVxuXG5sZXQgYWRkX25vZGUgdCB2ID1cbiAgbGV0IG5vZGUgPSBhbGxvY2F0ZSB0IHYgaW5cbiAgdC5yb290IDwtIG1lcmdlIHQgdC5yb290IG5vZGU7XG4gIG5vZGVcbjs7XG5cbmxldCBhZGQgdCB2ID0gaWdub3JlIChhZGRfbm9kZSB0IHYgOiBfIE5vZGUudClcblxuKCogW21lcmdlX3BhaXJzXSB0YWtlcyBhIGxpc3Qgb2YgaGVhcCByb290cyBhbmQgbWVyZ2VzIGNvbnNlY3V0aXZlIHBhaXJzLCByZWR1Y2luZyB0aGVcbiAgIGxpc3Qgb2YgbGVuZ3RoIG4gdG8gbi8yLiAgVGhlbiBpdCBtZXJnZXMgdGhlIG1lcmdlZCBwYWlycyBpbnRvIGEgc2luZ2xlIGhlYXAuICBPbmVcbiAgIGludHVpdGlvbiBpcyB0aGF0IHRoaXMgaXMgc29tZXdoYXQgbGlrZSBidWlsZGluZyBhIHNpbmdsZSBsZXZlbCBvZiBhIGJpbmFyeSB0cmVlLlxuXG4gICBUaGUgb3V0cHV0IGhlYXAgZG9lcyBub3QgY29udGFpbiB0aGUgdmFsdWUgdGhhdCB3YXMgYXQgdGhlIHJvb3Qgb2YgdGhlIGlucHV0IGhlYXAuXG5cbiAgIFdlIGJyZWFrIHRoZSBmdW5jdGlvbiBpbnRvIHR3byBwYXJ0cy4gIEEgZmlyc3Qgc3RhZ2UgdGhhdCBpcyB3aWxsaW5nIHRvIHVzZSBsaW1pdGVkXG4gICBzdGFjayBpbnN0ZWFkIG9mIGhlYXAgYWxsb2NhdGlvbiBmb3IgYm9va2tlZXBpbmcsIGFuZCBhIHNlY29uZCBzdGFnZSB0aGF0IHNoaWZ0cyB0b1xuICAgdXNpbmcgYSBsaXN0IGFzIGFuIGFjY3VtdWxhdG9yIGlmIHdlIGdvIHRvbyBkZWVwLlxuXG4gICBUaGlzIGNhbiBiZSBtYWRlIHRhaWwgcmVjdXJzaXZlIGFuZCBub24tYWxsb2NhdGluZyBieSBzdGFydGluZyB3aXRoIGFuIGVtcHR5IGhlYXAgYW5kXG4gICBtZXJnaW5nIG1lcmdlZCBwYWlycyBpbnRvIGl0LiBVbmZvcnR1bmF0ZWx5IHRoaXMgXCJsZWZ0IGZvbGRcIiB2ZXJzaW9uIGlzIG5vdCB3aGF0IGlzXG4gICBkZXNjcmliZWQgaW4gdGhlIG9yaWdpbmFsIHBhcGVyIGJ5IEZyZWRtYW4gZXQgYWwuOyB0aGV5IHNwZWNpZmljYWxseSBzYXkgdGhhdFxuICAgY2hpbGRyZW4gc2hvdWxkIGJlIG1lcmdlZCB0b2dldGhlciBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3QgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgIGxpc3QuIChbbWVyZ2VdIGlzIG5vdCBhc3NvY2lhdGl2ZSwgc28gb3JkZXIgbWF0dGVycy4pXG4qKVxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgICB8IFtdIC0+IGFjY1xuICAgICAgIHwgW2hlYWRdIC0+IGhlYWQgOjogYWNjXG4gICAgICAgfCBoZWFkIDo6IG5leHQxIDo6IG5leHQyIC0+IGxvb3AgKG1lcmdlIGhlYWQgbmV4dDEgOjogYWNjKSBuZXh0MlxuICAgICBpblxuICAgICBtYXRjaCBsb29wIFtdIGNoaWxkcmVuIHdpdGhcbiAgICAgfCBbXSAtPiBOb25lXG4gICAgIHwgW2hdIC0+IFNvbWUgaFxuICAgICB8IHggOjogeHMgLT4gU29tZSAoTGlzdC5mb2xkIHhzIH5pbml0OnggfmY6bWVyZ2UpXG4gICBdfVxuKilcbmxldCBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgaGVhZCA9XG4gIGxldCByZWMgbG9vcCBhY2MgaGVhZCA9XG4gICAgaWYgTm9kZS5pc19lbXB0eSBoZWFkXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0MSA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIGhlYWQgfnBvb2w6dC5wb29sIGluXG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5leHQxXG4gICAgICB0aGVuIGhlYWQgOjogYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5leHQyID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgbmV4dDEgfnBvb2w6dC5wb29sIGluXG4gICAgICAgIGxvb3AgKG1lcmdlIHQgaGVhZCBuZXh0MSA6OiBhY2MpIG5leHQyKSlcbiAgaW5cbiAgbWF0Y2ggbG9vcCBbXSBoZWFkIHdpdGhcbiAgfCBbXSAtPiBOb2RlLmVtcHR5ICgpXG4gIHwgWyBoIF0gLT4gaFxuICB8IHggOjogeHMgLT4gTGlzdC5mb2xkIHhzIH5pbml0OnggfmY6KGZ1biBhY2MgaGVhcCAtPiBtZXJnZSB0IGFjYyBoZWFwKVxuOztcblxuKCogdHJhbnNsYXRpb246XG4gICB7W1xuICAgICBtYXRjaCB0LnJvb3Qgd2l0aFxuICAgICB8IE5vZGUgKF8sIGNoaWxkcmVuKSAtPlxuICAgICAgIGxldCByZWMgbG9vcCBkZXB0aCBjaGlsZHJlbiA9XG4gICAgICAgICBpZiBkZXB0aCA+PSBtYXhfc3RhY2tfZGVwdGhcbiAgICAgICAgIHRoZW4gYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGNoaWxkZW5cbiAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgbWF0Y2ggY2hpbGRyZW4gd2l0aFxuICAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICAgfCBbaGVhZF0gLT4gU29tZSBoZWFkXG4gICAgICAgICAgIHwgaGVhZCA6OiBuZXh0MSA6OiBuZXh0MiAtPlxuICAgICAgICAgICAgIG1lcmdlIChtZXJnZSBoZWFkIG5leHQxKSAobG9vcCAoZGVwdGggKyAxKSBuZXh0MilcbiAgICAgICAgIGVuZFxuICAgICAgIGluXG4gICAgICAgbG9vcCAwIGNoaWxkcmVuXG4gICBdfVxuKilcbmxldCBtZXJnZV9wYWlycyA9XG4gIGxldCBtYXhfc3RhY2tfZGVwdGggPSAxXzAwMCBpblxuICBsZXQgcmVjIGxvb3AgdCBkZXB0aCBoZWFkID1cbiAgICBpZiBkZXB0aCA+PSBtYXhfc3RhY2tfZGVwdGhcbiAgICB0aGVuIGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBoZWFkXG4gICAgZWxzZSBpZiBOb2RlLmlzX2VtcHR5IGhlYWRcbiAgICB0aGVuIGhlYWRcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0MSA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIGhlYWQgfnBvb2w6dC5wb29sIGluXG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5leHQxXG4gICAgICB0aGVuIGhlYWRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV4dDIgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBuZXh0MSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgKCogbWVyZ2UgdGhlIGZpcnN0IHR3byBub2RlcyBpbiBvdXIgbGlzdCwgYW5kIHRoZW4gbWVyZ2UgdGhlIHJlc3VsdCB3aXRoIHRoZVxuICAgICAgICAgICByZXN1bHQgb2YgcmVjdXJzaXZlbHkgY2FsbGluZyBtZXJnZV9wYWlycyBvbiB0aGUgdGFpbCAqKVxuICAgICAgICBtZXJnZSB0IChtZXJnZSB0IGhlYWQgbmV4dDEpIChsb29wIHQgKGRlcHRoICsgMSkgbmV4dDIpKSlcbiAgaW5cbiAgZnVuIHQgaGVhZCAtPiBsb29wIHQgMCBoZWFkXG47O1xuXG5sZXQgcmVtb3ZlX25vbl9lbXB0eSB0IG5vZGUgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBOb2RlLmRldGFjaCBub2RlIH5wb29sO1xuICBsZXQgbWVyZ2VkX2NoaWxkcmVuID0gbWVyZ2VfcGFpcnMgdCAoTm9kZS5kaXNjb25uZWN0X2NoaWxkIG5vZGUgfnBvb2wpIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgaWYgTm9kZS5lcXVhbCB0LnJvb3Qgbm9kZSB0aGVuIG1lcmdlZF9jaGlsZHJlbiBlbHNlIG1lcmdlIHQgdC5yb290IG1lcmdlZF9jaGlsZHJlblxuICBpblxuICBOb2RlLmZyZWUgbm9kZSB+cG9vbDtcbiAgdC5yb290IDwtIG5ld19yb290XG47O1xuXG5sZXQgcmVtb3ZlX3RvcCB0ID0gaWYgbm90IChOb2RlLmlzX2VtcHR5IHQucm9vdCkgdGhlbiByZW1vdmVfbm9uX2VtcHR5IHQgdC5yb290XG5cbigqIE5vdGUgdGhhdCB0aGlzIGlzIHRhaWwtcmVjdXJzaXZlIGFuZCB0aGF0IGVhY2ggbm9kZSBpcyB2aXNpdGVkIGF0IG1vc3QgMyB0aW1lcyAob25jZVxuICAgZm9yIGVhY2ggYnJhbmNoIG9mIHRoZSBcImlmXCIpLCBzbyBpdCB0YWtlcyBsaW5lYXIgdGltZSBhbmQgY29uc3RhbnQgc3BhY2UuICopXG5sZXQgcmVjIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IG5vZGUgfnBvb2wgPVxuICBsZXQgY2hpbGQgPSBOb2RlLmNoaWxkIG5vZGUgfnBvb2wgaW5cbiAgbGV0IHNpYmxpbmcgPSBOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbCBpblxuICBpZiBub3QgKE5vZGUuaXNfZW1wdHkgY2hpbGQpXG4gIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgY2hpbGQgfnBvb2xcbiAgZWxzZSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgc2libGluZylcbiAgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBzaWJsaW5nIH5wb29sXG4gIGVsc2UgKFxuICAgIGxldCBwcmV2ID0gTm9kZS5wcmV2IG5vZGUgfnBvb2wgaW5cbiAgICBOb2RlLmRldGFjaCBub2RlIH5wb29sO1xuICAgIE5vZGUuZnJlZSBub2RlIH5wb29sO1xuICAgIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBwcmV2KSB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHByZXYgfnBvb2wpXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIG5vdCAoTm9kZS5pc19lbXB0eSB0LnJvb3QpXG4gIHRoZW4gKFxuICAgIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHQucm9vdCB+cG9vbDp0LnBvb2w7XG4gICAgdC5yb290IDwtIE5vZGUuZW1wdHkgKCkpXG47O1xuXG5sZXQgcG9wX2V4biB0ID1cbiAgbGV0IHIgPSB0b3BfZXhuIHQgaW5cbiAgcmVtb3ZlX3RvcCB0O1xuICByXG47O1xuXG5sZXQgcG9wIHQgPSBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3BfZXhuIHQpXG5cbmxldCBwb3BfaWYgdCBmID1cbiAgbWF0Y2ggdG9wIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgdiAtPlxuICAgIGlmIGYgdlxuICAgIHRoZW4gKFxuICAgICAgcmVtb3ZlX3RvcCB0O1xuICAgICAgU29tZSB2KVxuICAgIGVsc2UgTm9uZVxuOztcblxuKCogcGFpcmluZyBoZWFwcyBhcmUgbm90IGJhbGFuY2VkIHRyZWVzLCBhbmQgdGhlcmVmb3JlIHdlIGNhbid0IHJlbHkgb24gYSBiYWxhbmNlXG4gICBwcm9wZXJ0eSB0byBzdG9wIG91cnNlbHZlcyBmcm9tIG92ZXJmbG93aW5nIHRoZSBzdGFjay4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgYWNjIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgYWNjIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdG9fdmlzaXQgPSBOb2RlLnNpYmxpbmcgfnBvb2wgbm9kZSA6OiBOb2RlLmNoaWxkIH5wb29sIG5vZGUgOjogcmVzdCBpblxuICAgICAgICBsb29wIChmIGFjYyAoTm9kZS52YWx1ZV9leG4gfnBvb2wgbm9kZSkpIHRvX3Zpc2l0KVxuICBpblxuICBsb29wIGluaXQgWyB0LnJvb3QgXVxuOztcblxuKCogYWxtb3N0IGlkZW50aWNhbCB0byBmb2xkLCBjb3BpZWQgZm9yIHNwZWVkIHB1cnBvc2VzICopXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgbGV0IHJlYyBsb29wIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgbm9kZSA6OiByZXN0IC0+XG4gICAgICBpZiBOb2RlLmlzX2VtcHR5IG5vZGVcbiAgICAgIHRoZW4gbG9vcCByZXN0XG4gICAgICBlbHNlIChcbiAgICAgICAgZiAoTm9kZS52YWx1ZV9leG4gfnBvb2wgbm9kZSk7XG4gICAgICAgIGxldCB0b192aXNpdCA9IE5vZGUuc2libGluZyB+cG9vbCBub2RlIDo6IE5vZGUuY2hpbGQgfnBvb2wgbm9kZSA6OiByZXN0IGluXG4gICAgICAgIGxvb3AgdG9fdmlzaXQpXG4gIGluXG4gIGxvb3AgWyB0LnJvb3QgXVxuOztcblxubGV0IGxlbmd0aCB0ID0gTm9kZS5Qb29sLmxlbmd0aCB0LnBvb2xcblxubW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IGlzX2VtcHR5IHQgPSBOb2RlLmlzX2VtcHR5IHQucm9vdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfYXJyYXkgYXJyIH5jbXAgPVxuICBsZXQgdCA9IGNyZWF0ZSB+bWluX3NpemU6KEFycmF5Lmxlbmd0aCBhcnIpIH5jbXAgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnIgfmY6KGZ1biB2IC0+IGFkZCB0IHYpO1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdCBsIH5jbXAgPSBvZl9hcnJheSAoQXJyYXkub2ZfbGlzdCBsKSB+Y21wXG5sZXQgc2V4cF9vZl90IGYgdCA9IEFycmF5LnNleHBfb2ZfdCBmICh0b19hcnJheSB0IHw+IEFycmF5LnNvcnRlZF9jb3B5IH5jb21wYXJlOnQuY21wKVxuXG5tb2R1bGUgRWx0ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPVxuICAgIHsgbXV0YWJsZSBub2RlIDogJ2EgTm9kZS50XG4gICAgOyBub2RlX2lkIDogTm9kZS5JZC50XG4gICAgOyBoZWFwIDogJ2EgdFxuICAgIH1cblxuICAoKiBJZiBpZHMgYXJlIGRpZmZlcmVudCwgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYnkgc29tZVxuICAgICBvdGhlciBtZWFucyAoYW5kIHBvc3NpYmx5IHJldXNlZCkuICopXG4gIGxldCBpc19ub2RlX3ZhbGlkIHQgPSBOb2RlLklkLmVxdWFsIChOb2RlLmlkIH5wb29sOnQuaGVhcC5wb29sIHQubm9kZSkgdC5ub2RlX2lkXG5cbiAgbGV0IHZhbHVlIHQgPVxuICAgIGlmIGlzX25vZGVfdmFsaWQgdCB0aGVuIFNvbWUgKE5vZGUudmFsdWVfZXhuIHQubm9kZSB+cG9vbDp0LmhlYXAucG9vbCkgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2V4biB0ID1cbiAgICBpZiBpc19ub2RlX3ZhbGlkIHRcbiAgICB0aGVuIE5vZGUudmFsdWVfZXhuIHQubm9kZSB+cG9vbDp0LmhlYXAucG9vbFxuICAgIGVsc2UgZmFpbHdpdGggXCJIZWFwLnZhbHVlX2V4bjogbm9kZSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBoZWFwXCJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gWyVzZXhwICh2YWx1ZSB0IDogYSBvcHRpb24pXVxuZW5kXG5cbmxldCByZW1vdmUgdCAodG9rZW4gOiBfIEVsdC50KSA9XG4gIGlmIG5vdCAocGh5c19lcXVhbCB0IHRva2VuLmhlYXApXG4gIHRoZW4gZmFpbHdpdGggXCJjYW5ub3QgcmVtb3ZlIGZyb20gYSBkaWZmZXJlbnQgaGVhcFwiXG4gIGVsc2UgaWYgbm90IChOb2RlLmlzX2VtcHR5IHRva2VuLm5vZGUpXG4gIHRoZW4gKFxuICAgIGlmIEVsdC5pc19ub2RlX3ZhbGlkIHRva2VuIHRoZW4gcmVtb3ZlX25vbl9lbXB0eSB0IHRva2VuLm5vZGU7XG4gICAgdG9rZW4ubm9kZSA8LSBOb2RlLmVtcHR5ICgpKVxuOztcblxubGV0IGFkZF9yZW1vdmFibGUgdCB2ID1cbiAgbGV0IG5vZGUgPSBhZGRfbm9kZSB0IHYgaW5cbiAgeyBFbHQubm9kZTsgaGVhcCA9IHQ7IG5vZGVfaWQgPSBOb2RlLmlkIH5wb29sOnQucG9vbCBub2RlIH1cbjs7XG5cbmxldCB1cGRhdGUgdCB0b2tlbiB2ID1cbiAgcmVtb3ZlIHQgdG9rZW47XG4gIGFkZF9yZW1vdmFibGUgdCB2XG47O1xuXG5sZXQgZmluZF9lbHQgPVxuICBsZXQgcmVjIGxvb3AgdCBmIG5vZGVzID1cbiAgICBtYXRjaCBub2RlcyB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIHQgZiByZXN0XG4gICAgICBlbHNlIGlmIGYgKE5vZGUudmFsdWVfZXhuIG5vZGUgfnBvb2w6dC5wb29sKVxuICAgICAgdGhlbiBTb21lIHsgRWx0Lm5vZGU7IGhlYXAgPSB0OyBub2RlX2lkID0gTm9kZS5pZCB+cG9vbDp0LnBvb2wgbm9kZSB9XG4gICAgICBlbHNlXG4gICAgICAgIGxvb3AgdCBmIChOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbDp0LnBvb2wgOjogTm9kZS5jaGlsZCBub2RlIH5wb29sOnQucG9vbCA6OiByZXN0KVxuICBpblxuICBmdW4gdCB+ZiAtPiBsb29wIHQgZiBbIHQucm9vdCBdXG47O1xuXG5tb2R1bGUgVW5zYWZlID0gc3RydWN0XG4gIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIGhlYXAgPSAnYSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgTm9kZS50XG5cbiAgICBsZXQgdmFsdWUgdCBoZWFwID0gTm9kZS52YWx1ZV9leG4gfnBvb2w6aGVhcC5wb29sIHRcbiAgZW5kXG5cbiAgbGV0IGFkZF9yZW1vdmFibGUgPSBhZGRfbm9kZVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlX25vbl9lbXB0eVxuXG4gIGxldCB1cGRhdGUgdCBlbHQgdiA9XG4gICAgcmVtb3ZlIHQgZWx0O1xuICAgIGFkZF9yZW1vdmFibGUgdCB2XG4gIDs7XG5lbmRcbiJdfQ==
