// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_register_global=runtime.caml_register_global,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Timing_wheel_Import=caml_string_of_jsbytes("Timing_wheel__Import"),
     cst_timing_wheel=caml_string_of_jsbytes("timing_wheel"),
     cst_timing_wheel_src_import_ml=
      caml_string_of_jsbytes("timing_wheel/src/import.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_timing_wheel$0=caml_string_of_jsbytes("timing_wheel"),
     cst_timing_wheel$1=caml_string_of_jsbytes("timing_wheel"),
     cst_Timing_wheel_Import$0=caml_string_of_jsbytes("Timing_wheel__Import"),
     cst_Timing_wheel_Timing_wheel_=
      caml_string_of_jsbytes("Timing_wheel__Timing_wheel_intf"),
     cst_timing_wheel$2=caml_string_of_jsbytes("timing_wheel"),
     cst_timing_wheel_src_timing_wh=
      caml_string_of_jsbytes("timing_wheel/src/timing_wheel_intf.ml"),
     cst$0=caml_string_of_jsbytes(""),
     cst_timing_wheel$3=caml_string_of_jsbytes("timing_wheel"),
     cst_timing_wheel$4=caml_string_of_jsbytes("timing_wheel"),
     cst_Timing_wheel_Timing_wheel_$0=
      caml_string_of_jsbytes("Timing_wheel__Timing_wheel_intf"),
     cst_Timing_wheel_max_alarm_tim$0=
      caml_string_of_jsbytes
       ("Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel"),
     cst_Timing_wheel_max_alarm_tim=
      caml_string_of_jsbytes
       ("Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel"),
     cst_Timing_wheel_min_alarm_int=
      caml_string_of_jsbytes
       ("Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel"),
     cst_Timing_wheel_cannot_resche=
      caml_string_of_jsbytes
       ("Timing_wheel cannot reschedule alarm not in timing wheel"),
     cst_Timing_wheel_cannot_schedu$0=
      caml_string_of_jsbytes
       ("Timing_wheel cannot schedule alarm before start of current interval"),
     cst_Timing_wheel_cannot_schedu=
      caml_string_of_jsbytes
       ("Timing_wheel cannot schedule alarm that far in the future"),
     cst_Timing_wheel_create_got_st=
      caml_string_of_jsbytes("Timing_wheel.create got start before the epoch"),
     pos$9=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1631:26"),
     pos$8=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1628:26"),
     pos$7=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1644:26"),
     pos$6=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1649:26"),
     cst_Timing_wheel_interval_num_$1=
      caml_string_of_jsbytes
       ("Timing_wheel.interval_num_start got too large interval_num"),
     cst_Timing_wheel_interval_num_$0=
      caml_string_of_jsbytes
       ("Timing_wheel.interval_num_start got too small interval_num"),
     cst_Timing_wheel_interval_num_=
      caml_string_of_jsbytes
       ("Timing_wheel.interval_num got time too far in the past"),
     cst_Timing_wheel_next_alarm_fi$0=
      caml_string_of_jsbytes
       ("Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval"),
     cst_Timing_wheel_next_alarm_fi=
      caml_string_of_jsbytes
       ("Timing_wheel.next_alarm_fires_at_exn of empty timing wheel"),
     cst_Timing_wheel_add_at_interv=
      caml_string_of_jsbytes
       ("Timing_wheel.add_at_interval_num got invalid interval num"),
     cst_Priority_queue_add_elt_key$0=
      caml_string_of_jsbytes("Priority_queue.add_elt key out of level bounds"),
     arg_108=[0,caml_string_of_jsbytes("_")],
     cst_Priority_queue_add_elt_key=
      caml_string_of_jsbytes("Priority_queue.add_elt key out of bounds"),
     pos$5=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1006:32"),
     pos$4=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:1003:32"),
     pos$3=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:902:31"),
     pos$2=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:909:30"),
     pos$1=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:921:31"),
     pos$0=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:939:32"),
     pos=caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml:944:30"),
     cst_Timing_wheel_got_invalid_a=
      caml_string_of_jsbytes("Timing_wheel got invalid alarm"),
     cst_alarm_precision=caml_string_of_jsbytes("alarm_precision"),
     cst_capacity=caml_string_of_jsbytes("capacity"),
     cst_level_bits$0=caml_string_of_jsbytes("level_bits"),
     cst_alarm_precision$0=caml_string_of_jsbytes("alarm_precision"),
     cst_Alarm_precision_of_span_fl=
      caml_string_of_jsbytes
       ("[Alarm_precision.of_span_floor_pow2_ns] got non-positive span"),
     cst_Alarm_precision_to_span_of=
      caml_string_of_jsbytes
       ("[Alarm_precision.to_span] of negative power of two nanoseconds"),
     cst_Level_bits_create_exn_requ=
      caml_string_of_jsbytes("Level_bits.create_exn requires a nonempty list"),
     cst_Level_bits_create_exn_got_=
      caml_string_of_jsbytes("Level_bits.create_exn got nonpositive num bits"),
     cst_Level_bits_create_exn_got_$0=
      caml_string_of_jsbytes("Level_bits.create_exn got too many bits"),
     cst_Timing_wheel=caml_string_of_jsbytes("Timing_wheel"),
     cst_timing_wheel$5=caml_string_of_jsbytes("timing_wheel"),
     cst_timing_wheel_src_timing_wh$0=
      caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
     cst$1=caml_string_of_jsbytes(""),
     cst_timing_wheel$6=caml_string_of_jsbytes("timing_wheel"),
     cst_level_bits=caml_string_of_jsbytes("level_bits"),
     error_source_039=
      caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml.Config.t"),
     cst_slots=caml_string_of_jsbytes("slots"),
     cst_max_allowed_key=caml_string_of_jsbytes("max_allowed_key"),
     cst_min_allowed_key=caml_string_of_jsbytes("min_allowed_key"),
     cst_length=caml_string_of_jsbytes("length"),
     cst_diff_max_min_allowed_key=
      caml_string_of_jsbytes("diff_max_min_allowed_key"),
     cst_min_key_in_same_slot_mask=
      caml_string_of_jsbytes("min_key_in_same_slot_mask"),
     cst_keys_per_slot=caml_string_of_jsbytes("keys_per_slot"),
     cst_bits_per_slot=caml_string_of_jsbytes("bits_per_slot"),
     cst_slots_mask=caml_string_of_jsbytes("slots_mask"),
     cst_bits=caml_string_of_jsbytes("bits"),
     cst_index=caml_string_of_jsbytes("index"),
     cst_levels=caml_string_of_jsbytes("levels"),
     cst_elt_key_lower_bound=caml_string_of_jsbytes("elt_key_lower_bound"),
     cst_min_elt=caml_string_of_jsbytes("min_elt"),
     cst_pool=caml_string_of_jsbytes("pool"),
     cst_length$0=caml_string_of_jsbytes("length"),
     cst_priority_queue=caml_string_of_jsbytes("priority_queue"),
     cst_max_allowed_alarm_time=
      caml_string_of_jsbytes("max_allowed_alarm_time"),
     cst_now_interval_num_start=
      caml_string_of_jsbytes("now_interval_num_start"),
     cst_now=caml_string_of_jsbytes("now"),
     cst_max_interval_num=caml_string_of_jsbytes("max_interval_num"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_config=caml_string_of_jsbytes("config"),
     cst_timing_wheel$7=caml_string_of_jsbytes("timing_wheel"),
     cst_Timing_wheel$0=caml_string_of_jsbytes("Timing_wheel"),
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Core=global_data.Core,
     Core_Time_ns_alternate_sexp=global_data.Core__Time_ns_alternate_sexp,
     Assert_failure=global_data.Assert_failure,
     Ppx_assert_lib_Runtime=global_data.Ppx_assert_lib__Runtime,
     Base_Invariant=global_data.Base__Invariant,
     Core_Time_ns=global_data.Core__Time_ns,
     Core_List=global_data.Core__List;
    global_data.Base__Field;
    var
     Core_Int63=global_data.Core__Int63,
     Core_Array=global_data.Core__Array,
     Tuple_pool=global_data.Tuple_pool,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Core_Int=global_data.Core__Int,
     Core_Binable=global_data.Core__Binable,
     Base_Sexpable=global_data.Base__Sexpable,
     Timing_wheel=[0];
    caml_register_global(213,Timing_wheel,"Timing_wheel__");
    caml_call1(Ppx_module_timer_runtime[4],cst_Timing_wheel_Import);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_timing_wheel);
    caml_call1(Expect_test_collector[5][1],cst_timing_wheel_src_import_ml);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_timing_wheel$0,cst);
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_timing_wheel$1);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Timing_wheel_Import$0);
    var Timing_wheel_Import=[0];
    caml_register_global(218,Timing_wheel_Import,"Timing_wheel__Import");
    caml_call1(Ppx_module_timer_runtime[4],cst_Timing_wheel_Timing_wheel_);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_timing_wheel$2);
    caml_call1(Expect_test_collector[5][1],cst_timing_wheel_src_timing_wh);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_timing_wheel$3,cst$0);
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_timing_wheel$4);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Timing_wheel_Timing_wheel_$0);
    var Timing_wheel_Timing_wheel_intf=[0];
    caml_register_global
     (219,Timing_wheel_Timing_wheel_intf,"Timing_wheel__Timing_wheel_intf");
    caml_call1(Ppx_module_timer_runtime[4],cst_Timing_wheel);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_timing_wheel$5);
    caml_call1(Expect_test_collector[5][1],cst_timing_wheel_src_timing_wh$0);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_timing_wheel$6,cst$1);
    var
     max_time=Core_Time_ns_alternate_sexp[45],
     min_time=Core_Time_ns_alternate_sexp[43],
     zero=Core_Int[55],
     to_int=Core_Int[61],
     t_of_sexp=Core_Int[79],
     sexp_of_t=Core_Int[80],
     symbol=Core_Int[84],
     symbol$0=Core_Int[85],
     symbol$1=Core_Int[87],
     equal=Core_Int[90],
     max_num_bits=Core_Int63[58] - 1 | 0,
     _b3_=[0,caml_string_of_jsbytes("_")],
     _b4_=[0,caml_string_of_jsbytes("timing_wheel")],
     _b1_=[0,caml_string_of_jsbytes("_")],
     _b2_=[0,caml_string_of_jsbytes("timing_wheel")],
     _bZ_=[0,caml_string_of_jsbytes("_")],
     _b0_=[0,caml_string_of_jsbytes("timing_wheel")],
     _bX_=[0,caml_string_of_jsbytes("now_interval_num_start")],
     _bY_=[0,caml_string_of_jsbytes("at")],
     _bV_=[0,caml_string_of_jsbytes("max_allowed_alarm_time")],
     _bW_=[0,caml_string_of_jsbytes("at")],
     _bU_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1707,53],
     _bT_=[0,caml_string_of_jsbytes("start")],
     _bR_=[0,caml_string_of_jsbytes("_")],
     _bQ_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1654,6],
     _bP_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1658,6],
     _bO_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1662,6],
     _bN_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1624,11],
     _bM_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1625,11],
     _bL_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1636,11],
     _bK_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1637,11],
     _bJ_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),1638,11],
     _bS_=
      [0,
       caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
       1618,
       58357,
       58379],
     _bH_=[0,caml_string_of_jsbytes("t.max_interval_num")],
     _bI_=[0,caml_string_of_jsbytes("interval_num")],
     _bF_=[0,caml_string_of_jsbytes("min_interval_num")],
     _bG_=[0,caml_string_of_jsbytes("interval_num")],
     _bE_=[0,caml_string_of_jsbytes("time")],
     _bC_=[0,caml_string_of_jsbytes("_")],
     _bD_=[0,caml_string_of_jsbytes("timing_wheel")],
     _bA_=[0,caml_string_of_jsbytes("_")],
     _bB_=[0,caml_string_of_jsbytes("timing_wheel")],
     _bv_=[0,caml_string_of_jsbytes("alarms")],
     _bw_=[0,caml_string_of_jsbytes("now")],
     _bx_=[0,caml_string_of_jsbytes("max_interval_num")],
     _by_=[0,caml_string_of_jsbytes("start")],
     _bz_=[0,caml_string_of_jsbytes("config")],
     _bt_=[0,caml_string_of_jsbytes("value")],
     _bu_=[0,caml_string_of_jsbytes("at")],
     _bb_=[0,caml_string_of_jsbytes("max_allowed_alarm_interval_num")],
     _bc_=[0,caml_string_of_jsbytes("min_allowed_alarm_interval_num")],
     _bd_=[0,caml_string_of_jsbytes("interval_num")],
     _a__=[0,caml_string_of_jsbytes("_")],
     _a$_=[0,caml_string_of_jsbytes("level")],
     _ba_=[0,caml_string_of_jsbytes("key")],
     _a6_=[0,caml_string_of_jsbytes("priority_queue")],
     _a7_=[0,caml_string_of_jsbytes("max_allowed_key t")],
     _a8_=[0,caml_string_of_jsbytes("min_allowed_key t")],
     _a9_=[0,caml_string_of_jsbytes("key")],
     _a4_=[0,caml_string_of_jsbytes("_")],
     _a1_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),977,38],
     _a0_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),983,15],
     _aZ_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),984,15],
     _aY_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),987,13],
     _aX_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),988,13],
     _aW_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),991,15],
     _aU_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),997,15],
     _aV_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),995,13],
     _a3_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),974,6],
     _a2_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),975,6],
     _aS_=[0,caml_string_of_jsbytes("_")],
     _aR_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),898,38],
     _aQ_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),899,36],
     _aP_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),906,15],
     _aO_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),914,15],
     _aN_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),928,15],
     _aM_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),936,15],
     _aL_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),957,21],
     _aK_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),961,21],
     _aJ_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),965,21],
     _aI_=
      [0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),969,21],
     _aT_=
      [0,
       caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
       895,
       31577,
       31603],
     _a5_=
      [0,
       caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
       972,
       34918,
       34942],
     _aF_=[0,caml_string_of_jsbytes("elts")],
     _aG_=[0,caml_string_of_jsbytes("max_allowed_key")],
     _aH_=[0,caml_string_of_jsbytes("min_allowed_key")],
     _aD_=[0,caml_string_of_jsbytes("value")],
     _aE_=[0,caml_string_of_jsbytes("key")],
     _ay_=[0,caml_string_of_jsbytes("levels")],
     _az_=[0,caml_string_of_jsbytes("elt_key_lower_bound")],
     _aA_=[0,caml_string_of_jsbytes("min_elt")],
     _aB_=[0,caml_string_of_jsbytes("pool")],
     _aC_=[0,caml_string_of_jsbytes("length")],
     _ad_=[0,caml_string_of_jsbytes("slots")],
     _ae_=[0,caml_string_of_jsbytes("max_allowed_key")],
     _af_=[0,caml_string_of_jsbytes("min_allowed_key")],
     _ag_=[0,caml_string_of_jsbytes("length")],
     _ah_=[0,caml_string_of_jsbytes("diff_max_min_allowed_key")],
     _ai_=[0,caml_string_of_jsbytes("min_key_in_same_slot_mask")],
     _aj_=[0,caml_string_of_jsbytes("keys_per_slot")],
     _ak_=[0,caml_string_of_jsbytes("bits_per_slot")],
     _al_=[0,caml_string_of_jsbytes("slots_mask")],
     _am_=[0,caml_string_of_jsbytes("bits")],
     _an_=[0,caml_string_of_jsbytes("index")],
     _H_=[0,caml_string_of_jsbytes("_")],
     _G_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),648,8],
     _F_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),651,8],
     _E_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),653,8],
     _I_=
      [0,
       caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
       647,
       23049,
       23075],
     _u_=[0,10,[0,10,[0,6,[0,6,[0,5,0]]]]],
     _s_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),257,6],
     _t_=
      [0,
       caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),
       256,
       8261,
       8285],
     _p_=[0,caml_string_of_jsbytes("capacity")],
     _q_=[0,caml_string_of_jsbytes("level_bits")],
     _r_=[0,caml_string_of_jsbytes("alarm_precision")],
     _o_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),235,2],
     _h_=[0,caml_string_of_jsbytes("span")],
     _e_=[0,caml_string_of_jsbytes("max_num_bits")],
     _f_=[0,caml_string_of_jsbytes("got")],
     _d_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),117,6],
     _c_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),114,4],
     _b_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),82,4],
     _a_=[0,caml_string_of_jsbytes("timing_wheel/src/timing_wheel.ml"),83,4],
     _g_=[0,11,[0,10,[0,10,[0,10,[0,10,[0,10,[0,1,0]]]]]]],
     min_value=0;
    function invariant(t)
     {if(! caml_call2(symbol,t,min_value))throw [0,Assert_failure,_b_];
      if(caml_call2(symbol$0,t,max_num_bits))return 0;
      throw [0,Assert_failure,_a_]}
    function of_int(i){invariant(i);return i}
    function symbol$2(t1,t2){var t=t1 + t2 | 0;invariant(t);return t}
    function symbol$3(t1,t2){var t=t1 - t2 | 0;invariant(t);return t}
    function pow2(t){return caml_call2(Core_Int63[47],Core_Int63[14],t)}
    function sexp_of_t$0(x_007){return caml_call2(Core[421],sexp_of_t,x_007)}
    function num_bits_internal(t)
     {return caml_call3(Core_List[10],t,zero,symbol$2)}
    function num_bits(t){return num_bits_internal(t)}
    function f(t)
     {if(caml_call1(Core_List[8],t))throw [0,Assert_failure,_c_];
      function _fM_(num_key_bits)
       {invariant(num_key_bits);
        if(caml_call2(symbol$1,num_key_bits,zero))return 0;
        throw [0,Assert_failure,_d_]}
      caml_call2(Core_List[9],t,_fM_);
      return invariant(num_bits_internal(t))}
    function t_of_sexp$0(sexp)
     {var t=caml_call2(Core[422],t_of_sexp,sexp);f(t);return t}
    function create_exn(opt,ints)
     {if(opt)
       var sth=opt[1],extend_to_max_num_bits=sth;
      else
       var extend_to_max_num_bits=0;
      if(caml_call1(Core_List[8],ints))
       caml_call1(Core[6],cst_Level_bits_create_exn_requ);
      function _fA_(bits){return caml_call2(Core[89],bits,0)}
      if(caml_call2(Core_List[13],ints,_fA_))
       {var
         _fB_=[0,caml_call2(Core[421],Core[356],ints),0],
         _fC_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Level_bits_create_exn_got_),
            _fB_]];
        caml_call1(Core[253],_fC_)}
      function _fD_(_fL_,_fK_){return _fL_ + _fK_ | 0}
      var num_bits=caml_call3(Core_List[10],ints,0,_fD_);
      if(caml_call2(Core[91],num_bits,max_num_bits))
       {var
         _fE_=[0,[1,[0,_e_,[0,caml_call1(Core[356],max_num_bits),0]]],0],
         _fF_=[0,[1,[0,_f_,[0,caml_call1(Core[356],num_bits),0]]],_fE_],
         _fG_=[0,caml_call2(Core[421],Core[356],ints),_fF_],
         _fH_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Level_bits_create_exn_got_$0),
            _fG_]];
        caml_call1(Core[253],_fH_)}
      if(extend_to_max_num_bits)
       var
        _fI_=caml_call1(Core[230],1),
        _fJ_=caml_call2(Core_List[119],max_num_bits - num_bits | 0,_fI_),
        ints$0=caml_call2(Core[157],ints,_fJ_);
      else
       var ints$0=ints;
      return caml_call2(Core_List[72],ints$0,of_int)}
    var level_bits_default=create_exn(0,_g_),compare=Core[352];
    function equal$0(x_012,x_013)
     {var match=caml_call2(compare,x_012,x_013);return 0 === match?1:0}
    function num_key_bits(t){return of_int(t)}
    function to_sexpable(t)
     {if(caml_call2(Core[92],t,0))
       {var
         _fx_=[0,caml_call1(Core[356],t),0],
         _fy_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Alarm_precision_to_span_of),
            _fx_]];
        caml_call1(Core[253],_fy_)}
      var _fz_=caml_call1(caml_call1(Core_Int63[47],Core_Int63[14]),t);
      return caml_call1(Core_Time_ns[1][127],_fz_)}
    function sexp_of_t$1(t)
     {var _fw_=to_sexpable(t);return caml_call1(Core_Time_ns[1][10],_fw_)}
    var
     one_nanosecond=0,
     about_one_microsecond=10,
     about_one_millisecond=20,
     about_one_second=30,
     about_one_day=46;
    function mul(t,pow2){return t + pow2 | 0}
    function div(t,pow2){return t - pow2 | 0}
    function of_sexpable(span)
     {if(caml_call2(Core_Time_ns[1][16],span,Core_Time_ns[1][75]))
       {var
         _ft_=[0,[1,[0,_h_,[0,caml_call1(Core_Time_ns[1][10],span),0]]],0],
         _fu_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Alarm_precision_of_span_fl),
            _ft_]];
        caml_call1(Core[253],_fu_)}
      var _fv_=caml_call1(Core_Time_ns[1][126],span);
      return caml_call1(Core_Int63[86],_fv_)}
    var
     _i_=Core_Time_ns[1],
     _j_=
      caml_call1
       (caml_call1(Core_Binable[6],[0,_i_[5],_i_[1],_i_[2],_i_[3],_i_[4]]),
        [0,to_sexpable,of_sexpable]),
     bin_size_t=_j_[1],
     bin_write_t=_j_[2],
     bin_read_t=_j_[3],
     bin_read_t$0=_j_[4],
     bin_shape_t=_j_[5],
     bin_writer_t=_j_[6],
     bin_reader_t=_j_[7],
     bin_t=_j_[8],
     _k_=Core_Time_ns[1],
     include=
      caml_call1
       (caml_call1(Base_Sexpable[1],[0,_k_[9],_k_[10]]),
        [0,to_sexpable,of_sexpable]),
     t_of_sexp$1=include[1],
     sexp_of_t$2=include[2],
     _l_=
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
    function level_bits(r){return r[2]}
    function _m_(r,v){return [0,r[1],v,r[3]]}
    var
     _n_=0,
     level_bits$0=
      [0,function(param){return 0},cst_level_bits,_n_,level_bits,_m_];
    function t_of_sexp$2(sexp_019)
     {if(0 === sexp_019[0])
       return caml_call2
               (Sexplib0_Sexp_conv_error[16],error_source_039,sexp_019);
      var
       field_sexps_020=sexp_019[1],
       alarm_precision_021=[0,0],
       level_bits_023=[0,0],
       capacity_025=[0,0],
       duplicates_027=[0,0],
       extra_028=[0,0],
       param=field_sexps_020;
      for(;;)
       {if(param)
         {var _fk_=param[1];
          if(1 === _fk_[0])
           {var _fl_=_fk_[1];
            if(_fl_)
             {var _fm_=_fl_[1];
              if(0 === _fm_[0])
               {var _fn_=_fl_[2],_fo_=_fm_[1],switch$0=0;
                if(! _fn_ || ! _fn_[2])switch$0 = 1;
                if(switch$0)
                 {var
                   tail_041=param[2],
                   field_sexp_030$3=
                    function(_fs_)
                     {function field_sexp_030(param)
                       {if(! _fs_)
                         return caml_call2
                                 (Sexplib0_Sexp_conv_error[10],error_source_039,sexp_019);
                        if(_fs_[2])throw [0,Assert_failure,_o_];
                        var x_042=_fs_[1];
                        return x_042}
                      return field_sexp_030},
                   field_sexp_030=field_sexp_030$3(_fn_);
                  if(caml_string_notequal(_fo_,cst_alarm_precision))
                   if(caml_string_notequal(_fo_,cst_capacity))
                    if(caml_string_notequal(_fo_,cst_level_bits$0))
                     {if(Sexplib0_Sexp_conv[26][1])
                       extra_028[1] = [0,_fo_,extra_028[1]]}
                    else
                     if(level_bits_023[1])
                      duplicates_027[1] = [0,_fo_,duplicates_027[1]];
                     else
                      {var
                        field_sexp_030$0=field_sexp_030(0),
                        fvalue_034=t_of_sexp$0(field_sexp_030$0);
                       level_bits_023[1] = [0,fvalue_034]}
                   else
                    if(capacity_025[1])
                     duplicates_027[1] = [0,_fo_,duplicates_027[1]];
                    else
                     {var
                       field_sexp_030$1=field_sexp_030(0),
                       fvalue_032=caml_call1(Core[357],field_sexp_030$1);
                      capacity_025[1] = [0,fvalue_032]}
                  else
                   if(alarm_precision_021[1])
                    duplicates_027[1] = [0,_fo_,duplicates_027[1]];
                   else
                    {var
                      field_sexp_030$2=field_sexp_030(0),
                      fvalue_035=caml_call1(_l_[10],field_sexp_030$2);
                     alarm_precision_021[1] = [0,fvalue_035]}
                  var param=tail_041;
                  continue}}}}
          caml_call2(Sexplib0_Sexp_conv_error[10],error_source_039,_fk_)}
        if(duplicates_027[1])
         return caml_call3
                 (Sexplib0_Sexp_conv_error[12],
                  error_source_039,
                  duplicates_027[1],
                  sexp_019);
        if(extra_028[1])
         return caml_call3
                 (Sexplib0_Sexp_conv_error[13],
                  error_source_039,
                  extra_028[1],
                  sexp_019);
        var
         _fp_=alarm_precision_021[1],
         _fq_=level_bits_023[1],
         _fr_=capacity_025[1];
        if(! _fp_)
         return caml_call3
                 (Sexplib0_Sexp_conv_error[15],
                  error_source_039,
                  sexp_019,
                  [0,
                   [0,0 === alarm_precision_021[1]?1:0,cst_alarm_precision$0],
                   0]);
        var alarm_precision_022=_fp_[1];
        if(_fq_)
         var v_038=_fq_[1],v_038$0=v_038;
        else
         var v_038$0=level_bits_default;
        return [0,alarm_precision_022,v_038$0,_fr_]}}
    function sexp_of_t$3(param)
     {var
       capacity_048=param[3],
       level_bits_046=param[2],
       alarm_precision_044=param[1],
       bnds_043=0;
      if(capacity_048)
       var
        v_049=capacity_048[1],
        arg_051=caml_call1(Core[356],v_049),
        bnd_050=[1,[0,_p_,[0,arg_051,0]]],
        bnds_043$0=[0,bnd_050,bnds_043];
      else
       var bnds_043$0=bnds_043;
      var
       arg_047=sexp_of_t$0(level_bits_046),
       bnds_043$1=[0,[1,[0,_q_,[0,arg_047,0]]],bnds_043$0],
       arg_045=caml_call1(_l_[11],alarm_precision_044),
       bnds_043$2=[0,[1,[0,_r_,[0,arg_045,0]]],bnds_043$1];
      return [1,bnds_043$2]}
    function alarm_precision(t){return to_sexpable(t[1])}
    function max_num_level_bits(alarm_precision)
     {return symbol$3(max_num_bits,num_key_bits(alarm_precision))}
    function invariant$0(t)
     {function _fi_(param)
       {var _fj_=max_num_level_bits(t[1]);
        if(! caml_call2(symbol$0,num_bits_internal(t[2]),_fj_))
         throw [0,Assert_failure,_s_];
        var level_bits_fun=caml_call2(Base_Invariant[2],t,f);
        caml_call1(level_bits_fun,level_bits$0);
        return 0}
      return caml_call4(Base_Invariant[1],_t_,t,sexp_of_t$3,_fi_)}
    function create(capacity,opt,alarm_precision,param)
     {if(opt)
       var sth=opt[1],level_bits=sth;
      else
       var level_bits=level_bits_default;
      var max_num_bits=max_num_level_bits(alarm_precision);
      if(caml_call2(symbol$0,num_bits_internal(level_bits),max_num_bits))
       var level_bits$0=level_bits;
      else
       var
        loop=
         function(t,remaining)
          {if(! t)return 0;
           var t$0=t[2],b=t[1];
           return caml_call2(symbol,b,remaining)
                   ?[0,remaining,0]
                   :[0,b,loop(t$0,symbol$3(remaining,b))]},
        level_bits$0=loop(level_bits,max_num_bits);
      return [0,alarm_precision,level_bits$0,capacity]}
    function microsecond_precision(param)
     {return create(0,[0,create_exn(0,_u_)],about_one_microsecond,0)}
    function durations(t)
     {function _ff_(num_bits_accum,level_num_bits)
       {var
         num_bits_accum$0=
          num_bits_accum
          +
          caml_call1(to_int,level_num_bits)
          |
          0,
         _fh_=
          caml_call2(Core[90],num_bits_accum$0,Core_Int63[58] - 1 | 0)
           ?Core_Int63[59]
           :caml_call2(Core_Int63[47],Core_Int63[14],num_bits_accum$0),
         duration=caml_call1(Core_Time_ns[1][127],_fh_);
        return [0,num_bits_accum$0,duration]}
      var _fg_=caml_call1(to_int,num_key_bits(t[1]));
      return caml_call3(Core_List[73],t[2],_fg_,_ff_)}
    var compare$0=Core_Int63[110],sexpifier=Core_Int63[99];
    function create$0(level_bits)
     {var _fd_=Core_Int63[14],_fe_=pow2(level_bits);
      return caml_call2(Core_Int63[17],_fe_,_fd_)}
    function num_keys(num_bits){return pow2(num_bits)}
    var
     one=Core_Int63[14],
     symbol$4=Core_Int63[17],
     bit_not=Core_Int63[45],
     sexp_of_t$4=Core_Int63[99],
     equal$1=Core_Int63[109];
    function create$1(bits_per_slot)
     {return caml_call1(bit_not,caml_call2(symbol$4,pow2(bits_per_slot),one))}
    var
     to_int_exn=Core_Int63[5],
     zero$0=Core_Int63[13],
     one$0=Core_Int63[14],
     symbol$5=Core_Int63[16],
     symbol$6=Core_Int63[18],
     succ=Core_Int63[39],
     pred=Core_Int63[40],
     max_value=Core_Int63[59],
     of_int$0=Core_Int63[69],
     sexp_of_t$5=Core_Int63[99],
     symbol$7=Core_Int63[103],
     symbol$8=Core_Int63[104],
     symbol$9=Core_Int63[105],
     symbol$10=Core_Int63[106],
     symbol$11=Core_Int63[107],
     symbol$12=Core_Int63[108],
     equal$2=Core_Int63[109],
     compare$1=Core_Int63[110],
     min=Core_Int63[111],
     max=Core_Int63[112],
     ascending=Core_Int63[113],
     descending=Core_Int63[114],
     between=Core_Int63[115],
     clamp_exn=Core_Int63[116],
     clamp=Core_Int63[117],
     Replace_polymorphic_compare=Core_Int63[118],
     comparator=Core_Int63[119],
     Map=Core_Int63[120],
     Set=Core_Int63[121],
     validate_lbound=Core_Int63[128],
     validate_ubound=Core_Int63[129],
     validate_bound=Core_Int63[130];
    function to_int63(t){return t}
    function of_int63(i){return i}
    function scale_int(t,i)
     {return caml_call2(symbol$6,t,caml_call1(of_int$0,i))}
    var
     to_int_exn$0=Core_Int63[5],
     zero$1=Core_Int63[13],
     one$1=Core_Int63[14],
     symbol$13=Core_Int63[16],
     symbol$14=Core_Int63[17],
     rem=Core_Int63[25],
     succ$0=Core_Int63[39],
     pred$0=Core_Int63[40],
     bit_and=Core_Int63[42],
     shift_right=Core_Int63[48],
     max_value$0=Core_Int63[59],
     min_value$0=Core_Int63[60],
     of_int$1=Core_Int63[69],
     sexpifier$0=Core_Int63[99],
     symbol$15=Core_Int63[103],
     symbol$16=Core_Int63[104],
     symbol$17=Core_Int63[105],
     symbol$18=Core_Int63[106],
     symbol$19=Core_Int63[107],
     symbol$20=Core_Int63[108],
     equal$3=Core_Int63[109],
     compare$2=Core_Int63[110],
     min$0=Core_Int63[111],
     max$0=Core_Int63[112],
     ascending$0=Core_Int63[113],
     descending$0=Core_Int63[114],
     between$0=Core_Int63[115],
     clamp_exn$0=Core_Int63[116],
     clamp$0=Core_Int63[117],
     Replace_polymorphic_compare$0=Core_Int63[118],
     comparator$0=Core_Int63[119],
     Map$0=Core_Int63[120],
     Set$0=Core_Int63[121],
     hash_fold_t=Core_Int63[122],
     hash=Core_Int63[123],
     hashable=Core_Int63[124],
     Table=Core_Int63[125],
     Hash_set=Core_Int63[126],
     Hash_queue=Core_Int63[127],
     validate_lbound$0=Core_Int63[128],
     validate_ubound$0=Core_Int63[129],
     validate_bound$0=Core_Int63[130];
    function of_int63$0(i){return i}
    function to_int63$0(t){return t}
    function add(t,i){return caml_call2(symbol$13,t,i)}
    function add_clamp_to_max(t,i)
     {return caml_call2(symbol$18,t,caml_call2(symbol$14,max_value$0,i))
              ?max_value$0
              :caml_call2(symbol$13,t,i)}
    function sub(t,i){return caml_call2(symbol$14,t,i)}
    function diff(t1,t2){return caml_call2(symbol$14,t1,t2)}
    function min_key_in_same_slot(t,min_key_in_same_slot_mask)
     {return caml_call2(bit_and,t,min_key_in_same_slot_mask)}
    var
     _x_=Set$0[1],
     _z_=Map$0[1],
     _B_=Set[1],
     _C_=Map[1],
     _D_=
      [0,
       sexp_of_t$5,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0,_C_[9],_C_[10],_C_[11]],
        Map[2],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45],
        Map[46],
        Map[47],
        Map[48],
        Map[49],
        Map[50],
        Map[51],
        Map[52],
        Map[53],
        Map[54],
        Map[55],
        Map[56],
        Map[57],
        Map[58],
        Map[59],
        Map[60],
        Map[61],
        Map[62],
        Map[63],
        Map[64],
        Map[65],
        Map[66],
        Map[67],
        Map[68],
        Map[69],
        Map[70],
        Map[71],
        Map[72],
        Map[73],
        Map[74],
        Map[75],
        Map[76],
        Map[77],
        Map[78],
        Map[79],
        Map[80],
        Map[81],
        Map[82],
        Map[83],
        Map[84],
        Map[85],
        Map[86],
        Map[87],
        Map[88],
        Map[89],
        Map[90],
        Map[91],
        Map[92],
        Map[93],
        Map[94],
        Map[95],
        Map[96],
        Map[97],
        Map[98],
        Map[99],
        Map[100],
        Map[101],
        Map[102],
        Map[103],
        Map[104],
        Map[105],
        Map[106],
        Map[107]],
       [0,
        [0,_B_[1],_B_[2],_B_[11]],
        Set[2],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28],
        Set[29],
        Set[30],
        Set[31],
        Set[32],
        Set[33],
        Set[34],
        Set[35],
        Set[36],
        Set[37],
        Set[38],
        Set[39],
        Set[40],
        Set[41],
        Set[42],
        Set[43],
        Set[44],
        Set[45],
        Set[46],
        Set[47],
        Set[48],
        Set[49],
        Set[50],
        Set[51],
        Set[52],
        Set[53],
        Set[54],
        Set[55],
        Set[56],
        Set[57],
        Set[58],
        Set[59],
        Set[60],
        Set[61],
        Set[62],
        Set[63],
        Set[64],
        Set[65],
        Set[66],
        Set[67],
        Set[68],
        Set[69],
        Set[70],
        Set[71],
        Set[72],
        Set[73],
        Set[74],
        Set[75]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5],
     _v_=
      [0,
       Hash_set[1],
       Hash_set[2],
       Hash_set[3],
       Hash_set[4],
       Hash_set[5],
       Hash_set[6],
       Hash_set[7]],
     _w_=
      [0,
       Table[1],
       Table[2],
       Table[3],
       Table[4],
       Table[5],
       Table[6],
       Table[7],
       Table[8],
       Table[9],
       Table[10],
       Table[11],
       Table[12],
       Table[13],
       Table[14],
       Table[15],
       Table[16],
       Table[17],
       Table[18],
       Table[19],
       Table[20],
       Table[21],
       Table[22],
       Table[23],
       Table[24],
       Table[25],
       Table[26],
       Table[27],
       Table[28],
       Table[29],
       Table[30],
       Table[31],
       Table[32],
       Table[33],
       Table[34],
       Table[35],
       Table[36],
       Table[37],
       Table[38],
       Table[39],
       Table[40],
       Table[41],
       Table[42],
       Table[43],
       Table[44],
       Table[45],
       Table[46],
       Table[47],
       Table[48],
       Table[49],
       Table[50],
       Table[51],
       Table[52],
       Table[53],
       Table[54],
       Table[55],
       Table[56],
       Table[57],
       Table[58],
       Table[59],
       Table[60],
       Table[61],
       Table[62],
       Table[63],
       Table[64],
       Table[65],
       Table[66],
       Table[67],
       Table[68],
       Table[69],
       Table[70],
       Table[71],
       Table[72],
       Table[73],
       Table[74],
       Table[75],
       Table[76],
       Table[77],
       Table[78],
       Table[79],
       Table[80],
       Table[81],
       Table[82],
       Table[83],
       Table[84]],
     _y_=
      [0,
       [0,_x_[1],_x_[2],_x_[11]],
       Set$0[2],
       Set$0[3],
       Set$0[4],
       Set$0[5],
       Set$0[6],
       Set$0[7],
       Set$0[8],
       Set$0[9],
       Set$0[10],
       Set$0[11],
       Set$0[12],
       Set$0[13],
       Set$0[14],
       Set$0[15],
       Set$0[16],
       Set$0[17],
       Set$0[18],
       Set$0[19],
       Set$0[20],
       Set$0[21],
       Set$0[22],
       Set$0[23],
       Set$0[24],
       Set$0[25],
       Set$0[26],
       Set$0[27],
       Set$0[28],
       Set$0[29],
       Set$0[30],
       Set$0[31],
       Set$0[32],
       Set$0[33],
       Set$0[34],
       Set$0[35],
       Set$0[36],
       Set$0[37],
       Set$0[38],
       Set$0[39],
       Set$0[40],
       Set$0[41],
       Set$0[42],
       Set$0[43],
       Set$0[44],
       Set$0[45],
       Set$0[46],
       Set$0[47],
       Set$0[48],
       Set$0[49],
       Set$0[50],
       Set$0[51],
       Set$0[52],
       Set$0[53],
       Set$0[54],
       Set$0[55],
       Set$0[56],
       Set$0[57],
       Set$0[58],
       Set$0[59],
       Set$0[60],
       Set$0[61],
       Set$0[62],
       Set$0[63],
       Set$0[64],
       Set$0[65],
       Set$0[66],
       Set$0[67],
       Set$0[68],
       Set$0[69],
       Set$0[70],
       Set$0[71],
       Set$0[72],
       Set$0[73],
       Set$0[74],
       Set$0[75]],
     _A_=
      [0,
       [0,_z_[9],_z_[10],_z_[11]],
       Map$0[2],
       Map$0[3],
       Map$0[4],
       Map$0[5],
       Map$0[6],
       Map$0[7],
       Map$0[8],
       Map$0[9],
       Map$0[10],
       Map$0[11],
       Map$0[12],
       Map$0[13],
       Map$0[14],
       Map$0[15],
       Map$0[16],
       Map$0[17],
       Map$0[18],
       Map$0[19],
       Map$0[20],
       Map$0[21],
       Map$0[22],
       Map$0[23],
       Map$0[24],
       Map$0[25],
       Map$0[26],
       Map$0[27],
       Map$0[28],
       Map$0[29],
       Map$0[30],
       Map$0[31],
       Map$0[32],
       Map$0[33],
       Map$0[34],
       Map$0[35],
       Map$0[36],
       Map$0[37],
       Map$0[38],
       Map$0[39],
       Map$0[40],
       Map$0[41],
       Map$0[42],
       Map$0[43],
       Map$0[44],
       Map$0[45],
       Map$0[46],
       Map$0[47],
       Map$0[48],
       Map$0[49],
       Map$0[50],
       Map$0[51],
       Map$0[52],
       Map$0[53],
       Map$0[54],
       Map$0[55],
       Map$0[56],
       Map$0[57],
       Map$0[58],
       Map$0[59],
       Map$0[60],
       Map$0[61],
       Map$0[62],
       Map$0[63],
       Map$0[64],
       Map$0[65],
       Map$0[66],
       Map$0[67],
       Map$0[68],
       Map$0[69],
       Map$0[70],
       Map$0[71],
       Map$0[72],
       Map$0[73],
       Map$0[74],
       Map$0[75],
       Map$0[76],
       Map$0[77],
       Map$0[78],
       Map$0[79],
       Map$0[80],
       Map$0[81],
       Map$0[82],
       Map$0[83],
       Map$0[84],
       Map$0[85],
       Map$0[86],
       Map$0[87],
       Map$0[88],
       Map$0[89],
       Map$0[90],
       Map$0[91],
       Map$0[92],
       Map$0[93],
       Map$0[94],
       Map$0[95],
       Map$0[96],
       Map$0[97],
       Map$0[98],
       Map$0[99],
       Map$0[100],
       Map$0[101],
       Map$0[102],
       Map$0[103],
       Map$0[104],
       Map$0[105],
       Map$0[106],
       Map$0[107]];
    function sexp_of_pool_slots(of_a_054,x_055)
     {function _e9_(_fc_){return sexp_of_pool_slots(of_a_054,_fc_)}
      var _e__=caml_call1(Tuple_pool[36][3][1],_e9_);
      function _e$_(_fb_){return sexp_of_pool_slots(of_a_054,_fb_)}
      var _fa_=caml_call1(Tuple_pool[36][3][1],_e$_);
      return caml_call7
              (Tuple_pool[36][1][8],
               sexpifier$0,
               Core_Time_ns_alternate_sexp[92],
               of_a_054,
               Core[356],
               _fa_,
               _e__,
               x_055)}
    function sexp_of_t$6(of_a_056,x_057)
     {function _e7_(_e8_){return sexp_of_pool_slots(of_a_056,_e8_)}
      return caml_call2(Tuple_pool[36][3][1],_e7_,x_057)}
    var
     null$0=Tuple_pool[36][3][4],
     null$1=Tuple_pool[36][3][4],
     is_null=Tuple_pool[36][3][5],
     free=Tuple_pool[36][14];
    function key(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][3])}
    function at(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][4])}
    function value(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][5])}
    function level_index(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][6])}
    function prev(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][7])}
    function set_prev(p,t,x)
     {return caml_call4(Tuple_pool[36][33],p,t,Tuple_pool[36][2][7],x)}
    function next(p,t)
     {return caml_call3(Tuple_pool[36][31],p,t,Tuple_pool[36][2][8])}
    function set_next(p,t,x)
     {return caml_call4(Tuple_pool[36][33],p,t,Tuple_pool[36][2][8],x)}
    function is_valid(p,t){return caml_call2(Tuple_pool[36][6],p,t)}
    var grow=Tuple_pool[36][12],is_full=Tuple_pool[36][13];
    function of_external_exn(pool,t)
     {if(is_valid(pool,t))return t;
      var
       _e6_=
        caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_got_invalid_a);
      return caml_call1(Core[253],_e6_)}
    function link(pool,prev,next)
     {set_next(pool,prev,next);return set_prev(pool,next,prev)}
    function iter(pool,first,f)
     {var current=[0,first],continue$0=[0,1];
      for(;;)
       {if(! continue$0[1])return 0;
        var next$0=next(pool,current[1]);
        caml_call1(f,current[1]);
        if(caml_call2(Core[246],next$0,first))
         continue$0[1] = 0;
        else
         current[1] = next$0}}
    function slots(r){return r[11]}
    function max_allowed_key(r){return r[10]}
    function set_max_allowed_key(r,v){r[10] = v;return 0}
    function min_allowed_key(r){return r[9]}
    function set_min_allowed_key(r,v){r[9] = v;return 0}
    function length(r){return r[8]}
    function set_length(r,v){r[8] = v;return 0}
    function diff_max_min_allowed_key(r){return r[7]}
    function min_key_in_same_slot_mask(r){return r[6]}
    function keys_per_slot(r){return r[5]}
    function bits_per_slot(r){return r[4]}
    function slots_mask(r){return r[3]}
    function bits(r){return r[2]}
    function index(r){return r[1]}
    function _J_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],v]}
    var _K_=0,slots$0=[0,function(param){return 0},cst_slots,_K_,slots,_J_];
    function _L_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],v,r[11]]}
    var
     _M_=[0,set_max_allowed_key],
     max_allowed_key$0=
      [0,
       function(param){return 0},
       cst_max_allowed_key,
       _M_,
       max_allowed_key,
       _L_];
    function _N_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],v,r[10],r[11]]}
    var
     _O_=[0,set_min_allowed_key],
     min_allowed_key$0=
      [0,
       function(param){return 0},
       cst_min_allowed_key,
       _O_,
       min_allowed_key,
       _N_];
    function _P_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],r[6],r[7],v,r[9],r[10],r[11]]}
    var
     _Q_=[0,set_length],
     length$0=[0,function(param){return 0},cst_length,_Q_,length,_P_];
    function _R_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],r[6],v,r[8],r[9],r[10],r[11]]}
    var
     _S_=0,
     diff_max_min_allowed_key$0=
      [0,
       function(param){return 0},
       cst_diff_max_min_allowed_key,
       _S_,
       diff_max_min_allowed_key,
       _R_];
    function _T_(r,v)
     {return [0,r[1],r[2],r[3],r[4],r[5],v,r[7],r[8],r[9],r[10],r[11]]}
    var
     _U_=0,
     min_key_in_same_slot_mask$0=
      [0,
       function(param){return 0},
       cst_min_key_in_same_slot_mask,
       _U_,
       min_key_in_same_slot_mask,
       _T_];
    function _V_(r,v)
     {return [0,r[1],r[2],r[3],r[4],v,r[6],r[7],r[8],r[9],r[10],r[11]]}
    var
     _W_=0,
     keys_per_slot$0=
      [0,function(param){return 0},cst_keys_per_slot,_W_,keys_per_slot,_V_];
    function _X_(r,v)
     {return [0,r[1],r[2],r[3],v,r[5],r[6],r[7],r[8],r[9],r[10],r[11]]}
    var
     _Y_=0,
     bits_per_slot$0=
      [0,function(param){return 0},cst_bits_per_slot,_Y_,bits_per_slot,_X_];
    function _Z_(r,v)
     {return [0,r[1],r[2],v,r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11]]}
    var
     ___=0,
     slots_mask$0=
      [0,function(param){return 0},cst_slots_mask,___,slots_mask,_Z_];
    function _$_(r,v)
     {return [0,r[1],v,r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11]]}
    var _aa_=0,bits$0=[0,function(param){return 0},cst_bits,_aa_,bits,_$_];
    function _ab_(r,v)
     {return [0,v,r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11]]}
    var
     _ac_=0,
     index$0=[0,function(param){return 0},cst_index,_ac_,index,_ab_];
    function sexp_of_t$7(of_a_065,param)
     {var
       diff_max_min_allowed_key_079=param[7],
       min_key_in_same_slot_mask_077=param[6],
       keys_per_slot_075=param[5],
       bits_per_slot_073=param[4],
       slots_mask_071=param[3],
       bits_069=param[2],
       index_067=param[1],
       length_081=param[8],
       min_allowed_key_083=param[9],
       max_allowed_key_085=param[10],
       slots_087=param[11],
       arg_088=caml_call1(Sexplib0_Sexp_conv[23],slots_087),
       bnds_066=[0,[1,[0,_ad_,[0,arg_088,0]]],0],
       arg_086=caml_call1(sexpifier$0,max_allowed_key_085),
       bnds_066$0=[0,[1,[0,_ae_,[0,arg_086,0]]],bnds_066],
       arg_084=caml_call1(sexpifier$0,min_allowed_key_083),
       bnds_066$1=[0,[1,[0,_af_,[0,arg_084,0]]],bnds_066$0],
       arg_082=caml_call1(Core[356],length_081),
       bnds_066$2=[0,[1,[0,_ag_,[0,arg_082,0]]],bnds_066$1],
       arg_080=caml_call1(_D_[1],diff_max_min_allowed_key_079),
       bnds_066$3=[0,[1,[0,_ah_,[0,arg_080,0]]],bnds_066$2],
       arg_078=caml_call1(sexp_of_t$4,min_key_in_same_slot_mask_077),
       bnds_066$4=[0,[1,[0,_ai_,[0,arg_078,0]]],bnds_066$3],
       arg_076=caml_call1(_D_[1],keys_per_slot_075),
       bnds_066$5=[0,[1,[0,_aj_,[0,arg_076,0]]],bnds_066$4],
       arg_074=caml_call1(sexp_of_t,bits_per_slot_073),
       bnds_066$6=[0,[1,[0,_ak_,[0,arg_074,0]]],bnds_066$5],
       arg_072=caml_call1(sexpifier,slots_mask_071),
       bnds_066$7=[0,[1,[0,_al_,[0,arg_072,0]]],bnds_066$6],
       arg_070=caml_call1(sexp_of_t,bits_069),
       bnds_066$8=[0,[1,[0,_am_,[0,arg_070,0]]],bnds_066$7],
       arg_068=caml_call1(Core[356],index_067),
       bnds_066$9=[0,[1,[0,_an_,[0,arg_068,0]]],bnds_066$8];
      return [1,bnds_066$9]}
    function slot(t,key)
     {var _e5_=t[3];
      return caml_call1
              (to_int_exn$0,
               caml_call2(bit_and,caml_call2(shift_right,key,t[4]),_e5_))}
    function next_slot(t,slot)
     {return (slot + 1 | 0) & caml_call1(Core_Int63[5],t[3])}
    function min_key_in_same_slot$0(t,key)
     {return min_key_in_same_slot(key,t[6])}
    function compute_min_allowed_key(t,prev_level_max_allowed_key)
     {return caml_call2(equal$3,prev_level_max_allowed_key,max_value$0)
              ?max_value$0
              :min_key_in_same_slot$0
                (t,caml_call1(succ$0,prev_level_max_allowed_key))}
    function levels(r){return r[5]}
    function elt_key_lower_bound(r){return r[4]}
    function set_elt_key_lower_bound(r,v){r[4] = v;return 0}
    function min_elt(r){return r[3]}
    function set_min_elt(r,v){r[3] = v;return 0}
    function pool(r){return r[2]}
    function set_pool(r,v){r[2] = v;return 0}
    function length$1(r){return r[1]}
    function set_length$0(r,v){r[1] = v;return 0}
    function _ao_(r,v){return [0,r[1],r[2],r[3],r[4],v]}
    var
     _ap_=0,
     levels$0=[0,function(param){return 0},cst_levels,_ap_,levels,_ao_];
    function _aq_(r,v){return [0,r[1],r[2],r[3],v,r[5]]}
    var
     _ar_=[0,set_elt_key_lower_bound],
     elt_key_lower_bound$0=
      [0,
       function(param){return 0},
       cst_elt_key_lower_bound,
       _ar_,
       elt_key_lower_bound,
       _aq_];
    function _as_(r,v){return [0,r[1],r[2],v,r[4],r[5]]}
    var
     _at_=[0,set_min_elt],
     min_elt$0=[0,function(param){return 0},cst_min_elt,_at_,min_elt,_as_];
    function _au_(r,v){return [0,r[1],v,r[3],r[4],r[5]]}
    var
     _av_=[0,set_pool],
     pool$0=[0,function(param){return 0},cst_pool,_av_,pool,_au_];
    function _aw_(r,v){return [0,v,r[2],r[3],r[4],r[5]]}
    var
     _ax_=[0,set_length$0],
     length$2=[0,function(param){return 0},cst_length$0,_ax_,length$1,_aw_];
    function is_empty(t){return caml_call2(Core[90],t[1],0)}
    function num_levels(t){return t[5].length - 1}
    function min_allowed_key$1(t){return caml_check_bound(t[5],0)[1][9]}
    function max_allowed_key$1(t)
     {var _e4_=num_levels(t) - 1 | 0;
      return caml_check_bound(t[5],_e4_)[1 + _e4_][10]}
    function internal_iter(t,f)
     {var _eW_=caml_call2(Core[91],t[1],0);
      if(_eW_)
       {var pool=t[2],levels=t[5],_eY_=levels.length - 1 - 1 | 0,_eX_=0;
        if(_eY_ >= 0)
         {var level_index=_eX_;
          for(;;)
           {var level=caml_check_bound(levels,level_index)[1 + level_index];
            if(caml_call2(Core[91],level[8],0))
             {var slots=level[11],_e1_=slots.length - 1 - 1 | 0,_e0_=0;
              if(_e1_ >= 0)
               {var slot_index=_e0_;
                for(;;)
                 {var elt=caml_check_bound(slots,slot_index)[1 + slot_index];
                  if(1 - caml_call1(is_null,elt))iter(pool,elt,f);
                  var _e3_=slot_index + 1 | 0;
                  if(_e1_ !== slot_index){var slot_index=_e3_;continue}
                  break}}}
            var _e2_=level_index + 1 | 0;
            if(_eY_ !== level_index){var level_index=_e2_;continue}
            break}}
        var _eZ_=0}
      else
       var _eZ_=_eW_;
      return _eZ_}
    function compute_diff_max_min_allowed_k(level_bits,bits_per_slot)
     {var bits=symbol$2(level_bits,bits_per_slot);
      if(caml_call2(equal,bits,max_num_bits))return _D_[26];
      var _eV_=num_keys(bits);
      return caml_call1(_D_[32],_eV_)}
    function min_elt$1(t)
     {if(is_empty(t))return caml_call1(null$1,0);
      if(! caml_call1(is_null,t[3]))return t[3];
      var
       pool=t[2],
       min_elt_already_found=[0,caml_call1(null$1,0)],
       min_key_already_found=[0,max_value$0],
       level_index=[0,0],
       num_levels$0=num_levels(t);
      for(;;)
       {if(! caml_call2(Core[92],level_index[1],num_levels$0))
         {t[3] = min_elt_already_found[1];
          t[4] = min_key_already_found[1];
          return t[3]}
        var _eS_=level_index[1],level=caml_check_bound(t[5],_eS_)[1 + _eS_];
        if(caml_call2(symbol$18,level[9],min_key_already_found[1]))
         level_index[1] = num_levels$0;
        else
         if(caml_call2(Core[90],level[8],0))
          level_index[1]++;
         else
          {var
            slots=level[11],
            slot_min_key=
             [0,min_key_in_same_slot$0(level,caml_call2(max$0,level[9],t[4]))],
            slot$0=[0,slot(level,slot_min_key[1])];
           for(;;)
            {var _eT_=slot$0[1];
             if
              (caml_call1(is_null,caml_check_bound(slots,_eT_)[1 + _eT_])
               &&
               caml_call2(symbol$19,slot_min_key[1],min_key_already_found[1]))
              {slot$0[1] = next_slot(level,slot$0[1]);
               slot_min_key[1] = add(slot_min_key[1],level[5]);
               continue}
             var _eU_=slot$0[1],first=caml_check_bound(slots,_eU_)[1 + _eU_];
             if(1 - caml_call1(is_null,first))
              {var continue$0=[0,1],current=[0,first];
               for(;;)
                {if(continue$0[1])
                  {var current_key=key(pool,current[1]);
                   if
                    (caml_call2(symbol$16,current_key,min_key_already_found[1]))
                    {min_elt_already_found[1] = current[1];
                     min_key_already_found[1] = current_key}
                   var next$0=next(pool,current[1]),switch$0=0;
                   if
                    (!
                     caml_call2(Core[246],next$0,first)
                     &&
                     !
                     caml_call2(Core[90],level_index[1],0))
                    {current[1] = next$0;switch$0 = 1}
                   if(! switch$0)continue$0[1] = 0;
                   continue}
                 break}}
             level_index[1]++;
             break}}}}
    function add_elt(t,to_add)
     {var
       pool$0=t[2],
       key$0=key(pool$0,to_add),
       _eL_=caml_call2(symbol$15,key$0,min_allowed_key$1(t)),
       _eM_=_eL_?caml_call2(symbol$16,key$0,max_allowed_key$1(t)):_eL_;
      if(1 - _eM_)
       {var pool=t[2],r=[0,0],_eA_=0,_eB_=0;
        internal_iter
         (t,
          function(elt)
           {var _eQ_=r[1],_eR_=value(pool,elt);
            r[1] = [0,[0,key(pool,elt),_eR_],_eQ_];
            return 0});
        var
         elts_115=caml_call1(Core_List[34],r[1]),
         max_allowed_key_113=max_allowed_key$1(t),
         min_allowed_key_111=min_allowed_key$1(t),
         bnds_110=0,
         _ez_=
          function(param)
           {var
             key_105=param[1],
             bnds_104=[0,[1,[0,_aD_,[0,arg_108,0]]],0],
             arg_106=caml_call1(sexpifier$0,key_105),
             bnds_104$0=[0,[1,[0,_aE_,[0,arg_106,0]]],bnds_104];
            return [1,bnds_104$0]},
         arg_116=caml_call2(Core[421],_ez_,elts_115),
         bnds_110$0=[0,[1,[0,_aF_,[0,arg_116,0]]],bnds_110],
         arg_114=caml_call1(sexpifier$0,max_allowed_key_113),
         bnds_110$1=[0,[1,[0,_aG_,[0,arg_114,0]]],bnds_110$0],
         arg_112=caml_call1(sexpifier$0,min_allowed_key_111),
         bnds_110$2=[0,[1,[0,_aH_,[0,arg_112,0]]],bnds_110$1],
         _eC_=
          [0,
           [1,[0,_a7_,[0,caml_call1(sexpifier$0,max_allowed_key$1(t)),0]]],
           [0,[1,[0,_a6_,[0,[1,bnds_110$2],_eB_]]],_eA_]],
         _eD_=
          [0,
           [1,[0,_a8_,[0,caml_call1(sexpifier$0,min_allowed_key$1(t)),0]]],
           _eC_],
         _eE_=[0,[1,[0,_a9_,[0,caml_call1(sexpifier$0,key$0),0]]],_eD_],
         _eF_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Priority_queue_add_elt_key),
            _eE_]];
        caml_call1(Core[253],_eF_)}
      var level_index=[0,0];
      for(;;)
       {var _eN_=level_index[1];
        if
         (caml_call2
           (symbol$18,key$0,caml_check_bound(t[5],_eN_)[1 + _eN_][10]))
         {level_index[1]++;continue}
        var
         level_index$0=level_index[1],
         level=caml_check_bound(t[5],level_index$0)[1 + level_index$0],
         _eO_=caml_call2(symbol$15,key$0,level[9]),
         _eP_=_eO_?caml_call2(symbol$16,key$0,level[10]):_eO_;
        if(1 - _eP_)
         {var
           _eG_=0,
           _eH_=0,
           _eI_=
            [0,
             [1,
              [0,
               _a$_,
               [0,sexp_of_t$7(function(param){return _a__},level),_eH_]]],
             _eG_],
           _eJ_=[0,[1,[0,_ba_,[0,caml_call1(sexpifier$0,key$0),0]]],_eI_],
           _eK_=
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7],cst_Priority_queue_add_elt_key$0),
              _eJ_]];
          caml_call1(Core[253],_eK_)}
        level[8] = level[8] + 1 | 0;
        caml_call4
         (Tuple_pool[36][33],pool$0,to_add,Tuple_pool[36][2][6],level_index$0);
        var
         slot$0=slot(level,key$0),
         slots=level[11],
         t$0=caml_check_bound(slots,slot$0)[1 + slot$0];
        if(caml_call1(is_null,t$0))
         {caml_check_bound(slots,slot$0)[1 + slot$0] = to_add;
          return link(pool$0,to_add,to_add)}
        var prev$0=prev(pool$0,t$0);
        link(pool$0,prev$0,to_add);
        return link(pool$0,to_add,t$0)}}
    function internal_add_elt(t,elt)
     {var key$0=key(t[2],elt);
      if(caml_call2(symbol$19,key$0,t[4])){t[3] = elt;t[4] = key$0}
      add_elt(t,elt);
      t[1] = t[1] + 1 | 0;
      return 0}
    function ensure_valid_key(t,key)
     {var
       _ex_=caml_call2(symbol$19,key,min_allowed_key$1(t)),
       _ey_=_ex_ || caml_call2(symbol$18,key,max_allowed_key$1(t));
      if(! _ey_)return _ey_;
      var
       _et_=
        [0,[1,[0,_bb_,[0,caml_call1(sexpifier$0,max_allowed_key$1(t)),0]]],0],
       _eu_=
        [0,
         [1,[0,_bc_,[0,caml_call1(sexpifier$0,min_allowed_key$1(t)),0]]],
         _et_],
       _ev_=[0,[1,[0,_bd_,[0,caml_call1(sexpifier$0,key),0]]],_eu_],
       _ew_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_add_at_interv),
          _ev_]];
      return caml_call1(Core[253],_ew_)}
    function internal_add(t,key,at,value)
     {ensure_valid_key(t,key);
      if(caml_call1(is_full,t[2]))t[2] = caml_call2(grow,0,t[2]);
      var
       _es_=t[2],
       _eq_=caml_call1(null$1,0),
       _er_=caml_call1(null$1,0),
       elt=caml_call7(Tuple_pool[36][21],_es_,key,at,value,-1,_er_,_eq_);
      internal_add_elt(t,elt);
      return elt}
    function internal_remove(t$0,t)
     {var pool=t$0[2];
      if(caml_call2(Tuple_pool[36][3][7],t,t$0[3]))
       t$0[3] = caml_call1(null$1,0);
      t$0[1] = t$0[1] - 1 | 0;
      var
       _em_=level_index(pool,t),
       level=caml_check_bound(t$0[5],_em_)[1 + _em_];
      level[8] = level[8] - 1 | 0;
      var
       slots=level[11],
       slot$0=slot(level,key(pool,t)),
       first=caml_check_bound(slots,slot$0)[1 + slot$0],
       _en_=next(pool,t);
      if(caml_call2(Core[246],t,_en_))
       {var _eo_=caml_call1(null$1,0);
        caml_check_bound(slots,slot$0)[1 + slot$0] = _eo_;
        return 0}
      if(caml_call2(Core[246],t,first))
       {var _ep_=next(pool,t);
        caml_check_bound(slots,slot$0)[1 + slot$0] = _ep_}
      var _ek_=next(pool,t);
      set_next(pool,prev(pool,t),_ek_);
      var _el_=prev(pool,t);
      return set_prev(pool,next(pool,t),_el_)}
    var
     _be_=
      [0,
       _D_,
       sexpifier$0,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       _A_,
       _y_,
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       _w_,
       _v_,
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
     min_interval_num=_be_[31];
    function priority_queue(r){return r[7]}
    function max_allowed_alarm_time(r){return r[6]}
    function set_max_allowed_alarm_time(r,v){r[6] = v;return 0}
    function now_interval_num_start(r){return r[5]}
    function set_now_interval_num_start(r,v){r[5] = v;return 0}
    function now(r){return r[4]}
    function set_now(r,v){r[4] = v;return 0}
    function max_interval_num(r){return r[3]}
    function start(r){return r[2]}
    function config(r){return r[1]}
    function _bf_(r,v){return [0,r[1],r[2],r[3],r[4],r[5],r[6],v]}
    var
     _bg_=0,
     priority_queue$0=
      [0,
       function(param){return 0},
       cst_priority_queue,
       _bg_,
       priority_queue,
       _bf_];
    function _bh_(r,v){return [0,r[1],r[2],r[3],r[4],r[5],v,r[7]]}
    var
     _bi_=[0,set_max_allowed_alarm_time],
     max_allowed_alarm_time$0=
      [0,
       function(param){return 0},
       cst_max_allowed_alarm_time,
       _bi_,
       max_allowed_alarm_time,
       _bh_];
    function _bj_(r,v){return [0,r[1],r[2],r[3],r[4],v,r[6],r[7]]}
    var
     _bk_=[0,set_now_interval_num_start],
     now_interval_num_start$0=
      [0,
       function(param){return 0},
       cst_now_interval_num_start,
       _bk_,
       now_interval_num_start,
       _bj_];
    function _bl_(r,v){return [0,r[1],r[2],r[3],v,r[5],r[6],r[7]]}
    var
     _bm_=[0,set_now],
     now$0=[0,function(param){return 0},cst_now,_bm_,now,_bl_];
    function _bn_(r,v){return [0,r[1],r[2],v,r[4],r[5],r[6],r[7]]}
    var
     _bo_=0,
     max_interval_num$0=
      [0,
       function(param){return 0},
       cst_max_interval_num,
       _bo_,
       max_interval_num,
       _bn_];
    function _bp_(r,v){return [0,r[1],v,r[3],r[4],r[5],r[6],r[7]]}
    var
     _bq_=0,
     start$0=[0,function(param){return 0},cst_start,_bq_,start,_bp_];
    function _br_(r,v){return [0,v,r[2],r[3],r[4],r[5],r[6],r[7]]}
    var
     _bs_=0,
     config$0=[0,function(param){return 0},cst_config,_bs_,config,_br_];
    function sexp_of_t_now(param,t)
     {return caml_call1(Core_Time_ns_alternate_sexp[92],t[4])}
    function alarm_precision$0(t){return alarm_precision(t[1])}
    function at$0(tw,t)
     {var _ej_=tw[7],_ei_=of_external_exn(_ej_[2],t);return at(_ej_[2],_ei_)}
    function value$0(tw,t)
     {var _eh_=tw[7],_eg_=of_external_exn(_eh_[2],t);
      return value(_eh_[2],_eg_)}
    function interval_num(tw,t)
     {var _ef_=tw[7],_ee_=of_external_exn(_ef_[2],t);return key(_ef_[2],_ee_)}
    function iter$0(t,f){return internal_iter(t[7],f)}
    function compare$3(t1,t2)
     {return caml_call2(Core_Time_ns_alternate_sexp[101],t1[1],t2[1])}
    function sexp_of_t$8(sexp_of_a,t)
     {var
       max_interval_num_167=t[3],
       start_165=t[2],
       config_163=t[1],
       now_169=t[4],
       r=[0,0];
      iter$0
       (t,
        function(a)
         {var _ed_=r[1],_ec_=value$0(t,a);
          r[1] = [0,[0,at$0(t,a),_ec_],_ed_];
          return 0});
      var alarms_171=caml_call2(Core_List[58],r[1],compare$3),bnds_162=0;
      function _eb_(param)
       {var
         value_159=param[2],
         at_157=param[1],
         arg_160=caml_call1(sexp_of_a,value_159),
         bnds_156=[0,[1,[0,_bt_,[0,arg_160,0]]],0],
         arg_158=caml_call1(Core_Time_ns_alternate_sexp[92],at_157),
         bnds_156$0=[0,[1,[0,_bu_,[0,arg_158,0]]],bnds_156];
        return [1,bnds_156$0]}
      var
       arg_172=caml_call2(Core[421],_eb_,alarms_171),
       bnds_162$0=[0,[1,[0,_bv_,[0,arg_172,0]]],bnds_162],
       arg_170=caml_call1(Core_Time_ns_alternate_sexp[92],now_169),
       bnds_162$1=[0,[1,[0,_bw_,[0,arg_170,0]]],bnds_162$0],
       arg_168=caml_call1(_be_[2],max_interval_num_167),
       bnds_162$2=[0,[1,[0,_bx_,[0,arg_168,0]]],bnds_162$1],
       arg_166=caml_call1(Core_Time_ns_alternate_sexp[92],start_165),
       bnds_162$3=[0,[1,[0,_by_,[0,arg_166,0]]],bnds_162$2],
       arg_164=sexp_of_t$3(config_163),
       bnds_162$4=[0,[1,[0,_bz_,[0,arg_164,0]]],bnds_162$3];
      return [1,bnds_162$4]}
    function length$3(t){return t[7][1]}
    function is_empty$0(t)
     {var _ea_=length$3(t);return caml_call2(Core[90],_ea_,0)}
    function pool$1(t){return t[7][2]}
    function interval_num_internal(time,alarm_precision)
     {var
       _d__=caml_call1(Core_Time_ns_alternate_sexp[61],time),
       _d$_=caml_call2(Core_Int63[48],_d__,alarm_precision);
      return caml_call1(_be_[35],_d$_)}
    function interval_num_unchecked(t,time)
     {return interval_num_internal(time,t[1][1])}
    function interval_num$0(t,time)
     {if(caml_call2(Core_Time_ns_alternate_sexp[98],time,min_time))
       {var
         _d8_=
          [0,
           [1,[0,_bE_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],time),0]]],
           0],
         _d9_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_interval_num_),
            _d8_]];
        caml_call1(Core[253],_d9_)}
      return interval_num_unchecked(t,time)}
    function interval_num_start_unchecked(t,interval_num)
     {var
       interval_num$0=caml_call1(_be_[36],interval_num),
       _d7_=caml_call2(Core_Int63[47],interval_num$0,t[1][1]);
      return caml_call1(Core_Time_ns_alternate_sexp[62],_d7_)}
    function interval_num_start(t,interval_num)
     {if(caml_call2(_be_[7],interval_num,min_interval_num))
       {var
         _d1_=[0,[1,[0,_bF_,[0,caml_call1(_be_[2],min_interval_num),0]]],0],
         _d2_=[0,[1,[0,_bG_,[0,caml_call1(_be_[2],interval_num),0]]],_d1_],
         _d3_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_interval_num_$0),
            _d2_]];
        caml_call1(Core[253],_d3_)}
      if(caml_call2(_be_[6],interval_num,t[3]))
       {var
         _d4_=[0,[1,[0,_bH_,[0,caml_call1(_be_[2],t[3]),0]]],0],
         _d5_=[0,[1,[0,_bI_,[0,caml_call1(_be_[2],interval_num),0]]],_d4_],
         _d6_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_interval_num_$1),
            _d5_]];
        caml_call1(Core[253],_d6_)}
      return interval_num_start_unchecked(t,interval_num)}
    function next_alarm_fires_at_internal(t,key)
     {return interval_num_start(t,caml_call1(_be_[42],key))}
    function next_alarm_fires_at(t)
     {var elt=min_elt$1(t[7]);
      if(caml_call1(is_null,elt))return 0;
      var key$0=key(pool$1(t),elt);
      return caml_call2(_be_[9],key$0,t[3])
              ?0
              :[0,next_alarm_fires_at_internal(t,key$0)]}
    function next_alarm_fires_at_exn(t)
     {var elt=min_elt$1(t[7]);
      if(caml_call1(is_null,elt))
       {var
         _dT_=0,
         _dU_=0,
         _dV_=
          [0,
           [1,[0,_bB_,[0,sexp_of_t$8(function(param){return _bA_},t),_dU_]]],
           _dT_],
         _dW_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_next_alarm_fi),
            _dV_]];
        caml_call1(Core[253],_dW_)}
      var key$0=key(pool$1(t),elt);
      if(caml_call2(_be_[9],key$0,t[3]))
       {var
         _dX_=0,
         _dY_=0,
         _dZ_=
          [0,
           [1,[0,_bD_,[0,sexp_of_t$8(function(param){return _bC_},t),_dY_]]],
           _dX_],
         _d0_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_next_alarm_fi$0),
            _dZ_]];
        caml_call1(Core[253],_d0_)}
      return next_alarm_fires_at_internal(t,key$0)}
    function compute_max_allowed_alarm_time(t)
     {var max_allowed_key=max_allowed_key$1(t[7]);
      if(caml_call2(_be_[3],max_allowed_key,t[3]))return max_time;
      var
       _dP_=Core_Time_ns[1][67],
       _dQ_=alarm_precision$0(t),
       _dR_=caml_call2(Core_Time_ns[1][98],_dQ_,_dP_),
       _dS_=interval_num_start_unchecked(t,max_allowed_key);
      return caml_call2(Core_Time_ns_alternate_sexp[51],_dS_,_dR_)}
    function min_allowed_alarm_interval_num(t){return min_allowed_key$1(t[7])}
    function max_allowed_alarm_interval_num(t){return interval_num$0(t,t[6])}
    function interval_start(t,time)
     {return interval_num_start_unchecked(t,interval_num$0(t,time))}
    function invariant$1(invariant_a,t)
     {function _c7_(param)
       {function check(f){return caml_call2(Base_Invariant[2],t,f)}
        var
         priority_queue_fun=
          check
           (function(t)
             {var pool=t[2];
              function _dg_(param)
               {function check(f){return caml_call2(Base_Invariant[2],t,f)}
                if(! caml_call2(symbol$15,min_allowed_key$1(t),zero$1))
                 throw [0,Assert_failure,_a3_];
                var _dm_=min_allowed_key$1(t);
                if(! caml_call2(symbol$15,max_allowed_key$1(t),_dm_))
                 throw [0,Assert_failure,_a2_];
                var
                 levels_fun=
                  check
                   (function(levels)
                     {var _ds_=num_levels(t);
                      if(! caml_call2(Core[91],_ds_,0))
                       throw [0,Assert_failure,_aV_];
                      function _dt_(level_index$0,level)
                       {if(! caml_call2(Core[90],level_index$0,level[1]))
                         throw [0,Assert_failure,_aU_];
                        function _du_(param)
                         {function check(f)
                           {return caml_call2(Base_Invariant[2],level,f)}
                          var
                           slots_fun=
                            check
                             (function(slots)
                               {function _dE_(t$0)
                                 {var _dH_=1 - caml_call1(is_null,t$0);
                                  if(! _dH_)return _dH_;
                                  function _dF_(param)
                                   {if(! is_valid(pool,t$0))throw [0,Assert_failure,_G_];
                                    caml_call1(invariant_a,value(pool,t$0));
                                    var n=next(pool,t$0);
                                    if(! caml_call1(is_null,n))
                                     {var _dO_=prev(pool,n);
                                      if(! caml_call2(Tuple_pool[36][3][7],t$0,_dO_))
                                       throw [0,Assert_failure,_F_]}
                                    var p=prev(pool,t$0);
                                    if(! caml_call1(is_null,p))
                                     {var _dN_=next(pool,p);
                                      if(! caml_call2(Tuple_pool[36][3][7],t$0,_dN_))
                                       throw [0,Assert_failure,_E_]}
                                    return 0}
                                  function _dG_(x_062)
                                   {return sexp_of_t$6(function(param){return _H_},x_062)}
                                  caml_call4(Base_Invariant[1],_I_,t$0,_dG_,_dF_);
                                  return iter
                                          (pool,
                                           t$0,
                                           function(elt)
                                            {var _dI_=level[9];
                                             if(! caml_call2(symbol$15,key(pool,elt),_dI_))
                                              throw [0,Assert_failure,_aL_];
                                             var _dJ_=level[10];
                                             if(! caml_call2(symbol$16,key(pool,elt),_dJ_))
                                              throw [0,Assert_failure,_aK_];
                                             var _dK_=t[4];
                                             if(! caml_call2(symbol$15,key(pool,elt),_dK_))
                                              throw [0,Assert_failure,_aJ_];
                                             var _dL_=level[1],_dM_=level_index(pool,elt);
                                             if(caml_call2(Core[90],_dM_,_dL_))
                                              return caml_call1(invariant_a,value(pool,elt));
                                             throw [0,Assert_failure,_aI_]})}
                                return caml_call2(Core_Array[22],slots,_dE_)}),
                           max_allowed_key_fun=
                            check
                             (function(got)
                               {var
                                 expect=add_clamp_to_max(level[9],level[7]),
                                 equal=0,
                                 message=0,
                                 here=0;
                                function comparator(a_128,b_129)
                                 {return caml_call2(compare$2,a_128,b_129)}
                                return caml_call8
                                        (Ppx_assert_lib_Runtime[3],
                                         pos,
                                         sexpifier$0,
                                         comparator,
                                         here,
                                         message,
                                         equal,
                                         expect,
                                         got)}),
                           min_allowed_key_fun=
                            check
                             (function(min_allowed_key)
                               {if(! caml_call2(symbol$15,min_allowed_key,zero$1))
                                 throw [0,Assert_failure,_aM_];
                                var _dC_=caml_call2(symbol$19,min_allowed_key,max_value$0);
                                if(! _dC_)return _dC_;
                                var
                                 got=caml_call2(rem,min_allowed_key,level[5]),
                                 sexpifier=_D_[1],
                                 _dD_=_D_[24],
                                 equal=0,
                                 message=0,
                                 here=0;
                                function comparator(a_126,b_127)
                                 {return caml_call2(_D_[9],a_126,b_127)}
                                return caml_call8
                                        (Ppx_assert_lib_Runtime[3],
                                         pos$0,
                                         sexpifier,
                                         comparator,
                                         here,
                                         message,
                                         equal,
                                         _dD_,
                                         got)}),
                           length_fun=
                            check
                             (function(length)
                               {function _dA_(n,first)
                                 {if(caml_call1(is_null,first))return n;
                                  var r=[0,0],current=[0,first],continue$0=[0,1];
                                  for(;;)
                                   {if(! continue$0[1])return n + r[1] | 0;
                                    r[1]++;
                                    var next$0=next(pool,current[1]);
                                    if(caml_call2(Core[246],next$0,first))
                                     continue$0[1] = 0;
                                    else
                                     current[1] = next$0}}
                                var _dB_=caml_call3(Core_Array[23],level[11],0,_dA_);
                                if(caml_call2(Core[90],length,_dB_))return 0;
                                throw [0,Assert_failure,_aN_]}),
                           expect=compute_diff_max_min_allowed_k(level[2],level[4]),
                           diff_max_min_allowed_key_fun=
                            check
                             (function(got)
                               {var sexpifier=_D_[1],equal=0,message=0,here=0;
                                function comparator(a_124,b_125)
                                 {return caml_call2(_D_[9],a_124,b_125)}
                                return caml_call8
                                        (Ppx_assert_lib_Runtime[3],
                                         pos$1,
                                         sexpifier,
                                         comparator,
                                         here,
                                         message,
                                         equal,
                                         expect,
                                         got)}),
                           min_key_in_same_slot_mask_fun=
                            check
                             (function(min_key_in_same_slot_mask)
                               {if
                                 (caml_call2
                                   (equal$1,min_key_in_same_slot_mask,create$1(level[4])))
                                 return 0;
                                throw [0,Assert_failure,_aO_]}),
                           keys_per_slot_fun=
                            check
                             (function(got)
                               {var
                                 expect=num_keys(level[4]),
                                 sexpifier=_D_[1],
                                 equal=0,
                                 message=0,
                                 here=0;
                                function comparator(a_122,b_123)
                                 {return caml_call2(_D_[9],a_122,b_123)}
                                return caml_call8
                                        (Ppx_assert_lib_Runtime[3],
                                         pos$2,
                                         sexpifier,
                                         comparator,
                                         here,
                                         message,
                                         equal,
                                         expect,
                                         got)}),
                           bits_per_slot_fun=
                            check
                             (function(bits_per_slot)
                               {if(caml_call2(symbol,bits_per_slot,zero))return 0;
                                throw [0,Assert_failure,_aP_]}),
                           expect$0=create$0(level[2]),
                           slots_mask_fun=
                            check
                             (function(got)
                               {var equal=0,message=0,here=0;
                                function comparator(a_120,b_121)
                                 {return caml_call2(compare$0,a_120,b_121)}
                                return caml_call8
                                        (Ppx_assert_lib_Runtime[3],
                                         pos$3,
                                         sexpifier,
                                         comparator,
                                         here,
                                         message,
                                         equal,
                                         expect$0,
                                         got)}),
                           bits_fun=
                            check
                             (function(bits)
                               {if(caml_call2(symbol$1,bits,zero))return 0;
                                throw [0,Assert_failure,_aQ_]}),
                           index_fun=
                            check
                             (function(index)
                               {if(caml_call2(Core[88],index,0))return 0;
                                throw [0,Assert_failure,_aR_]});
                          caml_call1(index_fun,index$0);
                          caml_call1(bits_fun,bits$0);
                          caml_call1(slots_mask_fun,slots_mask$0);
                          caml_call1(bits_per_slot_fun,bits_per_slot$0);
                          caml_call1(keys_per_slot_fun,keys_per_slot$0);
                          caml_call1
                           (min_key_in_same_slot_mask_fun,min_key_in_same_slot_mask$0);
                          caml_call1
                           (diff_max_min_allowed_key_fun,diff_max_min_allowed_key$0);
                          caml_call1(length_fun,length$0);
                          caml_call1(min_allowed_key_fun,min_allowed_key$0);
                          caml_call1(max_allowed_key_fun,max_allowed_key$0);
                          return caml_call1(slots_fun,slots$0)}
                        function _dv_(x_119)
                         {return sexp_of_t$7(function(param){return _aS_},x_119)}
                        caml_call4(Base_Invariant[1],_aT_,level,_dv_,_du_);
                        var _dw_=caml_call2(Core[91],level_index$0,0);
                        if(! _dw_)return _dw_;
                        var
                         _dx_=level_index$0 - 1 | 0,
                         prev_level=caml_check_bound(levels,_dx_)[1 + _dx_],
                         _dy_=level[5],
                         expect=caml_call1(_D_[33],prev_level[7]),
                         sexpifier$1=_D_[1],
                         equal=0,
                         message=0,
                         here=0;
                        function comparator(a_131,b_132)
                         {return caml_call2(_D_[9],a_131,b_132)}
                        caml_call8
                         (Ppx_assert_lib_Runtime[3],
                          pos$4,
                          sexpifier$1,
                          comparator,
                          here,
                          message,
                          equal,
                          expect,
                          _dy_);
                        var
                         _dz_=level[9],
                         expect$0=compute_min_allowed_key(level,prev_level[10]),
                         equal$0=0,
                         message$0=0,
                         here$0=0;
                        function comparator$0(a_133,b_134)
                         {return caml_call2(compare$2,a_133,b_134)}
                        return caml_call8
                                (Ppx_assert_lib_Runtime[3],
                                 pos$5,
                                 sexpifier$0,
                                 comparator$0,
                                 here$0,
                                 message$0,
                                 equal$0,
                                 expect$0,
                                 _dz_)}
                      return caml_call2(Core_Array[58],levels,_dt_)}),
                 elt_key_lower_bound_fun=
                  check
                   (function(elt_key_lower_bound)
                     {if
                       (!
                        caml_call2
                         (symbol$15,elt_key_lower_bound,min_allowed_key$1(t)))
                       throw [0,Assert_failure,_aY_];
                      if
                       (!
                        caml_call2
                         (symbol$16,elt_key_lower_bound,max_allowed_key$1(t)))
                       throw [0,Assert_failure,_aX_];
                      var _dr_=1 - caml_call1(is_null,t[3]);
                      if(! _dr_)return _dr_;
                      if(caml_call2(equal$3,elt_key_lower_bound,key(t[2],t[3])))
                       return 0;
                      throw [0,Assert_failure,_aW_]}),
                 min_elt_fun=
                  check
                   (function(elt)
                     {var _dp_=1 - caml_call1(is_null,elt);
                      if(! _dp_)return _dp_;
                      if(! is_valid(t[2],elt))throw [0,Assert_failure,_a0_];
                      var _dq_=key(t[2],elt);
                      if(caml_call2(equal$3,t[4],_dq_))return 0;
                      throw [0,Assert_failure,_aZ_]}),
                 pool_fun=
                  check
                   (function(t)
                     {function _dn_(_do_){return 0}
                      return caml_call2(Tuple_pool[36][5],_dn_,t)}),
                 length_fun=
                  check
                   (function(length)
                     {if(caml_call2(Core[88],length,0))return 0;
                      throw [0,Assert_failure,_a1_]});
                caml_call1(length_fun,length$2);
                caml_call1(pool_fun,pool$0);
                caml_call1(min_elt_fun,min_elt$0);
                caml_call1(elt_key_lower_bound_fun,elt_key_lower_bound$0);
                return caml_call1(levels_fun,levels$0)}
              function _dh_(x_130)
               {function of_a_063(param){return _a4_}
                var
                 length_091=x_130[1],
                 pool_093=x_130[2],
                 min_elt_095=x_130[3],
                 elt_key_lower_bound_097=x_130[4],
                 levels_099=x_130[5],
                 bnds_090=0;
                function _dj_(_dl_){return sexp_of_t$7(of_a_063,_dl_)}
                var
                 arg_100=caml_call2(Core[288],_dj_,levels_099),
                 bnds_090$0=[0,[1,[0,_ay_,[0,arg_100,0]]],bnds_090],
                 arg_098=caml_call1(sexpifier$0,elt_key_lower_bound_097),
                 bnds_090$1=[0,[1,[0,_az_,[0,arg_098,0]]],bnds_090$0],
                 arg_096=sexp_of_t$6(of_a_063,min_elt_095),
                 bnds_090$2=[0,[1,[0,_aA_,[0,arg_096,0]]],bnds_090$1];
                function _di_(_dk_){return sexp_of_pool_slots(of_a_063,_dk_)}
                var
                 arg_094=caml_call2(Tuple_pool[36][4],_di_,pool_093),
                 bnds_090$3=[0,[1,[0,_aB_,[0,arg_094,0]]],bnds_090$2],
                 arg_092=caml_call1(Core[356],length_091),
                 bnds_090$4=[0,[1,[0,_aC_,[0,arg_092,0]]],bnds_090$3];
                return [1,bnds_090$4]}
              return caml_call4(Base_Invariant[1],_a5_,t,_dh_,_dg_)}),
         max_allowed_alarm_time_fun=
          check
           (function(got)
             {var
               expect=compute_max_allowed_alarm_time(t),
               sexpifier=Core_Time_ns_alternate_sexp[92],
               equal=0,
               message=0,
               here=0;
              function comparator(a_183,b_184)
               {return caml_call2
                        (Core_Time_ns_alternate_sexp[101],a_183,b_184)}
              return caml_call8
                      (Ppx_assert_lib_Runtime[3],
                       pos$6,
                       sexpifier,
                       comparator,
                       here,
                       message,
                       equal,
                       expect,
                       got)}),
         now_interval_num_start_fun=
          check
           (function(got)
             {var
               expect=interval_num_start(t,min_allowed_alarm_interval_num(t)),
               sexpifier=Core_Time_ns_alternate_sexp[92],
               equal=0,
               message=0,
               here=0;
              function comparator(a_181,b_182)
               {return caml_call2
                        (Core_Time_ns_alternate_sexp[101],a_181,b_182)}
              return caml_call8
                      (Ppx_assert_lib_Runtime[3],
                       pos$7,
                       sexpifier,
                       comparator,
                       here,
                       message,
                       equal,
                       expect,
                       got)}),
         now_fun=
          check
           (function(now)
             {if(! caml_call2(Core_Time_ns_alternate_sexp[94],now,t[2]))
               throw [0,Assert_failure,_bL_];
              if(! caml_call2(Core_Time_ns_alternate_sexp[95],now,max_time))
               throw [0,Assert_failure,_bK_];
              var _de_=min_allowed_key$1(t[7]),_df_=interval_num$0(t,t[4]);
              if(caml_call2(_be_[9],_df_,_de_))return 0;
              throw [0,Assert_failure,_bJ_]}),
         max_interval_num_fun=
          check
           (function(expect)
             {var
               got=interval_num$0(t,max_time),
               sexpifier=_be_[2],
               equal=0,
               message=0,
               here=0;
              function comparator(a_177,b_178)
               {return caml_call2(_be_[22],a_177,b_178)}
              caml_call8
               (Ppx_assert_lib_Runtime[3],
                pos$8,
                sexpifier,
                comparator,
                here,
                message,
                equal,
                expect,
                got);
              var
               got$0=interval_num$0(t,interval_num_start(t,expect)),
               sexpifier$0=_be_[2],
               equal$0=0,
               message$0=0,
               here$0=0;
              function comparator$0(a_179,b_180)
               {return caml_call2(_be_[22],a_179,b_180)}
              return caml_call8
                      (Ppx_assert_lib_Runtime[3],
                       pos$9,
                       sexpifier$0,
                       comparator$0,
                       here$0,
                       message$0,
                       equal$0,
                       expect,
                       got$0)}),
         start_fun=
          check
           (function(start)
             {if(! caml_call2(Core_Time_ns_alternate_sexp[94],start,min_time))
               throw [0,Assert_failure,_bN_];
              if(caml_call2(Core_Time_ns_alternate_sexp[95],start,max_time))
               return 0;
              throw [0,Assert_failure,_bM_]}),
         config_fun=check(invariant$0);
        caml_call1(config_fun,config$0);
        caml_call1(start_fun,start$0);
        caml_call1(max_interval_num_fun,max_interval_num$0);
        caml_call1(now_fun,now$0);
        caml_call1(now_interval_num_start_fun,now_interval_num_start$0);
        caml_call1(max_allowed_alarm_time_fun,max_allowed_alarm_time$0);
        caml_call1(priority_queue_fun,priority_queue$0);
        return iter$0
                (t,
                 function(alarm)
                  {var
                    _c9_=interval_num$0(t,at$0(t,alarm)),
                    _c__=interval_num(t,alarm);
                   if(! caml_call2(_be_[9],_c__,_c9_))
                    throw [0,Assert_failure,_bQ_];
                   var
                    _c$_=interval_start(t,t[4]),
                    _da_=interval_start(t,at$0(t,alarm));
                   if(! caml_call2(Core_Time_ns_alternate_sexp[94],_da_,_c$_))
                    throw [0,Assert_failure,_bP_];
                   var
                    _db_=alarm_precision$0(t),
                    _dc_=caml_call2(Core_Time_ns_alternate_sexp[54],t[4],_db_),
                    _dd_=at$0(t,alarm);
                   if(caml_call2(Core_Time_ns_alternate_sexp[97],_dd_,_dc_))
                    return 0;
                   throw [0,Assert_failure,_bO_]})}
      function _c8_(x_176)
       {return sexp_of_t$8(function(param){return _bR_},x_176)}
      return caml_call4(Base_Invariant[1],_bS_,t,_c8_,_c7_)}
    var debug=0;
    function advance_clock(t,to,handle_fired)
     {var _c4_=caml_call2(Core_Time_ns_alternate_sexp[97],to,t[4]);
      if(_c4_)
       {t[4] = to;
        var key$0=interval_num_unchecked(t,to);
        t[5] = interval_num_start_unchecked(t,key$0);
        var _c5_=t[7];
        if(caml_call2(symbol$16,key$0,min_allowed_key$1(_c5_)))
         var match=0;
        else
         {var
           level_index=[0,0],
           result=[0,1],
           prev_level_max_allowed_key=[0,caml_call1(pred$0,key$0)],
           levels=_c5_[5],
           num_levels$0=num_levels(_c5_);
          a:
          for(;;)
           {if(caml_call2(Core[92],level_index[1],num_levels$0))
             {var
               _c3_=level_index[1],
               level=caml_check_bound(levels,_c3_)[1 + _c3_],
               min_allowed_key_before=level[9],
               desired_min_allowed_key=
                compute_min_allowed_key(level,prev_level_max_allowed_key[1]),
               level_min_allowed_key=
                min_key_in_same_slot$0
                 (level,
                  caml_call2
                   (min$0,
                    desired_min_allowed_key,
                    caml_call2(max$0,level[9],_c5_[4]))),
               level_min_allowed_key$0=[0,level_min_allowed_key],
               slot$0=[0,slot(level,level_min_allowed_key$0[1])],
               keys_per_slot=level[5],
               slots=level[11];
              for(;;)
               {if
                 (!
                  caml_call2
                   (symbol$19,
                    level_min_allowed_key$0[1],
                    desired_min_allowed_key))
                 {level[9] = desired_min_allowed_key;
                  level[10]
                  =
                  add_clamp_to_max(desired_min_allowed_key,level[7]);
                  if(caml_call2(equal$3,level[9],min_allowed_key_before))
                   {level_index[1] = num_levels$0;result[1] = 0}
                  else
                   {level_index[1] = level_index[1] + 1 | 0;
                    prev_level_max_allowed_key[1] = level[10]}
                  continue a}
                if(caml_call2(Core[90],level[8],0))
                 {level_min_allowed_key$0[1] = desired_min_allowed_key;
                  continue}
                var
                 _c0_=slot$0[1],
                 first=caml_check_bound(slots,_c0_)[1 + _c0_];
                if(1 - caml_call1(is_null,first))
                 {var _c1_=caml_call1(null$1,0),_c2_=slot$0[1];
                  caml_check_bound(slots,_c2_)[1 + _c2_] = _c1_;
                  var pool=_c5_[2],current=[0,first],continue$0=[0,1];
                  for(;;)
                   {if(continue$0[1])
                     {var next$0=next(pool,current[1]);
                      level[8] = level[8] - 1 | 0;
                      if(caml_call2(symbol$15,key(pool,current[1]),key$0))
                       add_elt(_c5_,current[1]);
                      else
                       {_c5_[1] = _c5_[1] - 1 | 0;
                        caml_call1(handle_fired,current[1]);
                        caml_call2(free,pool,current[1])}
                      if(caml_call2(Core[246],next$0,first))
                       continue$0[1] = 0;
                      else
                       current[1] = next$0;
                      continue}
                    break}}
                slot$0[1] = next_slot(level,slot$0[1]);
                level_min_allowed_key$0[1]
                =
                add_clamp_to_max(level_min_allowed_key$0[1],keys_per_slot)}}
            if(caml_call2(symbol$18,key$0,_c5_[4]))
             {_c5_[3] = caml_call1(null$1,0);
              _c5_[4] = min_allowed_key$1(_c5_)}
            var match=result[1];
            break}}
        if(match){t[6] = compute_max_allowed_alarm_time(t);return 0}
        var _c6_=debug}
      else
       var _c6_=_c4_;
      return _c6_}
    function create$2(config,start)
     {if
       (caml_call2
         (Core_Time_ns_alternate_sexp[98],
          start,
          Core_Time_ns_alternate_sexp[43]))
       {var
         _cP_=
          [0,
           [1,
            [0,_bT_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],start),0]]],
           0],
         _cQ_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_create_got_st),
            _cP_]];
        caml_call1(Core[253],_cQ_)}
      var l=config[2],_cR_=config[3];
      function _cL_(index,param,level_bits)
       {var
         levels=param[3],
         max_level_min_allowed_key=param[2],
         bits_per_slot=param[1],
         keys_per_slot=num_keys(bits_per_slot),
         diff_max_min_allowed_key=
          compute_diff_max_min_allowed_k(level_bits,bits_per_slot),
         min_key_in_same_slot_mask=create$1(bits_per_slot),
         min_allowed_key=
          min_key_in_same_slot
           (max_level_min_allowed_key,min_key_in_same_slot_mask),
         t=add_clamp_to_max(min_allowed_key,diff_max_min_allowed_key),
         _cU_=caml_call1(null$1,0),
         _cV_=pow2(level_bits),
         _cW_=caml_call1(Core_Int63[5],_cV_),
         _cX_=caml_call2(Core_Array[38],_cW_,_cU_),
         level=
          [0,
           index,
           level_bits,
           create$0(level_bits),
           bits_per_slot,
           keys_per_slot,
           min_key_in_same_slot_mask,
           diff_max_min_allowed_key,
           0,
           min_allowed_key,
           t,
           _cX_],
         _cY_=[0,level,levels],
         _cZ_=
          caml_call2(symbol$17,t,max_value$0)?max_value$0:caml_call1(succ$0,t);
        return [0,symbol$2(level_bits,bits_per_slot),_cZ_,_cY_]}
      var
       match=caml_call3(Core_List[95],l,[0,zero,zero$1,0],_cL_),
       levels=match[3],
       _cM_=caml_call1(Core_Array[90],levels),
       _cN_=caml_call1(null$1,0);
      if(_cR_)var sth=_cR_[1],capacity=sth;else var capacity=1;
      var
       _cO_=
        [0,
         0,
         caml_call2(Tuple_pool[36][35],Tuple_pool[36][1][22],capacity),
         _cN_,
         zero$1,
         _cM_],
       _cS_=Core_Time_ns_alternate_sexp[46],
       _cT_=Core_Time_ns_alternate_sexp[46],
       t=
        [0,
         config,
         start,
         interval_num_internal(max_time,config[1]),
         _cT_,
         _cS_,
         max_time,
         _cO_];
      t[6] = compute_max_allowed_alarm_time(t);
      advance_clock(t,start,function(param){throw [0,Assert_failure,_bU_]});
      return t}
    function add_at_interval_num(t,at,value)
     {var _cK_=interval_num_start(t,at);
      return internal_add(t[7],at,_cK_,value)}
    function ensure_can_schedule_alarm(t,at)
     {if(caml_call2(Core_Time_ns_alternate_sexp[97],at,t[6]))
       {var
         _cD_=
          [0,
           [1,[0,_bV_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],t[6]),0]]],
           0],
         _cE_=
          [0,
           [1,[0,_bW_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],at),0]]],
           _cD_],
         _cF_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_cannot_schedu),
            _cE_]];
        caml_call1(Core[253],_cF_)}
      var _cJ_=caml_call2(Core_Time_ns_alternate_sexp[98],at,t[5]);
      if(! _cJ_)return _cJ_;
      var
       _cG_=
        [0,
         [1,[0,_bX_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],t[5]),0]]],
         0],
       _cH_=
        [0,
         [1,[0,_bY_,[0,caml_call1(Core_Time_ns_alternate_sexp[92],at),0]]],
         _cG_],
       _cI_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_cannot_schedu$0),
          _cH_]];
      return caml_call1(Core[253],_cI_)}
    function add$0(t,at,value)
     {ensure_can_schedule_alarm(t,at);
      var _cC_=interval_num_unchecked(t,at);
      return internal_add(t[7],_cC_,at,value)}
    function remove(t,alarm)
     {var _cB_=t[7],pool=_cB_[2],elt=of_external_exn(pool,alarm);
      internal_remove(_cB_,elt);
      return caml_call2(free,pool,elt)}
    function clear(t)
     {var _cA_=t[7],_cr_=1 - is_empty(_cA_);
      if(_cr_)
       {_cA_[1] = 0;
        var
         pool=_cA_[2],
         free_elt=function(elt){return caml_call2(free,pool,elt)},
         levels=_cA_[5],
         _ct_=levels.length - 1 - 1 | 0,
         _cs_=0;
        if(_ct_ >= 0)
         {var level_index=_cs_;
          for(;;)
           {var level=caml_check_bound(levels,level_index)[1 + level_index];
            if(caml_call2(Core[91],level[8],0))
             {level[8] = 0;
              var slots=level[11],_cw_=slots.length - 1 - 1 | 0,_cv_=0;
              if(_cw_ >= 0)
               {var slot_index=_cv_;
                for(;;)
                 {var elt=caml_check_bound(slots,slot_index)[1 + slot_index];
                  if(1 - caml_call1(is_null,elt))
                   {iter(pool,elt,free_elt);
                    var _cy_=caml_call1(null$1,0);
                    caml_check_bound(slots,slot_index)[1 + slot_index] = _cy_}
                  var _cz_=slot_index + 1 | 0;
                  if(_cw_ !== slot_index){var slot_index=_cz_;continue}
                  break}}}
            var _cx_=level_index + 1 | 0;
            if(_ct_ !== level_index){var level_index=_cx_;continue}
            break}}
        var _cu_=0}
      else
       var _cu_=_cr_;
      return _cu_}
    function mem(t,alarm){return is_valid(t[7][2],alarm)}
    function reschedule_gen(t$0,alarm,k,x)
     {if(1 - mem(t$0,alarm))
       caml_call1(Core[6],cst_Timing_wheel_cannot_resche);
      ensure_can_schedule_alarm(t$0,x);
      var _cq_=t$0[7];
      ensure_valid_key(_cq_,k);
      var pool=_cq_[2],t=of_external_exn(pool,alarm);
      internal_remove(_cq_,t);
      caml_call4(Tuple_pool[36][33],pool,t,Tuple_pool[36][2][3],k);
      caml_call4(Tuple_pool[36][33],pool,t,Tuple_pool[36][2][4],x);
      return internal_add_elt(_cq_,t)}
    function reschedule(t,alarm,at)
     {return reschedule_gen(t,alarm,interval_num_unchecked(t,at),at)}
    function reschedule_at_interval_num(t,alarm,at)
     {return reschedule_gen(t,alarm,at,interval_num_start(t,at))}
    function min_alarm_interval_num(t)
     {var elt=min_elt$1(t[7]);
      return caml_call1(is_null,elt)?0:[0,key(pool$1(t),elt)]}
    function min_alarm_interval_num_exn(t)
     {var elt=min_elt$1(t[7]);
      if(! caml_call1(is_null,elt))return key(pool$1(t),elt);
      var
       _cm_=0,
       _cn_=0,
       _co_=
        [0,
         [1,[0,_b0_,[0,sexp_of_t$8(function(param){return _bZ_},t),_cn_]]],
         _cm_],
       _cp_=
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_min_alarm_int),
          _co_]];
      return caml_call1(Core[253],_cp_)}
    function max_alarm_time_in_list(t,first)
     {var
       pool=pool$1(t),
       with_key=key(pool,first),
       max_alarm_time=[0,Core_Time_ns_alternate_sexp[43]],
       current=[0,first],
       continue$0=[0,1];
      for(;;)
       {if(! continue$0[1])return max_alarm_time[1];
        var next$0=next(pool,current[1]);
        if(caml_call2(equal$3,key(pool,current[1]),with_key))
         {var _ck_=max_alarm_time[1],_cl_=at(pool,current[1]);
          max_alarm_time[1]
          =
          caml_call2(Core_Time_ns_alternate_sexp[103],_cl_,_ck_)}
        if(caml_call2(Core[246],next$0,first))
         continue$0[1] = 0;
        else
         current[1] = next$0}}
    function min_alarm_time_in_list(t,first)
     {var
       pool=pool$1(t),
       with_key=key(pool,first),
       min_alarm_time=[0,Core_Time_ns_alternate_sexp[45]],
       current=[0,first],
       continue$0=[0,1];
      for(;;)
       {if(! continue$0[1])return min_alarm_time[1];
        var next$0=next(pool,current[1]);
        if(caml_call2(equal$3,key(pool,current[1]),with_key))
         {var _ci_=min_alarm_time[1],_cj_=at(pool,current[1]);
          min_alarm_time[1]
          =
          caml_call2(Core_Time_ns_alternate_sexp[102],_cj_,_ci_)}
        if(caml_call2(Core[246],next$0,first))
         continue$0[1] = 0;
        else
         current[1] = next$0}}
    function max_alarm_time_in_min_interval(t)
     {var elt=min_elt$1(t[7]);
      return caml_call1(is_null,elt)?0:[0,max_alarm_time_in_list(t,elt)]}
    function min_alarm_time_in_min_interval(t)
     {var elt=min_elt$1(t[7]);
      return caml_call1(is_null,elt)?0:[0,min_alarm_time_in_list(t,elt)]}
    function max_alarm_time_in_min_interval$0(t)
     {var elt=min_elt$1(t[7]);
      if(caml_call1(is_null,elt))
       {var
         _ce_=0,
         _cf_=0,
         _cg_=
          [0,
           [1,[0,_b2_,[0,sexp_of_t$8(function(param){return _b1_},t),_cf_]]],
           _ce_],
         _ch_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_max_alarm_tim),
            _cg_]];
        caml_call1(Core[253],_ch_)}
      return max_alarm_time_in_list(t,elt)}
    function min_alarm_time_in_min_interval$0(t)
     {var elt=min_elt$1(t[7]);
      if(caml_call1(is_null,elt))
       {var
         _ca_=0,
         _cb_=0,
         _cc_=
          [0,
           [1,[0,_b4_,[0,sexp_of_t$8(function(param){return _b3_},t),_cb_]]],
           _ca_],
         _cd_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_Timing_wheel_max_alarm_tim$0),
            _cc_]];
        caml_call1(Core[253],_cd_)}
      return min_alarm_time_in_list(t,elt)}
    function fire_past_alarms(t,handle_fired)
     {var
       _b__=t[4],
       key=min_allowed_alarm_interval_num(t),
       _b$_=t[7],
       level=caml_check_bound(_b$_[5],0)[1],
       _b5_=caml_call2(Core[91],level[8],0);
      if(_b5_)
       {var
         slot$0=slot(level,key),
         slots=level[11],
         pool=_b$_[2],
         first=[0,caml_check_bound(slots,slot$0)[1 + slot$0]],
         _b6_=1 - caml_call1(is_null,first[1]);
        if(_b6_)
         {var current=[0,first[1]],continue$0=[0,1];
          for(;;)
           {if(continue$0[1])
             {var elt=current[1],next$0=next(pool,elt);
              if(caml_call2(Core[246],next$0,first[1]))
               continue$0[1] = 0;
              else
               current[1] = next$0;
              var _b7_=at(pool,elt);
              if(caml_call2(Core_Time_ns_alternate_sexp[95],_b7_,_b__))
               {caml_call1(handle_fired,elt);
                internal_remove(_b$_,elt);
                caml_call2(free,pool,elt);
                first[1] = caml_check_bound(slots,slot$0)[1 + slot$0]}
              continue}
            var _b8_=0;
            break}}
        else
         var _b8_=_b6_;
        var _b9_=_b8_}
      else
       var _b9_=_b5_;
      return _b9_}
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_timing_wheel$7);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Timing_wheel$0);
    var
     Timing_wheel$0=
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_sexpable,
        of_sexpable,
        to_sexpable,
        one_nanosecond,
        about_one_day,
        about_one_microsecond,
        about_one_millisecond,
        about_one_second,
        mul,
        div,
        _l_],
       sexp_of_t$8,
       sexp_of_t_now,
       _be_,
       [0,sexp_of_t$6,null$0,at$0,interval_num,value$0],
       invariant$1,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        f,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$0,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       min_allowed_alarm_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       fire_past_alarms,
       max_allowed_alarm_time,
       min_allowed_alarm_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0,max_time,interval_num_internal,[0,invariant,zero]]];
    caml_register_global(236,Timing_wheel$0,"Timing_wheel");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzEwOCIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMzkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImYiLCJudW1fa2V5X2JpdHMiLCJ0X29mX3NleHAkMCIsInNleHAiLCJjcmVhdGVfZXhuIiwib3B0IiwiaW50cyIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyQwIiwibGV2ZWxfYml0c19kZWZhdWx0IiwiY29tcGFyZSIsImVxdWFsJDAiLCJ4XzAxMiIsInhfMDEzIiwidG9fc2V4cGFibGUiLCJzZXhwX29mX3QkMSIsIm9uZV9uYW5vc2Vjb25kIiwiYWJvdXRfb25lX21pY3Jvc2Vjb25kIiwiYWJvdXRfb25lX21pbGxpc2Vjb25kIiwiYWJvdXRfb25lX3NlY29uZCIsImFib3V0X29uZV9kYXkiLCJtdWwiLCJkaXYiLCJvZl9zZXhwYWJsZSIsInNwYW4iLCJsZXZlbF9iaXRzIiwiciIsInYiLCJsZXZlbF9iaXRzJDAiLCJ0X29mX3NleHAkMiIsInNleHBfMDE5IiwiZmllbGRfc2V4cHNfMDIwIiwiYWxhcm1fcHJlY2lzaW9uXzAyMSIsImxldmVsX2JpdHNfMDIzIiwiY2FwYWNpdHlfMDI1IiwiZHVwbGljYXRlc18wMjciLCJleHRyYV8wMjgiLCJ0YWlsXzA0MSIsImZpZWxkX3NleHBfMDMwJDMiLCJmaWVsZF9zZXhwXzAzMCIsInhfMDQyIiwiZmllbGRfc2V4cF8wMzAkMCIsImZ2YWx1ZV8wMzQiLCJmaWVsZF9zZXhwXzAzMCQxIiwiZnZhbHVlXzAzMiIsImZpZWxkX3NleHBfMDMwJDIiLCJmdmFsdWVfMDM1IiwiYWxhcm1fcHJlY2lzaW9uXzAyMiIsInZfMDM4Iiwidl8wMzgkMCIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDQ4IiwibGV2ZWxfYml0c18wNDYiLCJhbGFybV9wcmVjaXNpb25fMDQ0IiwiYm5kc18wNDMiLCJ2XzA0OSIsImFyZ18wNTEiLCJibmRfMDUwIiwiYm5kc18wNDMkMCIsImFyZ18wNDciLCJibmRzXzA0MyQxIiwiYXJnXzA0NSIsImJuZHNfMDQzJDIiLCJhbGFybV9wcmVjaXNpb24iLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMCIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJsb29wIiwicmVtYWluaW5nIiwidCQwIiwiYiIsIm1pY3Jvc2Vjb25kX3ByZWNpc2lvbiIsImR1cmF0aW9ucyIsIm51bV9iaXRzX2FjY3VtIiwibGV2ZWxfbnVtX2JpdHMiLCJudW1fYml0c19hY2N1bSQwIiwiZHVyYXRpb24iLCJjb21wYXJlJDAiLCJzZXhwaWZpZXIiLCJjcmVhdGUkMCIsIm51bV9rZXlzIiwiY3JlYXRlJDEiLCJiaXRzX3Blcl9zbG90IiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInNleHBpZmllciQwIiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsIm1pbl9rZXlfaW5fc2FtZV9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDU0IiwieF8wNTUiLCJzZXhwX29mX3QkNiIsIm9mX2FfMDU2IiwieF8wNTciLCJudWxsJDAiLCJudWxsJDEiLCJpc19udWxsIiwiZnJlZSIsImtleSIsInAiLCJhdCIsInZhbHVlIiwibGV2ZWxfaW5kZXgiLCJwcmV2Iiwic2V0X3ByZXYiLCJ4IiwibmV4dCIsInNldF9uZXh0IiwiaXNfdmFsaWQiLCJncm93IiwiaXNfZnVsbCIsIm9mX2V4dGVybmFsX2V4biIsInBvb2wiLCJsaW5rIiwiaXRlciIsImZpcnN0IiwiY3VycmVudCIsImNvbnRpbnVlJDAiLCJuZXh0JDAiLCJzbG90cyIsIm1heF9hbGxvd2VkX2tleSIsInNldF9tYXhfYWxsb3dlZF9rZXkiLCJtaW5fYWxsb3dlZF9rZXkiLCJzZXRfbWluX2FsbG93ZWRfa2V5IiwibGVuZ3RoIiwic2V0X2xlbmd0aCIsImRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSIsImtleXNfcGVyX3Nsb3QiLCJzbG90c19tYXNrIiwiaW5kZXgiLCJzbG90cyQwIiwibWF4X2FsbG93ZWRfa2V5JDAiLCJtaW5fYWxsb3dlZF9rZXkkMCIsImxlbmd0aCQwIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5JDAiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrJDAiLCJrZXlzX3Blcl9zbG90JDAiLCJiaXRzX3Blcl9zbG90JDAiLCJzbG90c19tYXNrJDAiLCJiaXRzJDAiLCJpbmRleCQwIiwic2V4cF9vZl90JDciLCJvZl9hXzA2NSIsImRpZmZfbWF4X21pbl9hbGxvd2VkX2tleV8wNzkiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXzA3NyIsImtleXNfcGVyX3Nsb3RfMDc1IiwiYml0c19wZXJfc2xvdF8wNzMiLCJzbG90c19tYXNrXzA3MSIsImJpdHNfMDY5IiwiaW5kZXhfMDY3IiwibGVuZ3RoXzA4MSIsIm1pbl9hbGxvd2VkX2tleV8wODMiLCJtYXhfYWxsb3dlZF9rZXlfMDg1Iiwic2xvdHNfMDg3IiwiYXJnXzA4OCIsImJuZHNfMDY2IiwiYXJnXzA4NiIsImJuZHNfMDY2JDAiLCJhcmdfMDg0IiwiYm5kc18wNjYkMSIsImFyZ18wODIiLCJibmRzXzA2NiQyIiwiYXJnXzA4MCIsImJuZHNfMDY2JDMiLCJhcmdfMDc4IiwiYm5kc18wNjYkNCIsImFyZ18wNzYiLCJibmRzXzA2NiQ1IiwiYXJnXzA3NCIsImJuZHNfMDY2JDYiLCJhcmdfMDcyIiwiYm5kc18wNjYkNyIsImFyZ18wNzAiLCJibmRzXzA2NiQ4IiwiYXJnXzA2OCIsImJuZHNfMDY2JDkiLCJzbG90IiwibmV4dF9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3QkMCIsImNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkiLCJsZXZlbHMiLCJlbHRfa2V5X2xvd2VyX2JvdW5kIiwic2V0X2VsdF9rZXlfbG93ZXJfYm91bmQiLCJtaW5fZWx0Iiwic2V0X21pbl9lbHQiLCJzZXRfcG9vbCIsImxlbmd0aCQxIiwic2V0X2xlbmd0aCQwIiwibGV2ZWxzJDAiLCJlbHRfa2V5X2xvd2VyX2JvdW5kJDAiLCJtaW5fZWx0JDAiLCJwb29sJDAiLCJsZW5ndGgkMiIsImlzX2VtcHR5IiwibnVtX2xldmVscyIsIm1pbl9hbGxvd2VkX2tleSQxIiwibWF4X2FsbG93ZWRfa2V5JDEiLCJpbnRlcm5hbF9pdGVyIiwibGV2ZWwiLCJzbG90X2luZGV4IiwiZWx0IiwiY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rIiwibWluX2VsdCQxIiwibWluX2VsdF9hbHJlYWR5X2ZvdW5kIiwibWluX2tleV9hbHJlYWR5X2ZvdW5kIiwibnVtX2xldmVscyQwIiwic2xvdF9taW5fa2V5Iiwic2xvdCQwIiwiY3VycmVudF9rZXkiLCJhZGRfZWx0IiwidG9fYWRkIiwia2V5JDAiLCJlbHRzXzExNSIsIm1heF9hbGxvd2VkX2tleV8xMTMiLCJtaW5fYWxsb3dlZF9rZXlfMTExIiwiYm5kc18xMTAiLCJrZXlfMTA1IiwiYm5kc18xMDQiLCJhcmdfMTA2IiwiYm5kc18xMDQkMCIsImFyZ18xMTYiLCJibmRzXzExMCQwIiwiYXJnXzExNCIsImJuZHNfMTEwJDEiLCJhcmdfMTEyIiwiYm5kc18xMTAkMiIsImxldmVsX2luZGV4JDAiLCJwcmV2JDAiLCJpbnRlcm5hbF9hZGRfZWx0IiwiZW5zdXJlX3ZhbGlkX2tleSIsImludGVybmFsX2FkZCIsImludGVybmFsX3JlbW92ZSIsIm1pbl9pbnRlcnZhbF9udW0iLCJwcmlvcml0eV9xdWV1ZSIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJzZXRfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJzZXRfbm93X2ludGVydmFsX251bV9zdGFydCIsIm5vdyIsInNldF9ub3ciLCJtYXhfaW50ZXJ2YWxfbnVtIiwic3RhcnQiLCJjb25maWciLCJwcmlvcml0eV9xdWV1ZSQwIiwibWF4X2FsbG93ZWRfYWxhcm1fdGltZSQwIiwibm93X2ludGVydmFsX251bV9zdGFydCQwIiwibm93JDAiLCJtYXhfaW50ZXJ2YWxfbnVtJDAiLCJzdGFydCQwIiwiY29uZmlnJDAiLCJzZXhwX29mX3Rfbm93IiwiYWxhcm1fcHJlY2lzaW9uJDAiLCJhdCQwIiwidHciLCJ2YWx1ZSQwIiwiaW50ZXJ2YWxfbnVtIiwiaXRlciQwIiwiY29tcGFyZSQzIiwic2V4cF9vZl90JDgiLCJzZXhwX29mX2EiLCJtYXhfaW50ZXJ2YWxfbnVtXzE2NyIsInN0YXJ0XzE2NSIsImNvbmZpZ18xNjMiLCJub3dfMTY5IiwiYSIsImFsYXJtc18xNzEiLCJibmRzXzE2MiIsInZhbHVlXzE1OSIsImF0XzE1NyIsImFyZ18xNjAiLCJibmRzXzE1NiIsImFyZ18xNTgiLCJibmRzXzE1NiQwIiwiYXJnXzE3MiIsImJuZHNfMTYyJDAiLCJhcmdfMTcwIiwiYm5kc18xNjIkMSIsImFyZ18xNjgiLCJibmRzXzE2MiQyIiwiYXJnXzE2NiIsImJuZHNfMTYyJDMiLCJhcmdfMTY0IiwiYm5kc18xNjIkNCIsImxlbmd0aCQzIiwiaXNfZW1wdHkkMCIsInBvb2wkMSIsImludGVydmFsX251bV9pbnRlcm5hbCIsInRpbWUiLCJpbnRlcnZhbF9udW1fdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtJDAiLCJpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtX3N0YXJ0IiwibmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCIsIm5leHRfYWxhcm1fZmlyZXNfYXQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biIsImNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSIsIm1pbl9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSIsIm1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSIsImludGVydmFsX3N0YXJ0IiwiaW52YXJpYW50JDEiLCJpbnZhcmlhbnRfYSIsImNoZWNrIiwicHJpb3JpdHlfcXVldWVfZnVuIiwibGV2ZWxzX2Z1biIsInNsb3RzX2Z1biIsIm4iLCJ4XzA2MiIsIm1heF9hbGxvd2VkX2tleV9mdW4iLCJnb3QiLCJleHBlY3QiLCJlcXVhbCIsIm1lc3NhZ2UiLCJoZXJlIiwiY29tcGFyYXRvciIsImFfMTI4IiwiYl8xMjkiLCJtaW5fYWxsb3dlZF9rZXlfZnVuIiwiYV8xMjYiLCJiXzEyNyIsImxlbmd0aF9mdW4iLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXlfZnVuIiwiYV8xMjQiLCJiXzEyNSIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfZnVuIiwia2V5c19wZXJfc2xvdF9mdW4iLCJhXzEyMiIsImJfMTIzIiwiYml0c19wZXJfc2xvdF9mdW4iLCJleHBlY3QkMCIsInNsb3RzX21hc2tfZnVuIiwiYV8xMjAiLCJiXzEyMSIsImJpdHNfZnVuIiwiaW5kZXhfZnVuIiwieF8xMTkiLCJwcmV2X2xldmVsIiwic2V4cGlmaWVyJDEiLCJhXzEzMSIsImJfMTMyIiwibWVzc2FnZSQwIiwiaGVyZSQwIiwiY29tcGFyYXRvciQwIiwiYV8xMzMiLCJiXzEzNCIsImVsdF9rZXlfbG93ZXJfYm91bmRfZnVuIiwibWluX2VsdF9mdW4iLCJwb29sX2Z1biIsInhfMTMwIiwib2ZfYV8wNjMiLCJsZW5ndGhfMDkxIiwicG9vbF8wOTMiLCJtaW5fZWx0XzA5NSIsImVsdF9rZXlfbG93ZXJfYm91bmRfMDk3IiwibGV2ZWxzXzA5OSIsImJuZHNfMDkwIiwiYXJnXzEwMCIsImJuZHNfMDkwJDAiLCJhcmdfMDk4IiwiYm5kc18wOTAkMSIsImFyZ18wOTYiLCJibmRzXzA5MCQyIiwiYXJnXzA5NCIsImJuZHNfMDkwJDMiLCJhcmdfMDkyIiwiYm5kc18wOTAkNCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWVfZnVuIiwiYV8xODMiLCJiXzE4NCIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnRfZnVuIiwiYV8xODEiLCJiXzE4MiIsIm5vd19mdW4iLCJtYXhfaW50ZXJ2YWxfbnVtX2Z1biIsImFfMTc3IiwiYl8xNzgiLCJnb3QkMCIsImFfMTc5IiwiYl8xODAiLCJzdGFydF9mdW4iLCJjb25maWdfZnVuIiwiYWxhcm0iLCJ4XzE3NiIsImRlYnVnIiwiYWR2YW5jZV9jbG9jayIsInRvIiwiaGFuZGxlX2ZpcmVkIiwicmVzdWx0IiwibWluX2FsbG93ZWRfa2V5X2JlZm9yZSIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5JDAiLCJjcmVhdGUkMiIsImwiLCJtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwiYWRkX2F0X2ludGVydmFsX251bSIsImVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0iLCJhZGQkMCIsInJlbW92ZSIsImNsZWFyIiwiZnJlZV9lbHQiLCJtZW0iLCJyZXNjaGVkdWxlX2dlbiIsImsiLCJyZXNjaGVkdWxlIiwicmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIiwibWluX2FsYXJtX2ludGVydmFsX251bV9leG4iLCJtYXhfYWxhcm1fdGltZV9pbl9saXN0Iiwid2l0aF9rZXkiLCJtYXhfYWxhcm1fdGltZSIsIm1pbl9hbGFybV90aW1lX2luX2xpc3QiLCJtaW5fYWxhcm1fdGltZSIsIm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCIsIm1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCIsIm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCQwIiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJmaXJlX3Bhc3RfYWxhcm1zIl0sInNvdXJjZXMiOlsiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2NvcmVfa2VybmVsL3RpbWluZ193aGVlbC90aW1pbmdfd2hlZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7O0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E4bEQwQkE7S0FIQUM7S0FnQkFDO0tBS0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EveEJoQkM7OztLQTRKc0JDO0tBSEFDO0tBckdEQztLQU9EQztLQVlDQztLQWtCQ0M7S0FLRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcnNCNUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FyTEVDO0tBQ0FDOzs7Ozs7Ozs7S0FzREVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBakNBQzthQUtBQyxVQUFVQztNQUNMLHVCQURLQSxFQUxWRjtNQU9LLHVCQUZLRSxFQTRCVkg7a0NBMUJxQjthQUdyQkksT0FBT0MsR0FDVCxVQURTQSxHQUNULE9BRFNBLENBRVI7YUFHQ0MsU0FBTUMsR0FBR0MsSUFDWCxJQUFJTCxFQURJSSxLQUFHQyxPQUVYLFVBRElMLEdBQ0osT0FESUEsQ0FFSDthQUdDTSxTQUFNRixHQUFHQyxJQUNYLElBQUlMLEVBRElJLEtBQUdDLE9BRVgsVUFESUwsR0FDSixPQURJQSxDQUVIO2FBR0NPLEtBQUtQ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O1FBRUFFO1FBQ0FDOztPQXl4Q0ZzUDtPQXJEQVI7O1VBSUZoSyxZQUVJRyxPQUNBK0osS0FFQUcsYUFEQUQ7T0FnS0Y2Qzs7UUF4OUNFclQ7UUFkSk47UUEwSmNJO1FBeEpWZjtRQWtCQW1CO1FBMEdBTztRQTFIQVo7O1FBNEhKZ0M7O1FBb0JJb0M7UUFhQUU7UUExQkFKO1FBTEF0QztRQTZDQWlEO1FBUEFEO09BcTRDRndVO09BOU9BNUk7T0FYUWI7T0FIUkc7T0F5RUEyQztPQURBRDtPQTlDQTNCO09Bd0VBaUM7T0ErRUFPO09BaERBTDtPQWtEQU87T0FxREFxRjtPQStKQWlDO09BbFlRdEw7T0E0S1I4RDtPQUNBQztPQWdJQW1HO09BL0JBRjtPQTJDQU07T0FGQUg7T0FXQU07T0FFQUM7T0FaQU47T0FnQkFPO09BS0FDO09BcUJBTTtPQUtBQztPQUtBQztPQVdBQztPQTFPQTFIO09BV0FDO1VBbmdEQW5VLFNBZzhDQTJULHlCQXI2Q0V2VDs7VSIsInNvdXJjZXNDb250ZW50IjpbIigqIEJlIHN1cmUgYW5kIGZpcnN0IHJlYWQgdGhlIGltcGxlbWVudGF0aW9uIG92ZXJ2aWV3IGluIHRpbWluZ193aGVlbF9pbnRmLm1sLlxuXG4gICBBIHRpbWluZyB3aGVlbCBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBcImxldmVsc1wiLCB3aGVyZSBlYWNoIGxldmVsIGlzIGFuIGFycmF5IG9mXG4gICBcInNsb3RzXCIuICBFYWNoIHNsb3QgcmVwcmVzZW50cyBhIHJhbmdlIG9mIGtleXMsIGFuZCBob2xkcyBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGhcbiAgIHRob3NlIGtleXMuICBFYWNoIGxldmVsIGlzIGRldGVybWluZWQgYnkgdHdvIHBhcmFtZXRlcnM6IFtiaXRzXSwgdGhlIG51bWJlciBvZiBrZXkgYml0c1xuICAgdGhhdCB0aGF0IGxldmVsIGlzIHJlc3BvbnNpYmxlIGZvciBkaXN0aW5ndWlzaGluZywgYW5kIFtiaXRzX3Blcl9zbG90XSwgdGhlIHNpemUgb2YgdGhlXG4gICByYW5nZSBvZiBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBzbG90IGluIHRoZSBhcnJheS4gIENvbmNlcHR1YWxseSwgZWFjaCBsZXZlbFxuICAgYnJlYWtzIHVwIGFsbCBwb3NzaWJsZSBrZXlzIGludG8gcmFuZ2VzIG9mIHNpemUgWzJeYml0c19wZXJfc2xvdF0uICBUaGUgbGVuZ3RoIG9mIGFcbiAgIGxldmVsIGFycmF5IGlzIFsyXmJpdHNdLCBhbmQgdGhlIGFycmF5IGlzIHVzZWQgbGlrZSBhIGNpcmN1bGFyIGJ1ZmZlciB0byB0cmF2ZXJzZSB0aGVcbiAgIHJhbmdlcyBhcyB0aGUgdGltaW5nIHdoZWVsJ3MgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLiAgQSBrZXkgW2tdLCBpZiBzdG9yZWQgaW4gdGhlXG4gICBsZXZlbCwgaXMgc3RvcmVkIGF0IGluZGV4IFsoayAvIDJeYml0c19wZXJfc2xvdCkgbW9kIDJeYml0c10uXG5cbiAgIFRoZSBzZXR0aW5ncyBvZiB0aGUgW2JpdHNdIHZhbHVlcyBhcmUgY29uZmlndXJhYmxlIGJ5IHVzZXIgY29kZSB1c2luZyBbTGV2ZWxfYml0c10sXG4gICBhbHRob3VnaCB0aGVyZSBpcyBhIHJlYXNvbmFibGUgZGVmYXVsdCBzZXR0aW5nLiAgR2l2ZW4gdGhlIFtiaXRzXSB2YWx1ZXMsIHRoZVxuICAgW2JpdHNfcGVyX3Nsb3RdIGFyZSBjaG9zZW4gc28gdGhhdCBbYml0c19wZXJfc2xvdF0gYXQgbGV2ZWwgW2ldIGlzIHRoZSBzdW0gb2YgdGhlXG4gICBbYml0c10gYXQgYWxsIGxvd2VyIGxldmVscy4gIFRodXMsIGEgc2xvdCdzIHJhbmdlIGF0IGxldmVsIFtpXSBpcyBhcyBsYXJnZSBhcyB0aGVcbiAgIGVudGlyZSByYW5nZSBvZiB0aGUgYXJyYXkgYXQgbGV2ZWwgW2kgLSAxXS5cblxuICAgRWFjaCBsZXZlbCBoYXMgYSBbbWluX2FsbG93ZWRfa2V5XSBhbmQgYSBbbWF4X2FsbG93ZWRfa2V5XSB0aGF0IGRldGVybWluZSB0aGUgcmFuZ2Ugb2ZcbiAgIGtleXMgdGhhdCBpdCBjdXJyZW50bHkgcmVwcmVzZW50cy4gIFRoZSBjcnVjaWFsIGludmFyaWFudCBvZiB0aGUgdGltaW5nIHdoZWVsIGRhdGFcbiAgIHN0cnVjdHVyZSBpcyB0aGF0IHRoZSBbbWluX2FsbG93ZWRfa2V5XSBhdCBsZXZlbCBbaV0gaXMgbm8gbW9yZSB0aGFuIHRoZVxuICAgW21heF9hbGxvd2VkX2tleSArIDFdIG9mIGxldmVsIFtpIC0gMV0uICBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbGV2ZWxzIGNhbiByZXByZXNlbnQgYWxsXG4gICBrZXlzIGZyb20gdGhlIFttaW5fYWxsb3dlZF9rZXldIG9mIHRoZSBsb3dlc3QgbGV2ZWwgdG8gdGhlIFttYXhfYWxsb3dlZF9rZXldIG9mIHRoZVxuICAgaGlnaGVzdCBsZXZlbC4gIFRoZSBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcmVzdG9yaW5nXG4gICB0aGlzIGludmFyaWFudC5cblxuICAgQXQgbGV2ZWwgMCwgW2JpdHNfcGVyX3Nsb3QgPSAwXSwgYW5kIHNvIHRoZSBzaXplIG9mIGVhY2ggc2xvdCBpcyBbMV0uICBUaGF0IGlzLCBsZXZlbCAwXG4gICBwcmVjaXNlbHkgZGlzdGluZ3Vpc2hlcyBhbGwgdGhlIGtleXMgYmV0d2VlbiBpdHMgW21pbl9hbGxvd2VkX2tleV0gKHdoaWNoIGlzIHRoZSBzYW1lXG4gICBhcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGVudGlyZSB0aW1pbmcgd2hlZWwpIGFuZCBbbWF4X2FsbG93ZWRfa2V5XS4gIEFzIHRoZVxuICAgbGV2ZWxzIGluY3JlYXNlLCB0aGUgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCB0aGUgW2JpdHNfcGVyX3Nsb3RdIGluY3JlYXNlcywgYW5kXG4gICB0aGUgcmFuZ2Ugb2Yga2V5cyBzdG9yZWQgaW4gdGhlIGxldmVsIGluY3JlYXNlcyAoZHJhbWF0aWNhbGx5KS5cblxuICAgVGhlIGlkZWEgb2YgdGhlIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gdGhlIGhpZXJhcmNoaWNhbCBhcHByb2FjaCBkZXNjcmliZWQgaW46XG5cbiAgIHt2XG4gICAgIEhhc2hlZCBhbmQgSGllcmFyY2hpY2FsIFRpbWluZyBXaGVlbHM6XG4gICAgIEVmZmljaWVudCBEYXRhIFN0cnVjdHVyZXMgZm9yIEltcGxlbWVudGluZyBhIFRpbWVyIEZhY2lsaXR5XG5cbiAgICAgVmFyZ2hlc2UgJiBMYXVjaywgMTk5NlxuICAgdn1cblxuICAgSG93ZXZlciwgdGhlIGNvZGUgaXMgY29tcGxldGVseSBuZXcuICopXG5cbm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgVGltaW5nX3doZWVsX2ludGZcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxubW9kdWxlIFRpbWVfbnMgPSBDb3JlX3ByaXZhdGUuVGltZV9uc19hbHRlcm5hdGVfc2V4cFxuXG5sZXQgc2V4cF9vZl90X3N0eWxlIDogWyBgUHJldHR5IHwgYEludGVybmFsIF0gcmVmID0gcmVmIGBQcmV0dHlcblxuKCogW3ttYXgsbWlufV90aW1lXSBhcmUgYm91bmRzIG9uIHRoZSB0aW1lcyBzdXBwb3J0ZWQgYnkgYSB0aW1pbmcgd2hlZWwuICopXG5cbmxldCBtYXhfdGltZSA9IFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGVcbmxldCBtaW5fdGltZSA9IFRpbWVfbnMuZXBvY2hcblxubW9kdWxlIE51bV9rZXlfYml0cyA6IHNpZ1xuICB0eXBlIHQgPSBwcml2YXRlIGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGluY2x1ZGUgQ29tcGFyYWJsZSB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgSW52YXJpYW50LlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqIHZhbCBtaW5fdmFsdWUgOiB0ICopXG5cbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG93MiA6IHQgLT4gSW50NjMudFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgSW50XG5cbiAgbGV0IG1pbl92YWx1ZSA9IDBcblxuICAoKiogV2Ugc3VwcG9ydCBhbGwgbm9uLW5lZ2F0aXZlIFtUaW1lX25zLnRdIHZhbHVlcy4gKilcbiAgbGV0IG1heF92YWx1ZSA9IEludDYzLm51bV9iaXRzIC0gMVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0ICh0ID49IG1pbl92YWx1ZSk7XG4gICAgYXNzZXJ0ICh0IDw9IG1heF92YWx1ZSlcbiAgOztcblxuICBsZXQgb2ZfaW50IGkgPVxuICAgIGludmFyaWFudCBpO1xuICAgIGlcbiAgOztcblxuICBsZXQgKCArICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgKyB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgKCAtICkgdDEgdDIgPVxuICAgIGxldCB0ID0gdDEgLSB0MiBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgcG93MiB0ID0gSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgdFxuZW5kXG5cbm1vZHVsZSBMZXZlbF9iaXRzID0gc3RydWN0XG4gIHR5cGUgdCA9IE51bV9rZXlfYml0cy50IGxpc3QgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgbWF4X251bV9iaXRzID0gKE51bV9rZXlfYml0cy5tYXhfdmFsdWUgOj4gaW50KVxuICBsZXQgbnVtX2JpdHNfaW50ZXJuYWwgdCA9IExpc3QuZm9sZCB0IH5pbml0Ok51bV9rZXlfYml0cy56ZXJvIH5mOk51bV9rZXlfYml0cy4oICsgKVxuICBsZXQgbnVtX2JpdHMgdCA9IChudW1fYml0c19pbnRlcm5hbCB0IDo+IGludClcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIGFzc2VydCAobm90IChMaXN0LmlzX2VtcHR5IHQpKTtcbiAgICBMaXN0Lml0ZXIgdCB+ZjooZnVuIG51bV9rZXlfYml0cyAtPlxuICAgICAgTnVtX2tleV9iaXRzLmludmFyaWFudCBudW1fa2V5X2JpdHM7XG4gICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBudW1fa2V5X2JpdHMgTnVtX2tleV9iaXRzLnplcm8pKTtcbiAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IChudW1fYml0c19pbnRlcm5hbCB0KVxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHQgPSBzZXhwIHw+IFslb2Zfc2V4cDogdF0gaW5cbiAgICBpbnZhcmlhbnQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9leG4gPyhleHRlbmRfdG9fbWF4X251bV9iaXRzID0gZmFsc2UpIGludHMgPVxuICAgIGlmIExpc3QuaXNfZW1wdHkgaW50cyB0aGVuIGZhaWx3aXRoIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIHJlcXVpcmVzIGEgbm9uZW1wdHkgbGlzdFwiO1xuICAgIGlmIExpc3QuZXhpc3RzIGludHMgfmY6KGZ1biBiaXRzIC0+IGJpdHMgPD0gMClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3Qgbm9ucG9zaXRpdmUgbnVtIGJpdHNcIiB+XzooaW50cyA6IGludCBsaXN0KV07XG4gICAgbGV0IG51bV9iaXRzID0gTGlzdC5mb2xkIGludHMgfmluaXQ6MCB+ZjooICsgKSBpblxuICAgIGlmIG51bV9iaXRzID4gbWF4X251bV9iaXRzXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkxldmVsX2JpdHMuY3JlYXRlX2V4biBnb3QgdG9vIG1hbnkgYml0c1wiXG4gICAgICAgICAgICB+XzooaW50cyA6IGludCBsaXN0KVxuICAgICAgICAgICAgfmdvdDoobnVtX2JpdHMgOiBpbnQpXG4gICAgICAgICAgICAobWF4X251bV9iaXRzIDogaW50KV07XG4gICAgbGV0IGludHMgPVxuICAgICAgaWYgZXh0ZW5kX3RvX21heF9udW1fYml0c1xuICAgICAgdGhlbiBpbnRzIEAgTGlzdC5pbml0IChtYXhfbnVtX2JpdHMgLSBudW1fYml0cykgfmY6KGNvbnN0IDEpXG4gICAgICBlbHNlIGludHNcbiAgICBpblxuICAgIExpc3QubWFwIGludHMgfmY6TnVtX2tleV9iaXRzLm9mX2ludFxuICA7O1xuXG4gIGxldCBkZWZhdWx0ID0gY3JlYXRlX2V4biBbIDExOyAxMDsgMTA7IDEwOyAxMDsgMTA7IDEgXVxuXG4gIGxldCB0cmltIHQgfm1heF9udW1fYml0cyA9XG4gICAgaWYgTnVtX2tleV9iaXRzLiggPD0gKSAobnVtX2JpdHNfaW50ZXJuYWwgdCkgbWF4X251bV9iaXRzXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgdCB+cmVtYWluaW5nID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gW11cbiAgICAgICAgfCBiIDo6IHQgLT5cbiAgICAgICAgICBpZiBOdW1fa2V5X2JpdHMuKCA+PSApIGIgcmVtYWluaW5nXG4gICAgICAgICAgdGhlbiBbIHJlbWFpbmluZyBdXG4gICAgICAgICAgZWxzZSBiIDo6IGxvb3AgdCB+cmVtYWluaW5nOihOdW1fa2V5X2JpdHMuKCAtICkgcmVtYWluaW5nIGIpXG4gICAgICBpblxuICAgICAgbG9vcCB0IH5yZW1haW5pbmc6bWF4X251bV9iaXRzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gOiBzaWdcbiAgaW5jbHVkZSBBbGFybV9wcmVjaXNpb25cblxuICB2YWwgbnVtX2tleV9iaXRzIDogdCAtPiBOdW1fa2V5X2JpdHMudFxuICB2YWwgaW50ZXJ2YWxfbnVtIDogdCAtPiBUaW1lX25zLnQgLT4gSW50NjMudFxuICB2YWwgaW50ZXJ2YWxfbnVtX3N0YXJ0IDogdCAtPiBJbnQ2My50IC0+IFRpbWVfbnMudFxuZW5kID0gc3RydWN0XG4gICgqKiBbdF0gaXMgcmVwcmVzZW50ZWQgYXMgdGhlIGxvZzIgb2YgYSBudW1iZXIgb2YgbmFub3NlY29uZHMuICopXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBoYXNoXVxuXG4gIGxldCBlcXVhbCA9IFslY29tcGFyZS5lcXVhbDogdF1cbiAgbGV0IG51bV9rZXlfYml0cyB0ID0gdCB8PiBOdW1fa2V5X2JpdHMub2ZfaW50XG5cbiAgbGV0IHRvX3NwYW4gdCA9XG4gICAgaWYgdCA8IDBcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiW0FsYXJtX3ByZWNpc2lvbi50b19zcGFuXSBvZiBuZWdhdGl2ZSBwb3dlciBvZiB0d28gbmFub3NlY29uZHNcIiB+XzoodCA6IGludCldO1xuICAgIEludDYzLihzaGlmdF9sZWZ0IG9uZSkgdCB8PiBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQgfD4gdG9fc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV1cbiAgbGV0IG9uZV9uYW5vc2Vjb25kID0gMFxuICBsZXQgYWJvdXRfb25lX21pY3Jvc2Vjb25kID0gMTBcbiAgbGV0IGFib3V0X29uZV9taWxsaXNlY29uZCA9IDIwXG4gIGxldCBhYm91dF9vbmVfc2Vjb25kID0gMzBcbiAgbGV0IGFib3V0X29uZV9kYXkgPSA0NlxuICBsZXQgbXVsIHQgfnBvdzIgPSB0ICsgcG93MlxuICBsZXQgZGl2IHQgfnBvdzIgPSB0IC0gcG93MlxuICBsZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9IEludDYzLnNoaWZ0X3JpZ2h0ICh0aW1lIHw+IFRpbWVfbnMudG9faW50NjNfbnNfc2luY2VfZXBvY2gpIHRcblxuICBsZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgaW50ZXJ2YWxfbnVtID1cbiAgICBJbnQ2My5zaGlmdF9sZWZ0IGludGVydmFsX251bSB0IHw+IFRpbWVfbnMub2ZfaW50NjNfbnNfc2luY2VfZXBvY2hcbiAgOztcblxuICBsZXQgb2Zfc3Bhbl9mbG9vcl9wb3cyX25zIHNwYW4gPVxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLm9mX3NwYW5fZmxvb3JfcG93Ml9uc10gZ290IG5vbi1wb3NpdGl2ZSBzcGFuXCJcbiAgICAgICAgICAgIChzcGFuIDogVGltZV9ucy5TcGFuLnQpXTtcbiAgICBzcGFuIHw+IFRpbWVfbnMuU3Bhbi50b19pbnQ2M19ucyB8PiBJbnQ2My5mbG9vcl9sb2cyXG4gIDs7XG5cbiAgbGV0IG9mX3NwYW4gPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcblxuICBtb2R1bGUgVW5zdGFibGUgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgY29tcGFyZV1cblxuICAgICAgbGV0IG9mX2JpbmFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19iaW5hYmxlID0gdG9fc3BhblxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfc3Bhbl9mbG9vcl9wb3cyX25zXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19zcGFuXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIEJpbmFibGUuT2ZfYmluYWJsZV93aXRob3V0X3V1aWQgW0BhbGVydCBcIi1sZWdhY3lcIl0gKFRpbWVfbnMuU3BhbikgKFQpXG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZSAoVGltZV9ucy5TcGFuKSAoVClcbiAgZW5kXG5lbmRcblxubW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICBsZXQgbGV2ZWxfYml0c19kZWZhdWx0ID0gTGV2ZWxfYml0cy5kZWZhdWx0XG5cbiAgdHlwZSB0ID1cbiAgICB7IGFsYXJtX3ByZWNpc2lvbiA6IEFsYXJtX3ByZWNpc2lvbi5VbnN0YWJsZS50XG4gICAgOyBsZXZlbF9iaXRzIDogTGV2ZWxfYml0cy50IFtAZGVmYXVsdCBsZXZlbF9iaXRzX2RlZmF1bHRdXG4gICAgOyBjYXBhY2l0eSA6IGludCBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF1cblxuICBsZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBBbGFybV9wcmVjaXNpb24udG9fc3BhbiB0LmFsYXJtX3ByZWNpc2lvblxuXG4gICgqIFttYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbGV2ZWwgYml0cyBuZWVkZWQgZm9yIGFcbiAgICAgdGltaW5nIHdoZWVsIHdpdGggdGhlIHNwZWNpZmllZCBbYWxhcm1fcHJlY2lzaW9uXSB0byBiZSBhYmxlIHRvIHJlcHJlc2VudCBhbGxcbiAgICAgcG9zc2libGUgdGltZXMgZnJvbSBbVGltZV9ucy5lcG9jaF0gb253YXJkLiAgU2luY2Ugbm9uLW5lZ2F0aXZlIHRpbWVzIGhhdmUgNjIgYml0cyxcbiAgICAgd2UgcmVxdWlyZSBbTCA8PSA2MiAtIEFdLCB3aGVyZSBbQV0gaXMgdGhlIG51bWJlciBvZiBhbGFybSBiaXRzIGFuZCBbTF0gaXMgdGhlXG4gICAgIG51bWJlciBvZiBsZXZlbCBiaXRzLiAqKVxuICBsZXQgbWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbiA9XG4gICAgTnVtX2tleV9iaXRzLiggLSApXG4gICAgICBOdW1fa2V5X2JpdHMubWF4X3ZhbHVlXG4gICAgICAoQWxhcm1fcHJlY2lzaW9uLm51bV9rZXlfYml0cyBhbGFybV9wcmVjaXNpb24pXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIE51bV9rZXlfYml0cy4oIDw9IClcbiAgICAgICAgICAoTGV2ZWxfYml0cy5udW1fYml0c19pbnRlcm5hbCB0LmxldmVsX2JpdHMpXG4gICAgICAgICAgKG1heF9udW1fbGV2ZWxfYml0cyB0LmFsYXJtX3ByZWNpc2lvbikpO1xuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+YWxhcm1fcHJlY2lzaW9uOmlnbm9yZVxuICAgICAgICB+Y2FwYWNpdHk6aWdub3JlXG4gICAgICAgIH5sZXZlbF9iaXRzOihjaGVjayBMZXZlbF9iaXRzLmludmFyaWFudCkpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgPyhsZXZlbF9iaXRzID0gbGV2ZWxfYml0c19kZWZhdWx0KSB+YWxhcm1fcHJlY2lzaW9uICgpID1cbiAgICBsZXQgbGV2ZWxfYml0cyA9XG4gICAgICBMZXZlbF9iaXRzLnRyaW0gbGV2ZWxfYml0cyB+bWF4X251bV9iaXRzOihtYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uKVxuICAgIGluXG4gICAgeyBhbGFybV9wcmVjaXNpb247IGxldmVsX2JpdHM7IGNhcGFjaXR5IH1cbiAgOztcblxuICBsZXQgbWljcm9zZWNvbmRfcHJlY2lzaW9uICgpID1cbiAgICBjcmVhdGVcbiAgICAgICgpXG4gICAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi5hYm91dF9vbmVfbWljcm9zZWNvbmRcbiAgICAgIH5sZXZlbF9iaXRzOihMZXZlbF9iaXRzLmNyZWF0ZV9leG4gWyAxMDsgMTA7IDY7IDY7IDUgXSlcbiAgOztcblxuICBsZXQgZHVyYXRpb25zIHQgPVxuICAgIExpc3QuZm9sZGluZ19tYXBcbiAgICAgIHQubGV2ZWxfYml0c1xuICAgICAgfmluaXQ6KEFsYXJtX3ByZWNpc2lvbi5udW1fa2V5X2JpdHMgdC5hbGFybV9wcmVjaXNpb24gfD4gTnVtX2tleV9iaXRzLnRvX2ludClcbiAgICAgIH5mOihmdW4gbnVtX2JpdHNfYWNjdW0gbGV2ZWxfbnVtX2JpdHMgLT5cbiAgICAgICAgbGV0IG51bV9iaXRzX2FjY3VtID0gbnVtX2JpdHNfYWNjdW0gKyAobGV2ZWxfbnVtX2JpdHMgfD4gTnVtX2tleV9iaXRzLnRvX2ludCkgaW5cbiAgICAgICAgbGV0IGR1cmF0aW9uID1cbiAgICAgICAgICBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgICAgICAgICAgIChpZiBudW1fYml0c19hY2N1bSA9IEludDYzLm51bV9iaXRzIC0gMVxuICAgICAgICAgICAgIHRoZW4gSW50NjMubWF4X3ZhbHVlXG4gICAgICAgICAgICAgZWxzZSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSBudW1fYml0c19hY2N1bSlcbiAgICAgICAgaW5cbiAgICAgICAgbnVtX2JpdHNfYWNjdW0sIGR1cmF0aW9uKVxuICA7O1xuZW5kXG5cblxuKCoqIFRpbWluZyB3aGVlbCBpcyBpbXBsZW1lbnRlZCBhcyBhIHByaW9yaXR5IHF1ZXVlIGluIHdoaWNoIHRoZSBrZXlzIGFyZVxuICAgIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnRlcnZhbHMgb2YgdGltZS4gIFRoZSBwcmlvcml0eSBxdWV1ZSBpc1xuICAgIHVubGlrZSBhIHR5cGljYWwgcHJpb3JpdHkgcXVldWUgaW4gdGhhdCByYXRoZXIgdGhhbiBoYXZpbmcgYSBcImRlbGV0ZSBtaW5cIiBvcGVyYXRpb24sXG4gICAgaXQgaGFzIGEgbm9uZGVjcmVhc2luZyBtaW5pbXVtIGFsbG93ZWQga2V5LCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCB0aW1lLFxuICAgIGFuZCBhbiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBvcGVyYXRpb24sIHdoaWNoIGltcGxlbWVudHMgW2FkdmFuY2VfY2xvY2tdLlxuICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGFzIGEgc2lkZSBlZmZlY3QgcmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgdGltaW5nXG4gICAgd2hlZWwgd2hvc2Uga2V5IGlzIHNtYWxsZXIgdGhhbiB0aGUgbmV3IG1pbmltdW0sIHdoaWNoIGltcGxlbWVudHMgZmlyaW5nIHRoZSBhbGFybXNcbiAgICB3aG9zZSB0aW1lIGhhcyBleHBpcmVkLlxuXG4gICAgQWRkaW5nIGVsZW1lbnRzIHRvIGFuZCByZW1vdmluZyBlbGVtZW50cyBmcm9tIGEgdGltaW5nIHdoZWVsIHRha2VzIGNvbnN0YW50IHRpbWUsXG4gICAgdW5saWtlIGEgaGVhcC1iYXNlZCBwcmlvcml0eSBxdWV1ZSB3aGljaCB0YWtlcyBsb2coTiksIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZlxuICAgIGVsZW1lbnRzIGluIHRoZSBoZWFwLiAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlXG4gICAgYW1vdW50IG9mIGluY3JlYXNlIGluIHRoZSBtaW4tYWxsb3dlZCBrZXksIGFzIGNvbXBhcmVkIHRvIGxvZyhOKSBmb3IgYSBoZWFwLiAgSXQgaXNcbiAgICB0aGVzZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlcyB0aGF0IG1vdGl2YXRlIHRoZSBleGlzdGVuY2Ugb2YgdGltaW5nIHdoZWVscyBhbmQgbWFrZVxuICAgIHRoZW0gYSBnb29kIGNob2ljZSBmb3IgbWFpbnRhaW5nIGEgc2V0IG9mIGFsYXJtcy4gIFdpdGggYSB0aW1pbmcgd2hlZWwsIG9uZSBjYW5cbiAgICBzdXBwb3J0IGFueSBudW1iZXIgb2YgYWxhcm1zIHBheWluZyBjb25zdGFudCBvdmVyaGVhZCBwZXIgYWxhcm0sIHdoaWxlIHBheWluZyBhXG4gICAgc21hbGwgY29uc3RhbnQgb3ZlcmhlYWQgcGVyIHVuaXQgb2YgdGltZSBwYXNzZWQuXG5cbiAgICBBcyB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBpbmNyZWFzZXMsIHRoZSB0aW1pbmcgd2hlZWwgZG9lcyBhIGxhenkgcmFkaXggc29ydCBvZiB0aGVcbiAgICBlbGVtZW50IGtleXMsIHdpdGggbGV2ZWwgMCBoYW5kbGluZyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgW2JfMF0gYml0cyBpbiBhIGtleSwgYW5kXG4gICAgZWFjaCBzdWJzZXF1ZW50IGxldmVsIFtpXSBoYW5kbGluZyB0aGUgbmV4dCBtb3N0IHNpZ25pZmljYW50IFtiX2ldIGJpdHMuICBUaGUgbGV2ZWxzXG4gICAgaG9sZCBpbmNyZWFzaW5nbHkgbGFyZ2VyIHJhbmdlcyBvZiBrZXlzLCB3aGVyZSB0aGUgdW5pb24gb2YgYWxsIHRoZSBsZXZlbHMgY2FuIGhvbGRcbiAgICBhbnkga2V5IGZyb20gW21pbl9hbGxvd2VkX2tleSB0XSB0byBbbWF4X2FsbG93ZWRfa2V5IHRdLiAgV2hlbiBhIGtleSBpcyBhZGRlZCB0byB0aGVcbiAgICB0aW1pbmcgd2hlZWwsIGl0IGlzIGFkZGVkIGF0IHRoZSBsb3dlc3QgcG9zc2libGUgbGV2ZWwgdGhhdCBjYW4gc3RvcmUgdGhlIGtleS4gIEFzXG4gICAgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgaW5jcmVhc2VzLCB0aW1pbmctd2hlZWwgZWxlbWVudHMgbW92ZSBkb3duIGxldmVscyB1bnRpbCB0aGV5XG4gICAgcmVhY2ggbGV2ZWwgMCwgYW5kIHRoZW4gYXJlIGV2ZW50dWFsbHkgcmVtb3ZlZC4gICopXG5tb2R1bGUgUHJpb3JpdHlfcXVldWUgOiBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIHR5cGUgJ2EgcHJpb3JpdHlfcXVldWUgPSAnYSB0XG5cbiAgbW9kdWxlIEtleSA6IEludGVydmFsX251bVxuXG4gIG1vZHVsZSBFbHQgOiBzaWdcbiAgICAoKiogQW4gW0VsdC50XSByZXByZXNlbnRzIGFuIGVsZW1lbnQgdGhhdCB3YXMgYWRkZWQgdG8gYSB0aW1pbmcgd2hlZWwuICopXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgYXQgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+IFRpbWVfbnMudFxuICAgIHZhbCBrZXkgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIHZhbHVlIDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBudWxsIDogdW5pdCAtPiAnYSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBJbnRlcm5hbF9lbHQgOiBzaWdcbiAgICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBrZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCBtYXhfYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICAgIHZhbCBtaW5fYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICAgIHZhbCBpc19udWxsIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgdG9fZXh0ZXJuYWwgOiAnYSB0IC0+ICdhIEVsdC50XG4gIGVuZFxuXG4gIHZhbCBwb29sIDogJ2EgdCAtPiAnYSBJbnRlcm5hbF9lbHQuUG9vbC50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICgqKiBbY3JlYXRlID9sZXZlbF9iaXRzICgpXSBjcmVhdGVzIGEgbmV3IGVtcHR5IHRpbWluZyB3aGVlbCwgW3RdLCB3aXRoIFtsZW5ndGggdCA9IDBdXG4gICAgICBhbmQgW21pbl9hbGxvd2VkX2tleSB0ID0gMF0uICopXG4gIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+ID9sZXZlbF9iaXRzOkxldmVsX2JpdHMudCAtPiB1bml0IC0+ICdhIHRcblxuICAoKiogW2xlbmd0aCB0XSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRpbWluZyB3aGVlbC4gKilcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcblxuICAoKiogW21pbl9hbGxvd2VkX2tleSB0XSBpcyB0aGUgbWluaW11bSBrZXkgdGhhdCBjYW4gYmUgc3RvcmVkIGluIFt0XS4gIFRoaXMgb25seVxuICAgICAgaW5kaWNhdGVzIHRoZSBwb3NzaWJpbGl0eTsgdGhlcmUgbmVlZCBub3QgYmUgYW4gZWxlbWVudCBbZWx0XSBpbiBbdF0gd2l0aCBbRWx0LmtleVxuICAgICAgZWx0ID0gbWluX2FsbG93ZWRfa2V5IHRdLiAgVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFwibWluX2tleVwiIG9wZXJhdGlvbiBpbiBhXG4gICAgICB0eXBpY2FsIHByaW9yaXR5IHF1ZXVlLlxuXG4gICAgICBbbWluX2FsbG93ZWRfa2V5IHRdIGNhbiBpbmNyZWFzZSBvdmVyIHRpbWUsIHZpYSBjYWxscyB0b1xuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0uICopXG4gIHZhbCBtaW5fYWxsb3dlZF9rZXkgOiBfIHQgLT4gS2V5LnRcblxuICAoKiogW21heF9hbGxvd2VkX2tleSB0XSBpcyB0aGUgbWF4aW11bSBhbGxvd2VkIGtleSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gW3RdLiAgQXNcbiAgICAgIFttaW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcywgc28gZG9lcyBbbWF4X2FsbG93ZWRfa2V5XTsgaG93ZXZlciBpdCBpcyBub3QgdGhlIGNhc2VcbiAgICAgIHRoYXQgW21heF9hbGxvd2VkX2tleSB0IC0gbWluX2FsbG93ZWRfa2V5IHRdIGlzIGEgY29uc3RhbnQuICBJdCBpcyBndWFyYW50ZWVkIHRoYXRcbiAgICAgIFttYXhfYWxsb3dlZF9rZXkgdCA+PSBtaW5fYWxsb3dlZF9rZXkgdCArIDJeQiAtIDFdLFxuICAgICAgd2hlcmUgW0JdIGlzIHRoZSBzdW0gb2YgdGhlIGJfaSBpbiBbbGV2ZWxfYml0c10uICopXG4gIHZhbCBtYXhfYWxsb3dlZF9rZXkgOiBfIHQgLT4gS2V5LnRcblxuICB2YWwgbWluX2VsdF8gOiAnYSB0IC0+ICdhIEludGVybmFsX2VsdC50XG4gIHZhbCBpbnRlcm5hbF9hZGQgOiAnYSB0IC0+IGtleTpLZXkudCAtPiBhdDpUaW1lX25zLnQgLT4gJ2EgLT4gJ2EgSW50ZXJuYWxfZWx0LnRcblxuICAoKiogW3JlbW92ZSB0IGVsdF0gcmVtb3ZlcyBbZWx0XSBmcm9tIFt0XS4gIEl0IGlzIGFuIGVycm9yIGlmIFtlbHRdIGlzIG5vdCBjdXJyZW50bHlcbiAgICAgIGluIFt0XSwgYW5kIHRoaXMgZXJyb3IgbWF5IG9yIG1heSBub3QgYmUgZGV0ZWN0ZWQuICopXG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+ICdhIEVsdC50IC0+IHVuaXRcblxuICB2YWwgY2hhbmdlIDogJ2EgdCAtPiAnYSBFbHQudCAtPiBrZXk6S2V5LnQgLT4gYXQ6VGltZV9ucy50IC0+IHVuaXRcblxuICAoKiogW2NsZWFyIHRdIHJlbW92ZXMgYWxsIGVsdHMgZnJvbSBbdF0uICopXG4gIHZhbCBjbGVhciA6IF8gdCAtPiB1bml0XG5cbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4gYm9vbFxuXG4gIG1vZHVsZSBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0IDogc2lnXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkXG4gIGVuZFxuXG4gICgqKiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5IHQgfmtleSB+aGFuZGxlX3JlbW92ZWRdIGluY3JlYXNlcyB0aGUgbWluaW11bSBhbGxvd2VkXG4gICAgICBrZXkgaW4gW3RdIHRvIFtrZXldLCBhbmQgcmVtb3ZlcyBhbGwgZWxlbWVudHMgd2l0aCBrZXlzIGxlc3MgdGhhbiBba2V5XSwgYXBwbHlpbmdcbiAgICAgIFtoYW5kbGVfcmVtb3ZlZF0gdG8gZWFjaCBlbGVtZW50IHRoYXQgaXMgcmVtb3ZlZC4gIElmIFtrZXkgPD0gbWluX2FsbG93ZWRfa2V5IHRdLFxuICAgICAgdGhlbiBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBkb2VzIG5vdGhpbmcuICBPdGhlcndpc2UsIGlmXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSByZXR1cm5zIHN1Y2Nlc3NmdWxseSwgW21pbl9hbGxvd2VkX2tleSB0ID0ga2V5XS5cblxuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gW2tleSAtIG1pbl9hbGxvd2VkX2tleSB0XSxcbiAgICAgIGFsdGhvdWdoIHBvc3NpYmx5IGxlc3MgdGltZS5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW2hhbmRsZV9yZW1vdmVkXSBhY2Nlc3NlcyBbdF0gaW4gYW55IHdheSBvdGhlciB0aGFuXG4gICAgICBbRWx0XSBmdW5jdGlvbnMuICopXG4gIHZhbCBpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlcbiAgICA6ICAnYSB0XG4gICAgLT4ga2V5OktleS50XG4gICAgLT4gaGFuZGxlX3JlbW92ZWQ6KCdhIEVsdC50IC0+IHVuaXQpXG4gICAgLT4gSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC50XG5cbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIEVsdC50IC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgZmlyZV9wYXN0X2FsYXJtc1xuICAgIDogICdhIHRcbiAgICAtPiBoYW5kbGVfZmlyZWQ6KCdhIEVsdC50IC0+IHVuaXQpXG4gICAgLT4ga2V5OktleS50XG4gICAgLT4gbm93OlRpbWVfbnMudFxuICAgIC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICAoKiogRWFjaCBzbG90IGluIGEgbGV2ZWwgaXMgYSAocG9zc2libHkgbnVsbCkgcG9pbnRlciB0byBhIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgb2YgZWxlbWVudHMuICBXZSBwb29sIHRoZSBlbGVtZW50cyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGVtIGFmdGVyIHRoZXkgYXJlIHJlbW92ZWRcbiAgICAgIGZyb20gdGhlIHRpbWluZyB3aGVlbCAoZWl0aGVyIHZpYSBbcmVtb3ZlXSBvciBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSkuICBJblxuICAgICAgYWRkaXRpb24gdG8gc3RvcmluZyB0aGUgW2tleV0sIFthdF0sIGFuZCBbdmFsdWVdIGluIHRoZSBlbGVtZW50LCB3ZSBzdG9yZSB0aGVcbiAgICAgIFtsZXZlbF9pbmRleF0gc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgdG8gdGhlIGxldmVsIGhvbGRpbmcgYW4gZWxlbWVudCB3aGVuIHdlXG4gICAgICBbcmVtb3ZlXSBpdC5cblxuICAgICAgV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiBbRXh0ZXJuYWxfZWx0XSBhbmQgW0ludGVybmFsX2VsdF0sIHdoaWNoIGFyZSB0aGUgc2FtZVxuICAgICAgdW5kZXJuZWF0aC4gIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCBhbiBbSW50ZXJuYWxfZWx0XSBpcyBlaXRoZXIgW251bGxdIG9yIGFcbiAgICAgIHZhbGlkIHBvaW50ZXIuICBPbiB0aGUgb3RoZXIgaGFuZCwgW0V4dGVybmFsX2VsdF1zIGFyZSByZXR1cm5lZCB0byB1c2VyIGNvZGUsIHNvXG4gICAgICB0aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdmFsaWRpdHkgLS0gd2UgYWx3YXlzIHZhbGlkYXRlIGFuIFtFeHRlcm5hbF9lbHRdIGJlZm9yZVxuICAgICAgZG9pbmcgYW55dGhpbmcgd2l0aCBpdC5cblxuICAgICAgSXQgaXMgdGhlcmVmb3JlIE9LIHRvIHVzZSBbUG9vbC5VbnNhZmVdLCBiZWNhdXNlIHdlIHdpbGwgbmV2ZXIgYXR0ZW1wdCB0byBhY2Nlc3MgYVxuICAgICAgc2xvdCBvZiBhbiBpbnZhbGlkIHBvaW50ZXIuICopXG4gIG1vZHVsZSBQb29sID0gUG9vbC5VbnNhZmVcblxuICBtb2R1bGUgUG9pbnRlciA9IFBvb2wuUG9pbnRlclxuXG4gIG1vZHVsZSBLZXkgOiBzaWdcbiAgICAoKiogW0ludGVydmFsX251bV0gaXMgdGhlIHB1YmxpYyBBUEkuICBFdmVyeXRoaW5nIGZvbGxvd2luZyBpbiB0aGUgc2lnbmF0dXJlIGlzXG4gICAgICAgIGZvciBpbnRlcm5hbCB1c2UuICopXG4gICAgaW5jbHVkZSBUaW1pbmdfd2hlZWxfaW50Zi5JbnRlcnZhbF9udW1cblxuICAgICgqKiBbYWRkX2NsYW1wX3RvX21heF0gZG9lc24ndCB3b3JrIGF0IGFsbCB3aXRoIG5lZ2F0aXZlIHNwYW5zICopXG4gICAgdmFsIGFkZF9jbGFtcF90b19tYXggOiB0IC0+IFNwYW4udCAtPiB0XG5cbiAgICB2YWwgc3VjY19jbGFtcF90b19tYXggOiB0IC0+IHRcblxuICAgICgqKiBbU2xvdHNfbWFza10gaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSBhIGtleSdzIHNsb3QgaW4gYSBnaXZlbiBsZXZlbC4gKilcbiAgICBtb2R1bGUgU2xvdHNfbWFzayA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBjcmVhdGUgOiBsZXZlbF9iaXRzOk51bV9rZXlfYml0cy50IC0+IHRcbiAgICAgIHZhbCBuZXh0X3Nsb3QgOiB0IC0+IGludCAtPiBpbnRcbiAgICBlbmRcblxuICAgICgqKiBbTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza10gaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSB0aGUgbWluaW11bSBrZXkgaW4gdGhlXG4gICAgICAgIHNhbWUgc2xvdCBhcyBhIGdpdmVuIGtleS4gKilcbiAgICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIGluY2x1ZGUgRXF1YWwuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiBiaXRzX3Blcl9zbG90Ok51bV9rZXlfYml0cy50IC0+IHRcbiAgICBlbmRcblxuICAgIHZhbCBudW1fa2V5cyA6IE51bV9rZXlfYml0cy50IC0+IFNwYW4udFxuICAgIHZhbCBtaW5fa2V5X2luX3NhbWVfc2xvdCA6IHQgLT4gTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay50IC0+IHRcbiAgICB2YWwgc2xvdCA6IHQgLT4gYml0c19wZXJfc2xvdDpOdW1fa2V5X2JpdHMudCAtPiBzbG90c19tYXNrOlNsb3RzX21hc2sudCAtPiBpbnRcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIFNsb3RzX21hc2sgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgbGV0IGNyZWF0ZSB+bGV2ZWxfYml0cyA9IEludDYzLiggLSApIChOdW1fa2V5X2JpdHMucG93MiBsZXZlbF9iaXRzKSBJbnQ2My5vbmVcbiAgICAgIGxldCBuZXh0X3Nsb3QgdCBzbG90ID0gKHNsb3QgKyAxKSBsYW5kIEludDYzLnRvX2ludF9leG4gdFxuICAgIGVuZFxuXG4gICAgbGV0IG51bV9rZXlzIG51bV9iaXRzID0gTnVtX2tleV9iaXRzLnBvdzIgbnVtX2JpdHNcblxuICAgIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID0gc3RydWN0XG4gICAgICBpbmNsdWRlIEludDYzXG5cbiAgICAgIGxldCBjcmVhdGUgfmJpdHNfcGVyX3Nsb3QgPSBiaXRfbm90IChOdW1fa2V5X2JpdHMucG93MiBiaXRzX3Blcl9zbG90IC0gb25lKVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIFNwYW4gPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgSW50NjNcblxuICAgICAgbGV0IHRvX2ludDYzIHQgPSB0XG4gICAgICBsZXQgb2ZfaW50NjMgaSA9IGlcbiAgICAgIGxldCBzY2FsZV9pbnQgdCBpID0gdCAqIG9mX2ludCBpXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIEludDYzXG5cbiAgICBsZXQgb2ZfaW50NjMgaSA9IGlcbiAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICBsZXQgYWRkIHQgaSA9IHQgKyBpXG4gICAgbGV0IGFkZF9jbGFtcF90b19tYXggdCBpID0gaWYgdCA+IG1heF92YWx1ZSAtIGkgdGhlbiBtYXhfdmFsdWUgZWxzZSB0ICsgaVxuICAgIGxldCBzdWNjX2NsYW1wX3RvX21heCB0ID0gaWYgdCA9IG1heF92YWx1ZSB0aGVuIG1heF92YWx1ZSBlbHNlIHN1Y2MgdFxuICAgIGxldCBzdWIgdCBpID0gdCAtIGlcbiAgICBsZXQgZGlmZiB0MSB0MiA9IHQxIC0gdDJcblxuICAgIGxldCBzbG90IHQgfihiaXRzX3Blcl9zbG90IDogTnVtX2tleV9iaXRzLnQpIH5zbG90c19tYXNrID1cbiAgICAgIHRvX2ludF9leG4gKGJpdF9hbmQgKHNoaWZ0X3JpZ2h0IHQgKGJpdHNfcGVyX3Nsb3QgOj4gaW50KSkgc2xvdHNfbWFzaylcbiAgICA7O1xuXG4gICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90IHQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9XG4gICAgICBiaXRfYW5kIHQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID0gS2V5Lk1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgbW9kdWxlIFNsb3RzX21hc2sgPSBLZXkuU2xvdHNfbWFza1xuXG4gIG1vZHVsZSBFeHRlcm5hbF9lbHQgPSBzdHJ1Y3RcblxuICAgICgqKiBUaGUgW3Bvb2xfc2xvdHNdIGhlcmUgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGUgc2xvdHMgaW4gYSBsZXZlbCBhcnJheS4gIFRoaXMgaXNcbiAgICAgICAgZm9yIHRoZSBzbG90cyBpbiB0aGUgcG9vbCB0dXBsZSByZXByZXNlbnRpbmcgYSBsZXZlbCBlbGVtZW50LiAqKVxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9XG4gICAgICAoIEtleS50XG4gICAgICAsIFRpbWVfbnMudFxuICAgICAgLCAnYVxuICAgICAgLCBpbnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnRcbiAgICAgICwgJ2EgcG9vbF9zbG90cyBQb2ludGVyLnQgKVxuICAgICAgICBQb29sLlNsb3RzLnQ2XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9pbnRlci50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxfZWx0IDogc2lnXG4gICAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+IHVuaXQgLT4gXyB0XG4gICAgICB2YWwgaXNfZnVsbCA6IF8gdCAtPiBib29sXG4gICAgICB2YWwgZ3JvdyA6ID9jYXBhY2l0eTppbnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPSBwcml2YXRlICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gXyB0XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCBpc192YWxpZCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGJvb2xcblxuICAgICgqKiBEZWFsaW5nIHdpdGggW0V4dGVybmFsX2VsdF1zLiAqKVxuXG4gICAgdmFsIGV4dGVybmFsX2lzX3ZhbGlkIDogJ2EgUG9vbC50IC0+ICdhIEV4dGVybmFsX2VsdC50IC0+IGJvb2xcbiAgICB2YWwgdG9fZXh0ZXJuYWwgOiAnYSB0IC0+ICdhIEV4dGVybmFsX2VsdC50XG4gICAgdmFsIG9mX2V4dGVybmFsX2V4biA6ICdhIFBvb2wudCAtPiAnYSBFeHRlcm5hbF9lbHQudCAtPiAnYSB0XG4gICAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaW52YXJpYW50IDogJ2EgUG9vbC50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbY3JlYXRlXSByZXR1cm5zIGFuIGVsZW1lbnQgd2hvc2UgW25leHRdIGFuZCBbcHJldl0gYXJlIFtudWxsXS4gKilcbiAgICB2YWwgY3JlYXRlXG4gICAgICA6ICAnYSBQb29sLnRcbiAgICAgIC0+IGtleTpLZXkudFxuICAgICAgKCoqIFthdF0gaXMgdXNlZCB3aGVuIHRoZSBwcmlvcml0eSBxdWV1ZSBpcyB1c2VkIHRvIGltcGxlbWVudCBhIHRpbWluZyB3aGVlbC4gIElmXG4gICAgICAgICAgdW51c2VkLCBpdCB3aWxsIGJlIFtUaW1lX25zLmVwb2NoXS4gKilcbiAgICAgIC0+IGF0OlRpbWVfbnMudFxuICAgICAgLT4gdmFsdWU6J2FcbiAgICAgIC0+IGxldmVsX2luZGV4OmludFxuICAgICAgLT4gJ2EgdFxuXG4gICAgdmFsIGZyZWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogYWNjZXNzb3JzICopXG5cbiAgICB2YWwga2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnRcbiAgICB2YWwgbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgbmV4dCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdmFsdWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiAnYVxuXG4gICAgKCoqIG11dGF0b3JzICopXG5cbiAgICB2YWwgc2V0X2tleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2F0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gVGltZV9ucy50IC0+IHVuaXRcbiAgICB2YWwgc2V0X2xldmVsX2luZGV4IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50IC0+IHVuaXRcblxuICAgICgqKiBbaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZF0gdHJlYXRzIFt0XSBhcyB0aGUgaGVhZCBvZiB0aGUgbGlzdCBhbmQgYWRkcyBbdG9fYWRkXVxuICAgICAgICB0byB0aGUgZW5kIG9mIGl0LiAqKVxuICAgIHZhbCBpbnNlcnRfYXRfZW5kIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gdG9fYWRkOidhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFtsaW5rX3RvX3NlbGYgcG9vbCB0XSBtYWtlcyBbdF0gYmUgYSBzaW5nbGV0b24gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0LiAqKVxuICAgIHZhbCBsaW5rX3RvX3NlbGYgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogW3VubGluayBwIHRdIHVubGlua3MgW3RdIGZyb20gdGhlIGNpcmN1bGFybHkgZG91Ymx5LWxpbmtlZCBsaXN0IHRoYXQgaXQgaXMgaW4uICBJdFxuICAgICAgICBjaGFuZ2VzIHRoZSBwb2ludGVycyBvZiBbdF0ncyBbcHJldl0gYW5kIFtuZXh0XSBlbHRzLCBidXQgbm90IFt0XSdzIFtwcmV2XSBhbmRcbiAgICAgICAgW25leHRdIHBvaW50ZXJzLiAgW3VubGlua10gaXMgbWVhbmluZ2xlc3MgaWYgW3RdIGlzIGEgc2luZ2xldG9uLiAqKVxuICAgIHZhbCB1bmxpbmsgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB1bml0XG5cbiAgICAoKiogSXRlcmF0b3JzLiAgW2l0ZXIgcCB0IH5pbml0IH5mXSB2aXNpdHMgZWFjaCBlbGVtZW50IGluIHRoZSBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgICAgY29udGFpbmluZyBbdF0sIHN0YXJ0aW5nIGF0IFt0XSwgYW5kIGZvbGxvd2luZyBbbmV4dF0gcG9pbnRlcnMuICBbbGVuZ3RoXSBjb3VudHNcbiAgICAgICAgYnkgdmlzaXRpbmcgZWFjaCBlbGVtZW50IGluIHRoZSBsaXN0LiAqKVxuICAgIHZhbCBpdGVyIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gZjooJ2EgdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgICB2YWwgbGVuZ3RoIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gaW50XG5cbiAgICAoKiogW21heF9hbGFybV90aW1lIHQgZWx0IH53aXRoX2tleV0gZmluZHMgdGhlIG1heCBbYXRdIGluIFtlbHRdJ3MgbGlzdCBhbW9uZyB0aGUgZWx0c1xuICAgICAgICB3aG9zZSBrZXkgaXMgW3dpdGhfa2V5XSwgcmV0dXJuaW5nIFtUaW1lX25zLmVwb2NoXSBpZiB0aGUgbGlzdCBpcyBlbXB0eS4gKilcbiAgICB2YWwgbWF4X2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcblxuICAgIHZhbCBtaW5fYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHBvb2xfc2xvdHMgPSAnYSBFeHRlcm5hbF9lbHQucG9vbF9zbG90cyBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgJ2EgdCA9ICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICAgIGxldCBpc19udWxsID0gUG9pbnRlci5pc19udWxsXG4gICAgbGV0IGVxdWFsIHQxIHQyID0gUG9pbnRlci5waHlzX2VxdWFsIHQxIHQyXG5cbiAgICBsZXQgY3JlYXRlIHBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleCA9XG4gICAgICBQb29sLm5ldzYgcG9vbCBrZXkgYXQgdmFsdWUgbGV2ZWxfaW5kZXggKG51bGwgKCkpIChudWxsICgpKVxuICAgIDs7XG5cbiAgICBsZXQgZnJlZSA9IFBvb2wuZnJlZVxuICAgIGxldCBrZXkgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MFxuICAgIGxldCBzZXRfa2V5IHAgdCBrID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MCBrXG4gICAgbGV0IGF0IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDFcbiAgICBsZXQgc2V0X2F0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50MSB4XG4gICAgbGV0IHZhbHVlIHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDJcbiAgICBsZXQgbGV2ZWxfaW5kZXggcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50M1xuICAgIGxldCBzZXRfbGV2ZWxfaW5kZXggcCB0IGkgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQzIGlcbiAgICBsZXQgcHJldiBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ0XG4gICAgbGV0IHNldF9wcmV2IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NCB4XG4gICAgbGV0IG5leHQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50NVxuICAgIGxldCBzZXRfbmV4dCBwIHQgeCA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDUgeFxuICAgIGxldCBpc192YWxpZCBwIHQgPSBQb29sLnBvaW50ZXJfaXNfdmFsaWQgcCB0XG4gICAgbGV0IGV4dGVybmFsX2lzX3ZhbGlkID0gaXNfdmFsaWRcblxuICAgIGxldCBpbnZhcmlhbnQgcG9vbCBpbnZhcmlhbnRfYSB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICAgIGFzc2VydCAoaXNfdmFsaWQgcG9vbCB0KTtcbiAgICAgICAgaW52YXJpYW50X2EgKHZhbHVlIHBvb2wgdCk7XG4gICAgICAgIGxldCBuID0gbmV4dCBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIG4gfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKHByZXYgcG9vbCBuKSk7XG4gICAgICAgIGxldCBwID0gcHJldiBwb29sIHQgaW5cbiAgICAgICAgYXNzZXJ0IChpc19udWxsIHAgfHwgUG9pbnRlci5waHlzX2VxdWFsIHQgKG5leHQgcG9vbCBwKSkpXG4gICAgOztcblxuICAgIG1vZHVsZSBQb29sID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBwb29sX3Nsb3RzIFBvb2wudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBsZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID0gUG9vbC5pbnZhcmlhbnQgaWdub3JlIHRcbiAgICAgIGxldCBjcmVhdGUgPyhjYXBhY2l0eSA9IDEpICgpID0gUG9vbC5jcmVhdGUgUG9vbC5TbG90cy50NiB+Y2FwYWNpdHlcbiAgICAgIGxldCBncm93ID0gUG9vbC5ncm93XG4gICAgICBsZXQgaXNfZnVsbCA9IFBvb2wuaXNfZnVsbFxuICAgIGVuZFxuXG4gICAgbGV0IHRvX2V4dGVybmFsIHQgPSB0XG5cbiAgICBsZXQgb2ZfZXh0ZXJuYWxfZXhuIHBvb2wgdCA9XG4gICAgICBpZiBpc192YWxpZCBwb29sIHQgdGhlbiB0IGVsc2UgcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaW1pbmdfd2hlZWwgZ290IGludmFsaWQgYWxhcm1cIl1cbiAgICA7O1xuXG4gICAgbGV0IHVubGluayBwb29sIHQgPVxuICAgICAgc2V0X25leHQgcG9vbCAocHJldiBwb29sIHQpIChuZXh0IHBvb2wgdCk7XG4gICAgICBzZXRfcHJldiBwb29sIChuZXh0IHBvb2wgdCkgKHByZXYgcG9vbCB0KVxuICAgIDs7XG5cbiAgICBsZXQgbGluayBwb29sIHByZXYgbmV4dCA9XG4gICAgICBzZXRfbmV4dCBwb29sIHByZXYgbmV4dDtcbiAgICAgIHNldF9wcmV2IHBvb2wgbmV4dCBwcmV2XG4gICAgOztcblxuICAgIGxldCBsaW5rX3RvX3NlbGYgcG9vbCB0ID0gbGluayBwb29sIHQgdFxuXG4gICAgbGV0IGluc2VydF9hdF9lbmQgcG9vbCB0IH50b19hZGQgPVxuICAgICAgbGV0IHByZXYgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgbGluayBwb29sIHByZXYgdG9fYWRkO1xuICAgICAgbGluayBwb29sIHRvX2FkZCB0XG4gICAgOztcblxuICAgIGxldCBpdGVyIHBvb2wgZmlyc3QgfmYgPVxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgKCogV2UgZ2V0IFtuZXh0XSBiZWZvcmUgY2FsbGluZyBbZl0gc28gdGhhdCBbZl0gY2FuIG1vZGlmeSBvciBbZnJlZV0gWyFjdXJyZW50XS4gKilcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgZiAhY3VycmVudDtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IGxlbmd0aCBwb29sIGZpcnN0ID1cbiAgICAgIGxldCByID0gcmVmIDAgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGluY3IgcjtcbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhclxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1heF9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMuZXBvY2ggaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgIGlmIEtleS5lcXVhbCAoa2V5IHBvb2wgIWN1cnJlbnQpIHdpdGhfa2V5XG4gICAgICAgIHRoZW4gbWF4X2FsYXJtX3RpbWUgOj0gVGltZV9ucy5tYXggKGF0IHBvb2wgIWN1cnJlbnQpICFtYXhfYWxhcm1fdGltZTtcbiAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICAgIGRvbmU7XG4gICAgICAhbWF4X2FsYXJtX3RpbWVcbiAgICA7O1xuXG4gICAgbGV0IG1pbl9hbGFybV90aW1lIHBvb2wgZmlyc3QgfndpdGhfa2V5ID1cbiAgICAgIGxldCBtaW5fYWxhcm1fdGltZSA9IHJlZiBUaW1lX25zLm1heF92YWx1ZV9yZXByZXNlbnRhYmxlIGluXG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAoKiBUaGUgW2tleV0gY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgZm9yIFttYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxdIGJlY2F1c2VcbiAgICAgICAgICAgbWF4IHRpbWUgcGVyIGludGVydmFsIGlzIG5vdCB0aGUgc2FtZSBhcyBtYXggdGltZSBnbG9iYWxseS5cblxuICAgICAgICAgICBUaGlzIGlzIG5vdCBzbyBmb3IgW21pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0sIHNvIHRoaXMgY2FuIHBvdGVudGlhbGx5XG4gICAgICAgICAgIGJlIHNpbXBsaWZpZWQuXG5cbiAgICAgICAgICAgUHJvYmFibHkgYSBiZXR0ZXIgY2hhbmdlIHdvdWxkIGJlIHRvIHNpbXBseSB0cmFuc2ZlciB0aGUgZXZlbnRzIHRvIHRoZVxuICAgICAgICAgICBcImZpcmVkXCIgY29sbGVjdGlvbiAoYW5kIHJlbmFtZSBpdCB0byBcImFib3V0IHRvIGZpcmVcIiksIHdoaWNoIGlzIHNvcnRlZCBieSB0aW1lLFxuICAgICAgICAgICBzbyBnZXR0aW5nIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhhdCBjb2xsZWN0aW9uIGlzIGVmZmljaWVudC5cbiAgICAgICAgKilcbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtaW5fYWxhcm1fdGltZSA6PSBUaW1lX25zLm1pbiAoYXQgcG9vbCAhY3VycmVudCkgIW1pbl9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtaW5fYWxhcm1fdGltZVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBMZXZlbCA9IHN0cnVjdFxuICAgICgqKiBGb3IgZ2l2ZW4gbGV2ZWwsIG9uZSBjYW4gYnJlYWsgdGhlIGJpdHMgaW50byBhIGtleSBpbnRvIHRocmVlIHJlZ2lvbnM6XG5cbiAgICAgICAge3ZcbiAgICAgICAgIHwgaGlnaGVyIGxldmVscyB8IHRoaXMgbGV2ZWwgfCBsb3dlciBsZXZlbHMgfFxuICAgICAgICB2fVxuXG4gICAgICAgIFwiTG93ZXIgbGV2ZWxzXCIgaXMgW2JpdHNfcGVyX3Nsb3RdIGJpdHMgd2lkZS4gIFwiVGhpcyBsZXZlbFwiIGlzIFtiaXRzXSB3aWRlLiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7ICgqIFRoZSBbaW5kZXhdIGluIHRoZSB0aW1pbmcgd2hlZWwncyBhcnJheSBvZiBsZXZlbHMgd2hlcmUgdGhpcyBsZXZlbCBpcy4gKilcbiAgICAgICAgaW5kZXggOiBpbnRcbiAgICAgIDsgKCogSG93IG1hbnkgW2JpdHNdIHRoaXMgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yLiAqKVxuICAgICAgICBiaXRzIDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsgKCogW3Nsb3RzX21hc2sgPSBTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czp0LmJpdHNdLiAqKVxuICAgICAgICBzbG90c19tYXNrIDogU2xvdHNfbWFzay50XG4gICAgICA7ICgqIFtiaXRzX3Blcl9zbG90XSBpcyBob3cgbWFueSBiaXRzIGVhY2ggc2xvdCBkaXN0aW5ndWlzaGVzLCBhbmQgaXMgdGhlIHN1bSBvZiBvZlxuICAgICAgICAgICB0aGUgW2JpdHNdIG9mIGFsbCB0aGUgbG93ZXIgbGV2ZWxzLiAqKVxuICAgICAgICBiaXRzX3Blcl9zbG90IDogTnVtX2tleV9iaXRzLnRcbiAgICAgIDsga2V5c19wZXJfc2xvdCA6IEtleS5TcGFuLnRcbiAgICAgIDsgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA6IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sudFxuICAgICAgOyAoKiBbZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5ID0ga2V5c19wZXJfc2xvdCAqIEFycmF5Lmxlbmd0aCBzbG90cyAtIDFdICopXG4gICAgICAgIGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA6IEtleS5TcGFuLnRcbiAgICAgIDsgKCogW2xlbmd0aF0gaXMgdGhlIG51bWJlciBvZiBlbHRzIGN1cnJlbnRseSBpbiB0aGlzIGxldmVsLiAqKVxuICAgICAgICBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgICAgOyAoKiBBbGwgZWxlbWVudHMgYXQgdGhpcyBsZXZlbCBoYXZlIHRoZWlyIFtrZXldIHNhdGlzZnkgW21pbl9hbGxvd2VkX2tleSA8PSBrZXkgPD1cbiAgICAgICAgICAgbWF4X2FsbG93ZWRfa2V5XS4gIEFsc28sIFttaW5fYWxsb3dlZF9rZXldIGlzIGEgbXVsdGlwbGUgb2YgW2tleXNfcGVyX3Nsb3RdLiAqKVxuICAgICAgICBtdXRhYmxlIG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG11dGFibGUgbWF4X2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgKCogW3Nsb3RzXSBob2xkcyB0aGUgKHBvc3NpYmx5IG51bGwpIHBvaW50ZXJzIHRvIHRoZSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RzXG4gICAgICAgICAgIG9mIGVsdHMuICBbQXJyYXkubGVuZ3RoIHNsb3RzID0gMSBsc2wgYml0c10uICopXG4gICAgICAgIHNsb3RzIDogKCdhIEludGVybmFsX2VsdC50IGFycmF5W0BzZXhwLm9wYXF1ZV0pXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IHNsb3QgdCB+a2V5ID0gS2V5LnNsb3Qga2V5IH5iaXRzX3Blcl9zbG90OnQuYml0c19wZXJfc2xvdCB+c2xvdHNfbWFzazp0LnNsb3RzX21hc2tcbiAgICBsZXQgbmV4dF9zbG90IHQgc2xvdCA9IFNsb3RzX21hc2submV4dF9zbG90IHQuc2xvdHNfbWFzayBzbG90XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5ID1cbiAgICAgIEtleS5taW5fa2V5X2luX3NhbWVfc2xvdCBrZXkgdC5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcblxuICAgIGxldCBjb21wdXRlX21pbl9hbGxvd2VkX2tleSB0IH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA9XG4gICAgICAoKiBUaGlzIGNvbXB1dGF0aW9uIGVuc3VyZXMgdGhhdCBbdF0ncyBbbWluX2FsbG93ZWRfa2V5XSBpcyBhcyBsYXJnZSBhcyBwb3NzaWJsZVxuICAgICAgICAgc3ViamVjdCB0byB0aGUgY29uc3RyYWludCB0aGF0IHRoZXJlIGlzIG5vIGludGVyLWxldmVsIGdhcC4gKilcbiAgICAgIGlmIEtleS5lcXVhbCBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSBLZXkubWF4X3ZhbHVlXG4gICAgICB0aGVuIEtleS5tYXhfdmFsdWVcbiAgICAgIGVsc2UgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5OihLZXkuc3VjYyBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSlcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICA7IG11dGFibGUgcG9vbCA6ICdhIEludGVybmFsX2VsdC5Qb29sLnRcbiAgICA7ICgqIFttaW5fZWx0XSBpcyBlaXRoZXIgbnVsbCBvciBhbiBlbGVtZW50IHdob3NlIGtleSBpcyBbZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIG1pbl9lbHQgOiAnYSBJbnRlcm5hbF9lbHQudFxuICAgIDsgKCogQWxsIGVsZW1lbnRzIGluIHRoZSBwcmlvcml0eSBxdWV1ZSBoYXZlIHRoZWlyIGtleSBbPj0gZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIGVsdF9rZXlfbG93ZXJfYm91bmQgOiBLZXkudFxuICAgIDsgbGV2ZWxzIDogJ2EgTGV2ZWwudCBhcnJheVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIHR5cGUgJ2EgcHJpb3JpdHlfcXVldWUgPSAnYSB0XG5cbiAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IEV4dGVybmFsX2VsdC5udWxsXG4gICAgbGV0IGF0IHAgdCA9IEludGVybmFsX2VsdC5hdCBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gICAgbGV0IGtleSBwIHQgPSBJbnRlcm5hbF9lbHQua2V5IHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgICBsZXQgdmFsdWUgcCB0ID0gSW50ZXJuYWxfZWx0LnZhbHVlIHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgZW5kXG5cbiAgbGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxuICBsZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuICBsZXQgbnVtX2xldmVscyB0ID0gQXJyYXkubGVuZ3RoIHQubGV2ZWxzXG4gIGxldCBtaW5fYWxsb3dlZF9rZXkgdCA9IExldmVsLm1pbl9hbGxvd2VkX2tleSB0LmxldmVscy4oMClcbiAgbGV0IG1heF9hbGxvd2VkX2tleSB0ID0gTGV2ZWwubWF4X2FsbG93ZWRfa2V5IHQubGV2ZWxzLihudW1fbGV2ZWxzIHQgLSAxKVxuXG4gIGxldCBpbnRlcm5hbF9pdGVyIHQgfmYgPVxuICAgIGlmIHQubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgZm9yIGxldmVsX2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggbGV2ZWxzIC0gMSBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgZm9yIHNsb3RfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBzbG90cyAtIDEgZG9cbiAgICAgICAgICAgIGxldCBlbHQgPSBzbG90cy4oc2xvdF9pbmRleCkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KSB0aGVuIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mXG4gICAgICAgICAgZG9uZSlcbiAgICAgIGRvbmUpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9IGludGVybmFsX2l0ZXIgdCB+ZjooZiA6IF8gRWx0LnQgLT4gdW5pdCA6PiBfIEludGVybmFsX2VsdC50IC0+IHVuaXQpXG5cbiAgbW9kdWxlIFByZXR0eSA9IHN0cnVjdFxuICAgIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIHsga2V5IDogS2V5LnRcbiAgICAgICAgOyB2YWx1ZSA6ICdhXG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtaW5fYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyBtYXhfYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyBlbHRzIDogJ2EgRWx0LnQgbGlzdFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBwcmV0dHkgdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICB7IFByZXR0eS5taW5fYWxsb3dlZF9rZXkgPSBtaW5fYWxsb3dlZF9rZXkgdFxuICAgIDsgbWF4X2FsbG93ZWRfa2V5ID0gbWF4X2FsbG93ZWRfa2V5IHRcbiAgICA7IGVsdHMgPVxuICAgICAgICAobGV0IHIgPSByZWYgW10gaW5cbiAgICAgICAgIGludGVybmFsX2l0ZXIgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICByXG4gICAgICAgICAgIDo9IHsgUHJldHR5LkVsdC5rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0XG4gICAgICAgICAgICAgIDsgdmFsdWUgPSBJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6OiAhcik7XG4gICAgICAgICBMaXN0LnJldiAhcilcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgbWF0Y2ggIXNleHBfb2ZfdF9zdHlsZSB3aXRoXG4gICAgfCBgSW50ZXJuYWwgLT4gWyVzZXhwICh0IDogYSB0X2ludGVybmFsKV1cbiAgICB8IGBQcmV0dHkgLT4gWyVzZXhwIChwcmV0dHkgdCA6IGEgUHJldHR5LnQpXVxuICA7O1xuXG4gIGxldCBjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSB+bGV2ZWxfYml0cyB+Yml0c19wZXJfc2xvdCA9XG4gICAgbGV0IGJpdHMgPSBOdW1fa2V5X2JpdHMuKCArICkgbGV2ZWxfYml0cyBiaXRzX3Blcl9zbG90IGluXG4gICAgaWYgTnVtX2tleV9iaXRzLmVxdWFsIGJpdHMgTnVtX2tleV9iaXRzLm1heF92YWx1ZVxuICAgIHRoZW4gS2V5LlNwYW4ubWF4X3ZhbHVlXG4gICAgZWxzZSBLZXkuU3Bhbi5wcmVkIChLZXkubnVtX2tleXMgYml0cylcbiAgOztcblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgOiB1bml0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBsZXZlbF9pbnZhcmlhbnQgbGV2ZWwgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIGxldmVsIFslc2V4cF9vZjogXyBMZXZlbC50XSAoZnVuICgpIC0+XG4gICAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIGxldmVsIGYgaW5cbiAgICAgICAgTGV2ZWwuRmllbGRzLml0ZXJcbiAgICAgICAgICB+aW5kZXg6KGNoZWNrIChmdW4gaW5kZXggLT4gYXNzZXJ0IChpbmRleCA+PSAwKSkpXG4gICAgICAgICAgfmJpdHM6KGNoZWNrIChmdW4gYml0cyAtPiBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBiaXRzIE51bV9rZXlfYml0cy56ZXJvKSkpXG4gICAgICAgICAgfnNsb3RzX21hc2s6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBTbG90c19tYXNrLnRdXG4gICAgICAgICAgICAgICAgICB+ZXhwZWN0OihTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czpsZXZlbC5iaXRzKSkpXG4gICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBiaXRzX3Blcl9zbG90IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID49ICkgYml0c19wZXJfc2xvdCBOdW1fa2V5X2JpdHMuemVybykpKVxuICAgICAgICAgIH5rZXlzX3Blcl9zbG90OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4ga2V5c19wZXJfc2xvdCAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAga2V5c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OihLZXkubnVtX2tleXMgbGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5lcXVhbFxuICAgICAgICAgICAgICAgICAgIG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICAgICAoTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICB+Yml0c19wZXJfc2xvdDpsZXZlbC5iaXRzX3Blcl9zbG90KSkpKVxuICAgICAgICAgIH5kaWZmX21heF9taW5fYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAgKGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgIH5sZXZlbF9iaXRzOmxldmVsLmJpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6bGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5sZW5ndGg6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICAgICAgICAgICA9IEFycmF5LmZvbGQgbGV2ZWwuc2xvdHMgfmluaXQ6MCB+ZjooZnVuIG4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gICAgICAgICAgICAgICAgICAgdGhlbiBuXG4gICAgICAgICAgICAgICAgICAgZWxzZSBuICsgSW50ZXJuYWxfZWx0Lmxlbmd0aCBwb29sIGVsdCkpKSlcbiAgICAgICAgICB+bWluX2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2FsbG93ZWRfa2V5IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgbWluX2FsbG93ZWRfa2V5IEtleS56ZXJvKTtcbiAgICAgICAgICAgICAgIGlmIEtleS4oIDwgKSBtaW5fYWxsb3dlZF9rZXkgS2V5Lm1heF92YWx1ZVxuICAgICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChLZXkucmVtIG1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90KVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6S2V5LlNwYW4uemVybykpXG4gICAgICAgICAgfm1heF9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1heF9hbGxvd2VkX2tleSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LnRdXG4gICAgICAgICAgICAgICAgIG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgIChLZXkuYWRkX2NsYW1wX3RvX21heFxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSkpKVxuICAgICAgICAgIH5zbG90czpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHNsb3RzIC0+XG4gICAgICAgICAgICAgICBBcnJheS5pdGVyIHNsb3RzIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaW52YXJpYW50IHBvb2wgaW52YXJpYW50X2EgZWx0O1xuICAgICAgICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICAgICAgICBLZXkuKCA+PSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgICAgICAgIEtleS4oIDw9IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5tYXhfYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgICAgICAgS2V5LiggPj0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIHQuZWx0X2tleV9sb3dlcl9ib3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKEludGVybmFsX2VsdC5sZXZlbF9pbmRleCBwb29sIGVsdCA9IGxldmVsLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudF9hIChJbnRlcm5hbF9lbHQudmFsdWUgcG9vbCBlbHQpKSkpKSkpXG4gICAgaW5cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF9pbnRlcm5hbF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1pbl9hbGxvd2VkX2tleSB0KSBLZXkuemVybyk7XG4gICAgICBhc3NlcnQgKEtleS4oID49ICkgKG1heF9hbGxvd2VkX2tleSB0KSAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5sZW5ndGg6KGNoZWNrIChmdW4gbGVuZ3RoIC0+IGFzc2VydCAobGVuZ3RoID49IDApKSlcbiAgICAgICAgfnBvb2w6KGNoZWNrIChJbnRlcm5hbF9lbHQuUG9vbC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgICAgfm1pbl9lbHQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZWx0XyAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XylcbiAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgIGFzc2VydCAoSW50ZXJuYWxfZWx0LmlzX3ZhbGlkIHQucG9vbCBlbHRfKTtcbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LmVxdWFsIHQuZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgZWx0XykpKSkpXG4gICAgICAgIH5lbHRfa2V5X2xvd2VyX2JvdW5kOlxuICAgICAgICAgIChjaGVjayAoZnVuIGVsdF9rZXlfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oID49ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWluX2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBhc3NlcnQgKEtleS4oIDw9ICkgZWx0X2tleV9sb3dlcl9ib3VuZCAobWF4X2FsbG93ZWRfa2V5IHQpKTtcbiAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBLZXkuZXF1YWwgZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgdC5taW5fZWx0KSkpKVxuICAgICAgICB+bGV2ZWxzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGxldmVscyAtPlxuICAgICAgICAgICAgIGFzc2VydCAobnVtX2xldmVscyB0ID4gMCk7XG4gICAgICAgICAgICAgQXJyYXkuaXRlcmkgbGV2ZWxzIH5mOihmdW4gbGV2ZWxfaW5kZXggbGV2ZWwgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAobGV2ZWxfaW5kZXggPSBMZXZlbC5pbmRleCBsZXZlbCk7XG4gICAgICAgICAgICAgICBsZXZlbF9pbnZhcmlhbnQgbGV2ZWw7XG4gICAgICAgICAgICAgICBpZiBsZXZlbF9pbmRleCA+IDBcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBsZXQgcHJldl9sZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXggLSAxKSBpblxuICAgICAgICAgICAgICAgICBsZXQgbW9kdWxlIEwgPSBMZXZlbCBpblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChMLmtleXNfcGVyX3Nsb3QgbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDooS2V5LlNwYW4uc3VjYyBwcmV2X2xldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS50XVxuICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgICAoTGV2ZWwuY29tcHV0ZV9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6cHJldl9sZXZlbC5tYXhfYWxsb3dlZF9rZXkpKSkpKSlcbiAgOztcblxuICAoKiogW21pbl9lbHRfXSByZXR1cm5zIFtudWxsXSBpZiBpdCBjYW4ndCBmaW5kIHRoZSBkZXNpcmVkIGVsZW1lbnQuICBXZSB3cmFwIGl0IHVwXG4gICAgICBhZnRlcndhcmRzIHRvIHJldHVybiBhbiBbb3B0aW9uXS4gKilcbiAgbGV0IG1pbl9lbHRfIHQgPVxuICAgIGlmIGlzX2VtcHR5IHRcbiAgICB0aGVuIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICB0aGVuIHQubWluX2VsdFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBtaW5fZWx0X2FscmVhZHlfZm91bmQgPSByZWYgKEludGVybmFsX2VsdC5udWxsICgpKSBpblxuICAgICAgbGV0IG1pbl9rZXlfYWxyZWFkeV9mb3VuZCA9IHJlZiBLZXkubWF4X3ZhbHVlIGluXG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgbGV0IG51bV9sZXZlbHMgPSBudW1fbGV2ZWxzIHQgaW5cbiAgICAgIHdoaWxlICFsZXZlbF9pbmRleCA8IG51bV9sZXZlbHMgZG9cbiAgICAgICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKCFsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgS2V5LiggPiApIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIFdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgYW55IG1vcmUgbGV2ZWxzLiAgUXVpdCB0aGUgbG9vcC4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSBudW1fbGV2ZWxzXG4gICAgICAgIGVsc2UgaWYgbGV2ZWwubGVuZ3RoID0gMFxuICAgICAgICB0aGVuIGluY3IgbGV2ZWxfaW5kZXhcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogTG9vayBpbiBbbGV2ZWxdLiAqKVxuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgbGV0IHNsb3RfbWluX2tleSA9XG4gICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKExldmVsLm1pbl9rZXlfaW5fc2FtZV9zbG90XG4gICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgIH5rZXk6KEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgc2xvdCA9IHJlZiAoTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OiFzbG90X21pbl9rZXkpIGluXG4gICAgICAgICAgKCogRmluZCB0aGUgZmlyc3Qgbm9uZW1wdHkgc2xvdCB3aXRoIGEgc21hbGwgZW5vdWdoIFtzbG90X21pbl9rZXldLiAqKVxuICAgICAgICAgIHdoaWxlXG4gICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXNfbnVsbCBzbG90cy4oIXNsb3QpXG4gICAgICAgICAgICAmJiBLZXkuKCA8ICkgIXNsb3RfbWluX2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgZG9cbiAgICAgICAgICAgIHNsb3QgOj0gTGV2ZWwubmV4dF9zbG90IGxldmVsICFzbG90O1xuICAgICAgICAgICAgc2xvdF9taW5fa2V5IDo9IEtleS5hZGQgIXNsb3RfbWluX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90XG4gICAgICAgICAgZG9uZTtcbiAgICAgICAgICBsZXQgZmlyc3QgPSBzbG90cy4oIXNsb3QpIGluXG4gICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIFZpc2l0IGFsbCBvZiB0aGUgZWx0cyBpbiB0aGlzIHNsb3QgYW5kIGZpbmQgb25lIHdpdGggbWluaW11bSBrZXkuICopXG4gICAgICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgICAgICBsZXQgY3VycmVudF9rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgaWYgS2V5LiggPD0gKSBjdXJyZW50X2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgIG1pbl9lbHRfYWxyZWFkeV9mb3VuZCA6PSAhY3VycmVudDtcbiAgICAgICAgICAgICAgICBtaW5fa2V5X2FscmVhZHlfZm91bmQgOj0gY3VycmVudF9rZXkpO1xuICAgICAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgKCogSWYgWyFsZXZlbF9pbmRleCA9IDBdIHRoZW4gYWxsIGVsdHMgaW4gdGhpcyBzbG90IGhhdmUgdGhlIHNhbWUgW2tleV0sXG4gICAgICAgICAgICAgICAgIGkuZS4gWyFzbG90X21pbl9rZXldLiAgU28sIHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgYW55IGVsZW1lbnRzIGFmdGVyXG4gICAgICAgICAgICAgICAgIFtmaXJzdF0uICBUaGlzIGlzIGEgdXNlZnVsIHNob3J0IGN1dCBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIHNhbWUgbWluIHNsb3QgaW4gbGV2ZWwgMC4gKilcbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHx8ICFsZXZlbF9pbmRleCA9IDBcbiAgICAgICAgICAgICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgICAgICAgICAgICBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgICAgICAgZG9uZSk7XG4gICAgICAgICAgKCogRmluaXNoZWQgbG9va2luZyBpbiBbbGV2ZWxdLiAgTW92ZSB1cCB0byB0aGUgbmV4dCBsZXZlbC4gKilcbiAgICAgICAgICBpbmNyIGxldmVsX2luZGV4KVxuICAgICAgZG9uZTtcbiAgICAgIHQubWluX2VsdCA8LSAhbWluX2VsdF9hbHJlYWR5X2ZvdW5kO1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtICFtaW5fa2V5X2FscmVhZHlfZm91bmQ7XG4gICAgICB0Lm1pbl9lbHQpXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5ID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgYm91bmRzXCJcbiAgICAgICAgICAoa2V5IDogS2V5LnQpXG4gICAgICAgICAgKG1pbl9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgKG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgfnByaW9yaXR5X3F1ZXVlOih0IDogXyB0KV1cbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgbGV2ZWwgYm91bmRzXCIgKGtleSA6IEtleS50KSAobGV2ZWwgOiBfIExldmVsLnQpXVxuICA7O1xuXG4gIGxldCBhZGRfZWx0IHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0IGluXG4gICAgaWYgbm90IChLZXkuKCA+PSApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpICYmIEtleS4oIDw9ICkga2V5IChtYXhfYWxsb3dlZF9rZXkgdCkpXG4gICAgdGhlbiByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5O1xuICAgICgqIEZpbmQgdGhlIGxvd2VzdCBsZXZlbCB0aGF0IHdpbGwgaG9sZCBbZWx0XS4gKilcbiAgICBsZXQgbGV2ZWxfaW5kZXggPVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIHdoaWxlIEtleS4oID4gKSBrZXkgKExldmVsLm1heF9hbGxvd2VkX2tleSB0LmxldmVscy4oIWxldmVsX2luZGV4KSkgZG9cbiAgICAgICAgaW5jciBsZXZlbF9pbmRleFxuICAgICAgZG9uZTtcbiAgICAgICFsZXZlbF9pbmRleFxuICAgIGluXG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgIGlmIG5vdCAoS2V5LiggPj0gKSBrZXkgbGV2ZWwubWluX2FsbG93ZWRfa2V5ICYmIEtleS4oIDw9ICkga2V5IGxldmVsLm1heF9hbGxvd2VkX2tleSlcbiAgICB0aGVuIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsO1xuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggKyAxO1xuICAgIEludGVybmFsX2VsdC5zZXRfbGV2ZWxfaW5kZXggcG9vbCBlbHQgbGV2ZWxfaW5kZXg7XG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIGxldCBmaXJzdCA9IHNsb3RzLihzbG90KSBpblxuICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgdGhlbiBJbnRlcm5hbF9lbHQuaW5zZXJ0X2F0X2VuZCBwb29sIGZpcnN0IH50b19hZGQ6ZWx0XG4gICAgZWxzZSAoXG4gICAgICBzbG90cy4oc2xvdCkgPC0gZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LmxpbmtfdG9fc2VsZiBwb29sIGVsdClcbiAgOztcblxuICBsZXQgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdCA9XG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgdC5wb29sIGVsdCBpblxuICAgIGlmIEtleS4oIDwgKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgdGhlbiAoXG4gICAgICB0Lm1pbl9lbHQgPC0gZWx0O1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIGtleSk7XG4gICAgYWRkX2VsdCB0IGVsdDtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2dvdF9pbnZhbGlkX2tleSB0IGtleSA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmFkZF9hdF9pbnRlcnZhbF9udW0gZ290IGludmFsaWQgaW50ZXJ2YWwgbnVtXCJcbiAgICAgICAgICB+aW50ZXJ2YWxfbnVtOihrZXkgOiBLZXkudClcbiAgICAgICAgICB+bWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtOihtaW5fYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW06KG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXVxuICA7O1xuXG4gIGxldCBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleSA9XG4gICAgaWYgS2V5LiggPCApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpIHx8IEtleS4oID4gKSBrZXkgKG1heF9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gcmFpc2VfZ290X2ludmFsaWRfa2V5IHQga2V5XG4gIDs7XG5cbiAgbGV0IGludGVybmFsX2FkZCB0IH5rZXkgfmF0IHZhbHVlID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBpZiBJbnRlcm5hbF9lbHQuUG9vbC5pc19mdWxsIHQucG9vbCB0aGVuIHQucG9vbCA8LSBJbnRlcm5hbF9lbHQuUG9vbC5ncm93IHQucG9vbDtcbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0LmNyZWF0ZSB0LnBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleDooLTEpIGluXG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdDtcbiAgICBlbHRcbiAgOztcblxuICAoKiogW3JlbW92ZV9vcl9yZV9hZGRfZWx0c10gdmlzaXRzIGVhY2ggZWxlbWVudCBpbiB0aGUgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBbZmlyc3RdLiAgSWYgdGhlIGVsZW1lbnQncyBrZXkgaXMgWz49IHRfbWluX2FsbG93ZWRfa2V5XSwgdGhlbiBpdCBhZGRzIHRoZSBlbGVtZW50XG4gICAgICBiYWNrIGF0IGEgbG93ZXIgbGV2ZWwuICBJZiBub3QsIHRoZW4gaXQgY2FsbHMgW2hhbmRsZV9yZW1vdmVkXSBhbmQgW2ZyZWVdcyB0aGVcbiAgICAgIGVsZW1lbnQuICopXG4gIGxldCByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCAobGV2ZWwgOiBfIExldmVsLnQpIGZpcnN0IH50X21pbl9hbGxvd2VkX2tleSB+aGFuZGxlX3JlbW92ZWRcbiAgICA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAoKiBXZSBleHRyYWN0IFtuZXh0XSBmcm9tIFtjdXJyZW50XSBmaXJzdCwgYmVjYXVzZSB3ZSB3aWxsIG1vZGlmeSBvciBbZnJlZV1cbiAgICAgICAgIFtjdXJyZW50XSBiZWZvcmUgY29udGludWluZyB0aGUgbG9vcC4gKilcbiAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgICBpZiBLZXkuKCA+PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQpIHRfbWluX2FsbG93ZWRfa2V5XG4gICAgICB0aGVuIGFkZF9lbHQgdCAhY3VycmVudFxuICAgICAgZWxzZSAoXG4gICAgICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICAgICAgaGFuZGxlX3JlbW92ZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCAhY3VycmVudCk7XG4gICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgIWN1cnJlbnQpO1xuICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICBkb25lXG4gIDs7XG5cbiAgKCoqIFtpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgW2xldmVsXSB0byBhc1xuICAgICAgbGFyZ2UgYSB2YWx1ZSBhcyBwb3NzaWJsZSwgYnV0IG5vIG1vcmUgdGhhbiBbbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleV0uXG4gICAgICBbdF9taW5fYWxsb3dlZF9rZXldIGlzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGZvciB0aGUgZW50aXJlIHRpbWluZyB3aGVlbC4gIEFzXG4gICAgICBlbGVtZW50cyBhcmUgZW5jb3VudGVyZWQsIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGUgdGltaW5nIHdoZWVsIGlmIHRoZWlyIGtleSBpc1xuICAgICAgc21hbGxlciB0aGFuIFt0X21pbl9hbGxvd2VkX2tleV0sIG9yIGFkZGVkIGF0IGEgbG93ZXIgbGV2ZWwgaWYgbm90LiAqKVxuICBsZXQgaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIHRcbiAgICAgICAgKGxldmVsIDogXyBMZXZlbC50KVxuICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgfnRfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIH5oYW5kbGVfcmVtb3ZlZFxuICAgID1cbiAgICBsZXQgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgTGV2ZWwuY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkgbGV2ZWwgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgaW5cbiAgICAoKiBXZSByZXF1aXJlIHRoYXQgW21vZCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdCA9IDBdLiAgU28sXG4gICAgICAgd2Ugc3RhcnQgW2xldmVsX21pbl9hbGxvd2VkX2tleV0gd2hlcmUgdGhhdCBpcyB0cnVlLCBhbmQgdGhlbiBpbmNyZWFzZSBpdCBieVxuICAgICAgIFtrZXlzX3Blcl9zbG90XSBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC4gKilcbiAgICBsZXQgbGV2ZWxfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgIExldmVsLm1pbl9rZXlfaW5fc2FtZV9zbG90XG4gICAgICAgIGxldmVsXG4gICAgICAgIH5rZXk6XG4gICAgICAgICAgKEtleS5taW5cbiAgICAgICAgICAgICBkZXNpcmVkX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgIChLZXkubWF4IGxldmVsLm1pbl9hbGxvd2VkX2tleSB0LmVsdF9rZXlfbG93ZXJfYm91bmQpKVxuICAgIGluXG4gICAgbGV0IGxldmVsX21pbl9hbGxvd2VkX2tleSA9IHJlZiBsZXZlbF9taW5fYWxsb3dlZF9rZXkgaW5cbiAgICBsZXQgc2xvdCA9IHJlZiAoTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OiFsZXZlbF9taW5fYWxsb3dlZF9rZXkpIGluXG4gICAgbGV0IGtleXNfcGVyX3Nsb3QgPSBsZXZlbC5rZXlzX3Blcl9zbG90IGluXG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICB3aGlsZSBLZXkuKCA8ICkgIWxldmVsX21pbl9hbGxvd2VkX2tleSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSBkb1xuICAgICAgaWYgbGV2ZWwubGVuZ3RoID0gMFxuICAgICAgdGhlblxuICAgICAgICAoKiBJZiBubyBlbGVtZW50cyByZW1haW4gYXQgdGhpcyBsZXZlbCwgd2UgY2FuIGp1c3Qgc2V0IFttaW5fYWxsb3dlZF9rZXldIHRvIHRoZVxuICAgICAgICAgICBkZXNpcmVkIHZhbHVlLiAqKVxuICAgICAgICBsZXZlbF9taW5fYWxsb3dlZF9rZXkgOj0gZGVzaXJlZF9taW5fYWxsb3dlZF9rZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgZmlyc3QgPSBzbG90cy4oIXNsb3QpIGluXG4gICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHNsb3RzLighc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCk7XG4gICAgICAgICAgcmVtb3ZlX29yX3JlX2FkZF9lbHRzIHQgbGV2ZWwgZmlyc3QgfnRfbWluX2FsbG93ZWRfa2V5IH5oYW5kbGVfcmVtb3ZlZCk7XG4gICAgICAgIHNsb3QgOj0gTGV2ZWwubmV4dF9zbG90IGxldmVsICFzbG90O1xuICAgICAgICBsZXZlbF9taW5fYWxsb3dlZF9rZXkgOj0gS2V5LmFkZF9jbGFtcF90b19tYXggIWxldmVsX21pbl9hbGxvd2VkX2tleSBrZXlzX3Blcl9zbG90KVxuICAgIGRvbmU7XG4gICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5IDwtIGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5O1xuICAgIGxldmVsLm1heF9hbGxvd2VkX2tleVxuICAgIDwtIEtleS5hZGRfY2xhbXBfdG9fbWF4IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICA7O1xuXG4gIG1vZHVsZSBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkXG4gIGVuZFxuXG4gIGxldCBpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZCA6IEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQudCA9XG4gICAgaWYgS2V5LiggPD0gKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgZWxzZSAoXG4gICAgICAoKiBXZSBpbmNyZWFzZSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgbGV2ZWxzIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlIGludmFyaWFudFxuICAgICAgICAgdGhhdCB0aGV5IGhhdmUgYXMgbGFyZ2UgYXMgcG9zc2libGUgYSBbbWluX2FsbG93ZWRfa2V5XSwgd2hpbGUgbGVhdmluZyBubyBnYXBzXG4gICAgICAgICBpbiBrZXlzLiAqKVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIGxldCByZXN1bHQgPSByZWYgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC5NYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZCBpblxuICAgICAgbGV0IHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5ID0gcmVmIChLZXkucHJlZCBrZXkpIGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGxldCBudW1fbGV2ZWxzID0gbnVtX2xldmVscyB0IGluXG4gICAgICB3aGlsZSAhbGV2ZWxfaW5kZXggPCBudW1fbGV2ZWxzIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4oIWxldmVsX2luZGV4KSBpblxuICAgICAgICBsZXQgbWluX2FsbG93ZWRfa2V5X2JlZm9yZSA9IGxldmVsLm1pbl9hbGxvd2VkX2tleSBpblxuICAgICAgICBpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICB0XG4gICAgICAgICAgbGV2ZWxcbiAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6IXByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgfnRfbWluX2FsbG93ZWRfa2V5OmtleVxuICAgICAgICAgIH5oYW5kbGVfcmVtb3ZlZDtcbiAgICAgICAgaWYgS2V5LmVxdWFsIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpIG1pbl9hbGxvd2VkX2tleV9iZWZvcmVcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogVGhpcyBsZXZlbCBkaWQgbm90IHNoaWZ0LiAgRG9uJ3Qgc2hpZnQgYW55IGhpZ2hlciBsZXZlbHMuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gbnVtX2xldmVscztcbiAgICAgICAgICByZXN1bHQgOj0gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBMZXZlbCBbbGV2ZWxfaW5kZXhdIHNoaWZ0ZWQuICBDb25zaWRlciBzaGlmdGluZyBoaWdoZXIgbGV2ZWxzLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9ICFsZXZlbF9pbmRleCArIDE7XG4gICAgICAgICAgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgOj0gTGV2ZWwubWF4X2FsbG93ZWRfa2V5IGxldmVsKVxuICAgICAgZG9uZTtcbiAgICAgIGlmIEtleS4oID4gKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogV2UgaGF2ZSByZW1vdmVkIFt0Lm1pbl9lbHRdIG9yIGl0IHdhcyBhbHJlYWR5IG51bGwsIHNvIGp1c3Qgc2V0IGl0IHRvXG4gICAgICAgICAgIG51bGwuICopXG4gICAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIG1pbl9hbGxvd2VkX2tleSB0KTtcbiAgICAgICFyZXN1bHQpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgP2xldmVsX2JpdHMgKCkgPVxuICAgIGxldCBsZXZlbF9iaXRzID1cbiAgICAgIG1hdGNoIGxldmVsX2JpdHMgd2l0aFxuICAgICAgfCBTb21lIGwgLT4gbFxuICAgICAgfCBOb25lIC0+IExldmVsX2JpdHMuZGVmYXVsdFxuICAgIGluXG4gICAgbGV0IF8sIF8sIGxldmVscyA9XG4gICAgICBMaXN0LmZvbGRpXG4gICAgICAgIGxldmVsX2JpdHNcbiAgICAgICAgfmluaXQ6KE51bV9rZXlfYml0cy56ZXJvLCBLZXkuemVybywgW10pXG4gICAgICAgIH5mOihmdW5cbiAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgIChiaXRzX3Blcl9zbG90LCBtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5LCBsZXZlbHMpXG4gICAgICAgICAgICAgKGxldmVsX2JpdHMgOiBOdW1fa2V5X2JpdHMudClcbiAgICAgICAgICAgICAtPlxuICAgICAgICAgICAgICAgbGV0IGtleXNfcGVyX3Nsb3QgPSBLZXkubnVtX2tleXMgYml0c19wZXJfc2xvdCBpblxuICAgICAgICAgICAgICAgbGV0IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgIGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IH5sZXZlbF9iaXRzIH5iaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPVxuICAgICAgICAgICAgICAgICBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmNyZWF0ZSB+Yml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBtaW5fYWxsb3dlZF9rZXkgPVxuICAgICAgICAgICAgICAgICBLZXkubWluX2tleV9pbl9zYW1lX3Nsb3QgbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1heF9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgIEtleS5hZGRfY2xhbXBfdG9fbWF4IG1pbl9hbGxvd2VkX2tleSBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBsZXQgbGV2ZWwgPVxuICAgICAgICAgICAgICAgICB7IExldmVsLmluZGV4XG4gICAgICAgICAgICAgICAgIDsgYml0cyA9IGxldmVsX2JpdHNcbiAgICAgICAgICAgICAgICAgOyBzbG90c19tYXNrID0gU2xvdHNfbWFzay5jcmVhdGUgfmxldmVsX2JpdHNcbiAgICAgICAgICAgICAgICAgOyBiaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAgIDsga2V5c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICA7IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICAgOyBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgOyBsZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgIDsgbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIDsgbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIDsgc2xvdHMgPVxuICAgICAgICAgICAgICAgICAgICAgQXJyYXkuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgIH5sZW46KEludDYzLnRvX2ludF9leG4gKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoIE51bV9rZXlfYml0cy4oICsgKSBsZXZlbF9iaXRzIGJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICwgS2V5LnN1Y2NfY2xhbXBfdG9fbWF4IG1heF9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgLCBsZXZlbCA6OiBsZXZlbHMgKSlcbiAgICBpblxuICAgIHsgbGVuZ3RoID0gMFxuICAgIDsgcG9vbCA9IEludGVybmFsX2VsdC5Qb29sLmNyZWF0ZSA/Y2FwYWNpdHkgKClcbiAgICA7IG1pbl9lbHQgPSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIDsgZWx0X2tleV9sb3dlcl9ib3VuZCA9IEtleS56ZXJvXG4gICAgOyBsZXZlbHMgPSBBcnJheS5vZl9saXN0X3JldiBsZXZlbHNcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG1lbSB0IGVsdCA9IEludGVybmFsX2VsdC5leHRlcm5hbF9pc192YWxpZCB0LnBvb2wgZWx0XG5cbiAgbGV0IGludGVybmFsX3JlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBpZiBJbnRlcm5hbF9lbHQuZXF1YWwgZWx0IHQubWluX2VsdFxuICAgIHRoZW5cbiAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgICgqIFdlIGtlZXAgW3QuZWx0X2xvd2VyX2JvdW5kXSBzaW5jZSBpdCBpcyB2YWxpZCBldmVuIHRob3VnaCBbdC5taW5fZWx0XSBpcyBiZWluZ1xuICAgICAgIHJlbW92ZWQuICopO1xuICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oSW50ZXJuYWxfZWx0LmxldmVsX2luZGV4IHBvb2wgZWx0KSBpblxuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggLSAxO1xuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXk6KEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpIGluXG4gICAgbGV0IGZpcnN0ID0gc2xvdHMuKHNsb3QpIGluXG4gICAgaWYgcGh5c19lcXVhbCBlbHQgKEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0KVxuICAgIHRoZW4gKCogW2VsdF0gaXMgdGhlIG9ubHkgZWxlbWVudCBpbiB0aGUgc2xvdCAqKVxuICAgICAgc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSAoXG4gICAgICBpZiBwaHlzX2VxdWFsIGVsdCBmaXJzdCB0aGVuIHNsb3RzLihzbG90KSA8LSBJbnRlcm5hbF9lbHQubmV4dCBwb29sIGVsdDtcbiAgICAgIEludGVybmFsX2VsdC51bmxpbmsgcG9vbCBlbHQpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwb29sIGVsdCBpblxuICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdFxuICA7O1xuXG4gIGxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfmhhbmRsZV9maXJlZCB+a2V5IH5ub3cgPVxuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLigwKSBpblxuICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBzbG90ID0gTGV2ZWwuc2xvdCBsZXZlbCB+a2V5IGluXG4gICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmaXJzdCA9IHJlZiBzbG90cy4oc2xvdCkgaW5cbiAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgIWZpcnN0KVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVmICFmaXJzdCBpblxuICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgICBsZXQgZWx0ID0gIWN1cnJlbnQgaW5cbiAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0IGluXG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0ICFmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0O1xuICAgICAgICAgIGlmIFRpbWVfbnMuKCA8PSApIChJbnRlcm5hbF9lbHQuYXQgcG9vbCBlbHQpIG5vd1xuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgaGFuZGxlX2ZpcmVkIChJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWwgZWx0KTtcbiAgICAgICAgICAgIGludGVybmFsX3JlbW92ZSB0IGVsdDtcbiAgICAgICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0O1xuICAgICAgICAgICAgKCogV2UgcmVjb21wdXRlIFtmaXJzdF0gYmVjYXVzZSBbaW50ZXJuYWxfcmVtb3ZlXSBtYXkgaGF2ZSBjaGFuZ2VkIGl0LiAqKVxuICAgICAgICAgICAgZmlyc3QgOj0gc2xvdHMuKHNsb3QpKVxuICAgICAgICBkb25lKSlcbiAgOztcblxuICBsZXQgY2hhbmdlIHQgZWx0IH5rZXkgfmF0ID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5zZXRfa2V5IHBvb2wgZWx0IGtleTtcbiAgICBJbnRlcm5hbF9lbHQuc2V0X2F0IHBvb2wgZWx0IGF0O1xuICAgIGludGVybmFsX2FkZF9lbHQgdCBlbHRcbiAgOztcblxuICBsZXQgY2xlYXIgdCA9XG4gICAgaWYgbm90IChpc19lbXB0eSB0KVxuICAgIHRoZW4gKFxuICAgICAgdC5sZW5ndGggPC0gMDtcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgZnJlZV9lbHQgZWx0ID0gSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgZm9yIGxldmVsX2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggbGV2ZWxzIC0gMSBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSBsZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBsZXZlbC5sZW5ndGggPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldmVsLmxlbmd0aCA8LSAwO1xuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgZm9yIHNsb3RfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBzbG90cyAtIDEgZG9cbiAgICAgICAgICAgIGxldCBlbHQgPSBzbG90cy4oc2xvdF9pbmRleCkgaW5cbiAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0KVxuICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgIEludGVybmFsX2VsdC5pdGVyIHBvb2wgZWx0IH5mOmZyZWVfZWx0O1xuICAgICAgICAgICAgICBzbG90cy4oc2xvdF9pbmRleCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKCkpXG4gICAgICAgICAgZG9uZSlcbiAgICAgIGRvbmUpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsX2VsdCA9IFByaW9yaXR5X3F1ZXVlLkludGVybmFsX2VsdFxubW9kdWxlIEtleSA9IFByaW9yaXR5X3F1ZXVlLktleVxubW9kdWxlIEludGVydmFsX251bSA9IEtleVxuXG5sZXQgbWluX2ludGVydmFsX251bSA9IEludGVydmFsX251bS56ZXJvXG5cbigqIEFsbCB0aW1lIGZyb20gdGhlIGVwb2NoIG9ud2FyZHMgaXMgYnJva2VuIGludG8gaGFsZi1vcGVuIGludGVydmFscyBvZiBzaXplXG4gICBbQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiBjb25maWddLiAgVGhlIGludGVydmFscyBhcmUgbnVtYmVyZWQgc3RhcnRpbmcgYXQgemVybywgYW5kIGFcbiAgIHRpbWUncyBpbnRlcnZhbCBudW1iZXIgc2VydmVzIGFzIGl0cyBrZXkgaW4gW3ByaW9yaXR5X3F1ZXVlXS4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgOyBzdGFydCA6IFRpbWVfbnMudFxuICA7ICgqIFttYXhfaW50ZXJ2YWxfbnVtXSBpcyB0aGUgaW50ZXJ2YWwgbnVtYmVyIG9mIFttYXhfdGltZV0uICopXG4gICAgbWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50XG4gIDsgbXV0YWJsZSBub3cgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgOiBUaW1lX25zLnRcbiAgOyBwcmlvcml0eV9xdWV1ZSA6ICdhIFByaW9yaXR5X3F1ZXVlLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG50eXBlICdhIHRpbWluZ193aGVlbCA9ICdhIHRcbnR5cGUgJ2EgdF9ub3cgPSAnYSB0XG5cbmxldCBzZXhwX29mX3Rfbm93IF8gdCA9IFslc2V4cCAodC5ub3cgOiBUaW1lX25zLnQpXVxubGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiB0LmNvbmZpZ1xuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgUHJpb3JpdHlfcXVldWUuRWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgbnVsbCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5udWxsXG4gIGxldCBhdCB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LmF0IHR3LnByaW9yaXR5X3F1ZXVlIHRcbiAgbGV0IHZhbHVlIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQudmFsdWUgdHcucHJpb3JpdHlfcXVldWUgdFxuICBsZXQgaW50ZXJ2YWxfbnVtIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQua2V5IHR3LnByaW9yaXR5X3F1ZXVlIHRcbmVuZFxuXG5sZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG5sZXQgaXRlciB0IH5mID0gUHJpb3JpdHlfcXVldWUuaXRlciB0LnByaW9yaXR5X3F1ZXVlIH5mXG5cbm1vZHVsZSBQcmV0dHkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEFsYXJtID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgYXQgOiBUaW1lX25zLnRcbiAgICAgIDsgdmFsdWUgOiAnYVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICAgIGxldCBjcmVhdGUgdCBhbGFybSA9IHsgYXQgPSBBbGFybS5hdCB0IGFsYXJtOyB2YWx1ZSA9IEFsYXJtLnZhbHVlIHQgYWxhcm0gfVxuICAgIGxldCBjb21wYXJlIHQxIHQyID0gVGltZV9ucy5jb21wYXJlIChhdCB0MSkgKGF0IHQyKVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgICA7IHN0YXJ0IDogVGltZV9ucy50XG4gICAgOyBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgICA7IG5vdyA6IFRpbWVfbnMudFxuICAgIDsgYWxhcm1zIDogJ2EgQWxhcm0udCBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBwcmV0dHlcbiAgICAgICh7IGNvbmZpZ1xuICAgICAgIDsgc3RhcnRcbiAgICAgICA7IG1heF9pbnRlcnZhbF9udW1cbiAgICAgICA7IG5vd1xuICAgICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9IF9cbiAgICAgICA7IG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPSBfXG4gICAgICAgOyBwcmlvcml0eV9xdWV1ZSA9IF9cbiAgICAgICB9IGFzIHQpXG4gID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiByIDo9IFByZXR0eS5BbGFybS5jcmVhdGUgdCBhIDo6ICFyKTtcbiAgbGV0IGFsYXJtcyA9IExpc3Quc29ydCAhciB+Y29tcGFyZTpQcmV0dHkuQWxhcm0uY29tcGFyZSBpblxuICB7IFByZXR0eS5jb25maWc7IHN0YXJ0OyBtYXhfaW50ZXJ2YWxfbnVtOyBub3c7IGFsYXJtcyB9XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgbWF0Y2ggIXNleHBfb2ZfdF9zdHlsZSB3aXRoXG4gIHwgYEludGVybmFsIC0+IHNleHBfb2ZfdF9pbnRlcm5hbCBzZXhwX29mX2EgdFxuICB8IGBQcmV0dHkgLT4gWyVzZXhwIChwcmV0dHkgdCA6IGEgUHJldHR5LnQpXVxuOztcblxubGV0IGxlbmd0aCB0ID0gUHJpb3JpdHlfcXVldWUubGVuZ3RoIHQucHJpb3JpdHlfcXVldWVcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldFtAY29sZF0gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF9leG5fb2ZfZW1wdHlfdGltaW5nX3doZWVsIHQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIiB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF93aXRoX2FsbF9hbGFybXNfaW5fbWF4X2ludGVydmFsIHQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB3aXRoIGFsbCBhbGFybXMgaW4gbWF4IGludGVydmFsXCJcbiAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG47O1xuXG5sZXQgcG9vbCB0ID0gUHJpb3JpdHlfcXVldWUucG9vbCB0LnByaW9yaXR5X3F1ZXVlXG5cbmxldCBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWUgfmFsYXJtX3ByZWNpc2lvbiA9XG4gIEludGVydmFsX251bS5vZl9pbnQ2MyAoQWxhcm1fcHJlY2lzaW9uLmludGVydmFsX251bSBhbGFybV9wcmVjaXNpb24gdGltZSlcbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdGltZSA9XG4gIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZSB+YWxhcm1fcHJlY2lzaW9uOnQuY29uZmlnLmFsYXJtX3ByZWNpc2lvblxuOztcblxubGV0IGludGVydmFsX251bSB0IHRpbWUgPVxuICBpZiBUaW1lX25zLiggPCApIHRpbWUgbWluX3RpbWVcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW0gZ290IHRpbWUgdG9vIGZhciBpbiB0aGUgcGFzdFwiICh0aW1lIDogVGltZV9ucy50KV07XG4gIGludGVydmFsX251bV91bmNoZWNrZWQgdCB0aW1lXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGludGVydmFsX251bSA9XG4gIEFsYXJtX3ByZWNpc2lvbi5pbnRlcnZhbF9udW1fc3RhcnRcbiAgICB0LmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICAoaW50ZXJ2YWxfbnVtIHw+IEludGVydmFsX251bS50b19pbnQ2Mylcbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fc21hbGwgaW50ZXJ2YWxfbnVtID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtX3N0YXJ0IGdvdCB0b28gc21hbGwgaW50ZXJ2YWxfbnVtXCJcbiAgICAgICAgKGludGVydmFsX251bSA6IEludGVydmFsX251bS50KVxuICAgICAgICAobWluX2ludGVydmFsX251bSA6IEludGVydmFsX251bS50KV1cbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fbGFyZ2UgdCBpbnRlcnZhbF9udW0gPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW1fc3RhcnQgZ290IHRvbyBsYXJnZSBpbnRlcnZhbF9udW1cIlxuICAgICAgICAoaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXG4gICAgICAgICh0Lm1heF9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udCldXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgaW50ZXJ2YWxfbnVtID1cbiAgaWYgSW50ZXJ2YWxfbnVtLiggPCApIGludGVydmFsX251bSBtaW5faW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fc21hbGwgaW50ZXJ2YWxfbnVtO1xuICBpZiBJbnRlcnZhbF9udW0uKCA+ICkgaW50ZXJ2YWxfbnVtIHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX2xhcmdlIHQgaW50ZXJ2YWxfbnVtO1xuICBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgaW50ZXJ2YWxfbnVtXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleSA9XG4gICgqIFtpbnRlcnZhbF9udW1fc3RhcnQgdCBrZXldIGlzIHRoZSBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgc3RhcnQgb2YgdGhlIHRpbWUgaW50ZXJ2YWxcbiAgICAgaG9sZGluZyB0aGUgZmlyc3QgYWxhcm0gaW4gW3RdLiAgQWR2YW5jaW5nIHRvIHRoYXQgd291bGQgbm90IGJlIGVub3VnaCwgc2luY2UgdGhlXG4gICAgIGFsYXJtcyBpbiB0aGF0IGludGVydmFsIGRvbid0IGZpcmUgdW50aWwgdGhlIGNsb2NrIGlzIGFkdmFuY2VkIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgbmV4dCBpbnRlcnZhbC4gIFNvLCB3ZSB1c2UgW3N1Y2Mga2V5XSB0byBhZHZhbmNlIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICBpbnRlcnZhbC4gKilcbiAgaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKEtleS5zdWNjIGtleSlcbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdCBpblxuICAgIGlmIEludGVydmFsX251bS5lcXVhbCBrZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5KSlcbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF9leG5fb2ZfZW1wdHlfdGltaW5nX3doZWVsIHQ7XG4gIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdCBpblxuICBpZiBJbnRlcnZhbF9udW0uZXF1YWwga2V5IHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfd2l0aF9hbGxfYWxhcm1zX2luX21heF9pbnRlcnZhbCB0O1xuICBuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5XG47O1xuXG5sZXQgY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgPVxuICBsZXQgbWF4X2FsbG93ZWRfa2V5ID0gUHJpb3JpdHlfcXVldWUubWF4X2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJ2YWxfbnVtLiggPj0gKSBtYXhfYWxsb3dlZF9rZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gbWF4X3RpbWVcbiAgZWxzZVxuICAgIFRpbWVfbnMuYWRkXG4gICAgICAoaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IG1heF9hbGxvd2VkX2tleSlcbiAgICAgIChUaW1lX25zLlNwYW4uKCAtICkgKGFsYXJtX3ByZWNpc2lvbiB0KSBUaW1lX25zLlNwYW4ubmFub3NlY29uZClcbjs7XG5cbmxldCBub3dfaW50ZXJ2YWxfbnVtIHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZVxubGV0IG1pbl9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSA9IG5vd19pbnRlcnZhbF9udW1cbmxldCBtYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gdCA9IGludGVydmFsX251bSB0IChtYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpXG5sZXQgaW50ZXJ2YWxfc3RhcnQgdCB0aW1lID0gaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IChpbnRlcnZhbF9udW0gdCB0aW1lKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y29uZmlnOihjaGVjayBDb25maWcuaW52YXJpYW50KVxuICAgICAgfnN0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1biBzdGFydCAtPlxuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+PSApIHN0YXJ0IG1pbl90aW1lKTtcbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBzdGFydCBtYXhfdGltZSkpKVxuICAgICAgfm1heF9pbnRlcnZhbF9udW06XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9pbnRlcnZhbF9udW0gLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogSW50ZXJ2YWxfbnVtLnRdXG4gICAgICAgICAgICAgfmV4cGVjdDptYXhfaW50ZXJ2YWxfbnVtXG4gICAgICAgICAgICAgKGludGVydmFsX251bSB0IG1heF90aW1lKTtcbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogSW50ZXJ2YWxfbnVtLnRdXG4gICAgICAgICAgICAgfmV4cGVjdDptYXhfaW50ZXJ2YWxfbnVtXG4gICAgICAgICAgICAgKGludGVydmFsX251bSB0IChpbnRlcnZhbF9udW1fc3RhcnQgdCBtYXhfaW50ZXJ2YWxfbnVtKSkpKVxuICAgICAgfm5vdzpcbiAgICAgICAgKGNoZWNrIChmdW4gbm93IC0+XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oID49ICkgbm93IHQuc3RhcnQpO1xuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIG5vdyBtYXhfdGltZSk7XG4gICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgSW50ZXJ2YWxfbnVtLmVxdWFsXG4gICAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgdC5ub3cpXG4gICAgICAgICAgICAgICAoUHJpb3JpdHlfcXVldWUubWluX2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWUpKSkpXG4gICAgICB+bm93X2ludGVydmFsX251bV9zdGFydDpcbiAgICAgICAgKGNoZWNrIChmdW4gbm93X2ludGVydmFsX251bV9zdGFydCAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdXG4gICAgICAgICAgICAgbm93X2ludGVydmFsX251bV9zdGFydFxuICAgICAgICAgICAgIH5leHBlY3Q6KGludGVydmFsX251bV9zdGFydCB0IChub3dfaW50ZXJ2YWxfbnVtIHQpKSkpXG4gICAgICB+bWF4X2FsbG93ZWRfYWxhcm1fdGltZTpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2FsbG93ZWRfYWxhcm1fdGltZSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdXG4gICAgICAgICAgICAgbWF4X2FsbG93ZWRfYWxhcm1fdGltZVxuICAgICAgICAgICAgIH5leHBlY3Q6KGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KSkpXG4gICAgICB+cHJpb3JpdHlfcXVldWU6KGNoZWNrIChQcmlvcml0eV9xdWV1ZS5pbnZhcmlhbnQgaW52YXJpYW50X2EpKTtcbiAgICBpdGVyIHQgfmY6KGZ1biBhbGFybSAtPlxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgSW50ZXJ2YWxfbnVtLmVxdWFsXG4gICAgICAgICAgKEFsYXJtLmludGVydmFsX251bSB0IGFsYXJtKVxuICAgICAgICAgIChpbnRlcnZhbF9udW0gdCAoQWxhcm0uYXQgdCBhbGFybSkpKTtcbiAgICAgIGFzc2VydCAoXG4gICAgICAgIFRpbWVfbnMuKCA+PSApXG4gICAgICAgICAgKGludGVydmFsX3N0YXJ0IHQgKEFsYXJtLmF0IHQgYWxhcm0pKVxuICAgICAgICAgIChpbnRlcnZhbF9zdGFydCB0IChub3cgdCkpKTtcbiAgICAgIGFzc2VydCAoXG4gICAgICAgIFRpbWVfbnMuKCA+ICkgKEFsYXJtLmF0IHQgYWxhcm0pIChUaW1lX25zLnN1YiAobm93IHQpIChhbGFybV9wcmVjaXNpb24gdCkpKSkpXG47O1xuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZCA9XG4gIGlmIFRpbWVfbnMuKCA+ICkgdG9fIChub3cgdClcbiAgdGhlbiAoXG4gICAgdC5ub3cgPC0gdG9fO1xuICAgIGxldCBrZXkgPSBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdG9fIGluXG4gICAgdC5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IDwtIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBrZXk7XG4gICAgbWF0Y2hcbiAgICAgIFByaW9yaXR5X3F1ZXVlLmluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgIH5rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkOmhhbmRsZV9maXJlZFxuICAgIHdpdGhcbiAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZSAtPlxuICAgICAgaWYgZGVidWdcbiAgICAgIHRoZW5cbiAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPSApIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSAoY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKVxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWQgLT5cbiAgICAgIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbjs7XG5cbmxldCBjcmVhdGUgfmNvbmZpZyB+c3RhcnQgPVxuICBpZiBUaW1lX25zLiggPCApIHN0YXJ0IFRpbWVfbnMuZXBvY2hcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbC5jcmVhdGUgZ290IHN0YXJ0IGJlZm9yZSB0aGUgZXBvY2hcIiAoc3RhcnQgOiBUaW1lX25zLnQpXTtcbiAgbGV0IHQgPVxuICAgIHsgY29uZmlnXG4gICAgOyBzdGFydFxuICAgIDsgbWF4X2ludGVydmFsX251bSA9XG4gICAgICAgIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZTptYXhfdGltZSB+YWxhcm1fcHJlY2lzaW9uOmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICA7IG5vdyA9IFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9XG4gICAgICAgIFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IG1heF90aW1lICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IHByaW9yaXR5X3F1ZXVlID1cbiAgICAgICAgUHJpb3JpdHlfcXVldWUuY3JlYXRlID9jYXBhY2l0eTpjb25maWcuY2FwYWNpdHkgfmxldmVsX2JpdHM6Y29uZmlnLmxldmVsX2JpdHMgKClcbiAgICB9XG4gIGluXG4gIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdDtcbiAgYWR2YW5jZV9jbG9jayB0IH50b186c3RhcnQgfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgdFxuOztcblxubGV0IGFkZF9hdF9pbnRlcnZhbF9udW0gdCB+YXQgdmFsdWUgPVxuICBJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWxcbiAgICAoUHJpb3JpdHlfcXVldWUuaW50ZXJuYWxfYWRkXG4gICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgIH5rZXk6YXRcbiAgICAgICB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuICAgICAgIHZhbHVlKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gdGhhdCBmYXIgaW4gdGhlIGZ1dHVyZVwiXG4gICAgICAgIChhdCA6IFRpbWVfbnMudClcbiAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6KHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2JlZm9yZV9zdGFydF9vZl9jdXJyZW50X2ludGVydmFsIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gYmVmb3JlIHN0YXJ0IG9mIGN1cnJlbnQgaW50ZXJ2YWxcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Oih0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnQpXVxuOztcblxubGV0IGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQgPVxuICBpZiBUaW1lX25zLiggPiApIGF0IHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0aGVuIHJhaXNlX3RoYXRfZmFyX2luX3RoZV9mdXR1cmUgdCBhdDtcbiAgaWYgVGltZV9ucy4oIDwgKSBhdCB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgdGhlbiByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0XG47O1xuXG5sZXQgYWRkIHQgfmF0IHZhbHVlID1cbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpXG4gICAgICAgfmF0XG4gICAgICAgdmFsdWUpXG47O1xuXG5sZXQgcmVtb3ZlIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5yZW1vdmUgdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxubGV0IGNsZWFyIHQgPSBQcmlvcml0eV9xdWV1ZS5jbGVhciB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWVtIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5tZW0gdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxuXG5sZXQgcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5IH5hdCA9XG4gIGlmIG5vdCAobWVtIHQgYWxhcm0pXG4gIHRoZW4gZmFpbHdpdGggXCJUaW1pbmdfd2hlZWwgY2Fubm90IHJlc2NoZWR1bGUgYWxhcm0gbm90IGluIHRpbWluZyB3aGVlbFwiO1xuICBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0O1xuICBQcmlvcml0eV9xdWV1ZS5jaGFuZ2UgdC5wcmlvcml0eV9xdWV1ZSBhbGFybSB+a2V5IH5hdFxuOztcblxubGV0IHJlc2NoZWR1bGUgdCBhbGFybSB+YXQgPSByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6KGludGVydmFsX251bV91bmNoZWNrZWQgdCBhdCkgfmF0XG5cbmxldCByZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSB0IGFsYXJtIH5hdCA9XG4gIHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleTphdCB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuOztcblxubGV0IG1pbl9hbGFybV9pbnRlcnZhbF9udW0gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWluX2FsYXJtX2ludGVydmFsX251bV9leG4gb2YgZW1wdHkgdGltaW5nX3doZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbiAgZWxzZSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdFxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWF4X2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWluX2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAobWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldO1xuICBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0XG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkID1cbiAgUHJpb3JpdHlfcXVldWUuZmlyZV9wYXN0X2FsYXJtc1xuICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICB+aGFuZGxlX2ZpcmVkXG4gICAgfmtleToobm93X2ludGVydmFsX251bSB0KVxuICAgIH5ub3c6dC5ub3dcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBOdW1fa2V5X2JpdHMgPSBOdW1fa2V5X2JpdHNcblxuICBsZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsID0gaW50ZXJ2YWxfbnVtX2ludGVybmFsXG4gIGxldCBtYXhfdGltZSA9IG1heF90aW1lXG5lbmRcbiJdfQ==
