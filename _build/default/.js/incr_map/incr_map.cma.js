// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_update_dummy=runtime.caml_update_dummy;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Incr_map_Incr_map_intf=
      caml_string_of_jsbytes("Incr_map__Incr_map_intf"),
     cst_incr_map=caml_string_of_jsbytes("incr_map"),
     cst_src_incr_map_intf_ml=caml_string_of_jsbytes("src/incr_map_intf.ml"),
     cst=caml_string_of_jsbytes(""),
     cst_incr_map$0=caml_string_of_jsbytes("incr_map"),
     cst_incr_map$1=caml_string_of_jsbytes("incr_map"),
     cst_Incr_map_Incr_map_intf$0=
      caml_string_of_jsbytes("Incr_map__Incr_map_intf"),
     cst_Invalid_indices=caml_string_of_jsbytes("Invalid indices"),
     cst_BUG_Hit_supposedly_impossi=
      caml_string_of_jsbytes
       ("BUG: Hit supposedly impossible case in Incr_map.index_by"),
     cst_impossible_case_BUG_in_inc=
      caml_string_of_jsbytes("impossible case: BUG in incr_map.ml subrange"),
     cst_Incr_map=caml_string_of_jsbytes("Incr_map"),
     cst_incr_map$2=caml_string_of_jsbytes("incr_map"),
     cst_src_incr_map_ml=caml_string_of_jsbytes("src/incr_map.ml"),
     cst$0=caml_string_of_jsbytes(""),
     cst_incr_map$3=caml_string_of_jsbytes("incr_map"),
     cst_incr_map$4=caml_string_of_jsbytes("incr_map"),
     cst_Incr_map$0=caml_string_of_jsbytes("Incr_map"),
     Ppx_module_timer_runtime=global_data.Ppx_module_timer_runtime,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Expect_test_collector=global_data.Expect_test_collector,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime,
     Core_Int=global_data.Core__Int,
     Core_Map=global_data.Core__Map,
     Core=global_data.Core,
     Incremental=global_data.Incremental,
     Core_Option=global_data.Core__Option,
     Core_Info=global_data.Core__Info,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Core_List=global_data.Core__List,
     Core_Bool=global_data.Core__Bool,
     Core_Tuple=global_data.Core__Tuple,
     Assert_failure=global_data.Assert_failure,
     Core_Maybe_bound=global_data.Core__Maybe_bound,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Ppx_compare_lib=global_data.Ppx_compare_lib,
     Core_Lazy=global_data.Core__Lazy,
     Core_Set=global_data.Core__Set,
     Core_Sequence=global_data.Core__Sequence,
     Incr_map=[0];
    caml_register_global(51,Incr_map,"Incr_map__");
    caml_call1(Ppx_module_timer_runtime[4],cst_Incr_map_Incr_map_intf);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_incr_map);
    caml_call1(Expect_test_collector[5][1],cst_src_incr_map_intf_ml);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_incr_map$0,cst);
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_incr_map$1);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Incr_map_Incr_map_intf$0);
    var Incr_map_Incr_map_intf=[0];
    caml_register_global(56,Incr_map_Incr_map_intf,"Incr_map__Incr_map_intf");
    caml_call1(Ppx_module_timer_runtime[4],cst_Incr_map);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_incr_map$2);
    caml_call1(Expect_test_collector[5][1],cst_src_incr_map_ml);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_incr_map$3,cst$0);
    var
     _F_=[0,caml_string_of_jsbytes("entries")],
     _G_=[0,caml_string_of_jsbytes("actual_value")],
     _H_=[0,caml_string_of_jsbytes("key")],
     _A_=[0,caml_string_of_jsbytes("node_is_unnecessary")],
     _B_=[0,caml_string_of_jsbytes("node_is_invalid")],
     _C_=[0,caml_string_of_jsbytes("node_is_const")],
     _D_=[0,caml_string_of_jsbytes("node_info")],
     _E_=[0,caml_string_of_jsbytes("saved_value")],
     _z_=[0,1],
     _y_=[0,1],
     _x_=[0,1],
     _w_=[0,1],
     _v_=[0,1],
     _u_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _t_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _s_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _r_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _q_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _p_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _o_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _n_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _l_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1210,6],
     _m_=[0,[0,0,0]],
     _g_=[0,caml_string_of_jsbytes("to_")],
     _h_=[0,caml_string_of_jsbytes("from")],
     _i_=[0,0,0],
     _k_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1194,10],
     _j_=[0,caml_string_of_jsbytes("src/incr_map.ml"),1195,10],
     _f_=[0,1],
     _e_=[0,1],
     _d_=[0,1],
     _c_=[0,1],
     _b_=[0,caml_string_of_jsbytes("src/incr_map.ml"),311,12],
     _a_=[0,caml_string_of_jsbytes("src/incr_map.ml"),238,11];
    function with_old(i,f)
     {var old=[0,0];
      function _eN_(a)
       {var b=caml_call2(f,old[1],a);old[1] = [0,[0,a,b]];return b}
      return caml_call2(Incremental[76][3][5],i,_eN_)}
    function unordered_fold
     (opt,update,specialized_initial,_eJ_,map,init,add,remove)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      if(_eJ_)
       var sth$0=_eJ_[1],revert_to_init_when_empty=sth$0;
      else
       var revert_to_init_when_empty=0;
      function default$0(key,old_data,new_data,acc)
       {return caml_call3
                (add,key,new_data,caml_call3(remove,key,old_data,acc))}
      var update$0=caml_call2(Core_Option[34],update,default$0);
      return with_old
              (map,
               function(old,new_in)
                {if(! old)
                  {if(! specialized_initial)
                    return caml_call3(Core_Map[55],new_in,init,add);
                   var initial=specialized_initial[1];
                   return caml_call2(initial,init,new_in)}
                 var match=old[1],old_out=match[2],old_in=match[1];
                 if(revert_to_init_when_empty)
                  {var _eK_=caml_call1(Core_Map[29],new_in);
                   if(caml_call2(Core[90],_eK_,0))return init}
                 function _eL_(acc,param)
                  {var change=param[2],key=param[1],_eM_=change[1];
                   if(847852583 === _eM_)
                    {var old=change[2];return caml_call3(remove,key,old,acc)}
                   if(1013247643 <= _eM_)
                    {var match=change[2],new$0=match[2],old$0=match[1];
                     return caml_call4(update$0,key,old$0,new$0,acc)}
                   var new$1=change[2];
                   return caml_call3(add,key,new$1,acc)}
                 return caml_call5
                         (Core_Map[81],old_in,new_in,data_equal,old_out,_eL_)})}
    function unordered_fold_nested_maps
     (opt,revert_to_init_when_empty,update,incr_map,init,add,remove)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      if(update)
       var update$0=update[1],update$1=update$0;
      else
       var
        update$1=
         function(outer_key,inner_key,old_data,new_data,acc)
          {return caml_call4
                   (add,
                    outer_key,
                    inner_key,
                    new_data,
                    caml_call4(remove,outer_key,inner_key,old_data,acc))};
      function _eC_(outer_key,inner_map,acc)
       {function _eI_(inner_key,data,acc)
         {return caml_call4(remove,outer_key,inner_key,data,acc)}
        return caml_call3(Core_Map[55],inner_map,acc,_eI_)}
      function _eD_(outer_key,inner_map,acc)
       {function _eH_(inner_key,data,acc)
         {return caml_call4(add,outer_key,inner_key,data,acc)}
        return caml_call3(Core_Map[55],inner_map,acc,_eH_)}
      var _eE_=0;
      return unordered_fold
              (0,
               [0,
                function(outer_key,old_inner_map,new_inner_map,acc)
                 {function _eF_(acc,param)
                   {var diff=param[2],inner_key=param[1],_eG_=diff[1];
                    if(847852583 === _eG_)
                     {var data_removed=diff[2];
                      return caml_call4
                              (remove,outer_key,inner_key,data_removed,acc)}
                    if(1013247643 <= _eG_)
                     {var match=diff[2],new_data=match[2],old_data=match[1];
                      return caml_call5
                              (update$1,outer_key,inner_key,old_data,new_data,acc)}
                    var data_added=diff[2];
                    return caml_call4(add,outer_key,inner_key,data_added,acc)}
                  return caml_call2
                          (caml_call3
                            (Core_Map[81],old_inner_map,new_inner_map,data_equal),
                           acc,
                           _eF_)}],
               _eE_,
               revert_to_init_when_empty,
               incr_map,
               init,
               _eD_,
               _eC_)}
    function with_comparator(get_comparator,x,f)
     {var
       _eA_=caml_call2(Incremental[10],x,get_comparator),
       _eB_=caml_call2(Incremental[34],0,_eA_);
      return caml_call2(Incremental[26],_eB_,f)}
    function with_comparator$0(map,f)
     {return with_comparator(Core_Map[2],map,f)}
    function of_set(set)
     {function _ev_(comparator)
       {var
         old_input=[0,caml_call1(Core_Set[3][1],comparator)],
         old_output=[0,caml_call1(Core_Map[110][1],comparator)];
        function _ew_(new_input)
         {function _ex_(output,param)
           {if(0 === param[0])
             {var k=param[1];return caml_call2(Core_Map[41],output,k)}
            var k$0=param[1];
            return caml_call3(Core_Map[31],output,k$0,0)}
          var
           _ey_=old_output[1],
           _ez_=caml_call2(Core_Set[17],old_input[1],new_input),
           new_output=caml_call3(Core_Sequence[18],_ez_,_ey_,_ex_);
          old_input[1] = new_input;
          old_output[1] = new_output;
          return new_output}
        return caml_call2(Incremental[10],set,_ew_)}
      return with_comparator(Core_Set[5],set,_ev_)}
    function generic_mapi(witness,opt,map)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      return function(f)
       {return with_old
                (map,
                 function(old,input)
                  {var match=caml_call1(Core_Map[29],input);
                   if(0 !== match && old)
                    {var
                      match$0=old[1],
                      old_output=match$0[2],
                      old_input=match$0[1],
                      _et_=
                       function(output,param)
                        {var change=param[2],key=param[1],_eu_=change[1];
                         if(847852583 === _eu_)
                          return caml_call2(Core_Map[41],output,key);
                         var
                          new_data=1013247643 <= _eu_?change[2][2]:change[2],
                          res=caml_call2(f,key,new_data);
                         if(! witness)return caml_call3(Core_Map[32],output,key,res);
                         if(! res)return caml_call2(Core_Map[41],output,key);
                         var output_data=res[1];
                         return caml_call3(Core_Map[32],output,key,output_data)};
                     return caml_call5
                             (Core_Map[81],old_input,input,data_equal,old_output,_et_)}
                   return witness
                           ?caml_call2(Core_Map[63],input,f)
                           :caml_call2(Core_Map[52],input,f)})}}
    function mapi(data_equal,map,f)
     {return caml_call1(generic_mapi(0,data_equal,map),f)}
    function filter_mapi(data_equal,map,f)
     {return caml_call1(generic_mapi(1,data_equal,map),f)}
    function map(data_equal,map,f)
     {return mapi
              (data_equal,map,function(param,data){return caml_call1(f,data)})}
    function filter_map(data_equal,map,f)
     {return filter_mapi
              (data_equal,map,function(param,data){return caml_call1(f,data)})}
    function with_old2(i1,i2,f)
     {var old=[0,0];
      function _es_(a1,a2)
       {var b=caml_call3(f,old[1],a1,a2);old[1] = [0,[0,a1,a2,b]];return b}
      return caml_call3(Incremental[12],i1,i2,_es_)}
    function mapi_count(opt,input,comparator)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      return function(f)
       {function add(new_key,acc)
         {function _er_(param)
           {if(! param)return 1;var n=param[1];return n + 1 | 0}
          return caml_call3(Core_Map[37],acc,new_key,_er_)}
        function remove(new_key,acc)
         {function _ep_(param)
           {if(! param)return 0;
            var _eq_=param[1];
            return 1 === _eq_?0:[0,_eq_ - 1 | 0]}
          return caml_call3(Core_Map[36],acc,new_key,_ep_)}
        function _ej_(key,data,acc){return remove(caml_call2(f,key,data),acc)}
        function _ek_(key,data,acc){return add(caml_call2(f,key,data),acc)}
        var _el_=caml_call1(Core_Map[4],comparator),_em_=0,_en_=0;
        return unordered_fold
                ([0,data_equal],
                 [0,
                  function(key,old_data,new_data,acc)
                   {var
                     prev_key=caml_call2(f,key,old_data),
                     new_key=caml_call2(f,key,new_data),
                     _eo_=caml_call2(comparator[1][1],prev_key,new_key);
                    return caml_call2(Core[90],_eo_,0)
                            ?acc
                            :add(new_key,remove(prev_key,acc))}],
                 _en_,
                 _em_,
                 input,
                 _el_,
                 _ek_,
                 _ej_)}}
    function map_count(data_equal,input,comparator,f)
     {function _ei_(param,data){return caml_call1(f,data)}
      return caml_call1(mapi_count(data_equal,input,comparator),_ei_)}
    function min_helper(map)
     {var match=caml_call1(Core_Map[82],map);
      if(! match)return 0;
      var match$0=match[1],min=match$0[1];
      return [0,min]}
    function max_helper(map)
     {var match=caml_call1(Core_Map[84],map);
      if(! match)return 0;
      var match$0=match[1],max=match$0[1];
      return [0,max]}
    function bounds_helper(map)
     {var
       match=caml_call1(Core_Map[82],map),
       match$0=caml_call1(Core_Map[84],map);
      if(match)
       {if(match$0)
         {var max=match$0[1][1],match$1=match[1],min=match$1[1];
          return [0,[0,min,max]]}}
      else
       if(! match$0)return 0;
      throw [0,Assert_failure,_a_]}
    function mapi_min(data_equal,input,comparator,f)
     {var _eh_=caml_call1(mapi_count(data_equal,input,comparator),f);
      return caml_call2(Incremental[10],_eh_,min_helper)}
    function mapi_max(data_equal,input,comparator,f)
     {var _eg_=caml_call1(mapi_count(data_equal,input,comparator),f);
      return caml_call2(Incremental[10],_eg_,max_helper)}
    function mapi_bounds(data_equal,input,comparator,f)
     {var _ef_=caml_call1(mapi_count(data_equal,input,comparator),f);
      return caml_call2(Incremental[10],_ef_,bounds_helper)}
    function mapi_mn(data_equal,input,comparator,f)
     {return mapi_min
              (data_equal,
               input,
               comparator,
               function(param,data){return caml_call1(f,data)})}
    function map_max(data_equal,input,comparator,f)
     {return mapi_max
              (data_equal,
               input,
               comparator,
               function(param,data){return caml_call1(f,data)})}
    function min_value(data_equal,input,comparator)
     {return mapi_mn(data_equal,input,comparator,function(_ee_){return _ee_})}
    function max_value(data_equal,input,comparator)
     {return map_max(data_equal,input,comparator,function(_ed_){return _ed_})}
    function map_bounds(data_equal,input,comparator,f)
     {return mapi_bounds
              (data_equal,
               input,
               comparator,
               function(param,data){return caml_call1(f,data)})}
    function value_bounds(data_equal,input,comparator)
     {return map_bounds
              (data_equal,input,comparator,function(_ec_){return _ec_})}
    function merge(opt,_d5_,left_map,right_map,f)
     {if(opt)
       var sth=opt[1],data_equal_left=sth;
      else
       var data_equal_left=Core[246];
      if(_d5_)
       var sth$0=_d5_[1],data_equal_right=sth$0;
      else
       var data_equal_right=Core[246];
      return with_old2
              (left_map,
               right_map,
               function(old,new_left_map,new_right_map)
                {var comparator=caml_call1(Core_Map[2],new_left_map);
                 if(old)
                  var
                   x=old[1],
                   old_output=x[3],
                   old_right_map=x[2],
                   old_left_map=x[1];
                 else
                  var
                   old_left_map$0=caml_call1(Core_Map[110][1],comparator),
                   old_output=old_left_map$0,
                   old_right_map=old_left_map$0,
                   old_left_map=old_left_map$0;
                 var
                  left_diff=
                   caml_call3
                    (Core_Map[80],old_left_map,new_left_map,data_equal_left),
                  right_diff=
                   caml_call3
                    (Core_Map[80],old_right_map,new_right_map,data_equal_right);
                 function _d6_(output,diff_element)
                  {if(2 === diff_element[0])
                    {var
                      right_key=diff_element[2][1],
                      match$3=diff_element[1],
                      left_key=match$3[1],
                      _ea_=caml_call2(comparator[1],left_key,right_key);
                     if(! caml_call2(Core[90],_ea_,0))
                      throw [0,Assert_failure,_b_];
                     var key$0=left_key}
                   else
                    var match=diff_element[1],key=match[1],key$0=key;
                   function new_data(param)
                    {var _eb_=param[1];
                     if(847852583 === _eb_)return 0;
                     var x=1013247643 <= _eb_?param[2][2]:param[2];
                     return [0,x]}
                   switch(diff_element[0])
                    {case 0:
                      var
                       match$0=diff_element[1],
                       left_diff=match$0[2],
                       right_data_opt=caml_call2(Core_Map[38],new_right_map,key$0),
                       right_data_opt$0=right_data_opt,
                       left_data_opt=new_data(left_diff);
                      break;
                     case 1:
                      var
                       match$1=diff_element[1],
                       right_diff=match$1[2],
                       right_data_opt$1=new_data(right_diff),
                       right_data_opt$0=right_data_opt$1,
                       left_data_opt=caml_call2(Core_Map[38],new_left_map,key$0);
                      break;
                     default:
                      var
                       right_diff$0=diff_element[2][2],
                       match$2=diff_element[1],
                       left_diff$0=match$2[2],
                       right_data_opt$2=new_data(right_diff$0),
                       left_data_opt$0=new_data(left_diff$0),
                       right_data_opt$0=right_data_opt$2,
                       left_data_opt=left_data_opt$0}
                   if(left_data_opt)
                    {var _d__=left_data_opt[1];
                     if(right_data_opt$0)
                      var
                       y=right_data_opt$0[1],
                       _d$_=caml_call2(f,key$0,[0,737457313,[0,_d__,y]]);
                     else
                      var _d$_=caml_call2(f,key$0,[0,847852583,_d__]);
                     var output_data_opt=_d$_}
                   else
                    if(right_data_opt$0)
                     var
                      y$0=right_data_opt$0[1],
                      output_data_opt=caml_call2(f,key$0,[0,-57574468,y$0]);
                    else
                     var output_data_opt=0;
                   if(! output_data_opt)
                    return caml_call2(Core_Map[41],output,key$0);
                   var data=output_data_opt[1];
                   return caml_call3(Core_Map[32],output,key$0,data)}
                 function _d7_(param,_d9_)
                  {var right_key=_d9_[1],left_key=param[1];
                   return caml_call2(comparator[1],left_key,right_key)}
                 var
                  _d8_=
                   caml_call3(Core_Sequence[62],left_diff,right_diff,_d7_);
                 return caml_call3(Core_Sequence[18],_d8_,old_output,_d6_)})}
    function generic_mapi_with_comparator(witness,cutoff,opt,lhs)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      return function(comparator,f)
       {var
         incremental_state=caml_call1(Incremental[4],lhs),
         empty_map=caml_call1(Core_Map[110][1],comparator),
         prev_map=[0,empty_map],
         prev_nodes=[0,empty_map],
         acc=[0,empty_map];
        function _dP_(param){return acc[1]}
        var
         result=caml_call3(Incremental[79][2][2],incremental_state,0,_dP_),
         on_inner_change=
          witness
           ?function(key,opt)
             {var old=acc[1];
              if(opt)
               var data=opt[1],_d4_=caml_call3(Core_Map[32],old,key,data);
              else
               var _d4_=caml_call2(Core_Map[41],old,key);
              acc[1] = _d4_;
              return 0}
           :function(key,data)
             {acc[1] = caml_call3(Core_Map[32],acc[1],key,data);return 0},
         lhs_change=[];
        caml_update_dummy
         (lhs_change,
          [246,
           function(_dS_)
            {function _dT_(map)
              {function _dU_(nodes,param)
                {var changed=param[2],key=param[1],_dV_=changed[1];
                 if(847852583 === _dV_)
                  {var
                    match=caml_call2(Core_Map[39],nodes,key),
                    dep=match[2],
                    node=match[1],
                    nodes$0=caml_call2(Core_Map[41],nodes,key);
                   caml_call2(Incremental[79][2][7],result,dep);
                   acc[1] = caml_call2(Core_Map[41],acc[1],key);
                   caml_call1(Incremental[79][2][5],node);
                   return nodes$0}
                 if(1013247643 <= _dV_)
                  {var
                    match$0=caml_call2(Core_Map[39],nodes,key),
                    node$0=match$0[1];
                   caml_call1(Incremental[79][2][4],node$0);
                   return nodes}
                 function _dW_(param)
                  {return caml_call2(Core_Map[39],prev_map[1],key)}
                 var
                  node$1=
                   caml_call3(Incremental[79][2][2],incremental_state,0,_dW_);
                 function _dX_(c)
                  {var _d3_=caml_call1(Incremental[79][2][3],node$1);
                   return caml_call2(Incremental[59],_d3_,c)}
                 caml_call2(Core_Option[41],cutoff,_dX_);
                 var
                  _dY_=caml_call1(Core[237],lhs_change),
                  _dZ_=caml_call2(Incremental[79][1][2],0,_dY_);
                 caml_call2(Incremental[79][2][6],node$1,_dZ_);
                 var
                  _d0_=
                   caml_call2(f,key,caml_call1(Incremental[79][2][3],node$1)),
                  _d1_=[0,function(_d2_){return on_inner_change(key,_d2_)}],
                  user_function_dep=
                   caml_call2(Incremental[79][1][2],_d1_,_d0_);
                 caml_call2(Incremental[79][2][6],result,user_function_dep);
                 return caml_call3
                         (Core_Map[32],nodes,key,[0,node$1,user_function_dep])}
               var
                new_nodes=
                 caml_call5
                  (Core_Map[81],prev_map[1],map,data_equal,prev_nodes[1],_dU_);
               prev_nodes[1] = new_nodes;
               prev_map[1] = map;
               return 0}
             return caml_call2(Incremental[10],lhs,_dT_)}]);
        var
         _dQ_=caml_call1(Core[237],lhs_change),
         _dR_=caml_call2(Incremental[79][1][2],0,_dQ_);
        caml_call2(Incremental[79][2][6],result,_dR_);
        return caml_call1(Incremental[79][2][3],result)}}
    function filter_mapi$0(cutoff,data_equal,map,f)
     {return with_comparator$0
              (map,
               function(comparator)
                {return caml_call2
                         (generic_mapi_with_comparator(1,cutoff,data_equal,map),
                          comparator,
                          f)})}
    function mapi$0(cutoff,data_equal,map,f)
     {return with_comparator$0
              (map,
               function(comparator)
                {return caml_call2
                         (generic_mapi_with_comparator(0,cutoff,data_equal,map),
                          comparator,
                          f)})}
    function map$0(cutoff,data_equal,map,f)
     {return mapi$0
              (cutoff,
               data_equal,
               map,
               function(param,data){return caml_call1(f,data)})}
    function filter_map$0(cutoff,data_equal,map,f)
     {return filter_mapi$0
              (cutoff,
               data_equal,
               map,
               function(param,data){return caml_call1(f,data)})}
    function merge$0(cutoff,data_equal_left,data_equal_right,map1,map2,f)
     {function _dO_(key,diff){return caml_call2(f,key,diff)}
      return filter_mapi$0
              (cutoff,
               0,
               merge
                (data_equal_left,
                 data_equal_right,
                 map1,
                 map2,
                 function(param,diff){return [0,diff]}),
               _dO_)}
    function unzip_mapi(opt,left_result_equal,right_result_equal,input,f)
     {var
       pair=
        with_comparator$0
         (input,
          function(comparator)
           {if(opt)
             var sth=opt[1],data_equal=sth;
            else
             var data_equal=Core[246];
            if(left_result_equal)
             var sth$0=left_result_equal[1],left_result_equal$0=sth$0;
            else
             var left_result_equal$0=Core[246];
            if(right_result_equal)
             var sth$1=right_result_equal[1],right_result_equal$0=sth$1;
            else
             var right_result_equal$0=Core[246];
            var
             incremental_state=caml_call1(Incremental[4],input),
             empty_map=caml_call1(Core_Map[110][1],comparator),
             left_acc=[0,empty_map];
            function _dz_(param){return left_acc[1]}
            var
             left_result=
              caml_call3(Incremental[79][2][2],incremental_state,0,_dz_),
             right_acc=[0,empty_map];
            function _dA_(param){return right_acc[1]}
            var
             right_result=
              caml_call3(Incremental[79][2][2],incremental_state,0,_dA_),
             prev_map=[0,empty_map];
            function _dB_(map)
             {var
               match=caml_call1(Core_Map[28],prev_map[1]),
               match$0=caml_call1(Core_Map[28],map),
               switch$0=0;
              if(match)
               if(match$0)
                switch$0 = 1;
               else
                var
                 _dG_=
                  function(key,data)
                   {var match=caml_call2(f,key,data),l=match[1];return l},
                 left$0=caml_call2(Core_Map[52],map,_dG_),
                 _dH_=
                  function(key,data)
                   {var match=caml_call2(f,key,data),r=match[2];return r},
                 right$0=caml_call2(Core_Map[52],map,_dH_),
                 right=right$0,
                 left=left$0;
              else
               if(match$0)
                switch$0 = 1;
               else
                var
                 _dI_=
                  function(param,_dK_)
                   {var
                     changed=_dK_[2],
                     key=_dK_[1],
                     right=param[2],
                     left=param[1],
                     _dL_=changed[1];
                    if(847852583 === _dL_)
                     {var _dM_=caml_call2(Core_Map[41],right,key);
                      return [0,caml_call2(Core_Map[41],left,key),_dM_]}
                    if(1013247643 <= _dL_)
                     {var
                       match=changed[2],
                       new$0=match[2],
                       prev=match[1],
                       match$0=caml_call2(f,key,prev),
                       prev_b=match$0[2],
                       prev_a=match$0[1],
                       match$1=caml_call2(f,key,new$0),
                       new_b=match$1[2],
                       new_a=match$1[1],
                       left$0=
                        caml_call2(left_result_equal$0,prev_a,new_a)
                         ?left
                         :caml_call3(Core_Map[32],left,key,new_a),
                       right$0=
                        caml_call2(right_result_equal$0,prev_b,new_b)
                         ?right
                         :caml_call3(Core_Map[32],right,key,new_b);
                      return [0,left$0,right$0]}
                    var
                     element=changed[2],
                     match$2=caml_call2(f,key,element),
                     b=match$2[2],
                     a=match$2[1],
                     _dN_=caml_call3(Core_Map[32],right,key,b);
                    return [0,caml_call3(Core_Map[32],left,key,a),_dN_]},
                 _dJ_=
                  caml_call5
                   (Core_Map[81],
                    prev_map[1],
                    map,
                    data_equal,
                    [0,left_acc[1],right_acc[1]],
                    _dI_),
                 right=_dJ_[2],
                 left=_dJ_[1];
              if(switch$0)var right=empty_map,left=empty_map;
              if(1 - caml_call2(Core[246],left_acc[1],left))
               caml_call1(Incremental[79][2][4],left_result);
              if(1 - caml_call2(Core[246],right_acc[1],right))
               caml_call1(Incremental[79][2][4],right_result);
              left_acc[1] = left;
              right_acc[1] = right;
              prev_map[1] = map;
              return 0}
            var
             input_change=caml_call2(Incremental[10],input,_dB_),
             _dC_=caml_call2(Incremental[79][1][2],0,input_change);
            caml_call2(Incremental[79][2][6],left_result,_dC_);
            var _dD_=caml_call2(Incremental[79][1][2],0,input_change);
            caml_call2(Incremental[79][2][6],right_result,_dD_);
            var
             _dE_=caml_call1(Incremental[79][2][3],right_result),
             _dF_=[0,caml_call1(Incremental[79][2][3],left_result),_dE_];
            return caml_call2(Core_Tuple[1][8],Incremental[40],_dF_)});
      function _du_(_dy_){return _dy_[2]}
      var _dv_=caml_call2(Incremental[10],pair,_du_);
      function _dw_(_dx_){return _dx_[1]}
      return [0,caml_call2(Incremental[10],pair,_dw_),_dv_]}
    function unzip(left_result_equal,right_result_equal,input)
     {function _dt_(l,r){return caml_call2(Core_Tuple[1][10],l,r)}
      var
       data_equal=
        caml_call3(Core_Option[23],left_result_equal,right_result_equal,_dt_);
      return unzip_mapi
              (data_equal,
               left_result_equal,
               right_result_equal,
               input,
               function(param,data){return data})}
    function unzip_mapi$0(cutoff,opt,input,f)
     {var
       pair=
        with_comparator$0
         (input,
          function(comparator)
           {if(opt)
             var sth=opt[1],data_equal=sth;
            else
             var data_equal=Core[246];
            var
             incremental_state=caml_call1(Incremental[4],input),
             empty_map=caml_call1(Core_Map[110][1],comparator),
             prev_map=[0,empty_map],
             prev_nodes=[0,empty_map],
             left_acc=[0,empty_map];
            function _da_(param){return left_acc[1]}
            var
             left_result=
              caml_call3(Incremental[79][2][2],incremental_state,0,_da_),
             right_acc=[0,empty_map];
            function _db_(param){return right_acc[1]}
            var
             right_result=
              caml_call3(Incremental[79][2][2],incremental_state,0,_db_),
             input_change=[];
            caml_update_dummy
             (input_change,
              [246,
               function(_di_)
                {function _dj_(map)
                  {function _dk_(nodes,param)
                    {var changed=param[2],key=param[1],_dl_=changed[1];
                     if(847852583 === _dl_)
                      {var
                        match=caml_call2(Core_Map[39],nodes,key),
                        right_dep=match[3],
                        left_dep=match[2],
                        node=match[1],
                        nodes$0=caml_call2(Core_Map[41],nodes,key);
                       caml_call2(Incremental[79][2][7],left_result,left_dep);
                       caml_call2(Incremental[79][2][7],right_result,right_dep);
                       left_acc[1] = caml_call2(Core_Map[41],left_acc[1],key);
                       right_acc[1] = caml_call2(Core_Map[41],right_acc[1],key);
                       caml_call1(Incremental[79][2][5],node);
                       return nodes$0}
                     if(1013247643 <= _dl_)
                      {var
                        match$0=caml_call2(Core_Map[39],nodes,key),
                        node$0=match$0[1];
                       caml_call1(Incremental[79][2][4],node$0);
                       return nodes}
                     function _dm_(param)
                      {return caml_call2(Core_Map[39],prev_map[1],key)}
                     var
                      node$1=
                       caml_call3(Incremental[79][2][2],incremental_state,0,_dm_);
                     function _dn_(c)
                      {var _ds_=caml_call1(Incremental[79][2][3],node$1);
                       return caml_call2(Incremental[59],_ds_,c)}
                     caml_call2(Core_Option[41],cutoff,_dn_);
                     var
                      _do_=caml_call1(Core[237],input_change),
                      _dp_=caml_call2(Incremental[79][1][2],0,_do_);
                     caml_call2(Incremental[79][2][6],node$1,_dp_);
                     var
                      match$1=
                       caml_call2(f,key,caml_call1(Incremental[79][2][3],node$1)),
                      right_incr=match$1[2],
                      left_incr=match$1[1],
                      _dq_=
                       [0,
                        function(data)
                         {left_acc[1]
                          =
                          caml_call3(Core_Map[32],left_acc[1],key,data);
                          return 0}],
                      left_user_function_dep=
                       caml_call2(Incremental[79][1][2],_dq_,left_incr),
                      _dr_=
                       [0,
                        function(data)
                         {right_acc[1]
                          =
                          caml_call3(Core_Map[32],right_acc[1],key,data);
                          return 0}],
                      right_user_function_dep=
                       caml_call2(Incremental[79][1][2],_dr_,right_incr);
                     caml_call2
                      (Incremental[79][2][6],left_result,left_user_function_dep);
                     caml_call2
                      (Incremental[79][2][6],right_result,right_user_function_dep);
                     return caml_call3
                             (Core_Map[32],
                              nodes,
                              key,
                              [0,node$1,left_user_function_dep,right_user_function_dep])}
                   var
                    new_nodes=
                     caml_call5
                      (Core_Map[81],prev_map[1],map,data_equal,prev_nodes[1],_dk_);
                   prev_nodes[1] = new_nodes;
                   prev_map[1] = map;
                   return 0}
                 return caml_call2(Incremental[10],input,_dj_)}]);
            var
             _dc_=caml_call1(Core[237],input_change),
             _dd_=caml_call2(Incremental[79][1][2],0,_dc_);
            caml_call2(Incremental[79][2][6],left_result,_dd_);
            var
             _de_=caml_call1(Core[237],input_change),
             _df_=caml_call2(Incremental[79][1][2],0,_de_);
            caml_call2(Incremental[79][2][6],right_result,_df_);
            var
             _dg_=caml_call1(Incremental[79][2][3],right_result),
             _dh_=[0,caml_call1(Incremental[79][2][3],left_result),_dg_];
            return caml_call2(Core_Tuple[1][8],Incremental[40],_dh_)});
      function _c7_(_c$_){return _c$_[2]}
      var _c8_=caml_call2(Incremental[10],pair,_c7_);
      function _c9_(_c__){return _c__[1]}
      return [0,caml_call2(Incremental[10],pair,_c9_),_c8_]}
    function keys(map)
     {return with_comparator$0
              (map,
               function(comparator)
                {function add(key,param,acc)
                  {return caml_call2(Core_Set[11],acc,key)}
                 function remove(key,param,acc)
                  {return caml_call2(Core_Set[12],acc,key)}
                 function data_equal(param,_c6_){return 1}
                 return unordered_fold
                         ([0,data_equal],
                          0,
                          0,
                          _c_,
                          map,
                          caml_call1(Core_Set[3][1],comparator),
                          add,
                          remove)})}
    function partition_mapi(data_equal,map,f)
     {return with_comparator$0
              (map,
               function(comparator)
                {var empty=caml_call1(Core_Map[110][1],comparator);
                 function _cX_(key,param,_c4_)
                  {var
                    second=_c4_[2],
                    first=_c4_[1],
                    _c5_=caml_call2(Core_Map[41],second,key);
                   return [0,caml_call2(Core_Map[41],first,key),_c5_]}
                 function _cY_(key,data,param)
                  {var
                    second=param[2],
                    first=param[1],
                    match=caml_call2(f,key,data);
                   if(0 === match[0])
                    {var data$0=match[1];
                     return [0,caml_call3(Core_Map[31],first,key,data$0),second]}
                   var data$1=match[1];
                   return [0,first,caml_call3(Core_Map[31],second,key,data$1)]}
                 var _cZ_=[0,empty,empty],_c0_=0;
                 return unordered_fold
                         (data_equal,
                          [0,
                           function(key,param,data,_c1_)
                            {var
                              second=_c1_[2],
                              first=_c1_[1],
                              match=caml_call2(f,key,data);
                             if(0 === match[0])
                              {var
                                data$0=match[1],
                                _c2_=caml_call2(Core_Map[41],second,key);
                               return [0,caml_call3(Core_Map[32],first,key,data$0),_c2_]}
                             var
                              data$1=match[1],
                              _c3_=caml_call3(Core_Map[32],second,key,data$1);
                             return [0,caml_call2(Core_Map[41],first,key),_c3_]}],
                          _c0_,
                          _d_,
                          map,
                          _cZ_,
                          _cY_,
                          _cX_)})}
    function flatten(state,map)
     {var
       _cS_=caml_call1(Core_Map[2],map),
       result=[0,caml_call1(Core_Map[110][1],_cS_)];
      function _cT_(param){return result[1]}
      var node=caml_call3(Incremental[79][2][2],state,0,_cT_);
      function _cU_(key,incr)
       {var
         _cV_=
          [0,
           function(a)
            {result[1] = caml_call3(Core_Map[32],result[1],key,a);return 0}],
         _cW_=caml_call2(Incremental[79][1][2],_cV_,incr);
        return caml_call2(Incremental[79][2][6],node,_cW_)}
      caml_call2(Core_Map[45],map,_cU_);
      return caml_call1(Incremental[79][2][3],node)}
    function join(map_incr)
     {return with_comparator$0
              (map_incr,
               function(comparator)
                {var
                  incremental_state=caml_call1(Incremental[4],map_incr),
                  empty_map=caml_call1(Core_Map[110][1],comparator),
                  result_map=[0,empty_map],
                  old_map_of_incrs=[0,empty_map],
                  current_dependencies=[0,empty_map];
                 function _cM_(param){return result_map[1]}
                 var
                  result=
                   caml_call3(Incremental[79][2][2],incremental_state,0,_cM_);
                 function add_subnode(current_dependencies,key,data_node)
                  {var
                    _cR_=
                     [0,
                      function(data)
                       {result_map[1]
                        =
                        caml_call3(Core_Map[32],result_map[1],key,data);
                        return 0}],
                    new_dep=caml_call2(Incremental[79][1][2],_cR_,data_node);
                   caml_call2(Incremental[79][2][6],result,new_dep);
                   return caml_call3
                           (Core_Map[32],current_dependencies,key,new_dep)}
                 function remove_subnode(current_dependencies,key)
                  {var dep=caml_call2(Core_Map[39],current_dependencies,key);
                   caml_call2(Incremental[79][2][7],result,dep);
                   result_map[1] = caml_call2(Core_Map[41],result_map[1],key);
                   return caml_call2(Core_Map[41],current_dependencies,key)}
                 function _cN_(map_of_incrs)
                  {function _cP_(current_dependencies,param)
                    {var diff=param[2],key=param[1],_cQ_=diff[1];
                     if(847852583 === _cQ_)
                      return remove_subnode(current_dependencies,key);
                     if(1013247643 <= _cQ_)
                      {var match=diff[2],data_node=match[2];
                       return add_subnode
                               (remove_subnode(current_dependencies,key),key,data_node)}
                     var data_node$0=diff[2];
                     return add_subnode(current_dependencies,key,data_node$0)}
                   var
                    new_dependency_map=
                     caml_call5
                      (Core_Map[81],
                       old_map_of_incrs[1],
                       map_of_incrs,
                       Core[246],
                       current_dependencies[1],
                       _cP_);
                   current_dependencies[1] = new_dependency_map;
                   old_map_of_incrs[1] = map_of_incrs;
                   return 0}
                 var
                  lhs_change=caml_call2(Incremental[10],map_incr,_cN_),
                  _cO_=caml_call2(Incremental[79][1][2],0,lhs_change);
                 caml_call2(Incremental[79][2][6],result,_cO_);
                 return caml_call1(Incremental[79][2][3],result)})}
    function separate(input_map,data_equal)
     {var state=caml_call1(Incremental[4],input_map);
      return with_comparator$0
              (input_map,
               function(comparator)
                {var
                  empty=caml_call1(Core_Map[110][1],comparator),
                  state$0=[0,empty,empty,empty];
                 function _cA_(param){return state$0[3]}
                 var
                  output_map_node=
                   caml_call3(Incremental[79][2][2],state,0,_cA_);
                 function make_node_depend_on_input_map_
                  (node,input_map_changed)
                  {var
                    _cL_=caml_call1(Core_Lazy[32],input_map_changed),
                    dependency=caml_call2(Incremental[79][1][2],0,_cL_);
                   return caml_call2(Incremental[79][2][6],node,dependency)}
                 var input_map_changed=[];
                 caml_update_dummy
                  (input_map_changed,
                   [246,
                    function(_cB_)
                     {function _cC_(input_map)
                       {var prev_input_map=state$0[1];
                        function _cD_(param,_cF_)
                         {var
                           change=_cF_[2],
                           key=_cF_[1],
                           output_map=param[2],
                           expert_nodes=param[1],
                           _cG_=change[1];
                          if(847852583 === _cG_)
                           {var old_node=caml_call2(Core_Map[39],expert_nodes,key);
                            caml_call1(Incremental[79][2][5],old_node);
                            caml_call1(Incremental[79][2][4],output_map_node);
                            var _cH_=caml_call2(Core_Map[41],output_map,key);
                            return [0,caml_call2(Core_Map[41],expert_nodes,key),_cH_]}
                          if(1013247643 <= _cG_)
                           {var _cI_=caml_call2(Core_Map[39],expert_nodes,key);
                            caml_call1(Incremental[79][2][4],_cI_);
                            return [0,expert_nodes,output_map]}
                          function _cE_(param)
                           {return caml_call2(Core_Map[39],state$0[1],key)}
                          var node=caml_call3(Incremental[79][2][2],state,0,_cE_);
                          make_node_depend_on_input_map_(node,input_map_changed);
                          caml_call1(Incremental[79][2][4],output_map_node);
                          var
                           _cJ_=caml_call1(Incremental[79][2][3],node),
                           _cK_=caml_call3(Core_Map[31],output_map,key,_cJ_);
                          return [0,
                                  caml_call3(Core_Map[31],expert_nodes,key,node),
                                  _cK_]}
                        var
                         match=
                          caml_call5
                           (Core_Map[81],
                            prev_input_map,
                            input_map,
                            data_equal,
                            [0,state$0[2],state$0[3]],
                            _cD_),
                         output_map=match[2],
                         expert_nodes=match[1];
                        state$0[1] = input_map;
                        state$0[2] = expert_nodes;
                        state$0[3] = output_map;
                        return 0}
                      return caml_call2(Incremental[10],input_map,_cC_)}]);
                 make_node_depend_on_input_map_
                  (output_map_node,input_map_changed);
                 return caml_call1(Incremental[79][2][3],output_map_node)})}
    function subrange(opt,map_incr)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      return function(range)
       {return with_old2
                (map_incr,
                 range,
                 function(old,map,range)
                  {var compare=caml_call1(Core_Map[2],map)[1];
                   function cmp_a(l,r)
                    {var _cz_=caml_call2(compare,l,r);
                     return caml_call2(Core[90],_cz_,0)}
                   function maybe_bound_equal(a_002,b_003)
                    {if(caml_call2(Ppx_compare_lib[1],a_002,b_003))return 1;
                     if(typeof a_002 === "number")
                      {if(typeof b_003 === "number")return 1;
                       if(1 === b_003[0])return 0}
                     else
                      {if(0 === a_002[0])
                        {var _cx_=a_002[1];
                         if(typeof b_003 !== "number" && 0 === b_003[0])
                          {var b_005=b_003[1];return cmp_a(_cx_,b_005)}
                         return 0}
                       var _cy_=a_002[1];
                       if(typeof b_003 === "number")return 0;
                       if(0 !== b_003[0])
                        {var b_007=b_003[1];return cmp_a(_cy_,b_007)}}
                     return 0}
                   function range_is_empty(min,max)
                    {var switch$0=0;
                     if(typeof min !== "number")
                      if(0 === min[0])
                       {var _cv_=min[1];
                        if(typeof max !== "number")
                         {if(0 === max[0])
                           {var max$0=max[1],_ct_=caml_call2(compare,_cv_,max$0);
                            return caml_call2(Core[91],_ct_,0)}
                          var max$1=max[1],min$0=_cv_;
                          switch$0 = 1}}
                      else
                       {var _cw_=min[1];
                        if(typeof max !== "number")
                         {var max$1=max[1],min$0=_cw_;switch$0 = 1}}
                     if(! switch$0)return 0;
                     var _cu_=caml_call2(compare,min$0,max$1);
                     return caml_call2(Core[88],_cu_,0)}
                   function range_includes(min,max,key)
                    {var _cs_=caml_call3(Core_Maybe_bound[17],min,key,compare);
                     return _cs_
                             ?caml_call3(Core_Maybe_bound[18],max,key,compare)
                             :_cs_}
                   if(! range)
                    {var _ck_=caml_call1(Core_Map[2],map);
                     return caml_call1(Core_Map[110][1],_ck_)}
                   var range$0=range[1],max=range$0[2],min=range$0[1];
                   function from_scratch(param)
                    {return caml_call3(Core_Map[94],map,min,max)}
                   if(old)
                    {var _ch_=old[1],_ci_=_ch_[2];
                     if(_ci_)
                      {var
                        old_range=_ci_[1],
                        old_min=old_range[1],
                        old_map=_ch_[1],
                        old_max=old_range[2];
                       if
                        (!
                         range_is_empty(old_min,old_max)
                         &&
                         !
                         range_is_empty(min,old_max)
                         &&
                         !
                         range_is_empty(old_min,max))
                        {var
                          old_res=_ch_[3],
                          old_max$0=old_range[2],
                          _cj_=
                           function(param)
                            {function apply_diff_in_intersection(param$0,_cp_)
                              {var
                                data=_cp_[2],
                                key=_cp_[1],
                                map=param$0[2],
                                outside=param$0[1],
                                _co_=range_includes(min,max,key),
                                _cq_=_co_?range_includes(old_min,old_max$0,key):_co_;
                               if(! _cq_)
                                {var outside$0=outside - 1 | 0;
                                 return 0 <= outside$0
                                         ?[0,outside$0,caml_call2(Core_Map[41],map,key)]
                                         :caml_call1(param,from_scratch(0))}
                               var _cr_=data[1];
                               if(847852583 === _cr_)
                                return [0,outside,caml_call2(Core_Map[41],map,key)];
                               var data$0=1013247643 <= _cr_?data[2][2]:data[2];
                               return [0,outside,caml_call3(Core_Map[32],map,key,data$0)]}
                             var
                              outside_cutoff=caml_call1(Core_Map[29],old_res) / 4 | 0,
                              with_updated_values_in_interse=
                               caml_call5
                                 (Core_Map[81],
                                  old_map,
                                  map,
                                  data_equal,
                                  [0,outside_cutoff,old_res],
                                  apply_diff_in_intersection)
                                [2];
                             if
                              (caml_call4
                                (Core_Tuple[1][10],
                                 maybe_bound_equal,
                                 maybe_bound_equal,
                                 old_range,
                                 range$0))
                              return with_updated_values_in_interse;
                             var
                              without_keys_out_of_range=
                               caml_call3
                                (Core_Map[94],with_updated_values_in_interse,min,max);
                             function map_append_exn(lower_part,upper_part)
                              {var match=caml_call2(Core_Map[93],lower_part,upper_part);
                               if(typeof match === "number")
                                return caml_call1(Core[6],cst_impossible_case_BUG_in_inc);
                               var map=match[2];
                               return map}
                             if(typeof old_min === "number")
                              var
                               _cl_=caml_call1(Core_Map[2],map),
                               _cm_=caml_call1(Core_Map[110][1],_cl_);
                             else
                              if(0 === old_min[0])
                               var
                                old_min$0=old_min[1],
                                _cm_=caml_call3(Core_Map[94],map,min,[1,old_min$0]);
                              else
                               var
                                old_min$1=old_min[1],
                                _cm_=caml_call3(Core_Map[94],map,min,[0,old_min$1]);
                             if(typeof old_max$0 === "number")
                              var
                               _cn_=caml_call1(Core_Map[2],map),
                               upper_part=caml_call1(Core_Map[110][1],_cn_);
                             else
                              if(0 === old_max$0[0])
                               var
                                old_max=old_max$0[1],
                                upper_part=caml_call3(Core_Map[94],map,[1,old_max],max);
                              else
                               var
                                old_max$1=old_max$0[1],
                                upper_part=caml_call3(Core_Map[94],map,[0,old_max$1],max);
                             var
                              with_new_keys_now_in_range=
                               map_append_exn
                                (_cm_,map_append_exn(without_keys_out_of_range,upper_part));
                             return with_new_keys_now_in_range};
                         return caml_call1(Core[260],_cj_)}
                       return from_scratch(0)}}
                   return from_scratch(0)})}}
    function rekey(data_equal,map_incr,outer_comparator,f)
     {function _b$_(key,data,output)
       {var _cg_=caml_call2(f,key,data);
        return caml_call2(Core_Map[41],output,_cg_)}
      function _ca_(key,data,output)
       {var _cf_=caml_call2(f,key,data);
        return caml_call3(Core_Map[31],output,_cf_,data)}
      var _cb_=caml_call1(Core_Map[4],outer_comparator),_cc_=0;
      return unordered_fold
              (data_equal,
               [0,
                function(key,old_data,new_data,output)
                 {var
                   prev_key=caml_call2(f,key,old_data),
                   new_key=caml_call2(f,key,new_data),
                   _cd_=
                    caml_call2
                     (caml_call1(Core_Map[2],output)[1],prev_key,new_key);
                  if(caml_call2(Core[90],_cd_,0))
                   return caml_call3(Core_Map[32],output,new_key,new_data);
                  var _ce_=caml_call2(Core_Map[41],output,prev_key);
                  return caml_call3(Core_Map[31],_ce_,new_key,new_data)}],
               _cc_,
               _e_,
               map_incr,
               _cb_,
               _ca_,
               _b$_)}
    function index_byi(data_equal,map_incr,outer_comparator,index)
     {return with_comparator$0
              (map_incr,
               function(inner_comparator)
                {function _b7_(inner_key,data,outer_map)
                  {var match=caml_call2(index,inner_key,data);
                   if(! match)return outer_map;
                   var outer_key=match[1];
                   function _b__(param)
                    {if(! param)
                      return caml_call1(Core[6],cst_BUG_Hit_supposedly_impossi);
                     var
                      inner_map=param[1],
                      inner_map$0=caml_call2(Core_Map[41],inner_map,inner_key);
                     return caml_call1(Core_Map[28],inner_map$0)
                             ?0
                             :[0,inner_map$0]}
                   return caml_call3(Core_Map[36],outer_map,outer_key,_b__)}
                 function _b8_(inner_key,data,outer_map)
                  {var match=caml_call2(index,inner_key,data);
                   if(! match)return outer_map;
                   var outer_key=match[1];
                   function _b9_(param)
                    {if(! param)
                      return caml_call3
                              (Core_Map[110][2],inner_comparator,inner_key,data);
                     var inner_map=param[1];
                     return caml_call3(Core_Map[31],inner_map,inner_key,data)}
                   return caml_call3(Core_Map[37],outer_map,outer_key,_b9_)}
                 return unordered_fold
                         (data_equal,
                          0,
                          0,
                          _f_,
                          map_incr,
                          caml_call1(Core_Map[4],outer_comparator),
                          _b8_,
                          _b7_)})}
    function index_by(data_equal,map_incr,comparator,index)
     {return index_byi
              (data_equal,
               map_incr,
               comparator,
               function(param,data){return caml_call1(index,data)})}
    function is_known(param)
     {if(typeof param === "number" && param)return 0;return 1}
    function to_option(param)
     {if(typeof param === "number")return 0;var k=param[1];return [0,k]}
    function find_key_range_linear(from,to,map)
     {var
       len=caml_call1(Core_Map[29],map),
       begin_key=caml_call2(Core_Int[84],from,len)?0:1,
       end_key=caml_call2(Core_Int[84],to,len)?0:1;
      function find_keys(fold,start_pos,advance_pos)
       {function _b5_(param)
         {return caml_call3
                  (fold,
                   map,
                   [0,begin_key,end_key,start_pos],
                   function(key,param$0,_b6_)
                    {var
                      pos=_b6_[3],
                      end_key=_b6_[2],
                      begin_key=_b6_[1],
                      begin_key$0=
                       caml_call2(Core_Int[86],pos,from)?[0,key]:begin_key,
                      end_key$0=caml_call2(Core_Int[86],pos,to)?[0,key]:end_key;
                     if(is_known(begin_key$0) && is_known(end_key$0))
                      return caml_call1(param,[0,begin_key$0,end_key$0,pos]);
                     return [0,begin_key$0,end_key$0,caml_call1(advance_pos,pos)]})}
        return caml_call1(Core[260],_b5_)}
      if(caml_call2(Core[92],to,len - from | 0))
       var
        _b1_=function(pos){return pos + 1 | 0},
        match=find_keys(Core_Map[55],0,_b1_);
      else
       var
        _b4_=function(pos){return pos - 1 | 0},
        match=find_keys(Core_Map[57],len - 1 | 0,_b4_);
      var end_key$0=match[2],begin_key$0=match[1];
      function _b2_(begin_key){return [0,begin_key,to_option(end_key$0)]}
      var _b3_=to_option(begin_key$0);
      return caml_call2(Core_Option[29],_b3_,_b2_)}
    function rank(map,key)
     {return with_comparator$0
              (map,
               function(comparator)
                {var compare_key=comparator[1];
                 function same_key(a,b)
                  {var _b0_=caml_call2(compare_key,a,b);
                   return caml_call2(Core[90],_b0_,0)}
                 function process(old,new_map,new_key)
                  {var old$0=old;
                   for(;;)
                    {if(! caml_call2(Core_Map[42],new_map,new_key))return 0;
                     if(old$0)
                      {var
                        match=old$0[1],
                        old_rank=match[3],
                        old_key=match[2],
                        old_map=match[1];
                       if
                        (caml_call2(Core[246],new_map,old_map)
                         &&
                         same_key(old_key,new_key))
                        return old_rank;
                       if(old_rank)
                        {var old_rank$0=old_rank[1];
                         if(caml_call2(Core[246],new_map,old_map))
                          {var _bS_=caml_call2(compare_key,new_key,old_key);
                           if(caml_call2(Core[92],_bS_,0))
                            var
                             upper_bound=[1,old_key],
                             lower_bound=[1,new_key],
                             subrange=
                              caml_call3(Core_Map[94],new_map,lower_bound,upper_bound),
                             _bV_=
                              (old_rank$0 - caml_call1(Core_Map[29],subrange) | 0)
                              -
                              1
                              |
                              0;
                           else
                            var
                             upper_bound$0=[1,new_key],
                             lower_bound$0=[1,old_key],
                             subrange$0=
                              caml_call3(Core_Map[94],new_map,lower_bound$0,upper_bound$0),
                             _bV_=
                              (old_rank$0 + caml_call1(Core_Map[29],subrange$0) | 0)
                              +
                              1
                              |
                              0;
                           return [0,_bV_]}
                         if(same_key(new_key,old_key))
                          {var
                            _bT_=
                             function(acc,param)
                              {var diff=param[2],diff_key=param[1];
                               if(typeof diff !== "number")
                                {var _bX_=diff[1];
                                 if(-57574468 === _bX_)
                                  {var _bY_=caml_call2(compare_key,diff_key,new_key);
                                   if(caml_call2(Core[92],_bY_,0))return acc + 1 | 0}
                                 else
                                  if(847852583 === _bX_)
                                   {var _bZ_=caml_call2(compare_key,diff_key,new_key);
                                    if(caml_call2(Core[92],_bZ_,0))return acc - 1 | 0}}
                               return acc},
                            _bU_=function(param,_bW_){return 1};
                           return [0,
                                   caml_call5
                                    (Core_Map[81],old_map,new_map,_bU_,old_rank$0,_bT_)]}
                         var
                          old_rank$1=
                           process
                            ([0,[0,old_map,old_key,[0,old_rank$0]]],new_map,old_key),
                          old$1=[0,[0,new_map,old_key,old_rank$1]],
                          old$0=old$1;
                         continue}}
                     return caml_call2(Core_Map[100],new_map,new_key)}}
                 return with_old2(map,key,process)})}
    function subrange_by_rank(data_equal,map,range)
     {function find_key_range(range)
       {return with_old2
                (map,
                 range,
                 function(old,map,param)
                  {var
                    to=param[2],
                    from=param[1],
                    _by_=caml_call2(Core_Int[88],to,from),
                    _bz_=_by_ || caml_call2(Core_Int[88],from,0);
                   if(_bz_)
                    {var
                      _bA_=[0,[1,[0,_g_,[0,caml_call1(Core[356],to),0]]],0],
                      _bB_=[0,[1,[0,_h_,[0,caml_call1(Core[356],from),0]]],_bA_],
                      _bC_=
                       [1,
                        [0,
                         caml_call1(Sexplib0_Sexp_conv[7],cst_Invalid_indices),
                         _bB_]];
                     caml_call1(Core[253],_bC_)}
                   if(old)
                    {var _bD_=old[1],_bE_=_bD_[3];
                     if(_bE_)
                      {var
                        _bF_=_bE_[1],
                        end_key_opt$0=_bF_[2],
                        begin_key=_bF_[1],
                        match=_bD_[2],
                        old_to=match[2],
                        old_from=match[1],
                        old_map=_bD_[1],
                        _bG_=caml_call1(Core_Map[2],map)[1],
                        find_offset=
                         function(key,changed_key,change)
                          {var _bQ_=caml_call2(_bG_,changed_key,key);
                           if(! caml_call2(Core_Int[88],_bQ_,0))return 0;
                           if(typeof change !== "number")
                            {var _bR_=change[1];
                             if(-57574468 === _bR_)return -1;
                             if(847852583 === _bR_)return 1}
                           return 0},
                        range_offset_begin=from - old_from | 0,
                        range_offset_end=to - old_to | 0,
                        adjust_and_offset=
                         function(by$1,key$1)
                          {var switch$0=0;
                           if
                            (caml_call2(Core[88],by$1,0)
                             &&
                             !
                             caml_call2(Core_Map[42],map,key$1))
                            {var _bP_=1;switch$0 = 1}
                           if(! switch$0)var _bP_=0;
                           var by$2=by$1 + _bP_ | 0,key=key$1,by=by$2;
                           for(;;)
                            {if(caml_call2(Core_Int[86],by,0))return [0,key];
                             if(caml_call2(Core_Int[88],by,0))
                              var add=1,closest_dir=-640801497;
                             else
                              var add=-1,closest_dir=-779285466;
                             var match=caml_call3(Core_Map[97],map,closest_dir,key);
                             if(! match)return 0;
                             var
                              match$0=match[1],
                              key$0=match$0[1],
                              by$0=by + add | 0,
                              key=key$0,
                              by=by$0}},
                        diff=
                         function(init,f)
                          {function _bN_(param,_bO_){return 1}
                           return caml_call5(Core_Map[81],old_map,map,_bN_,init,f)};
                       if(end_key_opt$0)
                        var
                         end_key=end_key_opt$0[1],
                         match$0=
                          diff
                           (_i_,
                            function(param,_bK_)
                             {var
                               change=_bK_[2],
                               key=_bK_[1],
                               offset_end=param[2],
                               offset_begin=param[1],
                               _bL_=offset_end + find_offset(end_key,key,change) | 0;
                              return [0,
                                      offset_begin + find_offset(begin_key,key,change) | 0,
                                      _bL_]}),
                         map_offset_end=match$0[2],
                         map_offset_begin=match$0[1],
                         end_key_opt$1=
                          adjust_and_offset
                           (map_offset_end + range_offset_end | 0,end_key),
                         end_key_opt$2=end_key_opt$1,
                         begin_key_opt=
                          adjust_and_offset
                           (map_offset_begin + range_offset_begin | 0,begin_key);
                       else
                        var
                         map_offset_begin$0=
                          diff
                           (0,
                            function(offset_begin,param)
                             {var change=param[2],key=param[1];
                              return offset_begin + find_offset(begin_key,key,change) | 0}),
                         _bw_=function(_bM_){return _bM_[1]},
                         _bx_=find_key_range_linear(to,to,map),
                         end_key_opt=caml_call2(Core_Option[29],_bx_,_bw_),
                         begin_key_opt$0=
                          adjust_and_offset
                           (map_offset_begin$0 + range_offset_begin | 0,begin_key),
                         end_key_opt$2=end_key_opt,
                         begin_key_opt=begin_key_opt$0;
                       var _bH_=caml_call1(Core_Map[42],map);
                       if(! caml_call2(Core_Option[43],begin_key_opt,_bH_))
                        throw [0,Assert_failure,_k_];
                       var _bI_=caml_call1(Core_Map[42],map);
                       if(! caml_call2(Core_Option[43],end_key_opt$2,_bI_))
                        throw [0,Assert_failure,_j_];
                       var
                        _bJ_=
                         function(begin_key){return [0,begin_key,end_key_opt$2]};
                       return caml_call2(Core_Option[29],begin_key_opt,_bJ_)}}
                   return find_key_range_linear(from,to,map)})}
      function symbol(new$0,bound)
       {function _bv_(param){return new$0}
        return caml_call2(Core_Maybe_bound[16],bound,_bv_)}
      var
       _a0_=caml_call1(Incremental[4],map),
       return$0=caml_call1(Incremental[9],_a0_);
      function _a1_(param)
       {if(3 < param >>> 0)throw [0,Assert_failure,_l_];
        switch(param)
         {case 0:return caml_call1(return$0,_m_);
          case 1:
           var
            _a4_=
             function(param)
              {var _br_=param[1];
               if(typeof _br_ !== "number")
                {var _bs_=_br_[1];if(typeof param[2] !== "number")return _bs_}
               throw [0,Assert_failure,_n_]},
            l=caml_call2(Incremental[76][3][5],range,_a4_),
            _a5_=
             function(param)
              {var _bq_=param[1];
               if(typeof _bq_ !== "number" && typeof param[2] !== "number")
                return _bq_;
               throw [0,Assert_failure,_o_]},
            let_syntax_017=caml_call2(Incremental[76][3][5],range,_a5_),
            _a6_=
             function(param)
              {if(typeof param[1] !== "number")
                {var _bp_=param[2];
                 if(typeof _bp_ !== "number")
                  {var pattern_syntax_010=_bp_[1];return pattern_syntax_010}}
               throw [0,Assert_failure,_p_]},
            u=caml_call2(Incremental[76][3][5],range,_a6_),
            _a7_=
             function(param)
              {if(typeof param[1] !== "number")
                {var _bo_=param[2];if(typeof _bo_ !== "number")return _bo_}
               throw [0,Assert_failure,_q_]},
            let_syntax_018=caml_call2(Incremental[76][3][5],range,_a7_),
            let_syntax_016=find_key_range(caml_call2(Incremental[40],l,u)),
            _a8_=
             function(param)
              {var match=param[2],ub=match[2],lb=match[1],key_range=param[1];
               if(! key_range)return 0;
               var _bk_=key_range[1],_bl_=_bk_[2],_bm_=_bk_[1];
               if(! _bl_)return [0,[0,symbol(_bm_,lb),0]];
               var end_key=_bl_[1],_bn_=symbol(end_key,ub);
               return [0,[0,symbol(_bm_,lb),_bn_]]},
            _a9_=
             caml_call2(Incremental[76][3][20],let_syntax_017,let_syntax_018),
            _a__=caml_call2(Incremental[76][3][20],let_syntax_016,_a9_);
           return caml_call2(Incremental[76][3][5],_a__,_a8_);
          case 2:
           var
            _a$_=
             function(param)
              {var _bi_=param[1];
               if(typeof _bi_ !== "number")
                {var _bj_=_bi_[1];if(typeof param[2] === "number")return _bj_}
               throw [0,Assert_failure,_r_]},
            l$0=caml_call2(Incremental[76][3][5],range,_a$_),
            _ba_=
             function(param)
              {var _bh_=param[1];
               if(typeof _bh_ !== "number" && typeof param[2] === "number")
                return _bh_;
               throw [0,Assert_failure,_s_]},
            lb=caml_call2(Incremental[76][3][5],range,_ba_),
            let_syntax_020=find_key_range(caml_call2(Incremental[40],l$0,l$0)),
            _bb_=
             function(param)
              {var lb=param[2],key_range=param[1];
               if(! key_range)return 0;
               var match=key_range[1],key=match[1];
               return [0,[0,symbol(key,lb),0]]},
            _bc_=caml_call2(Incremental[76][3][20],let_syntax_020,lb);
           return caml_call2(Incremental[76][3][5],_bc_,_bb_);
          default:
           var
            _bd_=
             function(param)
              {if(typeof param[1] === "number")
                {var _bu_=param[2];
                 if(typeof _bu_ !== "number")
                  {var pattern_syntax_014=_bu_[1];return pattern_syntax_014}}
               throw [0,Assert_failure,_t_]},
            u$0=caml_call2(Incremental[76][3][5],range,_bd_),
            _be_=
             function(param)
              {if(typeof param[1] === "number")
                {var _bt_=param[2];if(typeof _bt_ !== "number")return _bt_}
               throw [0,Assert_failure,_u_]},
            ub=caml_call2(Incremental[76][3][5],range,_be_),
            let_syntax_023=find_key_range(caml_call2(Incremental[40],u$0,u$0)),
            _bf_=
             function(param)
              {var ub=param[2],key_range=param[1];
               if(! key_range)return 0;
               var match=key_range[1],key=match[1];
               return [0,[0,0,symbol(key,ub)]]},
            _bg_=caml_call2(Incremental[76][3][20],let_syntax_023,ub);
           return caml_call2(Incremental[76][3][5],_bg_,_bf_)}}
      function _a2_(param)
       {return typeof param[1] === "number"
                ?typeof param[2] === "number"?0:3
                :typeof param[2] === "number"?2:1}
      var
       _a3_=caml_call2(Incremental[76][3][5],range,_a2_),
       key_range=caml_call2(Incremental[76][3][1],_a3_,_a1_);
      return caml_call1(subrange(data_equal,map),key_range)}
    function transpose(opt,k2_comparator,m)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      return with_comparator$0
              (m,
               function(k1_comparator)
                {function update(k1,old_data,new_data,acc)
                  {function _aU_(acc,param)
                    {var diff=param[2],k2=param[1],_aV_=diff[1];
                     if(847852583 === _aV_)
                      var value=0;
                     else
                      var x=1013247643 <= _aV_?diff[2][2]:diff[2],value=[0,x];
                     function _aW_(acc_inner)
                      {function _aX_(param){return value}
                       var
                        _aY_=caml_call1(Core_Map[110][1],k1_comparator),
                        _aZ_=caml_call2(Core_Option[34],acc_inner,_aY_),
                        acc_inner$0=caml_call3(Core_Map[36],_aZ_,k1,_aX_);
                       return caml_call1(Core_Map[28],acc_inner$0)
                               ?0
                               :[0,acc_inner$0]}
                     return caml_call3(Core_Map[36],acc,k2,_aW_)}
                   return caml_call5
                           (Core_Map[81],old_data,new_data,data_equal,acc,_aU_)}
                 function add(key,data)
                  {var _aS_=caml_call1(Core_Map[4],k2_comparator);
                   return function(_aT_){return update(key,_aS_,data,_aT_)}}
                 function remove(key,data)
                  {var _aQ_=caml_call1(Core_Map[4],k2_comparator);
                   return function(_aR_){return update(key,data,_aQ_,_aR_)}}
                 return unordered_fold
                         (0,
                          [0,update],
                          0,
                          _v_,
                          m,
                          caml_call1(Core_Map[4],k2_comparator),
                          add,
                          remove)})}
    function collapse_by(data_equal,map_incr,merge_keys,comparator)
     {function _aK_(outer_key,inner_key,param,acc)
       {var _aP_=caml_call2(merge_keys,outer_key,inner_key);
        return caml_call2(Core_Map[41],acc,_aP_)}
      function _aL_(outer_key,inner_key,data,acc)
       {var _aO_=caml_call2(merge_keys,outer_key,inner_key);
        return caml_call3(Core_Map[31],acc,_aO_,data)}
      var _aM_=caml_call1(Core_Map[4],comparator);
      return unordered_fold_nested_maps
              (data_equal,
               _w_,
               [0,
                function(outer_key,inner_key,param,new_data,acc)
                 {var _aN_=caml_call2(merge_keys,outer_key,inner_key);
                  return caml_call3(Core_Map[32],acc,_aN_,new_data)}],
               map_incr,
               _aM_,
               _aL_,
               _aK_)}
    function collapse(data_equal,map_incr,inner_comparator)
     {return with_comparator$0
              (map_incr,
               function(outer_comparator)
                {var
                  inner_comparator$0=inner_comparator[1],
                  comparator=
                   caml_call2
                    (Core_Tuple[1][5],outer_comparator,inner_comparator$0);
                 return collapse_by
                         (data_equal,map_incr,Core_Tuple[1][6],[0,comparator])})}
    function expand(data_equal,map_incr,outer_comparator,inner_comparator)
     {function _aA_(param,_aH_,acc)
       {var inner_key=param[2],outer_key=param[1];
        function _aI_(param)
         {if(! param)return 0;
          var
           map=param[1],
           map$0=caml_call2(Core_Map[41],map,inner_key),
           _aJ_=1 - caml_call1(Core_Map[28],map$0);
          return caml_call2(Core_Option[55],_aJ_,map$0)}
        return caml_call3(Core_Map[36],acc,outer_key,_aI_)}
      function _aB_(param,data,acc)
       {var inner_key=param[2],outer_key=param[1];
        function _aG_(param)
         {if(! param)
           return caml_call3(Core_Map[5],inner_comparator,inner_key,data);
          var map=param[1];
          return caml_call3(Core_Map[31],map,inner_key,data)}
        return caml_call3(Core_Map[37],acc,outer_key,_aG_)}
      var _aC_=caml_call1(Core_Map[4],outer_comparator),_aD_=0;
      return unordered_fold
              (data_equal,
               [0,
                function(param,_aE_,new_data,acc)
                 {var inner_key=param[2],outer_key=param[1];
                  function _aF_(param)
                   {if(! param)
                     return caml_call3
                             (Core_Map[5],inner_comparator,inner_key,new_data);
                    var map=param[1];
                    return caml_call3(Core_Map[32],map,inner_key,new_data)}
                  return caml_call3(Core_Map[37],acc,outer_key,_aF_)}],
               _aD_,
               _x_,
               map_incr,
               _aC_,
               _aB_,
               _aA_)}
    function counti(data_equal,map_incr,f)
     {function _az_(key,data,count)
       {return caml_call2(f,key,data)?count - 1 | 0:count}
      return unordered_fold
              (data_equal,
               0,
               0,
               _y_,
               map_incr,
               0,
               function(key,data,count)
                {return caml_call2(f,key,data)?count + 1 | 0:count},
               _az_)}
    function count(data_equal,map_incr,f)
     {return counti
              (data_equal,
               map_incr,
               function(param,data){return caml_call1(f,data)})}
    function existsi(data_equal,map_incr,f)
     {function _ax_(count){return caml_call2(Core[93],count,0)}
      var _ay_=counti(data_equal,map_incr,f);
      return caml_call2(Incremental[10],_ay_,_ax_)}
    function exists(data_equal,map_incr,f)
     {return existsi
              (data_equal,
               map_incr,
               function(param,data){return caml_call1(f,data)})}
    function sum(data_equal,map_incr,Group)
     {return function(f)
       {function _at_(param,v,acc)
         {var _aw_=caml_call1(f,v);return caml_call2(Group[3],acc,_aw_)}
        function _au_(param,v,acc)
         {var _av_=caml_call1(f,v);return caml_call2(Group[2],acc,_av_)}
        return unordered_fold(data_equal,0,0,_z_,map_incr,Group[1],_au_,_at_)}}
    function for_alli(data_equal,map_incr,f)
     {function _ar_(count){return caml_call2(Core[90],count,0)}
      var
       _as_=
        counti
         (data_equal,
          map_incr,
          function(key,data){return 1 - caml_call2(f,key,data)});
      return caml_call2(Incremental[10],_as_,_ar_)}
    function for_all(data_equal,map_incr,f)
     {return for_alli
              (data_equal,
               map_incr,
               function(param,data){return caml_call1(f,data)})}
    var For_testing=[0,find_key_range_linear];
    function M(K){return [0]}
    function create(opt,input_map,comparator)
     {if(opt)var sth=opt[1],data_equal=sth;else var data_equal=Core[246];
      var self=[];
      caml_update_dummy
       (self,
        [246,
         function(_ai_)
          {function _aj_(input_map)
            {var
              _al_=caml_obj_tag(self),
              self$0=
               250 === _al_
                ?self[1]
                :246 === _al_?caml_call1(CamlinternalLazy[2],self):self;
             function _am_(param,_an_)
              {var
                changed_value=_an_[2],
                key=_an_[1],
                entries=caml_call2(Core_Map[35],self$0[2],key);
               function _ao_(entry)
                {var _ap_=changed_value[1];
                 if(847852583 === _ap_)
                  var _aq_=0;
                 else
                  var
                   new_value=
                    1013247643 <= _ap_?changed_value[2][2]:changed_value[2],
                   _aq_=[0,new_value];
                 entry[1] = _aq_;
                 return caml_call1(Incremental[79][2][4],entry[2])}
               return caml_call2(Core_List[9],entries,_ao_)}
             caml_call5(Core_Map[81],self$0[1],input_map,data_equal,0,_am_);
             self$0[1] = input_map;
             return 0}
           var
            updater_node=caml_call2(Incremental[10],input_map,_aj_),
            empty_map=caml_call1(Core_Map[110][1],comparator),
            _ak_=caml_call1(Incremental[4],input_map);
           return [0,
                   empty_map,
                   empty_map,
                   updater_node,
                   caml_call2(Incremental[50][2],_ak_,0)]}]);
      var _ah_=caml_obj_tag(self);
      return 250 === _ah_
              ?self[1]
              :246 === _ah_?caml_call1(CamlinternalLazy[2],self):self}
    function find(t,key)
     {var match=caml_call2(Core_Map[35],t[2],key);
      if(match)
       {var entry=match[1];return caml_call1(Incremental[79][2][3],entry[2])}
      var incremental_state=caml_call1(Incremental[4],t[3]);
      function _W_(param)
       {var entry=[];
        caml_update_dummy
         (entry,
          [246,
           function(_Z_)
            {function ___(param){return caml_call1(Core[237],entry)[1]}
             var
              _$_=
               [0,
                function(is_now_observable)
                 {var
                   _ab_=caml_obj_tag(entry),
                   entry$0=
                    250 === _ab_
                     ?entry[1]
                     :246 === _ab_?caml_call1(CamlinternalLazy[2],entry):entry,
                   current_entries=caml_call2(Core_Map[35],t[2],key),
                   _ac_=caml_call1(Core[246],entry$0),
                   is_linked=caml_call2(Core_List[13],current_entries,_ac_);
                  if(caml_call2(Core_Bool[27],is_linked,is_now_observable))
                   return 0;
                  if(is_now_observable)
                   {var
                     _ad_=
                      function(param)
                       {if(param)
                         {var _ag_=param[1];
                          if(_ag_)
                           {var other_entry=_ag_[1];
                            entry$0[1] = other_entry[1];
                            return [0,entry$0,_ag_]}}
                        entry$0[1] = caml_call2(Core_Map[38],t[1],key);
                        return [0,entry$0,0]};
                    t[2] = caml_call3(Core_Map[37],t[2],key,_ad_);
                    return 0}
                  function _ae_(x){return 1 - caml_call2(Core[246],entry$0,x)}
                  var
                   new_entries=caml_call2(Core_List[50],current_entries,_ae_),
                   _af_=
                    caml_call1(Core_List[8],new_entries)
                     ?caml_call2(Core_Map[41],t[2],key)
                     :caml_call3(Core_Map[32],t[2],key,new_entries);
                  t[2] = _af_;
                  return 0}],
              _aa_=caml_call3(Incremental[79][2][2],incremental_state,_$_,___);
             return [0,caml_call2(Core_Map[38],t[1],key),_aa_]}]);
        var
         _X_=caml_obj_tag(entry),
         entry$0=
          250 === _X_
           ?entry[1]
           :246 === _X_?caml_call1(CamlinternalLazy[2],entry):entry,
         _Y_=caml_call2(Incremental[79][1][2],0,t[3]);
        caml_call2(Incremental[79][2][6],entry$0[2],_Y_);
        return caml_call1(Incremental[79][2][3],entry$0[2])}
      return caml_call3(Incremental[50][3],incremental_state,t[4],_W_)}
    function sexp_of_t(sexp_of_key,sexp_of_value,t)
     {function _I_(key,data)
       {var _J_=data[1];
        if(737457313 === _J_)
         var
          match=data[2],
          entries=match[2],
          x=match[1],
          actual_value=[0,x],
          entries$0=entries,
          actual_value$0=actual_value;
        else
         if(847852583 <= _J_)
          var x$0=data[2],entries$0=0,actual_value$0=[0,x$0];
         else
          var y=data[2],entries$0=y,actual_value$0=0;
        var _K_=0,_L_=0;
        function _M_(entry)
         {var
           saved_value=entry[1],
           node=entry[2],
           node$0=caml_call1(Incremental[79][2][3],node),
           match=caml_call1(Incremental[67],node$0),
           _O_=caml_call1(Incremental[5],node$0),
           match$0=caml_call2(Core_Option[55],_O_,0),
           _P_=1 - caml_call1(Incremental[6],node$0),
           match$1=caml_call2(Core_Option[55],_P_,0),
           _Q_=1 - caml_call1(Incremental[7],node$0),
           _R_=caml_call2(Core_Option[55],_Q_,0),
           match$2=0;
          if(_R_)
           var
            v=_R_[1],
            _S_=[0,[1,[0,_A_,[0,caml_call1(Core[518],v),0]]],match$2];
          else
           var _S_=match$2;
          if(match$1)
           var
            v$0=match$1[1],
            _T_=[0,[1,[0,_B_,[0,caml_call1(Core[518],v$0),0]]],_S_];
          else
           var _T_=_S_;
          if(match$0)
           var
            v$1=match$0[1],
            _U_=[0,[1,[0,_C_,[0,caml_call1(Core[518],v$1),0]]],_T_];
          else
           var _U_=_T_;
          if(match)
           var
            v$2=match[1],
            _V_=[0,[1,[0,_D_,[0,caml_call1(Core_Info[6],v$2),0]]],_U_];
          else
           var _V_=_U_;
          return [1,
                  [0,
                   [1,
                    [0,
                     _E_,
                     [0,caml_call2(Core[454],sexp_of_value,saved_value),0]]],
                   _V_]]}
        var
         match$0=
          [0,[1,[0,_F_,[0,caml_call2(Core[421],_M_,entries$0),_L_]]],_K_];
        if(actual_value$0)
         var
          v=actual_value$0[1],
          _N_=[0,[1,[0,_G_,[0,caml_call1(sexp_of_value,v),0]]],match$0];
        else
         var _N_=match$0;
        return [0,[1,[0,[1,[0,_H_,[0,caml_call1(sexp_of_key,key),0]]],_N_]]]}
      var info_per_key=caml_call3(Core_Map[77],t[1],t[2],_I_);
      return [1,caml_call1(Core_Map[73],info_per_key)]}
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_incr_map$4);
    caml_call1(Expect_test_collector[5][2],0);
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    caml_call1(Ppx_module_timer_runtime[5],cst_Incr_map$0);
    var
     Incr_map$0=
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       unordered_fold,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       mapi_mn,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       [0,create,find,M,[0,sexp_of_t]],
       For_testing,
       function(Incr)
        {function flatten$0(x){return flatten(Incr[2][3],x)}
         function M(K){return [0]}
         return [0,
                 of_set,
                 filter_mapi,
                 mapi,
                 filter_map,
                 map,
                 filter_mapi$0,
                 mapi$0,
                 filter_map$0,
                 map$0,
                 partition_mapi,
                 unordered_fold,
                 mapi_count,
                 map_count,
                 mapi_min,
                 mapi_max,
                 mapi_mn,
                 map_max,
                 min_value,
                 max_value,
                 mapi_bounds,
                 map_bounds,
                 value_bounds,
                 merge,
                 unzip,
                 unzip_mapi,
                 unzip_mapi$0,
                 merge$0,
                 flatten$0,
                 join,
                 separate,
                 keys,
                 rank,
                 subrange,
                 subrange_by_rank,
                 rekey,
                 index_byi,
                 index_by,
                 unordered_fold_nested_maps,
                 transpose,
                 collapse,
                 collapse_by,
                 expand,
                 counti,
                 count,
                 for_alli,
                 for_all,
                 existsi,
                 exists,
                 sum,
                 [0,create,find,M,[0,sexp_of_t]],
                 For_testing]}];
    caml_register_global(74,Incr_map$0,"Incr_map");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsid2l0aF9vbGQiLCJpIiwiZiIsIm9sZCIsImEiLCJiIiwidW5vcmRlcmVkX2ZvbGQiLCJvcHQiLCJ1cGRhdGUiLCJzcGVjaWFsaXplZF9pbml0aWFsIiwibWFwIiwiaW5pdCIsImFkZCIsInJlbW92ZSIsInN0aCIsImRhdGFfZXF1YWwiLCJzdGgkMCIsInJldmVydF90b19pbml0X3doZW5fZW1wdHkiLCJkZWZhdWx0JDAiLCJrZXkiLCJvbGRfZGF0YSIsIm5ld19kYXRhIiwiYWNjIiwidXBkYXRlJDAiLCJuZXdfaW4iLCJpbml0aWFsIiwib2xkX291dCIsIm9sZF9pbiIsImNoYW5nZSIsIm5ldyQwIiwib2xkJDAiLCJuZXckMSIsInVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzIiwiaW5jcl9tYXAiLCJ1cGRhdGUkMSIsIm91dGVyX2tleSIsImlubmVyX2tleSIsImlubmVyX21hcCIsImRhdGEiLCJvbGRfaW5uZXJfbWFwIiwibmV3X2lubmVyX21hcCIsImRpZmYiLCJkYXRhX3JlbW92ZWQiLCJkYXRhX2FkZGVkIiwid2l0aF9jb21wYXJhdG9yIiwiZ2V0X2NvbXBhcmF0b3IiLCJ4Iiwid2l0aF9jb21wYXJhdG9yJDAiLCJvZl9zZXQiLCJzZXQiLCJjb21wYXJhdG9yIiwib2xkX2lucHV0Iiwib2xkX291dHB1dCIsIm5ld19pbnB1dCIsIm91dHB1dCIsImsiLCJrJDAiLCJuZXdfb3V0cHV0IiwiZ2VuZXJpY19tYXBpIiwid2l0bmVzcyIsImlucHV0IiwicmVzIiwib3V0cHV0X2RhdGEiLCJtYXBpIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwIiwid2l0aF9vbGQyIiwiaTEiLCJpMiIsImExIiwiYTIiLCJtYXBpX2NvdW50IiwibmV3X2tleSIsIm4iLCJwcmV2X2tleSIsIm1hcF9jb3VudCIsIm1pbl9oZWxwZXIiLCJtaW4iLCJtYXhfaGVscGVyIiwibWF4IiwiYm91bmRzX2hlbHBlciIsIm1hcGlfbWluIiwibWFwaV9tYXgiLCJtYXBpX2JvdW5kcyIsIm1hcGlfbW4iLCJtYXBfbWF4IiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwibWFwX2JvdW5kcyIsInZhbHVlX2JvdW5kcyIsIm1lcmdlIiwibGVmdF9tYXAiLCJyaWdodF9tYXAiLCJkYXRhX2VxdWFsX2xlZnQiLCJkYXRhX2VxdWFsX3JpZ2h0IiwibmV3X2xlZnRfbWFwIiwibmV3X3JpZ2h0X21hcCIsIm9sZF9yaWdodF9tYXAiLCJvbGRfbGVmdF9tYXAiLCJvbGRfbGVmdF9tYXAkMCIsImxlZnRfZGlmZiIsInJpZ2h0X2RpZmYiLCJkaWZmX2VsZW1lbnQiLCJyaWdodF9rZXkiLCJsZWZ0X2tleSIsImtleSQwIiwicmlnaHRfZGF0YV9vcHQkMCIsImxlZnRfZGF0YV9vcHQiLCJyaWdodF9kaWZmJDAiLCJsZWZ0X2RpZmYkMCIsInJpZ2h0X2RhdGFfb3B0JDIiLCJsZWZ0X2RhdGFfb3B0JDAiLCJ5Iiwib3V0cHV0X2RhdGFfb3B0IiwieSQwIiwiZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvciIsImN1dG9mZiIsImluY3JlbWVudGFsX3N0YXRlIiwiZW1wdHlfbWFwIiwicHJldl9tYXAiLCJwcmV2X25vZGVzIiwicmVzdWx0Iiwib25faW5uZXJfY2hhbmdlIiwibGhzX2NoYW5nZSIsIm5vZGVzIiwiY2hhbmdlZCIsImRlcCIsIm5vZGUiLCJub2RlcyQwIiwibm9kZSQwIiwibm9kZSQxIiwiYyIsInVzZXJfZnVuY3Rpb25fZGVwIiwibmV3X25vZGVzIiwiZmlsdGVyX21hcGkkMCIsIm1hcGkkMCIsIm1hcCQwIiwiZmlsdGVyX21hcCQwIiwibWVyZ2UkMCIsIm1hcDEiLCJtYXAyIiwidW56aXBfbWFwaSIsImxlZnRfcmVzdWx0X2VxdWFsIiwicmlnaHRfcmVzdWx0X2VxdWFsIiwicGFpciIsImxlZnRfcmVzdWx0X2VxdWFsJDAiLCJzdGgkMSIsInJpZ2h0X3Jlc3VsdF9lcXVhbCQwIiwibGVmdF9hY2MiLCJsZWZ0X3Jlc3VsdCIsInJpZ2h0X2FjYyIsInJpZ2h0X3Jlc3VsdCIsImwiLCJsZWZ0JDAiLCJyIiwicmlnaHQkMCIsInJpZ2h0IiwibGVmdCIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsImlucHV0X2NoYW5nZSIsInVuemlwIiwidW56aXBfbWFwaSQwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwiZW1wdHkiLCJzZWNvbmQiLCJmaXJzdCIsImRhdGEkMCIsImRhdGEkMSIsImZsYXR0ZW4iLCJzdGF0ZSIsImluY3IiLCJqb2luIiwibWFwX2luY3IiLCJyZXN1bHRfbWFwIiwib2xkX21hcF9vZl9pbmNycyIsImN1cnJlbnRfZGVwZW5kZW5jaWVzIiwiYWRkX3N1Ym5vZGUiLCJkYXRhX25vZGUiLCJuZXdfZGVwIiwicmVtb3ZlX3N1Ym5vZGUiLCJtYXBfb2ZfaW5jcnMiLCJkYXRhX25vZGUkMCIsIm5ld19kZXBlbmRlbmN5X21hcCIsInNlcGFyYXRlIiwiaW5wdXRfbWFwIiwic3RhdGUkMCIsIm91dHB1dF9tYXBfbm9kZSIsIm1ha2Vfbm9kZV9kZXBlbmRfb25faW5wdXRfbWFwXyIsImlucHV0X21hcF9jaGFuZ2VkIiwiZGVwZW5kZW5jeSIsInByZXZfaW5wdXRfbWFwIiwib3V0cHV0X21hcCIsImV4cGVydF9ub2RlcyIsIm9sZF9ub2RlIiwic3VicmFuZ2UiLCJyYW5nZSIsImNvbXBhcmUiLCJjbXBfYSIsIm1heWJlX2JvdW5kX2VxdWFsIiwiYV8wMDIiLCJiXzAwMyIsImJfMDA1IiwiYl8wMDciLCJyYW5nZV9pc19lbXB0eSIsIm1heCQwIiwibWF4JDEiLCJtaW4kMCIsInJhbmdlX2luY2x1ZGVzIiwicmFuZ2UkMCIsImZyb21fc2NyYXRjaCIsIm9sZF9taW4iLCJvbGRfbWF4Iiwib2xkX3JlcyIsIm9sZF9tYXgkMCIsInBhcmFtIiwiYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24iLCJvdXRzaWRlIiwib3V0c2lkZSQwIiwib3V0c2lkZV9jdXRvZmYiLCJ3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2UiLCJ3aXRob3V0X2tleXNfb3V0X29mX3JhbmdlIiwibWFwX2FwcGVuZF9leG4iLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm9sZF9taW4kMCIsIm9sZF9taW4kMSIsIm9sZF9tYXgkMSIsIndpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlIiwicmVrZXkiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5kZXhfYnlpIiwiaW5kZXgiLCJpbm5lcl9jb21wYXJhdG9yIiwib3V0ZXJfbWFwIiwiaW5uZXJfbWFwJDAiLCJpbmRleF9ieSIsImlzX2tub3duIiwidG9fb3B0aW9uIiwiZmluZF9rZXlfcmFuZ2VfbGluZWFyIiwiZnJvbSIsInRvIiwibGVuIiwiYmVnaW5fa2V5IiwiZW5kX2tleSIsImZpbmRfa2V5cyIsImZvbGQiLCJzdGFydF9wb3MiLCJhZHZhbmNlX3BvcyIsInBvcyIsImJlZ2luX2tleSQwIiwiZW5kX2tleSQwIiwicmFuayIsImNvbXBhcmVfa2V5Iiwic2FtZV9rZXkiLCJwcm9jZXNzIiwibmV3X21hcCIsIm9sZF9yYW5rIiwib2xkX2tleSIsIm9sZF9tYXAiLCJvbGRfcmFuayQwIiwidXBwZXJfYm91bmQiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kJDAiLCJsb3dlcl9ib3VuZCQwIiwic3VicmFuZ2UkMCIsImRpZmZfa2V5Iiwib2xkX3JhbmskMSIsIm9sZCQxIiwic3VicmFuZ2VfYnlfcmFuayIsImZpbmRfa2V5X3JhbmdlIiwiZW5kX2tleV9vcHQkMCIsIm9sZF90byIsIm9sZF9mcm9tIiwiZmluZF9vZmZzZXQiLCJjaGFuZ2VkX2tleSIsInJhbmdlX29mZnNldF9iZWdpbiIsInJhbmdlX29mZnNldF9lbmQiLCJhZGp1c3RfYW5kX29mZnNldCIsImJ5JDEiLCJrZXkkMSIsImJ5JDIiLCJieSIsImNsb3Nlc3RfZGlyIiwiYnkkMCIsIm9mZnNldF9lbmQiLCJvZmZzZXRfYmVnaW4iLCJtYXBfb2Zmc2V0X2VuZCIsIm1hcF9vZmZzZXRfYmVnaW4iLCJlbmRfa2V5X29wdCQyIiwiYmVnaW5fa2V5X29wdCIsIm1hcF9vZmZzZXRfYmVnaW4kMCIsImVuZF9rZXlfb3B0IiwiYmVnaW5fa2V5X29wdCQwIiwic3ltYm9sIiwiYm91bmQiLCJyZXR1cm4kMCIsImxldF9zeW50YXhfMDE3IiwicGF0dGVybl9zeW50YXhfMDEwIiwidSIsImxldF9zeW50YXhfMDE4IiwibGV0X3N5bnRheF8wMTYiLCJ1YiIsImxiIiwia2V5X3JhbmdlIiwibCQwIiwibGV0X3N5bnRheF8wMjAiLCJwYXR0ZXJuX3N5bnRheF8wMTQiLCJ1JDAiLCJsZXRfc3ludGF4XzAyMyIsInRyYW5zcG9zZSIsImsyX2NvbXBhcmF0b3IiLCJtIiwiazFfY29tcGFyYXRvciIsImsxIiwiazIiLCJ2YWx1ZSIsImFjY19pbm5lciIsImFjY19pbm5lciQwIiwiY29sbGFwc2VfYnkiLCJtZXJnZV9rZXlzIiwiY29sbGFwc2UiLCJpbm5lcl9jb21wYXJhdG9yJDAiLCJleHBhbmQiLCJjb3VudGkiLCJjb3VudCIsImV4aXN0c2kiLCJleGlzdHMiLCJzdW0iLCJHcm91cCIsInYiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJjcmVhdGUiLCJzZWxmIiwic2VsZiQwIiwiY2hhbmdlZF92YWx1ZSIsImVudHJpZXMiLCJlbnRyeSIsIm5ld192YWx1ZSIsInVwZGF0ZXJfbm9kZSIsImZpbmQiLCJ0IiwiaXNfbm93X29ic2VydmFibGUiLCJlbnRyeSQwIiwiY3VycmVudF9lbnRyaWVzIiwiaXNfbGlua2VkIiwib3RoZXJfZW50cnkiLCJuZXdfZW50cmllcyIsInNleHBfb2ZfdCIsInNleHBfb2Zfa2V5Iiwic2V4cF9vZl92YWx1ZSIsImFjdHVhbF92YWx1ZSIsImVudHJpZXMkMCIsImFjdHVhbF92YWx1ZSQwIiwieCQwIiwic2F2ZWRfdmFsdWUiLCJtYXRjaCQyIiwidiQwIiwidiQxIiwidiQyIiwibWF0Y2gkMCIsImluZm9fcGVyX2tleSIsImZsYXR0ZW4kMCJdLCJzb3VyY2VzIjpbIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9pbmNyX21hcC9pbmNyX21hcC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBbUJNQSxTQUFTQyxFQUFHQztNQUNkLElBQ0lDO01BREosY0FFUUM7UUFDQSxJQUFKQyxFQUFJLFdBSk1ILEVBRVZDLE9BQ0lDLEdBQ0EsZUFEQUEsRUFDSkMsSUFBSSxPQUFKQSxDQUVIO01BTEQsd0NBRFdKLE9BTVY7YUFHQ0s7TUFDSUMsSUFDREMsT0FDQUMseUJBRURDLElBQ0NDLEtBQ0FDLElBQ0FDO01BRUwsR0FUTU4sSUFBYSxRQUFiQSxrQkFBYU8sYUFBYkM7TUFTTjtPQU5rQyxrQkFBNUJFLDBCQUE0QkQ7O1dBQTVCQztNQU1OLFNBQ01DLFVBQVNDLElBQUtDLFNBQVVDLFNBQVNDO1FBQ1g7aUJBTHZCVixJQUlVTyxJQUFlRSxTQUNGLFdBSnZCUixPQUdVTSxJQUFLQyxTQUFtQkUsS0FDcUI7TUFFMUQsSUFKRUMsU0FJRiwyQkFaR2YsT0FTQ1U7TUFHSixPQXZCQWxCO2VBY0VVO3dCQVdrQlAsSUFBSXFCO2lCQUN4QixLQURvQnJCO21CQUdsQixLQWhCQ007b0JBaUJVLCtCQUpXZSxPQVZyQmIsS0FDQUM7bUJBY2tCLElBQVhhLFFBbEJQaEI7bUJBa0JrQixrQkFBWGdCLFFBZlBkLEtBVXFCYTsyQkFBSnJCLE9BTUp1QixpQkFBUkM7b0JBbEJKVjttQkFtQjhCLGlDQVBWTzttQkFPVSwrQkFDM0IsT0FsQkpiO2lCQW9CQyxjQUtVVzttQkFBTCxzQ0FBZU07bUJBQWY7cUJBRWMsSUFBUHpCLElBRlF5QixVQUVELGtCQXpC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aUJBSkFEO2lCQWlPQXNDO2lCQW5uQkF4SztpQkEySkFpRTtpQkFrQ0FJO2lCQXVCQU07aUJBSUFDO2lCQVFBRTtpQkFJQUM7aUJBSUFDO2lCQUlBQztpQkFoQkFKO2lCQW9CQUs7aUJBSUFDO2lCQUlBQztpQkFvUUEyRTtpQkFmQXhCO2lCQThHQXlCO2lCQWpNQTVCO2lCQSttQ0E0TztpQkExMEJBL0w7aUJBcUJBWTtpQkEvR0F0QjtpQkFrYkEwRjtpQkFoUUF6RDtpQkFxVUEwRTtpQkF4TUF4QztpQkFnQkFFO2lCQThCQUs7aUJBNTVCQXZOO2lCQW1wQ0FpUztpQkF5RUFXO2lCQXJCQUY7aUJBaURBSTtpQkFzQkFDO2lCQVVBQztpQkE0QkFNO2lCQU1BQztpQkE5QkFOO2lCQUlBQztpQkFJQUM7b0JBcURFSyxPQStFQVEsVUF3QlNROzs7VSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbmluY2x1ZGUgSW5jcl9tYXBfaW50ZlxuXG4oKiogVGhpcyB0eXBlIGxldHMgdXMgY2FwdHVyZSB0aGUga2luZCBvZiBtYXAgZnVuY3Rpb24gYmVpbmcgcGVyZm9ybWVkLCBzbyB3ZSBjYW4gd2l0aFxuICAgIG9uZSBpbXBsZW1lbnRhdGlvbiBwZXJmb3JtIG1hcCBhbmQgZmlsdGVyLW1hcCBvcGVyYXRpb25zLlxuXG4gICAgSGVyZSwgWydpbnB1dF9kYXRhXSBpcyB0aGUgdHlwZSBvZiBkYXRhIGluIHRoZSBpbnB1dCBtYXAsIFsnb3V0cHV0X2RhdGFdIGlzIHRoZSB0eXBlXG4gICAgb2YgZGF0YSBpbiB0aGUgb3V0cHV0IG1hcCwgYW5kIFsnZl9vdXRwdXRdIGlzIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgW35mXSBmdW5jdGlvblxuICAgIHBhc3NlZCB0byB0aGUgbWFwcGluZyBmdW5jdGlvbi4gKilcbm1vZHVsZSBNYXBfdHlwZSA9IHN0cnVjdFxuICB0eXBlICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnZl9vdXRwdXQpIHQgPVxuICAgIHwgTWFwIDogKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSkgdFxuICAgIHwgRmlsdGVyX21hcCA6ICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnb3V0cHV0X2RhdGEgb3B0aW9uKSB0XG5cbiAgKCogVGhlIGV4dHJhIHR5cGUgdmFyaWFibGUgJ2EgaXMgdG8gYWxsb3cgaW4gZnV0dXJlOlxuICAgICB8IEZpbHRlciA6ICgnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgYm9vbCkgdCAqKVxuZW5kXG5cbm1vZHVsZSBHZW5lcmljID0gc3RydWN0XG4gIGxldCB3aXRoX29sZCBpIH5mID1cbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgbGV0JW1hcCBhID0gaSBpblxuICAgIGxldCBiID0gZiB+b2xkOiFvbGQgYSBpblxuICAgIG9sZCA6PSBTb21lIChhLCBiKTtcbiAgICBiXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID91cGRhdGVcbiAgICAgICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICAgICAgPyhyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5ID0gZmFsc2UpXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBsZXQgZGVmYXVsdCB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjID1cbiAgICAgICAgYWRkIH5rZXkgfmRhdGE6bmV3X2RhdGEgKHJlbW92ZSB+a2V5IH5kYXRhOm9sZF9kYXRhIGFjYylcbiAgICAgIGluXG4gICAgICBPcHRpb24udmFsdWUgdXBkYXRlIH5kZWZhdWx0XG4gICAgaW5cbiAgICB3aXRoX29sZCBtYXAgfmY6KGZ1biB+b2xkIG5ld19pbiAtPlxuICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAobWF0Y2ggc3BlY2lhbGl6ZWRfaW5pdGlhbCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gTWFwLmZvbGQgfmluaXQgfmY6YWRkIG5ld19pblxuICAgICAgICAgfCBTb21lIGluaXRpYWwgLT4gaW5pdGlhbCB+aW5pdCBuZXdfaW4pXG4gICAgICB8IFNvbWUgKG9sZF9pbiwgb2xkX291dCkgLT5cbiAgICAgICAgaWYgcmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSAmJiBNYXAubGVuZ3RoIG5ld19pbiA9IDBcbiAgICAgICAgdGhlbiBpbml0XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgfmluaXQ6b2xkX291dFxuICAgICAgICAgICAgb2xkX2luXG4gICAgICAgICAgICBuZXdfaW5cbiAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICB+ZjooZnVuIGFjYyAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgb2xkIC0+IHJlbW92ZSB+a2V5IH5kYXRhOm9sZCBhY2NcbiAgICAgICAgICAgICAgfCBgUmlnaHQgbmV3XyAtPiBhZGQgfmtleSB+ZGF0YTpuZXdfIGFjY1xuICAgICAgICAgICAgICB8IGBVbmVxdWFsIChvbGQsIG5ld18pIC0+IHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTpvbGQgfm5ld19kYXRhOm5ld18gYWNjKSlcbiAgOztcblxuICBsZXQgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgICAgP3VwZGF0ZVxuICAgICAgICBpbmNyX21hcFxuICAgICAgICB+aW5pdFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmVcbiAgICA9XG4gICAgbGV0IHVwZGF0ZSA9XG4gICAgICBtYXRjaCB1cGRhdGUgd2l0aFxuICAgICAgfCBTb21lIHVwZGF0ZSAtPiB1cGRhdGVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgICAgYWRkXG4gICAgICAgICAgICB+b3V0ZXJfa2V5XG4gICAgICAgICAgICB+aW5uZXJfa2V5XG4gICAgICAgICAgICB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICAgICAgKHJlbW92ZSB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6b2xkX2RhdGEgYWNjKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIGluY3JfbWFwXG4gICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgfmluaXRcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5Om91dGVyX2tleSB+b2xkX2RhdGE6b2xkX2lubmVyX21hcCB+bmV3X2RhdGE6bmV3X2lubmVyX21hcCBhY2MgLT5cbiAgICAgICAgKE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmIG9sZF9pbm5lcl9tYXAgbmV3X2lubmVyX21hcCB+ZGF0YV9lcXVhbClcbiAgICAgICAgICB+aW5pdDphY2NcbiAgICAgICAgICB+ZjooZnVuIGFjYyAoaW5uZXJfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IGRhdGFfcmVtb3ZlZCAtPiByZW1vdmUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOmRhdGFfcmVtb3ZlZCBhY2NcbiAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfYWRkZWQgLT4gYWRkIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX2FkZGVkIGFjY1xuICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkX2RhdGEsIG5ld19kYXRhKSAtPlxuICAgICAgICAgICAgICB1cGRhdGUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjKSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIE1hcC5mb2xkIGlubmVyX21hcCB+aW5pdDphY2MgfmY6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYykpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICA7O1xuXG4gIGxldCB3aXRoX2NvbXBhcmF0b3InIGdldF9jb21wYXJhdG9yIHggZiA9XG4gICAgSW5jcmVtZW50YWwuYmluZCAoSW5jcmVtZW50YWwuZnJlZXplIChJbmNyZW1lbnRhbC5tYXAgeCB+ZjpnZXRfY29tcGFyYXRvcikpIH5mXG4gIDs7XG5cbiAgKCoqIENhcHR1cmVzIHRoZSBjb21wYXJhdG9yICh3aGljaCBjYW4ndCBjaGFuZ2UgYW55d2F5LCBzaW5jZSB0aGUgdHlwZSBkZXRlcm1pbmVzIHRoZVxuICAgICAgY29tcGFyYXRvcikgYnkgZnJlZXppbmcgdGhlIGNvcnJlc3BvbmRpbmcgbWFwLiAgTm90ZSB0aGF0IGJ5IGZpcnN0IHVzaW5nIEluY3JlbWVudGFsLm1hcCB0b1xuICAgICAgZ2V0IHRoZSBjb21wYXJhdG9yIG91dCBvZiB0aGUgbWFwLCB3ZSBhbGxvdyB0aGUgaW5pdGlhbCBtYXAgaXRzZWxmIHRvIGJlIGdhcmJhZ2VcbiAgICAgIGNvbGxlY3RlZCAqKVxuICBsZXQgd2l0aF9jb21wYXJhdG9yIG1hcCBmID0gd2l0aF9jb21wYXJhdG9yJyBNYXAuY29tcGFyYXRvciBtYXAgZlxuXG4gIGxldCBvZl9zZXQgc2V0ID1cbiAgICB3aXRoX2NvbXBhcmF0b3InIFNldC5jb21wYXJhdG9yIHNldCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBvbGRfaW5wdXQgPSByZWYgKFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgbGV0IG9sZF9vdXRwdXQgPSByZWYgKE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKSBpblxuICAgICAgSW5jcmVtZW50YWwubWFwIHNldCB+ZjooZnVuIG5ld19pbnB1dCAtPlxuICAgICAgICBsZXQgbmV3X291dHB1dCA9XG4gICAgICAgICAgU2VxdWVuY2UuZm9sZFxuICAgICAgICAgICAgKFNldC5zeW1tZXRyaWNfZGlmZiAhb2xkX2lucHV0IG5ld19pbnB1dClcbiAgICAgICAgICAgIH5pbml0OiFvbGRfb3V0cHV0XG4gICAgICAgICAgICB+ZjooZnVuIG91dHB1dCAtPiBmdW5jdGlvblxuICAgICAgICAgICAgICB8IEZpcnN0IGsgLT4gTWFwLnJlbW92ZSBvdXRwdXQga1xuICAgICAgICAgICAgICB8IFNlY29uZCBrIC0+IE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5OmsgfmRhdGE6KCkpXG4gICAgICAgIGluXG4gICAgICAgIG9sZF9pbnB1dCA6PSBuZXdfaW5wdXQ7XG4gICAgICAgIG9sZF9vdXRwdXQgOj0gbmV3X291dHB1dDtcbiAgICAgICAgbmV3X291dHB1dCkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaVxuICAgICAgICAodHlwZSBpbnB1dF9kYXRhIG91dHB1dF9kYXRhIGZfb3V0cHV0IHN0YXRlX3dpdG5lc3MpXG4gICAgICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKG1hcCA6ICgoJ2tleSwgaW5wdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oZiA6IGtleTona2V5IC0+IGRhdGE6aW5wdXRfZGF0YSAtPiBmX291dHB1dClcbiAgICA9XG4gICAgd2l0aF9vbGQgbWFwIH5mOihmdW4gfm9sZCBpbnB1dCAtPlxuICAgICAgbWF0Y2ggb2xkLCBNYXAubGVuZ3RoIGlucHV0IHdpdGhcbiAgICAgIHwgXywgMCB8IE5vbmUsIF8gLT5cbiAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gKE1hcC5tYXBpIGlucHV0IH5mIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudClcbiAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPiBNYXAuZmlsdGVyX21hcGkgaW5wdXQgfmYpXG4gICAgICB8IFNvbWUgKG9sZF9pbnB1dCwgb2xkX291dHB1dCksIF8gLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICBvbGRfaW5wdXRcbiAgICAgICAgICBpbnB1dFxuICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgfmluaXQ6b2xkX291dHB1dFxuICAgICAgICAgIH5mOihmdW4gb3V0cHV0IChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5XG4gICAgICAgICAgICB8IGBSaWdodCBuZXdfZGF0YSB8IGBVbmVxdWFsIChfLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgICAgbGV0IHJlcyA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICAgICAgICAobWF0Y2ggd2l0bmVzcyB3aXRoXG4gICAgICAgICAgICAgICB8IE1hcF90eXBlLk1hcCAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOnJlc1xuICAgICAgICAgICAgICAgfCBNYXBfdHlwZS5GaWx0ZXJfbWFwIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCByZXMgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgICAgICAgfCBTb21lIG91dHB1dF9kYXRhIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGE6b3V0cHV0X2RhdGEpKSkpXG4gIDs7XG5cbiAgbGV0IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID0gZ2VuZXJpY19tYXBpIE1hcCA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgbGV0IGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZiA9IGdlbmVyaWNfbWFwaSBGaWx0ZXJfbWFwID9kYXRhX2VxdWFsIG1hcCB+ZlxuICBsZXQgbWFwID9kYXRhX2VxdWFsIG1hcCB+ZiA9IG1hcGkgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxuICBsZXQgZmlsdGVyX21hcCA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHdpdGhfb2xkMiBpMSBpMiB+ZiA9XG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgSW5jcmVtZW50YWwubWFwMiBpMSBpMiB+ZjooZnVuIGExIGEyIC0+XG4gICAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGExIGEyIGluXG4gICAgICBvbGQgOj0gU29tZSAoYTEsIGEyLCBiKTtcbiAgICAgIGIpXG4gIDs7XG5cbiAgbGV0IG1hcGlfY291bnRcbiAgICAgICAgKHR5cGUgYSBjbXApXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGlucHV0XG4gICAgICAgIH4oY29tcGFyYXRvciA6XG4gICAgICAgICAgICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGEgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKSlcbiAgICAgICAgfmZcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBNID0gKHZhbCBjb21wYXJhdG9yKSBpblxuICAgIGxldCBhZGQgbmV3X2tleSBhY2MgPVxuICAgICAgTWFwLnVwZGF0ZSBhY2MgbmV3X2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgfCBTb21lIG4gLT4gbiArIDEpXG4gICAgaW5cbiAgICBsZXQgcmVtb3ZlIG5ld19rZXkgYWNjID1cbiAgICAgIE1hcC5jaGFuZ2UgYWNjIG5ld19rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSAxIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIG4gLT4gU29tZSAobiAtIDEpKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIE0pKVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCAoZiB+a2V5IH5kYXRhKSBhY2MpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIChmIH5rZXkgfmRhdGEpIGFjYylcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIGxldCBwcmV2X2tleSA9IGYgfmtleSB+ZGF0YTpvbGRfZGF0YSBpblxuICAgICAgICBsZXQgbmV3X2tleSA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICBpZiBNLmNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIGFjY1xuICAgICAgICBlbHNlIGFjYyB8PiByZW1vdmUgcHJldl9rZXkgfD4gYWRkIG5ld19rZXkpXG4gIDs7XG5cbiAgbGV0IG1hcF9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1pbl9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtaW4sIF8pIC0+IFNvbWUgbWluXG4gIDs7XG5cbiAgbGV0IG1heF9oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWF4X2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtYXgsIF8pIC0+IFNvbWUgbWF4XG4gIDs7XG5cbiAgbGV0IGJvdW5kc19oZWxwZXIgbWFwID1cbiAgICBtYXRjaCBNYXAubWluX2VsdCBtYXAsIE1hcC5tYXhfZWx0IG1hcCB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKG1pbiwgXyksIFNvbWUgKG1heCwgXykgLT4gU29tZSAobWluLCBtYXgpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwIH5mOm1pbl9oZWxwZXIgKG1hcGlfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6bWF4X2hlbHBlciAobWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwaV9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpib3VuZHNfaGVscGVyIChtYXBpX2NvdW50ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX21pbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1hcF9tYXggP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgbWluX3ZhbHVlID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yID1cbiAgICBtYXBpX21uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1heF92YWx1ZSA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX21heCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtYXBfYm91bmRzID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtZXJnZVxuICAgICAgICA/KGRhdGFfZXF1YWxfbGVmdCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8oZGF0YV9lcXVhbF9yaWdodCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIGxlZnRfbWFwXG4gICAgICAgIHJpZ2h0X21hcFxuICAgICAgICB+ZlxuICAgID1cbiAgICB3aXRoX29sZDIgbGVmdF9tYXAgcmlnaHRfbWFwIH5mOihmdW4gfm9sZCBuZXdfbGVmdF9tYXAgbmV3X3JpZ2h0X21hcCAtPlxuICAgICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBuZXdfbGVmdF9tYXAgaW5cbiAgICAgIGxldCBvbGRfbGVmdF9tYXAsIG9sZF9yaWdodF9tYXAsIG9sZF9vdXRwdXQgPVxuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICAgICAgfCBTb21lIHggLT4geFxuICAgICAgaW5cbiAgICAgIGxldCBsZWZ0X2RpZmYgPVxuICAgICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX2xlZnRfbWFwIG5ld19sZWZ0X21hcCB+ZGF0YV9lcXVhbDpkYXRhX2VxdWFsX2xlZnRcbiAgICAgIGluXG4gICAgICBsZXQgcmlnaHRfZGlmZiA9XG4gICAgICAgIE1hcC5zeW1tZXRyaWNfZGlmZiBvbGRfcmlnaHRfbWFwIG5ld19yaWdodF9tYXAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgaW5cbiAgICAgICgqIFdlIG1lcmdlIHRoZSB0d28gc2lkZXMgb2YgdGhlIGRpZmZzIHRvZ2V0aGVyIHNvIHdlIGNhbiBtYWtlIHN1cmUgdG8gaGFuZGxlIGVhY2hcbiAgICAgICAgIGtleSBleGFjdGx5IG9uY2UuIFRoaXMgcmVsaWVzIG9uIHN5bW1ldHJpYyBkaWZmIGdpdmluZyBzb3J0ZWQgb3V0cHV0LiAqKVxuICAgICAgU2VxdWVuY2UubWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gICAgICAgIGxlZnRfZGlmZlxuICAgICAgICByaWdodF9kaWZmXG4gICAgICAgIH5jb21wYXJlOihmdW4gKGxlZnRfa2V5LCBfKSAocmlnaHRfa2V5LCBfKSAtPlxuICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZSBsZWZ0X2tleSByaWdodF9rZXkpXG4gICAgICB8PiBTZXF1ZW5jZS5mb2xkIH5pbml0Om9sZF9vdXRwdXQgfmY6KGZ1biBvdXRwdXQgZGlmZl9lbGVtZW50IC0+XG4gICAgICAgIGxldCBrZXkgPVxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBMZWZ0IChrZXksIF8pIHwgUmlnaHQgKGtleSwgXykgLT4ga2V5XG4gICAgICAgICAgfCBCb3RoICgobGVmdF9rZXksIF8pLCAocmlnaHRfa2V5LCBfKSkgLT5cbiAgICAgICAgICAgIGFzc2VydCAoY29tcGFyYXRvci5jb21wYXJlIGxlZnRfa2V5IHJpZ2h0X2tleSA9IDApO1xuICAgICAgICAgICAgbGVmdF9rZXlcbiAgICAgICAgaW5cbiAgICAgICAgKCogVGhlc2UgdmFsdWVzIHJlcHJlc2VudCB3aGV0aGVyIHRoZXJlIGlzIGRhdGEgZm9yIHRoZSBnaXZlbiBrZXkgaW4gdGhlIG5ld1xuICAgICAgICAgICBpbnB1dCBpbiB0aGUgbGVmdCBhbmQgcmlnaHQgbWFwLiAqKVxuICAgICAgICBsZXQgbGVmdF9kYXRhX29wdCwgcmlnaHRfZGF0YV9vcHQgPVxuICAgICAgICAgIGxldCBuZXdfZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgfCBCb3RoICgoXywgbGVmdF9kaWZmKSwgKF8sIHJpZ2h0X2RpZmYpKSAtPlxuICAgICAgICAgICAgbmV3X2RhdGEgbGVmdF9kaWZmLCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgICAgfCBMZWZ0IChfLCBsZWZ0X2RpZmYpIC0+IG5ld19kYXRhIGxlZnRfZGlmZiwgTWFwLmZpbmQgbmV3X3JpZ2h0X21hcCBrZXlcbiAgICAgICAgICB8IFJpZ2h0IChfLCByaWdodF9kaWZmKSAtPiBNYXAuZmluZCBuZXdfbGVmdF9tYXAga2V5LCBuZXdfZGF0YSByaWdodF9kaWZmXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvdXRwdXRfZGF0YV9vcHQgPVxuICAgICAgICAgIG1hdGNoIGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0IHdpdGhcbiAgICAgICAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSB4LCBOb25lIC0+IGYgfmtleSAoYExlZnQgeClcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgeSAtPiBmIH5rZXkgKGBSaWdodCB5KVxuICAgICAgICAgIHwgU29tZSB4LCBTb21lIHkgLT4gZiB+a2V5IChgQm90aCAoeCwgeSkpXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIG91dHB1dF9kYXRhX29wdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIGlucHV0X2RhdGEgb3V0cHV0X2RhdGEgZl9vdXRwdXQgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgKHdpdG5lc3MgOiAoaW5wdXRfZGF0YSwgb3V0cHV0X2RhdGEsIGZfb3V0cHV0KSBNYXBfdHlwZS50KVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChsaHMgOiAoKCdrZXksIGlucHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KGNvbXBhcmF0b3IgOiAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50KVxuICAgICAgICB+KGYgOlxuICAgICAgICAgICAga2V5OidrZXlcbiAgICAgICAgICAtPiBkYXRhOihpbnB1dF9kYXRhLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgICAgLT4gKGZfb3V0cHV0LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgIDogKCgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgbGhzIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBwcmV2X25vZGVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBhY2MgOiAoJ2tleSwgb3V0cHV0X2RhdGEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFhY2MpIGluXG4gICAgbGV0IChvbl9pbm5lcl9jaGFuZ2UgOiBrZXk6J2tleSAtPiBmX291dHB1dCAtPiB1bml0KSA9XG4gICAgICBtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgIHwgTWFwX3R5cGUuTWFwIC0+IGZ1biB+a2V5IGRhdGEgLT4gYWNjIDo9IE1hcC5zZXQgIWFjYyB+a2V5IH5kYXRhXG4gICAgICB8IE1hcF90eXBlLkZpbHRlcl9tYXAgLT5cbiAgICAgICAgZnVuIH5rZXkgb3B0IC0+XG4gICAgICAgICAgbGV0IG9sZCA9ICFhY2MgaW5cbiAgICAgICAgICBhY2NcbiAgICAgICAgICA6PSAobWF0Y2ggb3B0IHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG9sZCBrZXlcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE1hcC5zZXQgb2xkIH5rZXkgfmRhdGEpXG4gICAgaW5cbiAgICBsZXQgcmVjIGxoc19jaGFuZ2UgPVxuICAgICAgbGF6eVxuICAgICAgICAoSW5jcmVtZW50YWwubWFwIGxocyB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9kZXAgPSBNYXAuZmluZF9leG4gbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IHJlc3VsdCBkZXA7XG4gICAgICAgICAgICAgICAgICAgYWNjIDo9IE1hcC5yZW1vdmUgIWFjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgT3B0aW9uLml0ZXIgY3V0b2ZmIH5mOihmdW4gYyAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBsaHNfY2hhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgbGV0IHVzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgKGYgfmtleSB+ZGF0YTooRS5Ob2RlLndhdGNoIG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihvbl9pbm5lcl9jaGFuZ2UgfmtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgTWFwLnNldCBub2RlcyB+a2V5IH5kYXRhOihub2RlLCB1c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByZXZfbm9kZXMgOj0gbmV3X25vZGVzO1xuICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgbGhzX2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCByZXN1bHRcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgTWFwX3R5cGUuRmlsdGVyX21hcFxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwaScgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJyBNYXBfdHlwZS5NYXAgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIG1hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCcgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGZpbHRlcl9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1lcmdlJyA/Y3V0b2ZmID9kYXRhX2VxdWFsX2xlZnQgP2RhdGFfZXF1YWxfcmlnaHQgbWFwMSBtYXAyIH5mID1cbiAgICBtZXJnZSA/ZGF0YV9lcXVhbF9sZWZ0ID9kYXRhX2VxdWFsX3JpZ2h0IG1hcDEgbWFwMiB+ZjooZnVuIH5rZXk6XyBkaWZmIC0+IFNvbWUgZGlmZilcbiAgICB8PiBmaWx0ZXJfbWFwaScgP2N1dG9mZiB+ZjooZnVuIH5rZXkgfmRhdGE6ZGlmZiAtPiBmIH5rZXkgZGlmZilcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaV93aXRoX2NvbXBhcmF0b3JcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgOiB2IC0+IHYgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8obGVmdF9yZXN1bHRfZXF1YWwgOiB2MSAtPiB2MSAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgPyhyaWdodF9yZXN1bHRfZXF1YWwgOiB2MiAtPiB2MiAtPiBib29sID0gcGh5c19lcXVhbClcbiAgICAgICAgKGlucHV0IDogKCgna2V5LCB2LCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICAgICAgfihmIDoga2V5OidrZXkgLT4gZGF0YTp2IC0+IHYxICogdjIpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBsZWZ0X2FjYyA6ICgna2V5LCB2MSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhbGVmdF9hY2MpIGluXG4gICAgbGV0IHJpZ2h0X2FjYyA6ICgna2V5LCB2MiwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByaWdodF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJpZ2h0X2FjYykgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGlucHV0X2NoYW5nZSA9XG4gICAgICBJbmNyZW1lbnRhbC5tYXAgaW5wdXQgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgbGV0IGxlZnQsIHJpZ2h0ID1cbiAgICAgICAgICBtYXRjaCBNYXAuaXNfZW1wdHkgIXByZXZfbWFwLCBNYXAuaXNfZW1wdHkgbWFwIHdpdGhcbiAgICAgICAgICB8IHRydWUsIHRydWUgfCBmYWxzZSwgdHJ1ZSAtPiBlbXB0eV9tYXAsIGVtcHR5X21hcFxuICAgICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgICAgICgqIE1hcHBpbmcgb24gYSBtYXAgaXMgd2F5IGZhc3RlciB0aGFuIHN5bW1ldHJpYyBkaWZmaW5nIGFuZCB0aGVuXG4gICAgICAgICAgICAgICBidWlsZGluZyB0aGUgbWFwcyB1cCBwaWVjZSBieSBwaWVjZSwgc28gd2UgZG8gdGhpcyB3aGVuZXZlciB3ZVxuICAgICAgICAgICAgICAgdHJhbnNpdGlvbiBmcm9tIFwiZW1wdHlcIiB0byBcInNvbWV0aGluZ1wiLCB3aGljaCB3aWxsIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgIGhhcHBlbiBvbiB0aGUgZmlyc3Qgc3RhYmlsaXphdGlvbi4gKilcbiAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgIGxldCBsLCBfID0gZiB+a2V5IH5kYXRhIGluXG4gICAgICAgICAgICAgICAgbClcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgcmlnaHQgPVxuICAgICAgICAgICAgICBNYXAubWFwaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICAgICAgbGV0IF8sIHIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICAgICAgICByKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgfCBmYWxzZSwgZmFsc2UgLT5cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgfmluaXQ6KCFsZWZ0X2FjYywgIXJpZ2h0X2FjYylcbiAgICAgICAgICAgICAgfmY6KGZ1biAobGVmdCwgcmlnaHQpIChrZXksIGNoYW5nZWQpIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAocHJldiwgbmV3XykgLT5cbiAgICAgICAgICAgICAgICAgIGxldCBwcmV2X2EsIHByZXZfYiA9IGYgfmtleSB+ZGF0YTpwcmV2IGluXG4gICAgICAgICAgICAgICAgICBsZXQgbmV3X2EsIG5ld19iID0gZiB+a2V5IH5kYXRhOm5ld18gaW5cbiAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgbGVmdF9yZXN1bHRfZXF1YWwgcHJldl9hIG5ld19hXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gbGVmdFxuICAgICAgICAgICAgICAgICAgICBlbHNlIE1hcC5zZXQgbGVmdCB+a2V5IH5kYXRhOm5ld19hXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaWYgcmlnaHRfcmVzdWx0X2VxdWFsIHByZXZfYiBuZXdfYlxuICAgICAgICAgICAgICAgICAgICB0aGVuIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCByaWdodCB+a2V5IH5kYXRhOm5ld19iXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHRcbiAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTWFwLnJlbW92ZSBsZWZ0IGtleSwgTWFwLnJlbW92ZSByaWdodCBrZXlcbiAgICAgICAgICAgICAgICB8IGBSaWdodCBlbGVtZW50IC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYSwgYiA9IGYgfmtleSB+ZGF0YTplbGVtZW50IGluXG4gICAgICAgICAgICAgICAgICBNYXAuc2V0IGxlZnQgfmtleSB+ZGF0YTphLCBNYXAuc2V0IHJpZ2h0IH5rZXkgfmRhdGE6YilcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsICFsZWZ0X2FjYyBsZWZ0KSB0aGVuIEUuTm9kZS5tYWtlX3N0YWxlIGxlZnRfcmVzdWx0O1xuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgIXJpZ2h0X2FjYyByaWdodCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSByaWdodF9yZXN1bHQ7XG4gICAgICAgIGxlZnRfYWNjIDo9IGxlZnQ7XG4gICAgICAgIHJpZ2h0X2FjYyA6PSByaWdodDtcbiAgICAgICAgcHJldl9tYXAgOj0gbWFwKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIGlucHV0X2NoYW5nZSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpID9kYXRhX2VxdWFsID9sZWZ0X3Jlc3VsdF9lcXVhbCA/cmlnaHRfcmVzdWx0X2VxdWFsIGlucHV0IH5mID1cbiAgICBsZXQgcGFpciA9XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICAgIGlucHV0XG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgICAgICAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgICAgICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICAgICAgICB+ZlxuICAgICAgICB8PiBUdXBsZTIudW5jdXJyeSBJbmNyZW1lbnRhbC5ib3RoKVxuICAgIGluXG4gICAgSW5jcmVtZW50YWwubWFwIH5mOmZzdCBwYWlyLCBJbmNyZW1lbnRhbC5tYXAgfmY6c25kIHBhaXJcbiAgOztcblxuICBsZXQgdW56aXAgP2xlZnRfcmVzdWx0X2VxdWFsID9yaWdodF9yZXN1bHRfZXF1YWwgaW5wdXQgPVxuICAgIGxldCBkYXRhX2VxdWFsID1cbiAgICAgIE9wdGlvbi5tYXAyIGxlZnRfcmVzdWx0X2VxdWFsIHJpZ2h0X3Jlc3VsdF9lcXVhbCB+ZjooZnVuIGwgciAtPlxuICAgICAgICBUdXBsZTIuZXF1YWwgfmVxMTpsIH5lcTI6cilcbiAgICBpblxuICAgIHVuemlwX21hcGlcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgIGlucHV0XG4gICAgICB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBkYXRhKVxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6XG4gICAgICAgICAgICBrZXk6J2tleVxuICAgICAgICAgIC0+IGRhdGE6KHYsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAodjEsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQgKiAodjIsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgOiAoKCdrZXksIHYxLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgKiAoKCdrZXksIHYyLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dCBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IGxlZnRfYWNjIDo9IE1hcC5zZXQgIWxlZnRfYWNjIH5rZXkgfmRhdGEgaW5cbiAgICBsZXQgcmlnaHRfb25faW5uZXJfY2hhbmdlIH5rZXkgZGF0YSA9IHJpZ2h0X2FjYyA6PSBNYXAuc2V0ICFyaWdodF9hY2MgfmtleSB+ZGF0YSBpblxuICAgIGxldCByZWMgaW5wdXRfY2hhbmdlID1cbiAgICAgIGxhenlcbiAgICAgICAgKEluY3JlbWVudGFsLm1hcCBpbnB1dCB+ZjooZnVuIG1hcCAtPlxuICAgICAgICAgICBsZXQgbmV3X25vZGVzID1cbiAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICFwcmV2X21hcFxuICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICB+aW5pdDohcHJldl9ub2Rlc1xuICAgICAgICAgICAgICAgfmY6KGZ1biBub2RlcyAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIF9sZWZ0X2RlcCwgX3JpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBFLk5vZGUubWFrZV9zdGFsZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBsZWZ0X2RlcCwgcmlnaHRfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IE1hcC5yZW1vdmUgbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfZGVwO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgcmlnaHRfZGVwO1xuICAgICAgICAgICAgICAgICAgIGxlZnRfYWNjIDo9IE1hcC5yZW1vdmUgIWxlZnRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICByaWdodF9hY2MgOj0gTWFwLnJlbW92ZSAhcmlnaHRfYWNjIGtleTtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuaW52YWxpZGF0ZSBub2RlO1xuICAgICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgTWFwLmZpbmRfZXhuICFwcmV2X21hcCBrZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBPcHRpb24uaXRlciBjdXRvZmYgfmY6KGZ1biBjIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5zZXRfY3V0b2ZmIChFLk5vZGUud2F0Y2ggbm9kZSkgYyk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X2luY3IsIHJpZ2h0X2luY3IgPSBmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSBpblxuICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KGxlZnRfb25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRfdXNlcl9mdW5jdGlvbl9kZXAgPVxuICAgICAgICAgICAgICAgICAgICAgRS5EZXBlbmRlbmN5LmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICByaWdodF9pbmNyXG4gICAgICAgICAgICAgICAgICAgICAgIH5vbl9jaGFuZ2U6KHJpZ2h0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IGxlZnRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcDtcbiAgICAgICAgICAgICAgICAgICBNYXAuc2V0XG4gICAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgICAgICAgfmRhdGE6KG5vZGUsIGxlZnRfdXNlcl9mdW5jdGlvbl9kZXAsIHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwKSlcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgcHJldl9ub2RlcyA6PSBuZXdfbm9kZXM7XG4gICAgICAgICAgIHByZXZfbWFwIDo9IG1hcCkpXG4gICAgaW5cbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgbGVmdF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGlucHV0X2NoYW5nZSkpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgICAgbWFwXG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIH5jb21wYXJhdG9yIH5mXG4gICAgICAgIHw+IFR1cGxlMi51bmN1cnJ5IEluY3JlbWVudGFsLmJvdGgpXG4gICAgaW5cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6ZnN0IHBhaXIsIEluY3JlbWVudGFsLm1hcCB+ZjpzbmQgcGFpclxuICA7O1xuXG4gIGxldCBrZXlzIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBhZGQgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5hZGQgYWNjIGtleSBpblxuICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhOl8gYWNjID0gU2V0LnJlbW92ZSBhY2Mga2V5IGluXG4gICAgICBsZXQgZGF0YV9lcXVhbCBfIF8gPSB0cnVlIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICBtYXBcbiAgICAgICAgfmluaXQ6KFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+aW5pdDooZW1wdHksIGVtcHR5KVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YTpfIH5uZXdfZGF0YTpkYXRhIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBGaXJzdCBkYXRhIC0+IE1hcC5zZXQgZmlyc3QgfmtleSB+ZGF0YSwgTWFwLnJlbW92ZSBzZWNvbmQga2V5XG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBNYXAucmVtb3ZlIGZpcnN0IGtleSwgTWFwLnNldCBzZWNvbmQgfmtleSB+ZGF0YSlcbiAgICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IGRhdGEgLT4gTWFwLmFkZF9leG4gZmlyc3QgfmtleSB+ZGF0YSwgc2Vjb25kXG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBmaXJzdCwgTWFwLmFkZF9leG4gc2Vjb25kIH5rZXkgfmRhdGEpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhOl8gKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgTWFwLnJlbW92ZSBmaXJzdCBrZXksIE1hcC5yZW1vdmUgc2Vjb25kIGtleSkpXG4gIDs7XG5cbiAgbGV0IGZsYXR0ZW4gc3RhdGUgbWFwID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgcmVzdWx0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKSkgaW5cbiAgICBsZXQgbm9kZSA9IEUuTm9kZS5jcmVhdGUgc3RhdGUgKGZ1biAoKSAtPiAhcmVzdWx0KSBpblxuICAgIE1hcC5pdGVyaSBtYXAgfmY6KGZ1biB+a2V5IH5kYXRhOmluY3IgLT5cbiAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeVxuICAgICAgICBub2RlXG4gICAgICAgIChFLkRlcGVuZGVuY3kuY3JlYXRlIGluY3Igfm9uX2NoYW5nZTooZnVuIGEgLT5cbiAgICAgICAgICAgcmVzdWx0IDo9IE1hcC5zZXQgIXJlc3VsdCB+a2V5IH5kYXRhOmEpKSk7XG4gICAgRS5Ob2RlLndhdGNoIG5vZGVcbiAgOztcblxuICBsZXQgam9pbl93aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgfmNvbXBhcmF0b3IgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIG1hcF9pbmNyIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHJlc3VsdF9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IG9sZF9tYXBfb2ZfaW5jcnMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGN1cnJlbnRfZGVwZW5kZW5jaWVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJlc3VsdF9tYXApIGluXG4gICAgbGV0IGFkZF9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGFfbm9kZSA9XG4gICAgICBsZXQgbmV3X2RlcCA9XG4gICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGUgZGF0YV9ub2RlIH5vbl9jaGFuZ2U6KGZ1biBkYXRhIC0+XG4gICAgICAgICAgcmVzdWx0X21hcCA6PSBNYXAuc2V0ICFyZXN1bHRfbWFwIH5rZXkgfmRhdGEpXG4gICAgICBpblxuICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCBuZXdfZGVwO1xuICAgICAgTWFwLnNldCBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhOm5ld19kZXBcbiAgICBpblxuICAgIGxldCByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5ID1cbiAgICAgIGxldCBkZXAgPSBNYXAuZmluZF9leG4gY3VycmVudF9kZXBlbmRlbmNpZXMga2V5IGluXG4gICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmVzdWx0IGRlcDtcbiAgICAgIHJlc3VsdF9tYXAgOj0gTWFwLnJlbW92ZSAhcmVzdWx0X21hcCBrZXk7XG4gICAgICBNYXAucmVtb3ZlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIGtleVxuICAgIGluXG4gICAgbGV0IGxoc19jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIG1hcF9pbmNyIH5mOihmdW4gbWFwX29mX2luY3JzIC0+XG4gICAgICAgIGxldCBuZXdfZGVwZW5kZW5jeV9tYXAgPVxuICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICB+ZGF0YV9lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAhb2xkX21hcF9vZl9pbmNyc1xuICAgICAgICAgICAgbWFwX29mX2luY3JzXG4gICAgICAgICAgICB+aW5pdDohY3VycmVudF9kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIH5mOihmdW4gY3VycmVudF9kZXBlbmRlbmNpZXMgKGtleSwgZGlmZikgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgIHwgYExlZnQgXyAtPiByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5XG4gICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGFfbm9kZSAtPiBhZGRfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhX25vZGVcbiAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoXywgZGF0YV9ub2RlKSAtPlxuICAgICAgICAgICAgICAgIHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfD4gYWRkX3N1Ym5vZGUgfmtleSB+ZGF0YV9ub2RlKVxuICAgICAgICBpblxuICAgICAgICBjdXJyZW50X2RlcGVuZGVuY2llcyA6PSBuZXdfZGVwZW5kZW5jeV9tYXA7XG4gICAgICAgIG9sZF9tYXBfb2ZfaW5jcnMgOj0gbWFwX29mX2luY3JzKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBsaHNfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGpvaW4gbWFwID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPiBqb2luX3dpdGhfY29tcGFyYXRvciBtYXAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbW9kdWxlIFNlcGFyYXRlX3N0YXRlID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdCA9XG4gICAgICB7IG11dGFibGUgaW5wdXRfbWFwIDogKCdrLCAndiwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgbXV0YWJsZSBleHBlcnRfbm9kZXMgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnQsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgb3V0cHV0X21hcCA6ICgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnRcbiAgICAgIH1cblxuICAgIGxldCBjcmVhdGUgY29tcGFyYXRvciA9XG4gICAgICBsZXQgZW1wdHkgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgeyBpbnB1dF9tYXAgPSBlbXB0eTsgZXhwZXJ0X25vZGVzID0gZW1wdHk7IG91dHB1dF9tYXAgPSBlbXB0eSB9XG4gICAgOztcblxuICAgIGxldCBjcmVhdGVfbG9va3VwX25vZGUgc3RhdGUgdCBrZXkgPVxuICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT4gTWFwLmZpbmRfZXhuIHQuaW5wdXRfbWFwIGtleSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2VwYXJhdGUgaW5wdXRfbWFwIH5kYXRhX2VxdWFsID1cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXAgaW5cbiAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXRfbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgbGV0IHN0YXRlID0gU2VwYXJhdGVfc3RhdGUuY3JlYXRlIGNvbXBhcmF0b3IgaW5cbiAgICAgIGxldCBvdXRwdXRfbWFwX25vZGUgPVxuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiBzdGF0ZS5vdXRwdXRfbWFwKVxuICAgICAgaW5cbiAgICAgIGxldCBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG5vZGUgfmlucHV0X21hcF9jaGFuZ2VkID1cbiAgICAgICAgbGV0IGRlcGVuZGVuY3kgPVxuICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSAoTGF6eS5mb3JjZV92YWwgaW5wdXRfbWFwX2NoYW5nZWQpXG4gICAgICAgIGluXG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmFkZF9kZXBlbmRlbmN5IG5vZGUgZGVwZW5kZW5jeVxuICAgICAgaW5cbiAgICAgICgqIFdlIHdhbnQgdG8gbWFrZSBub2RlcyBkZXBlbmQgb24gW2lucHV0X21hcF9jaGFuZ2VkXSBzbyB0aGF0IFtpbnB1dF9tYXBfY2hhbmdlZF1cbiAgICAgICAgIGlzIGFsbG93ZWQgdG8gbWFrZSB0aGVtIHN0YWxlLCBidXQgd2UgZG8gbm90IHdhbnQgdGhlbSB0byBiZSByZWNvbXB1dGVkIGZvciBhbnlcbiAgICAgICAgIG90aGVyIHJlYXNvbi4gU28gd2UgbWFrZSBbaW5wdXRfbWFwX2NoYW5nZWRdIGEgdW5pdCBpbmNyZW1lbnRhbCAodGhhdCB0aGVyZWZvcmVcbiAgICAgICAgIG5ldmVyIGNoYW5nZXMpIGFuZCB0aGlzIHdheSBbb3V0cHV0X21hcF9ub2RlXSBhbmQgdGhlIGxvb2t1cCBub2RlcyB3aWxsIG9ubHkgYmVcbiAgICAgICAgIHJlY29tcHV0ZWQgd2hlbiB0aGV5IGFyZSBleHBsaWNpdGx5IG1hZGUgc3RhbGUuXG4gICAgICAqKVxuICAgICAgbGV0IHJlYyBpbnB1dF9tYXBfY2hhbmdlZCA9XG4gICAgICAgIGxhenlcbiAgICAgICAgICAoSW5jcmVtZW50YWwubWFwIGlucHV0X21hcCB+ZjooZnVuIGlucHV0X21hcCAtPlxuICAgICAgICAgICAgIGxldCBwcmV2X2lucHV0X21hcCA9IHN0YXRlLmlucHV0X21hcCBpblxuICAgICAgICAgICAgIGxldCBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXAgPVxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgcHJldl9pbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgaW5wdXRfbWFwXG4gICAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAgIH5pbml0OihzdGF0ZS5leHBlcnRfbm9kZXMsIHN0YXRlLm91dHB1dF9tYXApXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gKGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfb2xkX3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgb2xkX25vZGUgPSBNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuaW52YWxpZGF0ZSBvbGRfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgTWFwLnJlbW92ZSBleHBlcnRfbm9kZXMga2V5LCBNYXAucmVtb3ZlIG91dHB1dF9tYXAga2V5XG4gICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgX25ld192YWx1ZSAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICBTZXBhcmF0ZV9zdGF0ZS5jcmVhdGVfbG9va3VwX25vZGUgaW5jcmVtZW50YWxfc3RhdGUgc3RhdGUga2V5XG4gICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBub2RlIH5pbnB1dF9tYXBfY2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgb3V0cHV0X21hcF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgKCBNYXAuYWRkX2V4biBleHBlcnRfbm9kZXMgfmtleSB+ZGF0YTpub2RlXG4gICAgICAgICAgICAgICAgICAgICAsIE1hcC5hZGRfZXhuXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0X21hcFxuICAgICAgICAgICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGF0YTooSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggbm9kZSkgKVxuICAgICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgKF9vbGRfdmFsdWUsIF9uZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5tYWtlX3N0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgIChNYXAuZmluZF9leG4gZXhwZXJ0X25vZGVzIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICBleHBlcnRfbm9kZXMsIG91dHB1dF9tYXApXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBzdGF0ZS5pbnB1dF9tYXAgPC0gaW5wdXRfbWFwO1xuICAgICAgICAgICAgIHN0YXRlLmV4cGVydF9ub2RlcyA8LSBleHBlcnRfbm9kZXM7XG4gICAgICAgICAgICAgc3RhdGUub3V0cHV0X21hcCA8LSBvdXRwdXRfbWFwKSlcbiAgICAgIGluXG4gICAgICBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG91dHB1dF9tYXBfbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQ7XG4gICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBvdXRwdXRfbWFwX25vZGUpXG4gIDs7XG5cbiAgKCogSnVzdCBmb3IgZGVyaXZpbmcgc3RydWN0dXJhbCBlcXVhbGl0eS4gKilcbiAgdHlwZSAnYSBtYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgPSAnYSBNYXliZV9ib3VuZC50ID1cbiAgICB8IEluY2wgb2YgJ2FcbiAgICB8IEV4Y2wgb2YgJ2FcbiAgICB8IFVuYm91bmRlZFxuICBbQEBkZXJpdmluZyBlcXVhbF1cblxuICBsZXQgc3VicmFuZ2VcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAobWFwX2luY3IgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIHJhbmdlXG4gICAgPVxuICAgIHdpdGhfb2xkMiBtYXBfaW5jciByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIHJhbmdlIC0+XG4gICAgICBsZXQgY29tcGFyZSA9IChNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgIGxldCBlcXVhbCBsIHIgPSBjb21wYXJlIGwgciA9IDAgaW5cbiAgICAgIGxldCAoID4gKSBhIGIgPSBjb21wYXJlIGEgYiA+IDBcbiAgICAgIGFuZCAoID49ICkgYSBiID0gY29tcGFyZSBhIGIgPj0gMCBpblxuICAgICAgbGV0IG1heWJlX2JvdW5kX2VxdWFsIGEgYiA6IGJvb2wgPSBlcXVhbF9tYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgZXF1YWwgYSBiIGluXG4gICAgICBsZXQgcmFuZ2VfaXNfZW1wdHkgfm1pbiB+bWF4IDogYm9vbCA9XG4gICAgICAgIG1hdGNoIG1pbiwgbWF4IHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQsIChVbmJvdW5kZWQgfCBFeGNsIF8gfCBJbmNsIF8pIHwgKEV4Y2wgXyB8IEluY2wgXyksIFVuYm91bmRlZCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIHwgSW5jbCBtaW4sIEluY2wgbWF4IC0+IG1pbiA+IG1heFxuICAgICAgICB8IEV4Y2wgbWluLCBFeGNsIG1heCB8IEluY2wgbWluLCBFeGNsIG1heCB8IEV4Y2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPj0gbWF4XG4gICAgICBpblxuICAgICAgbGV0IHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXkgOiBib29sID1cbiAgICAgICAgTWF5YmVfYm91bmQuaXNfbG93ZXJfYm91bmQgbWluIH5vZl86a2V5IH5jb21wYXJlXG4gICAgICAgICYmIE1heWJlX2JvdW5kLmlzX3VwcGVyX2JvdW5kIG1heCB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHJhbmdlIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAoKiBFbXB0eSBuZXcgcmFuZ2UgbWVhbnMgZW1wdHkgbWFwICopXG4gICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICB8IFNvbWUgKChtaW4sIG1heCkgYXMgcmFuZ2UpIC0+XG4gICAgICAgIGxldCBmcm9tX3NjcmF0Y2ggKCkgPSBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZDptaW4gfnVwcGVyX2JvdW5kOm1heCBpblxuICAgICAgICAobWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIE5vbmUsIF8pIC0+XG4gICAgICAgICAgICgqIG5vIG9sZCByYW5nZSAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAoXywgU29tZSAob2xkX21pbiwgb2xkX21heCksIF8pXG4gICAgICAgICAgIHdoZW4gcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW4gfm1heDpvbGRfbWF4XG4gICAgICAgICAgICAgfHwgcmFuZ2VfaXNfZW1wdHkgfm1pbjpvbGRfbWluIH5tYXggLT5cbiAgICAgICAgICAgKCogZW1wdHkgb2xkIHJhbmdlIG9yIG9sZCByYW5nZSBkaXNqb2ludCB3aXRoIG5ldyAqKVxuICAgICAgICAgICBmcm9tX3NjcmF0Y2ggKClcbiAgICAgICAgIHwgU29tZSAob2xkX21hcCwgU29tZSAoKG9sZF9taW4sIG9sZF9tYXgpIGFzIG9sZF9yYW5nZSksIG9sZF9yZXMpIC0+XG4gICAgICAgICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgICAgICAgICgqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGtleSBpcyBpbiBib3RoIG5ldyBhbmQgb2xkIHJhbmdlcyAqKVxuICAgICAgICAgICAgIGxldCBpbl9yYW5nZV9pbnRlcnNlY3Rpb24ga2V5ID1cbiAgICAgICAgICAgICAgIHJhbmdlX2luY2x1ZGVzIH5taW4gfm1heCBrZXlcbiAgICAgICAgICAgICAgICYmIHJhbmdlX2luY2x1ZGVzIH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXgga2V5XG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBBcHBseSBjaGFuZ2VzIHRvIGtleXMgd2hpY2ggYXJlIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgYm90aCByYW5nZXMuXG5cbiAgICAgICAgICAgICAgICBbb3V0c2lkZV0gaXMgdGhlIG51bWJlciBvZiB1cGRhdGVzIG91dHNpZGUgdGhlIHJhbmdlIGludGVyc2VjdGlvbiB0aGF0IHdlXG4gICAgICAgICAgICAgICAgdG9sZXJhdGUgYmVmb3JlIGdpdmluZyB1cCBhbmQgcmVjb25zdHJ1Y3RpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZS4gVGhpc1xuICAgICAgICAgICAgICAgIGlzIGFuIG9wdGltaXNhdGlvbiBpbiB0aGUgY2FzZSB0aGF0IHRoZSBtYXAgY2hhbmdlcyBpbiBhIHZlcnkgYmlnIHdheSwgYXRcbiAgICAgICAgICAgICAgICB3aGljaCBwb2ludCBjb21wdXRpbmcgYmFzZWQgb24gdGhlIG5ldyByYW5nZSBpcyBjaGVhcGVyLiAgKilcbiAgICAgICAgICAgICBsZXQgYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24gKG91dHNpZGUsIG1hcCkgKGtleSwgZGF0YSkgPVxuICAgICAgICAgICAgICAgaWYgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleVxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5XG4gICAgICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGEgfCBgVW5lcXVhbCAoXywgZGF0YSkgLT4gb3V0c2lkZSwgTWFwLnNldCBtYXAgfmtleSB+ZGF0YSlcbiAgICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgICBsZXQgb3V0c2lkZSA9IG91dHNpZGUgLSAxIGluXG4gICAgICAgICAgICAgICAgIGlmIEludC5PLihvdXRzaWRlIDwgMClcbiAgICAgICAgICAgICAgICAgdGhlbiByZXR1cm4gKGZyb21fc2NyYXRjaCAoKSlcbiAgICAgICAgICAgICAgICAgZWxzZSBvdXRzaWRlLCBNYXAucmVtb3ZlIG1hcCBrZXkpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAoKiBGaXJzdCB1cGRhdGUgdGhlIGtleXMgaW4gL2JvdGgvIHRoZSBvbGQgYW5kIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgbGV0IHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uID1cbiAgICAgICAgICAgICAgICgqIEN1dG9mZiB0aGUgYmlnIGRpZmYgY29tcHV0YXRpb24gaWYgd2UgcmVhY2ggTyh8c3VibWFwfCkgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHJhbmdlICopXG4gICAgICAgICAgICAgICBsZXQgb3V0c2lkZV9jdXRvZmYgPSBNYXAubGVuZ3RoIG9sZF9yZXMgLyA0IGluXG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgICB+aW5pdDoob3V0c2lkZV9jdXRvZmYsIG9sZF9yZXMpXG4gICAgICAgICAgICAgICAgIH5mOmFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICB8PiBzbmRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIFR1cGxlMi5lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMTptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgfmVxMjptYXliZV9ib3VuZF9lcXVhbFxuICAgICAgICAgICAgICAgICAgb2xkX3JhbmdlXG4gICAgICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIFRoZXJlIGFyZSBubyBrZXlzIHRvIHJlbW92ZSBhbmQgZXZlcnl0aGluZyBpbiByYW5nZSBpcyB1cGRhdGVkLiAqKVxuICAgICAgICAgICAgICAgd2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICgqIFJlbW92ZSBhbnkga2V5cyB3aGljaCBhcmUgbm90IGluIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgICBsZXQgd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZVxuICAgICAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgfmxvd2VyX2JvdW5kOm1pblxuICAgICAgICAgICAgICAgICAgIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoKiBBZGQgaW4gYW55IGtleXMgd2hpY2ggYXJlIGluIHRoZSBuZXcgcmFuZ2UgYnV0IG5vdCB0aGUgb2xkIHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlID1cbiAgICAgICAgICAgICAgICAgbGV0IG1hcF9hcHBlbmRfZXhuIGxvd2VyX3BhcnQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICAgICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiaW1wb3NzaWJsZSBjYXNlOiBCVUcgaW4gaW5jcl9tYXAubWwgc3VicmFuZ2VcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21pbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEluY2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21pbiAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDooRXhjbCBvbGRfbWluKVxuICAgICAgICAgICAgICAgICBhbmQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21heCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihJbmNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21heCAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6KEV4Y2wgb2xkX21heCkgfnVwcGVyX2JvdW5kOm1heFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBtYXBfYXBwZW5kX2V4blxuICAgICAgICAgICAgICAgICAgIGxvd2VyX3BhcnRcbiAgICAgICAgICAgICAgICAgICAobWFwX2FwcGVuZF9leG4gd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSB1cHBlcl9wYXJ0KVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlKSkpKVxuICA7O1xuXG4gIGxldCByZWtleSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5mID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgbWFwX2luY3JcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLmFkZF9leG4gb3V0cHV0IH5rZXk6KGYgfmtleSB+ZGF0YSkgfmRhdGEpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBvdXRwdXQgLT4gTWFwLnJlbW92ZSBvdXRwdXQgKGYgfmtleSB+ZGF0YSkpXG4gICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIG91dHB1dCAtPlxuICAgICAgICBsZXQgcHJldl9rZXkgPSBmIH5rZXkgfmRhdGE6b2xkX2RhdGEgaW5cbiAgICAgICAgbGV0IG5ld19rZXkgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgaWYgKE1hcC5jb21wYXJhdG9yIG91dHB1dCkuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIE1hcC5zZXQgb3V0cHV0IH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YVxuICAgICAgICBlbHNlIE1hcC5yZW1vdmUgb3V0cHV0IHByZXZfa2V5IHw+IE1hcC5hZGRfZXhuIH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YSlcbiAgOztcblxuICBsZXQgaW5kZXhfYnlpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3IgfmluZGV4ID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwX2luY3IgKGZ1biBpbm5lcl9jb21wYXJhdG9yIC0+XG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfmFkZDooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIG91dGVyX21hcCAtPlxuICAgICAgICAgIG1hdGNoIGluZGV4IH5rZXk6aW5uZXJfa2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gb3V0ZXJfbWFwXG4gICAgICAgICAgfCBTb21lIG91dGVyX2tleSAtPlxuICAgICAgICAgICAgTWFwLnVwZGF0ZSBvdXRlcl9tYXAgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b25cbiAgICAgICAgICAgICAgICAgIGlubmVyX2tleVxuICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+IE1hcC5hZGRfZXhuIGlubmVyX21hcCB+a2V5OmlubmVyX2tleSB+ZGF0YSkpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC5jaGFuZ2Ugb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZmFpbHdpdGggXCJCVUc6IEhpdCBzdXBwb3NlZGx5IGltcG9zc2libGUgY2FzZSBpbiBJbmNyX21hcC5pbmRleF9ieVwiXG4gICAgICAgICAgICAgIHwgU29tZSBpbm5lcl9tYXAgLT5cbiAgICAgICAgICAgICAgICBsZXQgaW5uZXJfbWFwID0gTWFwLnJlbW92ZSBpbm5lcl9tYXAgaW5uZXJfa2V5IGluXG4gICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGlubmVyX21hcCB0aGVuIE5vbmUgZWxzZSBTb21lIGlubmVyX21hcCkpKVxuICA7O1xuXG4gIGxldCBpbmRleF9ieSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgIGluZGV4X2J5aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvciB+aW5kZXg6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gaW5kZXggZGF0YSlcbiAgOztcblxuXG4gICgqKiBGaW5kIHR3byBrZXlzIGluIG1hcCBieSBpbmRleCwgTyhuKS4gV2UgdXNlIGp1c3Qgb25lIGZvbGQgKHR3byBNYXAubnRoIHdvdWxkIHVzZSB0d28pXG4gICAgICBhbmQgb3B0aW1pemUgZm9yIGtleXMgY2xvc2UgdG8gZWl0aGVyIGJlZ2lubmluZyBvciBlbmQgYnkgdXNpbmcgZWl0aGVyIGZvbGQgb3JcbiAgICAgIGZvbGRfcmlnaHQuXG4gICopXG4gIG1vZHVsZSBLZXlfc3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAnayB0ID1cbiAgICAgIHwgS25vd24gb2YgJ2tcbiAgICAgIHwgS25vd25fbm9uZVxuICAgICAgfCBVbmtub3duXG5cbiAgICBsZXQgaXNfa25vd24gPSBmdW5jdGlvblxuICAgICAgfCBVbmtub3duIC0+IGZhbHNlXG4gICAgICB8IF8gLT4gdHJ1ZVxuICAgIDs7XG5cbiAgICBsZXQgdG9fb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biB8IEtub3duX25vbmUgLT4gTm9uZVxuICAgICAgfCBLbm93biBrIC0+IFNvbWUga1xuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBmaW5kX2tleV9yYW5nZV9saW5lYXIgKHR5cGUgaykgfmZyb20gfnRvXyAobWFwIDogKGssIF8sIF8pIE1hcC50KVxuICAgIDogKGsgKiBrIG9wdGlvbikgb3B0aW9uXG4gICAgPVxuICAgIGxldCBvcGVuIEtleV9zdGF0dXMgaW5cbiAgICBsZXQgbGVuID0gTWFwLmxlbmd0aCBtYXAgaW5cbiAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPj0gKSBmcm9tIGxlbiB0aGVuIEtub3duX25vbmUgZWxzZSBVbmtub3duIGluXG4gICAgbGV0IGVuZF9rZXkgPSBpZiBJbnQuKCA+PSApIHRvXyBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBmaW5kX2tleXMgZm9sZCB+c3RhcnRfcG9zIH5hZHZhbmNlX3BvcyA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgZm9sZFxuICAgICAgICAgIG1hcFxuICAgICAgICAgIH5pbml0OihiZWdpbl9rZXksIGVuZF9rZXksIHN0YXJ0X3BvcylcbiAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6XyAoYmVnaW5fa2V5LCBlbmRfa2V5LCBwb3MpIC0+XG4gICAgICAgICAgICBsZXQgYmVnaW5fa2V5ID0gaWYgSW50LiggPSApIHBvcyBmcm9tIHRoZW4gS25vd24ga2V5IGVsc2UgYmVnaW5fa2V5IGluXG4gICAgICAgICAgICBsZXQgZW5kX2tleSA9IGlmIEludC4oID0gKSBwb3MgdG9fIHRoZW4gS25vd24ga2V5IGVsc2UgZW5kX2tleSBpblxuICAgICAgICAgICAgaWYgaXNfa25vd24gYmVnaW5fa2V5ICYmIGlzX2tub3duIGVuZF9rZXlcbiAgICAgICAgICAgIHRoZW4gcmV0dXJuIChiZWdpbl9rZXksIGVuZF9rZXksIHBvcylcbiAgICAgICAgICAgIGVsc2UgYmVnaW5fa2V5LCBlbmRfa2V5LCBhZHZhbmNlX3BvcyBwb3MpKVxuICAgIGluXG4gICAgbGV0IGJlZ2luX2tleSwgZW5kX2tleSwgXyA9XG4gICAgICAoKiBTZWFyY2hpbmcgZnJvbSBsZWZ0IHRha2VzIE8odG9fKSwgZnJvbSByaWdodCAtIE8obGVuIC0gZnJvbSksIHNvIHNlbGVjdCB0aGVcbiAgICAgICAgIHNtYWxsZXIgb25lLiAqKVxuICAgICAgaWYgdG9fIDwgbGVuIC0gZnJvbVxuICAgICAgdGhlbiBmaW5kX2tleXMgTWFwLmZvbGQgfnN0YXJ0X3BvczowIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgKyAxKVxuICAgICAgZWxzZSBmaW5kX2tleXMgTWFwLmZvbGRfcmlnaHQgfnN0YXJ0X3BvczoobGVuIC0gMSkgfmFkdmFuY2VfcG9zOihmdW4gcG9zIC0+IHBvcyAtIDEpXG4gICAgaW5cbiAgICBPcHRpb24ubWFwIChLZXlfc3RhdHVzLnRvX29wdGlvbiBiZWdpbl9rZXkpIH5mOihmdW4gYmVnaW5fa2V5IC0+XG4gICAgICBiZWdpbl9rZXksIEtleV9zdGF0dXMudG9fb3B0aW9uIGVuZF9rZXkpXG4gIDs7XG5cbiAgbGV0IG50aF9mcm9tX2VpdGhlcl9zaWRlICh0eXBlIGspIG4gKG1hcCA6IChrLCBfLCBfKSBNYXAudCkgOiBrIG9wdGlvbiA9XG4gICAgT3B0aW9uLm1hcCB+Zjpmc3QgKGZpbmRfa2V5X3JhbmdlX2xpbmVhciB+ZnJvbTpuIH50b186biBtYXApXG4gIDs7XG5cbiAgKCoqIEZpbmQga2V5IFtieV0gcG9zaXRpb25zIGVhcmxpZXIvbGF0ZXIgaW4gYSBtYXAuIFJldHVybnMgbm9uZSBpZiBvdXQgb2YgYm91bmRzLiAqKVxuICBsZXQgcmVjIG9mZnNldCAoa2V5IDogJ2spIChtYXAgOiAoJ2ssIF8sIF8pIE1hcC50KSB+YnkgOiAnayBvcHRpb24gPVxuICAgIGlmIEludC4oID0gKSBieSAwXG4gICAgdGhlbiBTb21lIGtleVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNsb3Nlc3RfZGlyLCBhZGQgPVxuICAgICAgICBpZiBJbnQuKCA8ICkgYnkgMCB0aGVuIGBMZXNzX3RoYW4sIDEgZWxzZSBgR3JlYXRlcl90aGFuLCAtMVxuICAgICAgaW5cbiAgICAgIG1hdGNoIE1hcC5jbG9zZXN0X2tleSBtYXAgY2xvc2VzdF9kaXIga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKGtleSwgXykgLT4gb2Zmc2V0IGtleSBtYXAgfmJ5OihieSArIGFkZCkpXG4gIDs7XG5cbiAgKCoqIEZpbmQgaG93IHdlIG5lZWQgdG8gbW92ZSBba2V5XSBpZiBbY2hhbmdlZF9rZXldIGNoYW5nZWQgaW4gdGhlIGdpdmVuXG4gICAgICB3YXkgKilcbiAgbGV0IGZpbmRfb2Zmc2V0IH5jb21wYXJlIH5rZXkgfmNoYW5nZWRfa2V5IGNoYW5nZSA9XG4gICAgaWYgSW50LiggPCApIChjb21wYXJlIGNoYW5nZWRfa2V5IGtleSkgMFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgIHwgYExlZnQgXyAtPiAxXG4gICAgICB8IGBSaWdodCBfIC0+IC0xXG4gICAgICB8IF8gLT4gMClcbiAgICBlbHNlIDBcbiAgOztcblxuICBsZXQgcmFua1xuICAgICAgICAodHlwZSBrIHYgY21wIHN0YXRlX3dpdG5lc3MpXG4gICAgICAgIChtYXAgOiAoKGssIHYsIGNtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChrZXkgOiAoaywgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IHNhbWVfa2V5IGEgYiA9IGNvbXBhcmVfa2V5IGEgYiA9IDAgaW5cbiAgICAgIGxldCB3aGVuX2tleV9jaGFuZ2VkIH5tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rID1cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgbmV3X2tleSBvbGRfa2V5IDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBJZiB0aGUgbmV3IGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG9sZCBrZXksIGZpbmQgdGhlIHNpemUgb2YgdGhlIG1hcCBzdWJyYW5nZVxuICAgICAgICAgICAgIGJldHdlZW4gdGhlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcHJldmlvdXMgcmFuayAqKVxuICAgICAgICAgIGxldCBsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQgPSBFeGNsIG5ld19rZXksIEV4Y2wgb2xkX2tleSBpblxuICAgICAgICAgIGxldCBzdWJyYW5nZSA9IE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCBpblxuICAgICAgICAgIG9sZF9yYW5rIC0gTWFwLmxlbmd0aCBzdWJyYW5nZSAtIDEpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIE90aGVyd2lzZSwgdGhlIG5ldyBrZXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG9sZCBrZXksIHNvIGZpbmQgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgICAgICAgbWFwIHN1YnJhbmdlIGJldHdlZW4gdGhlbSBhbmQgYWRkIGl0IHRvIHRoZSBwcmV2aW91cyByYW5rICopXG4gICAgICAgICAgbGV0IGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IEV4Y2wgb2xkX2tleSwgRXhjbCBuZXdfa2V5IGluXG4gICAgICAgICAgbGV0IHN1YnJhbmdlID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIGluXG4gICAgICAgICAgb2xkX3JhbmsgKyBNYXAubGVuZ3RoIHN1YnJhbmdlICsgMSlcbiAgICAgIGluXG4gICAgICBsZXQgd2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5IH5vbGRfcmFuayA9XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgKCogV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgZGF0YSwgc28gb3B0aW1pemUgdGhlc2UgY2hlY2tzICopXG4gICAgICAgICAgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSlcbiAgICAgICAgICBvbGRfbWFwXG4gICAgICAgICAgbmV3X21hcFxuICAgICAgICAgIH5pbml0Om9sZF9yYW5rXG4gICAgICAgICAgfmY6KGZ1biBhY2MgKGRpZmZfa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICB8IGBMZWZ0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyAtIDFcbiAgICAgICAgICAgIHwgYFJpZ2h0IF8gd2hlbiBjb21wYXJlX2tleSBkaWZmX2tleSBrZXkgPCAwIC0+IGFjYyArIDFcbiAgICAgICAgICAgIHwgXyAtPiBhY2MpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBwcm9jZXNzIH4ob2xkIDogKChrLCB2LCBfKSBNYXAudCAqIF8gKiBfKSBvcHRpb24pIG5ld19tYXAgKG5ld19rZXkgOiBrKSA9XG4gICAgICAgIGlmIG5vdCAoTWFwLm1lbSBuZXdfbWFwIG5ld19rZXkpXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICAgICgqIElmIHRoZSBtYXAgYW5kIGtleSBhcmUgdGhlIHNhbWUsIGp1c3QgcmV1c2UgdGhlIG9sZCByYW5rICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBvbGRfcmFuaylcbiAgICAgICAgICAgIHdoZW4gcGh5c19lcXVhbCBuZXdfbWFwIG9sZF9tYXAgJiYgc2FtZV9rZXkgb2xkX2tleSBuZXdfa2V5IC0+IG9sZF9yYW5rXG4gICAgICAgICAgKCogSWYgdGhlIG1hcCBpcyB0aGUgc2FtZSBidXQgdGhlIGtleSBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHBoeXNfZXF1YWwgbmV3X21hcCBvbGRfbWFwIC0+XG4gICAgICAgICAgICBTb21lICh3aGVuX2tleV9jaGFuZ2VkIH5tYXA6bmV3X21hcCB+b2xkX2tleSB+bmV3X2tleSB+b2xkX3JhbmspXG4gICAgICAgICAgKCogSWYgdGhlIGtleSBpcyB0aGUgc2FtZSBidXQgdGhlIG1hcCBjaGFuZ2VkICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSB3aGVuIHNhbWVfa2V5IG5ld19rZXkgb2xkX2tleSAtPlxuICAgICAgICAgICAgU29tZSAod2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5Om5ld19rZXkgfm9sZF9yYW5rKVxuICAgICAgICAgICgqIElmIGJvdGggdGhlIG1hcCBhbmQgdGhlIGtleSBjaGFuZ2VkLCB0aGlzIGNhbiBiZSBzaW11bGF0ZWQgYXMgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5naW5nIGZvbGxvd2VkIGJ5IHRoZSBrZXkgY2hhbmdpbmcgKilcbiAgICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspIC0+XG4gICAgICAgICAgICAoKiBXZSBjYWxsIFtwcm9jZXNzXSByZWN1cnNpdmVseSBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmdcbiAgICAgICAgICAgICAgIFt3aGVuX21hcF9jaGFuZ2VkXSBmb2xsb3dlZCBieSBbd2hlbl9rZXlfY2hhbmdlZF0gc2luY2UgaXQgbWlnaHQgYmUgdGhlXG4gICAgICAgICAgICAgICBjYXNlIHRoYXQgW29sZF9rZXldIGlzIGluIFtvbGRfbWFwXSBhbmQgW25ld19rZXldIGlzIGluIFtuZXdfbWFwXSwgYnV0XG4gICAgICAgICAgICAgICBbb2xkX2tleV0gaXMgbm90IGluIFtuZXdfbWFwXS4gKilcbiAgICAgICAgICAgIGxldCBvbGRfcmFuayA9XG4gICAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykpIG5ld19tYXAgb2xkX2tleVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHByb2Nlc3Mgfm9sZDooU29tZSAobmV3X21hcCwgb2xkX2tleSwgb2xkX3JhbmspKSBuZXdfbWFwIG5ld19rZXlcbiAgICAgICAgICAoKiBJZiB0aGUgcHJldmlvdXMga2V5IHdhcyBub3QgaW4gdGhlIG1hcCBvciB0aGlzIGlzIHRoZSBmaXJzdCBzdGFiaWxpemF0aW9uLFxuICAgICAgICAgICAgIGNvbXB1dGUgdGhlIHJhbmsgZnJvbSBzY3JhdGNoICopXG4gICAgICAgICAgfCBTb21lIChfLCBfLCBOb25lKSB8IE5vbmUgLT4gTWFwLnJhbmsgbmV3X21hcCBuZXdfa2V5KVxuICAgICAgaW5cbiAgICAgIHdpdGhfb2xkMiBtYXAga2V5IH5mOnByb2Nlc3MpXG4gIDs7XG5cbiAgKCoqIFJhbmdlIG1hcCBieSBpbmRpY2VzICopXG4gIGxldCBzdWJyYW5nZV9ieV9yYW5rXG4gICAgICAgICh0eXBlIGsgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcCA6ICgoaywgXywgXykgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIChyYW5nZSA6IChpbnQgTWF5YmVfYm91bmQudCAqIGludCBNYXliZV9ib3VuZC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgID1cbiAgICBsZXQgZmluZF9rZXlfcmFuZ2UgKHJhbmdlIDogKGludCAqIGludCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgIDogKChrICogayBvcHRpb24pIG9wdGlvbiwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgPVxuICAgICAgd2l0aF9vbGQyIG1hcCByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIChmcm9tLCB0b18pIC0+XG4gICAgICAgICgqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBubyBrZXlzLCBvbmx5IGJlZ2luIGtleSwgb3IgYmVnaW4gYW5kIGVuZCBrZXlzLlxuICAgICAgICAgICBUaGVzZSBhcmUgdGhlIGtleXMgYXQgW2Zyb21dIGFuZCBbdG9fXSBwb3NpdGlvbnMgaW4gdGhlIG1hcCwgb3IgTm9uZSBpZiB0aGVcbiAgICAgICAgICAgaW5kaWNlcyBhcmUgdG9vIGJpZy4gQXMgYWx3YXlzIFswIDw9IGZyb20gJiYgZnJvbSA8PSB0b19dLCB0aGVyZSBpcyBub1xuICAgICAgICAgICBwb3NzaWJpbGl0eSBvZiBvbmx5IFt0b19dIGJlaW5nIGEgdmFsaWQgcG9zaXRpb24uXG4gICAgICAgICopXG4gICAgICAgIGlmIEludC4oIDwgKSB0b18gZnJvbSB8fCBJbnQuKCA8ICkgZnJvbSAwXG4gICAgICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJJbnZhbGlkIGluZGljZXNcIiAoZnJvbSA6IGludCkgKHRvXyA6IGludCldO1xuICAgICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIChvbGRfZnJvbSwgb2xkX3RvKSwgU29tZSAoYmVnaW5fa2V5LCBlbmRfa2V5X29wdCkpIC0+XG4gICAgICAgICAgbGV0IGZpbmRfb2Zmc2V0ID0gZmluZF9vZmZzZXQgfmNvbXBhcmU6KE1hcC5jb21wYXJhdG9yIG1hcCkuY29tcGFyZSBpblxuICAgICAgICAgIGxldCByYW5nZV9vZmZzZXRfYmVnaW4gPSBmcm9tIC0gb2xkX2Zyb20gaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2VuZCA9IHRvXyAtIG9sZF90byBpblxuICAgICAgICAgIGxldCBhZGp1c3RfYW5kX29mZnNldCB+Ynkga2V5ID1cbiAgICAgICAgICAgIGxldCBieSA9IGJ5ICsgaWYgYnkgPj0gMCAmJiBub3QgKE1hcC5tZW0gbWFwIGtleSkgdGhlbiAxIGVsc2UgMCBpblxuICAgICAgICAgICAgb2Zmc2V0IGtleSBtYXAgfmJ5XG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGtleXMgY2hhbmdpbmcgYW5kIG5vdCB0aGUgZGF0YSwgc28gW2RhdGFfZXF1YWxdIGhlcmVcbiAgICAgICAgICAgICBjYW4gYmUgYWx3YXlzIHRydWUgKilcbiAgICAgICAgICBsZXQgZGlmZiB+aW5pdCB+ZiA9XG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZiB+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiB0cnVlKSBvbGRfbWFwIG1hcCB+aW5pdCB+ZlxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IGJlZ2luX2tleV9vcHQsIGVuZF9rZXlfb3B0ID1cbiAgICAgICAgICAgIG1hdGNoIGVuZF9rZXlfb3B0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBlbmRfa2V5IC0+XG4gICAgICAgICAgICAgIGxldCBtYXBfb2Zmc2V0X2JlZ2luLCBtYXBfb2Zmc2V0X2VuZCA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDooMCwgMCkgfmY6KGZ1biAob2Zmc2V0X2JlZ2luLCBvZmZzZXRfZW5kKSAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICAoIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAsIG9mZnNldF9lbmQgKyBmaW5kX29mZnNldCB+a2V5OmVuZF9rZXkgfmNoYW5nZWRfa2V5OmtleSBjaGFuZ2UgKSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIGFkanVzdF9hbmRfb2Zmc2V0IGVuZF9rZXkgfmJ5OihtYXBfb2Zmc2V0X2VuZCArIHJhbmdlX29mZnNldF9lbmQpIClcbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiA9XG4gICAgICAgICAgICAgICAgZGlmZiB+aW5pdDowIH5mOihmdW4gb2Zmc2V0X2JlZ2luIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgICAgIG9mZnNldF9iZWdpbiArIGZpbmRfb2Zmc2V0IH5rZXk6YmVnaW5fa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAoIGFkanVzdF9hbmRfb2Zmc2V0IGJlZ2luX2tleSB+Ynk6KG1hcF9vZmZzZXRfYmVnaW4gKyByYW5nZV9vZmZzZXRfYmVnaW4pXG4gICAgICAgICAgICAgICwgbnRoX2Zyb21fZWl0aGVyX3NpZGUgdG9fIG1hcCApXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhc3NlcnQgKE9wdGlvbi5mb3JfYWxsIH5mOihNYXAubWVtIG1hcCkgYmVnaW5fa2V5X29wdCk7XG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGVuZF9rZXlfb3B0KTtcbiAgICAgICAgICBPcHRpb24ubWFwIGJlZ2luX2tleV9vcHQgfmY6KGZ1biBiZWdpbl9rZXkgLT4gYmVnaW5fa2V5LCBlbmRfa2V5X29wdClcbiAgICAgICAgfCBOb25lIHwgU29tZSAoXywgXywgTm9uZSkgLT5cbiAgICAgICAgICAoKiBPbiBmaXJzdCBydW4gKHdoZW4gd2UgaGF2ZSB0bykgb3Igd2hlbiBib3RoIHRoZSBrZXlzIGFyZSBub25lLCBydW4gTyhuKVxuICAgICAgICAgICAgIHNjYW4uIFRoaXMgaXMgZmluZSBmb3Iga2V5cy1hcmUtbm9uZSBjYXNlIGFzIGl0IGhhcHBlbnMgd2hlbiB0aGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgYXJlIHBhc3QgZW5kIG9mIHRoZSBtYXAsIHNvIHRoZXkgc2hvdWxkbid0IGJlIHRvbyBmYXIgZnJvbSBlbmQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgbWFwIGNoYW5nZXMsIGFuZCBbZmluZF9rZXlfcmFuZ2VfbGluZWFyXSBpcyBmYXN0IGluIHN1Y2ggY2FzZS4gKilcbiAgICAgICAgICBmaW5kX2tleV9yYW5nZV9saW5lYXIgbWFwIH5mcm9tIH50b18pXG4gICAgaW5cbiAgICAoKiBIYW5kbGUgZGlmZmVyZW50IE1heWJlX2JvdW5kIGNhc2VzIGFuZCBjYWxsIGZpbmRfa2V5X3JhbmdlIGlmIG5lY2Vzc2FyeS4gSXQnc1xuICAgICAgIG5pY2VyIHRvIGRvIHRoaXMgaGVyZSBhcyBvcHBvc2VkIHRvIG1ha2luZyBmaW5kX2tleV9yYW5nZSBldmVuIG1vcmUgY29tcGxpY2F0ZWQgKilcbiAgICBsZXQgb3BlbiBJbmNyZW1lbnRhbC5MZXRfc3ludGF4IGluXG4gICAgbGV0ICggPj4+ICkgbmV3XyBib3VuZCA9IE1heWJlX2JvdW5kLm1hcCB+ZjooZnVuIF8gLT4gbmV3XykgYm91bmQgaW5cbiAgICBsZXQgcmV0dXJuID0gSW5jcmVtZW50YWwucmV0dXJuIChJbmNyZW1lbnRhbC5zdGF0ZSBtYXApIGluXG4gICAgbGV0IGtleV9yYW5nZSA9XG4gICAgICBtYXRjaCVwYXR0ZXJuX2JpbmQgcmFuZ2Ugd2l0aFxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCAtPlxuICAgICAgICByZXR1cm4gKFNvbWUgKE1heWJlX2JvdW5kLlVuYm91bmRlZCwgTWF5YmVfYm91bmQuVW5ib3VuZGVkKSlcbiAgICAgIHwgKCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpXG4gICAgICAgICwgKChNYXliZV9ib3VuZC5JbmNsIHUgfCBNYXliZV9ib3VuZC5FeGNsIHUpIGFzIHViKSApIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCB1KVxuICAgICAgICBhbmQgbGIgPSBsYlxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBTb21lIGVuZF9rZXkpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIGVuZF9rZXkgPj4+IHViKVxuICAgICAgICAgfCBTb21lIChiZWdpbl9rZXksIE5vbmUpIC0+IFNvbWUgKGJlZ2luX2tleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCAoKE1heWJlX2JvdW5kLkluY2wgbCB8IE1heWJlX2JvdW5kLkV4Y2wgbCkgYXMgbGIpLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCBsIGwpXG4gICAgICAgIGFuZCBsYiA9IGxiIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKGtleSA+Pj4gbGIsIFVuYm91bmRlZClcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBNYXliZV9ib3VuZC5VbmJvdW5kZWQsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgLT5cbiAgICAgICAgbGV0JW1hcCBrZXlfcmFuZ2UgPSBmaW5kX2tleV9yYW5nZSAoSW5jcmVtZW50YWwuYm90aCB1IHUpXG4gICAgICAgIGFuZCB1YiA9IHViIGluXG4gICAgICAgIChtYXRjaCBrZXlfcmFuZ2Ugd2l0aFxuICAgICAgICAgfCBTb21lIChrZXksIF8pIC0+IFNvbWUgKFVuYm91bmRlZCwga2V5ID4+PiB1YilcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIGluXG4gICAgc3VicmFuZ2UgP2RhdGFfZXF1YWwgbWFwIGtleV9yYW5nZVxuICA7O1xuXG4gIGxldCB0cmFuc3Bvc2VcbiAgICA6IHR5cGUgazEgazIgdiBrMV9jbXAgazJfY21wIHN0YXRlX3dpdG5lc3MuXG4gICAgICA/ZGF0YV9lcXVhbDoodiAtPiB2IC0+IGJvb2wpXG4gICAgICAtPiAoazIsIGsyX2NtcCkgTWFwLmNvbXBhcmF0b3JcbiAgICAgIC0+ICgoazEsIChrMiwgdiwgazJfY21wKSBNYXAudCwgazFfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgLT4gKChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGZ1biA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKSBrMl9jb21wYXJhdG9yIG0gLT5cbiAgICAgIHdpdGhfY29tcGFyYXRvciBtIChmdW4gazFfY29tcGFyYXRvciAtPlxuICAgICAgICBsZXQgdXBkYXRlXG4gICAgICAgICAgOiAga2V5OmsxIC0+IG9sZF9kYXRhOihrMiwgdiwgazJfY21wKSBNYXAudCAtPiBuZXdfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnRcbiAgICAgICAgICAgIC0+IChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50XG4gICAgICAgICAgICAtPiAoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudFxuICAgICAgICAgID1cbiAgICAgICAgICBmdW4gfmtleTprMSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgb2xkX2RhdGFcbiAgICAgICAgICAgICAgbmV3X2RhdGFcbiAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIChrMiwgZGlmZikgLT5cbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIE1hcC5jaGFuZ2UgYWNjIGsyIH5mOihmdW4gYWNjX2lubmVyIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgYWNjX2lubmVyID1cbiAgICAgICAgICAgICAgICAgICAgTWFwLmNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgIChPcHRpb24udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY2NfaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICB+ZGVmYXVsdDooTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6azFfY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgICAgICAgazFcbiAgICAgICAgICAgICAgICAgICAgICB+ZjooZnVuIF8gLT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGFjY19pbm5lciB0aGVuIE5vbmUgZWxzZSBTb21lIGFjY19pbm5lcikpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBhZGQgfmtleSB+ZGF0YSA9XG4gICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcikgfm5ld19kYXRhOmRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhID1cbiAgICAgICAgICB1cGRhdGUgfmtleSB+b2xkX2RhdGE6ZGF0YSB+bmV3X2RhdGE6KE1hcC5lbXB0eSBrMl9jb21wYXJhdG9yKVxuICAgICAgICBpblxuICAgICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICAgIG1cbiAgICAgICAgICB+aW5pdDooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpXG4gICAgICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgICAgIH51cGRhdGVcbiAgICAgICAgICB+YWRkXG4gICAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgY29sbGFwc2VfYnlcbiAgICAgICAgKHR5cGUgb3V0ZXJfa2V5IG91dGVyX2NtcCBpbm5lcl9rZXkgaW5uZXJfY21wIGNvbWJpbmVkX2tleSBjb21iaW5lZF9jbXApXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KG1lcmdlX2tleXMgOiBvdXRlcl9rZXkgLT4gaW5uZXJfa2V5IC0+IGNvbWJpbmVkX2tleSlcbiAgICAgICAgfihjb21wYXJhdG9yIDogKGNvbWJpbmVkX2tleSwgY29tYmluZWRfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBjb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfnVwZGF0ZTooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGE6XyB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIE1hcC5zZXQgYWNjIH5rZXk6KG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkgfmRhdGE6bmV3X2RhdGEpXG4gICAgICB+YWRkOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAuYWRkX2V4biBhY2MgfmtleToobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSB+ZGF0YSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLnJlbW92ZSBhY2MgKG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkpXG4gIDs7XG5cbiAgbGV0IGNvbGxhcHNlXG4gICAgICAgICh0eXBlIG91dGVyX2tleSBvdXRlcl9jbXAgaW5uZXJfa2V5IGlubmVyX2NtcClcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcF9pbmNyIDpcbiAgICAgICAgICAgKChvdXRlcl9rZXksIChpbm5lcl9rZXksIF8sIGlubmVyX2NtcCkgTWFwLnQsIG91dGVyX2NtcCkgTWFwLnQsIF8pIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH5jb21wYXJhdG9yOihpbm5lcl9jb21wYXJhdG9yIDogKGlubmVyX2tleSwgaW5uZXJfY21wKSBNYXAuY29tcGFyYXRvcilcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gb3V0ZXJfY29tcGFyYXRvciAtPlxuICAgICAgbGV0IG1vZHVsZSBDbXAgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gb3V0ZXJfa2V5ICogaW5uZXJfa2V5XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gKG91dGVyX2NtcCwgaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPVxuICAgICAgICAgIGxldCBpbm5lcl9jb21wYXJhdG9yID1cbiAgICAgICAgICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgaW5uZXJfY29tcGFyYXRvcikgaW5cbiAgICAgICAgICAgIE0uY29tcGFyYXRvclxuICAgICAgICAgIGluXG4gICAgICAgICAgVHVwbGUyLmNvbXBhcmF0b3Igb3V0ZXJfY29tcGFyYXRvciBpbm5lcl9jb21wYXJhdG9yXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICBjb2xsYXBzZV9ieVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+bWVyZ2Vfa2V5czpUdXBsZTIuY3JlYXRlXG4gICAgICAgIH5jb21wYXJhdG9yOihtb2R1bGUgQ21wKSlcbiAgOztcblxuICBsZXQgZXhwYW5kID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+dXBkYXRlOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5vbGRfZGF0YTpfIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBNYXAuc2luZ2xldG9uIGlubmVyX2NvbXBhcmF0b3IgaW5uZXJfa2V5IG5ld19kYXRhXG4gICAgICAgICAgfCBTb21lIG1hcCAtPiBNYXAuc2V0IG1hcCB+a2V5OmlubmVyX2tleSB+ZGF0YTpuZXdfZGF0YSkpXG4gICAgICB+YWRkOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAudXBkYXRlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE1hcC5zaW5nbGV0b24gaW5uZXJfY29tcGFyYXRvciBpbm5lcl9rZXkgZGF0YVxuICAgICAgICAgIHwgU29tZSBtYXAgLT4gTWFwLmFkZF9leG4gbWFwIH5rZXk6aW5uZXJfa2V5IH5kYXRhKSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLmNoYW5nZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIG1hcCAtPlxuICAgICAgICAgICAgbGV0IG1hcCA9IE1hcC5yZW1vdmUgbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgT3B0aW9uLnNvbWVfaWYgKG5vdCAoTWFwLmlzX2VtcHR5IG1hcCkpIG1hcCkpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6MFxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBjb3VudCAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBjb3VudCAtIDEgZWxzZSBjb3VudClcbiAgOztcblxuICBsZXQgY291bnQgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mKSB+ZjooZnVuIGNvdW50IC0+IGNvdW50IDw+IDApXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgZXhpc3RzaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHN1bVxuICAgICAgICAodHlwZSB1KVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAobWFwX2luY3IgOiAoKF8sIF8sIF8pIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICAobW9kdWxlIEdyb3VwIDogQWJzdHJhY3RfYWxnZWJyYS5Db21tdXRhdGl2ZV9ncm91cC5XaXRob3V0X3NleHAgd2l0aCB0eXBlIHQgPSB1KVxuICAgICAgICB+ZlxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDpHcm91cC56ZXJvXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleTpfIH5kYXRhOnYgYWNjIC0+IEdyb3VwLiggKyApIGFjYyAoZiB2KSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5Ol8gfmRhdGE6diBhY2MgLT4gR3JvdXAuKCAtICkgYWNjIChmIHYpKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICAoY291bnRpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxuICAgICAgfmY6KGZ1biBjb3VudCAtPiBjb3VudCA9IDApXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGZvcl9hbGxpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyID0gZmluZF9rZXlfcmFuZ2VfbGluZWFyXG4gIGVuZFxuXG4gIG1vZHVsZSBMb29rdXAgPSBzdHJ1Y3RcbiAgICB0eXBlICgndiwgJ3cpIGVudHJ5ID1cbiAgICAgIHsgbXV0YWJsZSBzYXZlZF92YWx1ZSA6ICd2IG9wdGlvblxuICAgICAgOyBub2RlIDogKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLnRcbiAgICAgIH1cblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIHNhdmVkX21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICAoKiBXZSBtYXkgaGF2ZSBtdWx0aXBsZSBlbnRyaWVzIHBlciBrZXkgaWYgbm9kZXMgYmVjb21lIG5lY2Vzc2FyeSBhZ2FpbiBhZnRlciBiZWluZ1xuICAgICAgICAgcmVtb3ZlZC4gKilcbiAgICAgIDsgbXV0YWJsZSBsb29rdXBfZW50cmllcyA6ICgnaywgKCd2LCAndykgZW50cnkgbGlzdCwgJ2NtcCkgTWFwLnRcbiAgICAgIDsgdXBkYXRlcl9ub2RlIDogKHVuaXQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICA7IHNjb3BlIDogJ3cgSW5jcmVtZW50YWwuU2NvcGUudFxuICAgICAgfVxuXG4gICAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgICAgdHlwZSB0XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICBlbmQpID1cbiAgICBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgndiwgJ3cpIHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MsICd3KSB0XG4gICAgZW5kXG5cbiAgICBsZXQgY3JlYXRlID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpIGlucHV0X21hcCB+Y29tcGFyYXRvciA9XG4gICAgICBsZXQgcmVjIHNlbGYgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKGxldCB1cGRhdGVyX25vZGUgPVxuICAgICAgICAgICAgIEluY3JlbWVudGFsLm1hcCBpbnB1dF9tYXAgfmY6KGZ1biBpbnB1dF9tYXAgLT5cbiAgICAgICAgICAgICAgIGxldCAobGF6eSBzZWxmKSA9IHNlbGYgaW5cbiAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgIHNlbGYuc2F2ZWRfbWFwXG4gICAgICAgICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICB+aW5pdDooKVxuICAgICAgICAgICAgICAgICB+ZjooZnVuICgpIChrZXksIGNoYW5nZWRfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBNYXAuZmluZF9tdWx0aSBzZWxmLmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIExpc3QuaXRlciBlbnRyaWVzIH5mOihmdW4gZW50cnkgLT5cbiAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgICA8LSAobWF0Y2ggY2hhbmdlZF92YWx1ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld192YWx1ZSB8IGBVbmVxdWFsIChfLCBuZXdfdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgU29tZSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBlbnRyeS5ub2RlKSk7XG4gICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcCA8LSBpbnB1dF9tYXApXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgICAgICAgICB7IHNhdmVkX21hcCA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IGxvb2t1cF9lbnRyaWVzID0gZW1wdHlfbWFwXG4gICAgICAgICAgIDsgdXBkYXRlcl9ub2RlXG4gICAgICAgICAgIDsgc2NvcGUgPSBJbmNyZW1lbnRhbC5TY29wZS5jdXJyZW50IChJbmNyZW1lbnRhbC5zdGF0ZSBpbnB1dF9tYXApICgpXG4gICAgICAgICAgIH0pXG4gICAgICBpblxuICAgICAgTGF6eS5mb3JjZSBzZWxmXG4gICAgOztcblxuICAgIGxldFtAY29sZF0gc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5IH5pc19ub3dfb2JzZXJ2YWJsZSA9XG4gICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgIGxldCBjdXJyZW50X2VudHJpZXMgPSBNYXAuZmluZF9tdWx0aSB0Lmxvb2t1cF9lbnRyaWVzIGtleSBpblxuICAgICAgbGV0IGlzX2xpbmtlZCA9IExpc3QuZXhpc3RzIGN1cnJlbnRfZW50cmllcyB+ZjoocGh5c19lcXVhbCBlbnRyeSkgaW5cbiAgICAgIGlmIEJvb2wuZXF1YWwgaXNfbGlua2VkIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGlzX25vd19vYnNlcnZhYmxlXG4gICAgICB0aGVuXG4gICAgICAgIHQubG9va3VwX2VudHJpZXNcbiAgICAgICAgPC0gTWFwLnVwZGF0ZSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgKG90aGVyX2VudHJ5IDo6IF8gYXMgb3RoZXJfZW50cmllcykgLT5cbiAgICAgICAgICAgICgqIFVwZGF0ZSB0aGlzIGVudHJ5J3MgdmFsdWUgdG8gYmUgY3VycmVudC4gKilcbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIG90aGVyX2VudHJ5LnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgZW50cnkgOjogb3RoZXJfZW50cmllc1xuICAgICAgICAgIHwgTm9uZSB8IFNvbWUgW10gLT5cbiAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleTtcbiAgICAgICAgICAgIFsgZW50cnkgXSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV3X2VudHJpZXMgPVxuICAgICAgICAgIExpc3QuZmlsdGVyIGN1cnJlbnRfZW50cmllcyB+ZjooZnVuIHggLT4gbm90IChwaHlzX2VxdWFsIGVudHJ5IHgpKVxuICAgICAgICBpblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgIDwtIChpZiBMaXN0LmlzX2VtcHR5IG5ld19lbnRyaWVzXG4gICAgICAgICAgICB0aGVuIE1hcC5yZW1vdmUgdC5sb29rdXBfZW50cmllcyBrZXlcbiAgICAgICAgICAgIGVsc2UgTWFwLnNldCB0Lmxvb2t1cF9lbnRyaWVzIH5rZXkgfmRhdGE6bmV3X2VudHJpZXMpKVxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleSA9XG4gICAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSB0LnVwZGF0ZXJfbm9kZSBpblxuICAgICAgSW5jcmVtZW50YWwuU2NvcGUud2l0aGluIGluY3JlbWVudGFsX3N0YXRlIHQuc2NvcGUgfmY6KGZ1biAoKSAtPlxuICAgICAgICBsZXQgcmVjIGVudHJ5ID1cbiAgICAgICAgICBsYXp5XG4gICAgICAgICAgICB7IHNhdmVkX3ZhbHVlID0gTWFwLmZpbmQgdC5zYXZlZF9tYXAga2V5XG4gICAgICAgICAgICA7IG5vZGUgPVxuICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgaW5jcmVtZW50YWxfc3RhdGVcbiAgICAgICAgICAgICAgICAgIChmdW4gKCkgLT4gKGZvcmNlIGVudHJ5KS5zYXZlZF92YWx1ZSlcbiAgICAgICAgICAgICAgICAgIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZTooc2xvd19wYXRoX2xpbmtfZW50cnkgdCBlbnRyeSB+a2V5KVxuICAgICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICBsZXQgKGxhenkgZW50cnkpID0gZW50cnkgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgICBlbnRyeS5ub2RlXG4gICAgICAgICAgKEluY3JlbWVudGFsLkV4cGVydC5EZXBlbmRlbmN5LmNyZWF0ZSB0LnVwZGF0ZXJfbm9kZSk7XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIGVudHJ5Lm5vZGUpXG4gICAgOztcblxuICAgIGxldCBmaW5kIHQga2V5ID1cbiAgICAgIG1hdGNoIE1hcC5maW5kX211bHRpIHQubG9va3VwX2VudHJpZXMga2V5IHdpdGhcbiAgICAgIHwgZW50cnkgOjogXyAtPiBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBlbnRyeS5ub2RlXG4gICAgICB8IFtdIC0+IHNsb3dfcGF0aF9jcmVhdGVfbm9kZSB0IGtleVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnID0gc3RydWN0XG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfZW50cnkgc2V4cF9vZl92YWx1ZSBlbnRyeSA9XG4gICAgICAgIGxldCB7IHNhdmVkX3ZhbHVlOyBub2RlIH0gPSBlbnRyeSBpblxuICAgICAgICBsZXQgbm9kZSA9IEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG5vZGUgaW5cbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgeyBzYXZlZF92YWx1ZSA6IHZhbHVlIG9wdGlvblxuICAgICAgICAgIDsgbm9kZV9pbmZvID0gKEluY3JlbWVudGFsLnVzZXJfaW5mbyBub2RlIDogKEluZm8udCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2NvbnN0ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChJbmNyZW1lbnRhbC5pc19jb25zdCBub2RlKSAoKSA6ICh1bml0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICA7IG5vZGVfaXNfaW52YWxpZCA9XG4gICAgICAgICAgICAgIChPcHRpb24uc29tZV9pZiAobm90IChJbmNyZW1lbnRhbC5pc192YWxpZCBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX3VubmVjZXNzYXJ5ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChub3QgKEluY3JlbWVudGFsLmlzX25lY2Vzc2FyeSBub2RlKSkgKCkgOiAodW5pdCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgIH1dXG4gICAgICA7O1xuXG4gICAgICBsZXRbQGNvbGRdIHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgICAgICBsZXQgaW5mb19wZXJfa2V5ID1cbiAgICAgICAgICBNYXAubWVyZ2UgdC5zYXZlZF9tYXAgdC5sb29rdXBfZW50cmllcyB+ZjooZnVuIH5rZXkgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IGFjdHVhbF92YWx1ZSwgZW50cmllcyA9XG4gICAgICAgICAgICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgICAgICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSB4LCBbXVxuICAgICAgICAgICAgICB8IGBSaWdodCB5IC0+IE5vbmUsIHlcbiAgICAgICAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gU29tZSB4LCB5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICBbJXNleHBcbiAgICAgICAgICAgICAgICB7IGtleSA6IGtleVxuICAgICAgICAgICAgICAgIDsgYWN0dWFsX3ZhbHVlIDogKHZhbHVlIG9wdGlvbltAc2V4cC5vcHRpb25dKVxuICAgICAgICAgICAgICAgIDsgZW50cmllcyA6IHZhbHVlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB9XSlcbiAgICAgICAgaW5cbiAgICAgICAgU2V4cC5MaXN0IChNYXAuZGF0YSBpbmZvX3Blcl9rZXkpXG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgc3RhdGVfd2l0bmVzc1xuXG4gIGluY2x1ZGVcbiAgICBTX2dlblxuICAgIHdpdGggdHlwZSAnYSBJbmNyLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgYW5kIHR5cGUgJ2EgSW5jci5DdXRvZmYudCA9ICdhIEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgIGFuZCB0eXBlICgnaywgJ3YsICdjbXApIExvb2t1cC50ID0gKCdrLCAndiwgJ2NtcCwgc3RhdGVfd2l0bmVzcykgR2VuZXJpYy5Mb29rdXAudFxuZW5kXG5cbm1vZHVsZSBNYWtlIChJbmNyIDogSW5jcmVtZW50YWwuUykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IGZsYXR0ZW4geCA9IGZsYXR0ZW4gSW5jci5TdGF0ZS50IHhcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgaW5jbHVkZSBMb29rdXBcblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXAsIEluY3Iuc3RhdGVfd2l0bmVzcykgTG9va3VwLnRcblxuICAgIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICAgIHR5cGUgdFxuICAgICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgZW5kKSA6IHNpZ1xuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEdlbmVyaWNcbiJdfQ==
