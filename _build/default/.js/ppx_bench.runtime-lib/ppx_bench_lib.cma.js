// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_ml=caml_string_of_jsbytes(".ml."),
     cst=caml_string_of_jsbytes("."),
     null$0=caml_string_of_jsbytes("<unknown>"),
     cst_BENCHMARKS_RUNNER=caml_string_of_jsbytes("BENCHMARKS_RUNNER"),
     cst$0=caml_string_of_jsbytes(""),
     cst_TRUE=caml_string_of_jsbytes("TRUE"),
     cst_FORCE_DROP_BENCH=caml_string_of_jsbytes("FORCE_DROP_BENCH"),
     Stdlib_Hashtbl=global_data.Stdlib__Hashtbl,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib=global_data.Stdlib,
     Stdlib_String=global_data.Stdlib__String,
     Ppx_bench_lib=[0];
    caml_register_global(7,Ppx_bench_lib,"Ppx_bench_lib");
    var Ppx_bench_lib_Export=[0];
    caml_register_global(8,Ppx_bench_lib_Export,"Ppx_bench_lib__Export");
    var r=[0,0],libname_ref=[0,null$0];
    function set(str){libname_ref[1] = str;return 0}
    function unset(param){libname_ref[1] = null$0;return 0}
    var t=[0,0];
    function push(s){t[1] = [0,s,t[1]];return 0}
    function pop_exn(param){t[1] = caml_call1(Stdlib_List[6],t[1]);return 0}
    function compare(t1,t2){return runtime.caml_int_compare(t1[1],t2[1])}
    function get_module_name_opt(t)
     {var str=t[3],len=runtime.caml_ml_string_length(str),i=0;
      for(;;)
       {if((i + 4 | 0) > len)return 0;
        if(caml_string_equal(caml_call3(Stdlib_String[15],str,i,4),cst_ml))
         return [0,
                 caml_call3
                  (Stdlib_String[15],str,i + 4 | 0,(len - i | 0) - 4 | 0)];
        var i$0=i + 1 | 0,i=i$0}}
    function with_test_spec(t,test_spec)
     {return [0,t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],test_spec,t[10]]}
    try
     {var _b_=caml_sys_getenv(cst_BENCHMARKS_RUNNER),v=_b_}
    catch(_r_)
     {_r_ = caml_wrap_exception(_r_);
      if(_r_ !== Stdlib[8])throw _r_;
      var v=cst$0}
    var
     add_environment_var=caml_string_equal(v,cst_TRUE),
     libs_to_entries=caml_call2(Stdlib_Hashtbl[1],0,10);
    function lookup_rev_lib(libname)
     {try
       {var _p_=caml_call2(Stdlib_Hashtbl[6],libs_to_entries,libname);
        return _p_}
      catch(_q_)
       {_q_ = caml_wrap_exception(_q_);
        if(_q_ === Stdlib[8])return 0;
        throw _q_}}
    function lookup_lib(libname)
     {var _o_=lookup_rev_lib(libname);return caml_call1(Stdlib_List[9],_o_)}
    try
     {caml_sys_getenv(cst_FORCE_DROP_BENCH);var _a_=1,force_drop=_a_}
    catch(_n_)
     {_n_ = caml_wrap_exception(_n_);
      if(_n_ !== Stdlib[8])throw _n_;
      var force_drop=0}
    function get_mode(param){return force_drop?-950194894:984731018}
    function add_bench
     (name,code,filename,type_conv_path,line,startpos,endpos,test_spec)
     {var match=get_mode(0);
      if(984731018 > match)return 0;
      var _i_=libname_ref[1],_j_=t[1];
      if(_j_)
       var
        _k_=caml_call1(Stdlib_List[9],_j_),
        _l_=[0,caml_call2(Stdlib_String[6],cst,_k_)];
      else
       var _l_=0;
      r[1]++;
      var
       entry=
        [0,
         r[1],
         code,
         type_conv_path,
         name,
         filename,
         line,
         startpos,
         endpos,
         test_spec,
         _l_],
       _m_=[0,entry,lookup_rev_lib(_i_)];
      return caml_call3(Stdlib_Hashtbl[5],libs_to_entries,_i_,_m_)}
    function add_bench_module(name,param,_g_,_f_,_e_,_d_,_c_,f)
     {var match=get_mode(0);
      if(984731018 > match)return 0;
      push(name);
      try
       {caml_call1(f,0);var _h_=pop_exn(0);return _h_}
      catch(ex){ex = caml_wrap_exception(ex);pop_exn(0);throw ex}}
    var
     Ppx_bench_lib_Benchmark_accumu=
      [0,
       [0,set,unset],
       [0,with_test_spec,compare,get_module_name_opt],
       add_environment_var,
       lookup_lib,
       add_bench,
       add_bench_module];
    caml_register_global
     (13,
      Ppx_bench_lib_Benchmark_accumu,
      "Ppx_bench_lib__Benchmark_accumulator");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfYmVuY2hfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJudWxsJDAiLCJyIiwibGlibmFtZV9yZWYiLCJzZXQiLCJzdHIiLCJ1bnNldCIsInQiLCJwdXNoIiwicyIsInBvcF9leG4iLCJjb21wYXJlIiwidDEiLCJ0MiIsImdldF9tb2R1bGVfbmFtZV9vcHQiLCJsZW4iLCJpIiwiaSQwIiwid2l0aF90ZXN0X3NwZWMiLCJ0ZXN0X3NwZWMiLCJ2IiwiYWRkX2Vudmlyb25tZW50X3ZhciIsImxpYnNfdG9fZW50cmllcyIsImxvb2t1cF9yZXZfbGliIiwibGlibmFtZSIsImxvb2t1cF9saWIiLCJmb3JjZV9kcm9wIiwiZ2V0X21vZGUiLCJhZGRfYmVuY2giLCJuYW1lIiwiY29kZSIsImZpbGVuYW1lIiwidHlwZV9jb252X3BhdGgiLCJsaW5lIiwic3RhcnRwb3MiLCJlbmRwb3MiLCJlbnRyeSIsImFkZF9iZW5jaF9tb2R1bGUiLCJmIiwiZXgiXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvcHB4X2JlbmNoL3J1bnRpbWUtbGliL2JlbmNobWFya19hY2N1bXVsYXRvci5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FVTUE7Ozs7Ozs7Ozs7Ozs7SUFUSSwyQkFTSkE7SUFUSSxTQVdKRyxJQUFJQyxLQUFNLGlCQUFOQSxJQUFNLFFBQWtCO0lBWHhCLFNBWUpDLGFBQVcsaUJBSFhMLE9BR1csUUFBbUI7SUFaMUIsSUFpQkpNO0lBakJJLFNBa0JKQyxLQUFLQyxHQUFJLFVBQUpBLEVBRExGLE1BQ1MsUUFBWTtJQWxCakIsU0FtQkpHLGVBQWtCLGlDQUZsQkgsTUFFa0IsUUFBVTtJQW5CeEIsU0FzREpJLFFBQVFDLEdBQUdDLElBQUssZ0NBQVJELE1BQUdDLE1BQXNDO0lBdEQ3QyxTQTBESkMsb0JBQW9CUDtNQUN0QixRQURzQkEsS0FDdEIsa0NBQUlGLEtBRVNXO01BQ1g7WUFEV0EsYUFEVEQsSUFPRztRQUhrQixxQkFBbEIsNkJBTEhWLElBRVNXO1NBSUM7O3FDQU5WWCxJQUVTVyxXQURURCxNQUNTQztRQUtKLFFBTElBLGdCQVFQO0lBckVBLFNBd0VKRSxlQUFlWCxFQUFFWTtNQUFZLFVBQWRaLHdDQUFFWSxVQUFGWixNQUFrQzs7TUFRL0MsK0NBREZhOzs7OztJQUlKOzJDQUpJQTtLQVVtRDthQUVyREcsZUFBZ0JDO007UUFDZCxxQ0FIRkYsZ0JBRWdCRTs7Ozs2QkFFSDtrQkFBRTtJQUpzQyxTQU9yREMsV0FBWUQ7TUFBbUIsUUFML0JELGVBS1lDLFNBQW1CLHFDQUF5Qjs7TUFNaEQsZ0RBSlJFOzs7OzthQVVBQyxnQkFBYyxPQVZkRCwrQkFVc0Q7YUFFdkNFO01BQ0dDLEtBQ0FDLEtBQ0FDLFNBQ0FDLGVBQ0FDLEtBQ0FDLFNBQ0FDLE9BQ0RoQjtNQUViLFVBWkpRO01BWUkscUJBQ087TUFEUCxJQTNHTyxJQUhUeEIsZUFZRixJQUxFSTtNQUtGO09BRWdDOztlQUFuQjs7O01BdEJiO01Bc0hJO09BSUE2Qjs7U0E1SEZsQztTQWdIZ0I0QjtTQUVBRTtTQUhBSDtTQUVBRTtTQUVBRTtTQUNBQztTQUNBQztTQUNEaEI7O09BbUI2QixPQWIxQ2lCLE1BakNKYjtNQThDOEMsb0NBaEQ5Q0Qsd0JBZ0RzRTthQUd2RGUsaUJBQ0dSLCtCQU9EUztNQUViLFVBMUNKWDtNQTBDSSxxQkFDTztNQUdYLEtBYmtCRTs7UUFlZixXQVJjUyxLQVNkLFFBMUlENUIsV0E2SUM7WUFEQTZCLGlDQUNBLGlCQURBQSxHQUVTOzs7O1VBdEpWbkMsSUFDQUU7VUE0REFZLGVBbEJBUCxRQUlBRztPQW9CRk87T0FrQkFJO09BY2VHO09BOEJBUzs7Ozs7VSIsInNvdXJjZXNDb250ZW50IjpbImxldCB1bmlxdWVfaWQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcblxuKCogVXNlZCB0byB0cmFjayB0aGUgY3VycmVudCBsaWJuYW1lIGluIHN1Y2ggYSB3YXkgdGhhdCBmb3IgZnVuY3RvciBhcHBsaWNhdGlvbnMsIGl0IGlzXG4gICB0aGUgY2FsbGluZyBsaWJyYXJpZXMgbmFtZSB0aGF0IGdldHMgcmVnaXN0ZXJlZC4gKilcbm1vZHVsZSBDdXJyZW50X2xpYm5hbWUgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIjx1bmtub3duPlwiXG4gIGxldCBsaWJuYW1lX3JlZiA9IHJlZiBudWxsXG4gIGxldCBzZXQgc3RyID0gbGlibmFtZV9yZWYgOj0gc3RyXG4gIGxldCB1bnNldCAoKSA9IGxpYm5hbWVfcmVmIDo9IG51bGxcbiAgbGV0IGdldCAoKSA9ICFsaWJuYW1lX3JlZlxuZW5kXG5cbm1vZHVsZSBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjayA9IHN0cnVjdFxuICBsZXQgdCA9IHJlZiBbXVxuICBsZXQgcHVzaCBzID0gdCA6PSBzIDo6ICF0XG4gIGxldCBwb3BfZXhuICgpID0gdCA6PSBMaXN0LnRsICF0XG5cbiAgbGV0IHRvX25hbWUgKCkgPVxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IG1zIC0+IFNvbWUgKFN0cmluZy5jb25jYXQgXCIuXCIgKExpc3QucmV2IG1zKSlcbiAgOztcbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBtYWluIGRhdGEgc3RydWN0dXJlIG9mIHRoaXMgbW9kdWxlLiBBbiBbRW50cnkudF0gcmVwcmVzZW50cyBhIGJlbmNobWFya1xuICAgYWxvbmcgd2l0aCBzb21lIG1ldGFkYXRhIGFib3V0IGlzIHBvc2l0aW9uLCBhcmd1bWVudHMgZXRjLiAqKVxubW9kdWxlIEVudHJ5ID0gc3RydWN0XG4gIHR5cGUgKCdwYXJhbSwgJ2EpIHBhcmFtZXRlcmlzZWRfc3BlYyA9XG4gICAgeyBhcmdfbmFtZSA6IHN0cmluZ1xuICAgIDsgcGFyYW1zIDogKHN0cmluZyAqICdwYXJhbSkgbGlzdFxuICAgIDsgdGh1bmsgOiAncGFyYW0gLT4gdW5pdCAtPiAnYVxuICAgIH1cblxuICB0eXBlIHRlc3Rfc3BlYyA9XG4gICAgfCBSZWd1bGFyX3RodW5rIDogKFsgYGluaXQgXSAtPiB1bml0IC0+ICdhKSAtPiB0ZXN0X3NwZWNcbiAgICB8IFBhcmFtZXRlcmlzZWRfdGh1bmsgOiAoJ3BhcmFtLCAnYSkgcGFyYW1ldGVyaXNlZF9zcGVjIC0+IHRlc3Rfc3BlY1xuXG4gIHR5cGUgdCA9XG4gICAgeyB1bmlxdWVfaWQgOiBpbnRcbiAgICA7IGNvZGUgOiBzdHJpbmdcbiAgICA7IHR5cGVfY29udl9wYXRoIDogc3RyaW5nXG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgOyBmaWxlbmFtZSA6IHN0cmluZ1xuICAgIDsgbGluZSA6IGludFxuICAgIDsgc3RhcnRwb3MgOiBpbnRcbiAgICA7IGVuZHBvcyA6IGludFxuICAgIDsgdGVzdF9zcGVjIDogdGVzdF9zcGVjXG4gICAgOyBiZW5jaF9tb2R1bGVfbmFtZSA6IHN0cmluZyBvcHRpb25cbiAgICB9XG5cbiAgbGV0IGNvbXBhcmUgdDEgdDIgPSBjb21wYXJlIHQxLnVuaXF1ZV9pZCB0Mi51bmlxdWVfaWRcblxuICAoKiBFeHRyYWN0cyBtb2R1bGUgbmFtZSBmcm9tIFtcImZpbGVuYW1lLm1sLk1vZHVsZVwiXSwgd2hpY2ggaXMgdGhlIGZvcm1hdCBvZiBbZXh0X25hbWVdXG4gICAgIGFzIHNldCBieSBbdHlwZWNvbnZdLiAqKVxuICBsZXQgZ2V0X21vZHVsZV9uYW1lX29wdCB0ID1cbiAgICBsZXQgc3RyID0gdC50eXBlX2NvbnZfcGF0aCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgKyA0IDw9IGxlblxuICAgICAgdGhlblxuICAgICAgICBpZiBTdHJpbmcuc3ViIHN0ciBpIDQgPSBcIi5tbC5cIlxuICAgICAgICB0aGVuIFNvbWUgKFN0cmluZy5zdWIgc3RyIChpICsgNCkgKGxlbiAtIGkgLSA0KSlcbiAgICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIGluXG4gICAgbG9vcCAwXG4gIDs7XG5cbiAgbGV0IHdpdGhfdGVzdF9zcGVjIHQgdGVzdF9zcGVjID0geyB0IHdpdGggdGVzdF9zcGVjIH1cbmVuZFxuXG4oKiBJbnNwZWN0IHN5c3RlbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gZGVjaWRlIGlmIGJlbmNobWFya3MgYXJlIGJlaW5nIHJ1bi4gVGhpcyBpc1xuICAgY2FsbGVkIGJ5IHRoZSBjb2RlIGdlbmVyYXRlZCBieSB0aGUgW3BhX2JlbmNoXSBzeW50YXggdG8gZGVjaWRlIGlmIHRoZSBnbG9iYWwgaGFzaHRhYmxlXG4gICBzaG91bGQgYmUgcG9wdWxhdGVkLiAqKVxubGV0IGFkZF9lbnZpcm9ubWVudF92YXIgPVxuICBsZXQgdiA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJCRU5DSE1BUktTX1JVTk5FUlwiIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiBcIlwiXG4gIGluXG4gIHYgPSBcIlRSVUVcIlxuOztcblxuKCogVGhpcyBoYXNodGFibGUgY29udGFpbnMgYWxsIHRoZSBiZW5jaG1hcmtzIGZyb20gYWxsIHRoZSBvZiBsaWJyYXJpZXMgdGhhdCBoYXZlIGJlZW5cbiAgIGxvYWRlZC4gQXQgdGhlIHRpbWUgdGhlIGJlbmNobWFya3MgYXJlIHJlZ2lzdGVyaW5nIHRoZW1zZWx2ZXMgd2l0aCBbcHB4X2JlbmNoX2xpYl0gd2VcbiAgIGRvbid0IHlldCBrbm93IHdoaWNoIGxpYnJhcmllcyB3aWxsIG5lZWQgdG8gYmUgcnVuLiAgKilcbmxldCBsaWJzX3RvX2VudHJpZXMgOiAoc3RyaW5nLCBFbnRyeS50IGxpc3QpIEhhc2h0YmwudCA9IEhhc2h0YmwuY3JlYXRlIDEwXG5cbmxldCBsb29rdXBfcmV2X2xpYiB+bGlibmFtZSA9XG4gIHRyeSBIYXNodGJsLmZpbmQgbGlic190b19lbnRyaWVzIGxpYm5hbWUgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiBbXVxuOztcblxubGV0IGxvb2t1cF9saWIgfmxpYm5hbWUgPSBMaXN0LnJldiAobG9va3VwX3Jldl9saWIgfmxpYm5hbWUpXG5cbmxldCBmb3JjZV9kcm9wID1cbiAgKCogVXNlZnVsIGZvciBqc19vZl9vY2FtbCB0byBwZXJmb3JtIGRlYWRjb2RlIGVsaW1pbmF0aW9uLlxuICAgICBzZWUgcHB4L3BweF9pbmxpbmVfdGVzdC9ydW50aW1lLWxpYi9ydW50aW1lLm1sIFtBY3Rpb24uZ2V0XSBmb3IgbW9yZSBkZXRhaWxzICopXG4gIHRyeVxuICAgIGlnbm9yZSAoU3lzLmdldGVudiBcIkZPUkNFX0RST1BfQkVOQ0hcIiA6IHN0cmluZyk7XG4gICAgdHJ1ZVxuICB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X21vZGUgKCkgPSBpZiBmb3JjZV9kcm9wIHRoZW4gYElnbm9yZSBlbHNlIGBDb2xsZWN0XG5cbmxldFtAaW5saW5lIG5ldmVyXSBhZGRfYmVuY2hcbiAgICAgICAgICAgICAgICAgICAgIH5uYW1lXG4gICAgICAgICAgICAgICAgICAgICB+Y29kZVxuICAgICAgICAgICAgICAgICAgICAgfmZpbGVuYW1lXG4gICAgICAgICAgICAgICAgICAgICB+dHlwZV9jb252X3BhdGhcbiAgICAgICAgICAgICAgICAgICAgIH5saW5lXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRwb3NcbiAgICAgICAgICAgICAgICAgICAgIH5lbmRwb3NcbiAgICAgICAgICAgICAgICAgICAgIHRlc3Rfc3BlY1xuICA9XG4gIG1hdGNoIGdldF9tb2RlICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYENvbGxlY3QgLT5cbiAgICBsZXQgbGlibmFtZSA9IEN1cnJlbnRfbGlibmFtZS5nZXQgKCkgaW5cbiAgICBsZXQgZW50cnkgPVxuICAgICAgeyBFbnRyeS5jb2RlXG4gICAgICA7IHVuaXF1ZV9pZCA9IHVuaXF1ZV9pZCAoKVxuICAgICAgOyB0eXBlX2NvbnZfcGF0aFxuICAgICAgOyBiZW5jaF9tb2R1bGVfbmFtZSA9IEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrLnRvX25hbWUgKClcbiAgICAgIDsgbmFtZVxuICAgICAgOyBmaWxlbmFtZVxuICAgICAgOyBsaW5lXG4gICAgICA7IHN0YXJ0cG9zXG4gICAgICA7IGVuZHBvc1xuICAgICAgOyB0ZXN0X3NwZWNcbiAgICAgIH1cbiAgICBpblxuICAgIEhhc2h0YmwuYWRkIGxpYnNfdG9fZW50cmllcyBsaWJuYW1lIChlbnRyeSA6OiBsb29rdXBfcmV2X2xpYiB+bGlibmFtZSlcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSBhZGRfYmVuY2hfbW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICB+bmFtZVxuICAgICAgICAgICAgICAgICAgICAgfmNvZGU6X1xuICAgICAgICAgICAgICAgICAgICAgfnR5cGVfY29udl9wYXRoOl9cbiAgICAgICAgICAgICAgICAgICAgIH5maWxlbmFtZTpfXG4gICAgICAgICAgICAgICAgICAgICB+bGluZTpfXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRwb3M6X1xuICAgICAgICAgICAgICAgICAgICAgfmVuZHBvczpfXG4gICAgICAgICAgICAgICAgICAgICBmXG4gID1cbiAgbWF0Y2ggZ2V0X21vZGUgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgQ29sbGVjdCAtPlxuICAgICgqIFJ1bm5pbmcgZiByZWdpc3RlcnMgdGhlIGJlbmNobWFya3MgdXNpbmcgQkVOQ0ggKilcbiAgICBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjay5wdXNoIG5hbWU7XG4gICAgKHRyeVxuICAgICAgIGYgKCk7XG4gICAgICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucG9wX2V4biAoKVxuICAgICB3aXRoXG4gICAgIHwgZXggLT5cbiAgICAgICBDdXJyZW50X2JlbmNoX21vZHVsZV9zdGFjay5wb3BfZXhuICgpO1xuICAgICAgIHJhaXNlIGV4KVxuOztcbiJdfQ==
