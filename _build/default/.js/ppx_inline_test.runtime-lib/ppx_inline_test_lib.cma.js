// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_inline_tests_runner_exe=
      caml_string_of_jsbytes("inline_tests_runner.exe"),
     cst$14=caml_string_of_jsbytes(""),
     cst$12=caml_string_of_jsbytes("\n"),
     cst$13=caml_string_of_jsbytes(" "),
     cst$11=caml_string_of_jsbytes(""),
     cst_ppx_inline_test_cannot_use=
      caml_string_of_jsbytes
       ("ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time"),
     cst$9=caml_string_of_jsbytes("\n"),
     cst$10=caml_string_of_jsbytes(" "),
     cst$7=caml_string_of_jsbytes("\n"),
     cst$8=caml_string_of_jsbytes("  "),
     cst$5=caml_string_of_jsbytes("\n"),
     cst_T_MODULE_at=caml_string_of_jsbytes("T_MODULE at "),
     cst_in_TES=caml_string_of_jsbytes("  in TES"),
     cst$6=caml_string_of_jsbytes(""),
     cst_time_without_resetting_ran=
      caml_string_of_jsbytes("time_without_resetting_random_seeds"),
     cst$4=caml_string_of_jsbytes("."),
     cst_Ppx_inline_test_lib_Runtim=
      caml_string_of_jsbytes("Ppx_inline_test_lib__Runtime"),
     cst_inline_tests_log$0=caml_string_of_jsbytes("inline_tests.log"),
     cst_inline_tests_log=caml_string_of_jsbytes("inline_tests.log"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(": "),
     cst$0=caml_string_of_jsbytes(""),
     cst_success=caml_string_of_jsbytes("success"),
     cst_failure=caml_string_of_jsbytes("failure"),
     cst_error=caml_string_of_jsbytes("error"),
     enable_everything=[0,0,0],
     cst_FORCE_DROP_INLINE_TEST=
      caml_string_of_jsbytes("FORCE_DROP_INLINE_TEST"),
     cst=caml_string_of_jsbytes(""),
     cst_inline_test_runner=caml_string_of_jsbytes("inline-test-runner"),
     cst_inline_test_runner$0=caml_string_of_jsbytes("inline-test-runner"),
     cst_Path_to_the_root_of_the_so=
      caml_string_of_jsbytes(" Path to the root of the source tree"),
     cst_source_tree_root=caml_string_of_jsbytes("-source-tree-root"),
     cst_Allow_output_patterns_in_t=
      caml_string_of_jsbytes(" Allow output patterns in tests expectations"),
     cst_allow_output_patterns=
      caml_string_of_jsbytes("-allow-output-patterns"),
     cst_Diff_command_for_tests_tha=
      caml_string_of_jsbytes
       (" Diff command for tests that require diffing (use - to disable diffing)"),
     cst_diff_cmd=caml_string_of_jsbytes("-diff-cmd"),
     cst_Update_expect_tests_in_pla=
      caml_string_of_jsbytes(" Update expect tests in place"),
     cst_in_place=caml_string_of_jsbytes("-in-place"),
     cst_Summarize_tests_without_us=
      caml_string_of_jsbytes(" Summarize tests without using color"),
     cst_no_color=caml_string_of_jsbytes("-no-color"),
     cst_location_Run_only_the_test=
      caml_string_of_jsbytes
       ('location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3'),
     cst_only_test=caml_string_of_jsbytes("-only-test"),
     cst_substring_Only_run_tests_w=
      caml_string_of_jsbytes
       ("substring Only run tests whose names contain the given substring"),
     cst_matching=caml_string_of_jsbytes("-matching"),
     cst_tag_Only_run_tests_tagged_=
      caml_string_of_jsbytes
       ("tag Only run tests tagged with [tag] (overrides previous -drop-tag)"),
     cst_require_tag=caml_string_of_jsbytes("-require-tag"),
     cst_tag_Only_run_tests_not_tag=
      caml_string_of_jsbytes
       ("tag Only run tests not tagged with [tag] (overrides previous -require-tag)"),
     cst_drop_tag=caml_string_of_jsbytes("-drop-tag"),
     cst_Log_the_tests_run_in_inlin=
      caml_string_of_jsbytes(" Log the tests run in inline_tests.log"),
     cst_log=caml_string_of_jsbytes("-log"),
     cst_Show_the_number_of_tests_r=
      caml_string_of_jsbytes(" Show the number of tests ran"),
     cst_show_counts=caml_string_of_jsbytes("-show-counts"),
     cst_End_with_an_error_if_no_te=
      caml_string_of_jsbytes(" End with an error if no tests were run"),
     cst_strict=caml_string_of_jsbytes("-strict"),
     cst_Run_tests_only_up_to_the_f=
      caml_string_of_jsbytes
       (" Run tests only up to the first error (doesn't work for expect tests)"),
     cst_stop_on_error=caml_string_of_jsbytes("-stop-on-error"),
     cst_Show_the_tests_as_they_run=
      caml_string_of_jsbytes(" Show the tests as they run"),
     cst_verbose=caml_string_of_jsbytes("-verbose"),
     cst_Only_run_the_tests_in_the_=
      caml_string_of_jsbytes(" Only run the tests in the given partition"),
     cst_partition=caml_string_of_jsbytes("-partition"),
     cst_Lists_all_the_partitions_t=
      caml_string_of_jsbytes
       (" Lists all the partitions that contain at least one test or test_module"),
     cst_list_partitions=caml_string_of_jsbytes("-list-partitions"),
     cst_Do_not_run_tests_but_show_=
      caml_string_of_jsbytes
       (" Do not run tests but show what would have been run"),
     cst_list_test_names=caml_string_of_jsbytes("-list-test-names"),
     am_running_inline_test_env_var=
      caml_string_of_jsbytes("TESTING_FRAMEWORK"),
     cst_PPX_INLINE_TEST_LIB_AM_RUN=
      caml_string_of_jsbytes("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST"),
     cst_inline_test=caml_string_of_jsbytes("inline-test"),
     Stdlib_List=global_data.Stdlib__List,
     Stdlib=global_data.Stdlib,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Filename=global_data.Stdlib__Filename,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Stdlib_String=global_data.Stdlib__String,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Result=global_data.Stdlib__Result,
     Base=global_data.Base,
     Base_String=global_data.Base__String,
     Base_List=global_data.Base__List,
     Stdlib_Random=global_data.Stdlib__Random,
     Base_Random=global_data.Base__Random,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Base_Int63=global_data.Base__Int63,
     Time_now=global_data.Time_now,
     Stdlib_Scanf=global_data.Stdlib__Scanf,
     Stdlib_Hashtbl=global_data.Stdlib__Hashtbl,
     Stdlib_Arg=global_data.Stdlib__Arg,
     Stdlib_Array=global_data.Stdlib__Array,
     Ppx_inline_test_lib=[0];
    caml_register_global(104,Ppx_inline_test_lib,"Ppx_inline_test_lib");
    var
     _E_=
      [0,[12,32,[2,0,[12,58,[4,0,0,0,0]]]],caml_string_of_jsbytes(" %s:%d")],
     _F_=[0,[12,32,[2,0,0]],caml_string_of_jsbytes(" %s")],
     _z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!")],
     _A_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!")],
     _B_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _C_=
      [0,
       [4,
        0,
        0,
        0,
        [11,
         caml_string_of_jsbytes(" tests ran, "),
         [4,0,0,0,[11,caml_string_of_jsbytes(" test_modules ran\n"),[10,0]]]]],
       caml_string_of_jsbytes("%d tests ran, %d test_modules ran\n%!")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("ppx_inline_test error: the following -only-test flags matched nothing:"),
        0],
       caml_string_of_jsbytes
        ("ppx_inline_test error: the following -only-test flags matched nothing:")],
     _G_=
      [0,
       [11,caml_string_of_jsbytes(".\n"),[10,0]],
       caml_string_of_jsbytes(".\n%!")],
     _H_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("ppx_inline_test error: no tests have been run.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("ppx_inline_test error: no tests have been run.\n%!")],
     _J_=
      [0,
       [11,caml_string_of_jsbytes("T_MODULES"),0],
       caml_string_of_jsbytes("T_MODULES")],
     _K_=
      [0,
       [11,
        caml_string_of_jsbytes(", "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" TES"),0]]],
       caml_string_of_jsbytes(", %d TES")],
     _I_=
      [0,
       [11,
        caml_string_of_jsbytes("FAILED "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" / "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" tests"),[2,0,[12,10,[10,0]]]]]]]],
       caml_string_of_jsbytes("FAILED %d / %d tests%s\n%!")],
     _x_=
      [0,
       [11,
        caml_string_of_jsbytes("T_MODULE at "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" threw"),
          [2,
           0,
           [2,0,[11,caml_string_of_jsbytes(".\n"),[2,0,[2,0,[12,10,[10,0]]]]]]]]]],
       caml_string_of_jsbytes("T_MODULE at %s threw%s%s.\n%s%s\n%!")],
     _y_=
      [0,[11,caml_string_of_jsbytes("TES"),0],caml_string_of_jsbytes("TES")],
     _r_=[0,[2,0,[12,10,[2,0,0]]],caml_string_of_jsbytes("%s\n%s")],
     _s_=[0,[2,0,[10,0]],caml_string_of_jsbytes("%s%!")],
     _t_=[0,1],
     _u_=
      [0,
       [11,
        caml_string_of_jsbytes(" ("),
        [8,[0,0,0],0,[0,3],[11,caml_string_of_jsbytes(" sec)\n"),[10,0]]]],
       caml_string_of_jsbytes(" (%.3f sec)\n%!")],
     _v_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" is false.\n"),[2,0,[12,10,[10,0]]]]],
       caml_string_of_jsbytes("%s is false.\n%s\n%!")],
     _w_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" threw"),
         [2,
          0,
          [2,0,[11,caml_string_of_jsbytes(".\n"),[2,0,[2,0,[12,10,[10,0]]]]]]]]],
       caml_string_of_jsbytes("%s threw%s%s.\n%s%s\n%!")],
     _q_=[0,[2,0,[10,0]],caml_string_of_jsbytes("%s%!")],
     _p_=[0,[2,0,[10,0]],caml_string_of_jsbytes("%s%!")],
     _o_=[0,[12,10,[2,0,[12,10,[10,0]]]],caml_string_of_jsbytes("\n%s\n%!")],
     _T_=
      [0,
       [11,
        caml_string_of_jsbytes("Argument "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" doesn't fit the format filename[:line_number]\n"),
          [10,0]]]],
       caml_string_of_jsbytes
        ("Argument %s doesn't fit the format filename[:line_number]\n%!")],
     _P_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unexpected anonymous argument "),
         [2,0,[12,10,[10,0]]]]],
       caml_string_of_jsbytes("%s: unexpected anonymous argument %s\n%!")],
     _g_=
      [0,
       [11,
        caml_string_of_jsbytes(" File "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(" , line "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" , characters "),
            [4,
             0,
             0,
             0,
             [11,caml_string_of_jsbytes(" - "),[4,0,0,0,[12,32,[10,0]]]]]]]]]],
       caml_string_of_jsbytes(" File %S , line %d , characters %d - %d %!")],
     _f_=
      [0,
       [11,
        caml_string_of_jsbytes(" File "),
        [3,0,[11,caml_string_of_jsbytes(" , line "),[4,0,0,0,[12,32,[10,0]]]]]],
       caml_string_of_jsbytes(" File %S , line %d %!")],
     _e_=
      [0,
       [11,caml_string_of_jsbytes(" File "),[3,0,[12,32,[10,0]]]],
       caml_string_of_jsbytes(" File %S %!")],
     _d_=
      [0,
       [11,
        caml_string_of_jsbytes("File "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(", line "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[2,0,0]]]]]]]]],
       caml_string_of_jsbytes("File %S, line %d, characters %d-%d%s")],
     _a_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _b_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _O_=
      [0,
       [2,
        0,
        [12,32,[2,0,[12,32,[2,0,[11,caml_string_of_jsbytes(" [args]"),0]]]]]],
       caml_string_of_jsbytes("%s %s %s [args]")],
     _n_=[0,187165616,545942154],
     _L_=[0,187165616,-863538453];
    function to_string(param)
     {switch(param)
       {case 0:return cst_success;
        case 1:return cst_failure;
        default:return cst_error}}
    function combine(t1,t2)
     {var switch$0=0;
      switch(t1)
       {case 0:if(! t2)return 0;break;case 1:break;default:switch$0 = 1}
      if(! switch$0 && 2 !== t2)return 1;
      return 2}
    function combine_all(ts){return caml_call3(Stdlib_List[25],combine,0,ts)}
    var
     test_modules_ran=[0,0],
     test_modules_failed=[0,0],
     tests_ran=[0,0],
     tests_failed=[0,0],
     dynamic_lib=[0,0],
     action=[0,-950194894];
    try
     {caml_sys_getenv(cst_FORCE_DROP_INLINE_TEST);var _ab_=1,force_drop=_ab_}
    catch(_b__)
     {_b__ = caml_wrap_exception(_b__);
      if(_b__ !== Stdlib[8])throw _b__;
      var force_drop=0}
    function get(param){return force_drop?-950194894:action[1]}
    function set(v){action[1] = v;return 0}
    var _c_=caml_call2(Stdlib_Hashtbl[1],0,23),current=[0,cst];
    function found_test(param)
     {var
       _b8_=caml_string_notequal(current[1],cst$0),
       _b9_=_b8_?1 - caml_call2(Stdlib_Hashtbl[9],_c_,current[1]):_b8_;
      return _b9_?caml_call3(Stdlib_Hashtbl[5],_c_,current[1],0):_b9_}
    function is_current(param)
     {if(! param)return 1;
      var p=param[1];
      return caml_string_equal(p,current[1])}
    var current$0=[0,0];
    function with$0(descr,tags,f)
     {var prev=current$0[1];
      current$0[1] = [0,[0,descr,tags],prev];
      try
       {var x=caml_call1(f,0);current$0[1] = prev;return x}
      catch(e){e = caml_wrap_exception(e);current$0[1] = prev;throw e}}
    function current_tags(param)
     {var _b7_=current$0[1];
      function _b5_(m){return m[2]}
      var _b6_=caml_call2(Stdlib_List[19],_b5_,_b7_);
      return caml_call1(Stdlib_List[13],_b6_)}
    var
     verbose=[0,0],
     strict=[0,0],
     show_counts=[0,0],
     list_test_names=[0,0],
     delayed_errors=[0,0],
     stop_on_error=[0,0],
     log=[0,0],
     time_sec=[0,0.],
     use_color=[0,1],
     in_place=[0,0],
     diff_command=[0,0],
     source_tree_root=[0,0],
     allow_output_patterns=[0,0];
    function displayed_descr(param)
     {var
       _b3_=caml_obj_tag(param),
       descr=
        250 === _b3_
         ?param[1]
         :246 === _b3_?caml_call1(CamlinternalLazy[2],param):param;
      return function(filename,line,start_pos,end_pos)
       {var
         _b4_=
          caml_string_equal(descr,cst$1)
           ?cst$2
           :caml_call2(Stdlib[28],cst$3,descr);
        return caml_call6
                (Stdlib_Printf[4],_d_,filename,line,start_pos,end_pos,_b4_)}}
    var
     _h_=caml_sys_argv(0),
     match=caml_call1(Stdlib_Array[11],_h_),
     switch$0=0;
    if(match)
     {var _i_=match[2];
      if(_i_)
       {var _j_=match[1];
        if(! caml_string_notequal(_i_[1],cst_inline_test_runner))
         {var _N_=_i_[2];
          if(_N_)
           {var rest=_N_[2],lib=_N_[1];
            if(Base[85][1])
             {var
               tests=[0,0],
               list_partitions=[0,0],
               partition=[0,0],
               tag_predicate=[0,enable_everything],
               name_filter=[0,0],
               msg$1=
                caml_call4
                 (Stdlib_Printf[4],_O_,_j_,cst_inline_test_runner$0,lib),
               f=
                function(anon)
                 {caml_call3(Stdlib_Printf[3],_P_,_j_,anon);
                  return caml_call1(Stdlib[99],1)},
               _Q_=0,
               _R_=
                [0,
                 [0,
                  cst_allow_output_patterns,
                  [2,allow_output_patterns],
                  cst_Allow_output_patterns_in_t],
                 [0,
                  [0,
                   cst_source_tree_root,
                   [4,function(s){source_tree_root[1] = [0,s];return 0}],
                   cst_Path_to_the_root_of_the_so],
                  _Q_]],
               _S_=
                [0,
                 [0,cst_no_color,[3,use_color],cst_Summarize_tests_without_us],
                 [0,
                  [0,cst_in_place,[2,in_place],cst_Update_expect_tests_in_pla],
                  [0,
                   [0,
                    cst_diff_cmd,
                    [4,function(s){diff_command[1] = [0,s];return 0}],
                    cst_Diff_command_for_tests_tha],
                   _R_]]],
               _U_=
                [0,
                 [0,
                  cst_only_test,
                  [4,
                   function(s)
                    {try
                      {var
                        _bW_=
                         function(file,line,start_pos,end_pos)
                          {return [0,file,[0,line]]},
                        _bX_=[0,caml_call3(Stdlib_Scanf[4],s,_g_,_bW_)],
                        match=_bX_}
                     catch(_b0_)
                      {try
                        {var
                          _bU_=function(file,line){return [0,file,[0,line]]},
                          _bV_=[0,caml_call3(Stdlib_Scanf[4],s,_f_,_bU_)],
                          match=_bV_}
                       catch(_b1_)
                        {try
                          {var
                            _bS_=function(file){return [0,file,0]},
                            _bT_=[0,caml_call3(Stdlib_Scanf[4],s,_e_,_bS_)],
                            match=_bT_}
                         catch(_b2_){var match=0}}}
                     if(match)
                      var
                       match$0=match[1],
                       index=match$0[2],
                       file=match$0[1],
                       index$0=index,
                       filename=file;
                     else
                      if(caml_call2(Stdlib_String[14],s,58))
                       {var
                         i=caml_call2(Stdlib_String[35],s,58),
                         filename$0=caml_call3(Stdlib_String[15],s,0,i),
                         index_string=
                          caml_call3
                           (Stdlib_String[15],
                            s,
                            i + 1 | 0,
                            (caml_ml_string_length(s) - i | 0) - 1 | 0);
                        try
                         {var
                           _bY_=runtime.caml_int_of_string(index_string),
                           index$1=_bY_}
                        catch(_bZ_)
                         {_bZ_ = caml_wrap_exception(_bZ_);
                          if(_bZ_[1] !== Stdlib[7])throw _bZ_;
                          caml_call2(Stdlib_Printf[3],_T_,s);
                          var index$1=caml_call1(Stdlib[99],1)}
                        var index$0=[0,index$1],filename=filename$0}
                      else
                       var index$0=0,filename=s;
                     tests[1] = [0,[0,filename,index$0,[0,0]],tests[1]];
                     return 0}],
                  cst_location_Run_only_the_test],
                 _S_],
               _V_=
                [0,
                 [0,
                  cst_matching,
                  [4,
                   function(s){name_filter[1] = [0,s,name_filter[1]];return 0}],
                  cst_substring_Only_run_tests_w],
                 _U_],
               _W_=
                [0,
                 [0,
                  cst_require_tag,
                  [4,
                   function(s)
                    {var _bQ_=tag_predicate[1],_bN_=_bQ_[2];
                     function _bO_(_bR_){return caml_string_notequal(s,_bR_)}
                     var _bP_=caml_call2(Stdlib_List[41],_bO_,_bN_);
                     tag_predicate[1] = [0,[0,s,_bQ_[1]],_bP_];
                     return 0}],
                  cst_tag_Only_run_tests_tagged_],
                 _V_],
               _X_=
                [0,
                 [0,
                  cst_drop_tag,
                  [4,
                   function(s)
                    {var _bL_=tag_predicate[1],_bI_=[0,s,_bL_[2]],_bJ_=_bL_[1];
                     function _bK_(_bM_){return caml_string_notequal(s,_bM_)}
                     tag_predicate[1]
                     =
                     [0,caml_call2(Stdlib_List[41],_bK_,_bJ_),_bI_];
                     return 0}],
                  cst_tag_Only_run_tests_not_tag],
                 _W_],
               _Y_=
                [0,
                 [0,cst_verbose,[2,verbose],cst_Show_the_tests_as_they_run],
                 [0,
                  [0,
                   cst_stop_on_error,
                   [2,stop_on_error],
                   cst_Run_tests_only_up_to_the_f],
                  [0,
                   [0,cst_strict,[2,strict],cst_End_with_an_error_if_no_te],
                   [0,
                    [0,
                     cst_show_counts,
                     [2,show_counts],
                     cst_Show_the_number_of_tests_r],
                    [0,
                     [0,
                      cst_log,
                      [0,
                       function(param)
                        {try
                          {runtime.caml_sys_remove(cst_inline_tests_log$0)}
                         catch(_bH_){}
                         log[1] = [0,caml_call1(Stdlib[60],cst_inline_tests_log)];
                         return 0}],
                      cst_Log_the_tests_run_in_inlin],
                     _X_]]]]],
               _Z_=
                [0,
                 [0,
                  cst_partition,
                  [4,function(i){partition[1] = [0,i];return 0}],
                  cst_Only_run_the_tests_in_the_],
                 _Y_],
               ___=
                [0,
                 [0,
                  cst_list_partitions,
                  [0,function(param){list_partitions[1] = 1;return 0}],
                  cst_Lists_all_the_partitions_t],
                 _Z_],
               _$_=
                [0,
                 [0,
                  cst_list_test_names,
                  [0,
                   function(param)
                    {list_test_names[1] = 1;verbose[1] = 1;return 0}],
                  cst_Do_not_run_tests_but_show_],
                 ___],
               l=caml_call2(Stdlib_Arg[11],0,_$_),
               argv=caml_call1(Stdlib_Array[12],[0,_j_,rest]);
              try
               {caml_call5(Stdlib_Arg[3],0,argv,l,f,msg$1)}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                if(exn[1] === Stdlib_Arg[8])
                 {var msg=exn[2];
                  caml_call2(Stdlib_Printf[3],_a_,msg);
                  caml_call1(Stdlib[99],1)}
                else
                 {if(exn[1] !== Stdlib_Arg[7])throw exn;
                  var msg$0=exn[2];
                  caml_call2(Stdlib_Printf[2],_b_,msg$0);
                  caml_call1(Stdlib[99],0)}}
              var
               _aa_=
                list_partitions[1]?-260537174:[0,1025081494,partition[1]];
              set
               ([0,
                 -753295984,
                 [0,[0,lib,tests[1],name_filter[1],tag_predicate[1]],_aa_]]);
              switch$0 = 1}}}}}
    var match$0=get(0),_k_=typeof match$0 === "number"?0:1;
    try
     {var switch$1=0;
      caml_sys_getenv(cst_PPX_INLINE_TEST_LIB_AM_RUN);
      switch$1 = 1}
    catch(_bF_)
     {_bF_ = caml_wrap_exception(_bF_);
      if(_bF_ !== Stdlib[8])throw _bF_;
      try
       {var switch$2=0,val=caml_sys_getenv(am_running_inline_test_env_var);
        switch$2 = 1}
      catch(_bG_)
       {_bG_ = caml_wrap_exception(_bG_);
        if(_bG_ !== Stdlib[8])throw _bG_;
        var _l_=0}
      if(switch$2)
       var _M_=caml_string_notequal(val,cst_inline_test)?0:1,_l_=_M_;
      var _m_=_l_}
    if(switch$1)var _m_=1;
    var testing=_k_?_n_:_m_?_L_:822171972;
    function wall_time_clock_ns(param){return caml_call1(Time_now[1],0)}
    var
     where_to_cut_backtrace=
      [246,
       function(_bC_)
        {var
          _bD_=caml_call2(Stdlib[28],cst$4,cst_time_without_resetting_ran),
          _bE_=caml_call2(Stdlib[28],cst_Ppx_inline_test_lib_Runtim,_bD_);
         return caml_call2(Base_String[70][2],0,_bE_)}];
    function time_without_resetting_random_(f)
     {var before_ns=wall_time_clock_ns(0);
      try
       {var _bB_=[0,caml_call1(f,0)],res=_bB_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var res=[1,[0,exn,caml_call1(Stdlib_Printexc[6],0)]]}
      var
       _bz_=wall_time_clock_ns(0),
       _bA_=caml_call2(Base_Int63[42],_bz_,before_ns);
      time_sec[1] = caml_call1(Base_Int63[3],_bA_) / 1000000000.;
      return res}
    var
     saved_caml_random_state=
      [246,
       function(_by_){return caml_call1(Stdlib_Random[15][1],[0,100,200,300])}],
     saved_base_random_state=
      [246,
       function(_bx_){return caml_call1(Base_Random[18][2],[0,111,222,333])}];
    function string_of_module_descr(param)
     {var _br_=current$0[1];
      function _bp_(m){return m[1]}
      var _bq_=caml_call2(Stdlib_List[19],_bp_,_br_);
      function _bs_(s)
       {var
         _bu_=caml_call1(Stdlib_String[28],s),
         _bv_=caml_call2(Stdlib[28],_bu_,cst$5),
         _bw_=caml_call2(Stdlib[28],cst_T_MODULE_at,_bv_);
        return caml_call2(Stdlib[28],cst_in_TES,_bw_)}
      var _bt_=caml_call2(Stdlib_List[19],_bs_,_bq_);
      return caml_call2(Stdlib_String[6],cst$6,_bt_)}
    function print_delayed_errors(param)
     {var delayed_errors$0=caml_call1(Stdlib_List[9],delayed_errors[1]);
      if(! delayed_errors$0)return 0;
      var _bn_=caml_call2(Stdlib_String[1],70,61);
      caml_call2(Stdlib_Printf[3],_o_,_bn_);
      function _bo_(message){return caml_call2(Stdlib_Printf[3],_p_,message)}
      return caml_call2(Stdlib_List[17],_bo_,delayed_errors$0)}
    function eprintf_or_delay(fmt)
     {function _bl_(s)
       {if(verbose[1])
         delayed_errors[1] = [0,s,delayed_errors[1]];
        else
         caml_call2(Stdlib_Printf[3],_q_,s);
        var _bm_=stop_on_error[1];
        return _bm_?(print_delayed_errors(0),caml_call1(Stdlib[99],2)):_bm_}
      return caml_call2(Stdlib_Printf[10],_bl_,fmt)}
    function add_hooks(C)
     {return function(f,param){caml_call1(C[1],0);return caml_call1(f,0)}}
    function hum_backtrace(backtrace)
     {var
       _bd_=caml_call1(Base_String[88],backtrace),
       _be_=Base_List[133],
       _bf_=
        caml_call2
         (_be_,
          _bd_,
          function(str)
           {var
             _bj_=caml_obj_tag(where_to_cut_backtrace),
             _bk_=
              250 === _bj_
               ?where_to_cut_backtrace[1]
               :246 === _bj_
                 ?caml_call1(CamlinternalLazy[2],where_to_cut_backtrace)
                 :where_to_cut_backtrace;
            return 1 - caml_call2(Base_String[70][5],_bk_,str)}),
       _bg_=Base_List[76],
       _bh_=
        caml_call2
         (_bg_,
          _bf_,
          function(str)
           {var _bi_=caml_call2(Base[197],str,cst$7);
            return caml_call2(Base[197],cst$8,_bi_)});
      return caml_call2(Base_String[54],0,_bh_)}
    function test_inner
     (config,
      descr,
      tags,
      def_filename,
      def_line_number,
      start_pos,
      end_pos,
      f,
      bool_of_f)
     {var match=get(0);
      if(typeof match === "number")return 0;
      var
       _aT_=match[2],
       what_to_do=_aT_[2],
       match$0=_aT_[1],
       which_tags=match$0[4],
       name_filter=match$0[3],
       only_test_location=match$0[2],
       libname=match$0[1],
       f$0=caml_call1(add_hooks(config),f),
       descr$0=
        [246,
         function(_bc_)
          {return caml_call4
                   (displayed_descr(descr),
                    def_filename,
                    def_line_number,
                    start_pos,
                    end_pos)}],
       _aU_=current_tags(0),
       tags$0=caml_call2(Stdlib[37],tags,_aU_),
       _aV_=caml_equal([0,libname],dynamic_lib[1]);
      if(_aV_)
       {if(only_test_location)
         var
          _aR_=
           function(param)
            {var
              used=param[3],
              line_number_opt=param[2],
              filename=param[1],
              position_start=
               caml_ml_string_length(def_filename)
               -
               caml_ml_string_length(filename)
               |
               0,
              _a9_=0 <= position_start?1:0;
             if(_a9_)
              {var
                end_of_def_filename=
                 caml_call3
                  (Stdlib_String[15],
                   def_filename,
                   position_start,
                   caml_ml_string_length(filename)),
                _a__=caml_string_equal(end_of_def_filename,filename);
               if(_a__)
                {var
                  _a$_=0 === position_start?1:0,
                  _ba_=
                   _a$_
                   ||
                   (47
                     ===
                     runtime.caml_string_get(def_filename,position_start - 1 | 0)
                     ?1
                     :0);
                 if(_ba_)
                  if(line_number_opt)
                   var
                    line_number=line_number_opt[1],
                    _bb_=caml_equal(def_line_number,line_number);
                  else
                   var _bb_=1;
                 else
                  var _bb_=_ba_}
               else
                var _bb_=_a__;
               var found=_bb_}
             else
              var found=_a9_;
             if(found)used[1] = 1;
             return found},
          _aW_=caml_call2(Stdlib_List[33],_aR_,only_test_location);
        else
         var _aW_=1;
        if(_aW_)
         {var
           _aI_=which_tags[1],
           _aJ_=
            function(req){return 1 - caml_call2(Stdlib_List[36],req,tags$0)},
           _aK_=caml_call2(Stdlib_List[33],_aJ_,_aI_);
          if(_aK_)
           var _aX_=_aK_;
          else
           var
            _aL_=which_tags[2],
            _aM_=
             function(dropped)
              {return caml_call2(Stdlib_List[36],dropped,tags$0)},
            _aX_=caml_call2(Stdlib_List[33],_aM_,_aL_);
          var _aY_=1 - _aX_;
          if(_aY_)
           {var
             _aZ_=caml_obj_tag(descr$0),
             _a0_=
              250 === _aZ_
               ?descr$0[1]
               :246 === _aZ_?caml_call1(CamlinternalLazy[2],descr$0):descr$0;
            if(name_filter)
             var
              _aS_=
               function(substring)
                {return caml_call2(Base_String[76],_a0_,substring)},
              _a1_=caml_call2(Stdlib_List[33],_aS_,name_filter);
            else
             var _a1_=1;
            var should_run=_a1_}
          else
           var should_run=_aY_}
        else
         var should_run=_aW_}
      else
       var should_run=_aV_;
      if(should_run)
       {if(typeof what_to_do === "number")return found_test(0);
        var partition=what_to_do[2],_a2_=is_current(partition);
        if(_a2_)
         {var
           _a3_=caml_obj_tag(descr$0),
           descr$1=
            250 === _a3_
             ?descr$0[1]
             :246 === _a3_?caml_call1(CamlinternalLazy[2],descr$0):descr$0;
          tests_ran[1]++;
          var _a4_=log[1];
          if(_a4_)
           {var ch=_a4_[1],_a5_=string_of_module_descr(0);
            caml_call4(Stdlib_Printf[1],ch,_r_,descr$1,_a5_)}
          if(verbose[1])caml_call2(Stdlib_Printf[2],_s_,descr$1);
          if(list_test_names[1])
           var result$0=_t_;
          else
           {var
             caml_random_state=caml_call1(Stdlib_Random[16],0),
             base_random_state=
              caml_call1(Base_Random[18][4],Base_Random[18][1]),
             _aN_=caml_obj_tag(saved_caml_random_state),
             _aO_=
              250 === _aN_
               ?saved_caml_random_state[1]
               :246 === _aN_
                 ?caml_call1(CamlinternalLazy[2],saved_caml_random_state)
                 :saved_caml_random_state;
            caml_call1(Stdlib_Random[17],_aO_);
            var
             _aP_=caml_obj_tag(saved_base_random_state),
             _aQ_=
              250 === _aP_
               ?saved_base_random_state[1]
               :246 === _aP_
                 ?caml_call1(CamlinternalLazy[2],saved_base_random_state)
                 :saved_base_random_state;
            caml_call1(Base_Random[19],_aQ_);
            var result=time_without_resetting_random_(f$0);
            caml_call1(Stdlib_Random[17],caml_random_state);
            caml_call1(Base_Random[19],base_random_state);
            var result$0=caml_call2(Stdlib_Result[8],bool_of_f,result)}
          if(verbose[1])caml_call2(Stdlib_Printf[2],_u_,time_sec[1]);
          if(0 !== result$0[0])
           {var match$1=result$0[1],backtrace=match$1[2],exn=match$1[1];
            tests_failed[1]++;
            var
             backtrace$0=hum_backtrace(backtrace),
             exn_str=caml_call1(Sexplib0_Sexp_conv[68],exn),
             sep=caml_call2(Stdlib_String[14],exn_str,10)?cst$9:cst$10,
             _a7_=string_of_module_descr(0);
            return caml_call5
                    (eprintf_or_delay(_w_),descr$1,sep,exn_str,backtrace$0,_a7_)}
          if(result$0[1])return 0;
          tests_failed[1]++;
          var _a6_=string_of_module_descr(0);
          return caml_call2(eprintf_or_delay(_v_),descr$1,_a6_)}
        var _a8_=_a2_}
      else
       var _a8_=should_run;
      return _a8_}
    function set_lib_and_partition(static_lib,partition)
     {if(dynamic_lib[1])return 0;
      dynamic_lib[1] = [0,static_lib];
      var match=get(0);
      if(typeof match === "number")return 0;
      var
       match$0=match[2],
       what_to_do=match$0[2],
       which_tests=match$0[1],
       _aH_=caml_string_equal(which_tests[1],static_lib);
      if(! _aH_)return _aH_;
      var switch$0=0;
      if(typeof what_to_do !== "number" && ! what_to_do[2])
       {var requires_partition=0;switch$0 = 1}
      if(! switch$0)var requires_partition=1;
      if(caml_string_equal(partition,cst$11) && requires_partition)
       return caml_call1(Stdlib[2],cst_ppx_inline_test_cannot_use);
      current[1] = partition;
      return 0}
    function unset_lib(static_lib)
     {var _aE_=dynamic_lib[1];
      if(! _aE_)return 0;
      var
       lib=_aE_[1],
       _aF_=caml_string_equal(lib,static_lib),
       _aG_=_aF_?(dynamic_lib[1] = 0,0):_aF_;
      return _aG_}
    function test(config,descr,tags,filename,line_number,start_pos,end_pos,f)
     {return test_inner
              (config,
               descr,
               tags,
               filename,
               line_number,
               start_pos,
               end_pos,
               f,
               function(b){return b})}
    function test_unit
     (config,descr,tags,filename,line_number,start_pos,end_pos,f)
     {return test_inner
              (config,
               descr,
               tags,
               filename,
               line_number,
               start_pos,
               end_pos,
               f,
               function(param){return 1})}
    function test_module
     (config,descr,tags,def_filename,def_line_number,start_pos,end_pos,f)
     {var match=get(0);
      if(typeof match === "number")return 0;
      var
       _ax_=match[2],
       what_to_do=_ax_[2],
       match$0=_ax_[1],
       which_tags=match$0[4],
       libname=match$0[1],
       f$0=caml_call1(add_hooks(config),f),
       _ay_=current_tags(0),
       tags$0=caml_call2(Stdlib[37],tags,_ay_),
       _az_=caml_equal([0,libname],dynamic_lib[1]);
      if(_az_)
       var
        _av_=which_tags[2],
        _aw_=
         function(dropped){return caml_call2(Stdlib_List[36],dropped,tags$0)},
        should_run=1 - caml_call2(Stdlib_List[33],_aw_,_av_);
      else
       var should_run=_az_;
      if(should_run)
       {if(typeof what_to_do === "number")return found_test(0);
        var partition=what_to_do[2],_aA_=is_current(partition);
        if(_aA_)
         {test_modules_ran[1]++;
          var
           descr$0=
            caml_call4
             (displayed_descr(descr),
              def_filename,
              def_line_number,
              start_pos,
              end_pos),
           match$1=
            with$0
             (descr$0,
              tags,
              function(param){return time_without_resetting_random_(f$0)});
          if(0 === match$1[0])return 0;
          var match$2=match$1[1],backtrace=match$2[2],exn=match$2[1];
          test_modules_failed[1]++;
          var
           backtrace$0=hum_backtrace(backtrace),
           exn_str=caml_call1(Sexplib0_Sexp_conv[68],exn),
           sep=caml_call2(Stdlib_String[14],exn_str,10)?cst$12:cst$13,
           _aB_=string_of_module_descr(0),
           _aC_=caml_call1(Stdlib_String[28],descr$0);
          return caml_call5
                  (eprintf_or_delay(caml_call2(Stdlib[98],_y_,_x_)),
                   _aC_,
                   sep,
                   exn_str,
                   backtrace$0,
                   _aB_)}
        var _aD_=_aA_}
      else
       var _aD_=should_run;
      return _aD_}
    function summarize(param)
     {var match=get(0);
      if(typeof match === "number")
       {var switch$0=0;
        if(runtime.caml_notequal(caml_sys_argv(0),[0]))
         {var _aj_=runtime.caml_check_bound(caml_sys_argv(0),0)[1];
          if
           (caml_string_equal
             (caml_call1(Stdlib_Filename[13],_aj_),
              cst_inline_tests_runner_exe))
           {caml_call1(Stdlib_Printf[3],_z_);switch$0 = 1}}
        if(! switch$0)caml_call1(Stdlib_Printf[3],_A_);
        return 2}
      var _ak_=match[2],_al_=_ak_[1];
      if(typeof _ak_[2] === "number")
       {var
         _af_=0,
         _ag_=function(k,param,acc){return [0,k,acc]},
         _ah_=caml_call3(Stdlib_Hashtbl[14],_ag_,_c_,_af_),
         _ai_=caml_call2(Stdlib_List[56],Stdlib_String[9],_ah_),
         _am_=caml_call1(Stdlib_Printf[2],_B_);
        caml_call2(Stdlib_List[17],_am_,_ai_);
        return 0}
      var _an_=log[1];
      if(_an_){var ch=_an_[1];caml_call1(Stdlib[76],ch)}
      print_delayed_errors(0);
      var _ao_=tests_failed[1],_ap_=test_modules_failed[1];
      if(0 === _ao_ && 0 === _ap_)
       {if(show_counts[1])
         caml_call3(Stdlib_Printf[3],_C_,tests_ran[1],test_modules_ran[1]);
        var
         _aq_=_al_[2],
         _ar_=function(param){var used=param[3];return 1 - used[1]},
         unused_tests=caml_call2(Stdlib_List[41],_ar_,_aq_),
         errors=unused_tests?[0,unused_tests]:0;
        if(errors)
         {var tests=errors[1];
          caml_call1(Stdlib_Printf[3],_D_);
          var
           _as_=
            function(param)
             {var line_number_opt=param[2],filename=param[1];
              if(! line_number_opt)
               return caml_call2(Stdlib_Printf[3],_F_,filename);
              var line_number=line_number_opt[1];
              return caml_call3(Stdlib_Printf[3],_E_,filename,line_number)};
          caml_call2(Stdlib_List[17],_as_,tests);
          caml_call1(Stdlib_Printf[3],_G_);
          return 2}
        if(0 === tests_ran[1] && strict[1])
         {caml_call1(Stdlib_Printf[3],_H_);return 2}
        return 0}
      if(0 === _ap_)
       var _at_=cst$14;
      else
       var
        _au_=caml_call2(Stdlib[98],_K_,_J_),
        _at_=caml_call2(Stdlib_Printf[4],_au_,_ap_);
      caml_call4(Stdlib_Printf[3],_I_,_ao_,tests_ran[1],_at_);
      return 1}
    var
     use_color$0=use_color[1],
     in_place$0=in_place[1],
     diff_command$0=diff_command[1],
     source_tree_root$0=source_tree_root[1],
     allow_output_patterns$0=allow_output_patterns[1],
     evaluators=[0,[0,summarize,0]];
    function add_evaluator(f){evaluators[1] = [0,f,evaluators[1]];return 0}
    function exit(param)
     {var _ac_=caml_call1(Stdlib_List[9],evaluators[1]);
      function _ad_(f){return caml_call1(f,0)}
      var param$0=combine_all(caml_call2(Stdlib_List[19],_ad_,_ac_));
      switch(param$0)
       {case 0:var _ae_=0;break;case 1:var _ae_=2;break;default:var _ae_=1}
      return caml_call1(Stdlib[99],_ae_)}
    var
     Ppx_inline_test_lib_Runtime=
      [0,
       [0,combine,combine_all,to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       testing,
       use_color$0,
       in_place$0,
       diff_command$0,
       source_tree_root$0,
       allow_output_patterns$0,
       _m_,
       am_running_inline_test_env_var,
       add_evaluator,
       exit];
    caml_register_global
     (125,Ppx_inline_test_lib_Runtime,"Ppx_inline_test_lib__Runtime");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlbmFibGVfZXZlcnl0aGluZyIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciIsInRvX3N0cmluZyIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0Iiwic2V0IiwidiIsImN1cnJlbnQiLCJmb3VuZF90ZXN0IiwiaXNfY3VycmVudCIsInAiLCJjdXJyZW50JDAiLCJ3aXRoJDAiLCJkZXNjciIsInRhZ3MiLCJmIiwicHJldiIsIngiLCJlIiwiY3VycmVudF90YWdzIiwibSIsInZlcmJvc2UiLCJzdHJpY3QiLCJzaG93X2NvdW50cyIsImxpc3RfdGVzdF9uYW1lcyIsImRlbGF5ZWRfZXJyb3JzIiwic3RvcF9vbl9lcnJvciIsImxvZyIsInRpbWVfc2VjIiwidXNlX2NvbG9yIiwiaW5fcGxhY2UiLCJkaWZmX2NvbW1hbmQiLCJzb3VyY2VfdHJlZV9yb290IiwiYWxsb3dfb3V0cHV0X3BhdHRlcm5zIiwiZGlzcGxheWVkX2Rlc2NyIiwiZmlsZW5hbWUiLCJsaW5lIiwic3RhcnRfcG9zIiwiZW5kX3BvcyIsInJlc3QiLCJsaWIiLCJ0ZXN0cyIsImxpc3RfcGFydGl0aW9ucyIsInBhcnRpdGlvbiIsInRhZ19wcmVkaWNhdGUiLCJuYW1lX2ZpbHRlciIsIm1zZyQxIiwiYW5vbiIsInMiLCJmaWxlIiwiaW5kZXgiLCJpbmRleCQwIiwiaSIsImZpbGVuYW1lJDAiLCJpbmRleF9zdHJpbmciLCJpbmRleCQxIiwibCIsImFyZ3YiLCJtc2ciLCJtc2ckMCIsInRlc3RpbmciLCJ3YWxsX3RpbWVfY2xvY2tfbnMiLCJ3aGVyZV90b19jdXRfYmFja3RyYWNlIiwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fIiwiYmVmb3JlX25zIiwicmVzIiwiZXhuIiwic2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUiLCJzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSIsInN0cmluZ19vZl9tb2R1bGVfZGVzY3IiLCJwcmludF9kZWxheWVkX2Vycm9ycyIsImRlbGF5ZWRfZXJyb3JzJDAiLCJtZXNzYWdlIiwiZXByaW50Zl9vcl9kZWxheSIsImZtdCIsImFkZF9ob29rcyIsIkMiLCJodW1fYmFja3RyYWNlIiwiYmFja3RyYWNlIiwic3RyIiwidGVzdF9pbm5lciIsImNvbmZpZyIsImRlZl9maWxlbmFtZSIsImRlZl9saW5lX251bWJlciIsImJvb2xfb2ZfZiIsIndoYXRfdG9fZG8iLCJ3aGljaF90YWdzIiwib25seV90ZXN0X2xvY2F0aW9uIiwibGlibmFtZSIsImYkMCIsImRlc2NyJDAiLCJ0YWdzJDAiLCJ1c2VkIiwibGluZV9udW1iZXJfb3B0IiwicG9zaXRpb25fc3RhcnQiLCJlbmRfb2ZfZGVmX2ZpbGVuYW1lIiwibGluZV9udW1iZXIiLCJmb3VuZCIsInJlcSIsImRyb3BwZWQiLCJzdWJzdHJpbmciLCJzaG91bGRfcnVuIiwiZGVzY3IkMSIsImNoIiwicmVzdWx0JDAiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwicmVzdWx0IiwiYmFja3RyYWNlJDAiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJ1bnVzZWRfdGVzdHMiLCJlcnJvcnMiLCJ1c2VfY29sb3IkMCIsImluX3BsYWNlJDAiLCJkaWZmX2NvbW1hbmQkMCIsInNvdXJjZV90cmVlX3Jvb3QkMCIsImFsbG93X291dHB1dF9wYXR0ZXJucyQwIiwiZXZhbHVhdG9ycyIsImFkZF9ldmFsdWF0b3IiLCJleGl0Il0sInNvdXJjZXMiOlsiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3BweF9pbmxpbmVfdGVzdC9ydW50aW1lLWxpYi9ydW50aW1lLm1sIl0sIm1hcHBpbmdzIjoiOzs7OztJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0RE1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrUEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEzU2lCLFNBTWZDO01BQVk7ZUFDRDtlQUNBO2dCQUNBLGlCQUFPO0lBVEgsU0FZZkMsUUFBUUMsR0FBR0M7TTtNQUNiLE9BRFVEO2VBRW1CLEtBRmhCQyxHQUVnQjs2QkFGaEJBLEdBSWdCO01BREEsUUFDTztJQWhCbkIsU0FtQmZDLFlBQVlDLElBQUssa0NBUGpCSixVQU9ZSSxHQUFzQztJQW5CbkM7Ozs7Ozs7O01BMEdMLHVEQURWTzs7Ozs7YUFHQUMsV0FNRixPQVRFRCxzQkFEQUQsU0FZVTthQUVWRyxJQUFJQyxHQUFJLFlBQUpBLEVBQUksUUFBVztJQVNiO2FBRU5FO01BQ0M7aUNBRkREO09BRUMsY0FBc0IsaUNBRnZCQTtNQUdBLDZDQUhBQSxrQkFHMkI7SUFKckIsU0FNTkU7TUFBYSxXQUNMO01BQ0UsSUFBTEM7TUFBSyx5QkFBTEEsRUFQTEgsV0FPc0I7SUFSaEIsSUE2Qk5JO0lBN0JNLFNBK0JOQyxPQUFPQyxN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VUFBWkQsRUFBS0MsSUFBZTtTQUF2Qzs7U0FpY1E7UUFBVjs7TUFYSSxTQTdZSi9GO01BMFo2RCxTQUc5QyxJQUFONEUsV0FBTSxzQkFBTkE7TUFFUDtNQWxCRSxJQWtCRixLQWpqQkZ2RyxnQkFpakJFLEtBbmpCRkY7O1FBcWpCWSxHQXRhWnlCO1NBdWEyQixnQ0FyakIzQnhCLGFBRkFGO1FBeWpCUzs7OEJBR2EsSUFBWStGLGNBQVosV0FBWUEsT0FBbUI7U0FBM0M7Z0JBREUrQjtRQU9OLEdBUklDO2NBU0duRixNQVRIbUY7VUFVRjs7OztjQUNVO21CQUFnQi9CO2VBRWQsdUNBRkkxRDtjQUFOLElBR0Q2RCxZQUhpQkg7Y0FHRix1Q0FIUjFELFNBR1A2RCxZQUNSO1VBSkQsZ0NBRkt2RDtVQU9MOztpQkF4a0JSMUMsZ0JBNklBdUI7VUErYlU7UUFFTztNQUtiOzs7T0FDeUQ7O2FBQWY7TUFEMUMscUNBbmxCSnZCO01BbWxCSSxRQUdEOztLQUVIOEgsWUFqY0FoRztLQWtjQWlHLFdBamNBaEc7S0FrY0FpRyxlQWpjQWhHO0tBa2NBaUcsbUJBamNBaEc7S0FrY0FpRyx3QkFqY0FoRztLQW1jQWlHLGlCQS9EQVY7YUFnRUFXLGNBQWVwSCxHQUFJLG1CQUFKQSxFQURmbUgsZUFDbUIsUUFBOEI7YUFDakRFO01BQ3VCLG1DQUh2QkY7TUFHdUIsY0FBWG5ILEdBQUssa0JBQUxBLElBQVM7TUFBdkIsWUEvbUJJcEIsWUErbUJKO01BbG9CbUI7O3dDQXFvQlo7Ozs7VUF6bkJISCxRQU9BRyxZQWJBSjtPQTZkRndIO09BdUJBSTtPQVVBQztPQUlBRTtPQUllQztPQWpOZjNEO09BOFRBaUU7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7O09BbFZBM0k7T0FxVkE2STtPQUNBQzs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgVGVzdF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3VjY2VzcyB8IEZhaWx1cmUgfCBFcnJvclxuXG4gIGxldCB0b19leGl0X2NvZGUgPSBmdW5jdGlvblxuICAgIHwgU3VjY2VzcyAtPiAwXG4gICAgfCBGYWlsdXJlIC0+IDJcbiAgICB8IEVycm9yICAgLT4gMVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgU3VjY2VzcyAtPiBcInN1Y2Nlc3NcIlxuICAgIHwgRmFpbHVyZSAtPiBcImZhaWx1cmVcIlxuICAgIHwgRXJyb3IgICAtPiBcImVycm9yXCJcbiAgOztcblxuICBsZXQgY29tYmluZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFN1Y2Nlc3MsIFN1Y2Nlc3MgICAgICAgIC0+IFN1Y2Nlc3NcbiAgICB8IEVycm9yICAsIF8gfCBfLCBFcnJvciAgIC0+IEVycm9yXG4gICAgfCBGYWlsdXJlLCBfIHwgXywgRmFpbHVyZSAtPiBGYWlsdXJlXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfYWxsIHRzID0gTGlzdC5mb2xkX2xlZnQgY29tYmluZSBTdWNjZXNzIHRzXG5lbmRcblxubGV0IHBhcnNlX2FyZ3YgYXJndiBsIGYgbXNnID1cbiAgdHJ5XG4gICAgQXJnLnBhcnNlX2FyZ3YgYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBBcmcuQmFkIG1zZyAtPiBQcmludGYuZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDFcbiAgfCBBcmcuSGVscCBtc2cgLT4gUHJpbnRmLnByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcbjs7XG5cbnR5cGUgZGVzY3IgPSBzdHJpbmdcbmxldCB0ZXN0X21vZHVsZXNfcmFuID0gcmVmIDBcbmxldCB0ZXN0X21vZHVsZXNfZmFpbGVkID0gcmVmIDBcbmxldCB0ZXN0c19yYW4gPSByZWYgMFxubGV0IHRlc3RzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgZHluYW1pY19saWIgOiBzdHJpbmcgb3B0aW9uIHJlZiA9IHJlZiBOb25lXG50eXBlIGZpbGVuYW1lID0gc3RyaW5nXG50eXBlIGxpbmVfbnVtYmVyID0gaW50XG50eXBlIHN0YXJ0X3BvcyA9IGludFxudHlwZSBlbmRfcG9zID0gaW50XG50eXBlIGNvbmZpZyA9IChtb2R1bGUgSW5saW5lX3Rlc3RfY29uZmlnLlMpXG50eXBlICdhIHRlc3RfZnVuY3Rpb25fYXJnc1xuICA9IGNvbmZpZzpjb25maWdcbiAgLT4gZGVzY3I6ZGVzY3IgTGF6eS50XG4gIC0+IHRhZ3M6c3RyaW5nIGxpc3RcbiAgLT4gZmlsZW5hbWU6ZmlsZW5hbWVcbiAgLT4gbGluZV9udW1iZXI6bGluZV9udW1iZXJcbiAgLT4gc3RhcnRfcG9zOnN0YXJ0X3Bvc1xuICAtPiBlbmRfcG9zOmVuZF9wb3NcbiAgLT4gJ2FcblxubW9kdWxlIFRhZ19wcmVkaWNhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHJlcXVpcmVkX3RhZ3MgIDogc3RyaW5nIGxpc3RcbiAgICA7IGRyb3BwZWRfdGFncyA6IHN0cmluZyBsaXN0XG4gICAgfVxuXG4gIGxldCBlbmFibGVfZXZlcnl0aGluZyA9IHsgcmVxdWlyZWRfdGFncyA9IFtdOyBkcm9wcGVkX3RhZ3MgPSBbXSB9XG5cbiAgbGV0IGRyb3AgdCB0YWcgPVxuICAgIHsgZHJvcHBlZF90YWdzID0gdGFnIDo6IHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gTGlzdC5maWx0ZXIgKCg8PikgdGFnKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB9XG5cbiAgbGV0IHJlcXVpcmUgdCB0YWcgPVxuICAgIHsgZHJvcHBlZF90YWdzID0gTGlzdC5maWx0ZXIgKCg8PikgdGFnKSB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IHRhZyA6OiB0LnJlcXVpcmVkX3RhZ3NcbiAgICB9XG5cbiAgbGV0IGVudGlyZV9tb2R1bGVfZGlzYWJsZWQgdCB+cGFydGlhbF90YWdzOnRhZ3MgPVxuICAgIExpc3QuZXhpc3RzIChmdW4gZHJvcHBlZCAtPiBMaXN0Lm1lbSBkcm9wcGVkIHRhZ3MpIHQuZHJvcHBlZF90YWdzXG5cbiAgbGV0IGRpc2FibGVkIHQgfmNvbXBsZXRlX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biByZXEgLT4gbm90IChMaXN0Lm1lbSByZXEgdGFncykpIHQucmVxdWlyZWRfdGFnc1xuICAgIHx8IExpc3QuZXhpc3RzIChmdW4gZHJvcHBlZCAtPiBMaXN0Lm1lbSBkcm9wcGVkIHRhZ3MpIHQuZHJvcHBlZF90YWdzXG5lbmRcblxuXG50eXBlIHdoaWNoX3Rlc3RzID1cbiAgeyBsaWJuYW1lIDogc3RyaW5nXG4gIDsgb25seV90ZXN0X2xvY2F0aW9uIDogKGZpbGVuYW1lICogbGluZV9udW1iZXIgb3B0aW9uICogYm9vbCByZWYpIGxpc3RcbiAgOyBuYW1lX2ZpbHRlciA6IHN0cmluZyBsaXN0XG4gIDsgd2hpY2hfdGFncyA6IFRhZ19wcmVkaWNhdGUudFxuICB9XG50eXBlIHRlc3RfbW9kZSA9XG4gIHsgd2hpY2hfdGVzdHMgOiB3aGljaF90ZXN0c1xuICA7IHdoYXRfdG9fZG8gOlxuICAgICAgWyBgUnVuX3BhcnRpdGlvbiBvZiBzdHJpbmcgb3B0aW9uXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnNcbiAgICAgIF1cbiAgfVxuXG5tb2R1bGUgQWN0aW9uIDogc2lnXG4gIHR5cGUgdCA9IFtcbiAgICB8IGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gIF1cbiAgdmFsIGdldCA6IHVuaXQgLT4gdFxuICB2YWwgc2V0IDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gW1xuICAgIHwgYElnbm9yZVxuICAgIHwgYFRlc3RfbW9kZSBvZiB0ZXN0X21vZGVcbiAgXVxuICBsZXQgYWN0aW9uIDogdCByZWYgPSByZWYgYElnbm9yZVxuICBsZXQgZm9yY2VfZHJvcCA9XG4gICAgdHJ5IGlnbm9yZSAoU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIiA6IHN0cmluZyk7IHRydWVcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuICBsZXQgZ2V0ICgpID1cbiAgICAoKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGNvbXBpbGluZyB0byBqYXZhc2NyaXB0LlxuICAgICAgIEpzX29mX29jYW1sIGNhbiBzdGF0aWNhbGx5IGV2YWx1YXRlIFtTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9JTkxJTkVfVEVTVFwiXVxuICAgICAgIGFuZCBpbmxpbmUgdGhlIHJlc3VsdCAoW2BJZ25vcmVdKSB3aGVuZXZlciBbZ2V0ICgpXSBpcyBjYWxsZWQuXG4gICAgICAgVW5pdCB0ZXN0cyBjYW4gdGhlbiBiZSB0cmVhdGVkIGFzIGRlYWRjb2RlIHNpbmNlIHRoZSBhcmd1bWVudCBbZl0gb2YgdGhlIFt0ZXN0XVxuICAgICAgIGZ1bmN0aW9uIGJlbG93IGlzIG5ldmVyIHVzZWQuICopXG4gICAgaWYgZm9yY2VfZHJvcFxuICAgIHRoZW4gYElnbm9yZVxuICAgIGVsc2UgIWFjdGlvblxuXG4gIGxldCBzZXQgdiA9IGFjdGlvbiA6PSB2XG5lbmRcblxubW9kdWxlIFBhcnRpdGlvbiA6IHNpZ1xuICB2YWwgZm91bmRfdGVzdCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgc2V0X2N1cnJlbnQgOiBzdHJpbmcgLT4gdW5pdFxuICB2YWwgaXNfY3VycmVudCA6IHN0cmluZyBvcHRpb24gLT4gYm9vbFxuICB2YWwgYWxsIDogdW5pdCAtPiBzdHJpbmcgbGlzdFxuZW5kID0gc3RydWN0XG4gIGxldCBhbGwgPSBIYXNodGJsLmNyZWF0ZSAyM1xuICBsZXQgY3VycmVudCA9IHJlZiBcIlwiICBsZXQgc2V0X2N1cnJlbnQgeCA9IGN1cnJlbnQgOj0geFxuICBsZXQgZm91bmRfdGVzdCAoKSA9XG4gICAgaWYgIWN1cnJlbnQgPD4gXCJcIiAmJiBub3QgKEhhc2h0YmwubWVtIGFsbCAhY3VycmVudCkgdGhlblxuICAgICAgSGFzaHRibC5hZGQgYWxsICFjdXJyZW50ICgpXG4gIDs7XG4gIGxldCBpc19jdXJyZW50ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBwIC0+IHAgPSAhY3VycmVudFxuICA7O1xuICBsZXQgYWxsICgpID1cbiAgICBMaXN0LnNvcnQgU3RyaW5nLmNvbXBhcmVcbiAgICAgIChIYXNodGJsLmZvbGQgKGZ1biBrICgpIGFjYyAtPiBrIDo6IGFjYykgYWxsIFtdKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNb2R1bGVfY29udGV4dCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgb25lX21vZHVsZSA9XG4gICAgICB7IGRlc2NyIDogc3RyaW5nXG4gICAgICA7IHRhZ3MgOiBzdHJpbmcgbGlzdFxuICAgICAgfVxuXG4gICAgdHlwZSB0ID0gb25lX21vZHVsZSBsaXN0XG5cbiAgICBsZXQgZGVzY3IgdCA9IExpc3QubWFwIChmdW4gbSAtPiBtLmRlc2NyKSB0XG4gICAgbGV0IHRhZ3MgdCA9IExpc3QuY29uY2F0IChMaXN0Lm1hcCAoZnVuIG0gLT4gbS50YWdzKSB0KVxuICBlbmRcblxuICBsZXQgY3VycmVudCA6IFQudCByZWYgPSByZWYgW11cblxuICBsZXQgd2l0aF8gfmRlc2NyIH50YWdzIGYgPVxuICAgIGxldCBwcmV2ID0gIWN1cnJlbnQgaW5cbiAgICBjdXJyZW50IDo9IHsgVC4gZGVzY3I7IHRhZ3MgfSA6OiBwcmV2O1xuICAgIHRyeVxuICAgICAgbGV0IHggPSBmICgpIGluXG4gICAgICBjdXJyZW50IDo9IHByZXY7XG4gICAgICB4XG4gICAgd2l0aCBlIC0+XG4gICAgICBjdXJyZW50IDo9IHByZXY7XG4gICAgICByYWlzZSBlXG5cbiAgbGV0IGN1cnJlbnRfZGVzY3IgKCkgPSBULmRlc2NyICFjdXJyZW50XG4gIGxldCBjdXJyZW50X3RhZ3MgICgpID0gVC50YWdzICAhY3VycmVudFxuZW5kXG5cbmxldCB2ZXJib3NlID0gcmVmIGZhbHNlXG5sZXQgc3RyaWN0ID0gcmVmIGZhbHNlXG5sZXQgc2hvd19jb3VudHMgPSByZWYgZmFsc2VcbmxldCBsaXN0X3Rlc3RfbmFtZXMgPSByZWYgZmFsc2VcbmxldCBkZWxheWVkX2Vycm9ycyA9IHJlZiBbXVxubGV0IHN0b3Bfb25fZXJyb3IgPSByZWYgZmFsc2VcblxubGV0IGxvZyA9IHJlZiBOb25lXG5cbmxldCB0aW1lX3NlYyA9IHJlZiAwLlxuXG5sZXQgdXNlX2NvbG9yID0gcmVmIHRydWVcbmxldCBpbl9wbGFjZSAgPSByZWYgZmFsc2VcbmxldCBkaWZmX2NvbW1hbmQgPSByZWYgTm9uZVxubGV0IHNvdXJjZV90cmVlX3Jvb3QgPSByZWYgTm9uZVxubGV0IGFsbG93X291dHB1dF9wYXR0ZXJucyA9IHJlZiBmYWxzZVxuXG5sZXQgZGlzcGxheWVkX2Rlc2NyIChsYXp5IGRlc2NyKSBmaWxlbmFtZSBsaW5lIHN0YXJ0X3BvcyBlbmRfcG9zID1cbiAgUHJpbnRmLnNwcmludGYgXCJGaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkJXNcIlxuICAgIGZpbGVuYW1lIGxpbmUgc3RhcnRfcG9zIGVuZF9wb3NcbiAgICAoaWYgZGVzY3IgPSBcIlwiIHRoZW4gXCJcIiBlbHNlIFwiOiBcIiBeIGRlc2NyKVxubGV0IHBhcnNlX2Rlc2NyIHN0ciA9XG4gIHRyeSBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgLCBsaW5lICVkICwgY2hhcmFjdGVycyAlZCAtICVkICUhXCJcbiAgICAgICAgICAgICAgKGZ1biBmaWxlIGxpbmUgX3N0YXJ0X3BvcyBfZW5kX3BvcyAtPiBmaWxlLCBTb21lIGxpbmUpKVxuICB3aXRoIF8gLT5cbiAgdHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAsIGxpbmUgJWQgJSFcIiAoZnVuIGZpbGUgbGluZSAtPiBmaWxlLCBTb21lIGxpbmUpKVxuICB3aXRoIF8gLT5cbiAgdHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAlIVwiIChmdW4gZmlsZSAtPiBmaWxlLCBOb25lKSlcbiAgd2l0aCBfIC0+IE5vbmVcblxubGV0ICgpID1cbiAgbWF0Y2ggQXJyYXkudG9fbGlzdCBTeXMuYXJndiB3aXRoXG4gIHwgbmFtZSA6OiBcImlubGluZS10ZXN0LXJ1bm5lclwiIDo6IGxpYiA6OiByZXN0XG4gICAgd2hlbiBCYXNlLkV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzLmFtX3Rlc3RpbmcgLT4gYmVnaW5cbiAgICAgICgqIHdoZW4gd2Ugc2VlIHRoaXMgYXJndW1lbnQsIHdlIHN3aXRjaCB0byB0ZXN0IG1vZGUgKilcbiAgICAgIGxldCB0ZXN0cyA9IHJlZiBbXSBpblxuICAgICAgbGV0IGxpc3RfcGFydGl0aW9ucyA9IHJlZiBmYWxzZSBpblxuICAgICAgbGV0IHBhcnRpdGlvbiA9IHJlZiBOb25lIGluXG4gICAgICBsZXQgdGFnX3ByZWRpY2F0ZSA9IHJlZiBUYWdfcHJlZGljYXRlLmVuYWJsZV9ldmVyeXRoaW5nIGluXG4gICAgICBsZXQgbmFtZV9maWx0ZXIgPSByZWYgW10gaW5cbiAgICAgIHBhcnNlX2FyZ3YgKEFycmF5Lm9mX2xpc3QgKG5hbWUgOjogcmVzdCkpIChBcmcuYWxpZ24gW1xuICAgICAgICBcIi1saXN0LXRlc3QtbmFtZXNcIiwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3Rlc3RfbmFtZXMgOj0gdHJ1ZTsgdmVyYm9zZSA6PSB0cnVlKSxcbiAgICAgICAgXCIgRG8gbm90IHJ1biB0ZXN0cyBidXQgc2hvdyB3aGF0IHdvdWxkIGhhdmUgYmVlbiBydW5cIjtcbiAgICAgICAgXCItbGlzdC1wYXJ0aXRpb25zXCIsIEFyZy5Vbml0IChmdW4gKCkgLT4gbGlzdF9wYXJ0aXRpb25zIDo9IHRydWUpLFxuICAgICAgICBcIiBMaXN0cyBhbGwgdGhlIHBhcnRpdGlvbnMgdGhhdCBjb250YWluIGF0IGxlYXN0IG9uZSB0ZXN0IG9yIHRlc3RfbW9kdWxlXCI7XG4gICAgICAgIFwiLXBhcnRpdGlvblwiLCBBcmcuU3RyaW5nIChmdW4gaSAtPiBwYXJ0aXRpb24gOj0gU29tZSBpKSxcbiAgICAgICAgXCIgT25seSBydW4gdGhlIHRlc3RzIGluIHRoZSBnaXZlbiBwYXJ0aXRpb25cIjtcbiAgICAgICAgXCItdmVyYm9zZVwiLCBBcmcuU2V0IHZlcmJvc2UsIFwiIFNob3cgdGhlIHRlc3RzIGFzIHRoZXkgcnVuXCI7XG4gICAgICAgIFwiLXN0b3Atb24tZXJyb3JcIiwgQXJnLlNldCBzdG9wX29uX2Vycm9yLCBcIiBSdW4gdGVzdHMgb25seSB1cCB0byB0aGUgZmlyc3QgZXJyb3IgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvZXNuJ3Qgd29yayBmb3IgZXhwZWN0IHRlc3RzKVwiO1xuICAgICAgICBcIi1zdHJpY3RcIiwgQXJnLlNldCBzdHJpY3QsIFwiIEVuZCB3aXRoIGFuIGVycm9yIGlmIG5vIHRlc3RzIHdlcmUgcnVuXCI7XG4gICAgICAgIFwiLXNob3ctY291bnRzXCIsIEFyZy5TZXQgc2hvd19jb3VudHMsIFwiIFNob3cgdGhlIG51bWJlciBvZiB0ZXN0cyByYW5cIjtcbiAgICAgICAgXCItbG9nXCIsIEFyZy5Vbml0IChmdW4gKCkgLT5cbiAgICAgICAgICAodHJ5IFN5cy5yZW1vdmUgXCJpbmxpbmVfdGVzdHMubG9nXCIgd2l0aCBfIC0+ICgpKTtcbiAgICAgICAgICBsb2cgOj0gU29tZSAob3Blbl9vdXQgXCJpbmxpbmVfdGVzdHMubG9nXCIpXG4gICAgICAgICksIFwiIExvZyB0aGUgdGVzdHMgcnVuIGluIGlubGluZV90ZXN0cy5sb2dcIjtcbiAgICAgICAgXCItZHJvcC10YWdcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT5cbiAgICAgICAgICB0YWdfcHJlZGljYXRlIDo9IFRhZ19wcmVkaWNhdGUuZHJvcCAhdGFnX3ByZWRpY2F0ZSBzXG4gICAgICAgICksIFwidGFnIE9ubHkgcnVuIHRlc3RzIG5vdCB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1yZXF1aXJlLXRhZylcIjtcbiAgICAgICAgXCItcmVxdWlyZS10YWdcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT5cbiAgICAgICAgICB0YWdfcHJlZGljYXRlIDo9IFRhZ19wcmVkaWNhdGUucmVxdWlyZSAhdGFnX3ByZWRpY2F0ZSBzXG4gICAgICAgICksIFwidGFnIE9ubHkgcnVuIHRlc3RzIHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLWRyb3AtdGFnKVwiO1xuICAgICAgICBcIi1tYXRjaGluZ1wiLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBuYW1lX2ZpbHRlciA6PSBzIDo6ICFuYW1lX2ZpbHRlciksXG4gICAgICAgIFwic3Vic3RyaW5nIE9ubHkgcnVuIHRlc3RzIHdob3NlIG5hbWVzIGNvbnRhaW4gdGhlIGdpdmVuIHN1YnN0cmluZ1wiO1xuICAgICAgICBcIi1vbmx5LXRlc3RcIiwgQXJnLlN0cmluZyAoZnVuIHMgLT5cbiAgICAgICAgICBsZXQgZmlsZW5hbWUsIGluZGV4ID1cbiAgICAgICAgICAgIG1hdGNoIHBhcnNlX2Rlc2NyIHMgd2l0aFxuICAgICAgICAgICAgfCBTb21lIChmaWxlLCBpbmRleCkgLT4gZmlsZSwgaW5kZXhcbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgcyAnOicgdGhlblxuICAgICAgICAgICAgICAgIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJzonIGluXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gU3RyaW5nLnN1YiBzIDAgaSBpblxuICAgICAgICAgICAgICAgIGxldCBpbmRleF9zdHJpbmcgPSBTdHJpbmcuc3ViIHMgKGkgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gaSAtIDEpIGluXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID1cbiAgICAgICAgICAgICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIGluZGV4X3N0cmluZ1xuICAgICAgICAgICAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT5cbiAgICAgICAgICAgICAgICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgICAgICAgICAgICAgICBcIkFyZ3VtZW50ICVzIGRvZXNuJ3QgZml0IHRoZSBmb3JtYXQgZmlsZW5hbWVbOmxpbmVfbnVtYmVyXVxcbiUhXCIgcztcbiAgICAgICAgICAgICAgICAgICAgZXhpdCAxXG4gICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBmaWxlbmFtZSwgU29tZSBpbmRleFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcywgTm9uZVxuICAgICAgICAgIGluXG4gICAgICAgICAgdGVzdHMgOj0gKGZpbGVuYW1lLCBpbmRleCwgcmVmIGZhbHNlKSA6OiAhdGVzdHNcbiAgICAgICAgKSwgXCJsb2NhdGlvbiBSdW4gb25seSB0aGUgdGVzdHMgc3BlY2lmaWVkIGJ5IGFsbCB0aGUgLW9ubHktdGVzdCBvcHRpb25zLlxuICAgICAgICAgICAgICAgICAgICAgIExvY2F0aW9ucyBjYW4gYmUgb25lIG9mIHRoZXNlIGZvcm1zOlxuICAgICAgICAgICAgICAgICAgICAgIC0gZmlsZS5tbFxuICAgICAgICAgICAgICAgICAgICAgIC0gZmlsZS5tbDpsaW5lX251bWJlclxuICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCJcbiAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzXG4gICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIiwgbGluZSAyMywgY2hhcmFjdGVycyAyLTNcIjtcbiAgICAgICAgXCItbm8tY29sb3JcIiwgQXJnLkNsZWFyIHVzZV9jb2xvciwgXCIgU3VtbWFyaXplIHRlc3RzIHdpdGhvdXQgdXNpbmcgY29sb3JcIjtcbiAgICAgICAgXCItaW4tcGxhY2VcIiwgQXJnLlNldCBpbl9wbGFjZSwgXCIgVXBkYXRlIGV4cGVjdCB0ZXN0cyBpbiBwbGFjZVwiO1xuICAgICAgICBcIi1kaWZmLWNtZFwiLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBkaWZmX2NvbW1hbmQgOj0gU29tZSBzKSxcbiAgICAgICAgXCIgRGlmZiBjb21tYW5kIGZvciB0ZXN0cyB0aGF0IHJlcXVpcmUgZGlmZmluZyAodXNlIC0gdG8gZGlzYWJsZSBkaWZmaW5nKVwiO1xuICAgICAgICBcIi1hbGxvdy1vdXRwdXQtcGF0dGVybnNcIiwgQXJnLlNldCBhbGxvd19vdXRwdXRfcGF0dGVybnMsXG4gICAgICAgIFwiIEFsbG93IG91dHB1dCBwYXR0ZXJucyBpbiB0ZXN0cyBleHBlY3RhdGlvbnNcIjtcbiAgICAgICAgXCItc291cmNlLXRyZWUtcm9vdFwiLCBBcmcuU3RyaW5nIChmdW4gcyAtPiBzb3VyY2VfdHJlZV9yb290IDo9IFNvbWUgcyksXG4gICAgICAgIFwiIFBhdGggdG8gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZSB0cmVlXCJcbiAgICAgIF0pIChmdW4gYW5vbiAtPlxuICAgICAgICBQcmludGYuZXByaW50ZiBcIiVzOiB1bmV4cGVjdGVkIGFub255bW91cyBhcmd1bWVudCAlc1xcbiUhXCIgbmFtZSBhbm9uO1xuICAgICAgICBleGl0IDFcbiAgICAgICkgKFByaW50Zi5zcHJpbnRmIFwiJXMgJXMgJXMgW2FyZ3NdXCIgbmFtZSBcImlubGluZS10ZXN0LXJ1bm5lclwiIGxpYik7XG4gICAgICBBY3Rpb24uc2V0IChcbiAgICAgICAgYFRlc3RfbW9kZVxuICAgICAgICAgIHsgd2hpY2hfdGVzdHMgPVxuICAgICAgICAgICAgICB7IGxpYm5hbWUgPSBsaWJcbiAgICAgICAgICAgICAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gPSAhdGVzdHM7XG4gICAgICAgICAgICAgICAgd2hpY2hfdGFncyA9ICF0YWdfcHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIG5hbWVfZmlsdGVyID0gIW5hbWVfZmlsdGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHdoYXRfdG9fZG8gPVxuICAgICAgICAgICAgICBpZiAhbGlzdF9wYXJ0aXRpb25zXG4gICAgICAgICAgICAgIHRoZW4gYExpc3RfcGFydGl0aW9uc1xuICAgICAgICAgICAgICBlbHNlIGBSdW5fcGFydGl0aW9uICFwYXJ0aXRpb25cbiAgICAgICAgICB9KVxuICAgIGVuZFxuICB8IF8gLT5cbiAgICAoKVxuXG5sZXQgYW1fdGVzdF9ydW5uZXIgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgVGVzdF9tb2RlIF8gLT4gdHJ1ZVxuICB8IGBJZ25vcmUgLT4gZmFsc2VcblxubGV0IGFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciA9XG4gICgqIGZvciBhcHByb3hpbWF0ZSBjb21wYXRpYmlsaXR5LCBnaXZlbiB0aGF0IHRoZSB2YXJpYWJsZSBpcyBub3QgZXhhY3RseSBlcXVpdmFsZW50XG4gICAgIHRvIHdoYXQgUFBYX0lOTElORV9URVNUX0xJQl9BTV9SVU5OSU5HX0lOTElORV9URVNUIHVzZWQgdG8gYmUgKilcbiAgXCJURVNUSU5HX0ZSQU1FV09SS1wiXG5cbigqIFRoaXMgdmFsdWUgaXMgZGVwcmVjYXRlZCBpbiBwcmluY2lwbGUsIGluIGZhdm9yIG9mIENvcmUuYW1fcnVubmluZ190ZXN0LCBzb1xuICAgd2UncmUgZ29pbmcgdG8gbGl2ZSB3aXRoIHRoZSB1Z2x5IHBhdHRlcm4gbWF0Y2guICopXG5sZXQgYW1fcnVubmluZ19pbmxpbmVfdGVzdCA9XG4gIG1hdGNoIFN5cy5nZXRlbnYgXCJQUFhfSU5MSU5FX1RFU1RfTElCX0FNX1JVTk5JTkdfSU5MSU5FX1RFU1RcIiB3aXRoXG4gIHwgKF8gOiBzdHJpbmcpIC0+IHRydWUgKCogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwZW9wbGUgc2V0dGluZyB0aGlzIHZhcmlhYmxlIGRpcmVjdGx5ICopXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgIG1hdGNoIFN5cy5nZXRlbnYgYW1fcnVubmluZ19pbmxpbmVfdGVzdF9lbnZfdmFyIHdpdGhcbiAgICB8IFwiaW5saW5lLXRlc3RcIiAtPiB0cnVlXG4gICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGZhbHNlXG4gICAgfCBfIC0+IGZhbHNlXG5cbmxldCB0ZXN0aW5nID1cbiAgaWYgYW1fdGVzdF9ydW5uZXJcbiAgdGhlbiBgVGVzdGluZyBgQW1fdGVzdF9ydW5uZXJcbiAgZWxzZVxuICAgIChpZiBhbV9ydW5uaW5nX2lubGluZV90ZXN0XG4gICAgIHRoZW4gYFRlc3RpbmcgYEFtX2NoaWxkX29mX3Rlc3RfcnVubmVyXG4gICAgIGVsc2UgYE5vdF90ZXN0aW5nKVxuXG5sZXQgd2FsbF90aW1lX2Nsb2NrX25zICgpID1cbiAgVGltZV9ub3cubmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaCAoKVxuXG5cbmxldCB3aGVyZV90b19jdXRfYmFja3RyYWNlID0gbGF6eSAoXG4gIEJhc2UuU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSAoX19NT0RVTEVfXyBeIFwiLlwiIF4gXCJ0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkc1wiKSlcblxubGV0IHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYgPVxuICBsZXQgYmVmb3JlX25zID0gd2FsbF90aW1lX2Nsb2NrX25zICgpIGluXG4gIGxldCByZXMgPVxuICAgICgqIFRvIGF2b2lkIG5vaXNlIGluIGJhY2t0cmFjZXMsIHdlIGRvIHR3byB0aGluZ3MuXG5cbiAgICAgICBXZSB1c2UgW3doZXJlX3RvX2N1dF9iYWNrdHJhY2VdIGFib3ZlIHRvIHJlbW92ZSB0aGUgc3RhY2sgZnJhbWVzIGZvciB0aGUgY3VycmVudFxuICAgICAgIGZ1bmN0aW9uIGFuZCBhbnkgZnVuY3Rpb24gaXQgZ2V0cyBpbmxpbmVkIGludG8sIGFzIGl0J3Mgbm90IG9mIGFueSBpbnRlcmVzdCB0byB0aGVcbiAgICAgICB1c2VyLCBzaW5jZSBpdCdzIG5vdCB0YWxraW5nIGFib3V0IHRoZWlyIHRlc3QgYnV0IGluc3RlYWQgdGFsa2luZyBhYm91dCB0aGVcbiAgICAgICBwcHhfaW5saW5lX3Rlc3QgbWFjaGluZXJ5LlxuXG4gICAgICAgV2UgYWxzbyBhdm9pZCBpbnNlcnRpbmcgYW55IGNvZGUgYmV0d2VlbiB0aGUgW2ZdIHRoYXQgY29tZXMgZnJvbSB0aGUgdXNlcidzIGZpbGVcbiAgICAgICBhbmQgZ3JhYmJpbmcgdGhlIGJhY2t0cmFjZSBmcm9tIGl0cyBleGNlcHRpb25zIChubyB3cmFwcGluZyBvZiBbZl0gd2l0aCBoaWdoIG9yZGVyXG4gICAgICAgZnVuY3Rpb25zIGxpa2UgRXhuLnByb3RlY3QsIG9yIChmdW4gKCkgLT4gZiAoKTsgdHJ1ZSkpLiAqKVxuICAgIHRyeSBPayAoZiAoKSlcbiAgICB3aXRoIGV4biAtPiBFcnJvciAoZXhuLCBQcmludGV4Yy5nZXRfYmFja3RyYWNlICgpKVxuICBpblxuICB0aW1lX3NlYyA6PSBCYXNlLkludDYzLih3YWxsX3RpbWVfY2xvY2tfbnMgKCkgLSBiZWZvcmVfbnMgfD4gdG9fZmxvYXQpICAvLiAxZTk7XG4gIHJlc1xuXG5cbmxldCBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSA9IGxhenkgKFN0ZGxpYi5SYW5kb20uU3RhdGUubWFrZSBbfCAxMDA7IDIwMDsgMzAwIHxdKVxubGV0IHNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlID0gbGF6eSAoQmFzZS5SYW5kb20uU3RhdGUubWFrZSBbfCAxMTE7IDIyMjsgMzMzIHxdKVxuXG5sZXQgdGltZV9hbmRfcmVzZXRfcmFuZG9tX3NlZWRzIGYgPVxuICBsZXQgY2FtbF9yYW5kb21fc3RhdGUgPSBTdGRsaWIuUmFuZG9tLmdldF9zdGF0ZSAoKSBpblxuICBsZXQgYmFzZV9yYW5kb21fc3RhdGUgPSBCYXNlLlJhbmRvbS5TdGF0ZS5jb3B5IEJhc2UuUmFuZG9tLlN0YXRlLmRlZmF1bHQgaW5cbiAgU3RkbGliLlJhbmRvbS5zZXRfc3RhdGUgKExhenkuZm9yY2Ugc2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUpO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgKExhenkuZm9yY2Ugc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUpO1xuICBsZXQgcmVzdWx0ID0gdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSBjYW1sX3JhbmRvbV9zdGF0ZTtcbiAgQmFzZS5SYW5kb20uc2V0X3N0YXRlIGJhc2VfcmFuZG9tX3N0YXRlO1xuICByZXN1bHRcblxubGV0IHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkgPVxuICBTdHJpbmcuY29uY2F0IFwiXCIgKFxuICAgIExpc3QubWFwIChmdW4gcyAtPiBcIiAgaW4gVEVTXCIgXiBcIlRfTU9EVUxFIGF0IFwiIF4gU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBzIF4gXCJcXG5cIilcbiAgICAgIChNb2R1bGVfY29udGV4dC5jdXJyZW50X2Rlc2NyICgpKVxuICApXG5cbmxldCBwb3NpdGlvbl9tYXRjaCBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIGwgPVxuICBMaXN0LmV4aXN0cyAoZnVuIChmaWxlbmFtZSwgbGluZV9udW1iZXJfb3B0LCB1c2VkKSAtPlxuICAgIGxldCBwb3NpdGlvbl9zdGFydCA9XG4gICAgICBTdHJpbmcubGVuZ3RoIGRlZl9maWxlbmFtZSAtIFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBsZXQgZm91bmQgPVxuICAgICAgcG9zaXRpb25fc3RhcnQgPj0gMCAmJlxuICAgICAgbGV0IGVuZF9vZl9kZWZfZmlsZW5hbWUgPVxuICAgICAgICBTdHJpbmcuc3ViIGRlZl9maWxlbmFtZVxuICAgICAgICAgIHBvc2l0aW9uX3N0YXJ0XG4gICAgICAgICAgKFN0cmluZy5sZW5ndGggZmlsZW5hbWUpIGluXG4gICAgICBlbmRfb2ZfZGVmX2ZpbGVuYW1lID0gZmlsZW5hbWVcbiAgICAgICYmIChwb3NpdGlvbl9zdGFydCA9IDAgfHwgZGVmX2ZpbGVuYW1lLltwb3NpdGlvbl9zdGFydCAtIDFdID0gJy8nKVxuICAgICAgJiYgKG1hdGNoIGxpbmVfbnVtYmVyX29wdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgIHwgU29tZSBsaW5lX251bWJlciAtPiBkZWZfbGluZV9udW1iZXIgPSBsaW5lX251bWJlcilcbiAgICBpblxuICAgIGlmIGZvdW5kIHRoZW4gdXNlZCA6PSB0cnVlO1xuICAgIGZvdW5kXG4gICkgbFxuXG5sZXQgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIGRlc2NyID1cbiAgbWF0Y2ggbmFtZV9maWx0ZXIgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBfIDo6IF8gLT5cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHN1YnN0cmluZyAtPiBCYXNlLlN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZyBkZXNjcikgbmFtZV9maWx0ZXJcblxubGV0IHByaW50X2RlbGF5ZWRfZXJyb3JzICgpID1cbiAgbWF0Y2ggTGlzdC5yZXYgIWRlbGF5ZWRfZXJyb3JzIHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IF8gOjogXyBhcyBkZWxheWVkX2Vycm9ycyAtPlxuICAgIFByaW50Zi5lcHJpbnRmIFwiXFxuJXNcXG4lIVwiIChTdHJpbmcubWFrZSA3MCAnPScpO1xuICAgIExpc3QuaXRlciAoZnVuIG1lc3NhZ2UgLT5cbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIG1lc3NhZ2VcbiAgICApIGRlbGF5ZWRfZXJyb3JzXG5cbmxldCBlcHJpbnRmX29yX2RlbGF5IGZtdCA9XG4gIFByaW50Zi5rc3ByaW50ZiAoZnVuIHMgLT5cbiAgICBpZiAhdmVyYm9zZSB0aGVuIGRlbGF5ZWRfZXJyb3JzIDo9IHMgOjogIWRlbGF5ZWRfZXJyb3JzXG4gICAgZWxzZSBQcmludGYuZXByaW50ZiBcIiVzJSFcIiBzO1xuICAgIGlmICFzdG9wX29uX2Vycm9yIHRoZW4gYmVnaW5cbiAgICAgIHByaW50X2RlbGF5ZWRfZXJyb3JzICgpO1xuICAgICAgZXhpdCAyXG4gICAgZW5kXG4gICkgZm10XG5cbmxldCBhZGRfaG9va3MgKChtb2R1bGUgQykgOiBjb25maWcpIGYgPVxuICBmdW4gKCkgLT4gQy5wcmVfdGVzdF9ob29rICgpOyBmICgpXG5cbmxldCBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSA9XG4gIGxldCBvcGVuIEJhc2UgaW5cbiAgYmFja3RyYWNlXG4gIHw+IFN0cmluZy5zcGxpdF9saW5lc1xuICB8PiBMaXN0LnRha2Vfd2hpbGUgfmY6KGZ1biBzdHIgLT5cbiAgICBub3QgKFN0cmluZy5TZWFyY2hfcGF0dGVybi5tYXRjaGVzIChmb3JjZSB3aGVyZV90b19jdXRfYmFja3RyYWNlKSBzdHIpKVxuICB8PiBMaXN0Lm1hcCB+ZjooZnVuIHN0ciAtPiBcIiAgXCIgXiBzdHIgXiBcIlxcblwiKVxuICB8PiBTdHJpbmcuY29uY2F0XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X2lubmVyIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZTpkZWZfZmlsZW5hbWUgfmxpbmVfbnVtYmVyOmRlZl9saW5lX251bWJlclxuICAgICAgICAgICAgICAgICAgICAgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmIGJvb2xfb2ZfZiA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbjsgd2hpY2hfdGFnczsgbmFtZV9maWx0ZXIgfTsgd2hhdF90b19kbyB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgPSBsYXp5IChkaXNwbGF5ZWRfZGVzY3IgZGVzY3IgZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBzdGFydF9wb3MgZW5kX3BvcykgaW5cbiAgICBsZXQgY29tcGxldGVfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICYmIGJlZ2luIG1hdGNoIG9ubHlfdGVzdF9sb2NhdGlvbiB3aXRoXG4gICAgICAgIHwgW10gLT4gdHJ1ZVxuICAgICAgICB8IF8gOjogXyAtPiBwb3NpdGlvbl9tYXRjaCBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIG9ubHlfdGVzdF9sb2NhdGlvblxuICAgICAgZW5kXG4gICAgICAmJiBub3QgKFRhZ19wcmVkaWNhdGUuZGlzYWJsZWQgd2hpY2hfdGFncyB+Y29tcGxldGVfdGFncylcbiAgICAgICYmIG5hbWVfZmlsdGVyX21hdGNoIH5uYW1lX2ZpbHRlciAoTGF6eS5mb3JjZSBkZXNjcilcbiAgICBpblxuICAgIGlmIHNob3VsZF9ydW4gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvbiB0aGVuIGJlZ2luXG4gICAgICAgICAgbGV0IGRlc2NyID0gTGF6eS5mb3JjZSBkZXNjciBpblxuICAgICAgICAgIGluY3IgdGVzdHNfcmFuO1xuICAgICAgICAgIGJlZ2luIG1hdGNoICFsb2cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBjaCAtPiBQcmludGYuZnByaW50ZiBjaCBcIiVzXFxuJXNcIiBkZXNjciAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSlcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBiZWdpblxuICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcIiVzJSFcIiBkZXNjclxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBsZXQgcmVzdWx0ID1cbiAgICAgICAgICAgIGlmICFsaXN0X3Rlc3RfbmFtZXNcbiAgICAgICAgICAgIHRoZW4gT2sgdHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoKiBTZWUgW3RpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzXSBmb3Igd2h5IHdlIHVzZSBbYm9vbF9vZl9mXVxuICAgICAgICAgICAgICAgICByYXRoZXIgaGF2ZSB0aGUgY2FsbGVyIHdyYXAgW2ZdIHRvIGFkanVzdCBpdHMgcmV0dXJuIHZhbHVlLiAqKVxuICAgICAgICAgICAgICBSZXN1bHQubWFwIGJvb2xfb2ZfZiAodGltZV9hbmRfcmVzZXRfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBJZiAhbGlzdF90ZXN0X25hbWVzLCB0aGlzIGlzIGlzIGEgaGFybWxlc3MgemVyby4gKilcbiAgICAgICAgICBpZiAhdmVyYm9zZSB0aGVuIFByaW50Zi5wcmludGYgXCIgKCUuM2Ygc2VjKVxcbiUhXCIgIXRpbWVfc2VjO1xuICAgICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgICAgfCBPayB0cnVlIC0+ICgpXG4gICAgICAgICAgfCBPayBmYWxzZSAtPlxuICAgICAgICAgICAgaW5jciB0ZXN0c19mYWlsZWQ7XG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5IFwiJXMgaXMgZmFsc2UuXFxuJXNcXG4lIVwiIGRlc2NyXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICAgIHwgRXJyb3IgKGV4biwgYmFja3RyYWNlKSAtPlxuICAgICAgICAgICAgaW5jciB0ZXN0c19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5IFwiJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiIGRlc2NyIHNlcCBleG5fc3RyXG4gICAgICAgICAgICAgIGJhY2t0cmFjZSAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbmxldCBzZXRfbGliX2FuZF9wYXJ0aXRpb24gc3RhdGljX2xpYiBwYXJ0aXRpb24gPVxuICBtYXRjaCAhZHluYW1pY19saWIgd2l0aFxuICB8IFNvbWUgXyAtPlxuICAgICgqIHBvc3NpYmxlIGlmIHRoZSBpbnRlcmZhY2UgaXMgdXNlZCBleHBsaWNpdGx5IG9yIGlmIHdlIGhhcHBlbiB0byBkeW5saW5rIHNvbWV0aGluZ1xuICAgICAgIHRoYXQgY29udGFpbiB0ZXN0cyAqKVxuICAgICgpXG4gIHwgTm9uZSAtPlxuICAgIGR5bmFtaWNfbGliIDo9IFNvbWUgc3RhdGljX2xpYjtcbiAgICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgICB8IGBJZ25vcmUgLT4gKClcbiAgICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0czsgd2hhdF90b19kbyB9IC0+XG4gICAgICBpZiB3aGljaF90ZXN0cy5saWJuYW1lID0gc3RhdGljX2xpYiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCByZXF1aXJlc19wYXJ0aXRpb24gPVxuICAgICAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgICAgIHwgYExpc3RfcGFydGl0aW9ucyB8IGBSdW5fcGFydGl0aW9uIChTb21lIF8pIC0+IHRydWVcbiAgICAgICAgICB8IGBSdW5fcGFydGl0aW9uIE5vbmUgLT4gZmFsc2VcbiAgICAgICAgaW5cbiAgICAgICAgaWYgcGFydGl0aW9uID0gXCJcIiAmJiByZXF1aXJlc19wYXJ0aXRpb25cbiAgICAgICAgdGhlbiBmYWlsd2l0aCBcInBweF9pbmxpbmVfdGVzdDogY2Fubm90IHVzZSAtbGlzdC1wYXJ0aXRpb24gb3IgLXBhcnRpdGlvbiBcXFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IHNwZWNpZnlpbmcgYSBwYXJ0aXRpb24gYXQgcHJlcHJvY2Vzc2luZyB0aW1lXCJcbiAgICAgICAgZWxzZSBQYXJ0aXRpb24uc2V0X2N1cnJlbnQgcGFydGl0aW9uXG4gICAgICBlbmRcblxubGV0IHVuc2V0X2xpYiBzdGF0aWNfbGliID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgKCogbm90IGdpdmluZyBhbiBlcnJvciwgYmVjYXVzZSB3aGVuIHNvbWUgYW5ub3lpbmcgcGVvcGxlIHB1dCBwYV9vdW5pdCBpbiB0aGVpciBsaXN0XG4gICAgICAgb2YgcHJlcHJvY2Vzc29ycywgcGFfb3VuaXQgaXMgc2V0IHVwIHR3aWNlIGFuZCB3ZSBoYXZlIHR3byBjYWxscyB0byB1bnNldF9saWIgYXRcbiAgICAgICB0aGUgZW5kIG9mIHRoZSBmaWxlLCBhbmQgdGhlIHNlY29uZCBvbmUgY29tZXMgaW4gdGhpcyBicmFuY2ggKilcbiAgICAoKVxuICB8IFNvbWUgbGliIC0+XG4gICAgaWYgbGliID0gc3RhdGljX2xpYiB0aGVuIGR5bmFtaWNfbGliIDo9IE5vbmVcblxubGV0IHRlc3QgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgPVxuICB0ZXN0X2lubmVyIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3Bvc1xuICAgIGYgKGZ1biBiIC0+IGIpXG5cbmxldCB0ZXN0X3VuaXQgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgPVxuICB0ZXN0X2lubmVyIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3Bvc1xuICAgIGYgKGZ1biAoKSAtPiB0cnVlKVxuXG5sZXRbQGlubGluZSBuZXZlcl0gdGVzdF9tb2R1bGUgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lOmRlZl9maWxlbmFtZSB+bGluZV9udW1iZXI6ZGVmX2xpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0geyBsaWJuYW1lOyBvbmx5X3Rlc3RfbG9jYXRpb24gPSBfOyBuYW1lX2ZpbHRlciA9IF87IHdoaWNoX3RhZ3MgfTsgd2hhdF90b19kbyB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgKCkgPSBkaXNwbGF5ZWRfZGVzY3IgZGVzY3IgZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBzdGFydF9wb3MgZW5kX3BvcyBpblxuICAgIGxldCBwYXJ0aWFsX3RhZ3MgPSB0YWdzIEAgTW9kdWxlX2NvbnRleHQuY3VycmVudF90YWdzICgpIGluXG4gICAgbGV0IHNob3VsZF9ydW4gPVxuICAgICAgU29tZSBsaWJuYW1lID0gIWR5bmFtaWNfbGliXG4gICAgICAoKiBJZiwgbm8gbWF0dGVyIHdoYXQgdGFncyBhIHRlc3QgZGVmaW5lcywgd2UgY2VydGFpbmx5IHdpbGwgZHJvcCBhbGwgdGVzdHMgd2l0aGluXG4gICAgICAgICB0aGlzIG1vZHVsZSwgdGhlbiBkb24ndCBydW4gdGhlIG1vZHVsZSBhdCBhbGwuIFRoaXMgbWVhbnMgcGVvcGxlIGNhbiB3cml0ZVxuICAgICAgICAgdGhpbmdzIGxpa2UgdGhlIGZvbGxvd2luZyB3aXRob3V0IGJyZWFraW5nIHRoZSAzMi1iaXQgYnVpbGQ6XG4gICAgICAgICBsZXQldGVzdF9tb2R1bGUgW0B0YWdzIFwiNjQtYml0cy1vbmx5XCJdID0gKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgIGxldCBpID0gSW50NjQudG9faW50X2V4biAuLi4uXG4gICAgICAgICBlbmQpXG4gICAgICAgICBXZSBkb24ndCBzaG9ydGN1dCBiYXNlZCBvbiBwb3NpdGlvbiwgYXMgd2UgY2FuJ3QgdGVsbCB3aGF0IHBvc2l0aW9ucyB0aGVcbiAgICAgICAgIGlubmVyIHRlc3RzIHdpbGwgaGF2ZS4gKilcbiAgICAgICYmIG5vdCAoVGFnX3ByZWRpY2F0ZS5lbnRpcmVfbW9kdWxlX2Rpc2FibGVkIHdoaWNoX3RhZ3MgfnBhcnRpYWxfdGFncylcbiAgICBpblxuICAgIGlmIHNob3VsZF9ydW4gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaW5jciB0ZXN0X21vZHVsZXNfcmFuO1xuICAgICAgICAgIGxldCBkZXNjciA9IGRlc2NyICgpIGluXG4gICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgIE1vZHVsZV9jb250ZXh0LndpdGhfIH5kZXNjciB+dGFncyAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICgqIFdlIGRvIG5vdCByZXNldCByYW5kb20gc3RhdGVzIHVwb24gZW50ZXJpbmcgW2xldCV0ZXN0X21vZHVsZV0uXG5cbiAgICAgICAgICAgICAgICAgQ29uOiBDb2RlIGluIHRlc3QgbW9kdWxlcyBjYW4gYWNjaWRlbnRhbGx5IGRlcGVuZCBvbiB0b3AtbGV2ZWwgcmFuZG9tXG4gICAgICAgICAgICAgICAgIHN0YXRlIGVmZmVjdHMuXG5cbiAgICAgICAgICAgICAgICAgUHJvczogKDEpIFdlIGRvbid0IHJlc2V0IHRvIHRoZSBzYW1lIHNlZWQgb24gZW50ZXJpbmcgYSBbbGV0JXRlc3RfbW9kdWxlXVxuICAgICAgICAgICAgICAgICBhbmQgdGhlbiBhIFtsZXQldGVzdF0gaW5zaWRlIHRoYXQgbW9kdWxlLCB3aGljaCBjb3VsZCBsZWFkIHRvXG4gICAgICAgICAgICAgICAgIGFjY2lkZW50YWxseSByYW5kb21seSBnZW5lcmF0aW5nIHRoZSBzYW1lIHZhbHVlcyBpbiBzb21lIHRlc3QuICgyKSBNb3ZpbmdcbiAgICAgICAgICAgICAgICAgY29kZSBpbnRvIGFuZCBvdXQgb2YgW2xldCV0ZXN0X21vZHVsZV0gZG9lcyBub3QgY2hhbmdlIGl0cyByYW5kb20gc2VlZC5cbiAgICAgICAgICAgICAgKilcbiAgICAgICAgICAgICAgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgICAgIHwgRXJyb3IgKGV4biwgYmFja3RyYWNlKSAtPlxuICAgICAgICAgICAgaW5jciB0ZXN0X21vZHVsZXNfZmFpbGVkO1xuICAgICAgICAgICAgbGV0IGJhY2t0cmFjZSA9IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlIGluXG4gICAgICAgICAgICBsZXQgZXhuX3N0ciA9IFNleHBsaWIwLlNleHBfY29udi5wcmludGV4Y19wcmVmZXJfc2V4cCBleG4gaW5cbiAgICAgICAgICAgIGxldCBzZXAgPSBpZiBTdHJpbmcuY29udGFpbnMgZXhuX3N0ciAnXFxuJyB0aGVuIFwiXFxuXCIgZWxzZSBcIiBcIiBpblxuICAgICAgICAgICAgZXByaW50Zl9vcl9kZWxheSAoXCJURVNcIiBeXiBcIlRfTU9EVUxFIGF0ICVzIHRocmV3JXMlcy5cXG4lcyVzXFxuJSFcIilcbiAgICAgICAgICAgICAgKFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkgZGVzY3IpIHNlcCBleG5fc3RyIGJhY2t0cmFjZSAoc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbmxldCBzdW1tYXJpemUgKCkgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+XG4gICAgaWYgU3lzLmFyZ3YgPD4gW3x8XSAmJiBGaWxlbmFtZS5iYXNlbmFtZSBTeXMuYXJndi4oMCkgPSBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlXCIgdGhlblxuICAgICAgUHJpbnRmLmVwcmludGYgXCJpbmxpbmVfdGVzdHNfcnVubmVyLmV4ZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcnVuIGJ5IGhhbmQsIHlvdSBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgIHNob3VsZCBydW4gdGhlIGlubGluZV90ZXN0c19ydW5uZXIgc2NyaXB0IGluc3RlYWQuXFxuJSFcIlxuICAgIGVsc2VcbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiWW91IGFyZSBkb2luZyBzb21ldGhpbmcgdW5leHBlY3RlZCB3aXRoIHRoZSB0ZXN0cy4gTm8gdGVzdHMgaGF2ZSBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgIGJlZW4gcnVuLiBZb3Ugc2hvdWxkIHVzZSB0aGUgaW5saW5lX3Rlc3RzX3J1bm5lciBzY3JpcHQgdG8gcnVuIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdHMuXFxuJSFcIjtcbiAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0cyA9IF87IHdoYXRfdG9fZG8gPSBgTGlzdF9wYXJ0aXRpb25zIH0gLT5cbiAgICBMaXN0Lml0ZXIgKFByaW50Zi5wcmludGYgXCIlc1xcblwiKSAoUGFydGl0aW9uLmFsbCAoKSk7XG4gICAgVGVzdF9yZXN1bHQuU3VjY2Vzc1xuICB8IGBUZXN0X21vZGUgeyB3aGF0X3RvX2RvID0gYFJ1bl9wYXJ0aXRpb24gXzsgd2hpY2hfdGVzdHMgfSAtPiBiZWdpblxuICAgICAgYmVnaW4gbWF0Y2ggIWxvZyB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBjaCAtPiBjbG9zZV9vdXQgY2hcbiAgICAgIGVuZDtcbiAgICAgIHByaW50X2RlbGF5ZWRfZXJyb3JzICgpO1xuICAgICAgbWF0Y2ggIXRlc3RzX2ZhaWxlZCwgIXRlc3RfbW9kdWxlc19mYWlsZWQgd2l0aFxuICAgICAgfCAwLCAwIC0+IGJlZ2luXG4gICAgICAgICAgaWYgIXNob3dfY291bnRzIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwiJWQgdGVzdHMgcmFuLCAlZCB0ZXN0X21vZHVsZXMgcmFuXFxuJSFcIiAhdGVzdHNfcmFuICF0ZXN0X21vZHVsZXNfcmFuXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGxldCBlcnJvcnMgPVxuICAgICAgICAgICAgbGV0IHVudXNlZF90ZXN0cyA9XG4gICAgICAgICAgICAgIExpc3QuZmlsdGVyIChmdW4gKF8sIF8sIHVzZWQpIC0+IG5vdCAhdXNlZCkgd2hpY2hfdGVzdHMub25seV90ZXN0X2xvY2F0aW9uXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbWF0Y2ggdW51c2VkX3Rlc3RzIHdpdGhcbiAgICAgICAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgICAgICAgfCBfIDo6IF8gLT4gU29tZSB1bnVzZWRfdGVzdHNcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGVycm9ycyB3aXRoXG4gICAgICAgICAgfCBTb21lIHRlc3RzIC0+XG4gICAgICAgICAgICBQcmludGYuZXByaW50ZiBcInBweF9pbmxpbmVfdGVzdCBlcnJvcjogdGhlIGZvbGxvd2luZyAtb25seS10ZXN0IGZsYWdzIG1hdGNoZWQgbm90aGluZzpcIjtcbiAgICAgICAgICAgIExpc3QuaXRlciAoZnVuIChmaWxlbmFtZSwgbGluZV9udW1iZXJfb3B0LCBfKSAtPlxuICAgICAgICAgICAgICBtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gUHJpbnRmLmVwcmludGYgXCIgJXNcIiBmaWxlbmFtZVxuICAgICAgICAgICAgICB8IFNvbWUgbGluZV9udW1iZXIgLT4gUHJpbnRmLmVwcmludGYgXCIgJXM6JWRcIiBmaWxlbmFtZSBsaW5lX251bWJlclxuICAgICAgICAgICAgKSB0ZXN0cztcbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwiLlxcbiUhXCI7XG4gICAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvclxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgaWYgIXRlc3RzX3JhbiA9IDAgJiYgIXN0cmljdCB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiBubyB0ZXN0cyBoYXZlIGJlZW4gcnVuLlxcbiUhXCI7XG4gICAgICAgICAgICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBUZXN0X3Jlc3VsdC5TdWNjZXNzXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGNvdW50LCBjb3VudF90ZXN0X21vZHVsZXMgLT5cbiAgICAgICAgUHJpbnRmLmVwcmludGYgXCJGQUlMRUQgJWQgLyAlZCB0ZXN0cyVzXFxuJSFcIiBjb3VudCAhdGVzdHNfcmFuXG4gICAgICAgICAgKGlmIGNvdW50X3Rlc3RfbW9kdWxlcyA9IDAgdGhlbiBcIlwiIGVsc2UgUHJpbnRmLnNwcmludGYgKFwiLCAlZCBURVNcIiBeXiBcIlRfTU9EVUxFU1wiKSBjb3VudF90ZXN0X21vZHVsZXMpO1xuICAgICAgICBUZXN0X3Jlc3VsdC5GYWlsdXJlXG4gICAgZW5kXG5cbmxldCB1c2VfY29sb3IgPSAhdXNlX2NvbG9yXG5sZXQgaW5fcGxhY2UgID0gIWluX3BsYWNlXG5sZXQgZGlmZl9jb21tYW5kID0gIWRpZmZfY29tbWFuZFxubGV0IHNvdXJjZV90cmVlX3Jvb3QgPSAhc291cmNlX3RyZWVfcm9vdFxubGV0IGFsbG93X291dHB1dF9wYXR0ZXJucyA9ICFhbGxvd19vdXRwdXRfcGF0dGVybnNcblxubGV0IGV2YWx1YXRvcnMgPSByZWYgW3N1bW1hcml6ZV1cbmxldCBhZGRfZXZhbHVhdG9yIH5mID0gZXZhbHVhdG9ycyA6PSBmIDo6ICFldmFsdWF0b3JzXG5sZXQgZXhpdCAoKSA9XG4gIExpc3QubWFwIChmdW4gZiAtPiBmICgpKSAoTGlzdC5yZXYgIWV2YWx1YXRvcnMpXG4gIHw+IFRlc3RfcmVzdWx0LmNvbWJpbmVfYWxsXG4gIHw+IFRlc3RfcmVzdWx0LnRvX2V4aXRfY29kZVxuICB8PiBleGl0XG4iXX0=
