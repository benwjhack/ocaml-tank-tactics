// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$11=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes("("),
     cst$3=caml_string_of_jsbytes("()"),
     cst$4=caml_string_of_jsbytes(")"),
     cst$5=caml_string_of_jsbytes(" "),
     cst$6=caml_string_of_jsbytes("("),
     cst$7=caml_string_of_jsbytes("()"),
     cst$8=caml_string_of_jsbytes(")"),
     cst$10=caml_string_of_jsbytes("()"),
     cst$9=caml_string_of_jsbytes("()"),
     cst=caml_string_of_jsbytes("\\"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst$0=caml_string_of_jsbytes(' "'),
     cst$1=caml_string_of_jsbytes('"'),
     cst_Sexplib0_Sexp_Not_found_s=
      caml_string_of_jsbytes("Sexplib0__Sexp.Not_found_s"),
     cst_Sexplib0_Sexp_Of_sexp_erro=
      caml_string_of_jsbytes("Sexplib0__Sexp.Of_sexp_error"),
     doc_comment_tag=caml_string_of_jsbytes("sexp_grammar.doc_comment"),
     unit_sexp_grammar=[2,0],
     sexp_t_sexp_grammar=[0,caml_string_of_jsbytes("Sexp.t")],
     fun_sexp_grammar=[4,0],
     cst_Assert_failure=caml_string_of_jsbytes("Assert_failure"),
     cst_Match_failure=caml_string_of_jsbytes("Match_failure"),
     cst_fun_of_sexp_cannot_convert=
      caml_string_of_jsbytes("fun_of_sexp: cannot convert function values"),
     cst_opaque_of_sexp_cannot_conv=
      caml_string_of_jsbytes("opaque_of_sexp: cannot convert opaque values"),
     cst_hashtbl_of_sexp_tuple_list=
      caml_string_of_jsbytes("hashtbl_of_sexp: tuple list needed"),
     cst_hashtbl_of_sexp_list_neede=
      caml_string_of_jsbytes("hashtbl_of_sexp: list needed"),
     cst_array_of_sexp_list_needed=
      caml_string_of_jsbytes("array_of_sexp: list needed"),
     cst_list_of_sexp_list_needed=
      caml_string_of_jsbytes("list_of_sexp: list needed"),
     cst_triple_of_sexp_list_needed=
      caml_string_of_jsbytes("triple_of_sexp: list needed"),
     cst_triple_of_sexp_list_must_c=
      caml_string_of_jsbytes
       ("triple_of_sexp: list must contain exactly three elements only"),
     cst_pair_of_sexp_list_needed=
      caml_string_of_jsbytes("pair_of_sexp: list needed"),
     cst_pair_of_sexp_list_must_con=
      caml_string_of_jsbytes
       ("pair_of_sexp: list must contain exactly two elements only"),
     cst_None=caml_string_of_jsbytes("None"),
     cst_none=caml_string_of_jsbytes("none"),
     cst_option_of_sexp_only_none_c=
      caml_string_of_jsbytes("option_of_sexp: only none can be atom"),
     cst_Some=caml_string_of_jsbytes("Some"),
     cst_some=caml_string_of_jsbytes("some"),
     cst_option_of_sexp_list_must_r=
      caml_string_of_jsbytes
       ("option_of_sexp: list must represent optional value"),
     cst_None$0=caml_string_of_jsbytes("None"),
     cst_none$0=caml_string_of_jsbytes("none"),
     cst_option_of_sexp_only_none_c$0=
      caml_string_of_jsbytes("option_of_sexp: only none can be atom"),
     cst_Some$0=caml_string_of_jsbytes("Some"),
     cst_some$0=caml_string_of_jsbytes("some"),
     cst_option_of_sexp_list_must_b=
      caml_string_of_jsbytes("option_of_sexp: list must be (some el)"),
     cst_nativeint_of_sexp=caml_string_of_jsbytes("nativeint_of_sexp: "),
     cst_nativeint_of_sexp_atom_nee=
      caml_string_of_jsbytes("nativeint_of_sexp: atom needed"),
     cst_int64_of_sexp=caml_string_of_jsbytes("int64_of_sexp: "),
     cst_int64_of_sexp_atom_needed=
      caml_string_of_jsbytes("int64_of_sexp: atom needed"),
     cst_int32_of_sexp=caml_string_of_jsbytes("int32_of_sexp: "),
     cst_int32_of_sexp_atom_needed=
      caml_string_of_jsbytes("int32_of_sexp: atom needed"),
     cst_float_of_sexp=caml_string_of_jsbytes("float_of_sexp: "),
     cst_float_of_sexp_atom_needed=
      caml_string_of_jsbytes("float_of_sexp: atom needed"),
     cst_int_of_sexp=caml_string_of_jsbytes("int_of_sexp: "),
     cst_int_of_sexp_atom_needed=
      caml_string_of_jsbytes("int_of_sexp: atom needed"),
     cst_char_of_sexp_atom_string_m=
      caml_string_of_jsbytes
       ("char_of_sexp: atom string must contain one character only"),
     cst_char_of_sexp_atom_needed=
      caml_string_of_jsbytes("char_of_sexp: atom needed"),
     cst_bytes_of_sexp_atom_needed=
      caml_string_of_jsbytes("bytes_of_sexp: atom needed"),
     cst_string_of_sexp_atom_needed=
      caml_string_of_jsbytes("string_of_sexp: atom needed"),
     cst_False=caml_string_of_jsbytes("False"),
     cst_True=caml_string_of_jsbytes("True"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_bool_of_sexp_unknown_strin=
      caml_string_of_jsbytes("bool_of_sexp: unknown string"),
     cst_bool_of_sexp_atom_needed=
      caml_string_of_jsbytes("bool_of_sexp: atom needed"),
     cst_unit_of_sexp_empty_list_ne=
      caml_string_of_jsbytes("unit_of_sexp: empty list needed"),
     cst_15G=caml_string_of_jsbytes("%.15G"),
     cst_17G=caml_string_of_jsbytes("%.17G"),
     cst$13=caml_string_of_jsbytes(" "),
     cst_of_sexp_trying_to_convert_=
      caml_string_of_jsbytes("_of_sexp: trying to convert an empty type"),
     cst_of_sexp_the_empty_list_is_=
      caml_string_of_jsbytes
       ("_of_sexp: the empty list is an invalid polymorphic variant"),
     cst_of_sexp_a_nested_list_is_a=
      caml_string_of_jsbytes
       ("_of_sexp: a nested list is an invalid polymorphic variant"),
     cst_of_sexp_polymorphic_varian$0=
      caml_string_of_jsbytes
       ("_of_sexp: polymorphic variant tag takes an argument"),
     cst_of_sexp_polymorphic_varian=
      caml_string_of_jsbytes
       ("_of_sexp: polymorphic variant does not take arguments"),
     cst_of_sexp_no_matching_varian=
      caml_string_of_jsbytes("_of_sexp: no matching variant found"),
     cst_of_sexp_cannot_convert_val=
      caml_string_of_jsbytes
       ("_of_sexp: cannot convert values of types resulting from polymorphic record fields"),
     cst_of_sexp_list_instead_of_at=
      caml_string_of_jsbytes
       ("_of_sexp: list instead of atom for record expected"),
     cst_extra_fields=caml_string_of_jsbytes("extra fields"),
     cst_duplicate_fields=caml_string_of_jsbytes("duplicate fields"),
     cst$12=caml_string_of_jsbytes(" "),
     cst_of_sexp_record_conversion_$0=
      caml_string_of_jsbytes
       ("_of_sexp: record conversion: only pairs expected, their first element must be an atom"),
     cst_of_sexp_record_conversion_=
      caml_string_of_jsbytes
       ("_of_sexp: record conversion: a [sexp.bool] field was given a payload."),
     cst_of_sexp_unexpected_variant=
      caml_string_of_jsbytes("_of_sexp: unexpected variant constructor"),
     cst_of_sexp_expected_a_variant$0=
      caml_string_of_jsbytes
       ("_of_sexp: expected a variant type, saw an empty list"),
     cst_of_sexp_expected_a_variant=
      caml_string_of_jsbytes
       ("_of_sexp: expected a variant type, saw a nested list"),
     cst_of_sexp_this_constructor_r=
      caml_string_of_jsbytes("_of_sexp: this constructor requires arguments"),
     cst_of_sexp_this_constructor_d=
      caml_string_of_jsbytes
       ("_of_sexp: this constructor does not take arguments"),
     cst_Sexplib0_Sexp_conv_error_N=
      caml_string_of_jsbytes("Sexplib0__Sexp_conv_error.No_variant_match"),
     Stdlib_StringLabels=global_data.Stdlib__StringLabels,
     Stdlib_Format=global_data.Stdlib__Format,
     Stdlib_ListLabels=global_data.Stdlib__ListLabels,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Stdlib=global_data.Stdlib,
     Stdlib_BytesLabels=global_data.Stdlib__BytesLabels,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_Bytes=global_data.Stdlib__Bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_Arg=global_data.Stdlib__Arg,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Stdlib_Parsing=global_data.Stdlib__Parsing,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Stdlib_Scanf=global_data.Stdlib__Scanf,
     Stdlib_Stack=global_data.Stdlib__Stack,
     Stdlib_Sys=global_data.Stdlib__Sys,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_MoreLabels=global_data.Stdlib__MoreLabels,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Stdlib_Obj=global_data.Stdlib__Obj,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Nativeint=global_data.Stdlib__Nativeint,
     Stdlib_Int64=global_data.Stdlib__Int64,
     Stdlib_Int32=global_data.Stdlib__Int32,
     Stdlib_Ephemeron=global_data.Stdlib__Ephemeron,
     Sexplib0=[0];
    caml_register_global(141,Sexplib0,"Sexplib0__");
    var
     _b_=[0,[15,[17,2,0]],caml_string_of_jsbytes("%a@?")],
     _a_=[0,0,0],
     _aG_=[0,0],
     _aH_=[0,1],
     _aC_=[0,caml_string_of_jsbytes("Sexplib.Conv.Of_sexp_error")],
     _aD_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),410,15],
     _az_=[0,0],
     _aA_=[0,0],
     _aw_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),334,15],
     _as_=[0,caml_string_of_jsbytes("Exit")],
     _at_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),338,15],
     _ao_=[0,caml_string_of_jsbytes("End_of_file")],
     _ap_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),342,15],
     _ak_=[0,caml_string_of_jsbytes("Failure")],
     _al_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),346,15],
     _ag_=[0,caml_string_of_jsbytes("Not_found")],
     _ah_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),350,15],
     _ac_=[0,caml_string_of_jsbytes("Invalid_argument")],
     _ad_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),354,15],
     _$_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),358,15],
     _X_=[0,caml_string_of_jsbytes("Not_found_s")],
     _Y_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),362,15],
     _U_=[0,caml_string_of_jsbytes("Sys_error")],
     _V_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),366,15],
     _Q_=[0,caml_string_of_jsbytes("Arg.Help")],
     _R_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),370,15],
     _M_=[0,caml_string_of_jsbytes("Arg.Bad")],
     _N_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),374,15],
     _I_=[0,caml_string_of_jsbytes("Lazy.Undefined")],
     _J_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),378,15],
     _E_=[0,caml_string_of_jsbytes("Parsing.Parse_error")],
     _F_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),382,15],
     _A_=[0,caml_string_of_jsbytes("Queue.Empty")],
     _B_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),386,15],
     _w_=[0,caml_string_of_jsbytes("Scanf.Scan_failure")],
     _x_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),390,15],
     _s_=[0,caml_string_of_jsbytes("Stack.Empty")],
     _t_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),394,15],
     _o_=[0,caml_string_of_jsbytes("Sys.Break")],
     _p_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),398,15],
     _l_=
      [0,
       [2,0,[12,32,[2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes("%s %s:%d:%d")],
     _k_=[0,2],
     _j_=[0,2],
     _h_=[0,caml_string_of_jsbytes("<fun>")],
     _g_=[0,caml_string_of_jsbytes("<opaque>")],
     _d_=[0,caml_string_of_jsbytes("some")],
     _e_=[1,0],
     _f_=[0,caml_string_of_jsbytes("none")],
     _c_=[1,0],
     _aM_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: polymorphic variant tag "),
         [3,
          0,
          [11,caml_string_of_jsbytes(" has incorrect number of arguments"),0]]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments")],
     _aL_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes
          ("_of_sexp: the following record elements were undefined: "),
         [2,0,0]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: the following record elements were undefined: %s")],
     _aK_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: "),
         [2,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]],
       caml_string_of_jsbytes("%s_of_sexp: %s: %s")],
     _aJ_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: sum tag "),
         [3,
          0,
          [11,caml_string_of_jsbytes(" has incorrect number of arguments"),0]]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: sum tag %S has incorrect number of arguments")],
     _aI_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: tuple of size "),
         [4,0,0,0,[11,caml_string_of_jsbytes(" expected"),0]]]],
       caml_string_of_jsbytes("%s_of_sexp: tuple of size %d expected")];
    function sexp_of_t(t){return t}
    function t_of_sexp(t){return t}
    function compare(a$0,b$0)
     {if(a$0 === b$0)return 0;
      if(0 === a$0[0])
       {var _b8_=a$0[1];
        if(0 !== b$0[0])return -1;
        var b$1=b$0[1];
        return caml_call2(Stdlib_StringLabels[9],_b8_,b$1)}
      var _b9_=a$0[1];
      if(0 === b$0[0])return 1;
      var b$2=b$0[1],a=_b9_,b=b$2;
      for(;;)
       {if(! a)return b?-1:0;
        if(! b)return 1;
        var ys=b[2],y=b[1],xs=a[2],x=a[1],res=compare(x,y);
        if(0 !== res)return res;
        var a=xs,b=ys}}
    function equal(a,b){return 0 === compare(a,b)?1:0}
    var
     Not_found_s=[248,cst_Sexplib0_Sexp_Not_found_s,caml_fresh_oo_id(0)],
     Of_sexp_error=[248,cst_Sexplib0_Sexp_Of_sexp_erro,caml_fresh_oo_id(0)],
     default_indent=[0,1];
    function must_escape(str)
     {var len=caml_ml_string_length(str),_bY_=0 === len?1:0;
      if(_bY_)return _bY_;
      var ix$3=len - 1 | 0,ix=ix$3;
      for(;;)
       {var match=caml_string_get(str,ix),switch$0=0;
        if(92 <= match)
         {var switcher=match - 93 | 0;
          if(33 < switcher >>> 0)
           if(0 <= switcher)switch$0 = 2;else switch$0 = 1;
          else
           if(31 === switcher)
            {var _bZ_=0 < ix?1:0;
             if(_bZ_)
              {var
                ix$0=ix - 1 | 0,
                _b0_=caml_string_get(str,ix$0),
                _b1_=caml_call2(Stdlib_Char[8],_b0_,35);
               if(! _b1_){var ix=ix$0;continue}
               var _b2_=_b1_}
             else
              var _b2_=_bZ_;
             return _b2_}}
        else
         if(42 <= match)
          {if(59 === match)switch$0 = 1}
         else
          if(33 <= match)
           switch(match - 33 | 0)
            {case 2:
              var _b4_=0 < ix?1:0;
              if(_b4_)
               {var
                 ix$2=ix - 1 | 0,
                 _b5_=caml_string_get(str,ix$2),
                 _b6_=caml_call2(Stdlib_Char[8],_b5_,124);
                if(! _b6_){var ix=ix$2;continue}
                var _b7_=_b6_}
              else
               var _b7_=_b4_;
              return _b7_;
             case 1:
             case 7:
             case 8:switch$0 = 1;break
             }
          else
           switch$0 = 2;
        switch(switch$0)
         {case 0:
           var _b3_=0 < ix?1:0;
           if(! _b3_)return _b3_;
           var ix$1=ix - 1 | 0,ix=ix$1;
           continue;
          case 1:return 1;
          default:return 1}}}
    function escaped(s)
     {var n=[0,0],_bO_=caml_ml_string_length(s) - 1 | 0,_bN_=0;
      if(_bO_ >= 0)
       {var i$0=_bN_;
        for(;;)
         {var match=caml_string_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _bV_=match - 34 | 0,switch$1=0;
            if(58 < _bV_ >>> 0)
             {if(93 <= _bV_)switch$1 = 1}
            else
             if(56 < _bV_ - 1 >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _bW_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _bW_=4;break;case 1:var _bW_=2;break}
          n[1] = n[1] + _bW_ | 0;
          var _bX_=i$0 + 1 | 0;
          if(_bO_ !== i$0){var i$0=_bX_;continue}
          break}}
      if(n[1] === caml_ml_string_length(s))return s;
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _bQ_=caml_ml_string_length(s) - 1 | 0,_bP_=0;
      if(_bQ_ >= 0)
       {var i=_bP_;
        for(;;)
         {var c=caml_string_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             var _bS_=caml_call1(Stdlib_Char[1],48 + (c / 100 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bS_);
             n[1]++;
             var
              _bT_=
               caml_call1(Stdlib_Char[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bT_);
             n[1]++;
             var _bU_=caml_call1(Stdlib_Char[1],48 + (c % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bU_);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _bR_=i + 1 | 0;
          if(_bQ_ !== i){var i=_bR_;continue}
          break}}
      return caml_call1(Stdlib_BytesLabels[48],s$0)}
    function esc_str(str)
     {var
       src=escaped(str),
       len=caml_ml_string_length(src),
       dst=caml_create_bytes(len + 2 | 0);
      caml_call5(Stdlib_Bytes[12],src,0,dst,1,len);
      caml_bytes_unsafe_set(dst,0,34);
      caml_bytes_unsafe_set(dst,len + 1 | 0,34);
      return caml_call1(Stdlib_BytesLabels[48],dst)}
    function index_of_newline(str,start)
     {try
       {var _bL_=[0,caml_call3(Stdlib_StringLabels[31],str,start,10)];
        return _bL_}
      catch(_bM_)
       {_bM_ = caml_wrap_exception(_bM_);
        if(_bM_ === Stdlib[8])return 0;
        throw _bM_}}
    function mach_maybe_esc_str(str){return must_escape(str)?esc_str(str):str}
    function pp_hum_indent(indent,ppf,param)
     {if(0 === param[0])
       {var str=param[1];
        if(! must_escape(str))return caml_call2(Stdlib_Format[13],ppf,str);
        var match=index_of_newline(str,0);
        if(match)
         var
          index=match[1],
          _bH_=(index + 1 | 0) === caml_ml_string_length(str)?1:0;
        else
         var _bH_=1;
        if(_bH_)
         {var _bI_=esc_str(str);return caml_call2(Stdlib_Format[13],ppf,_bI_)}
        caml_call2(Stdlib_Format[1],ppf,0);
        caml_call2(Stdlib_Format[13],ppf,cst$0);
        var index$0=0;
        for(;;)
         {var end_pos_opt=index_of_newline(str,index$0);
          if(end_pos_opt)
           var end_pos=end_pos_opt[1],end_pos$0=end_pos;
          else
           var end_pos$0=caml_ml_string_length(str);
          var
           next_line=
            caml_call3
             (Stdlib_StringLabels[15],str,index$0,end_pos$0 - index$0 | 0),
           _bJ_=escaped(next_line);
          caml_call2(Stdlib_Format[13],ppf,_bJ_);
          if(end_pos_opt)
           {var newline_index=end_pos_opt[1];
            caml_call2(Stdlib_Format[13],ppf,cst);
            caml_call2(Stdlib_Format[34],ppf,0);
            caml_call2(Stdlib_Format[13],ppf,cst_n);
            var index$1=newline_index + 1 | 0,index$0=index$1;
            continue}
          caml_call2(Stdlib_Format[13],ppf,cst$1);
          return caml_call2(Stdlib_Format[3],ppf,0)}}
      var _bK_=param[1];
      if(! _bK_)return caml_call2(Stdlib_Format[13],ppf,cst$3);
      var t=_bK_[2],h=_bK_[1];
      caml_call2(Stdlib_Format[1],ppf,indent);
      caml_call2(Stdlib_Format[13],ppf,cst$2);
      pp_hum_indent(indent,ppf,h);
      var param$0=t;
      for(;;)
       {if(param$0)
         {var t$0=param$0[2],h$0=param$0[1];
          caml_call2(Stdlib_Format[27],ppf,0);
          pp_hum_indent(indent,ppf,h$0);
          var param$0=t$0;
          continue}
        caml_call2(Stdlib_Format[13],ppf,cst$4);
        return caml_call2(Stdlib_Format[3],ppf,0)}}
    function pp_mach_internal(may_need_space,ppf,param)
     {if(0 === param[0])
       {var
         str=param[1],
         str$0=mach_maybe_esc_str(str),
         new_may_need_space=str$0 === str?1:0,
         new_may_need_space$0=may_need_space?new_may_need_space:may_need_space;
        if(new_may_need_space$0)caml_call2(Stdlib_Format[13],ppf,cst$5);
        caml_call2(Stdlib_Format[13],ppf,str$0);
        return new_may_need_space}
      var _bG_=param[1];
      if(! _bG_){caml_call2(Stdlib_Format[13],ppf,cst$7);return 0}
      var t=_bG_[2],h=_bG_[1];
      caml_call2(Stdlib_Format[13],ppf,cst$6);
      var
       may_need_space$0=pp_mach_internal(0,ppf,h),
       may_need_space$1=may_need_space$0,
       param$0=t;
      for(;;)
       {if(param$0)
         {var
           t$0=param$0[2],
           h$0=param$0[1],
           may_need_space$2=pp_mach_internal(may_need_space$1,ppf,h$0),
           may_need_space$1=may_need_space$2,
           param$0=t$0;
          continue}
        caml_call2(Stdlib_Format[13],ppf,cst$8);
        return 0}}
    function pp_hum(ppf,sexp)
     {return pp_hum_indent(default_indent[1],ppf,sexp)}
    function pp(ppf,sexp){pp_mach_internal(0,ppf,sexp);return 0}
    function size_loop(acc,param)
     {var _bE_=acc[2],_bF_=acc[1];
      if(0 === param[0])
       {var str=param[1];
        return [0,_bF_ + 1 | 0,_bE_ + caml_ml_string_length(str) | 0]}
      var lst=param[1];
      return caml_call3(Stdlib_ListLabels[25],size_loop,acc,lst)}
    function size(sexp){return size_loop(_a_,sexp)}
    function to_buffer_hum(buf,opt,sexp)
     {if(opt)var sth=opt[1],indent=sth;else var indent=default_indent[1];
      var ppf=caml_call1(Stdlib_Format[111],buf);
      function _bB_(_bC_,_bD_){return pp_hum_indent(indent,_bC_,_bD_)}
      return caml_call4(Stdlib_Format[129],ppf,_b_,_bB_,sexp)}
    function to_buffer(buf,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(Stdlib_Buffer[12],buf,32);
          caml_call2(Stdlib_Buffer[16],buf,str$0);
          return new_may_need_space}
        var _bA_=param[1];
        if(! _bA_){caml_call2(Stdlib_Buffer[16],buf,cst$9);return 0}
        var t=_bA_[2],h=_bA_[1];
        caml_call2(Stdlib_Buffer[12],buf,40);
        var
         may_need_space$0=loop(0,h),
         may_need_space$1=may_need_space$0,
         param$0=t;
        for(;;)
         {if(param$0)
           {var
             t$0=param$0[2],
             h$0=param$0[1],
             may_need_space$2=loop(may_need_space$1,h$0),
             may_need_space$1=may_need_space$2,
             param$0=t$0;
            continue}
          caml_call2(Stdlib_Buffer[12],buf,41);
          return 0}}
      loop(0,sexp);
      return 0}
    function to_buffer_gen(buf,add_char,add_string,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(add_char,buf,32);
          caml_call2(add_string,buf,str$0);
          return new_may_need_space}
        var _bz_=param[1];
        if(! _bz_){caml_call2(add_string,buf,cst$10);return 0}
        var t=_bz_[2],h=_bz_[1];
        caml_call2(add_char,buf,40);
        var
         may_need_space$0=loop(0,h),
         may_need_space$1=may_need_space$0,
         param$0=t;
        for(;;)
         {if(param$0)
           {var
             t$0=param$0[2],
             h$0=param$0[1],
             may_need_space$2=loop(may_need_space$1,h$0),
             may_need_space$1=may_need_space$2,
             param$0=t$0;
            continue}
          caml_call2(add_char,buf,41);
          return 0}}
      loop(0,sexp);
      return 0}
    function buffer(param){return caml_call1(Stdlib_Buffer[1],1024)}
    function to_string_hum(indent,sexp)
     {if(0 === sexp[0])
       {var str=sexp[1],match=index_of_newline(str,0),_by_=match?0:1;
        if(_by_)return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer_hum(buf,indent,sexp);
      return caml_call1(Stdlib_Buffer[2],buf)}
    function to_string(sexp)
     {if(0 === sexp[0]){var str=sexp[1];return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer(buf,sexp);
      return caml_call1(Stdlib_Buffer[2],buf)}
    var of_float_style=[0,1009018843],of_int_style=[0,1009018843];
    function message(name,fields)
     {function conv_fields(param)
       {if(! param)return 0;
        var rest=param[2],match=param[1],fsexp=match[2],fname=match[1];
        return caml_string_notequal(fname,cst$11)
                ?[0,[1,[0,[0,fname],[0,fsexp,0]]],conv_fields(rest)]
                :[0,fsexp,conv_fields(rest)]}
      return [1,[0,[0,name],conv_fields(fields)]]}
    var
     Sexplib0_Sexp=
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp,
       pp,
       to_string_hum,
       to_string,
       to_string,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer,
        to_buffer_hum,
        to_buffer,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
    caml_register_global(150,Sexplib0_Sexp,"Sexplib0__Sexp");
    function coerce(t){return t}
    var Sexplib0_Sexp_grammar=[0,coerce,doc_comment_tag];
    caml_register_global(151,Sexplib0_Sexp_grammar,"Sexplib0__Sexp_grammar");
    var
     bool_sexp_grammar=0,
     string_sexp_grammar=4,
     bytes_sexp_grammar=4,
     char_sexp_grammar=1,
     int_sexp_grammar=2,
     float_sexp_grammar=3,
     int32_sexp_grammar=2,
     int64_sexp_grammar=2,
     nativeint_sexp_grammar=2;
    function ref_sexp_grammar(grammar){return grammar}
    function lazy_t_sexp_grammar(grammar){return grammar}
    function option_sexp_grammar(param){return [1,param]}
    function list_sexp_grammar(param){return [2,[1,param]]}
    function array_sexp_grammar(param){return [2,[1,param]]}
    var
     include=
      [0,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       fun_sexp_grammar,
       fun_sexp_grammar];
    caml_register_global(152,include,"Sexplib0__Sexp_conv_grammar");
    var
     default_string_of_float=
      [0,
       function(x)
        {var y=caml_format_float(cst_15G,x);
         return caml_float_of_string(y) == x?y:caml_format_float(cst_17G,x)}],
     read_old_option_format=[0,1],
     write_old_option_format=[0,1];
    function list_map(f,l)
     {var _bx_=caml_call2(Stdlib_ListLabels[21],f,l);
      return caml_call1(Stdlib_ListLabels[9],_bx_)}
    function sexp_of_unit(param){return _c_}
    function sexp_of_bool(b){return [0,caml_call1(Stdlib[30],b)]}
    function sexp_of_string(str){return [0,str]}
    function sexp_of_bytes(bytes)
     {return [0,caml_call1(Stdlib_BytesLabels[6],bytes)]}
    function sexp_of_char(c)
     {return [0,caml_call2(Stdlib_StringLabels[1],1,c)]}
    function sexp_of_int(n){return [0,caml_call1(Stdlib[33],n)]}
    function sexp_of_float(n)
     {return [0,caml_call1(default_string_of_float[1],n)]}
    function sexp_of_int32(n){return [0,caml_call1(Stdlib_Int32[14],n)]}
    function sexp_of_int64(n){return [0,caml_call1(Stdlib_Int64[14],n)]}
    function sexp_of_nativeint(n)
     {return [0,caml_call1(Stdlib_Nativeint[15],n)]}
    function sexp_of_ref(sexp_of_a,rf){return caml_call1(sexp_of_a,rf[1])}
    function sexp_of_lazy_t(sexp_of_a,lv)
     {var
       _bv_=runtime.caml_obj_tag(lv),
       _bw_=
        250 === _bv_?lv[1]:246 === _bv_?caml_call1(CamlinternalLazy[2],lv):lv;
      return caml_call1(sexp_of_a,_bw_)}
    function sexp_of_option(sexp_of_a,param)
     {if(! param)return write_old_option_format[1]?_e_:_f_;
      var x=param[1];
      return write_old_option_format[1]
              ?[1,[0,caml_call1(sexp_of_a,x),0]]
              :[1,[0,_d_,[0,caml_call1(sexp_of_a,x),0]]]}
    function sexp_of_pair(sexp_of_a,sexp_of_b,param)
     {var b=param[2],a=param[1],_bu_=[0,caml_call1(sexp_of_b,b),0];
      return [1,[0,caml_call1(sexp_of_a,a),_bu_]]}
    function sexp_of_triple(sexp_of_a,sexp_of_b,sexp_of_c,param)
     {var
       c=param[3],
       b=param[2],
       a=param[1],
       _bs_=[0,caml_call1(sexp_of_c,c),0],
       _bt_=[0,caml_call1(sexp_of_b,b),_bs_];
      return [1,[0,caml_call1(sexp_of_a,a),_bt_]]}
    function sexp_of_list(sexp_of_a,lst)
     {var _br_=caml_call2(Stdlib_ListLabels[21],sexp_of_a,lst);
      return [1,caml_call1(Stdlib_ListLabels[9],_br_)]}
    function sexp_of_array(sexp_of_a,ar)
     {var lst_ref=[0,0],_bo_=ar.length - 1 - 1 | 0;
      if(_bo_ >= 0)
       {var i=_bo_;
        for(;;)
         {var _bp_=lst_ref[1];
          lst_ref[1]
          =
          [0,caml_call1(sexp_of_a,caml_check_bound(ar,i)[1 + i]),_bp_];
          var _bq_=i - 1 | 0;
          if(0 !== i){var i=_bq_;continue}
          break}}
      return [1,lst_ref[1]]}
    function sexp_of_hashtbl(sexp_of_key,sexp_of_val,htbl)
     {function coll(k,v,acc)
       {var _bn_=[0,caml_call1(sexp_of_val,v),0];
        return [0,[1,[0,caml_call1(sexp_of_key,k),_bn_]],acc]}
      return [1,caml_call3(Stdlib_MoreLabels[1][14],coll,htbl,0)]}
    function sexp_of_opaque(param){return _g_}
    function sexp_of_fun(param){return _h_}
    function equal$0(_bm_,_bl_){return _bm_ === _bl_?1:0}
    var
     hash=Stdlib_Obj[22][3],
     Exn_table=caml_call1(Stdlib_Ephemeron[1][16],[0,equal$0,hash]),
     the_exn_table=caml_call1(Exn_table[1],17);
    function add(opt,param,extension_constructor,sexp_of_exn)
     {if(opt)var sth=opt[1],printexc=sth;else var printexc=1;
      return caml_call3
              (Exn_table[5],
               the_exn_table,
               extension_constructor,
               [0,sexp_of_exn,printexc])}
    function find_auto(for_printexc,exn)
     {var
       extension_constructor=caml_call1(Stdlib_Obj[22][1],exn),
       match=caml_call2(Exn_table[8],the_exn_table,extension_constructor);
      if(! match)return 0;
      var match$0=match[1],printexc=match$0[2],sexp_of_exn=match$0[1];
      if(for_printexc && ! printexc)return 0;
      return [0,caml_call1(sexp_of_exn,exn)]}
    function size$0(param){return caml_call1(Exn_table[24],the_exn_table)[1]}
    var For_unit_tests_only=[0,size$0];
    function sexp_of_exn_opt(exn){return find_auto(0,exn)}
    function sexp_of_exn(exn)
     {var match=sexp_of_exn_opt(exn);
      if(! match)return [1,[0,[0,caml_call1(Stdlib_Printexc[1],exn)],0]];
      var sexp=match[1];
      return sexp}
    function exn_to_string(e){return to_string_hum(0,sexp_of_exn(e))}
    function _i_(exn)
     {var match=find_auto(1,exn);
      if(! match)return 0;
      var sexp=match[1];
      return [0,to_string_hum(_j_,sexp)]}
    caml_call1(Stdlib_Printexc[9],_i_);
    function printexc_prefer_sexp(exn)
     {var match=sexp_of_exn_opt(exn);
      if(! match)return caml_call1(Stdlib_Printexc[1],exn);
      var sexp=match[1];
      return to_string_hum(_k_,sexp)}
    var record_check_extra_fields=[0,1];
    function of_sexp_error_exn(exc,sexp){throw [0,Of_sexp_error,exc,sexp]}
    function of_sexp_error(what,sexp)
     {throw [0,Of_sexp_error,[0,Stdlib[7],what],sexp]}
    function unit_of_sexp(sexp)
     {if(1 === sexp[0] && ! sexp[1])return 0;
      return of_sexp_error(cst_unit_of_sexp_empty_list_ne,sexp)}
    function bool_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_bool_of_sexp_atom_needed,sexp);
      var _bk_=sexp[1];
      if(caml_string_notequal(_bk_,cst_False))
       {var switch$0=0;
        if(caml_string_notequal(_bk_,cst_True))
         if(caml_string_notequal(_bk_,cst_false))
          {if(caml_string_notequal(_bk_,cst_true))
            return of_sexp_error(cst_bool_of_sexp_unknown_strin,sexp)}
         else
          switch$0 = 1;
        if(! switch$0)return 1}
      return 0}
    function string_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_string_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      return str}
    function bytes_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_bytes_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      return caml_call1(Stdlib_BytesLabels[5],str)}
    function char_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_char_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      if(1 !== caml_ml_string_length(str))
       of_sexp_error(cst_char_of_sexp_atom_string_m,sexp);
      return caml_string_get(str,0)}
    function int_of_sexp(sexp)
     {if(0 !== sexp[0])return of_sexp_error(cst_int_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bj_=caml_int_of_string(str);return _bj_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bi_=exn_to_string(exc);
        return of_sexp_error(caml_call2(Stdlib[28],cst_int_of_sexp,_bi_),sexp)}}
    function float_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_float_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bh_=caml_float_of_string(str);return _bh_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bg_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_float_of_sexp,_bg_),sexp)}}
    function int32_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_int32_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bf_=caml_int_of_string(str);return _bf_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _be_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_int32_of_sexp,_be_),sexp)}}
    function int64_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_int64_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bd_=runtime.caml_int64_of_string(str);return _bd_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bc_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_int64_of_sexp,_bc_),sexp)}}
    function nativeint_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_nativeint_of_sexp_atom_nee,sexp);
      var str=sexp[1];
      try
       {var _bb_=caml_int_of_string(str);return _bb_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _ba_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_nativeint_of_sexp,_ba_),sexp)}}
    function ref_of_sexp(a_of_sexp,sexp)
     {return [0,caml_call1(a_of_sexp,sexp)]}
    function lazy_t_of_sexp(a_of_sexp,sexp)
     {var _a$_=caml_call1(a_of_sexp,sexp);
      return caml_call1(Stdlib_Lazy[4],_a$_)}
    function option_of_sexp(a_of_sexp,sexp)
     {if(! read_old_option_format[1])
       {if(0 === sexp[0])
         {var _a6_=sexp[1];
          if
           (caml_string_notequal(_a6_,cst_None$0)
            &&
            caml_string_notequal(_a6_,cst_none$0))
           return of_sexp_error(cst_option_of_sexp_only_none_c$0,sexp);
          return 0}
        var _a7_=sexp[1];
        if(_a7_)
         {var _a8_=_a7_[1];
          if(0 === _a8_[0])
           {var _a9_=_a8_[1],switch$2=0;
            if
             (!
              caml_string_notequal(_a9_,cst_Some$0)
              ||
              !
              caml_string_notequal(_a9_,cst_some$0))
             switch$2 = 1;
            if(switch$2)
             {var _a__=_a7_[2];
              if(_a__ && ! _a__[2])
               {var el$0=_a__[1];return [0,caml_call1(a_of_sexp,el$0)]}}}}
        return of_sexp_error(cst_option_of_sexp_list_must_b,sexp)}
      if(0 === sexp[0])
       {var _a1_=sexp[1];
        if
         (caml_string_notequal(_a1_,cst_None)
          &&
          caml_string_notequal(_a1_,cst_none))
         return of_sexp_error(cst_option_of_sexp_only_none_c,sexp)}
      else
       {var _a2_=sexp[1];
        if(_a2_)
         {var _a3_=_a2_[1];
          if(_a2_[2])
           {var switch$0=0;
            if(0 === _a3_[0])
             {var _a4_=_a3_[1],switch$1=0;
              if
               (caml_string_notequal(_a4_,cst_Some)
                &&
                caml_string_notequal(_a4_,cst_some))
               switch$1 = 1;
              if(! switch$1)
               {var _a5_=_a2_[2];if(! _a5_[2]){var el=_a5_[1];switch$0 = 1}}}
            if(! switch$0)
             return of_sexp_error(cst_option_of_sexp_list_must_r,sexp)}
          else
           var el=_a3_;
          return [0,caml_call1(a_of_sexp,el)]}}
      return 0}
    function pair_of_sexp(a_of_sexp,b_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_pair_of_sexp_list_needed,sexp);
      var _aZ_=sexp[1];
      if(_aZ_)
       {var _a0_=_aZ_[2];
        if(_a0_ && ! _a0_[2])
         {var
           b_sexp=_a0_[1],
           a_sexp=_aZ_[1],
           a=caml_call1(a_of_sexp,a_sexp),
           b=caml_call1(b_of_sexp,b_sexp);
          return [0,a,b]}}
      return of_sexp_error(cst_pair_of_sexp_list_must_con,sexp)}
    function triple_of_sexp(a_of_sexp,b_of_sexp,c_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_triple_of_sexp_list_needed,sexp);
      var _aW_=sexp[1];
      if(_aW_)
       {var _aX_=_aW_[2];
        if(_aX_)
         {var _aY_=_aX_[2];
          if(_aY_ && ! _aY_[2])
           {var
             c_sexp=_aY_[1],
             b_sexp=_aX_[1],
             a_sexp=_aW_[1],
             a=caml_call1(a_of_sexp,a_sexp),
             b=caml_call1(b_of_sexp,b_sexp),
             c=caml_call1(c_of_sexp,c_sexp);
            return [0,a,b,c]}}}
      return of_sexp_error(cst_triple_of_sexp_list_must_c,sexp)}
    function list_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_list_of_sexp_list_needed,sexp);
      var lst=sexp[1],rev_lst=caml_call2(Stdlib_ListLabels[21],a_of_sexp,lst);
      return caml_call1(Stdlib_ListLabels[9],rev_lst)}
    function array_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_array_of_sexp_list_needed,sexp);
      var _aU_=sexp[1];
      if(! _aU_)return [0];
      var
       t=_aU_[2],
       h=_aU_[1],
       len=caml_call1(Stdlib_ListLabels[1],t) + 1 | 0,
       res=runtime.caml_make_vect(len,caml_call1(a_of_sexp,h)),
       i=1,
       param=t;
      for(;;)
       {if(! param)return res;
        var t$0=param[2],h$0=param[1],_aV_=caml_call1(a_of_sexp,h$0);
        caml_check_bound(res,i)[1 + i] = _aV_;
        var i$0=i + 1 | 0,i=i$0,param=t$0}}
    function hashtbl_of_sexp(key_of_sexp,val_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_hashtbl_of_sexp_list_neede,sexp);
      var lst=sexp[1],htbl=caml_call2(Stdlib_MoreLabels[1][1],0,0);
      function act(param)
       {if(1 === param[0])
         {var _aQ_=param[1];
          if(_aQ_)
           {var _aR_=_aQ_[2];
            if(_aR_ && ! _aR_[2])
             {var
               v_sexp=_aR_[1],
               k_sexp=_aQ_[1],
               _aS_=caml_call1(val_of_sexp,v_sexp),
               _aT_=caml_call1(key_of_sexp,k_sexp);
              return caml_call3(Stdlib_MoreLabels[1][5],htbl,_aT_,_aS_)}}}
        return of_sexp_error(cst_hashtbl_of_sexp_tuple_list,sexp)}
      caml_call2(Stdlib_ListLabels[17],act,lst);
      return htbl}
    function opaque_of_sexp(sexp)
     {return of_sexp_error(cst_opaque_of_sexp_cannot_conv,sexp)}
    function fun_of_sexp(sexp)
     {return of_sexp_error(cst_fun_of_sexp_cannot_convert,sexp)}
    function get_flc_error(name,param)
     {var chr=param[3],line=param[2],file=param[1];
      return [0,caml_call5(Stdlib_Printf[4],_l_,name,file,line,chr)]}
    var _m_=0;
    function _n_(param)
     {if(param === Stdlib_Sys[44])return _o_;throw [0,Assert_failure,_p_]}
    var _q_=[0,[0,Stdlib_Sys[44],_n_],_m_];
    function _r_(param)
     {if(param === Stdlib_Stack[1])return _s_;throw [0,Assert_failure,_t_]}
    var _u_=[0,[0,Stdlib_Stack[1],_r_],_q_];
    function _v_(param)
     {if(param[1] !== Stdlib_Scanf[2])throw [0,Assert_failure,_x_];
      var arg=param[2];
      return [1,[0,_w_,[0,[0,arg],0]]]}
    var _y_=[0,[0,Stdlib_Scanf[2],_v_],_u_];
    function _z_(param)
     {if(param === Stdlib_Queue[1])return _A_;throw [0,Assert_failure,_B_]}
    var _C_=[0,[0,Stdlib_Queue[1],_z_],_y_];
    function _D_(param)
     {if(param === Stdlib_Parsing[10])return _E_;throw [0,Assert_failure,_F_]}
    var _G_=[0,[0,Stdlib_Parsing[10],_D_],_C_];
    function _H_(param)
     {if(param === Stdlib_Lazy[1])return _I_;throw [0,Assert_failure,_J_]}
    var _K_=[0,[0,Stdlib_Lazy[1],_H_],_G_];
    function _L_(param)
     {if(param[1] !== Stdlib_Arg[8])throw [0,Assert_failure,_N_];
      var arg=param[2];
      return [1,[0,_M_,[0,[0,arg],0]]]}
    var _O_=[0,[0,Stdlib_Arg[8],_L_],_K_];
    function _P_(param)
     {if(param[1] !== Stdlib_Arg[7])throw [0,Assert_failure,_R_];
      var arg=param[2];
      return [1,[0,_Q_,[0,[0,arg],0]]]}
    var _S_=[0,[0,Stdlib_Arg[7],_P_],_O_];
    function _T_(param)
     {if(param[1] !== Stdlib[11])throw [0,Assert_failure,_V_];
      var arg=param[2];
      return [1,[0,_U_,[0,[0,arg],0]]]}
    var
     _W_=[0,[0,Stdlib[11],_T_],_S_],
     _Z_=
      [0,
       [0,
        Not_found_s,
        function(param)
         {if(param[1] !== Not_found_s)throw [0,Assert_failure,_Y_];
          var arg=param[2];
          return [1,[0,_X_,[0,arg,0]]]}],
       _W_];
    function ___(param)
     {if(param[1] !== Stdlib[4])throw [0,Assert_failure,_$_];
      var arg=param[2];
      return get_flc_error(cst_Match_failure,arg)}
    var _aa_=[0,[0,Stdlib[4],___],_Z_];
    function _ab_(param)
     {if(param[1] !== Stdlib[6])throw [0,Assert_failure,_ad_];
      var arg=param[2];
      return [1,[0,_ac_,[0,[0,arg],0]]]}
    var _ae_=[0,[0,Stdlib[6],_ab_],_aa_];
    function _af_(param)
     {if(param === Stdlib[8])return _ag_;throw [0,Assert_failure,_ah_]}
    var _ai_=[0,[0,Stdlib[8],_af_],_ae_];
    function _aj_(param)
     {if(param[1] !== Stdlib[7])throw [0,Assert_failure,_al_];
      var arg=param[2];
      return [1,[0,_ak_,[0,[0,arg],0]]]}
    var _am_=[0,[0,Stdlib[7],_aj_],_ai_];
    function _an_(param)
     {if(param === Stdlib[12])return _ao_;throw [0,Assert_failure,_ap_]}
    var _aq_=[0,[0,Stdlib[12],_an_],_am_];
    function _ar_(param)
     {if(param === Stdlib[3])return _as_;throw [0,Assert_failure,_at_]}
    var _au_=[0,[0,Stdlib[3],_ar_],_aq_];
    function _av_(param)
     {if(param[1] !== Stdlib[5])throw [0,Assert_failure,_aw_];
      var arg=param[2];
      return get_flc_error(cst_Assert_failure,arg)}
    var _ax_=[0,[0,Stdlib[5],_av_],_au_];
    function _ay_(param)
     {var handler=param[2],extension_constructor=param[1];
      return add(_aA_,_az_,extension_constructor,handler)}
    caml_call2(Stdlib_ListLabels[17],_ay_,_ax_);
    var
     _aB_=0,
     _aE_=
      [0,
       [0,
        Of_sexp_error,
        function(param)
         {if(param[1] !== Of_sexp_error)throw [0,Assert_failure,_aD_];
          var sexp=param[3],exc=param[2];
          return [1,[0,_aC_,[0,sexp_of_exn(exc),[0,sexp,0]]]]}],
       _aB_];
    function _aF_(param)
     {var handler=param[2],extension_constructor=param[1];
      return add(_aH_,_aG_,extension_constructor,handler)}
    caml_call2(Stdlib_ListLabels[17],_aF_,_aE_);
    var
     Sexplib0_Sexp_conv=
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       fun_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0,add,For_unit_tests_only]];
    caml_register_global(170,Sexplib0_Sexp_conv,"Sexplib0__Sexp_conv");
    function tuple_of_size_n_expected(loc,n,sexp)
     {return of_sexp_error(caml_call3(Stdlib_Printf[4],_aI_,loc,n),sexp)}
    function stag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_this_constructor_d),sexp)}
    function stag_incorrect_n_args(loc,tag,sexp)
     {var msg=caml_call3(Stdlib_Printf[4],_aJ_,loc,tag);
      return of_sexp_error(msg,sexp)}
    function stag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_this_constructor_r),sexp)}
    function nested_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_expected_a_variant),sexp)}
    function empty_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_expected_a_variant$0),
               sexp)}
    function unexpected_stag(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_unexpected_variant),sexp)}
    function record_sexp_bool_with_payload(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_record_conversion_);
      return of_sexp_error(msg,sexp)}
    function record_only_pairs_expected(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_record_conversion_$0);
      return of_sexp_error(msg,sexp)}
    function record_superfluous_fields(what,loc,rev_fld_names,sexp)
     {var
       _aP_=caml_call1(Stdlib_ListLabels[9],rev_fld_names),
       fld_names_str=caml_call2(Stdlib_StringLabels[6],cst$12,_aP_),
       msg=caml_call4(Stdlib_Printf[4],_aK_,loc,what,fld_names_str);
      return of_sexp_error(msg,sexp)}
    function record_duplicate_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_duplicate_fields,loc,rev_fld_names,sexp)}
    function record_extra_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_extra_fields,loc,rev_fld_names,sexp)}
    function record_get_undefined_loop(fields,param)
     {var fields$0=fields,param$0=param;
      for(;;)
       {if(! param$0)
         {var _aO_=caml_call1(Stdlib_ListLabels[9],fields$0);
          return caml_call2(Stdlib_StringLabels[6],cst$13,_aO_)}
        var _aN_=param$0[1];
        if(_aN_[1])
         {var
           param$1=param$0[2],
           field=_aN_[2],
           fields$1=[0,field,fields$0],
           fields$0=fields$1,
           param$0=param$1;
          continue}
        var param$2=param$0[2],param$0=param$2}}
    function record_undefined_elements(loc,sexp,lst)
     {var
       undefined$0=record_get_undefined_loop(0,lst),
       msg=caml_call3(Stdlib_Printf[4],_aL_,loc,undefined$0);
      return of_sexp_error(msg,sexp)}
    function record_list_instead_atom(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_list_instead_of_at);
      return of_sexp_error(msg,sexp)}
    function record_poly_field_value(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_cannot_convert_val);
      return of_sexp_error(msg,sexp)}
    var
     No_variant_match=
      [248,cst_Sexplib0_Sexp_conv_error_N,caml_fresh_oo_id(0)];
    function no_variant_match(param){throw No_variant_match}
    function no_matching_variant_found(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_no_matching_varian),sexp)}
    function ptag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_polymorphic_varian),sexp)}
    function ptag_incorrect_n_args(loc,cnstr,sexp)
     {var msg=caml_call3(Stdlib_Printf[4],_aM_,loc,cnstr);
      return of_sexp_error(msg,sexp)}
    function ptag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_polymorphic_varian$0),
               sexp)}
    function nested_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_a_nested_list_is_a),sexp)}
    function empty_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_the_empty_list_is_),sexp)}
    function empty_type(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_trying_to_convert_),sexp)}
    var
     Sexplib0_Sexp_conv_error=
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
    caml_register_global
     (171,Sexplib0_Sexp_conv_error,"Sexplib0__Sexp_conv_error");
    var Sexplib0_Sexpable=[0];
    caml_register_global(172,Sexplib0_Sexpable,"Sexplib0__Sexpable");
    var Sexplib0$0=[0];
    caml_register_global(173,Sexplib0$0,"Sexplib0");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZG9jX2NvbW1lbnRfdGFnIiwic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJiJDEiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDMiLCJpeCIsIml4JDAiLCJpeCQyIiwiaXgkMSIsImVzY2FwZWQiLCJzIiwibiIsImkkMCIsInMkMCIsImkiLCJjIiwiZXNjX3N0ciIsInNyYyIsImRzdCIsImluZGV4X29mX25ld2xpbmUiLCJzdGFydCIsIm1hY2hfbWF5YmVfZXNjX3N0ciIsInBwX2h1bV9pbmRlbnQiLCJpbmRlbnQiLCJwcGYiLCJpbmRleCIsImluZGV4JDAiLCJlbmRfcG9zX29wdCIsImVuZF9wb3MiLCJlbmRfcG9zJDAiLCJuZXh0X2xpbmUiLCJuZXdsaW5lX2luZGV4IiwiaW5kZXgkMSIsImgiLCJ0JDAiLCJoJDAiLCJwcF9tYWNoX2ludGVybmFsIiwibWF5X25lZWRfc3BhY2UiLCJzdHIkMCIsIm5ld19tYXlfbmVlZF9zcGFjZSIsIm5ld19tYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMCIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHAiLCJzaXplX2xvb3AiLCJhY2MiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlciIsImxvb3AiLCJ0b19idWZmZXJfZ2VuIiwiYWRkX2NoYXIiLCJhZGRfc3RyaW5nIiwiYnVmZmVyIiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZyIsIm9mX2Zsb2F0X3N0eWxlIiwib2ZfaW50X3N0eWxlIiwibWVzc2FnZSIsIm5hbWUiLCJmaWVsZHMiLCJjb252X2ZpZWxkcyIsInJlc3QiLCJmc2V4cCIsImZuYW1lIiwiY29lcmNlIiwiZ3JhbW1hciIsInBhcmFtIiwiZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQiLCJyZWFkX29sZF9vcHRpb25fZm9ybWF0Iiwid3JpdGVfb2xkX29wdGlvbl9mb3JtYXQiLCJsaXN0X21hcCIsImYiLCJsIiwic2V4cF9vZl91bml0Iiwic2V4cF9vZl9ib29sIiwic2V4cF9vZl9zdHJpbmciLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXMiLCJzZXhwX29mX2NoYXIiLCJzZXhwX29mX2ludCIsInNleHBfb2ZfZmxvYXQiLCJzZXhwX29mX2ludDMyIiwic2V4cF9vZl9pbnQ2NCIsInNleHBfb2ZfbmF0aXZlaW50Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX2EiLCJyZiIsInNleHBfb2ZfbGF6eV90IiwibHYiLCJzZXhwX29mX29wdGlvbiIsInNleHBfb2ZfcGFpciIsInNleHBfb2ZfYiIsInNleHBfb2ZfdHJpcGxlIiwic2V4cF9vZl9jIiwic2V4cF9vZl9saXN0Iiwic2V4cF9vZl9hcnJheSIsImFyIiwibHN0X3JlZiIsInNleHBfb2ZfaGFzaHRibCIsInNleHBfb2Zfa2V5Iiwic2V4cF9vZl92YWwiLCJodGJsIiwiY29sbCIsImsiLCJ2Iiwic2V4cF9vZl9vcGFxdWUiLCJzZXhwX29mX2Z1biIsImVxdWFsJDAiLCJoYXNoIiwidGhlX2V4bl90YWJsZSIsImFkZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJzaXplJDAiLCJzZXhwX29mX2V4bl9vcHQiLCJleG5fdG9fc3RyaW5nIiwiZSIsInByaW50ZXhjX3ByZWZlcl9zZXhwIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsIm9mX3NleHBfZXJyb3JfZXhuIiwiZXhjIiwib2Zfc2V4cF9lcnJvciIsIndoYXQiLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImZsb2F0X29mX3NleHAiLCJpbnQzMl9vZl9zZXhwIiwiaW50NjRfb2Zfc2V4cCIsIm5hdGl2ZWludF9vZl9zZXhwIiwicmVmX29mX3NleHAiLCJhX29mX3NleHAiLCJsYXp5X3Rfb2Zfc2V4cCIsIm9wdGlvbl9vZl9zZXhwIiwiZWwkMCIsImVsIiwicGFpcl9vZl9zZXhwIiwiYl9vZl9zZXhwIiwiYl9zZXhwIiwiYV9zZXhwIiwidHJpcGxlX29mX3NleHAiLCJjX29mX3NleHAiLCJjX3NleHAiLCJsaXN0X29mX3NleHAiLCJyZXZfbHN0IiwiYXJyYXlfb2Zfc2V4cCIsImhhc2h0Ymxfb2Zfc2V4cCIsImtleV9vZl9zZXhwIiwidmFsX29mX3NleHAiLCJhY3QiLCJ2X3NleHAiLCJrX3NleHAiLCJvcGFxdWVfb2Zfc2V4cCIsImZ1bl9vZl9zZXhwIiwiZ2V0X2ZsY19lcnJvciIsImNociIsImxpbmUiLCJmaWxlIiwiYXJnIiwiaGFuZGxlciIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsImxvYyIsInN0YWdfbm9fYXJncyIsInN0YWdfaW5jb3JyZWN0X25fYXJncyIsInRhZyIsIm1zZyIsInN0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSIsInVuZXhwZWN0ZWRfc3RhZyIsInJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIiwicmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQiLCJyZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIiwicmV2X2ZsZF9uYW1lcyIsImZsZF9uYW1lc19zdHIiLCJyZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyIsInJlY29yZF9leHRyYV9maWVsZHMiLCJyZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIiwicGFyYW0kMSIsImZpZWxkIiwicGFyYW0kMiIsInJlY29yZF91bmRlZmluZWRfZWxlbWVudHMiLCJ1bmRlZmluZWQkMCIsInJlY29yZF9saXN0X2luc3RlYWRfYXRvbSIsInJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIiwibm9fdmFyaWFudF9tYXRjaCIsIm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQiLCJwdGFnX25vX2FyZ3MiLCJwdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJjbnN0ciIsInB0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV90eXBlIl0sInNvdXJjZXMiOlsiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3NleHBsaWIwL3NleHBfZ3JhbW1hci5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9zZXhwbGliMC9zZXhwLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3NleHBsaWIwL3NleHBfY29udl9ncmFtbWFyLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3NleHBsaWIwL3NleHBfY29udi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZXJyb3IubWwiXSwibWFwcGluZ3MiOiI7Ozs7O0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBOExJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQy9LQUMsVUFBVUMsR0FBSSxPQUFKQSxDQUFLO2FBQ2ZDLFVBQVVELEdBQUksT0FBSkEsQ0FBSzthQVdmRSxRQUFRQyxJQUFF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QUM7T0FNQUM7T0FPQUM7T0FTQUM7T0FNQUc7T0FJQUM7T0FJSUM7T0FNSkk7T0FRQUU7T0FLQUM7O09BWUFDO09BRUFDO09BSUFDO09BSUFDO09BVUFFO09BSUFDO09BSUFDO09BSUFDOzs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiogUmVwcmVzZW50YXRpb24gb2YgUy1leHByZXNzaW9uIGdyYW1tYXJzICopXG5cbigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGEgcmVwcmVzZW50YXRpb24gZm9yIHMtZXhwcmVzc2lvbiBncmFtbWFycy4gVXNpbmcgcHB4X3NleHBfY29udlxuICAgIGFuZCBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gcHJvZHVjZXMgYSBncmFtbWFyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXJpdmVkXG4gICAgW29mX3NleHBdIGZvciBhIGdpdmVuIHR5cGUuXG5cbiAgICBBcyB3aXRoIG90aGVyIGRlcml2ZWQgZGVmaW5pdGlvbnMsIHBvbHltb3JwaGljIHR5cGVzIGRlcml2ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICAgIGdyYW1tYXIgZm9yIGVhY2ggdHlwZSBhcmd1bWVudCBhbmQgcHJvZHVjZXMgYSBncmFtbWFyIGZvciB0aGUgbW9ub21vcnBoaXplZCB0eXBlLlxuXG4gICAgTW9ub21vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZ3JhbW1hciBkaXJlY3RseS4gVG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cyxcbiAgICBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gd3JhcHMgZ3JhbW1hcnMgaW4gdGhlIFtMYXp5XSBjb25zdHJ1Y3RvciBhcyBuZWVkZWQuXG5cbiAgICBUaGlzIHR5cGUgbWF5IGNoYW5nZSBvdmVyIHRpbWUgYXMgb3VyIG5lZWRzIGZvciBleHByZXNzaXZlIGdyYW1tYXJzIGNoYW5nZS4gV2Ugd2lsbFxuICAgIGF0dGVtcHQgdG8gbWFrZSBjaGFuZ2VzIGJhY2t3YXJkLWNvbXBhdGlibGUsIG9yIGF0IGxlYXN0IHByb3ZpZGUgYSByZWFzb25hYmxlIHVwZ3JhZGVcbiAgICBwYXRoLiAqKVxuXG5bQEBAd2FybmluZyBcIi0zMFwiXSAoKiBhbGxvdyBkdXBsaWNhdGUgZmllbGQgbmFtZXMgKilcblxuKCoqIEdyYW1tYXIgb2YgYSBzZXhwLiAqKVxudHlwZSBncmFtbWFyID1cbiAgfCBBbnkgb2Ygc3RyaW5nICgqKiBhY2NlcHRzIGFueSBzZXhwOyBzdHJpbmcgaXMgYSB0eXBlIG5hbWUgZm9yIGh1bWFuIHJlYWRhYmlsaXR5ICopXG4gIHwgQm9vbCAoKiogYWNjZXB0cyB0aGUgYXRvbXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLCBtb2R1bG8gY2FwaXRhbGl6YXRpb24gKilcbiAgfCBDaGFyICgqKiBhY2NlcHRzIGFueSBzaW5nbGUtY2hhcmFjdGVyIGF0b20gKilcbiAgfCBJbnRlZ2VyICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGludGVnZXIgc3ludGF4LCByZWdhcmRsZXNzIG9mIGJpdCB3aWR0aCAqKVxuICB8IEZsb2F0ICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGZsb2F0IHN5bnRheCAqKVxuICB8IFN0cmluZyAoKiogYWNjZXB0cyBhbnkgYXRvbSAqKVxuICB8IE9wdGlvbiBvZiBncmFtbWFyICgqKiBhY2NlcHRzIGFuIG9wdGlvbiwgYm90aCBbTm9uZV0gdnMgW1NvbWUgX10gYW5kIFsoKV0gdnMgWyhfKV0uICopXG4gIHwgTGlzdCBvZiBsaXN0X2dyYW1tYXIgKCoqIGFjY2VwdHMgYSBsaXN0ICopXG4gIHwgVmFyaWFudCBvZiB2YXJpYW50ICgqKiBhY2NlcHRzIGNsYXVzZXMga2V5ZWQgYnkgYSBsZWFkaW5nIG9yIHNvbGUgYXRvbSAqKVxuICB8IFVuaW9uIG9mIGdyYW1tYXIgbGlzdCAoKiogYWNjZXB0cyBhIHNleHAgaWYgYW55IG9mIHRoZSBsaXN0ZWQgZ3JhbW1hcnMgYWNjZXB0cyBpdCAqKVxuICB8IFRhZ2dlZCBvZiBncmFtbWFyIHdpdGhfdGFnXG4gICgqKiBhbm5vdGF0ZXMgYSBncmFtbWFyIHdpdGggYSBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIgKilcbiAgfCBUeXZhciBvZiBzdHJpbmdcbiAgKCoqIE5hbWUgb2YgYSB0eXBlIHZhcmlhYmxlLCBlLmcuIFtUeXZhciBcImFcIl0gZm9yIFsnYV0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBib2R5IG9mXG4gICAgICB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbZGVmbl0gZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSB2YXJpYWJsZS4gKilcbiAgfCBUeWNvbiBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3RcbiAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMuIEZvciBleGFtcGxlLCBbVHljb24gKFwibGlzdFwiLCBbIEludGVnZXIgXSldXG4gICAgICByZXByZXNlbnRzIFtpbnQgbGlzdF0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBpbm5lcm1vc3QgZW5jbG9zaW5nIFtSZWN1cnNpdmVdXG4gICAgICBncmFtbWFyIGRlZmluZXMgYSBjb3JyZXNwb25kaW5nIHR5cGUgY29uc3RydWN0b3IuICopXG4gIHwgUmVjdXJzaXZlIG9mIGdyYW1tYXIgKiBkZWZuIGxpc3RcbiAgKCoqIFtSZWN1cnNpdmUgKGdyYW1tYXIsIGRlZmluaXRpb25zKV0gYWxsb3dzIFtncmFtbWFyXSB0byByZWZlciB0byB0eXBlIGNvbnN0cnVjdG9yc1xuICAgICAgZnJvbSB0aGUgbXV0dWFsbHkgcmVjdXJzaXZlIFtkZWZpbml0aW9uc10uIFRoZSBkZWZpbml0aW9ucyBtYXkgYWxzbyByZWZlciB0byBlYWNoXG4gICAgICBvdGhlcnMnIHR5cGUgY29uc3RydWN0b3JzLlxuXG4gICAgICBPcmRpbmFyaWx5LCBbZ3JhbW1hcl0gaXRzZWxmIGlzIGp1c3QgYSBbVHljb25dIGFyZ3VtZW50LCBhbHRob3VnaCB0ZWNobmljYWxseSBpdCBjYW5cbiAgICAgIGJlIGFueSBncmFtbWFyLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBkZWZpbml0aW9ucyBkZWZpbmUgYSBiaW5hcnkgdHJlZSBwYXJhbWV0ZXJpemVkIGJ5IGEgdHlwZVxuICAgICAgc3RvcmVkIGF0IGl0cyBsZWF2ZXMuXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBkZWZucyA9XG4gICAgICAgICAgWyB7IHR5Y29uID0gXCJ0cmVlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJUcmVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcImxlYWZcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHsgdHljb24gPSBcIm5vZGVcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBMaXN0IChNYW55IChUeWNvbiBcInRyZWVcIiwgW1R5dmFyIFwiYVwiXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJsZWFmXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gW1R5dmFyIFwiYVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgOztcbiAgICAgIF19XG5cbiAgICAgIE5vcm1hbGx5LCB0aGUgdHlwZSBvZiBhIHRyZWUgc3RvcmluZyBpbnRlZ2VycyB3b3VsZCBiZSB3cml0dGVuIGxpa2UgdGhpczpcblxuICAgICAge1tcbiAgICAgICAgUmVjdXJzaXZlIChUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdKSwgZGVmbnMpXG4gICAgICBdfVxuXG4gICAgICBJdCBpcyBlcXVpdmFsZW50LCB0aG91Z2ggbmVlZGxlc3NseSB2ZXJib3NlLCB0byByZXBsYWNlIHRoZSBbVHljb25dIHJlZmVyZW5jZSB3aXRoXG4gICAgICB0aGUgZ3JhbW1hciBvZiBbXCJ0cmVlXCJdLCBzdWJzdGl0dXRpbmcgW0ludGVnZXJdIGZvciBbVHl2YXIgXCJhXCJdOlxuXG4gICAgICB7W1xuICAgICAgICBSZWN1cnNpdmVcbiAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOyB7IG5hbWUgPSBcIlRyZWVcIlxuICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgLCBkZWZucyApXG4gICAgICBdfVxuICAqKVxuICB8IExhenkgb2YgZ3JhbW1hciBsYXp5X3RcbiAgKCoqIExhemlseSBjb21wdXRlZCBncmFtbWFyLiBVc2UgW0xhenldIHRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMuIFRvIGRlZmluZVxuICAgICAgcmVjdXJzaXZlIGdyYW1tYXJzLCB1c2UgW1JlY3Vyc2l2ZV0gaW5zdGVhZC4gKilcblxuKCoqIEdyYW1tYXIgb2YgYSBsaXN0IG9mIHNleHBzLiAqKVxuYW5kIGxpc3RfZ3JhbW1hciA9XG4gIHwgRW1wdHkgKCoqIGFjY2VwdHMgYW4gZW1wdHkgbGlzdCBvZiBzZXhwcyAqKVxuICB8IENvbnMgb2YgZ3JhbW1hciAqIGxpc3RfZ3JhbW1hclxuICAoKiogYWNjZXB0cyBhIG5vbi1lbXB0eSBsaXN0IHdpdGggaGVhZCBhbmQgdGFpbCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hcnMgKilcbiAgfCBNYW55IG9mIGdyYW1tYXIgKCoqIGFjY2VwdHMgemVybyBvciBtb3JlIHNleHBzLCBlYWNoIG1hdGNoaW5nIHRoZSBnaXZlbiBncmFtbWFyICopXG4gIHwgRmllbGRzIG9mIHJlY29yZCAoKiogYWNjZXB0cyBzZXhwcyByZXByZXNlbnRpbmcgZmllbGRzIG9mIGEgcmVjb3JkICopXG5cbigqKiBDYXNlIHNlbnNpdGl2aXR5IG9wdGlvbnMgZm9yIG5hbWVzIG9mIHZhcmlhbnQgY29uc3RydWN0b3JzLiAqKVxuYW5kIGNhc2Vfc2Vuc2l0aXZpdHkgPVxuICB8IENhc2VfaW5zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZS4gVXNlZCBmb3IgY3VzdG9tIHBhcnNlcnMuICopXG4gIHwgQ2FzZV9zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBzZW5zaXRpdmUuIFVzZWQgZm9yIHBvbHltb3JwaGljIHZhcmlhbnRzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZSBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgY2FzZSBzZW5zaXRpdmUgYWZ0ZXJ3YXJkLlxuICAgICAgVXNlZCBmb3IgcmVndWxhciB2YXJpYW50cy4gKilcblxuKCoqIEdyYW1tYXIgb2YgdmFyaWFudHMuIEFjY2VwdHMgYW55IHNleHAgbWF0Y2hpbmcgb25lIG9mIHRoZSBjbGF1c2VzLiAqKVxuYW5kIHZhcmlhbnQgPVxuICB7IGNhc2Vfc2Vuc2l0aXZpdHkgOiBjYXNlX3NlbnNpdGl2aXR5XG4gIDsgY2xhdXNlcyA6IGNsYXVzZSB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHNpbmdsZSB2YXJpYW50IGNsYXVzZS4gQWNjZXB0cyBzZXhwcyBiYXNlZCBvbiB0aGUgW2NsYXVzZV9raW5kXS4gKilcbmFuZCBjbGF1c2UgPVxuICB7IG5hbWUgOiBzdHJpbmdcbiAgOyBjbGF1c2Vfa2luZCA6IGNsYXVzZV9raW5kXG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UncyBjb250ZW50cy4gW0F0b21fY2xhdXNlXSBhY2NlcHRzIGFuIGF0b20gbWF0Y2hpbmdcbiAgICB0aGUgY2xhdXNlJ3MgbmFtZS4gW0xpc3RfY2xhdXNlXSBhY2NlcHRzIGEgbGlzdCB3aG9zZSBoZWFkIGlzIGFuIGF0b20gbWF0Y2hpbmcgdGhlXG4gICAgY2xhdXNlJ3MgbmFtZSBhbmQgd2hvc2UgdGFpbCBtYXRjaGVzIFthcmdzXS4gVGhlIGNsYXVzZSdzIG5hbWUgaXMgbWF0Y2hlZCBtb2R1bG8gdGhlXG4gICAgdmFyaWFudCdzIFtuYW1lX2tpbmRdLiAqKVxuYW5kIGNsYXVzZV9raW5kID1cbiAgfCBBdG9tX2NsYXVzZVxuICB8IExpc3RfY2xhdXNlIG9mIHsgYXJncyA6IGxpc3RfZ3JhbW1hciB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkLiBBY2NlcHRzIGFueSBsaXN0IG9mIHNleHBzIHNwZWNpZnlpbmcgZWFjaCBvZiB0aGUgZmllbGRzLFxuICAgIHJlZ2FyZGxlc3Mgb2Ygb3JkZXIuIElmIFthbGxvd19leHRyYV9maWVsZHNdIGlzIHNwZWNpZmllZCwgaWdub3JlcyBzZXhwcyB3aXRoIG5hbWVzXG4gICAgbm90IGZvdW5kIGluIFtmaWVsZHNdLiAqKVxuYW5kIHJlY29yZCA9XG4gIHsgYWxsb3dfZXh0cmFfZmllbGRzIDogYm9vbFxuICA7IGZpZWxkcyA6IGZpZWxkIHdpdGhfdGFnX2xpc3QgbGlzdFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkIGZpZWxkLiBBIGZpZWxkIG11c3Qgc2hvdyB1cCBleGFjdGx5IG9uY2UgaW4gYSByZWNvcmQgaWZcbiAgICBbcmVxdWlyZWRdLCBvciBhdCBtb3N0IG9uY2Ugb3RoZXJ3aXNlLiBBY2NlcHRzIGEgbGlzdCBoZWFkZWQgYnkgW25hbWVdIGFzIGFuIGF0b20sXG4gICAgZm9sbG93ZWQgYnkgc2V4cHMgbWF0Y2hpbmcgW2FyZ3NdLiAqKVxuYW5kIGZpZWxkID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgcmVxdWlyZWQgOiBib29sXG4gIDsgYXJncyA6IGxpc3RfZ3JhbW1hclxuICB9XG5cbigqKiBHcmFtbWFyIHRhZ2dlZCB3aXRoIGNsaWVudC1zcGVjaWZpYyBrZXkvdmFsdWUgcGFpci4gKilcbmFuZCAnYSB3aXRoX3RhZyA9XG4gIHsga2V5IDogc3RyaW5nXG4gIDsgdmFsdWUgOiBTZXhwLnRcbiAgOyBncmFtbWFyIDogJ2FcbiAgfVxuXG5hbmQgJ2Egd2l0aF90YWdfbGlzdCA9XG4gIHwgVGFnIG9mICdhIHdpdGhfdGFnX2xpc3Qgd2l0aF90YWdcbiAgfCBOb190YWcgb2YgJ2FcblxuKCoqIEdyYW1tYXIgb2YgYSByZWN1cnNpdmUgdHlwZSBkZWZpbml0aW9uLiBOYW1lcyB0aGUgW3R5Y29uXSBiZWluZyBkZWZpbmVkLCBhbmQgdGhlXG4gICAgW3R5dmFyc10gaXQgdGFrZXMgYXMgcGFyYW1ldGVycy4gU3BlY2lmaWVzIHRoZSBbZ3JhbW1hcl0gb2YgdGhlIFt0eWNvbl0uIFRoZSBncmFtbWFyXG4gICAgbWF5IHJlZmVyIHRvIGFueSBvZiB0aGUgW3R5dmFyc10sIGFuZCB0byBhbnkgb2YgdGhlIFt0eWNvbl1zIGZyb20gdGhlIHNhbWUgc2V0IG9mXG4gICAgW1JlY3Vyc2l2ZV0gZGVmaW5pdGlvbnMuICopXG5hbmQgZGVmbiA9XG4gIHsgdHljb24gOiBzdHJpbmdcbiAgOyB0eXZhcnMgOiBzdHJpbmcgbGlzdFxuICA7IGdyYW1tYXIgOiBncmFtbWFyXG4gIH1cblxuKCoqIFRvcC1sZXZlbCBncmFtbWFyIHR5cGUuIEhhcyBhIHBoYW50b20gdHlwZSBwYXJhbWV0ZXIgdG8gYXNzb2NpYXRlIGVhY2ggZ3JhbW1hciB3aXRoXG4gICAgdGhlIHR5cGUgaXRzIHNleHBzIHJlcHJlc2VudC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gYXBwbHkgZ3JhbW1hcnMgdG8gdGhlIHdyb25nXG4gICAgdHlwZSwgd2hpbGUgZ3JhbW1hcnMgY2FuIHN0aWxsIGJlIGVhc2lseSBjb2VyY2VkIHRvIGEgbmV3IHR5cGUgaWYgbmVlZGVkLiAqKVxudHlwZSBfIHQgPSB7IHVudHlwZWQgOiBncmFtbWFyIH0gW0BAdW5ib3hlZF1cblxubGV0IGNvZXJjZSAodHlwZSBhIGIpICh7IHVudHlwZWQgPSBfIH0gYXMgdCA6IGEgdCkgOiBiIHQgPSB0XG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpcyB1c2VkIGZvciBhbGwgdGFncyBnZW5lcmF0ZWQgZnJvbSBkb2MgY29tbWVudHMuICopXG5sZXQgZG9jX2NvbW1lbnRfdGFnID0gXCJzZXhwX2dyYW1tYXIuZG9jX2NvbW1lbnRcIlxuIiwiW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiBibGl0X3N0cmluZyBkb2Vzbid0IGV4aXN0IGluIFtTdGRMYWJlbHMuQnl0ZXNdLi4uICAqKVxubGV0IGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgQnl0ZXMuYmxpdF9zdHJpbmcgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG47O1xuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBGb3JtYXRcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5cbmxldCBzZXhwX29mX3QgdCA9IHRcbmxldCB0X29mX3NleHAgdCA9IHRcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IHJlcyA9IGNvbXBhcmUgeCB5IGluXG4gICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgeHMgeXNcblxuYW5kIGNvbXBhcmUgYSBiID1cbiAgaWYgYSA9PSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IEF0b20gYSwgQXRvbSBiIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgIHwgTGlzdCBhLCBMaXN0IGIgLT4gY29tcGFyZV9saXN0IGEgYilcbjs7XG5cbmxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zIG9mIHRcbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yIG9mIGV4biAqIHRcblxubW9kdWxlIFByaW50aW5nID0gc3RydWN0XG4gICgqIERlZmF1bHQgaW5kZW50YXRpb24gbGV2ZWwgZm9yIGh1bWFuLXJlYWRhYmxlIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IGRlZmF1bHRfaW5kZW50ID0gcmVmIDFcblxuICAoKiBFc2NhcGluZyBvZiBzdHJpbmdzIHVzZWQgYXMgYXRvbXMgaW4gUy1leHByZXNzaW9ucyAqKVxuXG4gIGxldCBtdXN0X2VzY2FwZSBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxlbiA9IDBcbiAgICB8fFxuICAgIGxldCByZWMgbG9vcCBzdHIgaXggPVxuICAgICAgbWF0Y2ggc3RyLltpeF0gd2l0aFxuICAgICAgfCAnXCInIHwgJygnIHwgJyknIHwgJzsnIHwgJ1xcXFwnIC0+IHRydWVcbiAgICAgIHwgJ3wnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJyMnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJyMnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJ3wnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJ1xcMDAwJyAuLiAnXFwwMzInIHwgJ1xcMTI3JyAuLiAnXFwyNTUnIC0+IHRydWVcbiAgICAgIHwgXyAtPiBpeCA+IDAgJiYgbG9vcCBzdHIgKGl4IC0gMSlcbiAgICBpblxuICAgIGxvb3Agc3RyIChsZW4gLSAxKVxuICA7O1xuXG4gIGxldCBlc2NhcGVkIHMgPVxuICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgblxuICAgICAgOj0gIW5cbiAgICAgICAgICtcbiAgICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgICB8IF8gLT4gNFxuICAgIGRvbmU7XG4gICAgaWYgIW4gPSBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBzJyA9IEJ5dGVzLmNyZWF0ZSAhbiBpblxuICAgICAgbiA6PSAwO1xuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgKG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICAgICB8ICcgJyAuLiAnficgYXMgYyAtPiBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgYyAtPlxuICAgICAgICAgICBsZXQgYSA9IENoYXIuY29kZSBjIGluXG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAgbW9kIDEwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIG1vZCAxMCkpKSk7XG4gICAgICAgIGluY3IgblxuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcycpXG4gIDs7XG5cbiAgbGV0IGVzY19zdHIgc3RyID1cbiAgICBsZXQgZXN0ciA9IGVzY2FwZWQgc3RyIGluXG4gICAgbGV0IGVsZW4gPSBTdHJpbmcubGVuZ3RoIGVzdHIgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIChlbGVuICsgMikgaW5cbiAgICBieXRlc19ibGl0X3N0cmluZyB+c3JjOmVzdHIgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczoxIH5sZW46ZWxlbjtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAwICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgKGVsZW4gKyAxKSAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIDs7XG5cbiAgbGV0IGluZGV4X29mX25ld2xpbmUgc3RyIHN0YXJ0ID1cbiAgICB0cnkgU29tZSAoU3RyaW5nLmluZGV4X2Zyb20gc3RyIHN0YXJ0ICdcXG4nKSB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gTm9uZVxuICA7O1xuXG4gIGxldCBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBlbmRfcG9zX29wdCA9XG4gICAgbGV0IGVuZF9wb3MgPVxuICAgICAgbWF0Y2ggZW5kX3Bvc19vcHQgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICB8IFNvbWUgZW5kX3BvcyAtPiBlbmRfcG9zXG4gICAgaW5cbiAgICBTdHJpbmcuc3ViIHN0ciB+cG9zOmluZGV4IH5sZW46KGVuZF9wb3MgLSBpbmRleClcbiAgOztcblxuICBsZXQgaXNfb25lX2xpbmUgc3RyID1cbiAgICBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBpbmRleCAtPiBpbmRleCArIDEgPSBTdHJpbmcubGVuZ3RoIHN0clxuICA7O1xuXG4gIGxldCBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyID1cbiAgICBpZiBub3QgKG11c3RfZXNjYXBlIHN0cilcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyXG4gICAgZWxzZSBpZiBpc19vbmVfbGluZSBzdHJcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY19zdHIgc3RyKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGluZGV4ID1cbiAgICAgICAgbGV0IG5leHRfbmV3bGluZSA9IGluZGV4X29mX25ld2xpbmUgc3RyIGluZGV4IGluXG4gICAgICAgIGxldCBuZXh0X2xpbmUgPSBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBuZXh0X25ld2xpbmUgaW5cbiAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjYXBlZCBuZXh0X2xpbmUpO1xuICAgICAgICBtYXRjaCBuZXh0X25ld2xpbmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIG5ld2xpbmVfaW5kZXggLT5cbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXFwiO1xuICAgICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpO1xuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcblwiO1xuICAgICAgICAgIGxvb3AgKG5ld2xpbmVfaW5kZXggKyAxKVxuICAgICAgaW5cbiAgICAgIHBwX29wZW5fYm94IHBwZiAwO1xuICAgICAgKCogdGhlIGxlYWRpbmcgc3BhY2UgaXMgdG8gbGluZSB1cCB0aGUgbGluZXMgKilcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXFxcIlwiO1xuICAgICAgbG9vcCAwO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXCJcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKCkpXG4gIDs7XG5cbiAgbGV0IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgPSBpZiBtdXN0X2VzY2FwZSBzdHIgdGhlbiBlc2Nfc3RyIHN0ciBlbHNlIHN0clxuXG4gICgqIE91dHB1dCBvZiBTLWV4cHJlc3Npb25zIHRvIGZvcm1hdHRlcnMgKilcblxuICBsZXQgcmVjIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9vcGVuX2JveCBwcGYgaW5kZW50O1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBMaXN0IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiXG5cbiAgYW5kIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBwcF9wcmludF9zcGFjZSBwcGYgKCk7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIDs7XG5cbiAgbGV0IHJlYyBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPlxuICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXCI7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIHN0cic7XG4gICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHQ7XG4gICAgICBmYWxzZVxuICAgIHwgTGlzdCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCI7XG4gICAgICBmYWxzZVxuXG4gIGFuZCBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0XG4gICAgfCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiXG4gIDs7XG5cbiAgbGV0IHBwX2h1bSBwcGYgc2V4cCA9IHBwX2h1bV9pbmRlbnQgIWRlZmF1bHRfaW5kZW50IHBwZiBzZXhwXG4gIGxldCBwcF9tYWNoIHBwZiBzZXhwID0gaWdub3JlIChwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBzZXhwKVxuICBsZXQgcHAgPSBwcF9tYWNoXG5cbiAgKCogU2V4cCBzaXplICopXG5cbiAgbGV0IHJlYyBzaXplX2xvb3AgKCh2LCBjKSBhcyBhY2MpID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHYgKyAxLCBjICsgU3RyaW5nLmxlbmd0aCBzdHJcbiAgICB8IExpc3QgbHN0IC0+IExpc3QuZm9sZF9sZWZ0IGxzdCB+aW5pdDphY2MgfmY6c2l6ZV9sb29wXG4gIDs7XG5cbiAgbGV0IHNpemUgc2V4cCA9IHNpemVfbG9vcCAoMCwgMCkgc2V4cFxuXG4gICgqIEJ1ZmZlciBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19idWZmZXJfaHVtIH5idWYgPyhpbmRlbnQgPSAhZGVmYXVsdF9pbmRlbnQpIHNleHAgPVxuICAgIGxldCBwcGYgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBwcGYgXCIlYUA/XCIgKHBwX2h1bV9pbmRlbnQgaW5kZW50KSBzZXhwXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlcl9tYWNoIH5idWYgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlciA9IHRvX2J1ZmZlcl9tYWNoXG5cbiAgbGV0IHRvX2J1ZmZlcl9nZW4gfmJ1ZiB+YWRkX2NoYXIgfmFkZF9zdHJpbmcgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBhZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBhZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IGFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gICgqIFRoZSBtYXhpbXVtIHNpemUgb2YgYSB0aGluZyBvbiB0aGUgbWlub3IgaGVhcCBpcyAyNTYgd29yZHMuXG4gICAgIFByZXZpb3VzbHksIHRoaXMgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgYnVmZmVyIGhlcmUgd2FzIDQwOTYgYnl0ZXMsIHdoaWNoXG4gICAgIGNhdXNlZCB0aGUgQnVmZmVyIHRvIGJlIGFsbG9jYXRlZCBvbiB0aGUgKm1ham9yKiBoZWFwIGV2ZXJ5IHRpbWUuXG5cbiAgICAgQWNjb3JkaW5nIHRvIGEgc2ltcGxlIGJlbmNobWFyayBieSBSb24sIHdlIGNhbiBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvclxuICAgICBzbWFsbCBzLWV4cHJlc3Npb25zIGJ5IGEgZmFjdG9yIG9mIH40IGlmIHdlIG9ubHkgYWxsb2NhdGUgMTAyNCBieXRlc1xuICAgICAoMTI4IHdvcmRzICsgc29tZSBzbWFsbCBvdmVyaGVhZCkgd29ydGggb2YgYnVmZmVyIGluaXRpYWxseS4gIEFuZCBvbmVcbiAgICAgY2FuIGFyZ3VlIHRoYXQgaWYgaXQncyBmcmVlIHRvIGFsbG9jYXRlIHN0cmluZ3Mgc21hbGxlciB0aGFuIDI1NiB3b3JkcyxcbiAgICAgbGFyZ2Ugcy1leHByZXNzaW9ucyByZXF1aXJpbmcgbGFyZ2VyIGV4cGVuc2l2ZSBidWZmZXJzIHdvbid0IG5vdGljZVxuICAgICB0aGUgZXh0cmEgdHdvIGRvdWJsaW5ncyBmcm9tIDEwMjQgYnl0ZXMgdG8gMjA0OCBhbmQgNDA5Ni4gQW5kIGVzcGVjaWFsbHlcbiAgICAgcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyB0byBhbHdheXMgcGFzcyBpbiBhIGxhcmdlciBidWZmZXIgdG9cbiAgICAgdXNlLiAqKVxuICBsZXQgYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSAxMDI0XG5cbiAgKCogU3RyaW5nIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gP2luZGVudCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0clxuICAgICAgd2hlbiBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIF8gLT4gZmFsc2UgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX2h1bSA/aW5kZW50IHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX21hY2ggPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX21hY2ggc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfbWFjaFxuZW5kXG5cbmluY2x1ZGUgUHJpbnRpbmdcblxubGV0IG9mX2Zsb2F0X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5sZXQgb2ZfaW50X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGluY2x1ZGUgUHJpbnRpbmdcbmVuZFxuXG5sZXQgbWVzc2FnZSBuYW1lIGZpZWxkcyA9XG4gIGxldCByZWMgY29udl9maWVsZHMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IChmbmFtZSwgZnNleHApIDo6IHJlc3QgLT5cbiAgICAgIChtYXRjaCBmbmFtZSB3aXRoXG4gICAgICAgfCBcIlwiIC0+IGZzZXhwIDo6IGNvbnZfZmllbGRzIHJlc3RcbiAgICAgICB8IF8gLT4gTGlzdCBbIEF0b20gZm5hbWU7IGZzZXhwIF0gOjogY29udl9maWVsZHMgcmVzdClcbiAgaW5cbiAgTGlzdCAoQXRvbSBuYW1lIDo6IGNvbnZfZmllbGRzIGZpZWxkcylcbjs7XG4iLCJsZXQgdW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gTGlzdCBFbXB0eSB9XG5sZXQgYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQm9vbCB9XG5sZXQgc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IENoYXIgfVxubGV0IGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEZsb2F0IH1cbmxldCBpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgbmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IHNleHBfdF9zZXhwX2dyYW1tYXIgOiBTZXhwLnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJTZXhwLnRcIiB9XG5sZXQgcmVmX3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5sZXQgbGF6eV90X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5cbmxldCBvcHRpb25fc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBvcHRpb24gU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBPcHRpb24gdW50eXBlZCB9XG47O1xuXG5sZXQgbGlzdF9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGxpc3QgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBhcnJheV9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGFycmF5IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgZW1wdHlfc2V4cF9ncmFtbWFyIDogXyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbmxldCBvcGFxdWVfc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG5sZXQgZnVuX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxuIiwiKCogVXRpbGl0eSBNb2R1bGUgZm9yIFMtZXhwcmVzc2lvbiBDb252ZXJzaW9ucyAqKVxuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBNb3JlTGFiZWxzXG5vcGVuIFByaW50Zlxub3BlbiBTZXhwXG5cbigqIENvbnZlcnNpb24gb2YgT0NhbWwtdmFsdWVzIHRvIFMtZXhwcmVzc2lvbnMgKilcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogJyUuMTdnJyBpcyBndWFyYW50ZWVkIHRvIGJlIHJvdW5kLXRyaXBwYWJsZS5cblxuICAgJyUuMTVnJyB3aWxsIGJlIHJvdW5kLXRyaXBwYWJsZSBhbmQgbm90IGhhdmUgbm9pc2UgYXQgdGhlIGxhc3QgZGlnaXQgb3IgdHdvIGZvciBhIGZsb2F0XG4gICB3aGljaCB3YXMgY29udmVydGVkIGZyb20gYSBkZWNpbWFsIChzdHJpbmcpIHdpdGggPD0gMTUgc2lnbmlmaWNhbnQgZGlnaXRzLiAgU28gaXQnc1xuICAgd29ydGggdHJ5aW5nIGZpcnN0IHRvIGF2b2lkIHRoaW5ncyBsaWtlIFwiMy4xNDAwMDAwMDAwMDAwMDAxXCIuXG5cbiAgIFNlZSBjb21tZW50IGFib3ZlIFt0b19zdHJpbmdfcm91bmRfdHJpcHBhYmxlXSBpbiB7IUNvcmUuRmxvYXR9IGZvclxuICAgZGV0YWlsZWQgZXhwbGFuYXRpb24gYW5kIGV4YW1wbGVzLiAqKVxubGV0IGRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0ID1cbiAgcmVmIChmdW4geCAtPlxuICAgIGxldCB5ID0gZm9ybWF0X2Zsb2F0IFwiJS4xNUdcIiB4IGluXG4gICAgaWYgZmxvYXRfb2Zfc3RyaW5nIHkgPSB4IHRoZW4geSBlbHNlIGZvcm1hdF9mbG9hdCBcIiUuMTdHXCIgeClcbjs7XG5cbmxldCByZWFkX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCB3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCA9IHJlZiB0cnVlXG5sZXQgbGlzdF9tYXAgZiBsID0gTGlzdC5yZXYgKExpc3QucmV2X21hcCBsIH5mKVxubGV0IHNleHBfb2ZfdW5pdCAoKSA9IExpc3QgW11cbmxldCBzZXhwX29mX2Jvb2wgYiA9IEF0b20gKHN0cmluZ19vZl9ib29sIGIpXG5sZXQgc2V4cF9vZl9zdHJpbmcgc3RyID0gQXRvbSBzdHJcbmxldCBzZXhwX29mX2J5dGVzIGJ5dGVzID0gQXRvbSAoQnl0ZXMudG9fc3RyaW5nIGJ5dGVzKVxubGV0IHNleHBfb2ZfY2hhciBjID0gQXRvbSAoU3RyaW5nLm1ha2UgMSBjKVxubGV0IHNleHBfb2ZfaW50IG4gPSBBdG9tIChzdHJpbmdfb2ZfaW50IG4pXG5sZXQgc2V4cF9vZl9mbG9hdCBuID0gQXRvbSAoIWRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0IG4pXG5sZXQgc2V4cF9vZl9pbnQzMiBuID0gQXRvbSAoSW50MzIudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9pbnQ2NCBuID0gQXRvbSAoSW50NjQudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9uYXRpdmVpbnQgbiA9IEF0b20gKE5hdGl2ZWludC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX3JlZiBzZXhwX29mX19hIHJmID0gc2V4cF9vZl9fYSAhcmZcbmxldCBzZXhwX29mX2xhenlfdCBzZXhwX29mX19hIGx2ID0gc2V4cF9vZl9fYSAoTGF6eS5mb3JjZSBsdilcblxubGV0IHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfX2EgPSBmdW5jdGlvblxuICB8IFNvbWUgeCB3aGVuICF3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCAtPiBMaXN0IFsgc2V4cF9vZl9fYSB4IF1cbiAgfCBTb21lIHggLT4gTGlzdCBbIEF0b20gXCJzb21lXCI7IHNleHBfb2ZfX2EgeCBdXG4gIHwgTm9uZSB3aGVuICF3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCAtPiBMaXN0IFtdXG4gIHwgTm9uZSAtPiBBdG9tIFwibm9uZVwiXG47O1xuXG5sZXQgc2V4cF9vZl9wYWlyIHNleHBfb2ZfX2Egc2V4cF9vZl9fYiAoYSwgYikgPSBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGIgXVxuXG5sZXQgc2V4cF9vZl90cmlwbGUgc2V4cF9vZl9fYSBzZXhwX29mX19iIHNleHBfb2ZfX2MgKGEsIGIsIGMpID1cbiAgTGlzdCBbIHNleHBfb2ZfX2EgYTsgc2V4cF9vZl9fYiBiOyBzZXhwX29mX19jIGMgXVxuOztcblxuKCogTGlzdC5yZXYgKExpc3QucmV2X21hcCAuLi4pIGlzIHRhaWwgcmVjdXJzaXZlLCB0aGUgT0NhbWwgc3RhbmRhcmRcbiAgIGxpYnJhcnkgTGlzdC5tYXAgaXMgTk9ULiAqKVxubGV0IHNleHBfb2ZfbGlzdCBzZXhwX29mX19hIGxzdCA9IExpc3QgKExpc3QucmV2IChMaXN0LnJldl9tYXAgbHN0IH5mOnNleHBfb2ZfX2EpKVxuXG5sZXQgc2V4cF9vZl9hcnJheSBzZXhwX29mX19hIGFyID1cbiAgbGV0IGxzdF9yZWYgPSByZWYgW10gaW5cbiAgZm9yIGkgPSBBcnJheS5sZW5ndGggYXIgLSAxIGRvd250byAwIGRvXG4gICAgbHN0X3JlZiA6PSBzZXhwX29mX19hIGFyLihpKSA6OiAhbHN0X3JlZlxuICBkb25lO1xuICBMaXN0ICFsc3RfcmVmXG47O1xuXG5sZXQgc2V4cF9vZl9oYXNodGJsIHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsIGh0YmwgPVxuICBsZXQgY29sbCB+a2V5OmsgfmRhdGE6diBhY2MgPSBMaXN0IFsgc2V4cF9vZl9rZXkgazsgc2V4cF9vZl92YWwgdiBdIDo6IGFjYyBpblxuICBMaXN0IChIYXNodGJsLmZvbGQgaHRibCB+aW5pdDpbXSB+Zjpjb2xsKVxuOztcblxubGV0IHNleHBfb2Zfb3BhcXVlIF8gPSBBdG9tIFwiPG9wYXF1ZT5cIlxubGV0IHNleHBfb2ZfZnVuIF8gPSBBdG9tIFwiPGZ1bj5cIlxuXG4oKiBFeGNlcHRpb24gY29udmVydGVyIHJlZ2lzdHJhdGlvbiBhbmQgbG9va3VwICopXG5cbm1vZHVsZSBFeG5fY29udmVydGVyID0gc3RydWN0XG4gICgqIFRoZXNlIGV4Y2VwdGlvbiByZWdpc3RyYXRpb24gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IGNvbnRleHQtc3dpdGNoZXNcbiAgICAgY2Fubm90IGhhcHBlbiB1bmxlc3MgdGhlcmUgaXMgYW4gYWxsb2NhdGlvbi4gIEl0IGlzIHJlYXNvbmFibGUgdG8gZXhwZWN0XG4gICAgIHRoYXQgdGhpcyB3aWxsIHJlbWFpbiB0cnVlIGZvciB0aGUgZm9yZXNlZWFibGUgZnV0dXJlLiAgVGhhdCB3YXkgd2VcbiAgICAgYXZvaWQgdXNpbmcgbXV0ZXhlcyBhbmQgdGh1cyBhIGRlcGVuZGVuY3kgb24gdGhlIHRocmVhZHMgbGlicmFyeS4gKilcblxuICAoKiBGYXN0IGFuZCBhdXRvbWF0aWMgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiAqKVxuXG4gIG1vZHVsZSBSZWdpc3RyYXRpb24gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBzZXhwX29mX2V4biA6IGV4biAtPiBTZXhwLnRcbiAgICAgIDsgKCogSWYgW3ByaW50ZXhjID0gdHJ1ZV0gdGhlbiB0aGlzIHNleHAgY29udmVydGVyIGlzIHVzZWQgZm9yIFByaW50ZXhjLnRvX3N0cmluZyAqKVxuICAgICAgICBwcmludGV4YyA6IGJvb2xcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIEV4bl90YWJsZSA9IEVwaGVtZXJvbi5LMS5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuXG4gICAgICBsZXQgZXF1YWwgPSAoID09IClcbiAgICAgIGxldCBoYXNoID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuICAgIGVuZClcblxuICBsZXQgdGhlX2V4bl90YWJsZSA6IFJlZ2lzdHJhdGlvbi50IEV4bl90YWJsZS50ID0gRXhuX3RhYmxlLmNyZWF0ZSAxN1xuXG4gICgqIEVwaGVtZXJvbnMgYXJlIHVzZWQgc28gdGhhdCBbc2V4cF9vZl9leG5dIGNsb3N1cmUgZG9uJ3Qga2VlcCB0aGVcbiAgICAgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGxpdmUuICopXG4gIGxldCBhZGQgPyhwcmludGV4YyA9IHRydWUpID9maW5hbGlzZTpfIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBzZXhwX29mX2V4biA9XG4gICAgRXhuX3RhYmxlLmFkZCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9XG4gIDs7XG5cbiAgbGV0IGZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjIGV4biA9XG4gICAgbGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIGV4biBpblxuICAgIG1hdGNoIEV4bl90YWJsZS5maW5kX29wdCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfSAtPlxuICAgICAgKG1hdGNoIGZvcl9wcmludGV4YywgcHJpbnRleGMgd2l0aFxuICAgICAgIHwgZmFsc2UsIF8gfCBfLCB0cnVlIC0+IFNvbWUgKHNleHBfb2ZfZXhuIGV4bilcbiAgICAgICB8IHRydWUsIGZhbHNlIC0+IE5vbmUpXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl91bml0X3Rlc3RzX29ubHkgPSBzdHJ1Y3RcbiAgICBsZXQgc2l6ZSAoKSA9IChFeG5fdGFibGUuc3RhdHNfYWxpdmUgdGhlX2V4bl90YWJsZSkubnVtX2JpbmRpbmdzXG4gIGVuZFxuZW5kXG5cbmxldCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6dHJ1ZSBleG5cbmxldCBzZXhwX29mX2V4bl9vcHQgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4YzpmYWxzZSBleG5cblxubGV0IHNleHBfb2ZfZXhuIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gTGlzdCBbIEF0b20gKFByaW50ZXhjLnRvX3N0cmluZyBleG4pIF1cbiAgfCBTb21lIHNleHAgLT4gc2V4cFxuOztcblxubGV0IGV4bl90b19zdHJpbmcgZSA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl9leG4gZSlcblxuKCoge1tleGNlcHRpb24gQmxhaCBbQEBkZXJpdmluZyBzZXhwXV19IGdlbmVyYXRlcyBhIGNhbGwgdG8gdGhlIGZ1bmN0aW9uXG4gICBbRXhuX2NvbnZlcnRlci5hZGRdIGRlZmluZWQgaW4gdGhpcyBmaWxlLiAgU28gd2UgYXJlIGd1YXJhbnRlZCB0aGF0IGFzIHNvb24gYXMgd2VcbiAgIG1hcmsgYW4gZXhjZXB0aW9uIGFzIHNleHBhYmxlLCB0aGlzIG1vZHVsZSB3aWxsIGJlIGxpbmtlZCBpbiBhbmQgdGhpcyBwcmludGVyIHdpbGwgYmVcbiAgIHJlZ2lzdGVyZWQsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC4gKilcbmxldCAoKSA9XG4gIFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1biBleG4gLT5cbiAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgc2V4cCAtPiBTb21lIChTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHApKVxuOztcblxubGV0IHByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gUHJpbnRleGMudG9fc3RyaW5nIGV4blxuICB8IFNvbWUgc2V4cCAtPiBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHBcbjs7XG5cbigqIENvbnZlcnNpb24gb2YgUy1leHByZXNzaW9ucyB0byBPQ2FtbC12YWx1ZXMgKilcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBTZXhwLk9mX3NleHBfZXJyb3JcblxubGV0IHJlY29yZF9jaGVja19leHRyYV9maWVsZHMgPSByZWYgdHJ1ZVxubGV0IG9mX3NleHBfZXJyb3JfZXhuIGV4YyBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkpXG5sZXQgb2Zfc2V4cF9lcnJvciB3aGF0IHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoRmFpbHVyZSB3aGF0LCBzZXhwKSlcblxubGV0IHVuaXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiAoKVxuICB8IEF0b20gXyB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwidW5pdF9vZl9zZXhwOiBlbXB0eSBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBib29sX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gKFwidHJ1ZVwiIHwgXCJUcnVlXCIpIC0+IHRydWVcbiAgfCBBdG9tIChcImZhbHNlXCIgfCBcIkZhbHNlXCIpIC0+IGZhbHNlXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IHVua25vd24gc3RyaW5nXCIgc2V4cFxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBzdHJpbmdfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJzdHJpbmdfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYnl0ZXNfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gQnl0ZXMub2Zfc3RyaW5nIHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYnl0ZXNfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgY2hhcl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgIGlmIFN0cmluZy5sZW5ndGggc3RyIDw+IDFcbiAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gc3RyaW5nIG11c3QgY29udGFpbiBvbmUgY2hhcmFjdGVyIG9ubHlcIiBzZXhwO1xuICAgIHN0ci5bMF1cbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBpbnRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgZmxvYXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGZsb2F0X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImZsb2F0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJmbG9hdF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQzMl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50MzIub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50MzJfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDMyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDY0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQ2NC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQ2NF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50NjRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbmF0aXZlaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBOYXRpdmVpbnQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwibmF0aXZlaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJuYXRpdmVpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgcmVmX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gcmVmIChhX19vZl9zZXhwIHNleHApXG5sZXQgbGF6eV90X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoYV9fb2Zfc2V4cCBzZXhwKVxuXG5sZXQgb3B0aW9uX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgaWYgIXJlYWRfb2xkX29wdGlvbl9mb3JtYXRcbiAgdGhlbiAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBMaXN0IFtdIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIGVsIF0gfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCByZXByZXNlbnQgb3B0aW9uYWwgdmFsdWVcIiBzZXhwXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwKVxuICBlbHNlIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cFxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IGJlIChzb21lIGVsKVwiIHNleHApXG47O1xuXG5sZXQgcGFpcl9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGEsIGJcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHR3byBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCB0cmlwbGVfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgY19fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwOyBjX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgbGV0IGMgPSBjX19vZl9zZXhwIGNfc2V4cCBpblxuICAgIGEsIGIsIGNcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdGhyZWUgZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBsaXN0X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgcmV2X2xzdCA9IExpc3QucmV2X21hcCBsc3QgfmY6YV9fb2Zfc2V4cCBpblxuICAgIExpc3QucmV2IHJldl9sc3RcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImxpc3Rfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYXJyYXlfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+IFt8fF1cbiAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHQgKyAxIGluXG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgbGVuIChhX19vZl9zZXhwIGgpIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXNcbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIHJlcy4oaSkgPC0gYV9fb2Zfc2V4cCBoO1xuICAgICAgICBsb29wIChpICsgMSkgdFxuICAgIGluXG4gICAgbG9vcCAxIHRcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImFycmF5X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGhhc2h0Ymxfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWxfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgaHRibCA9IEhhc2h0YmwuY3JlYXRlIDAgaW5cbiAgICBsZXQgYWN0ID0gZnVuY3Rpb25cbiAgICAgIHwgTGlzdCBbIGtfc2V4cDsgdl9zZXhwIF0gLT5cbiAgICAgICAgSGFzaHRibC5hZGQgaHRibCB+a2V5OihrZXlfb2Zfc2V4cCBrX3NleHApIH5kYXRhOih2YWxfb2Zfc2V4cCB2X3NleHApXG4gICAgICB8IExpc3QgXyB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiB0dXBsZSBsaXN0IG5lZWRlZFwiIHNleHBcbiAgICBpblxuICAgIExpc3QuaXRlciBsc3QgfmY6YWN0O1xuICAgIGh0YmxcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgb3BhcXVlX29mX3NleHAgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgXCJvcGFxdWVfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgb3BhcXVlIHZhbHVlc1wiIHNleHBcbjs7XG5cbmxldCBmdW5fb2Zfc2V4cCBzZXhwID0gb2Zfc2V4cF9lcnJvciBcImZ1bl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBmdW5jdGlvbiB2YWx1ZXNcIiBzZXhwXG5cbigqIFNleHAgR3JhbW1hcnMgKilcblxuaW5jbHVkZSBTZXhwX2NvbnZfZ3JhbW1hclxuXG4oKiBSZWdpc3RlcmluZyBkZWZhdWx0IGV4Y2VwdGlvbiBwcmludGVycyAqKVxuXG5sZXQgZ2V0X2ZsY19lcnJvciBuYW1lIChmaWxlLCBsaW5lLCBjaHIpID0gQXRvbSAoc3ByaW50ZiBcIiVzICVzOiVkOiVkXCIgbmFtZSBmaWxlIGxpbmUgY2hyKVxuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6ZmFsc2UgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBc3NlcnRfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBc3NlcnRfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIkFzc2VydF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeGl0XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEV4aXQgLT4gQXRvbSBcIkV4aXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRW5kX29mX2ZpbGVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRW5kX29mX2ZpbGUgLT4gQXRvbSBcIkVuZF9vZl9maWxlXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJGYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQXRvbSBcIk5vdF9mb3VuZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBJbnZhbGlkX2FyZ3VtZW50XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEludmFsaWRfYXJndW1lbnQgYXJnIC0+IExpc3QgWyBBdG9tIFwiSW52YWxpZF9hcmd1bWVudFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXRjaF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJNYXRjaF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRfc11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmRfcyBhcmcgLT4gTGlzdCBbIEF0b20gXCJOb3RfZm91bmRfc1wiOyBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5c19lcnJvciBhcmcgLT4gTGlzdCBbIEF0b20gXCJTeXNfZXJyb3JcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkhlbHBdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkhlbHAgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkhlbHBcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkJhZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuQmFkIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5CYWRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTGF6eS5VbmRlZmluZWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTGF6eS5VbmRlZmluZWQgLT4gQXRvbSBcIkxhenkuVW5kZWZpbmVkXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFBhcnNpbmcuUGFyc2VfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUGFyc2luZy5QYXJzZV9lcnJvciAtPiBBdG9tIFwiUGFyc2luZy5QYXJzZV9lcnJvclwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBRdWV1ZS5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBRdWV1ZS5FbXB0eSAtPiBBdG9tIFwiUXVldWUuRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2NhbmYuU2Nhbl9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFNjYW5mLlNjYW5fZmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJTY2FuZi5TY2FuX2ZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3RhY2suRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3RhY2suRW1wdHkgLT4gQXRvbSBcIlN0YWNrLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5cy5CcmVha11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXMuQnJlYWsgLT4gQXRvbSBcIlN5cy5CcmVha1wiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4Yzp0cnVlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgT2Zfc2V4cF9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBPZl9zZXhwX2Vycm9yIChleGMsIHNleHApIC0+XG4gICAgICAgICAgTGlzdCBbIEF0b20gXCJTZXhwbGliLkNvbnYuT2Zfc2V4cF9lcnJvclwiOyBzZXhwX29mX2V4biBleGM7IHNleHAgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuIiwiKCogQ29udl9lcnJvcjogTW9kdWxlIGZvciBIYW5kbGluZyBFcnJvcnMgZHVyaW5nIEF1dG9tYXRlZCBTLWV4cHJlc3Npb25cbiAgIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIFByaW50Zlxub3BlbiBTZXhwX2NvbnZcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBPZl9zZXhwX2Vycm9yXG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHR1cGxlcyAqKVxuXG5sZXQgdHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGxvYyBuIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChzcHJpbnRmIFwiJXNfb2Zfc2V4cDogdHVwbGUgb2Ygc2l6ZSAlZCBleHBlY3RlZFwiIGxvYyBuKSBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBzdW0gdHlwZXMgKilcblxubGV0IHN0YWdfbm9fYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoaXMgY29uc3RydWN0b3IgZG9lcyBub3QgdGFrZSBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IHN0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgdGFnIHNleHAgPVxuICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzX29mX3NleHA6IHN1bSB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCIgbG9jIHRhZyBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgc3RhZ190YWtlc19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhpcyBjb25zdHJ1Y3RvciByZXF1aXJlcyBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhIG5lc3RlZCBsaXN0XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfc3VtIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhbiBlbXB0eSBsaXN0XCIpIHNleHBcbjs7XG5cbmxldCB1bmV4cGVjdGVkX3N0YWcgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB1bmV4cGVjdGVkIHZhcmlhbnQgY29uc3RydWN0b3JcIikgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcmVjb3JkcyAqKVxuXG5sZXQgcmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2MgXiBcIl9vZl9zZXhwOiByZWNvcmQgY29udmVyc2lvbjogYSBbc2V4cC5ib29sXSBmaWVsZCB3YXMgZ2l2ZW4gYSBwYXlsb2FkLlwiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvY1xuICAgIF4gXCJfb2Zfc2V4cDogcmVjb3JkIGNvbnZlcnNpb246IG9ubHkgcGFpcnMgZXhwZWN0ZWQsIHRoZWlyIGZpcnN0IGVsZW1lbnQgbXVzdCBiZSBhbiBcXFxuICAgICAgIGF0b21cIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdCB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIGxldCBmbGRfbmFtZXNfc3RyID0gU3RyaW5nLmNvbmNhdCAoTGlzdC5yZXYgcmV2X2ZsZF9uYW1lcykgfnNlcDpcIiBcIiBpblxuICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzX29mX3NleHA6ICVzOiAlc1wiIGxvYyB3aGF0IGZsZF9uYW1lc19zdHIgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9kdXBsaWNhdGVfZmllbGRzIGxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0OlwiZHVwbGljYXRlIGZpZWxkc1wiIH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2V4dHJhX2ZpZWxkcyBsb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdDpcImV4dHJhIGZpZWxkc1wiIH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjIHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBTdHJpbmcuY29uY2F0IChMaXN0LnJldiBmaWVsZHMpIH5zZXA6XCIgXCJcbiAgfCAodHJ1ZSwgZmllbGQpIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCAoZmllbGQgOjogZmllbGRzKSByZXN0XG4gIHwgXyA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzIHJlc3Rcbjs7XG5cbmxldCByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGxvYyBzZXhwIGxzdCA9XG4gIGxldCB1bmRlZmluZWQgPSByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIFtdIGxzdCBpblxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogdGhlIGZvbGxvd2luZyByZWNvcmQgZWxlbWVudHMgd2VyZSB1bmRlZmluZWQ6ICVzXCIgbG9jIHVuZGVmaW5lZFxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9IGxvYyBeIFwiX29mX3NleHA6IGxpc3QgaW5zdGVhZCBvZiBhdG9tIGZvciByZWNvcmQgZXhwZWN0ZWRcIiBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX3BvbHlfZmllbGRfdmFsdWUgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2NcbiAgICBeIFwiX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IHZhbHVlcyBvZiB0eXBlcyByZXN1bHRpbmcgZnJvbSBwb2x5bW9ycGhpYyByZWNvcmQgZmllbGRzXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcG9seW1vcnBoaWMgdmFyaWFudHMgKilcblxuZXhjZXB0aW9uIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX3ZhcmlhbnRfbWF0Y2ggKCkgPSByYWlzZSBOb192YXJpYW50X21hdGNoXG5cbmxldCBub19tYXRjaGluZ192YXJpYW50X2ZvdW5kIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogbm8gbWF0Y2hpbmcgdmFyaWFudCBmb3VuZFwiKSBzZXhwXG47O1xuXG5sZXQgcHRhZ19ub19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgcHRhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyBjbnN0ciBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgc3ByaW50ZlxuICAgICAgXCIlc19vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIlxuICAgICAgbG9jXG4gICAgICBjbnN0clxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcHRhZ190YWtlc19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCB0YWcgdGFrZXMgYW4gYXJndW1lbnRcIikgc2V4cFxuOztcblxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBhIG5lc3RlZCBsaXN0IGlzIGFuIGludmFsaWQgcG9seW1vcnBoaWMgdmFyaWFudFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhlIGVtcHR5IGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV90eXBlIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdHJ5aW5nIHRvIGNvbnZlcnQgYW4gZW1wdHkgdHlwZVwiKSBzZXhwXG47O1xuIl19
