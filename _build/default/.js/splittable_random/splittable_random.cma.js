// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_div=runtime.caml_int64_div,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_shift_right=runtime.caml_int64_shift_right,
     caml_int64_shift_right_unsigne=runtime.caml_int64_shift_right_unsigned,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_int64_xor=runtime.caml_int64_xor,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_mul=runtime.caml_mul,
     caml_notequal=runtime.caml_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    var
     global_data=runtime.caml_get_global_data(),
     int64$0=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_float_bounds_are_not_finit=
      caml_string_of_jsbytes("float: bounds are not finite numbers"),
     cst_float_bounds_are_crossed=
      caml_string_of_jsbytes("float: bounds are crossed"),
     cst_int64_crossed_bounds=caml_string_of_jsbytes("int64: crossed bounds"),
     cst_splittable_random=caml_string_of_jsbytes("splittable_random"),
     golden_gamma=runtime.caml_int64_create_lo_mi_hi(4881429,7977343,40503),
     cst_src_splittable_random_ml=
      caml_string_of_jsbytes("src/splittable_random.ml"),
     cst_src_splittable_random_ml$0=
      caml_string_of_jsbytes("src/splittable_random.ml"),
     cst_let_int64_1L_in_fun_unit_f=
      caml_string_of_jsbytes
       ("let int64 = 1L in fun () -> unit_float_from_int64 int64"),
     cst_unit_float_from_int64=caml_string_of_jsbytes("unit_float_from_int64"),
     Base_Int=global_data.Base__Int,
     Assert_failure=global_data.Assert_failure,
     Base=global_data.Base,
     Base_Float=global_data.Base__Float,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Base_Int64=global_data.Base__Int64,
     Base_Int63=global_data.Base__Int63,
     Base_Error=global_data.Base__Error,
     Base_Random=global_data.Base__Random,
     Ppx_bench_lib_Benchmark_accumu=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Base_Int32=global_data.Base__Int32,
     Base_Nativeint=global_data.Base__Nativeint;
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1],cst_splittable_random);
    var
     popcount=Base_Int64[47],
     _o_=[0,caml_string_of_jsbytes("src/splittable_random.ml"),289,6],
     _k_=[0,caml_string_of_jsbytes("hi")],
     _l_=[0,caml_string_of_jsbytes("lo")],
     _m_=[0,caml_string_of_jsbytes("hi")],
     _n_=[0,caml_string_of_jsbytes("lo")],
     _h_=[0,caml_string_of_jsbytes("hi")],
     _i_=[0,caml_string_of_jsbytes("lo")],
     _j_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _f_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _g_=runtime.caml_int64_create_lo_mi_hi(11184810,11184810,43690),
     _d_=runtime.caml_int64_create_lo_mi_hi(15001017,4680988,48984),
     _e_=runtime.caml_int64_create_lo_mi_hi(3215851,4832019,38096),
     _b_=runtime.caml_int64_create_lo_mi_hi(5606605,11524077,65361),
     _c_=runtime.caml_int64_create_lo_mi_hi(8776787,12189210,50382),
     _a_=runtime.caml_int64_create_lo_mi_hi(1,0,0);
    function of_int(seed){return [0,caml_int64_of_int32(seed),golden_gamma]}
    function copy(param)
     {var seed=param[1],odd_gamma=param[2];return [0,seed,odd_gamma]}
    function mix_bits(z,n)
     {return caml_int64_xor(z,caml_int64_shift_right_unsigne(z,n))}
    function mix64(z)
     {var
       z$0=caml_int64_mul(mix_bits(z,33),_b_),
       z$1=caml_int64_mul(mix_bits(z$0,33),_c_);
      return mix_bits(z$1,33)}
    function next_seed(t)
     {var next=caml_int64_add(t[1],t[2]);t[1] = next;return next}
    function of_seed_and_gamma(seed,gamma)
     {var
       seed$0=mix64(seed),
       z=caml_int64_mul(mix_bits(gamma,30),_d_),
       z$0=caml_int64_mul(mix_bits(z,27),_e_),
       z$1=caml_int64_or(mix_bits(z$0,31),_f_),
       n=
        caml_call1
         (popcount,caml_int64_xor(z$1,caml_int64_shift_right_unsigne(z$1,1))),
       odd_gamma=24 <= n?z$1:caml_int64_xor(z$1,_g_);
      return [0,seed$0,odd_gamma]}
    function random_int64(random_state)
     {return caml_call3
              (Base_Random[18][14],random_state,Base_Int64[61],Base_Int64[60])}
    function create(random_state)
     {var seed=random_int64(random_state),gamma=random_int64(random_state);
      return of_seed_and_gamma(seed,gamma)}
    function split(t)
     {var seed=next_seed(t),gamma=next_seed(t);
      return of_seed_and_gamma(seed,gamma)}
    function next_int64(t){return mix64(next_seed(t))}
    function perturb(t,salt)
     {var
       _by_=mix64(caml_int64_of_int32(salt)),
       next=caml_int64_add(t[1],_by_);
      t[1] = next;
      return 0}
    function bool(state)
     {var x=next_int64(state);return caml_equal(caml_int64_or(x,_a_),x)}
    function int64(state,lo,hi)
     {if(caml_greaterthan(lo,hi))
       {var
         _bu_=[0,[1,[0,_h_,[0,caml_call1(Base[133],hi),0]]],0],
         _bv_=[0,[1,[0,_i_,[0,caml_call1(Base[133],lo),0]]],_bu_],
         _bw_=
          [1,
           [0,caml_call1(Sexplib0_Sexp_conv[7],cst_int64_crossed_bounds),_bv_]];
        caml_call1(Base_Error[30],_bw_)}
      var maximum=caml_int64_sub(hi,lo);
      if(caml_equal(maximum,Base_Int64[60]))
       {var _bx_=Base_Int64[60];
        return caml_int64_add(caml_int64_and(next_int64(state),_bx_),lo)}
      if(caml_greaterequal(maximum,_j_))
       for(;;)
        {var
          _bs_=Base_Int64[60],
          draw$0=caml_int64_and(next_int64(state),_bs_),
          _bt_=caml_call1(Base_Int64[40],maximum),
          remainder=caml_call2(Base_Int64[34],draw$0,_bt_);
         if
          (caml_lessequal
            (caml_int64_sub(draw$0,remainder),
             caml_int64_sub(Base_Int64[60],maximum)))
          return caml_int64_add(remainder,lo)}
      for(;;)
       {var draw=next_int64(state);
        if(caml_lessequal(lo,draw) && caml_lessequal(draw,hi))return draw}}
    function int$0(state,lo,hi)
     {var lo$0=caml_int64_of_int32(lo),hi$0=caml_int64_of_int32(hi);
      return caml_int64_to_int32(int64(state,lo$0,hi$0))}
    function int32(state,lo,hi)
     {var lo$0=caml_int64_of_int32(lo),hi$0=caml_int64_of_int32(hi);
      return caml_int64_to_int32(int64(state,lo$0,hi$0))}
    function nativeint(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int64[80],lo),
       hi$0=caml_call1(Base_Int64[80],hi);
      return caml_int64_to_int32(int64(state,lo$0,hi$0))}
    function int63(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int63[79],lo),
       hi$0=caml_call1(Base_Int63[79],hi),
       _br_=int64(state,lo$0,hi$0);
      return caml_call1(Base_Int63[105],_br_)}
    var double_ulp=caml_call2(Base[195],2.,-53.);
    function unit_float_from_int64(int64)
     {var
       _bq_=
        caml_call1(Base_Int64[3],caml_int64_shift_right_unsigne(int64,11));
      return caml_call2(Base[192],_bq_,double_ulp)}
    function unit_float(state)
     {return unit_float_from_int64(next_int64(state))}
    function float$0(state,lo$1,hi$0)
     {var
       _bi_=caml_call1(Base_Float[84],lo$1),
       _bj_=_bi_?caml_call1(Base_Float[84],hi$0):_bi_;
      if(1 - _bj_)
       {var
         _bk_=[0,[1,[0,_k_,[0,caml_call1(Base[112],hi$0),0]]],0],
         _bl_=[0,[1,[0,_l_,[0,caml_call1(Base[112],lo$1),0]]],_bk_],
         _bm_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_float_bounds_are_not_finit),
            _bl_]];
        caml_call1(Base[202],_bm_)}
      if(caml_call2(Base_Float[12],lo$1,hi$0))
       {var
         _bn_=[0,[1,[0,_m_,[0,caml_call1(Base[112],hi$0),0]]],0],
         _bo_=[0,[1,[0,_n_,[0,caml_call1(Base[112],lo$1),0]]],_bn_],
         _bp_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_float_bounds_are_crossed),
            _bo_]];
        caml_call1(Base[202],_bp_)}
      var lo=lo$1,hi=hi$0;
      for(;;)
       {var range=caml_call2(Base[191],hi,lo);
        if(caml_call1(Base_Float[84],range))
         {var _bf_=unit_float(state),_bg_=caml_call2(Base[192],_bf_,range);
          return caml_call2(Base[190],lo,_bg_)}
        var
         _bh_=caml_call2(Base[190],hi,lo),
         lo$0=caml_call2(Base[193],_bh_,2.);
        if(bool(state)){var hi=lo$0;continue}
        var lo=lo$0}}
    if(Ppx_bench_lib_Benchmark_accumu[3])
     {var
       f=
        function(param)
         {return function(param){return unit_float_from_int64(int64$0)}};
      caml_call8
       (Ppx_bench_lib_Benchmark_accumu[5],
        cst_unit_float_from_int64,
        cst_let_int64_1L_in_fun_unit_f,
        cst_src_splittable_random_ml$0,
        cst_src_splittable_random_ml,
        278,
        0,
        99,
        [0,f])}
    function Make(M)
     {function bits_to_represent(t)
       {if(! caml_call2(M[12],t,M[38]))throw [0,Assert_failure,_o_];
        var t$0=[0,t],n=[0,0];
        for(;;)
         {if(! caml_call2(M[15],t$0[1],M[38]))return n[1];
          t$0[1] = caml_call2(M[73],t$0[1],1);
          caml_call1(Base_Int[51],n)}}
      function log_uniform(state,lo,hi)
       {var
         min_bits=bits_to_represent(lo),
         max_bits=bits_to_represent(hi),
         n=int$0(state,min_bits,max_bits),
         _ba_=caml_call2(M[72],M[39],n),
         _bb_=caml_call1(M[65],_ba_),
         _bc_=caml_call1(caml_call1(M[20],hi),_bb_);
        if(caml_call2(Base_Int[12],n,0))
         var _bd_=M[38];
        else
         var
          _a$_=caml_call1(Base_Int[41],n),
          _bd_=caml_call2(M[72],M[39],_a$_);
        var _be_=caml_call1(caml_call1(M[21],lo),_bd_);
        return caml_call3(M[96],state,_be_,_bc_)}
      return [0,log_uniform]}
    var
     t_sexp_grammar=Base_Int[1],
     of_float=Base_Int[2],
     to_float=Base_Int[3],
     of_int_exn=Base_Int[4],
     to_int_exn=Base_Int[5],
     hash_fold_t=Base_Int[6],
     hash=Base_Int[7],
     t_of_sexp=Base_Int[8],
     sexp_of_t=Base_Int[9],
     of_string=Base_Int[10],
     to_string=Base_Int[11],
     equal=Base_Int[12],
     compare=Base_Int[13],
     min=Base_Int[14],
     max=Base_Int[15],
     ascending=Base_Int[16],
     descending=Base_Int[17],
     between=Base_Int[18],
     clamp_exn=Base_Int[19],
     clamp=Base_Int[20],
     comparator=Base_Int[21],
     pp=Base_Int[22],
     hashable=Base_Int[23],
     is_positive=Base_Int[24],
     is_non_negative=Base_Int[25],
     is_negative=Base_Int[26],
     is_non_positive=Base_Int[27],
     sign=Base_Int[28],
     invariant=Base_Int[29],
     Hex=Base_Int[30],
     to_string_hum=Base_Int[31],
     one=Base_Int[32],
     minus_one=Base_Int[33],
     rem=Base_Int[34],
     round=Base_Int[35],
     round_towards_zero=Base_Int[36],
     round_down=Base_Int[37],
     round_up=Base_Int[38],
     round_nearest=Base_Int[39],
     succ=Base_Int[40],
     pred=Base_Int[41],
     pow=Base_Int[42],
     bit_and=Base_Int[43],
     bit_or=Base_Int[44],
     bit_xor=Base_Int[45],
     bit_not=Base_Int[46],
     popcount$0=Base_Int[47],
     shift_left=Base_Int[48],
     shift_right=Base_Int[49],
     decr=Base_Int[50],
     incr=Base_Int[51],
     of_int32_exn=Base_Int[52],
     to_int32_exn=Base_Int[53],
     of_int64_exn=Base_Int[54],
     to_int64=Base_Int[55],
     of_nativeint_exn=Base_Int[56],
     to_nativeint_exn=Base_Int[57],
     of_float_unchecked=Base_Int[58],
     num_bits=Base_Int[59],
     max_value=Base_Int[60],
     min_value=Base_Int[61],
     shift_right_logical=Base_Int[62],
     ceil_pow2=Base_Int[63],
     floor_pow2=Base_Int[64],
     ceil_log2=Base_Int[65],
     floor_log2=Base_Int[66],
     is_pow2=Base_Int[67],
     clz=Base_Int[68],
     ctz=Base_Int[69],
     O=Base_Int[70],
     symbol=Base_Int[71],
     lnot=Base_Int[72],
     abs=Base_Int[73],
     zero=Base_Int[74],
     symbol$0=Base_Int[75],
     symbol$1=Base_Int[76],
     symbol$2=Base_Int[77];
    function _p_(_a__,_a9_){return _a__ >>> _a9_ | 0}
    function _q_(_a8_,_a7_){return _a8_ >> _a7_}
    function _r_(_a6_,_a5_){return _a6_ << _a5_}
    var _s_=O[2];
    function _t_(_a4_,_a3_){return _a4_ ^ _a3_}
    function _u_(_a2_,_a1_){return _a2_ | _a1_}
    function _v_(_a0_,_aZ_){return _a0_ & _aZ_}
    var _w_=O[7],_x_=O[6],_y_=O[5],_z_=O[4];
    function _A_(_aY_){return - _aY_ | 0}
    var _B_=O[3];
    function _C_(_aX_,_aW_){return _aX_ !== _aW_?1:0}
    function _D_(_aV_,_aU_){return _aV_ < _aU_?1:0}
    function _E_(_aT_,_aS_){return _aS_ < _aT_?1:0}
    function _F_(_aR_,_aQ_){return _aR_ === _aQ_?1:0}
    function _G_(_aP_,_aO_){return _aP_ <= _aO_?1:0}
    function _H_(_aN_,_aM_){return _aM_ <= _aN_?1:0}
    var _I_=O[1];
    function _J_(_aL_){return - _aL_ | 0}
    var _K_=caml_div,_L_=caml_mul;
    function _M_(_aK_,_aJ_){return _aK_ - _aJ_ | 0}
    var
     _N_=
      [0,
       function(_aI_,_aH_){return _aI_ + _aH_ | 0},
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_];
    function _O_(_aG_,_aF_){return _aG_ >>> _aF_ | 0}
    function _P_(_aE_,_aD_){return _aE_ >> _aD_}
    function _Q_(_aC_,_aB_){return _aC_ << _aB_}
    function _R_(_aA_,_az_){return _aA_ ^ _az_}
    function _S_(_ay_,_ax_){return _ay_ | _ax_}
    function _T_(_aw_,_av_){return _aw_ & _av_}
    var _U_=caml_div;
    function _V_(_au_){return - _au_ | 0}
    function _W_(_at_){return - _at_ | 0}
    var _X_=caml_mul;
    function _Y_(_as_,_ar_){return _as_ - _ar_ | 0}
    function _Z_(_aq_,_ap_){return _aq_ + _ap_ | 0}
    function ___(_ao_,_an_){return _ao_ !== _an_?1:0}
    function _$_(_am_,_al_){return _am_ < _al_?1:0}
    function _aa_(_ak_,_aj_){return _aj_ < _ak_?1:0}
    function _ab_(_ai_,_ah_){return _ai_ === _ah_?1:0}
    function _ac_(_ag_,_af_){return _ag_ <= _af_?1:0}
    var
     For_int=
      Make
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_ae_,_ad_){return _ad_ <= _ae_?1:0},
         _ac_,
         _ab_,
         _aa_,
         _$_,
         ___,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         _Z_,
         _Y_,
         _X_,
         symbol,
         _W_,
         _V_,
         symbol$1,
         symbol$0,
         _U_,
         rem,
         symbol$2,
         _T_,
         _S_,
         _R_,
         lnot,
         _Q_,
         _P_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount$0,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _O_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _N_,
         int$0]),
     t_sexp_grammar$0=Base_Int32[1],
     of_float$0=Base_Int32[2],
     to_float$0=Base_Int32[3],
     of_int_exn$0=Base_Int32[4],
     to_int_exn$0=Base_Int32[5],
     hash_fold_t$0=Base_Int32[6],
     hash$0=Base_Int32[7],
     t_of_sexp$0=Base_Int32[8],
     sexp_of_t$0=Base_Int32[9],
     of_string$0=Base_Int32[10],
     to_string$0=Base_Int32[11],
     symbol$3=Base_Int32[12],
     symbol$4=Base_Int32[13],
     symbol$5=Base_Int32[14],
     symbol$6=Base_Int32[15],
     symbol$7=Base_Int32[16],
     symbol$8=Base_Int32[17],
     equal$0=Base_Int32[18],
     compare$0=Base_Int32[19],
     min$0=Base_Int32[20],
     max$0=Base_Int32[21],
     ascending$0=Base_Int32[22],
     descending$0=Base_Int32[23],
     between$0=Base_Int32[24],
     clamp_exn$0=Base_Int32[25],
     clamp$0=Base_Int32[26],
     comparator$0=Base_Int32[27],
     pp$0=Base_Int32[28],
     hashable$0=Base_Int32[29],
     is_positive$0=Base_Int32[30],
     is_non_negative$0=Base_Int32[31],
     is_negative$0=Base_Int32[32],
     is_non_positive$0=Base_Int32[33],
     sign$0=Base_Int32[34],
     invariant$0=Base_Int32[35],
     Hex$0=Base_Int32[36],
     to_string_hum$0=Base_Int32[37],
     zero$0=Base_Int32[38],
     one$0=Base_Int32[39],
     minus_one$0=Base_Int32[40],
     symbol$9=Base_Int32[41],
     symbol$10=Base_Int32[42],
     symbol$11=Base_Int32[43],
     symbol$12=Base_Int32[44],
     neg=Base_Int32[45],
     symbol$13=Base_Int32[46],
     symbol$14=Base_Int32[47],
     symbol$15=Base_Int32[48],
     symbol$16=Base_Int32[49],
     rem$0=Base_Int32[50],
     symbol$17=Base_Int32[51],
     land=Base_Int32[52],
     lor=Base_Int32[53],
     lxor=Base_Int32[54],
     lnot$0=Base_Int32[55],
     lsl=Base_Int32[56],
     asr=Base_Int32[57],
     round$0=Base_Int32[58],
     round_towards_zero$0=Base_Int32[59],
     round_down$0=Base_Int32[60],
     round_up$0=Base_Int32[61],
     round_nearest$0=Base_Int32[62],
     abs$0=Base_Int32[63],
     succ$0=Base_Int32[64],
     pred$0=Base_Int32[65],
     pow$0=Base_Int32[66],
     bit_and$0=Base_Int32[67],
     bit_or$0=Base_Int32[68],
     bit_xor$0=Base_Int32[69],
     bit_not$0=Base_Int32[70],
     popcount$1=Base_Int32[71],
     shift_left$0=Base_Int32[72],
     shift_right$0=Base_Int32[73],
     decr$0=Base_Int32[74],
     incr$0=Base_Int32[75],
     of_int32_exn$0=Base_Int32[76],
     to_int32_exn$0=Base_Int32[77],
     of_int64_exn$0=Base_Int32[78],
     to_int64$0=Base_Int32[79],
     of_nativeint_exn$0=Base_Int32[80],
     to_nativeint_exn$0=Base_Int32[81],
     of_float_unchecked$0=Base_Int32[82],
     num_bits$0=Base_Int32[83],
     max_value$0=Base_Int32[84],
     min_value$0=Base_Int32[85],
     lsr=Base_Int32[86],
     shift_right_logical$0=Base_Int32[87],
     ceil_pow2$0=Base_Int32[88],
     floor_pow2$0=Base_Int32[89],
     ceil_log2$0=Base_Int32[90],
     floor_log2$0=Base_Int32[91],
     is_pow2$0=Base_Int32[92],
     clz$0=Base_Int32[93],
     ctz$0=Base_Int32[94],
     O$0=Base_Int32[95],
     For_int32=
      Make
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$3,
         symbol$4,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$9,
         symbol$10,
         symbol$11,
         symbol$12,
         neg,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         rem$0,
         symbol$17,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$1,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         int32]),
     t_sexp_grammar$1=Base_Int63[1],
     of_float$1=Base_Int63[2],
     to_float$1=Base_Int63[3],
     of_int_exn$1=Base_Int63[4],
     to_int_exn$1=Base_Int63[5],
     hash_fold_t$1=Base_Int63[6],
     hash$1=Base_Int63[7],
     t_of_sexp$1=Base_Int63[8],
     sexp_of_t$1=Base_Int63[9],
     of_string$1=Base_Int63[10],
     to_string$1=Base_Int63[11],
     symbol$18=Base_Int63[12],
     symbol$19=Base_Int63[13],
     symbol$20=Base_Int63[14],
     symbol$21=Base_Int63[15],
     symbol$22=Base_Int63[16],
     symbol$23=Base_Int63[17],
     equal$1=Base_Int63[18],
     compare$1=Base_Int63[19],
     min$1=Base_Int63[20],
     max$1=Base_Int63[21],
     ascending$1=Base_Int63[22],
     descending$1=Base_Int63[23],
     between$1=Base_Int63[24],
     clamp_exn$1=Base_Int63[25],
     clamp$1=Base_Int63[26],
     comparator$1=Base_Int63[27],
     pp$1=Base_Int63[28],
     hashable$1=Base_Int63[29],
     is_positive$1=Base_Int63[30],
     is_non_negative$1=Base_Int63[31],
     is_negative$1=Base_Int63[32],
     is_non_positive$1=Base_Int63[33],
     sign$1=Base_Int63[34],
     invariant$1=Base_Int63[35],
     Hex$1=Base_Int63[36],
     to_string_hum$1=Base_Int63[37],
     zero$1=Base_Int63[38],
     one$1=Base_Int63[39],
     minus_one$1=Base_Int63[40],
     symbol$24=Base_Int63[41],
     symbol$25=Base_Int63[42],
     symbol$26=Base_Int63[43],
     symbol$27=Base_Int63[44],
     neg$0=Base_Int63[45],
     symbol$28=Base_Int63[46],
     symbol$29=Base_Int63[47],
     symbol$30=Base_Int63[48],
     symbol$31=Base_Int63[49],
     rem$1=Base_Int63[50],
     symbol$32=Base_Int63[51],
     land$0=Base_Int63[52],
     lor$0=Base_Int63[53],
     lxor$0=Base_Int63[54],
     lnot$1=Base_Int63[55],
     lsl$0=Base_Int63[56],
     asr$0=Base_Int63[57],
     round$1=Base_Int63[58],
     round_towards_zero$1=Base_Int63[59],
     round_down$1=Base_Int63[60],
     round_up$1=Base_Int63[61],
     round_nearest$1=Base_Int63[62],
     abs$1=Base_Int63[63],
     succ$1=Base_Int63[64],
     pred$1=Base_Int63[65],
     pow$1=Base_Int63[66],
     bit_and$1=Base_Int63[67],
     bit_or$1=Base_Int63[68],
     bit_xor$1=Base_Int63[69],
     bit_not$1=Base_Int63[70],
     popcount$2=Base_Int63[71],
     shift_left$1=Base_Int63[72],
     shift_right$1=Base_Int63[73],
     decr$1=Base_Int63[74],
     incr$1=Base_Int63[75],
     of_int32_exn$1=Base_Int63[76],
     to_int32_exn$1=Base_Int63[77],
     of_int64_exn$1=Base_Int63[78],
     to_int64$1=Base_Int63[79],
     of_nativeint_exn$1=Base_Int63[80],
     to_nativeint_exn$1=Base_Int63[81],
     of_float_unchecked$1=Base_Int63[82],
     num_bits$1=Base_Int63[83],
     max_value$1=Base_Int63[84],
     min_value$1=Base_Int63[85],
     lsr$0=Base_Int63[86],
     shift_right_logical$1=Base_Int63[87],
     ceil_pow2$1=Base_Int63[88],
     floor_pow2$1=Base_Int63[89],
     ceil_log2$1=Base_Int63[90],
     is_pow2$1=Base_Int63[91],
     clz$1=Base_Int63[92],
     ctz$1=Base_Int63[93],
     O$1=Base_Int63[94],
     floor_log2$1=Base_Int63[113],
     For_int63=
      Make
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$18,
         symbol$19,
         symbol$20,
         symbol$21,
         symbol$22,
         symbol$23,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$24,
         symbol$25,
         symbol$26,
         symbol$27,
         neg$0,
         symbol$28,
         symbol$29,
         symbol$30,
         symbol$31,
         rem$1,
         symbol$32,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$2,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         int63]),
     t_sexp_grammar$2=Base_Int64[1],
     of_float$2=Base_Int64[2],
     to_float$2=Base_Int64[3],
     of_int_exn$2=Base_Int64[4],
     to_int_exn$2=Base_Int64[5],
     hash_fold_t$2=Base_Int64[6],
     hash$2=Base_Int64[7],
     t_of_sexp$2=Base_Int64[8],
     sexp_of_t$2=Base_Int64[9],
     of_string$2=Base_Int64[10],
     to_string$2=Base_Int64[11],
     equal$2=Base_Int64[12],
     compare$2=Base_Int64[13],
     min$2=Base_Int64[14],
     max$2=Base_Int64[15],
     ascending$2=Base_Int64[16],
     descending$2=Base_Int64[17],
     between$2=Base_Int64[18],
     clamp_exn$2=Base_Int64[19],
     clamp$2=Base_Int64[20],
     comparator$2=Base_Int64[21],
     pp$2=Base_Int64[22],
     hashable$2=Base_Int64[23],
     is_positive$2=Base_Int64[24],
     is_non_negative$2=Base_Int64[25],
     is_negative$2=Base_Int64[26],
     is_non_positive$2=Base_Int64[27],
     sign$2=Base_Int64[28],
     invariant$2=Base_Int64[29],
     Hex$2=Base_Int64[30],
     to_string_hum$2=Base_Int64[31],
     one$2=Base_Int64[32],
     minus_one$2=Base_Int64[33],
     rem$2=Base_Int64[34],
     round$2=Base_Int64[35],
     round_towards_zero$2=Base_Int64[36],
     round_down$2=Base_Int64[37],
     round_up$2=Base_Int64[38],
     round_nearest$2=Base_Int64[39],
     succ$2=Base_Int64[40],
     pred$2=Base_Int64[41],
     pow$2=Base_Int64[42],
     bit_and$2=Base_Int64[43],
     bit_or$2=Base_Int64[44],
     bit_xor$2=Base_Int64[45],
     bit_not$2=Base_Int64[46],
     popcount$3=Base_Int64[47],
     shift_left$2=Base_Int64[48],
     shift_right$2=Base_Int64[49],
     decr$2=Base_Int64[50],
     incr$2=Base_Int64[51],
     of_int32_exn$2=Base_Int64[52],
     to_int32_exn$2=Base_Int64[53],
     of_int64_exn$2=Base_Int64[54],
     to_int64$2=Base_Int64[55],
     of_nativeint_exn$2=Base_Int64[56],
     to_nativeint_exn$2=Base_Int64[57],
     of_float_unchecked$2=Base_Int64[58],
     num_bits$2=Base_Int64[59],
     max_value$2=Base_Int64[60],
     min_value$2=Base_Int64[61],
     shift_right_logical$2=Base_Int64[62],
     ceil_pow2$2=Base_Int64[63],
     floor_pow2$2=Base_Int64[64],
     ceil_log2$2=Base_Int64[65],
     floor_log2$2=Base_Int64[66],
     is_pow2$2=Base_Int64[67],
     clz$2=Base_Int64[68],
     ctz$2=Base_Int64[69],
     O$2=Base_Int64[70],
     symbol$33=Base_Int64[71],
     lnot$2=Base_Int64[72],
     abs$2=Base_Int64[73],
     zero$2=Base_Int64[74],
     symbol$34=Base_Int64[75],
     symbol$35=Base_Int64[76],
     symbol$36=Base_Int64[77],
     For_int64=
      Make
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$33,
         caml_int64_neg,
         caml_int64_neg,
         symbol$35,
         symbol$34,
         caml_int64_div,
         rem$2,
         symbol$36,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$3,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         int64]),
     t_sexp_grammar$3=Base_Nativeint[1],
     of_float$3=Base_Nativeint[2],
     to_float$3=Base_Nativeint[3],
     of_int_exn$3=Base_Nativeint[4],
     to_int_exn$3=Base_Nativeint[5],
     hash_fold_t$3=Base_Nativeint[6],
     hash$3=Base_Nativeint[7],
     t_of_sexp$3=Base_Nativeint[8],
     sexp_of_t$3=Base_Nativeint[9],
     of_string$3=Base_Nativeint[10],
     to_string$3=Base_Nativeint[11],
     symbol$37=Base_Nativeint[12],
     symbol$38=Base_Nativeint[13],
     symbol$39=Base_Nativeint[14],
     symbol$40=Base_Nativeint[15],
     symbol$41=Base_Nativeint[16],
     symbol$42=Base_Nativeint[17],
     equal$3=Base_Nativeint[18],
     compare$3=Base_Nativeint[19],
     min$3=Base_Nativeint[20],
     max$3=Base_Nativeint[21],
     ascending$3=Base_Nativeint[22],
     descending$3=Base_Nativeint[23],
     between$3=Base_Nativeint[24],
     clamp_exn$3=Base_Nativeint[25],
     clamp$3=Base_Nativeint[26],
     comparator$3=Base_Nativeint[27],
     pp$3=Base_Nativeint[28],
     hashable$3=Base_Nativeint[29],
     is_positive$3=Base_Nativeint[30],
     is_non_negative$3=Base_Nativeint[31],
     is_negative$3=Base_Nativeint[32],
     is_non_positive$3=Base_Nativeint[33],
     sign$3=Base_Nativeint[34],
     invariant$3=Base_Nativeint[35],
     Hex$3=Base_Nativeint[36],
     to_string_hum$3=Base_Nativeint[37],
     zero$3=Base_Nativeint[38],
     one$3=Base_Nativeint[39],
     minus_one$3=Base_Nativeint[40],
     symbol$43=Base_Nativeint[41],
     symbol$44=Base_Nativeint[42],
     symbol$45=Base_Nativeint[43],
     symbol$46=Base_Nativeint[44],
     neg$1=Base_Nativeint[45],
     symbol$47=Base_Nativeint[46],
     symbol$48=Base_Nativeint[47],
     symbol$49=Base_Nativeint[48],
     symbol$50=Base_Nativeint[49],
     rem$3=Base_Nativeint[50],
     symbol$51=Base_Nativeint[51],
     land$1=Base_Nativeint[52],
     lor$1=Base_Nativeint[53],
     lxor$1=Base_Nativeint[54],
     lnot$3=Base_Nativeint[55],
     lsl$1=Base_Nativeint[56],
     asr$1=Base_Nativeint[57],
     round$3=Base_Nativeint[58],
     round_towards_zero$3=Base_Nativeint[59],
     round_down$3=Base_Nativeint[60],
     round_up$3=Base_Nativeint[61],
     round_nearest$3=Base_Nativeint[62],
     abs$3=Base_Nativeint[63],
     succ$3=Base_Nativeint[64],
     pred$3=Base_Nativeint[65],
     pow$3=Base_Nativeint[66],
     bit_and$3=Base_Nativeint[67],
     bit_or$3=Base_Nativeint[68],
     bit_xor$3=Base_Nativeint[69],
     bit_not$3=Base_Nativeint[70],
     popcount$4=Base_Nativeint[71],
     shift_left$3=Base_Nativeint[72],
     shift_right$3=Base_Nativeint[73],
     decr$3=Base_Nativeint[74],
     incr$3=Base_Nativeint[75],
     of_int32_exn$3=Base_Nativeint[76],
     to_int32_exn$3=Base_Nativeint[77],
     of_int64_exn$3=Base_Nativeint[78],
     to_int64$3=Base_Nativeint[79],
     of_nativeint_exn$3=Base_Nativeint[80],
     to_nativeint_exn$3=Base_Nativeint[81],
     of_float_unchecked$3=Base_Nativeint[82],
     num_bits$3=Base_Nativeint[83],
     max_value$3=Base_Nativeint[84],
     min_value$3=Base_Nativeint[85],
     lsr$1=Base_Nativeint[86],
     shift_right_logical$3=Base_Nativeint[87],
     ceil_pow2$3=Base_Nativeint[88],
     floor_pow2$3=Base_Nativeint[89],
     ceil_log2$3=Base_Nativeint[90],
     floor_log2$3=Base_Nativeint[91],
     is_pow2$3=Base_Nativeint[92],
     clz$3=Base_Nativeint[93],
     ctz$3=Base_Nativeint[94],
     O$3=Base_Nativeint[95],
     For_nativeint=
      Make
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$37,
         symbol$38,
         symbol$39,
         symbol$40,
         symbol$41,
         symbol$42,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$43,
         symbol$44,
         symbol$45,
         symbol$46,
         neg$1,
         symbol$47,
         symbol$48,
         symbol$49,
         symbol$50,
         rem$3,
         symbol$51,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$4,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         nativeint]),
     int$1=For_int[1],
     int32$0=For_int32[1],
     int63$0=For_int63[1],
     int64$1=For_int64[1],
     nativeint$0=For_nativeint[1];
    caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2],0);
    var
     Splittable_random=
      [0,
       [0,create,of_int,perturb,copy,split],
       bool,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       unit_float,
       [0,int$1,int32$0,int63$0,int64$1,nativeint$0]];
    runtime.caml_register_global(40,Splittable_random,"Splittable_random");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGxpdHRhYmxlX3JhbmRvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiaW50NjQkMCIsImdvbGRlbl9nYW1tYSIsInBvcGNvdW50Iiwib2ZfaW50Iiwic2VlZCIsImNvcHkiLCJvZGRfZ2FtbWEiLCJtaXhfYml0cyIsInoiLCJuIiwibWl4NjQiLCJ6JDAiLCJ6JDEiLCJuZXh0X3NlZWQiLCJ0IiwibmV4dCIsIm9mX3NlZWRfYW5kX2dhbW1hIiwiZ2FtbWEiLCJzZWVkJDAiLCJyYW5kb21faW50NjQiLCJyYW5kb21fc3RhdGUiLCJjcmVhdGUiLCJzcGxpdCIsIm5leHRfaW50NjQiLCJwZXJ0dXJiIiwic2FsdCIsImJvb2wiLCJzdGF0ZSIsIngiLCJpbnQ2NCIsImxvIiwiaGkiLCJtYXhpbXVtIiwiZHJhdyQwIiwicmVtYWluZGVyIiwiZHJhdyIsImludCQwIiwibG8kMCIsImhpJDAiLCJpbnQzMiIsIm5hdGl2ZWludCIsImludDYzIiwiZG91YmxlX3VscCIsInVuaXRfZmxvYXRfZnJvbV9pbnQ2NCIsInVuaXRfZmxvYXQiLCJmbG9hdCQwIiwibG8kMSIsInJhbmdlIiwiZiIsImJpdHNfdG9fcmVwcmVzZW50IiwidCQwIiwibG9nX3VuaWZvcm0iLCJtaW5fYml0cyIsIm1heF9iaXRzIiwidF9zZXhwX2dyYW1tYXIiLCJvZl9mbG9hdCIsInRvX2Zsb2F0Iiwib2ZfaW50X2V4biIsInRvX2ludF9leG4iLCJoYXNoX2ZvbGRfdCIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJlcXVhbCIsImNvbXBhcmUiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsInBwIiwiaGFzaGFibGUiLCJpc19wb3NpdGl2ZSIsImlzX25vbl9uZWdhdGl2ZSIsImlzX25lZ2F0aXZlIiwiaXNfbm9uX3Bvc2l0aXZlIiwic2lnbiIsImludmFyaWFudCIsInRvX3N0cmluZ19odW0iLCJvbmUiLCJtaW51c19vbmUiLCJyZW0iLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJzdWNjIiwicHJlZCIsInBvdyIsImJpdF9hbmQiLCJiaXRfb3IiLCJiaXRfeG9yIiwiYml0X25vdCIsInBvcGNvdW50JDAiLCJzaGlmdF9sZWZ0Iiwic2hpZnRfcmlnaHQiLCJkZWNyIiwiaW5jciIsIm9mX2ludDMyX2V4biIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0X2V4biIsInRvX2ludDY0Iiwib2ZfbmF0aXZlaW50X2V4biIsInRvX25hdGl2ZWludF9leG4iLCJvZl9mbG9hdF91bmNoZWNrZWQiLCJudW1fYml0cyIsIm1heF92YWx1ZSIsIm1pbl92YWx1ZSIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiY2VpbF9sb2cyIiwiZmxvb3JfbG9nMiIsImlzX3BvdzIiLCJjbHoiLCJjdHoiLCJzeW1ib2wiLCJsbm90IiwiYWJzIiwiemVybyIsInN5bWJvbCQwIiwic3ltYm9sJDEiLCJzeW1ib2wkMiIsInRfc2V4cF9ncmFtbWFyJDAiLCJvZl9mbG9hdCQwIiwidG9fZmxvYXQkMCIsIm9mX2ludF9leG4kMCIsInRvX2ludF9leG4kMCIsImhhc2hfZm9sZF90JDAiLCJoYXNoJDAiLCJ0X29mX3NleHAkMCIsInNleHBfb2ZfdCQwIiwib2Zfc3RyaW5nJDAiLCJ0b19zdHJpbmckMCIsInN5bWJvbCQzIiwic3ltYm9sJDQiLCJzeW1ib2wkNSIsInN5bWJvbCQ2Iiwic3ltYm9sJDciLCJzeW1ib2wkOCIsImVxdWFsJDAiLCJjb21wYXJlJDAiLCJtaW4kMCIsIm1heCQwIiwiYXNjZW5kaW5nJDAiLCJkZXNjZW5kaW5nJDAiLCJiZXR3ZWVuJDAiLCJjbGFtcF9leG4kMCIsImNsYW1wJDAiLCJjb21wYXJhdG9yJDAiLCJwcCQwIiwiaGFzaGFibGUkMCIsImlzX3Bvc2l0aXZlJDAiLCJpc19ub25fbmVnYXRpdmUkMCIsImlzX25lZ2F0aXZlJDAiLCJpc19ub25fcG9zaXRpdmUkMCIsInNpZ24kMCIsImludmFyaWFudCQwIiwidG9fc3RyaW5nX2h1bSQwIiwiemVybyQwIiwib25lJDAiLCJtaW51c19vbmUkMCIsInN5bWJvbCQ5Iiwic3ltYm9sJDEwIiwic3ltYm9sJDExIiwic3ltYm9sJDEyIiwibmVnIiwic3ltYm9sJDEzIiwic3ltYm9sJDE0Iiwic3ltYm9sJDE1Iiwic3ltYm9sJDE2IiwicmVtJDAiLCJzeW1ib2wkMTciLCJsYW5kIiwibG9yIiwibHhvciIsImxub3QkMCIsImxzbCIsImFzciIsInJvdW5kJDAiLCJyb3VuZF90b3dhcmRzX3plcm8kMCIsInJvdW5kX2Rvd24kMCIsInJvdW5kX3VwJDAiLCJyb3VuZF9uZWFyZXN0JDAiLCJhYnMkMCIsInN1Y2MkMCIsInByZWQkMCIsInBvdyQwIiwiYml0X2FuZCQwIiwiYml0X29yJDAiLCJiaXRfeG9yJDAiLCJiaXRfbm90JDAiLCJwb3Bjb3VudCQxIiwic2hpZnRfbGVmdCQwIiwic2hpZnRfcmlnaHQkMCIsImRlY3IkMCIsImluY3IkMCIsIm9mX2ludDMyX2V4biQwIiwidG9faW50MzJfZXhuJDAiLCJvZl9pbnQ2NF9leG4kMCIsInRvX2ludDY0JDAiLCJvZl9uYXRpdmVpbnRfZXhuJDAiLCJ0b19uYXRpdmVpbnRfZXhuJDAiLCJvZl9mbG9hdF91bmNoZWNrZWQkMCIsIm51bV9iaXRzJDAiLCJtYXhfdmFsdWUkMCIsIm1pbl92YWx1ZSQwIiwibHNyIiwic2hpZnRfcmlnaHRfbG9naWNhbCQwIiwiY2VpbF9wb3cyJDAiLCJmbG9vcl9wb3cyJDAiLCJjZWlsX2xvZzIkMCIsImZsb29yX2xvZzIkMCIsImlzX3BvdzIkMCIsImNseiQwIiwiY3R6JDAiLCJ0X3NleHBfZ3JhbW1hciQyIiwib2ZfZmxvYXQkMiIsInRvX2Zsb2F0JDIiLCJvZl9pbnRfZXhuJDIiLCJ0b19pbnRfZXhuJDIiLCJoYXNoX2ZvbGRfdCQyIiwiaGFzaCQyIiwidF9vZl9zZXhwJDIiLCJzZXhwX29mX3QkMiIsIm9mX3N0cmluZyQyIiwidG9fc3RyaW5nJDIiLCJlcXVhbCQyIiwiY29tcGFyZSQyIiwibWluJDIiLCJtYXgkMiIsImFzY2VuZGluZyQyIiwiZGVzY2VuZGluZyQyIiwiYmV0d2VlbiQyIiwiY2xhbXBfZXhuJDIiLCJjbGFtcCQyIiwiY29tcGFyYXRvciQyIiwicHAkMiIsImhhc2hhYmxlJDIiLCJpc19wb3NpdGl2ZSQyIiwiaXNfbm9uX25lZ2F0aXZlJDIiLCJpc19uZWdhdGl2ZSQyIiwiaXNfbm9uX3Bvc2l0aXZlJDIiLCJzaWduJDIiLCJpbnZhcmlhbnQkMiIsInRvX3N0cmluZ19odW0kMiIsIm9uZSQyIiwibWludXNfb25lJDIiLCJyZW0kMiIsInJvdW5kJDIiLCJyb3VuZF90b3dhcmRzX3plcm8kMiIsInJvdW5kX2Rvd24kMiIsInJvdW5kX3VwJDIiLCJyb3VuZF9uZWFyZXN0JDIiLCJzdWNjJDIiLCJwcmVkJDIiLCJwb3ckMiIsImJpdF9hbmQkMiIsImJpdF9vciQyIiwiYml0X3hvciQyIiwiYml0X25vdCQyIiwicG9wY291bnQkMyIsInNoaWZ0X2xlZnQkMiIsInNoaWZ0X3JpZ2h0JDIiLCJkZWNyJDIiLCJpbmNyJDIiLCJvZl9pbnQzMl9leG4kMiIsInRvX2ludDMyX2V4biQyIiwib2ZfaW50NjRfZXhuJDIiLCJ0b19pbnQ2NCQyIiwib2ZfbmF0aXZlaW50X2V4biQyIiwidG9fbmF0aXZlaW50X2V4biQyIiwib2ZfZmxvYXRfdW5jaGVja2VkJDIiLCJudW1fYml0cyQyIiwibWF4X3ZhbHVlJDIiLCJtaW5fdmFsdWUkMiIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwkMiIsImNlaWxfcG93MiQyIiwiZmxvb3JfcG93MiQyIiwiY2VpbF9sb2cyJDIiLCJmbG9vcl9sb2cyJDIiLCJpc19wb3cyJDIiLCJjbHokMiIsImN0eiQyIiwic3ltYm9sJDMzIiwibG5vdCQyIiwiYWJzJDIiLCJ6ZXJvJDIiLCJzeW1ib2wkMzQiLCJzeW1ib2wkMzUiLCJzeW1ib2wkMzYiLCJ0X3NleHBfZ3JhbW1hciQzIiwib2ZfZmxvYXQkMyIsInRvX2Zsb2F0JDMiLCJvZl9pbnRfZXhuJDMiLCJ0b19pbnRfZXhuJDMiLCJoYXNoX2ZvbGRfdCQzIiwiaGFzaCQzIiwidF9vZl9zZXhwJDMiLCJzZXhwX29mX3QkMyIsIm9mX3N0cmluZyQzIiwidG9fc3RyaW5nJDMiLCJzeW1ib2wkMzciLCJzeW1ib2wkMzgiLCJzeW1ib2wkMzkiLCJzeW1ib2wkNDAiLCJzeW1ib2wkNDEiLCJzeW1ib2wkNDIiLCJlcXVhbCQzIiwiY29tcGFyZSQzIiwibWluJDMiLCJtYXgkMyIsImFzY2VuZGluZyQzIiwiZGVzY2VuZGluZyQzIiwiYmV0d2VlbiQzIiwiY2xhbXBfZXhuJDMiLCJjbGFtcCQzIiwiY29tcGFyYXRvciQzIiwicHAkMyIsImhhc2hhYmxlJDMiLCJpc19wb3NpdGl2ZSQzIiwiaXNfbm9uX25lZ2F0aXZlJDMiLCJpc19uZWdhdGl2ZSQzIiwiaXNfbm9uX3Bvc2l0aXZlJDMiLCJzaWduJDMiLCJpbnZhcmlhbnQkMyIsInRvX3N0cmluZ19odW0kMyIsInplcm8kMyIsIm9uZSQzIiwibWludXNfb25lJDMiLCJzeW1ib2wkNDMiLCJzeW1ib2wkNDQiLCJzeW1ib2wkNDUiLCJzeW1ib2wkNDYiLCJuZWckMSIsInN5bWJvbCQ0NyIsInN5bWJvbCQ0OCIsInN5bWJvbCQ0OSIsInN5bWJvbCQ1MCIsInJlbSQzIiwic3ltYm9sJDUxIiwibGFuZCQxIiwibG9yJDEiLCJseG9yJDEiLCJsbm90JDMiLCJsc2wkMSIsImFzciQxIiwicm91bmQkMyIsInJvdW5kX3Rvd2FyZHNfemVybyQzIiwicm91bmRfZG93biQzIiwicm91bmRfdXAkMyIsInJvdW5kX25lYXJlc3QkMyIsImFicyQzIiwic3VjYyQzIiwicHJlZCQzIiwicG93JDMiLCJiaXRfYW5kJDMiLCJiaXRfb3IkMyIsImJpdF94b3IkMyIsImJpdF9ub3QkMyIsInBvcGNvdW50JDQiLCJzaGlmdF9sZWZ0JDMiLCJzaGlmdF9yaWdodCQzIiwiZGVjciQzIiwiaW5jciQzIiwib2ZfaW50MzJfZXhuJDMiLCJ0b19pbnQzMl9leG4kMyIsIm9mX2ludDY0X2V4biQzIiwidG9faW50NjQkMyIsIm9mX25hdGl2ZWludF9leG4kMyIsInRvX25hdGl2ZWludF9leG4kMyIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQzIiwibnVtX2JpdHMkMyIsIm1heF92YWx1ZSQzIiwibWluX3ZhbHVlJDMiLCJsc3IkMSIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwkMyIsImNlaWxfcG93MiQzIiwiZmxvb3JfcG93MiQzIiwiY2VpbF9sb2cyJDMiLCJmbG9vcl9sb2cyJDMiLCJpc19wb3cyJDMiLCJjbHokMyIsImN0eiQzIiwiaW50JDEiLCJpbnQzMiQwIiwiaW50NjMkMCIsImludDY0JDEiLCJuYXRpdmVpbnQkMCJdLCJzb3VyY2VzIjpbIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9zcGxpdHRhYmxlX3JhbmRvbS9zcGxpdHRhYmxlX3JhbmRvbS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9vY2FtbC9pbnQ2NC5tbGkiXSwibWFwcGluZ3MiOiI7Ozs7O0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNSTUE7Ozs7Ozs7S0FsUEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FURkM7Ozs7Ozs7Ozs7Ozs7Ozs7YUFXRUMsT0FBT0MsTUFDSyw4QkFETEEsTUFGUEgsYUFLRDthQUVDSTtVQUFPRCxjQUFPRSw2QkFBUEYsS0FBT0U7YUFFZEMsU0FBU0MsRUFBRUM7TUFDYixzQkFEV0QsRUFDSiwrQkFESUEsRUFBRUMsR0FDRzthQUVkQyxNQUFNRjtNQUNlOzBCQUpyQkQsU0FHTUM7T0FFZSxtQkFMckJELFNBSUVJO01BQ21CLE9BTHJCSixTQUtFSyxPQUNTO2FBOEJYQyxVQUFVQztNQUNELElBQVBDLEtBQU8sZUFEQ0QsV0FDRCxPQUFQQyxLQUFPLE9BQVBBLElBRUE7YUFFRkMsa0JBQW1CWixLQUFNYTtNQUNYO2NBdkNkUCxN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QUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FNQUM7U0FtREFDO1NBR0FDO1NBR0FDOztTQU9BQztTQUlBQztTQUlBQztTQUdBQztTQUdBQztTQUdBQztTQU1BQztTQU1BQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBL0lFcFE7S0F2RkY0UTtLQUlRQzs7S0FDQUU7O0tBQ0FFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FDQXdCOzs7OztLQUNBSzs7S0FJUkM7S0FJQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FHQUM7S0FJQUM7S0FDQUM7S0FzQkFDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBR0FDO0tBR0FDO0tBR0FDO0tBR0FDO0tBR0FDO0tBR0FDO0tBR0FDO0tBSVFDOzs7OztLQUlSSztLQUlBQztLQUNBQztLQU1BQztLQU1BQztLQUVBQztLQUNBQztLQUNBQztLQUdBQztLQU9BQztLQUdBQztLQUlBQztLQUNBQztLQUlBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQU1BQztLQW1EQUM7S0FHQUM7S0FHQUM7S0FHQUM7S0FJQUM7S0FJQUM7S0FJQUM7S0FHQUM7S0FHQUM7S0FHQUM7S0FNQUM7S0FNQUM7Ozs7O1NBdE9BNUY7U0FJUUM7O1NBQ0FFOztTQUNBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBQ0F3Qjs7Ozs7U0FDQUs7O1NBSVJDO1NBSUFDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBR0FDO1NBSUFDO1NBQ0FDO1NBc0JBQztTQUNBQztTQUNBQztTQUNBQztTQUdBQztTQUdBQztTQUdBQztTQUdBQztTQUdBQztTQUdBQztTQUdBQztTQUlRQzs7Ozs7U0FJUks7U0FJQUM7U0FDQUM7U0FNQUM7U0FNQUM7U0FFQUM7U0FDQUM7U0FDQUM7U0FHQUM7U0FPQUM7U0FHQUM7U0FJQUM7U0FDQUM7U0FJQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FNQUM7U0FtREFDO1NBR0FDO1NBR0FDO1NBR0FDO1NBSUFDO1NBSUFDO1NBSUFDO1NBR0FDO1NBR0FDO1NBR0FDO1NBTUFDO1NBTUFDOztTQXJHRTdWO0tBbUtFOFY7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7Ozs7O1VBM1FBclgsT0F4REFsQixPQXNFQXFCLFFBakVBbkIsS0F3REFpQjtPQWVGSTtPQW9FQVU7T0FNQUc7T0FZQUU7T0FoREFaO09BMENBVztPQStDQUs7T0FYQUQ7VUErSEUwVixNQUNBQyxRQUNBQyxRQUNBQyxRQUNBQzs7VSIsInNvdXJjZXNDb250ZW50IjpbIigqKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIFwiRmFzdCBTcGxpdHRhYmxlIFBzZXVkb3JhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiIGJ5IFN0ZWVsZSBldC5cbiAgICBhbC4gKDEpLiAgVGhlIHBhcGVyJ3MgYWxnb3JpdGhtIHByb3ZpZGVzIGRlY2VudCByYW5kb21uZXNzIGZvciBtb3N0IHB1cnBvc2VzLCBidXRcbiAgICBzYWNyaWZpY2VzIGNyeXB0b2dyYXBoaWMtcXVhbGl0eSByYW5kb21uZXNzIGluIGZhdm9yIG9mIHBlcmZvcm1hbmNlLiAgVGhlIG9yaWdpbmFsXG4gICAgaW1wbGVtZW50YXRpb24gd2FzIHRlc3RlZCB3aXRoIERpZUhhcmRlciBhbmQgQmlnQ3J1c2g7IHNlZSB0aGUgcGFwZXIgZm9yIGRldGFpbHMuXG5cbiAgICBPdXIgaW1wbGVtZW50YXRpb24gaXMgYSBwb3J0IGZyb20gSmF2YSB0byBPQ2FtbCBvZiB0aGUgcGFwZXIncyBhbGdvcml0aG0uICBPdGhlciB0aGFuXG4gICAgdGhlIGNob2ljZSBvZiBpbml0aWFsIHNlZWQgZm9yIFtjcmVhdGVdLCBvdXIgcG9ydCBzaG91bGQgYmUgZmFpdGhmdWwuICBXZSBoYXZlIG5vdFxuICAgIHJlLXJ1biB0aGUgRGllSGFyZGVyIG9yIEJpZ0NydXNoIHRlc3RzIG9uIG91ciBpbXBsZW1lbnRhdGlvbi4gIE91ciBwb3J0IGlzIGFsc28gbm90IGFzXG4gICAgcGVyZm9ybWFudCBhcyB0aGUgb3JpZ2luYWw7IHR3byBmYWN0b3JzIHRoYXQgaHVydCB1cyBhcmUgYm94ZWQgW2ludDY0XSB2YWx1ZXMgYW5kIGxhY2tcbiAgICBvZiBhIFBPUENOVCBwcmltaXRpdmUuXG5cbiAgICAoMSkgaHR0cDovLzIwMTQuc3BsYXNoY29uLm9yZy9ldmVudC9vb3BzbGEyMDE0LWZhc3Qtc3BsaXR0YWJsZS1wc2V1ZG9yYW5kb20tbnVtYmVyLWdlbmVyYXRvcnNcbiAgICAoYWxzbyBtaXJyb3JlZCBhdCBodHRwOi8vZ2VlLmNzLm9zd2Vnby5lZHUvZGwvcGFwZXJzL29vcHNsYTE0LnBkZilcblxuICAgIEJld2FyZSB3aGVuIGltcGxlbWVudGluZyB0aGlzIGludGVyZmFjZTsgaXQgaXMgZWFzeSB0byBpbXBsZW1lbnQgYSBbc3BsaXRdIG9wZXJhdGlvblxuICAgIHdob3NlIG91dHB1dCBpcyBub3QgYXMgXCJpbmRlcGVuZGVudFwiIGFzIGl0IHNlZW1zICgyKS4gIFRoaXMgYnVnIGNhdXNlZCBwcm9ibGVtcyBmb3JcbiAgICBIYXNrZWxsJ3MgUXVpY2tjaGVjayBsaWJyYXJ5IGZvciBhIGxvbmcgdGltZS5cblxuICAgICgyKSBTY2hhYXRodW4sIFwiRXZhbHVhdGlvbiBvZiBzcGxpdHRhYmxlIHBzZXVkby1yYW5kb20gZ2VuZXJhdG9yc1wiLCBKRlAgMjAxNS5cbiAgICBodHRwOi8vd3d3LmhnLnNjaGFhdGh1bi5uZXQvcmVzZWFyY2gvUGFwZXJzL2hnczIwMTVqZnAucGRmXG4qKVxuXG5vcGVuISBCYXNlXG5vcGVuICBJbnQ2NC5PXG5cbmxldCBpc19vZGQgeCA9IHggbG9yIDFMID0geFxuXG5sZXQgcG9wY291bnQgPSBJbnQ2NC5wb3Bjb3VudFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBzZWVkIDogaW50NjRcbiAgICA7IG9kZF9nYW1tYSAgICA6IGludDY0XG4gICAgfVxuXG4gIGxldCBnb2xkZW5fZ2FtbWEgPSAweDllMzdfNzliOV83ZjRhXzdjMTVMXG5cbiAgbGV0IG9mX2ludCBzZWVkID1cbiAgICB7IHNlZWQgICAgICA9IEludDY0Lm9mX2ludCBzZWVkXG4gICAgOyBvZGRfZ2FtbWEgPSBnb2xkZW5fZ2FtbWFcbiAgICB9XG5cbiAgbGV0IGNvcHkgeyBzZWVkIDsgb2RkX2dhbW1hIH0gPSB7IHNlZWQgOyBvZGRfZ2FtbWEgfVxuXG4gIGxldCBtaXhfYml0cyB6IG4gPVxuICAgIHogbHhvciAoeiBsc3IgbilcblxuICBsZXQgbWl4NjQgeiA9XG4gICAgbGV0IHogPSAobWl4X2JpdHMgeiAzMykgKiAweGZmNTFfYWZkN19lZDU1XzhjY2RMIGluXG4gICAgbGV0IHogPSAobWl4X2JpdHMgeiAzMykgKiAweGM0Y2VfYjlmZV8xYTg1X2VjNTNMIGluXG4gICAgbWl4X2JpdHMgeiAzM1xuXG4gIGxldCBtaXg2NF92YXJpYW50MTMgeiA9XG4gICAgbGV0IHogPSAobWl4X2JpdHMgeiAzMCkgKiAweGJmNThfNDc2ZF8xY2U0X2U1YjlMIGluXG4gICAgbGV0IHogPSAobWl4X2JpdHMgeiAyNykgKiAweDk0ZDBfNDliYl8xMzMxXzExZWJMIGluXG4gICAgbWl4X2JpdHMgeiAzMVxuXG4gIGxldCBtaXhfb2RkX2dhbW1hIHogPVxuICAgIGxldCB6ID0gKG1peDY0X3ZhcmlhbnQxMyB6KSBsb3IgMUwgaW5cbiAgICBsZXQgbiA9IHBvcGNvdW50ICh6IGx4b3IgKHogbHNyIDEpKSBpblxuICAgICgqIFRoZSBvcmlnaW5hbCBwYXBlciB1c2VzIFs+PV0gaW4gdGhlIGNvbmRpdGlvbmFsIGltbWVkaWF0ZWx5IGJlbG93OyBob3dldmVyIHRoaXMgaXNcbiAgICAgICBhIHR5cG8sIGFuZCB3ZSBjb3JyZWN0IGl0IGJ5IHVzaW5nIFs8XS4gVGhpcyB3YXMgZml4ZWQgaW4gcmVzcG9uc2UgdG8gWzFdIGFuZCBbMl0uXG5cbiAgICAgICBbMV0gaHR0cHM6Ly9naXRodWIuY29tL2phbmVzdHJlZXQvc3BsaXR0YWJsZV9yYW5kb20vaXNzdWVzLzFcbiAgICAgICBbMl0gaHR0cDovL3d3dy5wY2ctcmFuZG9tLm9yZy9wb3N0cy9idWdzLWluLXNwbGl0bWl4Lmh0bWxcbiAgICAqKVxuICAgIGlmIEludC4oIDwgKSBuIDI0XG4gICAgdGhlbiB6IGx4b3IgMHhhYWFhX2FhYWFfYWFhYV9hYWFhTFxuICAgIGVsc2UgelxuXG4gIGxldCV0ZXN0X3VuaXQgXCJvZGQgZ2FtbWFcIiA9XG4gICAgZm9yIGlucHV0ID0gLTFfMDAwXzAwMCB0byAxXzAwMF8wMDAgZG9cbiAgICAgIGxldCBvdXRwdXQgPSBtaXhfb2RkX2dhbW1hIChJbnQ2NC5vZl9pbnQgaW5wdXQpIGluXG4gICAgICBpZiBub3QgKGlzX29kZCBvdXRwdXQpIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2VcbiAgICAgICAgICBcImdhbW1hIHZhbHVlIGlzIG5vdCBvZGRcIlxuICAgICAgICAgICAgKGlucHV0ICA6IGludClcbiAgICAgICAgICAgIChvdXRwdXQgOiBpbnQ2NCldXG4gICAgZG9uZVxuXG4gIGxldCBuZXh0X3NlZWQgdCA9XG4gICAgbGV0IG5leHQgPSB0LnNlZWQgKyB0Lm9kZF9nYW1tYSBpblxuICAgIHQuc2VlZCA8LSBuZXh0O1xuICAgIG5leHRcblxuICBsZXQgb2Zfc2VlZF9hbmRfZ2FtbWEgfnNlZWQgfmdhbW1hID1cbiAgICBsZXQgc2VlZCAgICAgID0gbWl4NjQgICAgICAgICBzZWVkICBpblxuICAgIGxldCBvZGRfZ2FtbWEgPSBtaXhfb2RkX2dhbW1hIGdhbW1hIGluXG4gICAgeyBzZWVkOyBvZGRfZ2FtbWEgfVxuXG4gIGxldCByYW5kb21faW50NjQgcmFuZG9tX3N0YXRlID1cbiAgICBSYW5kb20uU3RhdGUuaW50NjRfaW5jbCByYW5kb21fc3RhdGUgSW50NjQubWluX3ZhbHVlIEludDY0Lm1heF92YWx1ZVxuXG4gIGxldCBjcmVhdGUgcmFuZG9tX3N0YXRlID1cbiAgICBsZXQgc2VlZCAgPSByYW5kb21faW50NjQgcmFuZG9tX3N0YXRlIGluXG4gICAgbGV0IGdhbW1hID0gcmFuZG9tX2ludDY0IHJhbmRvbV9zdGF0ZSBpblxuICAgIG9mX3NlZWRfYW5kX2dhbW1hIH5zZWVkIH5nYW1tYVxuXG4gIGxldCBzcGxpdCB0ID1cbiAgICBsZXQgc2VlZCAgPSBuZXh0X3NlZWQgdCBpblxuICAgIGxldCBnYW1tYSA9IG5leHRfc2VlZCB0IGluXG4gICAgb2Zfc2VlZF9hbmRfZ2FtbWEgfnNlZWQgfmdhbW1hXG5cbiAgbGV0IG5leHRfaW50NjQgdCA9IG1peDY0IChuZXh0X3NlZWQgdClcblxuICAoKiBbcGVydHVyYl0gaXMgbm90IGZyb20gYW55IGV4dGVybmFsIHNvdXJjZSwgYnV0IHByb3ZpZGVzIGEgd2F5IHRvIG1peCBpbiBleHRlcm5hbFxuICAgICBlbnRyb3B5IHdpdGggYSBwc2V1ZG8tcmFuZG9tIHN0YXRlLiAqKVxuICBsZXQgcGVydHVyYiB0IHNhbHQgPVxuICAgIGxldCBuZXh0ID0gdC5zZWVkICsgbWl4NjQgKEludDY0Lm9mX2ludCBzYWx0KSBpblxuICAgIHQuc2VlZCA8LSBuZXh0XG5cbmVuZFxuXG5sZXQgYm9vbCBzdGF0ZSA9IGlzX29kZCAoU3RhdGUubmV4dF9pbnQ2NCBzdGF0ZSlcblxuKCogV2UgYWJ1c2UgdGVybWlub2xvZ3kgYW5kIHJlZmVyIHRvIGluZGl2aWR1YWwgdmFsdWVzIGFzIGJpYXNlZCBvciB1bmJpYXNlZC4gIE1vcmVcbiAgIHByb3Blcmx5LCB3aGF0IGlzIHVuYmlhc2VkIGlzIHRoZSBzYW1wbGVyIHRoYXQgcmVzdWx0cyBpZiB3ZSBrZWVwIG9ubHkgdGhlc2UgXCJ1bmJpYXNlZFwiXG4gICB2YWx1ZXMuICopXG5sZXQgcmVtYWluZGVyX2lzX3VuYmlhc2VkXG4gICAgICB+ZHJhd1xuICAgICAgfnJlbWFpbmRlclxuICAgICAgfmRyYXdfbWF4aW11bVxuICAgICAgfnJlbWFpbmRlcl9tYXhpbXVtXG4gID1cbiAgbGV0IG9wZW4gSW50NjQuTyBpblxuICBkcmF3IC0gcmVtYWluZGVyIDw9IGRyYXdfbWF4aW11bSAtIHJlbWFpbmRlcl9tYXhpbXVtXG5cbmxldCV0ZXN0X3VuaXQgXCJyZW1haW5kZXJfaXNfdW5iaWFzZWRcIiA9XG4gICgqIGNob29zaW5nIGEgcmFuZ2Ugb2YgMTAgdmFsdWVzIGJhc2VkIG9uIGEgcmFuZ2Ugb2YgMTA1IHZhbHVlcyAqKVxuICBsZXQgZHJhd19tYXhpbXVtID0gMTA0TCBpblxuICBsZXQgcmVtYWluZGVyX21heGltdW0gPSA5TCBpblxuICBsZXQgaXNfdW5iaWFzZWQgZHJhdyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IEludDY0LnJlbSBkcmF3IChJbnQ2NC5zdWNjIHJlbWFpbmRlcl9tYXhpbXVtKSBpblxuICAgIHJlbWFpbmRlcl9pc191bmJpYXNlZCB+ZHJhdyB+cmVtYWluZGVyIH5kcmF3X21heGltdW0gfnJlbWFpbmRlcl9tYXhpbXVtXG4gIGluXG4gIGZvciBpID0gMCB0byA5OSBkb1xuICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAoaXNfdW5iaWFzZWQgKEludDY0Lm9mX2ludCBpKSlcbiAgICAgIH5leHBlY3Q6dHJ1ZVxuICAgICAgfm1lc3NhZ2U6KEludC50b19zdHJpbmcgaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAxMDAgdG8gMTA0IGRvXG4gICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgIChpc191bmJpYXNlZCAoSW50NjQub2ZfaW50IGkpKVxuICAgICAgfmV4cGVjdDpmYWxzZVxuICAgICAgfm1lc3NhZ2U6KEludC50b19zdHJpbmcgaSlcbiAgZG9uZVxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGJvdW5kZWQgcmFuZG9tbmVzcyBpcyBhZGFwdGVkIGZyb20gW1JhbmRvbS5TdGF0ZS5pbnQqXSBpbiB0aGVcbiAgIE9DYW1sIHN0YW5kYXJkIGxpYnJhcnkuICBUaGUgcHVycG9zZSBpcyB0byB1c2UgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNhbGxzIHRvXG4gICBbbmV4dF9pbnQ2NF0gdG8gcHJvZHVjZSBhIG51bWJlciB1bmlmb3JtbHkgY2hvc2VuIHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UuICopXG5sZXQgaW50NjQgPVxuICBsZXQgb3BlbiBJbnQ2NC5PIGluXG4gIGxldCByZWMgYmV0d2VlbiBzdGF0ZSB+bG8gfmhpID1cbiAgICBsZXQgZHJhdyA9IFN0YXRlLm5leHRfaW50NjQgc3RhdGUgaW5cbiAgICBpZiBsbyA8PSBkcmF3ICYmIGRyYXcgPD0gaGlcbiAgICB0aGVuIGRyYXdcbiAgICBlbHNlIGJldHdlZW4gc3RhdGUgfmxvIH5oaVxuICBpblxuICBsZXQgcmVjIG5vbl9uZWdhdGl2ZV91cF90byBzdGF0ZSBtYXhpbXVtID1cbiAgICBsZXQgZHJhdyA9IFN0YXRlLm5leHRfaW50NjQgc3RhdGUgbGFuZCBJbnQ2NC5tYXhfdmFsdWUgaW5cbiAgICBsZXQgcmVtYWluZGVyID0gSW50NjQucmVtIGRyYXcgKEludDY0LnN1Y2MgbWF4aW11bSkgaW5cbiAgICBpZiByZW1haW5kZXJfaXNfdW5iaWFzZWRcbiAgICAgICAgIH5kcmF3XG4gICAgICAgICB+cmVtYWluZGVyXG4gICAgICAgICB+ZHJhd19tYXhpbXVtOkludDY0Lm1heF92YWx1ZVxuICAgICAgICAgfnJlbWFpbmRlcl9tYXhpbXVtOm1heGltdW1cbiAgICB0aGVuIHJlbWFpbmRlclxuICAgIGVsc2Ugbm9uX25lZ2F0aXZlX3VwX3RvIHN0YXRlIG1heGltdW1cbiAgaW5cbiAgZnVuIHN0YXRlIH5sbyB+aGkgLT5cbiAgICBpZiBsbyA+IGhpIHRoZW4gYmVnaW5cbiAgICAgIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiaW50NjQ6IGNyb3NzZWQgYm91bmRzXCIgKGxvIDogaW50NjQpIChoaSA6IGludDY0KV1cbiAgICBlbmQ7XG4gICAgbGV0IGRpZmYgPSBoaSAtIGxvIGluXG4gICAgaWYgZGlmZiA9IEludDY0Lm1heF92YWx1ZVxuICAgIHRoZW4gKChTdGF0ZS5uZXh0X2ludDY0IHN0YXRlKSBsYW5kIEludDY0Lm1heF92YWx1ZSkgKyBsb1xuICAgIGVsc2UgaWYgZGlmZiA+PSAwTFxuICAgIHRoZW4gKG5vbl9uZWdhdGl2ZV91cF90byBzdGF0ZSBkaWZmKSArIGxvXG4gICAgZWxzZSBiZXR3ZWVuIHN0YXRlIH5sbyB+aGlcblxubGV0IGludCBzdGF0ZSB+bG8gfmhpID1cbiAgbGV0IGxvID0gSW50NjQub2ZfaW50IGxvIGluXG4gIGxldCBoaSA9IEludDY0Lm9mX2ludCBoaSBpblxuICAoKiB0cnVuY2F0ZSB1bm5lZWRlZCBiaXRzICopXG4gIEludDY0LnRvX2ludF90cnVuYyAoaW50NjQgc3RhdGUgfmxvIH5oaSlcblxubGV0IGludDMyIHN0YXRlIH5sbyB+aGkgPVxuICBsZXQgbG8gPSBJbnQ2NC5vZl9pbnQzMiBsbyBpblxuICBsZXQgaGkgPSBJbnQ2NC5vZl9pbnQzMiBoaSBpblxuICAoKiB0cnVuY2F0ZSB1bm5lZWRlZCBiaXRzICopXG4gIEludDY0LnRvX2ludDMyX3RydW5jIChpbnQ2NCBzdGF0ZSB+bG8gfmhpKVxuXG5sZXQgbmF0aXZlaW50IHN0YXRlIH5sbyB+aGkgPVxuICBsZXQgbG8gPSBJbnQ2NC5vZl9uYXRpdmVpbnQgbG8gaW5cbiAgbGV0IGhpID0gSW50NjQub2ZfbmF0aXZlaW50IGhpIGluXG4gICgqIHRydW5jYXRlIHVubmVlZGVkIGJpdHMgKilcbiAgSW50NjQudG9fbmF0aXZlaW50X3RydW5jIChpbnQ2NCBzdGF0ZSB+bG8gfmhpKVxuXG5sZXQgaW50NjMgc3RhdGUgfmxvIH5oaSA9XG4gIGxldCBsbyA9IEludDYzLnRvX2ludDY0IGxvIGluXG4gIGxldCBoaSA9IEludDYzLnRvX2ludDY0IGhpIGluXG4gICgqIHRydW5jYXRlIHVubmVlZGVkIGJpdHMgKilcbiAgSW50NjMub2ZfaW50NjRfdHJ1bmMgKGludDY0IHN0YXRlIH5sbyB+aGkpXG5cbmxldCBkb3VibGVfdWxwID0gMi4gKiouIC01My5cblxubGV0JXRlc3RfdW5pdCBcImRvdWJsZV91bHBcIiA9XG4gIGxldCBvcGVuIEZsb2F0Lk8gaW5cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+XG4gICAgYXNzZXJ0ICgxLjAgLS4gIGRvdWJsZV91bHAgICAgICAgICA8IDEuMCk7XG4gICAgYXNzZXJ0ICgxLjAgLS4gKGRvdWJsZV91bHAgLy4gMi4wKSA9IDEuMClcbiAgfCBXMzIgLT5cbiAgICAoKiAzMi1iaXQgT0NhbWwgdXNlcyBhIDY0LWJpdCBmbG9hdCByZXByZXNlbnRhdGlvbiBidXQgODAtYml0IGZsb2F0IGluc3RydWN0aW9ucywgc29cbiAgICAgICByb3VuZGluZyB3b3JrcyBkaWZmZXJlbnRseSBkdWUgdG8gdGhlIGNvbnZlcnNpb24gYmFjayBhbmQgZm9ydGguICopXG4gICAgYXNzZXJ0ICgxLjAgLS4gIGRvdWJsZV91bHAgICAgICAgICA8ICAxLjApO1xuICAgIGFzc2VydCAoMS4wIC0uIChkb3VibGVfdWxwIC8uIDIuMCkgPD0gMS4wKVxuXG5sZXQgdW5pdF9mbG9hdF9mcm9tX2ludDY0IGludDY0ID1cbiAgKEludDY0LnRvX2Zsb2F0IChpbnQ2NCBsc3IgMTEpKSAqLiBkb3VibGVfdWxwXG5cbmxldCV0ZXN0X3VuaXQgXCJ1bml0X2Zsb2F0X2Zyb21faW50NjRcIiA9IGJlZ2luXG4gIGxldCBvcGVuIEZsb2F0Lk8gaW5cbiAgYXNzZXJ0ICh1bml0X2Zsb2F0X2Zyb21faW50NjQgMHgwMDAwXzAwMDBfMDAwMF8wMDAwTCA9IDAuKTtcbiAgYXNzZXJ0ICh1bml0X2Zsb2F0X2Zyb21faW50NjQgMHhmZmZmX2ZmZmZfZmZmZl9mZmZmTCA8IDEuMCk7XG4gIGFzc2VydCAodW5pdF9mbG9hdF9mcm9tX2ludDY0IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZkwgPSAoMS4wIC0uIGRvdWJsZV91bHApKTtcbmVuZFxuXG5sZXQgdW5pdF9mbG9hdCBzdGF0ZSA9XG4gIHVuaXRfZmxvYXRfZnJvbV9pbnQ2NCAoU3RhdGUubmV4dF9pbnQ2NCBzdGF0ZSlcblxuKCogTm90ZSBhYm91dCByb3VuZG9mZiBlcnJvcjpcblxuICAgQWx0aG91Z2ggW2Zsb2F0IHN0YXRlIH5sbyB+aGldIGlzIG5vbWluYWxseSBpbmNsdXNpdmUgb2YgZW5kcG9pbnRzLCB3ZSBhcmUgcmVseWluZyBvblxuICAgdGhlIGZhY3QgdGhhdCBbdW5pdF9mbG9hdF0gbmV2ZXIgcmV0dXJucyAxLiwgYmVjYXVzZSB0aGVyZSBhcmUgcGFpcnMgWyhsbyxoaSldIGZvclxuICAgd2hpY2ggW2xvICsuIDEuICouIChoaSAtLiBsbykgPiBoaV0uICBUaGVyZSBhcmUgYWxzbyBwYWlycyBbKGxvLGhpKV0gYW5kIHZhbHVlcyBvZiBbeF1cbiAgIHdpdGggW3ggPCAxLl0gc3VjaCB0aGF0IFtsbyArLiB4ICouIChoaSAtLiBsbykgPSBoaV0sIHNvIGl0IHdvdWxkIG5vdCBiZSBjb3JyZWN0IHRvXG4gICBkb2N1bWVudCB0aGlzIGFzIGJlaW5nIGV4Y2x1c2l2ZSBvZiBbaGldLlxuKilcbmxldCBmbG9hdCA9XG4gIGxldCByZWMgZmluaXRlX2Zsb2F0IHN0YXRlIH5sbyB+aGkgPVxuICAgIGxldCByYW5nZSA9IGhpIC0uIGxvIGluXG4gICAgaWYgRmxvYXQuaXNfZmluaXRlIHJhbmdlXG4gICAgdGhlbiAobG8gKy4gKHVuaXRfZmxvYXQgc3RhdGUgKi4gcmFuZ2UpKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgICgqIElmIFtoaSAtIGxvXSBpcyBpbmZpbml0ZSwgdGhlbiBbaGkgKyBsb10gaXMgZmluaXRlIGJlY2F1c2UgW2hpXSBhbmQgW2xvXSBoYXZlXG4gICAgICAgICBvcHBvc2l0ZSBzaWducy4gKilcbiAgICAgIGxldCBtaWQgPSAoaGkgKy4gbG8pIC8uIDIuIGluXG4gICAgICBpZiBib29sIHN0YXRlXG4gICAgICAoKiBEZXBlbmRpbmcgb24gcm91bmRpbmcsIHRoZSByZWN1cnNpb24gd2l0aCBbfmhpOm1pZF0gbWlnaHQgYmUgaW5jbHVzaXZlIG9mIFttaWRdLFxuICAgICAgICAgd2hpY2ggd291bGQgbWVhbiB0aGUgdHdvIGNhc2VzIG92ZXJsYXAgb24gW21pZF0uIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byBpbmNyZW1lbnRcbiAgICAgICAgIG9yIGRlY3JlbWVudCBbbWlkXSB1c2luZyBbb25lX3VscF0gaW4gZWl0aGVyIG9mIHRoZSBjYWxscywgYnV0IHRoZW4gaWYgdGhlIGZpcnN0XG4gICAgICAgICBjYXNlIGlzIGV4Y2x1c2l2ZSB3ZSBsZWF2ZSBhIFwiZ2FwXCIgYmV0d2VlbiB0aGUgdHdvIHJhbmdlcy4gVGhlcmUncyBubyBwZXJmZWN0bHlcbiAgICAgICAgIHVuaWZvcm0gc29sdXRpb24sIHNvIHdlIHVzZSB0aGUgc2ltcGxlciBjb2RlIHRoYXQgZG9lcyBub3QgY2FsbCBbb25lX3VscF0uICopXG4gICAgICB0aGVuIGZpbml0ZV9mbG9hdCBzdGF0ZSB+bG8gfmhpOm1pZFxuICAgICAgZWxzZSBmaW5pdGVfZmxvYXQgc3RhdGUgfmxvOm1pZCB+aGlcbiAgICBlbmRcbiAgaW5cbiAgZnVuIHN0YXRlIH5sbyB+aGkgLT5cbiAgICBpZiBub3QgKEZsb2F0LmlzX2Zpbml0ZSBsbyAmJiBGbG9hdC5pc19maW5pdGUgaGkpXG4gICAgdGhlbiBiZWdpblxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2VcbiAgICAgICAgXCJmbG9hdDogYm91bmRzIGFyZSBub3QgZmluaXRlIG51bWJlcnNcIlxuICAgICAgICAgIChsbyA6IGZsb2F0KVxuICAgICAgICAgIChoaSA6IGZsb2F0KV1cbiAgICBlbmQ7XG4gICAgaWYgRmxvYXQuKCA+ICkgbG8gaGlcbiAgICB0aGVuIGJlZ2luXG4gICAgICByYWlzZV9zIFslbWVzc2FnZVxuICAgICAgICBcImZsb2F0OiBib3VuZHMgYXJlIGNyb3NzZWRcIlxuICAgICAgICAgIChsbyA6IGZsb2F0KVxuICAgICAgICAgIChoaSA6IGZsb2F0KV1cbiAgICBlbmQ7XG4gICAgZmluaXRlX2Zsb2F0IHN0YXRlIH5sbyB+aGlcblxubGV0JWJlbmNoX2Z1biBcInVuaXRfZmxvYXRfZnJvbV9pbnQ2NFwiID1cbiAgbGV0IGludDY0ID0gMUwgaW5cbiAgZnVuICgpIC0+IHVuaXRfZmxvYXRfZnJvbV9pbnQ2NCBpbnQ2NFxuXG5tb2R1bGUgTG9nX3VuaWZvcm0gPSBzdHJ1Y3RcbiAgbW9kdWxlIE1ha2UgKE0gOiBzaWcgaW5jbHVkZSBJbnQuUyB2YWwgdW5pZm9ybSA6IFN0YXRlLnQgLT4gbG86dCAtPiBoaTp0IC0+IHQgZW5kKSA6IHNpZ1xuICAgIHZhbCBsb2dfdW5pZm9ybSA6IFN0YXRlLnQgLT4gbG86TS50IC0+IGhpOk0udCAtPiBNLnRcbiAgZW5kID0gc3RydWN0XG4gICAgb3BlbiBNXG5cbiAgICBsZXQgYml0c190b19yZXByZXNlbnQgdCA9XG4gICAgICBhc3NlcnQgKHQgPj0gemVybyk7XG4gICAgICBsZXQgdCA9IHJlZiB0IGluXG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICB3aGlsZSAhdCA+IHplcm8gZG9cbiAgICAgICAgdCA6PSBzaGlmdF9yaWdodCAhdCAxO1xuICAgICAgICBJbnQuaW5jciBuO1xuICAgICAgZG9uZTtcbiAgICAgICFuXG5cbiAgICBsZXQldGVzdF91bml0IFwiYml0c190b19yZXByZXNlbnRcIiA9XG4gICAgICBsZXQgdGVzdCBuIGV4cGVjdCA9IFsldGVzdF9yZXN1bHQ6IGludF0gKGJpdHNfdG9fcmVwcmVzZW50IG4pIH5leHBlY3QgIGluXG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gMCkgICAwO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDEpICAgMTtcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biAyKSAgIDI7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gMykgICAyO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDQpICAgMztcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA1KSAgIDM7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gNikgICAzO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDcpICAgMztcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA4KSAgIDQ7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gMTAwKSA3O1xuICAgICAgdGVzdCBNLm1heF92YWx1ZSAoSW50LnByZWQgTS5udW1fYml0cyk7XG4gICAgOztcblxuICAgIGxldCBtaW5fcmVwcmVzZW50ZWRfYnlfbl9iaXRzIG4gPVxuICAgICAgaWYgSW50LmVxdWFsIG4gMFxuICAgICAgdGhlbiB6ZXJvXG4gICAgICBlbHNlIHNoaWZ0X2xlZnQgb25lIChJbnQucHJlZCBuKVxuXG4gICAgbGV0JXRlc3RfdW5pdCBcIm1pbl9yZXByZXNlbnRlZF9ieV9uX2JpdHNcIiA9XG4gICAgICBsZXQgdGVzdCBuIGV4cGVjdCA9IFsldGVzdF9yZXN1bHQ6IE0udF0gKG1pbl9yZXByZXNlbnRlZF9ieV9uX2JpdHMgbikgfmV4cGVjdCBpblxuICAgICAgdGVzdCAwIChNLm9mX2ludF9leG4gMCk7XG4gICAgICB0ZXN0IDEgKE0ub2ZfaW50X2V4biAxKTtcbiAgICAgIHRlc3QgMiAoTS5vZl9pbnRfZXhuIDIpO1xuICAgICAgdGVzdCAzIChNLm9mX2ludF9leG4gNCk7XG4gICAgICB0ZXN0IDQgKE0ub2ZfaW50X2V4biA4KTtcbiAgICAgIHRlc3QgNyAoTS5vZl9pbnRfZXhuIDY0KTtcbiAgICAgIHRlc3QgKEludC5wcmVkIE0ubnVtX2JpdHMpIChNLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgTS5taW5fdmFsdWUgMSk7XG4gICAgOztcblxuICAgIGxldCBtYXhfcmVwcmVzZW50ZWRfYnlfbl9iaXRzIG4gPVxuICAgICAgcHJlZCAoc2hpZnRfbGVmdCBvbmUgbilcblxuICAgIGxldCV0ZXN0X3VuaXQgXCJtYXhfcmVwcmVzZW50ZWRfYnlfbl9iaXRzXCIgPVxuICAgICAgbGV0IHRlc3QgbiBleHBlY3QgPSBbJXRlc3RfcmVzdWx0OiBNLnRdIChtYXhfcmVwcmVzZW50ZWRfYnlfbl9iaXRzIG4pIH5leHBlY3QgIGluXG4gICAgICB0ZXN0IDAgKE0ub2ZfaW50X2V4biAwKTtcbiAgICAgIHRlc3QgMSAoTS5vZl9pbnRfZXhuIDEpO1xuICAgICAgdGVzdCAyIChNLm9mX2ludF9leG4gMyk7XG4gICAgICB0ZXN0IDMgKE0ub2ZfaW50X2V4biA3KTtcbiAgICAgIHRlc3QgNCAoTS5vZl9pbnRfZXhuIDE1KTtcbiAgICAgIHRlc3QgNyAoTS5vZl9pbnRfZXhuIDEyNyk7XG4gICAgICB0ZXN0IChJbnQucHJlZCBNLm51bV9iaXRzKSBNLm1heF92YWx1ZTtcbiAgICA7O1xuXG4gICAgbGV0IGxvZ191bmlmb3JtIHN0YXRlIH5sbyB+aGkgPVxuICAgICAgbGV0IG1pbl9iaXRzID0gYml0c190b19yZXByZXNlbnQgbG8gaW5cbiAgICAgIGxldCBtYXhfYml0cyA9IGJpdHNfdG9fcmVwcmVzZW50IGhpIGluXG4gICAgICBsZXQgYml0cyA9IGludCBzdGF0ZSB+bG86bWluX2JpdHMgfmhpOm1heF9iaXRzIGluXG4gICAgICB1bmlmb3JtIHN0YXRlXG4gICAgICAgIH5sbzoobWluX3JlcHJlc2VudGVkX2J5X25fYml0cyBiaXRzIHw+IG1heCBsbylcbiAgICAgICAgfmhpOihtYXhfcmVwcmVzZW50ZWRfYnlfbl9iaXRzIGJpdHMgfD4gbWluIGhpKVxuICBlbmRcblxuICBtb2R1bGUgRm9yX2ludCAgICAgICA9IE1ha2UgKHN0cnVjdCBpbmNsdWRlIEludCAgICAgICBsZXQgdW5pZm9ybSA9IGludCAgICAgICBlbmQpXG4gIG1vZHVsZSBGb3JfaW50MzIgICAgID0gTWFrZSAoc3RydWN0IGluY2x1ZGUgSW50MzIgICAgIGxldCB1bmlmb3JtID0gaW50MzIgICAgIGVuZClcbiAgbW9kdWxlIEZvcl9pbnQ2MyAgICAgPSBNYWtlIChzdHJ1Y3QgaW5jbHVkZSBJbnQ2MyAgICAgbGV0IHVuaWZvcm0gPSBpbnQ2MyAgICAgZW5kKVxuICBtb2R1bGUgRm9yX2ludDY0ICAgICA9IE1ha2UgKHN0cnVjdCBpbmNsdWRlIEludDY0ICAgICBsZXQgdW5pZm9ybSA9IGludDY0ICAgICBlbmQpXG4gIG1vZHVsZSBGb3JfbmF0aXZlaW50ID0gTWFrZSAoc3RydWN0IGluY2x1ZGUgTmF0aXZlaW50IGxldCB1bmlmb3JtID0gbmF0aXZlaW50IGVuZClcblxuICBsZXQgaW50ICAgICAgID0gRm9yX2ludC5sb2dfdW5pZm9ybVxuICBsZXQgaW50MzIgICAgID0gRm9yX2ludDMyLmxvZ191bmlmb3JtXG4gIGxldCBpbnQ2MyAgICAgPSBGb3JfaW50NjMubG9nX3VuaWZvcm1cbiAgbGV0IGludDY0ICAgICA9IEZvcl9pbnQ2NC5sb2dfdW5pZm9ybVxuICBsZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybVxuZW5kXG5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgb3BlcmF0aW9ucyBvbiB0aGUgdHlwZSBbaW50NjRdIG9mXG4gICBzaWduZWQgNjQtYml0IGludGVnZXJzLiAgVW5saWtlIHRoZSBidWlsdC1pbiBbaW50XSB0eXBlLFxuICAgdGhlIHR5cGUgW2ludDY0XSBpcyBndWFyYW50ZWVkIHRvIGJlIGV4YWN0bHkgNjQtYml0IHdpZGUgb24gYWxsXG4gICBwbGF0Zm9ybXMuICBBbGwgYXJpdGhtZXRpYyBvcGVyYXRpb25zIG92ZXIgW2ludDY0XSBhcmUgdGFrZW5cbiAgIG1vZHVsbyAye142NH1cblxuICAgUGVyZm9ybWFuY2Ugbm90aWNlOiB2YWx1ZXMgb2YgdHlwZSBbaW50NjRdIG9jY3VweSBtb3JlIG1lbW9yeVxuICAgc3BhY2UgdGhhbiB2YWx1ZXMgb2YgdHlwZSBbaW50XSwgYW5kIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvblxuICAgW2ludDY0XSBhcmUgZ2VuZXJhbGx5IHNsb3dlciB0aGFuIHRob3NlIG9uIFtpbnRdLiAgVXNlIFtpbnQ2NF1cbiAgIG9ubHkgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVxdWlyZXMgZXhhY3QgNjQtYml0IGFyaXRobWV0aWMuXG5cbiAgICBMaXRlcmFscyBmb3IgNjQtYml0IGludGVnZXJzIGFyZSBzdWZmaXhlZCBieSBMOlxuICAgIHtbXG4gICAgICBsZXQgemVybzogaW50NjQgPSAwTFxuICAgICAgbGV0IG9uZTogaW50NjQgPSAxTFxuICAgICAgbGV0IG1fb25lOiBpbnQ2NCA9IC0xTFxuICAgIF19XG4qKVxuXG52YWwgemVybyA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIDAuICopXG5cbnZhbCBvbmUgOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAxLiAqKVxuXG52YWwgbWludXNfb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgLTEuICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbigqKiBVbmFyeSBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuKCoqIEFkZGl0aW9uLiAqKVxuXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG4oKiogU3VidHJhY3Rpb24uICopXG5cbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbigqKiBNdWx0aXBsaWNhdGlvbi4gKilcblxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuKCoqIEludGVnZXIgZGl2aXNpb24uXG4gICBAcmFpc2UgRGl2aXNpb25fYnlfemVybyBpZiB0aGUgc2Vjb25kXG4gICBhcmd1bWVudCBpcyB6ZXJvLiAgVGhpcyBkaXZpc2lvbiByb3VuZHMgdGhlIHJlYWwgcXVvdGllbnQgb2ZcbiAgIGl0cyBhcmd1bWVudHMgdG93YXJkcyB6ZXJvLCBhcyBzcGVjaWZpZWQgZm9yIHshU3RkbGliLigvKX0uICopXG5cbnZhbCB1bnNpZ25lZF9kaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFkaXZ9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCByZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X21vZFwiXG4oKiogSW50ZWdlciByZW1haW5kZXIuICBJZiBbeV0gaXMgbm90IHplcm8sIHRoZSByZXN1bHRcbiAgIG9mIFtJbnQ2NC5yZW0geCB5XSBzYXRpc2ZpZXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAgIFt4ID0gSW50NjQuYWRkIChJbnQ2NC5tdWwgKEludDY0LmRpdiB4IHkpIHkpIChJbnQ2NC5yZW0geCB5KV0uXG4gICBJZiBbeSA9IDBdLCBbSW50NjQucmVtIHggeV0gcmFpc2VzIFtEaXZpc2lvbl9ieV96ZXJvXS4gKilcblxudmFsIHVuc2lnbmVkX3JlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0XG4oKiogU2FtZSBhcyB7IXJlbX0sIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhbmQgcmVzdWx0IGFyZSBpbnRlcnByZXRlZCBhcyB7ZVxuICAgIHVuc2lnbmVkfSA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbnZhbCBzdWNjIDogaW50NjQgLT4gaW50NjRcbigqKiBTdWNjZXNzb3IuICBbSW50NjQuc3VjYyB4XSBpcyBbSW50NjQuYWRkIHggSW50NjQub25lXS4gKilcblxudmFsIHByZWQgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFByZWRlY2Vzc29yLiAgW0ludDY0LnByZWQgeF0gaXMgW0ludDY0LnN1YiB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBhYnMgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgaXRzIGFyZ3VtZW50LiAqKVxuXG52YWwgbWF4X2ludCA6IGludDY0XG4oKiogVGhlIGdyZWF0ZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIDJ7XjYzfSAtIDEuICopXG5cbnZhbCBtaW5faW50IDogaW50NjRcbigqKiBUaGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSA2NC1iaXQgaW50ZWdlciwgLTJ7XjYzfS4gKilcblxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBhbmQuICopXG5cbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIG9yLiAqKVxuXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIGV4Y2x1c2l2ZSBvci4gKilcblxudmFsIGxvZ25vdCA6IGludDY0IC0+IGludDY0XG4oKiogQml0d2lzZSBsb2dpY2FsIG5lZ2F0aW9uLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbigqKiBbSW50NjQuc2hpZnRfbGVmdCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIGxlZnQgYnkgW3ldIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0IHggeV0gc2hpZnRzIFt4XSB0byB0aGUgcmlnaHQgYnkgW3ldIGJpdHMuXG4gICBUaGlzIGlzIGFuIGFyaXRobWV0aWMgc2hpZnQ6IHRoZSBzaWduIGJpdCBvZiBbeF0gaXMgcmVwbGljYXRlZFxuICAgYW5kIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbigqKiBbSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhIGxvZ2ljYWwgc2hpZnQ6IHplcm9lcyBhcmUgaW5zZXJ0ZWQgaW4gdGhlIHZhY2F0ZWQgYml0c1xuICAgcmVnYXJkbGVzcyBvZiB0aGUgc2lnbiBvZiBbeF0uXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGludGVnZXIgKHR5cGUgW2ludF0pIHRvIGEgNjQtYml0IGludGVnZXJcbiAgICAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhblxuICAgaW50ZWdlciAodHlwZSBbaW50XSkuICBPbiA2NC1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye142M30sIGkuZS4gdGhlIGhpZ2gtb3JkZXIgYml0IGlzIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMxfSwgaS5lLiB0aGUgdG9wIDMzIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gKilcblxudmFsIHVuc2lnbmVkX3RvX2ludCA6IGludDY0IC0+IGludCBvcHRpb25cbigqKiBTYW1lIGFzIHshdG9faW50fSwgYnV0IGludGVycHJldHMgdGhlIGFyZ3VtZW50IGFzIGFuIHtlIHVuc2lnbmVkfSBpbnRlZ2VyLlxuICAgIFJldHVybnMgW05vbmVdIGlmIHRoZSB1bnNpZ25lZCB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgY2Fubm90IGZpdCBpbnRvIGFuXG4gICAgW2ludF0uXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvIGEgNjQtYml0IGludGVnZXIsXG4gICBkaXNjYXJkaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgKHRydW5jYXRlIHRvd2FyZHMgMCkuXG4gICBJZiB0aGUgdHJ1bmNhdGVkIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyBvdXRzaWRlIHRoZSByYW5nZVxuICAgXFxbeyFJbnQ2NC5taW5faW50fSwgeyFJbnQ2NC5tYXhfaW50fVxcXSwgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZCwgYW5kXG4gICBhbiB1bnNwZWNpZmllZCwgcGxhdGZvcm0tZGVwZW5kZW50IGludGVnZXIgaXMgcmV0dXJuZWQuICopXG5cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuICopXG5cblxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKS4gVGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LCBpLmUuIHRoZSB0b3AgMzIgYml0cyBhcmUgbG9zdFxuICAgZHVyaW5nIHRoZSBjb252ZXJzaW9uLiAgKilcblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBuYXRpdmUgaW50ZWdlciAodHlwZSBbbmF0aXZlaW50XSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgbmF0aXZlIGludGVnZXIuICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0uICBPbiA2NC1iaXQgcGxhdGZvcm1zLFxuICAgdGhlIGNvbnZlcnNpb24gaXMgZXhhY3QuICopXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBhIDY0LWJpdCBpbnRlZ2VyLlxuICAgVGhlIHN0cmluZyBpcyByZWFkIGluIGRlY2ltYWwgKGJ5IGRlZmF1bHQsIG9yIGlmIHRoZSBzdHJpbmdcbiAgIGJlZ2lucyB3aXRoIFswdV0pIG9yIGluIGhleGFkZWNpbWFsLCBvY3RhbCBvciBiaW5hcnkgaWYgdGhlXG4gICBzdHJpbmcgYmVnaW5zIHdpdGggWzB4XSwgWzBvXSBvciBbMGJdIHJlc3BlY3RpdmVseS5cblxuICAgVGhlIFswdV0gcHJlZml4IHJlYWRzIHRoZSBpbnB1dCBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgW1swLCAyKkludDY0Lm1heF9pbnQrMV1dLiAgSWYgdGhlIGlucHV0IGV4Y2VlZHMgeyFJbnQ2NC5tYXhfaW50fVxuICAgaXQgaXMgY29udmVydGVkIHRvIHRoZSBzaWduZWQgaW50ZWdlclxuICAgW0ludDY0Lm1pbl9pbnQgKyBpbnB1dCAtIEludDY0Lm1heF9pbnQgLSAxXS5cblxuICAgVGhlIFtfXSAodW5kZXJzY29yZSkgY2hhcmFjdGVyIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgYW5kIGlzIGlnbm9yZWQuXG4gICBAcmFpc2UgRmFpbHVyZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdFxuICAgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCBvciBpZiB0aGUgaW50ZWdlciByZXByZXNlbnRlZFxuICAgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgcmVwcmVzZW50YWJsZSBpbiB0eXBlIFtpbnQ2NF0uICopXG5cbnZhbCBvZl9zdHJpbmdfb3B0OiBzdHJpbmcgLT4gaW50NjQgb3B0aW9uXG4oKiogU2FtZSBhcyBbb2Zfc3RyaW5nXSwgYnV0IHJldHVybiBbTm9uZV0gaW5zdGVhZCBvZiByYWlzaW5nLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCB0b19zdHJpbmcgOiBpbnQ2NCAtPiBzdHJpbmdcbigqKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQsIGluIGRlY2ltYWwuICopXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXQgYWNjb3JkaW5nXG4gICB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQuXG4gICBCaXQgNjMgb2YgdGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzaWduIG9mIHRoZSBmbG9hdDtcbiAgIGJpdHMgNjIgdG8gNTIgcmVwcmVzZW50IHRoZSAoYmlhc2VkKSBleHBvbmVudDsgYml0cyA1MSB0byAwXG4gICByZXByZXNlbnQgdGhlIG1hbnRpc3NhLiAqKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdob3NlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLFxuICAgYWNjb3JkaW5nIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dCxcbiAgIGlzIHRoZSBnaXZlbiBbaW50NjRdLiAqKVxuXG50eXBlIHQgPSBpbnQ2NFxuKCoqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiA2NC1iaXQgaW50ZWdlcnMuICopXG5cbnZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRlZ2Vycywgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uIGFzXG4gICAgeyFTdGRsaWIuY29tcGFyZX0uICBBbG9uZyB3aXRoIHRoZSB0eXBlIFt0XSwgdGhpcyBmdW5jdGlvbiBbY29tcGFyZV1cbiAgICBhbGxvd3MgdGhlIG1vZHVsZSBbSW50NjRdIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgZnVuY3RvcnNcbiAgICB7IVNldC5NYWtlfSBhbmQgeyFNYXAuTWFrZX0uICopXG5cbnZhbCB1bnNpZ25lZF9jb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogU2FtZSBhcyB7IWNvbXBhcmV9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGludGVycHJldGVkIGFzIHtlIHVuc2lnbmVkfVxuICAgIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzLjAgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIG1heDogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuICopXG5cbigqKi8qKilcblxuKCoqIHsxIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5bQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlIFByaW50Zi5zcHJpbnRmIHdpdGggYSBbJUwuLi5dIGZvcm1hdCBpbnN0ZWFkLlwiXVxuKCoqIERvIG5vdCB1c2UgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uLiAgSW5zdGVhZCxcbiAgIHVzZWQgeyFQcmludGYuc3ByaW50Zn0gd2l0aCBhIFslTC4uLl0gZm9ybWF0LiAqKVxuIl19
