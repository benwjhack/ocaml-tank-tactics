// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     flags=[0,0,0],
     cst=caml_string_of_jsbytes("\n"),
     flags$0=[0,1,[0,3,0]],
     Base_List=global_data.Base__List,
     Caml=global_data.Caml,
     Base_Char=global_data.Base__Char,
     Base_String=global_data.Base__String,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Base_Buffer=global_data.Base__Buffer,
     Stdlib=global_data.Stdlib,
     Base_Exn=global_data.Base__Exn,
     Base=global_data.Base,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdio=[0];
    caml_register_global(6,Stdio,"Stdio__");
    var
     _a_=[0,caml_string_of_jsbytes("<stderr>")],
     _b_=[0,caml_string_of_jsbytes("<stdout>")],
     _c_=[0,caml_string_of_jsbytes("<Out_channel.t>")];
    function equal(t1,t2){return caml_call2(Base[203],t1,t2)}
    var seek=Caml[96][4],pos=Caml[96][5],length=Caml[96][6],stdin=Caml[38];
    function create(opt,file)
     {if(opt)var sth=opt[1],binary=sth;else var binary=1;
      var flags$0=binary?[0,6,flags]:flags;
      return caml_call3(Caml[81],flags$0,0,file)}
    var close=Caml[93];
    function with_file(binary,file,f)
     {var _t_=create(binary,file);return caml_call3(Base_Exn[12],f,_t_,close)}
    function may_eof(f)
     {try
       {var _r_=[0,caml_call1(f,0)];return _r_}
      catch(_s_)
       {_s_ = caml_wrap_exception(_s_);
        if(_s_ === Stdlib[12])return 0;
        throw _s_}}
    function input(t,buf,pos,len){return caml_call4(Caml[84],t,buf,pos,len)}
    function really_input(t,buf,pos,len)
     {return may_eof
              (function(param){return caml_call4(Caml[85],t,buf,pos,len)})}
    function really_input_exn(t,buf,pos,len)
     {return caml_call4(Caml[85],t,buf,pos,len)}
    function input_byte(t)
     {return may_eof(function(param){return caml_call1(Caml[87],t)})}
    function input_char(t)
     {return may_eof(function(param){return caml_call1(Caml[82],t)})}
    function input_binary_int(t)
     {return may_eof(function(param){return caml_call1(Caml[88],t)})}
    function unsafe_input_value(t)
     {return may_eof(function(param){return caml_call1(Caml[89],t)})}
    function input_buffer(t,buf,len)
     {return may_eof
              (function(param){return caml_call3(Stdlib_Buffer[22],buf,t,len)})}
    var set_binary_mode=Caml[95];
    function input_all(t)
     {var buffer=caml_call1(Base_Buffer[2],65536),chunk_size=65536;
      function loop(param)
       {for(;;)caml_call3(Stdlib_Buffer[22],buffer,t,chunk_size)}
      try
       {var _p_=loop(0);return _p_}
      catch(_q_)
       {_q_ = caml_wrap_exception(_q_);
        if(_q_ === Stdlib[12])return caml_call1(Base_Buffer[3],buffer);
        throw _q_}}
    function trim(fix_win_eol,line)
     {if(! fix_win_eol)return line;
      var len=runtime.caml_ml_string_length(line);
      if(0 < len)
       {var _o_=runtime.caml_string_get(line,len - 1 | 0);
        if(caml_call2(Base_Char[15],_o_,13))
         return caml_call3(Base_String[2],line,0,len - 1 | 0)}
      return line}
    function input_line(opt,t)
     {if(opt)var sth=opt[1],fix_win_eol=sth;else var fix_win_eol=1;
      var match=may_eof(function(param){return caml_call1(Caml[83],t)});
      if(! match)return 0;
      var line=match[1];
      return [0,trim(fix_win_eol,line)]}
    function input_line_exn(opt,t)
     {if(opt)var sth=opt[1],fix_win_eol=sth;else var fix_win_eol=1;
      var line=caml_call1(Caml[83],t);
      return trim(fix_win_eol,line)}
    function fold_lines(fix_win_eol,t,ac,f)
     {var ac$0=ac;
      for(;;)
       {var match=input_line(fix_win_eol,t);
        if(! match)return ac$0;
        var line=match[1],ac$1=caml_call2(f,ac$0,line),ac$0=ac$1}}
    function input_lines(fix_win_eol,t)
     {var
       _n_=
        fold_lines
         (fix_win_eol,t,0,function(lines,line){return [0,line,lines]});
      return caml_call1(Base_List[38],_n_)}
    function iter_lines(fix_win_eol,t,f)
     {return fold_lines
              (fix_win_eol,
               t,
               0,
               function(param,line){return caml_call1(f,line)})}
    function read_lines(fix_win_eol,fname)
     {return with_file
              (0,fname,function(_m_){return input_lines(fix_win_eol,_m_)})}
    function read_all(fname){return with_file(0,fname,input_all)}
    var
     Stdio_In_channel=
      [0,
       equal,
       stdin,
       create,
       with_file,
       close,
       input,
       really_input,
       really_input_exn,
       input_char,
       input_byte,
       input_binary_int,
       unsafe_input_value,
       input_buffer,
       input_all,
       input_line,
       input_line_exn,
       fold_lines,
       input_lines,
       iter_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       read_lines,
       read_all];
    caml_register_global(16,Stdio_In_channel,"Stdio__In_channel");
    function equal$0(t1,t2){return caml_call2(Base[203],t1,t2)}
    var
     seek$0=Caml[96][1],
     pos$0=Caml[96][2],
     length$0=Caml[96][3],
     stdout=Caml[39],
     stderr=Caml[40];
    function sexp_of_t(t)
     {return caml_call2(Base[203],t,stderr)
              ?_a_
              :caml_call2(Base[203],t,stdout)?_b_:_c_}
    function create$0(opt,_j_,_i_,_h_,file)
     {if(opt)var sth=opt[1],binary=sth;else var binary=1;
      if(_j_)var sth$0=_j_[1],append=sth$0;else var append=0;
      if(_i_)var sth$1=_i_[1],fail_if_exists=sth$1;else var fail_if_exists=0;
      if(_h_)var sth$2=_h_[1],perm=sth$2;else var perm=438;
      var
       _k_=binary?6:7,
       flags=[0,_k_,flags$0],
       _l_=append?2:4,
       flags$1=[0,_l_,flags],
       flags$2=fail_if_exists?[0,5,flags$1]:flags$1;
      return caml_call3(Caml[62],flags$2,perm,file)}
    var
     set_binary_mode$0=Caml[78],
     flush=Caml[63],
     close$0=Caml[76],
     close_no_err=Caml[77];
    function output(t,buf,pos,len){return caml_call4(Caml[68],t,buf,pos,len)}
    function output_substring(t,buf,pos,len)
     {return caml_call4(Caml[69],t,buf,pos,len)}
    var
     output_string=Caml[66],
     output_bytes=Caml[67],
     output_char=Caml[65],
     output_byte=Caml[70],
     output_binary_int=Caml[71],
     output_buffer=Stdlib_Buffer[10],
     output_value=Caml[72];
    function newline(t){return caml_call2(output_string,t,cst)}
    function output_lines(t,lines)
     {function _g_(line){caml_call2(output_string,t,line);return newline(t)}
      return caml_call2(Base_List[9],lines,_g_)}
    var
     printf=Stdlib_Printf[2],
     eprintf=Stdlib_Printf[3],
     fprintf=Stdlib_Printf[1],
     kfprintf=Stdlib_Printf[8],
     print_string=Caml[42],
     print_endline=Caml[46],
     prerr_endline=Caml[53];
    function print_s(mach,sexp)
     {var
       _f_=
        mach?caml_call1(Base[84][14],sexp):caml_call2(Base[84][13],0,sexp);
      return caml_call1(print_endline,_f_)}
    function eprint_s(mach,sexp)
     {var
       _e_=
        mach?caml_call1(Base[84][14],sexp):caml_call2(Base[84][13],0,sexp);
      return caml_call1(prerr_endline,_e_)}
    function with_file$0(binary,append,fail_if_exists,perm,file,f)
     {var _d_=create$0(binary,append,fail_if_exists,perm,file);
      return caml_call3(Base_Exn[12],f,_d_,close$0)}
    function write_lines(file,lines)
     {return with_file$0
              (0,0,0,0,file,function(t){return output_lines(t,lines)})}
    function write_all(file,data)
     {return with_file$0
              (0,
               0,
               0,
               0,
               file,
               function(t){return caml_call2(output_string,t,data)})}
    var
     Stdio_Out_channel=
      [0,
       sexp_of_t,
       equal$0,
       stdout,
       stderr,
       create$0,
       with_file$0,
       close$0,
       close_no_err,
       set_binary_mode$0,
       flush,
       output,
       output_string,
       output_substring,
       output_bytes,
       output_char,
       output_byte,
       output_binary_int,
       output_buffer,
       output_value,
       newline,
       output_lines,
       fprintf,
       printf,
       print_s,
       eprint_s,
       eprintf,
       kfprintf,
       print_string,
       print_endline,
       prerr_endline,
       seek$0,
       pos$0,
       length$0,
       write_lines,
       write_all];
    caml_register_global(18,Stdio_Out_channel,"Stdio__Out_channel");
    var
     Stdio$0=
      [0,
       stdin,
       stdout,
       stderr,
       printf,
       print_s,
       eprint_s,
       eprintf,
       print_string,
       print_endline,
       prerr_endline];
    caml_register_global(19,Stdio$0,"Stdio");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRpby5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZmxhZ3MiLCJmbGFncyQwIiwiZXF1YWwiLCJ0MSIsInQyIiwic2VlayIsInBvcyIsImxlbmd0aCIsImNyZWF0ZSIsIm9wdCIsImZpbGUiLCJzdGgiLCJiaW5hcnkiLCJjbG9zZSIsIndpdGhfZmlsZSIsImYiLCJtYXlfZW9mIiwiaW5wdXQiLCJ0IiwiYnVmIiwibGVuIiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X2V4biIsImlucHV0X2J5dGUiLCJpbnB1dF9jaGFyIiwiaW5wdXRfYmluYXJ5X2ludCIsInVuc2FmZV9pbnB1dF92YWx1ZSIsImlucHV0X2J1ZmZlciIsInNldF9iaW5hcnlfbW9kZSIsImlucHV0X2FsbCIsImJ1ZmZlciIsImNodW5rX3NpemUiLCJsb29wIiwidHJpbSIsImZpeF93aW5fZW9sIiwibGluZSIsImlucHV0X2xpbmUiLCJpbnB1dF9saW5lX2V4biIsImZvbGRfbGluZXMiLCJhYyIsImFjJDAiLCJhYyQxIiwiaW5wdXRfbGluZXMiLCJsaW5lcyIsIml0ZXJfbGluZXMiLCJyZWFkX2xpbmVzIiwiZm5hbWUiLCJyZWFkX2FsbCIsImVxdWFsJDAiLCJzZWVrJDAiLCJwb3MkMCIsImxlbmd0aCQwIiwic2V4cF9vZl90IiwiY3JlYXRlJDAiLCJzdGgkMCIsImFwcGVuZCIsInN0aCQxIiwiZmFpbF9pZl9leGlzdHMiLCJzdGgkMiIsInBlcm0iLCJmbGFncyQxIiwiZmxhZ3MkMiIsInNldF9iaW5hcnlfbW9kZSQwIiwiZmx1c2giLCJjbG9zZSQwIiwiY2xvc2Vfbm9fZXJyIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnVmZmVyIiwib3V0cHV0X3ZhbHVlIiwibmV3bGluZSIsIm91dHB1dF9saW5lcyIsImZwcmludGYiLCJrZnByaW50ZiIsIm1hY2giLCJzZXhwIiwid2l0aF9maWxlJDAiLCJ3cml0ZV9saW5lcyIsIndyaXRlX2FsbCIsImRhdGEiXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvc3RkaW8vaW5fY2hhbm5lbC5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9zdGRpby9vdXRfY2hhbm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FXTUE7O0tDa0JBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7YUR6QkZDLE1BQU9DLEdBQVFDLElBQUssNEJBQWJELEdBQVFDLEdBQXFCO1FBQ3BDQyxpQkFDQUMsZ0JBQ0FDO2FBR0FDLE9BQVNDLElBQWVDO01BQzFCLEdBRFdELElBQVMsUUFBVEEsY0FBU0UsYUFBVEM7TUFDWCxJQUNJWCxRQUZPVyxZQUNQWjtNQUVKLDJCQURJQyxVQUZzQlMsS0FHTztRQUcvQkc7YUFDQUMsVUFBV0YsT0FBT0YsS0FBTUs7TUFBaUIsUUFQekNQLE9BT1dJLE9BQU9GLE1BQXVCLCtCQUFqQkssTUFEeEJGLE1BQ2dGO2FBRWhGRyxRQUFRRDtNO1FBQ0Qsc0JBRENBOzs7OEJBRU87a0JBQUk7YUFHbkJFLE1BQU1DLEVBQUdDLElBQUtiLElBQUtjLEtBQU0sMkJBQW5CRixFQUFHQyxJQUFLYixJQUFLYyxJQUE4QjthQUNqREMsYUFBYUgsRUFBR0MsSUFBS2IsSUFBS2M7TUFBTSxPQU5oQ0o7K0JBTW1ELDJCQUF0Q0UsRUFBR0MsSUFBS2IsSUFBS2MsSUFBd0QsRUFBQzthQUNuRkUsaUJBQWlCSixFQUFHQyxJQUFLYixJQUFLYztNQUFNLDJCQUFuQkYsRUFBR0MsSUFBS2IsSUFBS2MsSUFBcUM7YUFDbkVHLFdBQVdMO01BQUksT0FSZkYsd0JBUWtDLDJCQUF2QkUsRUFBd0MsRUFBQzthQUNwRE0sV0FBV047TUFBSSxPQVRmRix3QkFTa0MsMkJBQXZCRSxFQUF3QyxFQUFDO2FBQ3BETyxpQkFBaUJQO01BQUksT0FWckJGLHdCQVV3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QUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7YUFDQUMsUUFBUXpELEdBQUksa0JBUFprRCxjQU9RbEQsTUFBd0I7YUFFaEMwRCxhQUFhMUQsRUFBRXlCO01BQ2pCLGFBQXdCUixNQUN0QixXQVhBaUMsY0FTYWxELEVBQ1NpQixNQUN0QixPQUpBd0MsUUFFYXpELEVBR0o7TUFGWCwrQkFEaUJ5QixVQUdMOzs7O0tBS1ZrQztLQUNBQzs7OztxQkFLU0MsS0FBS0M7TUFDaEI7O1FBRFdELEtBR0ssd0JBSEFDLE1BSUgsMEJBSkdBO01BSW9CLG9DQUFDO3NCQUd6QkQsS0FBS0M7TUFDakI7O1FBRFlELEtBR0ksd0JBSENDLE1BSUosMEJBSklBO01BSW1CLG9DQUFDO2FBR25DQyxZQUFXckUsT0FBUTJDLE9BQVFFLGVBQWdCRSxLQUFLakQsS0FBTUs7TUFDM0MsUUExRFhzQyxTQXlEV3pDLE9BQVEyQyxPQUFRRSxlQUFnQkUsS0FBS2pEO01BQ3JDLCtCQUQyQ0ssTUF6Q3REaUQsUUEwQ2dGO2FBR2hGa0IsWUFBWXhFLEtBQUtpQztNQUFRLE9BSnpCc0M7dUJBSVl2RSxjQUFvQ1EsR0FBSyxPQWhDckQwRCxhQWdDZ0QxRCxFQUEvQnlCLE1BQXdELEVBQUM7YUFDMUV3QyxVQUFVekUsS0FBTTBFO01BQU8sT0FMdkJIOzs7OztlQUtVdkU7d0JBQW9DUSxHQUFLLGtCQTFDbkRrRCxjQTBDOENsRCxFQUE5QmtFLEtBQXVELEVBQUM7Ozs7T0F6RXhFaEM7T0FQQUo7OztPQWtCQUs7T0F5REE0QjtPQXpDQWpCO09BQ0FDO09BSEFIO09BQ0FDO09BR0FHO09BRUFFO09BREFEO09BRUFFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BUUFDOzs7OztPQUNBQzs7OztPQXZEQTdCO09BQ0FDO09BQ0FDO09BNEVBK0I7T0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7VSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2VcblxudHlwZSB0ID0gQ2FtbC5pbl9jaGFubmVsXG5cbmxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBzZWVrID0gQ2FtbC5MYXJnZUZpbGUuc2Vla19pblxubGV0IHBvcyA9IENhbWwuTGFyZ2VGaWxlLnBvc19pblxubGV0IGxlbmd0aCA9IENhbWwuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgc3RkaW4gPSBDYW1sLnN0ZGluXG5cbmxldCBjcmVhdGUgPyhiaW5hcnkgPSB0cnVlKSBmaWxlID1cbiAgbGV0IGZsYWdzID0gWyBPcGVuX3Jkb25seSBdIGluXG4gIGxldCBmbGFncyA9IGlmIGJpbmFyeSB0aGVuIE9wZW5fYmluYXJ5IDo6IGZsYWdzIGVsc2UgZmxhZ3MgaW5cbiAgQ2FtbC5vcGVuX2luX2dlbiBmbGFncyAwbzAwMCBmaWxlXG47O1xuXG5sZXQgY2xvc2UgPSBDYW1sLmNsb3NlX2luXG5sZXQgd2l0aF9maWxlID9iaW5hcnkgZmlsZSB+ZiA9IEV4bi5wcm90ZWN0eCAoY3JlYXRlID9iaW5hcnkgZmlsZSkgfmYgfmZpbmFsbHk6Y2xvc2VcblxubGV0IG1heV9lb2YgZiA9XG4gIHRyeSBTb21lIChmICgpKSB3aXRoXG4gIHwgRW5kX29mX2ZpbGUgLT4gTm9uZVxuOztcblxubGV0IGlucHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBDYW1sLmlucHV0IHQgYnVmIHBvcyBsZW5cbmxldCByZWFsbHlfaW5wdXQgdCB+YnVmIH5wb3MgfmxlbiA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLnJlYWxseV9pbnB1dCB0IGJ1ZiBwb3MgbGVuKVxubGV0IHJlYWxseV9pbnB1dF9leG4gdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwucmVhbGx5X2lucHV0IHQgYnVmIHBvcyBsZW5cbmxldCBpbnB1dF9ieXRlIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9ieXRlIHQpXG5sZXQgaW5wdXRfY2hhciB0ID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfY2hhciB0KVxubGV0IGlucHV0X2JpbmFyeV9pbnQgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X2JpbmFyeV9pbnQgdClcbmxldCB1bnNhZmVfaW5wdXRfdmFsdWUgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X3ZhbHVlIHQpXG5sZXQgaW5wdXRfYnVmZmVyIHQgYnVmIH5sZW4gPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5CdWZmZXIuYWRkX2NoYW5uZWwgYnVmIHQgbGVuKVxubGV0IHNldF9iaW5hcnlfbW9kZSA9IENhbWwuc2V0X2JpbmFyeV9tb2RlX2luXG5cbmxldCBpbnB1dF9hbGwgdCA9XG4gICgqIFdlIHVzZSA2NTUzNiBiZWNhdXNlIHRoYXQgaXMgdGhlIHNpemUgb2YgT0NhbWwncyBJTyBidWZmZXJzLiAqKVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluXG4gIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIGNodW5rX3NpemUgaW5cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBDYW1sLkJ1ZmZlci5hZGRfY2hhbm5lbCBidWZmZXIgdCBjaHVua19zaXplO1xuICAgIGxvb3AgKClcbiAgaW5cbiAgdHJ5IGxvb3AgKCkgd2l0aFxuICB8IEVuZF9vZl9maWxlIC0+IEJ1ZmZlci5jb250ZW50cyBidWZmZXJcbjs7XG5cbmxldCB0cmltIH5maXhfd2luX2VvbCBsaW5lID1cbiAgaWYgZml4X3dpbl9lb2xcbiAgdGhlbiAoXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggbGluZSBpblxuICAgIGlmIGxlbiA+IDAgJiYgQ2hhci5lcXVhbCAoU3RyaW5nLmdldCBsaW5lIChsZW4gLSAxKSkgJ1xccidcbiAgICB0aGVuIFN0cmluZy5zdWIgbGluZSB+cG9zOjAgfmxlbjoobGVuIC0gMSlcbiAgICBlbHNlIGxpbmUpXG4gIGVsc2UgbGluZVxuOztcblxubGV0IGlucHV0X2xpbmUgPyhmaXhfd2luX2VvbCA9IHRydWUpIHQgPVxuICBtYXRjaCBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9saW5lIHQpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGxpbmUgLT4gU29tZSAodHJpbSB+Zml4X3dpbl9lb2wgbGluZSlcbjs7XG5cbmxldCBpbnB1dF9saW5lX2V4biA/KGZpeF93aW5fZW9sID0gdHJ1ZSkgdCA9XG4gIGxldCBsaW5lID0gQ2FtbC5pbnB1dF9saW5lIHQgaW5cbiAgdHJpbSB+Zml4X3dpbl9lb2wgbGluZVxuOztcblxubGV0IGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWMgPVxuICAgIG1hdGNoIGlucHV0X2xpbmUgP2ZpeF93aW5fZW9sIHQgd2l0aFxuICAgIHwgTm9uZSAtPiBhY1xuICAgIHwgU29tZSBsaW5lIC0+IGxvb3AgKGYgYWMgbGluZSlcbiAgaW5cbiAgbG9vcCBpbml0XG47O1xuXG5sZXQgaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sIHQgPVxuICBMaXN0LnJldiAoZm9sZF9saW5lcyA/Zml4X3dpbl9lb2wgdCB+aW5pdDpbXSB+ZjooZnVuIGxpbmVzIGxpbmUgLT4gbGluZSA6OiBsaW5lcykpXG47O1xuXG5sZXQgaXRlcl9saW5lcyA/Zml4X3dpbl9lb2wgdCB+ZiA9XG4gIGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBsaW5lIC0+IGYgbGluZSlcbjs7XG5cbmxldCByZWFkX2xpbmVzID9maXhfd2luX2VvbCBmbmFtZSA9IHdpdGhfZmlsZSBmbmFtZSB+ZjooaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sKVxubGV0IHJlYWRfYWxsIGZuYW1lID0gd2l0aF9maWxlIGZuYW1lIH5mOmlucHV0X2FsbFxuIiwib3BlbiEgQmFzZVxuXG50eXBlIHQgPSBDYW1sLm91dF9jaGFubmVsXG5cbmxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBzZWVrID0gQ2FtbC5MYXJnZUZpbGUuc2Vla19vdXRcbmxldCBwb3MgPSBDYW1sLkxhcmdlRmlsZS5wb3Nfb3V0XG5sZXQgbGVuZ3RoID0gQ2FtbC5MYXJnZUZpbGUub3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgc3Rkb3V0ID0gQ2FtbC5zdGRvdXRcbmxldCBzdGRlcnIgPSBDYW1sLnN0ZGVyclxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBpZiBwaHlzX2VxdWFsIHQgc3RkZXJyXG4gIHRoZW4gU2V4cC5BdG9tIFwiPHN0ZGVycj5cIlxuICBlbHNlIGlmIHBoeXNfZXF1YWwgdCBzdGRvdXRcbiAgdGhlbiBTZXhwLkF0b20gXCI8c3Rkb3V0PlwiXG4gIGVsc2UgU2V4cC5BdG9tIFwiPE91dF9jaGFubmVsLnQ+XCJcbjs7XG5cbnR5cGUgJ2Egd2l0aF9jcmVhdGVfYXJncyA9XG4gID9iaW5hcnk6Ym9vbCAtPiA/YXBwZW5kOmJvb2wgLT4gP2ZhaWxfaWZfZXhpc3RzOmJvb2wgLT4gP3Blcm06aW50IC0+ICdhXG5cbmxldCBjcmVhdGVcbiAgICAgID8oYmluYXJ5ID0gdHJ1ZSlcbiAgICAgID8oYXBwZW5kID0gZmFsc2UpXG4gICAgICA/KGZhaWxfaWZfZXhpc3RzID0gZmFsc2UpXG4gICAgICA/KHBlcm0gPSAwbzY2NilcbiAgICAgIGZpbGVcbiAgPVxuICBsZXQgZmxhZ3MgPSBbIE9wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0IF0gaW5cbiAgbGV0IGZsYWdzID0gKGlmIGJpbmFyeSB0aGVuIE9wZW5fYmluYXJ5IGVsc2UgT3Blbl90ZXh0KSA6OiBmbGFncyBpblxuICBsZXQgZmxhZ3MgPSAoaWYgYXBwZW5kIHRoZW4gT3Blbl9hcHBlbmQgZWxzZSBPcGVuX3RydW5jKSA6OiBmbGFncyBpblxuICBsZXQgZmxhZ3MgPSBpZiBmYWlsX2lmX2V4aXN0cyB0aGVuIE9wZW5fZXhjbCA6OiBmbGFncyBlbHNlIGZsYWdzIGluXG4gIENhbWwub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0gZmlsZVxuOztcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IENhbWwuc2V0X2JpbmFyeV9tb2RlX291dFxubGV0IGZsdXNoID0gQ2FtbC5mbHVzaFxubGV0IGNsb3NlID0gQ2FtbC5jbG9zZV9vdXRcbmxldCBjbG9zZV9ub19lcnIgPSBDYW1sLmNsb3NlX291dF9ub2VyclxubGV0IG91dHB1dCB0IH5idWYgfnBvcyB+bGVuID0gQ2FtbC5vdXRwdXQgdCBidWYgcG9zIGxlblxubGV0IG91dHB1dF9zdWJzdHJpbmcgdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwub3V0cHV0X3N1YnN0cmluZyB0IGJ1ZiBwb3MgbGVuXG5sZXQgb3V0cHV0X3N0cmluZyA9IENhbWwub3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IENhbWwub3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0X2NoYXIgPSBDYW1sLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBDYW1sLm91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBDYW1sLm91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X2J1ZmZlciA9IENhbWwuQnVmZmVyLm91dHB1dF9idWZmZXJcbmxldCBvdXRwdXRfdmFsdWUgPSBDYW1sLm91dHB1dF92YWx1ZVxubGV0IG5ld2xpbmUgdCA9IG91dHB1dF9zdHJpbmcgdCBcIlxcblwiXG5cbmxldCBvdXRwdXRfbGluZXMgdCBsaW5lcyA9XG4gIExpc3QuaXRlciBsaW5lcyB+ZjooZnVuIGxpbmUgLT5cbiAgICBvdXRwdXRfc3RyaW5nIHQgbGluZTtcbiAgICBuZXdsaW5lIHQpXG47O1xuXG5sZXQgcHJpbnRmID0gQ2FtbC5QcmludGYucHJpbnRmXG5sZXQgZXByaW50ZiA9IENhbWwuUHJpbnRmLmVwcmludGZcbmxldCBmcHJpbnRmID0gQ2FtbC5QcmludGYuZnByaW50ZlxubGV0IGtmcHJpbnRmID0gQ2FtbC5QcmludGYua2ZwcmludGZcbmxldCBwcmludF9zdHJpbmcgPSBDYW1sLnByaW50X3N0cmluZ1xubGV0IHByaW50X2VuZGxpbmUgPSBDYW1sLnByaW50X2VuZGxpbmVcbmxldCBwcmVycl9lbmRsaW5lID0gQ2FtbC5wcmVycl9lbmRsaW5lXG5cbmxldCBwcmludF9zID9tYWNoIHNleHAgPVxuICBwcmludF9lbmRsaW5lXG4gICAgKG1hdGNoIG1hY2ggd2l0aFxuICAgICB8IFNvbWUgKCkgLT4gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwXG4gICAgIHwgTm9uZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gc2V4cClcbjs7XG5cbmxldCBlcHJpbnRfcyA/bWFjaCBzZXhwID1cbiAgcHJlcnJfZW5kbGluZVxuICAgIChtYXRjaCBtYWNoIHdpdGhcbiAgICAgfCBTb21lICgpIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cFxuICAgICB8IE5vbmUgLT4gU2V4cC50b19zdHJpbmdfaHVtIHNleHApXG47O1xuXG5sZXQgd2l0aF9maWxlID9iaW5hcnkgP2FwcGVuZCA/ZmFpbF9pZl9leGlzdHMgP3Blcm0gZmlsZSB+ZiA9XG4gIEV4bi5wcm90ZWN0eCAoY3JlYXRlID9iaW5hcnkgP2FwcGVuZCA/ZmFpbF9pZl9leGlzdHMgP3Blcm0gZmlsZSkgfmYgfmZpbmFsbHk6Y2xvc2Vcbjs7XG5cbmxldCB3cml0ZV9saW5lcyBmaWxlIGxpbmVzID0gd2l0aF9maWxlIGZpbGUgfmY6KGZ1biB0IC0+IG91dHB1dF9saW5lcyB0IGxpbmVzKVxubGV0IHdyaXRlX2FsbCBmaWxlIH5kYXRhID0gd2l0aF9maWxlIGZpbGUgfmY6KGZ1biB0IC0+IG91dHB1dF9zdHJpbmcgdCBkYXRhKVxuIl19
