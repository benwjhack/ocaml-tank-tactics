// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$7=caml_string_of_jsbytes(""),
     cst_Stringext_rcut_empty_separ=
      caml_string_of_jsbytes("Stringext.rcut: empty separator"),
     cst_Stringext_cut_empty_separa=
      caml_string_of_jsbytes("Stringext.cut: empty separator"),
     cst$6=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     cst$1=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes(""),
     cst_Stringext_Found_int=caml_string_of_jsbytes("Stringext.Found_int"),
     cst_Stringext_Found_replace=
      caml_string_of_jsbytes("Stringext.Found_replace"),
     Stdlib_String=global_data.Stdlib__String,
     Stdlib=global_data.Stdlib,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Bytes=global_data.Stdlib__Bytes,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Buffer=global_data.Stdlib__Buffer;
    function string_after(s,n)
     {return caml_call3
              (Stdlib_String[15],s,n,caml_ml_string_length(s) - n | 0)}
    function quote(s)
     {var
       len=caml_ml_string_length(s),
       buf=caml_call1(Stdlib_Buffer[1],2 * len | 0),
       _U_=len - 1 | 0,
       _T_=0;
      if(_U_ >= 0)
       {var i=_T_;
        for(;;)
         {var c=caml_string_get(s,i),_V_=c - 63 | 0,switch$0=0;
          if(31 < _V_ >>> 0)
           {var _W_=_V_ + 27 | 0;
            if(10 >= _W_ >>> 0)
             switch(_W_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
          else
           if(26 < _V_ - 1 >>> 0)switch$0 = 1;
          if(switch$0)
           {caml_call2(Stdlib_Buffer[12],buf,92);
            caml_call2(Stdlib_Buffer[12],buf,c)}
          else
           caml_call2(Stdlib_Buffer[12],buf,c);
          var _X_=i + 1 | 0;
          if(_U_ !== i){var i=_X_;continue}
          break}}
      return caml_call1(Stdlib_Buffer[2],buf)}
    var of_char=caml_call1(Stdlib_String[1],1);
    function full_split(str,on)
     {if(caml_string_equal(str,cst$3))return 0;
      var sep=caml_call1(of_char,on);
      function loop(acc,offset)
       {try
         {var index=caml_call3(Stdlib_String[33],str,offset,on);
          if(index === offset)
           var _R_=loop([0,sep,acc],index - 1 | 0);
          else
           var
            token=
             caml_call3
              (Stdlib_String[15],str,index + 1 | 0,offset - index | 0),
            _R_=loop([0,sep,[0,token,acc]],index - 1 | 0);
          return _R_}
        catch(_S_)
         {_S_ = caml_wrap_exception(_S_);
          if(_S_ === Stdlib[8])
           return 0 <= offset
                   ?[0,caml_call3(Stdlib_String[15],str,0,offset + 1 | 0),acc]
                   :acc;
          throw _S_}}
      return loop(0,caml_ml_string_length(str) - 1 | 0)}
    function split(max,s,on)
     {if(max)
       {var max$0=max[1];
        if(caml_string_equal(s,cst))return 0;
        if(1 === max$0)return [0,s,0];
        var
         loop=
          function(offset,tokens)
           {if(tokens === (max$0 - 1 | 0))
             return [0,
                     caml_call3
                      (Stdlib_String[15],
                       s,
                       offset,
                       caml_ml_string_length(s) - offset | 0),
                     0];
            try
             {var index=caml_call3(Stdlib_String[31],s,offset,on);
              if(index === offset)
               var _P_=[0,cst$0,loop(offset + 1 | 0,tokens + 1 | 0)];
              else
               var
                token=
                 caml_call3(Stdlib_String[15],s,offset,index - offset | 0),
                _P_=[0,token,loop(index + 1 | 0,tokens + 1 | 0)];
              return _P_}
            catch(_Q_)
             {_Q_ = caml_wrap_exception(_Q_);
              if(_Q_ === Stdlib[8])
               return [0,
                       caml_call3
                        (Stdlib_String[15],
                         s,
                         offset,
                         caml_ml_string_length(s) - offset | 0),
                       0];
              throw _Q_}};
        return loop(0,0)}
      if(caml_string_equal(s,cst$1))return 0;
      function loop$0(acc,offset)
       {try
         {var index=caml_call3(Stdlib_String[33],s,offset,on);
          if(index === offset)
           var _N_=loop$0([0,cst$2,acc],index - 1 | 0);
          else
           var
            token=
             caml_call3(Stdlib_String[15],s,index + 1 | 0,offset - index | 0),
            _N_=loop$0([0,token,acc],index - 1 | 0);
          return _N_}
        catch(_O_)
         {_O_ = caml_wrap_exception(_O_);
          if(_O_ === Stdlib[8])
           return [0,caml_call3(Stdlib_String[15],s,0,offset + 1 | 0),acc];
          throw _O_}}
      return loop$0(0,caml_ml_string_length(s) - 1 | 0)}
    function rindex_from_on(s,i,on)
     {var i$0=i;
      for(;;)
       {if(0 > i$0)throw Stdlib[8];
        var _M_=caml_string_get(s,i$0);
        if(caml_call2(Stdlib_String[14],on,_M_))return i$0;
        var i$1=i$0 - 1 | 0,i$0=i$1}}
    function trim_left_sub(s,pos,len,chars)
     {var final$0=pos + len | 0,last_char=pos,i=pos;
      for(;;)
       {if(i !== final$0)
         {var _L_=caml_string_get(s,i);
          if(caml_call2(Stdlib_String[14],chars,_L_))
           {var
             i$0=i + 1 | 0,
             last_char$0=i + 1 | 0,
             last_char=last_char$0,
             i=i$0;
            continue}}
        var new_len=len - (last_char - pos | 0) | 0;
        return caml_call3(Stdlib_String[15],s,last_char,new_len)}}
    function split_trim_left(str,on,trim)
     {if(caml_string_equal(str,cst$4))return 0;
      function loop(acc,offset)
       {try
         {var index=rindex_from_on(str,offset,on);
          if(index === offset)
           var _J_=loop([0,cst$5,acc],index - 1 | 0);
          else
           var
            token=trim_left_sub(str,index + 1 | 0,offset - index | 0,trim),
            _J_=loop([0,token,acc],index - 1 | 0);
          return _J_}
        catch(_K_)
         {_K_ = caml_wrap_exception(_K_);
          if(_K_ === Stdlib[8])
           return [0,trim_left_sub(str,0,offset + 1 | 0,trim),acc];
          throw _K_}}
      return loop(0,caml_ml_string_length(str) - 1 | 0)}
    var Found_int=[248,cst_Stringext_Found_int,caml_fresh_oo_id(0)];
    function first_char_ne(s,c)
     {var
       _H_=0 < caml_ml_string_length(s)?1:0,
       _I_=_H_?caml_string_get(s,0) !== c?1:0:_H_;
      return _I_}
    function trim_left(s)
     {if(first_char_ne(s,32))return s;
      var len=caml_ml_string_length(s);
      try
       {var _F_=len - 1 | 0,_E_=0;
        if(_F_ >= 0)
         {var i=_E_;
          for(;;)
           {if(32 !== caml_string_get(s,i))throw [0,Found_int,i];
            var _G_=i + 1 | 0;
            if(_F_ !== i){var i=_G_;continue}
            break}}
        return cst$6}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Found_int)throw exn;
        var non_space=exn[2];
        return caml_call3(Stdlib_String[15],s,non_space,len - non_space | 0)}}
    function find_from(opt,str,pattern)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      try
       {var
         _z_=
          caml_ml_string_length(str) - caml_ml_string_length(pattern) | 0;
        if(_z_ >= start)
         {var sth$0=start;
          for(;;)
           {try
             {var _v_=caml_ml_string_length(pattern) - 1 | 0,_u_=0;
              if(_v_ >= 0)
               {var i=_u_;
                for(;;)
                 {var _x_=caml_string_get(pattern,i);
                  if(caml_string_get(str,i + sth$0 | 0) !== _x_)
                   throw Stdlib[3];
                  var _y_=i + 1 | 0;
                  if(_v_ !== i){var i=_y_;continue}
                  break}}
              var _w_=1,_B_=_w_}
            catch(_D_){var _B_=0}
            if(_B_)throw [0,Found_int,sth$0];
            var _C_=sth$0 + 1 | 0;
            if(_z_ !== sth$0){var sth$0=_C_;continue}
            break}}
        var _A_=0;
        return _A_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Found_int)return 0;
        var i$0=exn[2];
        return [0,i$0]}}
    function find_min(l,f)
     {if(! l)return 0;
      var xs$0=l[2],x$1=l[1],fx$1=caml_call1(f,x$1),x=x$1,fx=fx$1,param=xs$0;
      for(;;)
       {if(! param)return [0,[0,x,fx]];
        var xs=param[2],x$0=param[1],fx$0=caml_call1(f,x$0);
        if(runtime.caml_lessthan(fx$0,fx))
         {var x=x$0,fx=fx$0,param=xs;continue}
        var param=xs}}
    function replace_all(str,pattern,with$0)
     {var
       plen=caml_ml_string_length(pattern),
       slen=caml_ml_string_length(str),
       buf=caml_call1(Stdlib_Buffer[1],slen),
       i=0;
      for(;;)
       {var match=find_from([0,i],str,pattern);
        if(match)
         {var j=match[1];
          caml_call4(Stdlib_Buffer[18],buf,str,i,j - i | 0);
          caml_call2(Stdlib_Buffer[16],buf,with$0);
          var i$0=j + plen | 0,i=i$0;
          continue}
        caml_call4(Stdlib_Buffer[18],buf,str,i,slen - i | 0);
        return caml_call1(Stdlib_Buffer[2],buf)}}
    var Found_replace=[248,cst_Stringext_Found_replace,caml_fresh_oo_id(0)];
    function replace_all_assoc(str,tbl)
     {var
       slen=caml_ml_string_length(str),
       buf=caml_call1(Stdlib_Buffer[1],slen);
      function loop(i)
       {var i$0=i;
        for(;;)
         {if(slen <= i$0)return caml_call1(Stdlib_Buffer[2],buf);
          try
           {var
             found=[0,0],
             e=
              find_min
               (tbl,
                function(i,found)
                  {return function(param)
                    {var
                      with$0=param[2],
                      pattern=param[1],
                      match=find_from([0,i],str,pattern);
                     if(! match)return Stdlib[19];
                     var j=match[1];
                     if(j === i)throw [0,Found_replace,j,pattern,with$0];
                     found[1] = 1;
                     return j}}
                 (i$0,found));
            if(e)
             var
              _r_=e[1],
              j$1=_r_[2],
              match$0=_r_[1],
              with$2=match$0[2],
              pattern$1=match$0[1],
              _s_=found[1]?[0,[0,j$1,pattern$1,with$2]]:0,
              _t_=_s_;
            else
             var _t_=0;
            var r=_t_}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] !== Found_replace)throw exn;
            var
             with$0=exn[4],
             pattern=exn[3],
             j=exn[2],
             r=[0,[0,j,pattern,with$0]]}
          if(r)
           {var match=r[1],with$1=match[3],pattern$0=match[2],j$0=match[1];
            caml_call4(Stdlib_Buffer[18],buf,str,i$0,j$0 - i$0 | 0);
            caml_call2(Stdlib_Buffer[16],buf,with$1);
            var i$1=j$0 + caml_ml_string_length(pattern$0) | 0,i$0=i$1;
            continue}
          caml_call4(Stdlib_Buffer[18],buf,str,i$0,slen - i$0 | 0);
          return caml_call1(Stdlib_Buffer[2],buf)}}
      return loop(0)}
    function of_list(xs$0)
     {var
       l=caml_call1(Stdlib_List[1],xs$0),
       s=caml_create_bytes(l),
       i=0,
       param=xs$0;
      for(;;)
       {if(! param)return caml_call1(Stdlib_Bytes[48],s);
        var xs=param[2],x=param[1];
        caml_bytes_set(s,i,x);
        var i$0=i + 1 | 0,i=i$0,param=xs}}
    function to_list(s)
     {var i$1=caml_ml_string_length(s) - 1 | 0,acc=0,i=i$1;
      for(;;)
       {if(-1 === i)return acc;
        var i$0=i - 1 | 0,acc$0=[0,caml_string_get(s,i),acc],acc=acc$0,i=i$0}}
    function of_array(a)
     {var len=a.length - 1,bytes=caml_create_bytes(len),_p_=len - 1 | 0,_o_=0;
      if(_p_ >= 0)
       {var i=_o_;
        for(;;)
         {caml_bytes_set(bytes,i,runtime.caml_check_bound(a,i)[1 + i]);
          var _q_=i + 1 | 0;
          if(_p_ !== i){var i=_q_;continue}
          break}}
      return caml_call1(Stdlib_Bytes[48],bytes)}
    function to_array(s)
     {function _m_(_n_){return caml_string_get(s,_n_)}
      return caml_call2(Stdlib_Array[2],caml_ml_string_length(s),_m_)}
    function cut(s,on)
     {var sep_max=caml_ml_string_length(on) - 1 | 0;
      if(0 > sep_max)
       return caml_call1(Stdlib[1],cst_Stringext_cut_empty_separa);
      var s_max=caml_ml_string_length(s) - 1 | 0;
      if(0 > s_max)return 0;
      var k=[0,0],i=[0,0];
      try
       {a:
        for(;;)
         {if((i[1] + sep_max | 0) > s_max){var _k_=0;return _k_}
          if(caml_string_unsafe_get(s,i[1]) !== caml_string_unsafe_get(on,0))
           {i[1]++;continue}
          k[1] = 1;
          for(;;)
           {if
             (k[1]
              <=
              sep_max
              &&
              caml_string_unsafe_get(s,i[1] + k[1] | 0)
              ===
              caml_string_unsafe_get(on,k[1]))
             {k[1]++;continue}
            if(k[1] > sep_max)throw Stdlib[3];
            i[1]++;
            continue a}}}
      catch(_l_)
       {_l_ = caml_wrap_exception(_l_);
        if(_l_ !== Stdlib[3])throw _l_;
        var
         left_end=i[1] - 1 | 0,
         right_start=(i[1] + sep_max | 0) + 1 | 0,
         _j_=
          caml_call3
           (Stdlib_String[15],s,right_start,(s_max - right_start | 0) + 1 | 0);
        return [0,[0,caml_call3(Stdlib_String[15],s,0,left_end + 1 | 0),_j_]]}}
    function rcut(s,on)
     {var sep_max=caml_ml_string_length(on) - 1 | 0;
      if(0 > sep_max)
       return caml_call1(Stdlib[1],cst_Stringext_rcut_empty_separ);
      var s_max=caml_ml_string_length(s) - 1 | 0;
      if(0 > s_max)return 0;
      var k=[0,0],i=[0,s_max];
      try
       {a:
        for(;;)
         {if(sep_max > i[1]){var _h_=0;return _h_}
          if
           (caml_string_unsafe_get(s,i[1])
            !==
            caml_string_unsafe_get(on,sep_max))
           {i[1] += -1;continue}
          var sep_start=i[1] - sep_max | 0;
          k[1] = sep_max - 1 | 0;
          for(;;)
           {if
             (0
              <=
              k[1]
              &&
              caml_string_unsafe_get(s,sep_start + k[1] | 0)
              ===
              caml_string_unsafe_get(on,k[1]))
             {k[1] += -1;continue}
            if(0 > k[1])throw Stdlib[3];
            i[1] += -1;
            continue a}}}
      catch(_i_)
       {_i_ = caml_wrap_exception(_i_);
        if(_i_ !== Stdlib[3])throw _i_;
        var
         left_end=(i[1] - sep_max | 0) - 1 | 0,
         right_start=i[1] + 1 | 0,
         _g_=
          caml_call3
           (Stdlib_String[15],s,right_start,(s_max - right_start | 0) + 1 | 0);
        return [0,[0,caml_call3(Stdlib_String[15],s,0,left_end + 1 | 0),_g_]]}}
    function chop_prefix(s,prefix)
     {var
       prefix_l=caml_ml_string_length(prefix),
       string_l=caml_ml_string_length(s);
      if(string_l < prefix_l)return 0;
      try
       {var _b_=prefix_l - 1 | 0,_a_=0;
        if(_b_ >= 0)
         {var i=_a_;
          for(;;)
           {var _d_=caml_string_get(prefix,i);
            if(caml_string_get(s,i) !== _d_)throw Stdlib[3];
            var _e_=i + 1 | 0;
            if(_b_ !== i){var i=_e_;continue}
            break}}
        var
         _c_=
          [0,caml_call3(Stdlib_String[15],s,prefix_l,string_l - prefix_l | 0)];
        return _c_}
      catch(_f_){return 0}}
    function drop(s,n)
     {var l=caml_ml_string_length(s);
      return l <= n?cst$7:caml_call3(Stdlib_String[15],s,n,l - n | 0)}
    function take(s,n)
     {return caml_ml_string_length(s) <= n
              ?s
              :caml_call3(Stdlib_String[15],s,0,n)}
    var
     Stringext=
      [0,
       string_after,
       quote,
       split,
       full_split,
       trim_left,
       split_trim_left,
       of_char,
       of_list,
       to_list,
       to_array,
       of_array,
       find_from,
       replace_all,
       replace_all_assoc,
       cut,
       rcut,
       chop_prefix,
       drop,
       take,
       trim_left_sub];
    runtime.caml_register_global(19,Stringext,"Stringext");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdHJpbmdleHQuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN0cmluZ19hZnRlciIsInMiLCJuIiwicXVvdGUiLCJsZW4iLCJidWYiLCJpIiwiYyIsIm9mX2NoYXIiLCJmdWxsX3NwbGl0Iiwic3RyIiwib24iLCJzZXAiLCJsb29wIiwiYWNjIiwib2Zmc2V0IiwiaW5kZXgiLCJ0b2tlbiIsInNwbGl0IiwibWF4IiwibWF4JDAiLCJ0b2tlbnMiLCJsb29wJDAiLCJyaW5kZXhfZnJvbV9vbiIsImkkMCIsImkkMSIsInRyaW1fbGVmdF9zdWIiLCJwb3MiLCJjaGFycyIsImZpbmFsJDAiLCJsYXN0X2NoYXIiLCJsYXN0X2NoYXIkMCIsIm5ld19sZW4iLCJzcGxpdF90cmltX2xlZnQiLCJ0cmltIiwiZmlyc3RfY2hhcl9uZSIsInRyaW1fbGVmdCIsIm5vbl9zcGFjZSIsImZpbmRfZnJvbSIsIm9wdCIsInBhdHRlcm4iLCJzdGgiLCJzdGFydCIsInN0aCQwIiwiZmluZF9taW4iLCJsIiwiZiIsInhzJDAiLCJ4JDEiLCJ4cyIsIngkMCIsImZ4JDAiLCJyZXBsYWNlX2FsbCIsIndpdGgkMCIsInBsZW4iLCJzbGVuIiwiaiIsInJlcGxhY2VfYWxsX2Fzc29jIiwidGJsIiwiZm91bmQiLCJlIiwiaiQxIiwid2l0aCQyIiwicGF0dGVybiQxIiwiciIsIndpdGgkMSIsInBhdHRlcm4kMCIsImokMCIsIm9mX2xpc3QiLCJ4IiwidG9fbGlzdCIsImFjYyQwIiwib2ZfYXJyYXkiLCJhIiwiYnl0ZXMiLCJ0b19hcnJheSIsImN1dCIsInNlcF9tYXgiLCJzX21heCIsImsiLCJsZWZ0X2VuZCIsInJpZ2h0X3N0YXJ0IiwicmN1dCIsInNlcF9zdGFydCIsImNob3BfcHJlZml4IiwicHJlZml4IiwicHJlZml4X2wiLCJzdHJpbmdfbCIsImRyb3AiLCJ0YWtlIl0sInNvdXJjZXMiOlsiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3N0cmluZ2V4dC9zdHJpbmdleHQubWwi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QW9DQUU7T0FZQUk7T0FNQUM7T0FwUEEvRDtJQXBDVTtVIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiBTdHJpbmdcblxubGV0IHN0cmluZ19hZnRlciBzIG4gPSBTdHJpbmcuc3ViIHMgbiAoU3RyaW5nLmxlbmd0aCBzIC0gbilcblxubGV0IHF1b3RlIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlICgyICogbGVuKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICdbJyB8ICddJyB8ICcqJyB8ICcuJyB8ICdcXFxcJyB8ICc/JyB8ICcrJyB8ICdeJyB8ICckJyBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJztcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgIHwgYyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgZG9uZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG5cbigqIE5vdCB0YWlsIHJlY3Vyc2l2ZSBmb3IgXCJwZXJmb3JtYW5jZVwiLCBwbGVhc2UgY2hvb3NlIGxvdyB2YWx1ZXMgZm9yXG4gICBbbWF4XS4gVGhlIGlkZWEgaXMgdGhhdCBtYXggaXMgYWx3YXlzIHNtYWxsIGJlY2F1c2UgaXQncyBoYXJkXG4gICBjb2RlICopXG5sZXQgc3BsaXRfY2hhcl9ib3VuZGVkIHN0ciB+b24gfm1heCA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiBbXVxuICBlbHNlIGlmIG1heCA9IDEgdGhlbiBbc3RyXVxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wIG9mZnNldCB0b2tlbnMgPVxuICAgICAgaWYgdG9rZW5zID0gbWF4IC0gMVxuICAgICAgdGhlbiBbc3ViIHN0ciBvZmZzZXQgKGxlbmd0aCBzdHIgLSBvZmZzZXQpXVxuICAgICAgZWxzZVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgaW5kZXggPSBpbmRleF9mcm9tIHN0ciBvZmZzZXQgb24gaW5cbiAgICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgICBcIlwiOjoobG9vcCAob2Zmc2V0ICsgMSkgKHRva2VucyArIDEpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IFN0cmluZy5zdWIgc3RyIG9mZnNldCAoaW5kZXggLSBvZmZzZXQpIGluXG4gICAgICAgICAgICB0b2tlbjo6KGxvb3AgKGluZGV4ICsgMSkgKHRva2VucyArIDEpKVxuICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBbc3ViIHN0ciBvZmZzZXQgKGxlbmd0aCBzdHIgLSBvZmZzZXQpXVxuICAgIGluIGxvb3AgMCAwXG5cbmxldCBzcGxpdF9jaGFyX3VuYm91bmRlZCBzdHIgfm9uID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgcmVjIGxvb3AgYWNjIG9mZnNldCA9XG4gICAgICB0cnkgYmVnaW5cbiAgICAgICAgbGV0IGluZGV4ID0gcmluZGV4X2Zyb20gc3RyIG9mZnNldCBvbiBpblxuICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgbG9vcCAoXCJcIjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHRva2VuID0gc3ViIHN0ciAoaW5kZXggKyAxKSAob2Zmc2V0IC0gaW5kZXgpIGluXG4gICAgICAgICAgbG9vcCAodG9rZW46OmFjYykgKGluZGV4IC0gMSlcbiAgICAgIGVuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT4gKHN1YiBzdHIgMCAob2Zmc2V0ICsgMSkpOjphY2NcbiAgICBpbiBsb29wIFtdIChsZW5ndGggc3RyIC0gMSlcblxubGV0IG9mX2NoYXIgPSBTdHJpbmcubWFrZSAxXG5cbmxldCBmdWxsX3NwbGl0IHN0ciB+b24gPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCBzZXAgPSBvZl9jaGFyIG9uIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyBvZmZzZXQgPVxuICAgICAgdHJ5IGJlZ2luXG4gICAgICAgIGxldCBpbmRleCA9IHJpbmRleF9mcm9tIHN0ciBvZmZzZXQgb24gaW5cbiAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgIGxvb3AgKHNlcDo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHRva2VuID0gc3ViIHN0ciAoaW5kZXggKyAxKSAob2Zmc2V0IC0gaW5kZXgpIGluXG4gICAgICAgICAgbG9vcCAoc2VwOjp0b2tlbjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgZW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgICB0aGVuIChzdWIgc3RyIDAgKG9mZnNldCArIDEpKTo6YWNjXG4gICAgICAgIGVsc2UgYWNjXG4gICAgaW4gbG9vcCBbXSAobGVuZ3RoIHN0ciAtIDEpXG5cbigqIGNvcHlpbmcgY29yZSdzIGNvbnZlbnRpb24gZm9yIFN0cmluZy5zcGxpdCBidXQgd2l0aCBhbiBvcHRpb25hbCBtYXhcbiAgIGFyZ3VtZW50ICopXG5sZXQgc3BsaXQgP21heCBzIH5vbiA9XG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBzcGxpdF9jaGFyX3VuYm91bmRlZCBzIH5vblxuICB8IFNvbWUgbWF4IC0+ICAgICAgICAgICAgICAgICAoKiBhc3NlcnQgKG1heCA8IDEwMCk7ICopXG4gICAgc3BsaXRfY2hhcl9ib3VuZGVkIHMgfm9uIH5tYXhcblxubGV0IHJpbmRleF9mcm9tX29uIHMgfm9mZnNldCB+b24gPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBvbiBzLltpXSB0aGVuIGlcbiAgICBlbHNlIGxvb3AgKGkgLSAxKVxuICBpbiBsb29wIG9mZnNldFxuXG5sZXQgdHJpbV9sZWZ0X3N1YiBzIH5wb3MgfmxlbiB+Y2hhcnMgPVxuICBsZXQgc3RhcnRfcG9zID1cbiAgICBsZXQgZmluYWwgPSBwb3MgKyBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbGFzdF9jaGFyIGkgPVxuICAgICAgaWYgaSA9IGZpbmFsIHRoZW4gbGFzdF9jaGFyXG4gICAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBjaGFycyBzLltpXSB0aGVuIGxvb3AgKGkgKyAxKSAoaSArIDEpXG4gICAgICBlbHNlIGxhc3RfY2hhclxuICAgIGluIGxvb3AgcG9zIHBvc1xuICBpblxuICBsZXQgbmV3X2xlbiA9IGxlbiAtIChzdGFydF9wb3MgLSBwb3MpIGluXG4gIFN0cmluZy5zdWIgcyBzdGFydF9wb3MgbmV3X2xlblxuXG5sZXQgc3BsaXRfdHJpbV9sZWZ0IHN0ciB+b24gfnRyaW0gPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCBhY2Mgb2Zmc2V0ID1cbiAgICAgIHRyeSBiZWdpblxuICAgICAgICBsZXQgaW5kZXggPSByaW5kZXhfZnJvbV9vbiBzdHIgfm9mZnNldCB+b24gaW5cbiAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgIGxvb3AgKFwiXCI6OmFjYykgKGluZGV4IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCB0b2tlbiA9IHRyaW1fbGVmdF9zdWIgc3RyIH5wb3M6KGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH5sZW46KG9mZnNldCAtIGluZGV4KSB+Y2hhcnM6dHJpbSBpblxuICAgICAgICAgIGxvb3AgKHRva2VuOjphY2MpIChpbmRleCAtIDEpXG4gICAgICBlbmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICh0cmltX2xlZnRfc3ViIHN0ciB+cG9zOjAgfmxlbjoob2Zmc2V0ICsgMSkgfmNoYXJzOnRyaW0pOjphY2NcbiAgICBpbiBsb29wIFtdIChsZW5ndGggc3RyIC0gMSlcblxuZXhjZXB0aW9uIEZvdW5kX2ludCBvZiBpbnRcblxubGV0IGZpcnN0X2NoYXJfbmUgcyBjID1cbiAgU3RyaW5nLmxlbmd0aCBzID4gMCAmJiBzLlswXSA8PiBjXG5cbmxldCB0cmltX2xlZnQgcyA9XG4gIGlmIGZpcnN0X2NoYXJfbmUgcyAnICcgdGhlbiBzXG4gIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgdHJ5XG4gICAgICBmb3IgaT0wIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaWYgcy5baV0gPD4gJyAnIHRoZW4gcmFpc2UgKEZvdW5kX2ludCBpKVxuICAgICAgZG9uZTtcbiAgICAgIFwiXCJcbiAgICB3aXRoIEZvdW5kX2ludCBub25fc3BhY2UgLT5cbiAgICAgIHN1YiBzIG5vbl9zcGFjZSAobGVuIC0gbm9uX3NwYWNlKVxuXG5sZXQgc3Vic3RyX2VxID8oc3RhcnQ9MCkgcyB+cGF0dGVybiA9XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHBhdHRlcm4gLSAxIGRvXG4gICAgICBpZiBzLltpICsgc3RhcnRdIDw+IHBhdHRlcm4uW2ldIHRoZW4gcmFpc2UgRXhpdFxuICAgIGRvbmU7XG4gICAgdHJ1ZVxuICB3aXRoIF8gLT4gZmFsc2VcblxubGV0IGZpbmRfZnJvbSA/KHN0YXJ0PTApIHN0ciB+cGF0dGVybiA9XG4gIHRyeVxuICAgIGZvciBpID0gc3RhcnQgdG8gKFN0cmluZy5sZW5ndGggc3RyKSAtIChTdHJpbmcubGVuZ3RoIHBhdHRlcm4pIGRvXG4gICAgICBpZiBzdWJzdHJfZXEgfnN0YXJ0Omkgc3RyIH5wYXR0ZXJuIHRoZW5cbiAgICAgICAgcmFpc2UgKEZvdW5kX2ludCBpKVxuICAgIGRvbmU7XG4gICAgTm9uZVxuICB3aXRoXG4gIHwgRm91bmRfaW50IGkgLT4gU29tZSBpXG4gIHwgIF8gLT4gTm9uZVxuXG5sZXQgZmluZF9taW4gbCB+ZiA9XG4gIGxldCByZWMgbG9vcCB4IGZ4ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFNvbWUgKHgsIGZ4KVxuICAgIHwgeCc6OnhzIC0+XG4gICAgICBsZXQgZngnID0gZiB4JyBpblxuICAgICAgaWYgZngnIDwgZnggdGhlbiBsb29wIHgnIGZ4JyB4c1xuICAgICAgZWxzZSBsb29wIHggZnggeHNcbiAgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHg6OnhzIC0+IGxvb3AgeCAoZiB4KSB4c1xuXG5sZXQgcmVwbGFjZV9hbGwgc3RyIH5wYXR0ZXJuIH53aXRoXyA9XG4gIGxldCAoc2xlbiwgcGxlbikgPSBTdHJpbmcuKGxlbmd0aCBzdHIsIGxlbmd0aCBwYXR0ZXJuKSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBzbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBtYXRjaCBmaW5kX2Zyb20gfnN0YXJ0Omkgc3RyIH5wYXR0ZXJuIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoc2xlbiAtIGkpO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICAgIHwgU29tZSBqIC0+XG4gICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKGogLSBpKTtcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiB3aXRoXztcbiAgICAgIGxvb3AgKGogKyBwbGVuKVxuICBpbiBsb29wIDBcblxuZXhjZXB0aW9uIEZvdW5kX3JlcGxhY2Ugb2YgaW50ICogc3RyaW5nICogc3RyaW5nXG5cbmxldCByZXBsYWNlX2FsbF9hc3NvYyBzdHIgdGJsID1cbiAgbGV0IHNsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBzbGVuIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IHNsZW4gdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gICAgZWxzZVxuICAgICAgbGV0IHIgPVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICAgICAgICBsZXQgZSA9XG4gICAgICAgICAgICBmaW5kX21pbiB0YmwgfmY6KGZ1biAocGF0dGVybiwgd2l0aF8pIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGZpbmRfZnJvbSB+c3RhcnQ6aSBzdHIgfnBhdHRlcm4gd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgICAtPiBtYXhfaW50XG4gICAgICAgICAgICAgIHwgU29tZSBqIHdoZW4gaiA9IGkgLT4gcmFpc2UgKEZvdW5kX3JlcGxhY2UgKGosIHBhdHRlcm4sIHdpdGhfKSlcbiAgICAgICAgICAgICAgfCBTb21lIGogLT4gZm91bmQgOj0gdHJ1ZTsgailcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIGUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lICgocGF0dGVybiwgd2l0aF8pLCBqKSB3aGVuICFmb3VuZCAtPiBTb21lIChqLCBwYXR0ZXJuLCB3aXRoXylcbiAgICAgICAgICB8IFNvbWUgXyAtPiBOb25lXG4gICAgICAgIHdpdGggRm91bmRfcmVwbGFjZSAoaiwgcGF0dGVybiwgd2l0aF8pIC0+IFNvbWUgKGosIHBhdHRlcm4sIHdpdGhfKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoc2xlbiAtIGkpO1xuICAgICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gICAgICB8IFNvbWUgKGosIHBhdHRlcm4sIHdpdGhfKSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKGogLSBpKTtcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHdpdGhfO1xuICAgICAgICBsb29wIChqICsgU3RyaW5nLmxlbmd0aCBwYXR0ZXJuKVxuICBpbiBsb29wIDBcblxubGV0IGl0ZXJpIGYgbCA9XG4gIGxldCByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+ICgpXG4gICAgfCB4Ojp4cyAtPiAoZiBpIHgpOyBsb29wIChzdWNjIGkpIHhzXG4gIGluIGxvb3AgMCBsXG5cbmxldCBvZl9saXN0IHhzID1cbiAgbGV0IGwgPSBMaXN0Lmxlbmd0aCB4cyBpblxuICBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGl0ZXJpIChmdW4gaSBjIC0+IEJ5dGVzLnNldCBzIGkgYykgeHM7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID1cbiAgICBpZiBpID0gLTEgdGhlbiBhY2NcbiAgICBlbHNlXG4gICAgICBsb29wIChzLltpXSA6OiBhY2MpIChwcmVkIGkpXG4gIGluIGxvb3AgW10gKFN0cmluZy5sZW5ndGggcyAtIDEpXG5cbmxldCBvZl9hcnJheSBhID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBCeXRlcy5zZXQgYnl0ZXMgaSBhLihpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ5dGVzXG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAoU3RyaW5nLmxlbmd0aCBzKSAoU3RyaW5nLmdldCBzKVxuXG4oKiByaXBwZWQgb2ZmIGZyb20gb25lIG9mIGRidWVuemxpJ3MgbGlicyAqKVxubGV0IGN1dCBzIH5vbiA9XG4gIGxldCBzZXBfbWF4ID0gbGVuZ3RoIG9uIC0gMSBpblxuICBpZiBzZXBfbWF4IDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nZXh0LmN1dDogZW1wdHkgc2VwYXJhdG9yXCIgZWxzZVxuICAgIGxldCBzX21heCA9IGxlbmd0aCBzIC0gMSBpblxuICAgIGlmIHNfbWF4IDwgMCB0aGVuIE5vbmUgZWxzZVxuICAgICAgbGV0IGsgPSByZWYgMCBpblxuICAgICAgbGV0IGkgPSByZWYgMCBpblxuICAgICAgKCogV2UgcnVuIGZyb20gdGhlIHN0YXJ0IG9mIFtzXSB0byBlbmQgd2l0aCBbaV0gdHJ5aW5nIHRvIG1hdGNoIHRoZVxuICAgICAgICAgZmlyc3QgY2hhcmFjdGVyIG9mIFtvbl0gaW4gW3NdLiBJZiB0aGlzIG1hdGNoZXMsIHdlIHZlcmlmeSB0aGF0XG4gICAgICAgICB0aGUgd2hvbGUgW29uXSBpcyBtYXRjaGVkIHVzaW5nIFtrXS4gSWYgaXQgZG9lc24ndCBtYXRjaCB3ZVxuICAgICAgICAgY29udGludWUgdG8gbG9vayBmb3IgW29uXSB3aXRoIFtpXS4gSWYgaXQgbWF0Y2hlcyB3ZSBleGl0IHRoZVxuICAgICAgICAgbG9vcCBhbmQgZXh0cmFjdCBhIHN1YnN0cmluZyBmcm9tIHRoZSBzdGFydCBvZiBbc10gdG8gdGhlXG4gICAgICAgICBwb3NpdGlvbiBiZWZvcmUgdGhlIFtvbl0gd2UgZm91bmQgYW5kIGFub3RoZXIgZnJvbSB0aGUgcG9zaXRpb25cbiAgICAgICAgIGFmdGVyIHRoZSBbb25dIHdlIGZvdW5kIHRvIGVuZCBvZiBzdHJpbmcuIElmIFtpXSBpcyBzdWNoIHRoYXQgbm9cbiAgICAgICAgIHNlcGFyYXRvciBjYW4gYmUgZm91bmQgd2UgZXhpdCB0aGUgbG9vcCBhbmQgcmV0dXJuIHRoZSBubyBtYXRjaFxuICAgICAgICAgY2FzZS4gKilcbiAgICAgIHRyeVxuICAgICAgICB3aGlsZSAoIWkgKyBzZXBfbWF4IDw9IHNfbWF4KSBkb1xuICAgICAgICAgICgqIENoZWNrIHJlbWFpbmluZyBbb25dIGNoYXJzIG1hdGNoLCBhY2Nlc3MgdG8gdW5zYWZlIHMgKCFpICsgIWspIGlzXG4gICAgICAgICAgICAgZ3VhcmFudGVlZCBieSBsb29wIGludmFyaWFudC4gKilcbiAgICAgICAgICBpZiB1bnNhZmVfZ2V0IHMgIWkgPD4gdW5zYWZlX2dldCBvbiAwIHRoZW4gaW5jciBpIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIGsgOj0gMTtcbiAgICAgICAgICAgIHdoaWxlICghayA8PSBzZXBfbWF4ICYmIHVuc2FmZV9nZXQgcyAoIWkgKyAhaykgPSB1bnNhZmVfZ2V0IG9uICFrKVxuICAgICAgICAgICAgZG8gaW5jciBrIGRvbmU7XG4gICAgICAgICAgICBpZiAhayA8PSBzZXBfbWF4IHRoZW4gKCogbm8gbWF0Y2ggKikgaW5jciBpIGVsc2UgcmFpc2UgRXhpdFxuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lO1xuICAgICAgICBOb25lICgqIG5vIG1hdGNoIGluIHRoZSB3aG9sZSBzdHJpbmcuICopXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gKCogaSBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZXBhcmF0b3IgKilcbiAgICAgICAgbGV0IGxlZnRfZW5kID0gIWkgLSAxIGluXG4gICAgICAgIGxldCByaWdodF9zdGFydCA9ICFpICsgc2VwX21heCArIDEgaW5cbiAgICAgICAgU29tZSAoc3ViIHMgMCAobGVmdF9lbmQgKyAxKSxcbiAgICAgICAgICAgICAgc3ViIHMgcmlnaHRfc3RhcnQgKHNfbWF4IC0gcmlnaHRfc3RhcnQgKyAxKSlcblxubGV0IHJjdXQgcyB+b24gPVxuICBsZXQgc2VwX21heCA9IGxlbmd0aCBvbiAtIDEgaW5cbiAgaWYgc2VwX21heCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZ2V4dC5yY3V0OiBlbXB0eSBzZXBhcmF0b3JcIiBlbHNlXG4gICAgbGV0IHNfbWF4ID0gbGVuZ3RoIHMgLSAxIGluXG4gICAgaWYgc19tYXggPCAwIHRoZW4gTm9uZSBlbHNlXG4gICAgICBsZXQgayA9IHJlZiAwIGluXG4gICAgICBsZXQgaSA9IHJlZiBzX21heCBpblxuICAgICAgKCogV2UgcnVuIGZyb20gdGhlIGVuZCBvZiBbc10gdG8gdGhlIGJlZ2lubmluZyB3aXRoIFtpXSB0cnlpbmcgdG9cbiAgICAgICAgIG1hdGNoIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBbb25dIGluIFtzXS4gSWYgdGhpcyBtYXRjaGVzLCB3ZVxuICAgICAgICAgdmVyaWZ5IHRoYXQgdGhlIHdob2xlIFtvbl0gaXMgbWF0Y2hlZCB1c2luZyBba10gKHdlIGRvIHRoYXRcbiAgICAgICAgIGJhY2t3YXJkcykuICBJZiBpdCBkb2Vzbid0IG1hdGNoIHdlIGNvbnRpbnVlIHRvIGxvb2sgZm9yIFtvbl1cbiAgICAgICAgIHdpdGggW2ldLiAgSWYgaXQgbWF0Y2hlcyB3ZSBleGl0IHRoZSBsb29wIGFuZCBleHRyYWN0IGFcbiAgICAgICAgIHN1YnN0cmluZyBmcm9tIHRoZSBzdGFydCBvZiBbc10gdG8gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGVcbiAgICAgICAgIFtvbl0gd2UgZm91bmQgYW5kIGFub3RoZXIgZnJvbSB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIFtvbl0gd2VcbiAgICAgICAgIGZvdW5kIHRvIGVuZCBvZiBzdHJpbmcuICBJZiBbaV0gaXMgc3VjaCB0aGF0IG5vIHNlcGFyYXRvciBjYW5cbiAgICAgICAgIGJlIGZvdW5kIHdlIGV4aXQgdGhlIGxvb3AgYW5kIHJldHVybiB0aGUgbm8gbWF0Y2ggY2FzZS4gKilcbiAgICAgIHRyeVxuICAgICAgICB3aGlsZSAoIWkgPj0gc2VwX21heCkgZG9cbiAgICAgICAgICBpZiB1bnNhZmVfZ2V0IHMgIWkgPD4gdW5zYWZlX2dldCBvbiBzZXBfbWF4IHRoZW4gZGVjciBpIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICgqIENoZWNrIHJlbWFpbmluZyBbb25dIGNoYXJzIG1hdGNoLCBhY2Nlc3MgdG8gdW5zYWZlX2dldFxuICAgICAgICAgICAgICAgcyAoc2VwX3N0YXJ0ICsgIWspIGlzIGd1YXJhbnRlZWQgYnkgbG9vcCBpbnZhcmlhbnQuICopXG4gICAgICAgICAgICBsZXQgc2VwX3N0YXJ0ID0gIWkgLSBzZXBfbWF4IGluXG4gICAgICAgICAgICBrIDo9IHNlcF9tYXggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCFrID49IDAgJiYgdW5zYWZlX2dldCBzIChzZXBfc3RhcnQgKyAhaykgPSB1bnNhZmVfZ2V0IG9uICFrKVxuICAgICAgICAgICAgZG8gZGVjciBrIGRvbmU7XG4gICAgICAgICAgICBpZiAhayA+PSAwIHRoZW4gKCogbm8gbWF0Y2ggKikgZGVjciBpIGVsc2UgcmFpc2UgRXhpdFxuICAgICAgICAgIGVuZFxuICAgICAgICBkb25lO1xuICAgICAgICBOb25lICgqIG5vIG1hdGNoIGluIHRoZSB3aG9sZSBzdHJpbmcuICopXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gKCogaSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzZXBhcmF0b3IgKilcbiAgICAgICAgbGV0IGxlZnRfZW5kID0gIWkgLSBzZXBfbWF4IC0gMSBpblxuICAgICAgICBsZXQgcmlnaHRfc3RhcnQgPSAhaSArIDEgaW5cbiAgICAgICAgU29tZSAoc3ViIHMgMCAobGVmdF9lbmQgKyAxKSxcbiAgICAgICAgICAgICAgc3ViIHMgcmlnaHRfc3RhcnQgKHNfbWF4IC0gcmlnaHRfc3RhcnQgKyAxKSlcblxubGV0IGNob3BfcHJlZml4IHMgfnByZWZpeCA9XG4gIGxldCBwcmVmaXhfbCA9IFN0cmluZy5sZW5ndGggcHJlZml4IGluXG4gIGxldCBzdHJpbmdfbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBwcmVmaXhfbCA+IHN0cmluZ19sIHRoZW4gTm9uZVxuICBlbHNlXG4gICAgdHJ5XG4gICAgICBmb3IgaSA9IDAgdG8gcHJlZml4X2wgLSAxIGRvXG4gICAgICAgIGlmIHMuW2ldIDw+IHByZWZpeC5baV0gdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZG9uZTtcbiAgICAgIFNvbWUgKFN0cmluZy5zdWIgcyBwcmVmaXhfbCAoc3RyaW5nX2wgLSBwcmVmaXhfbCkpXG4gICAgd2l0aCBfIC0+IE5vbmVcblxubGV0IGRyb3AgcyBuID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbiA+PSBsXG4gIHRoZW4gXCJcIlxuICBlbHNlIFN0cmluZy5zdWIgcyBuIChsIC0gbilcblxubGV0IHRha2UgcyBuID1cbiAgaWYgbiA+PSBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBzXG4gIGVsc2UgU3RyaW5nLnN1YiBzIDAgblxuIl19
