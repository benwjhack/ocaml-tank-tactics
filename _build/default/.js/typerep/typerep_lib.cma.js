// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Typename_same_witness_exn=
      caml_string_of_jsbytes("Typename.same_witness_exn"),
     cst_Typename_create=caml_string_of_jsbytes("Typename.create"),
     cst_static=caml_string_of_jsbytes("static"),
     name$1=caml_string_of_jsbytes("int"),
     name$2=caml_string_of_jsbytes("int32"),
     name$3=caml_string_of_jsbytes("int64"),
     name$4=caml_string_of_jsbytes("nativeint"),
     name$5=caml_string_of_jsbytes("char"),
     name$6=caml_string_of_jsbytes("float"),
     name$7=caml_string_of_jsbytes("string"),
     name$8=caml_string_of_jsbytes("bytes"),
     name$9=caml_string_of_jsbytes("bool"),
     name$10=caml_string_of_jsbytes("unit"),
     name$11=caml_string_of_jsbytes("option"),
     name$12=caml_string_of_jsbytes("list"),
     name$13=caml_string_of_jsbytes("array"),
     name$14=caml_string_of_jsbytes("lazy_t"),
     name$15=caml_string_of_jsbytes("ref"),
     name$16=caml_string_of_jsbytes("function"),
     name$17=caml_string_of_jsbytes("tuple0"),
     name$18=caml_string_of_jsbytes("tuple2"),
     name$19=caml_string_of_jsbytes("tuple3"),
     name$20=caml_string_of_jsbytes("tuple4"),
     name$21=caml_string_of_jsbytes("tuple5"),
     cst_Latency_stats=caml_string_of_jsbytes("Latency_stats"),
     cst_zero=caml_string_of_jsbytes("zero"),
     cst_Typerep_lib_Type_generic_M$0=
      caml_string_of_jsbytes
       ("Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented"),
     cst_Typerep_lib_Type_generic_M=
      caml_string_of_jsbytes
       ("Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined"),
     cst_Typerep_lib_Type_generic_I=
      caml_string_of_jsbytes
       ("Typerep_lib.Type_generic.Ident.Broken_dependency"),
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib=global_data.Stdlib,
     Base=global_data.Base,
     Caml=global_data.Caml,
     Stdlib_Hashtbl=global_data.Stdlib__Hashtbl,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Array=global_data.Stdlib__Array,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Assert_failure=global_data.Assert_failure,
     CamlinternalMod=global_data.CamlinternalMod,
     Base_Int63=global_data.Base__Int63,
     Stdlib_Obj=global_data.Stdlib__Obj,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Typerep_lib=[0];
    caml_register_global(59,Typerep_lib,"Typerep_lib");
    var Typerep_lib_Named_intf=[0];
    caml_register_global(60,Typerep_lib_Named_intf,"Typerep_lib__Named_intf");
    var
     _a_=
      [0,
       [11,
        caml_string_of_jsbytes("Typename.Same_witness_exn "),
        [3,0,[12,32,[3,0,0]]]],
       caml_string_of_jsbytes("Typename.Same_witness_exn %S %S")],
     _l_=[0,0],
     _m_=[0,0],
     _n_=[0,0],
     _o_=[0,0],
     _p_=[0,0],
     _q_=[0,0],
     _r_=[0,0],
     _s_=[0,0],
     _t_=[0,0],
     _u_=[0,0],
     _v_=[0,0],
     _w_=[0,0],
     _x_=[0,0],
     _y_=[0,0],
     _z_=[0,0],
     _A_=[0,caml_string_of_jsbytes("lib/std_internal.ml"),802,14],
     _j_=
      [0,
       [0,
        [0,[0,0,0,0]],
        [0,[0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        0,
        0,
        0,
        0,
        0]],
     _k_=[0,caml_string_of_jsbytes("lib/std_internal.ml"),401,6],
     _B_=
      [0,
       [0,
        [0,[0,0,0,0]],
        [0,[0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        [0,[0]],
        [0,[0,0,0,0,0,0,0,0]],
        0,
        0,
        0,
        0,
        0]],
     _D_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),9,4],
     _C_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),11,4],
     _U_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),28,9],
     _T_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),29,9],
     _S_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),49,2],
     _G_=[0,caml_string_of_jsbytes("lib/typerep_obj.ml"),50,2],
     _J_=
      [0,
       [11,
        caml_string_of_jsbytes("Type_generic "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(" requires "),
          [3,0,[11,caml_string_of_jsbytes(" for uid "),[3,0,[12,10,0]]]]]]],
       caml_string_of_jsbytes("Type_generic %S requires %S for uid %S\n")],
     _H_=[0,caml_string_of_jsbytes("lib/type_generic.ml"),185,16],
     _I_=[0,caml_string_of_jsbytes("lib/type_generic.ml"),187,69],
     witness=0;
    function conv(param,x){return x}
    function Lift(X){function lift(param){return 0}return [0,lift]}
    var Typerep_lib_Type_equal=[0,conv,witness,Lift];
    caml_register_global(61,Typerep_lib_Type_equal,"Typerep_lib__Type_equal");
    function compare(a,b){return runtime.caml_int_compare(a[1],b[1])}
    function equal(a,b){return a[1] === b[1]?1:0}
    var uid=[0,0];
    function next(name){var code=uid[1];uid[1]++;return [0,code,name]}
    function hash(a){return caml_call1(Stdlib_Hashtbl[28],a[1])}
    function name(a){return a[2]}
    var static$0=next(cst_static);
    function cmp(k1,k2)
     {if(k1 === k2)return 0;
      var cmp$0=compare(k1[1],k2[1]);
      if(0 !== cmp$0)return cmp$0;
      var a=k1[2],b=k2[2];
      for(;;)
       {if(! a)return b?-1:0;
        if(! b)return 1;
        var ys=b[2],y=b[1],xs=a[2],x=a[1],n=cmp(x,y);
        if(0 !== n)return n;
        var a=xs,b=ys}}
    function equal$0(a,b){return 0 === cmp(a,b)?1:0}
    var hash$0=Stdlib_Hashtbl[28],unit=[0,static$0,0];
    function key(t){return t}
    function uid$0(t){return t[1]}
    function name$0(t){return t[1][2]}
    function create(opt,param)
     {if(opt)var sth=opt[1],name=sth;else var name=cst_Typename_create;
      return [0,next(name),0]}
    function same(nm1,nm2){return 0 === cmp(nm1,nm2)?1:0}
    function same_witness(nm1,nm2){return 0 === cmp(nm1,nm2)?[0,witness]:0}
    function same_witness_exn(nm1,nm2)
     {return 0 === cmp(nm1,nm2)
              ?witness
              :caml_call1(Stdlib[2],cst_Typename_same_witness_exn)}
    var Key_table=caml_call1(Stdlib_Hashtbl[26],[0,equal$0,hash$0]);
    function Table(X)
     {function create(int$0){return caml_call1(Key_table[1],int$0)}
      function mem(table,name){return caml_call2(Key_table[11],table,name)}
      function set(table,name,data)
       {return caml_call3(Key_table[10],table,name,[0,name,data])}
      function find(table,name)
       {try
         {var _ci_=[0,caml_call2(Key_table[7],table,name)],data=_ci_}
        catch(_cj_)
         {_cj_ = caml_wrap_exception(_cj_);
          if(_cj_[1] !== Base[205] && _cj_ !== Caml[8])throw _cj_;
          var data=0}
        if(! data)return 0;
        var match=data[1],data$0=match[2],name$0=match[1];
        return function(name$0,data)
                 {same_witness_exn(name$0,name);return [0,data]}
                (name$0,data$0)}
      return [0,create,mem,set,find]}
    function fail(uid_a,uid_b)
     {var msg=caml_call3(Stdlib_Printf[4],_a_,uid_a[2],uid_b[2]);
      return caml_call1(Stdlib[2],msg)}
    function Same_witness_exn_1(_ch_,B)
     {var
       uid_a=caml_call1(_ch_[1],unit)[1],
       uid_b=caml_call1(B[1],unit)[1],
       witness$0=equal(uid_a,uid_b)?[0,witness]:fail(uid_a,uid_b);
      return [0,witness$0]}
    function Same_witness_exn_2(_cg_,B)
     {var
       uid_a=caml_call2(_cg_[1],unit,unit)[1],
       uid_b=caml_call2(B[1],unit,unit)[1],
       witness$0=equal(uid_a,uid_b)?[0,witness]:fail(uid_a,uid_b);
      return [0,witness$0]}
    function Same_witness_exn_3(_cf_,B)
     {var
       uid_a=caml_call3(_cf_[1],unit,unit,unit)[1],
       uid_b=caml_call3(B[1],unit,unit,unit)[1],
       witness$0=equal(uid_a,uid_b)?[0,witness]:fail(uid_a,uid_b);
      return [0,witness$0]}
    function Same_witness_exn_4(_ce_,B)
     {var
       uid_a=caml_call4(_ce_[1],unit,unit,unit,unit)[1],
       uid_b=caml_call4(B[1],unit,unit,unit,unit)[1],
       witness$0=equal(uid_a,uid_b)?[0,witness]:fail(uid_a,uid_b);
      return [0,witness$0]}
    function Same_witness_exn_5(_cd_,B)
     {var
       uid_a=caml_call5(_cd_[1],unit,unit,unit,unit,unit)[1],
       uid_b=caml_call5(B[1],unit,unit,unit,unit,unit)[1],
       witness$0=equal(uid_a,uid_b)?[0,witness]:fail(uid_a,uid_b);
      return [0,witness$0]}
    function _b_(_cc_)
     {var uid=next(_cc_[1]);
      function typename_of_t(a,b,c,d,e)
       {return [0,uid,[0,a,[0,b,[0,c,[0,d,[0,e,0]]]]]]}
      return [0,typename_of_t]}
    function _c_(_cb_)
     {var uid=next(_cb_[1]);
      function typename_of_t(a,b,c,d)
       {return [0,uid,[0,a,[0,b,[0,c,[0,d,0]]]]]}
      return [0,typename_of_t]}
    function _d_(_ca_)
     {var uid=next(_ca_[1]);
      function typename_of_t(a,b,c){return [0,uid,[0,a,[0,b,[0,c,0]]]]}
      return [0,typename_of_t]}
    function _e_(_b$_)
     {var uid=next(_b$_[1]);
      function typename_of_t(a,b){return [0,uid,[0,a,[0,b,0]]]}
      return [0,typename_of_t]}
    function _f_(_b__)
     {var uid=next(_b__[1]);
      function typename_of_t(a){return [0,uid,[0,a,0]]}
      return [0,typename_of_t]}
    function _g_(_b9_)
     {var uid=next(_b9_[1]),typename_of_t=[0,uid,0];return [0,typename_of_t]}
    var
     _h_=[0,compare,equal,hash,name],
     _i_=[0,cmp,equal$0,hash$0],
     Typerep_lib_Typename=
      [0,
       create,
       unit,
       same,
       same_witness,
       same_witness_exn,
       _i_,
       key,
       _h_,
       uid$0,
       name$0,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_,
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
    caml_register_global(68,Typerep_lib_Typename,"Typerep_lib__Typename");
    function M(X)
     {var Tag_internal=[0];
      function label(t){return t[1]}
      function arity(t){return t[3]}
      function args_labels(t){return t[4]}
      function index(t){return t[5]}
      function ocaml_repr(t){return t[6]}
      function create(t){return t[8]}
      function tyid(t){return t[7]}
      function traverse(t){return t[2]}
      function internal_use_only(t){return t}
      var
       Tag=
        [0,
         label,
         arity,
         args_labels,
         index,
         ocaml_repr,
         create,
         tyid,
         traverse,
         internal_use_only],
       Variant_internal=[0];
      function typename_of_t(t){return t[1]}
      function length(t){return t[2].length - 1}
      function tag(t,index){return caml_check_bound(t[2],index)[1 + index]}
      function is_polymorphic(t){return t[3]}
      function value(t){return t[4]}
      function fold(t,init,f){return caml_call3(Stdlib_Array[17],f,init,t[2])}
      function internal_use_only$0(t){return t}
      var
       Variant=
        [0,
         typename_of_t,
         length,
         tag,
         is_polymorphic,
         value,
         fold,
         internal_use_only$0],
       Field_internal=[0];
      function label$0(t){return t[1]}
      function index$0(t){return t[3]}
      function get(t){return t[5]}
      function is_mutable(t){return t[6]}
      function tyid$0(t){return t[4]}
      function traverse$0(t){return t[2]}
      function internal_use_only$1(t){return t}
      var
       Field=
        [0,
         label$0,
         index$0,
         get,
         is_mutable,
         tyid$0,
         traverse$0,
         internal_use_only$1],
       Record_internal=[0];
      function typename_of_t$0(t){return t[1]}
      function length$0(t){return t[2].length - 1}
      function field(t,index){return caml_check_bound(t[2],index)[1 + index]}
      function has_double_array_tag(t){return t[3]}
      function create$0(t){return t[4]}
      function fold$0(t,init,f)
       {return caml_call3(Stdlib_Array[17],f,init,t[2])}
      function internal_use_only$2(t){return t}
      var
       Record=
        [0,
         typename_of_t$0,
         length$0,
         field,
         has_double_array_tag,
         create$0,
         fold$0,
         internal_use_only$2];
      return [0,
              Tag_internal,
              Tag,
              Variant_internal,
              Variant,
              Field_internal,
              Field,
              Record_internal,
              Record]}
    var Typerep_lib_Variant_and_record=[0,M];
    caml_register_global
     (70,
      Typerep_lib_Variant_and_record,
      "Typerep_lib__Variant_and_record_intf");
    var
     typename_of_int=_g_([0,name$1])[1],
     typename_of_int32=_g_([0,name$2])[1],
     typename_of_int64=_g_([0,name$3])[1],
     typename_of_nativeint=_g_([0,name$4])[1],
     typename_of_char=_g_([0,name$5])[1],
     typename_of_float=_g_([0,name$6])[1],
     typename_of_string=_g_([0,name$7])[1],
     typename_of_bytes=_g_([0,name$8])[1],
     typename_of_bool=_g_([0,name$9])[1],
     typename_of_unit=_g_([0,name$10])[1],
     M_option=_f_([0,name$11]),
     typename_of_option=M_option[1],
     M_list=_f_([0,name$12]),
     typename_of_list=M_list[1],
     M_array=_f_([0,name$13]),
     typename_of_array=M_array[1],
     M_lazy_t=_f_([0,name$14]),
     typename_of_lazy_t=M_lazy_t[1],
     M_ref=_f_([0,name$15]),
     typename_of_ref=M_ref[1],
     M_function=_e_([0,name$16]),
     typename_of_function=M_function[1],
     M_tuple0=_g_([0,name$17]),
     typename_of_tuple0=M_tuple0[1],
     M_tuple2=_e_([0,name$18]),
     typename_of_tuple2=M_tuple2[1],
     M_tuple3=_d_([0,name$19]),
     typename_of_tuple3=M_tuple3[1],
     M_tuple4=_c_([0,name$20]),
     typename_of_tuple4=M_tuple4[1],
     M_tuple5=_b_([0,name$21]),
     typename_of_tuple5=M_tuple5[1],
     Typerep=caml_call2(CamlinternalMod[1],_k_,_j_);
    function arity(param)
     {switch(param[0])
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        case 3:return 3;
        case 4:return 4;
        default:return 5}}
    function typename_of_t(param)
     {switch(param[0])
       {case 0:var rep=param[1];return rep[2];
        case 1:var rep$0=param[1];return rep$0[3];
        case 2:var rep$1=param[1];return rep$1[4];
        case 3:var rep$2=param[1];return rep$2[5];
        case 4:var rep$3=param[1];return rep$3[6];
        default:var rep$4=param[1];return rep$4[7]}}
    function name$22(rep)
     {var _b8_=typename_of_t(rep)[1];return caml_call1(_h_[4],_b8_)}
    var Named=[0,arity,typename_of_t,name$22];
    function arity$0(param)
     {switch(param[0])
       {case 0:return 2;case 1:return 3;case 2:return 4;default:return 5}}
    function typename_of_t$0(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          b=match[2],
          a=match[1],
          _bY_=caml_call1(Typerep[14],b);
         return caml_call2(typename_of_tuple2,caml_call1(Typerep[14],a),_bY_);
        case 1:
         var
          match$0=param[1],
          c=match$0[3],
          b$0=match$0[2],
          a$0=match$0[1],
          _bZ_=caml_call1(Typerep[14],c),
          _b0_=caml_call1(Typerep[14],b$0);
         return caml_call3
                 (typename_of_tuple3,caml_call1(Typerep[14],a$0),_b0_,_bZ_);
        case 2:
         var
          match$1=param[1],
          d=match$1[4],
          c$0=match$1[3],
          b$1=match$1[2],
          a$1=match$1[1],
          _b1_=caml_call1(Typerep[14],d),
          _b2_=caml_call1(Typerep[14],c$0),
          _b3_=caml_call1(Typerep[14],b$1);
         return caml_call4
                 (typename_of_tuple4,
                  caml_call1(Typerep[14],a$1),
                  _b3_,
                  _b2_,
                  _b1_);
        default:
         var
          match$2=param[1],
          e=match$2[5],
          d$0=match$2[4],
          c$1=match$2[3],
          b$2=match$2[2],
          a$2=match$2[1],
          _b4_=caml_call1(Typerep[14],e),
          _b5_=caml_call1(Typerep[14],d$0),
          _b6_=caml_call1(Typerep[14],c$1),
          _b7_=caml_call1(Typerep[14],b$2);
         return caml_call5
                 (typename_of_tuple5,
                  caml_call1(Typerep[14],a$2),
                  _b7_,
                  _b6_,
                  _b5_,
                  _b4_)}}
    var
     Tuple=[0,arity$0,typename_of_t$0],
     include=caml_call1(Typerep_lib_Variant_and_record[1],[0]),
     Tag_internal=include[1],
     Tag=include[2],
     Variant_internal=include[3],
     Variant=include[4],
     Field_internal=include[5],
     Field=include[6],
     Record_internal=include[7],
     Record=include[8];
    function typename_of_t$1(param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return typename_of_int;
         case 1:return typename_of_int32;
         case 2:return typename_of_int64;
         case 3:return typename_of_nativeint;
         case 4:return typename_of_char;
         case 5:return typename_of_float;
         case 6:return typename_of_string;
         case 7:return typename_of_bytes;
         case 8:return typename_of_bool;
         default:return typename_of_unit}
      switch(param[0])
       {case 0:
         var rep=param[1];
         return caml_call1(typename_of_option,typename_of_t$1(rep));
        case 1:
         var rep$0=param[1];
         return caml_call1(typename_of_list,typename_of_t$1(rep$0));
        case 2:
         var rep$1=param[1];
         return caml_call1(typename_of_array,typename_of_t$1(rep$1));
        case 3:
         var rep$2=param[1];
         return caml_call1(typename_of_lazy_t,typename_of_t$1(rep$2));
        case 4:
         var rep$3=param[1];
         return caml_call1(typename_of_ref,typename_of_t$1(rep$3));
        case 5:
         var
          match=param[1],
          rng=match[2],
          dom=match[1],
          _bX_=typename_of_t$1(rng);
         return caml_call2(typename_of_function,typename_of_t$1(dom),_bX_);
        case 6:var rep$4=param[1];return caml_call1(Typerep[2][2],rep$4);
        case 7:var rep$5=param[1];return caml_call1(Typerep[10][1],rep$5);
        case 8:var rep$6=param[1];return caml_call1(Typerep[6][1],rep$6);
        default:
         var match$0=param[1],name=match$0[1];return caml_call1(Named[2],name)}}
    function same_witness$0(t1,t2)
     {var t1$0=t1,t2$0=t2;
      for(;;)
       {var switch$0=0;
        if(typeof t1$0 === "number")
         switch(t1$0)
          {case 0:
            if(typeof t2$0 === "number")
             {if(0 === t2$0)return _l_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 1:
            if(typeof t2$0 === "number")
             {if(1 === t2$0)return _m_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 2:
            if(typeof t2$0 === "number")
             {if(2 === t2$0)return _n_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 3:
            if(typeof t2$0 === "number")
             {if(3 === t2$0)return _o_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 4:
            if(typeof t2$0 === "number")
             {if(4 === t2$0)return _p_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 5:
            if(typeof t2$0 === "number")
             {if(5 === t2$0)return _q_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 6:
            if(typeof t2$0 === "number")
             {if(6 === t2$0)return _r_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 7:
            if(typeof t2$0 === "number")
             {if(7 === t2$0)return _s_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           case 8:
            if(typeof t2$0 === "number")
             {if(8 === t2$0)return _t_}
            else
             if(9 === t2$0[0])switch$0 = 1;
            break;
           default:
            if(typeof t2$0 === "number")
             {if(9 === t2$0)return _u_}
            else
             if(9 === t2$0[0])switch$0 = 1}
        else
         switch(t1$0[0])
          {case 0:
            var switch$1=0,_bu_=t1$0[1];
            if(typeof t2$0 !== "number")
             switch(t2$0[0])
              {case 0:
                var r2$0=t2$0[1],x=same_witness$0(_bu_,r2$0);return x?x:x;
               case 9:switch$0 = 1;switch$1 = 1;break
               }
            break;
           case 1:
            var switch$2=0,_bv_=t1$0[1];
            if(typeof t2$0 !== "number")
             switch(t2$0[0])
              {case 1:
                var r2$1=t2$0[1],x$0=same_witness$0(_bv_,r2$1);
                return x$0?x$0:x$0;
               case 9:switch$0 = 1;switch$2 = 1;break
               }
            break;
           case 2:
            var switch$3=0,_bw_=t1$0[1];
            if(typeof t2$0 === "number")
             switch$3 = 1;
            else
             switch(t2$0[0])
              {case 2:
                var r2$2=t2$0[1],x$1=same_witness$0(_bw_,r2$2);
                return x$1?x$1:x$1;
               case 9:switch$0 = 1;break;
               default:switch$3 = 1}
            break;
           case 3:
            var switch$4=0,_bx_=t1$0[1];
            if(typeof t2$0 === "number")
             switch$4 = 1;
            else
             switch(t2$0[0])
              {case 3:
                var r2$3=t2$0[1],x$2=same_witness$0(_bx_,r2$3);
                return x$2?x$2:x$2;
               case 9:switch$0 = 1;break;
               default:switch$4 = 1}
            break;
           case 4:
            var switch$5=0,_by_=t1$0[1];
            if(typeof t2$0 === "number")
             switch$5 = 1;
            else
             switch(t2$0[0])
              {case 4:
                var r2$4=t2$0[1],x$3=same_witness$0(_by_,r2$4);
                return x$3?x$3:x$3;
               case 9:switch$0 = 1;break;
               default:switch$5 = 1}
            break;
           case 5:
            var _bz_=t1$0[1],switch$6=0,_bA_=_bz_[2],_bB_=_bz_[1];
            if(typeof t2$0 === "number")
             switch$6 = 1;
            else
             switch(t2$0[0])
              {case 5:
                var
                 match$0=t2$0[1],
                 rng2=match$0[2],
                 dom2=match$0[1],
                 match$1=same_witness$0(_bB_,dom2),
                 match$2=same_witness$0(_bA_,rng2);
                if(match$1 && match$2)return _v_;
                return 0;
               case 9:switch$0 = 1;break;
               default:switch$6 = 1}
            break;
           case 6:
            var _bC_=t1$0[1],switch$7=0;
            if(typeof t2$0 === "number")
             switch$7 = 1;
            else
             switch(t2$0[0])
              {case 6:
                var t2$2=t2$0[1];
                switch(_bC_[0])
                 {case 0:
                   var _bD_=_bC_[1];
                   if(0 !== t2$2[0])return 0;
                   var
                    match$3=t2$2[1],
                    b2=match$3[2],
                    a2=match$3[1],
                    b1=_bD_[2],
                    a1=_bD_[1],
                    match$4=same_witness$0(a1,a2),
                    match$5=same_witness$0(b1,b2);
                   if(match$4 && match$5)return _w_;
                   return 0;
                  case 1:
                   var _bE_=_bC_[1];
                   if(1 !== t2$2[0])return 0;
                   var
                    match$6=t2$2[1],
                    c2=match$6[3],
                    b2$0=match$6[2],
                    a2$0=match$6[1],
                    c1=_bE_[3],
                    b1$0=_bE_[2],
                    a1$0=_bE_[1],
                    match$7=same_witness$0(a1$0,a2$0),
                    match$8=same_witness$0(b1$0,b2$0),
                    match$9=same_witness$0(c1,c2);
                   if(match$7 && match$8 && match$9)return _x_;
                   return 0;
                  case 2:
                   var _bF_=_bC_[1];
                   if(2 !== t2$2[0])return 0;
                   var
                    match$10=t2$2[1],
                    d2=match$10[4],
                    c2$0=match$10[3],
                    b2$1=match$10[2],
                    a2$1=match$10[1],
                    d1=_bF_[4],
                    c1$0=_bF_[3],
                    b1$1=_bF_[2],
                    a1$1=_bF_[1],
                    match$11=same_witness$0(a1$1,a2$1),
                    match$12=same_witness$0(b1$1,b2$1),
                    match$13=same_witness$0(c1$0,c2$0),
                    match$14=same_witness$0(d1,d2);
                   if(match$11 && match$12 && match$13 && match$14)return _y_;
                   return 0;
                  default:
                   var _bG_=_bC_[1];
                   if(3 !== t2$2[0])return 0;
                   var
                    match$15=t2$2[1],
                    e2=match$15[5],
                    d2$0=match$15[4],
                    c2$1=match$15[3],
                    b2$2=match$15[2],
                    a2$2=match$15[1],
                    e1=_bG_[5],
                    d1$0=_bG_[4],
                    c1$1=_bG_[3],
                    b1$2=_bG_[2],
                    a1$2=_bG_[1],
                    match$16=same_witness$0(a1$2,a2$2),
                    match$17=same_witness$0(b1$2,b2$2),
                    match$18=same_witness$0(c1$1,c2$1),
                    match$19=same_witness$0(d1$0,d2$0),
                    match$20=same_witness$0(e1,e2);
                   if(match$16 && match$17 && match$18 && match$19 && match$20)
                    return _z_;
                   return 0}
               case 9:switch$0 = 1;break;
               default:switch$7 = 1}
            break;
           case 7:
            var switch$8=0,_bH_=t1$0[1];
            if(typeof t2$0 === "number")
             switch$8 = 1;
            else
             switch(t2$0[0])
              {case 7:
                var r2$5=t2$0[1],_bI_=caml_call1(Typerep[10][1],r2$5);
                return same_witness(caml_call1(Typerep[10][1],_bH_),_bI_);
               case 9:switch$0 = 1;break;
               default:switch$8 = 1}
            break;
           case 8:
            var switch$9=0,_bJ_=t1$0[1];
            if(typeof t2$0 === "number")
             switch$9 = 1;
            else
             switch(t2$0[0])
              {case 8:
                var r2$6=t2$0[1],_bK_=caml_call1(Typerep[6][1],r2$6);
                return same_witness(caml_call1(Typerep[6][1],_bJ_),_bK_);
               case 9:switch$0 = 1;break;
               default:switch$9 = 1}
            break;
           default:
            var _bL_=t1$0[1],_bM_=_bL_[1];
            if(typeof t2$0 !== "number" && 9 === t2$0[0])
             {var
               match$21=t2$0[1],
               r2$7=match$21[2],
               name2=match$21[1],
               r1$0=_bL_[2],
               _bP_=caml_call1(Named[2],name2),
               x$4=same_witness(caml_call1(Named[2],_bM_),_bP_);
              if(x$4)return x$4;
              if(! r1$0)
               {if(! r2$7)return 0;
                var
                 _bV_=r2$7[1],
                 _bW_=caml_obj_tag(_bV_),
                 t2$4=
                  250 === _bW_
                   ?_bV_[1]
                   :246 === _bW_?caml_call1(CamlinternalLazy[2],_bV_):_bV_,
                 t2$0=t2$4;
                continue}
              var
               _bQ_=r1$0[1],
               _bR_=caml_obj_tag(_bQ_),
               _bS_=
                250 === _bR_
                 ?_bQ_[1]
                 :246 === _bR_?caml_call1(CamlinternalLazy[2],_bQ_):_bQ_;
              if(r2$7)
               {var
                 _bT_=r2$7[1],
                 _bU_=caml_obj_tag(_bT_),
                 t2$3=
                  250 === _bU_
                   ?_bT_[1]
                   :246 === _bU_?caml_call1(CamlinternalLazy[2],_bT_):_bT_,
                 t1$0=_bS_,
                 t2$0=t2$3;
                continue}
              var t1$0=_bS_;
              continue}
            var r1=_bL_[2];
            if(! r1)return 0;
            var
             _bN_=r1[1],
             _bO_=caml_obj_tag(_bN_),
             t1$1=
              250 === _bO_
               ?_bN_[1]
               :246 === _bO_?caml_call1(CamlinternalLazy[2],_bN_):_bN_,
             t1$0=t1$1;
            continue}
        if(switch$0)
         {var match=t2$0[1],r2=match[2];
          if(! r2)return 0;
          var
           _bs_=r2[1],
           _bt_=caml_obj_tag(_bs_),
           t2$1=
            250 === _bt_
             ?_bs_[1]
             :246 === _bt_?caml_call1(CamlinternalLazy[2],_bs_):_bs_,
           t2$0=t2$1;
          continue}
        if(typeof t1$0 === "number")
         switch(t1$0)
          {case 0:break;
           case 1:return 0;
           case 2:return 0;
           case 3:return 0;
           case 4:return 0;
           case 5:return 0;
           case 6:return 0;
           case 7:return 0;
           case 8:return 0;
           default:return 0}
        else
         switch(t1$0[0])
          {case 9:break;
           case 0:return 0;
           case 1:return 0;
           case 2:return 0;
           case 3:return 0;
           case 4:return 0;
           case 5:return 0;
           case 6:return 0;
           case 7:return 0;
           default:return 0}
        return 0}}
    function same$0(a,b){return 0 !== same_witness$0(a,b)?1:0}
    function same_witness_exn$0(a,b)
     {var match=same_witness$0(a,b);
      if(! match)throw [0,Assert_failure,_A_];
      var proof=match[1];
      return proof}
    function head(t)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 !== "number" && 9 === t$0[0])
         {var _bp_=t$0[1][2];
          if(_bp_)
           {var
             _bq_=_bp_[1],
             _br_=caml_obj_tag(_bq_),
             t$1=
              250 === _br_
               ?_bq_[1]
               :246 === _br_?caml_call1(CamlinternalLazy[2],_bq_):_bq_,
             t$0=t$1;
            continue}}
        return t$0}}
    caml_call3
     (CamlinternalMod[2],
      _B_,
      Typerep,
      [0,
       Named,
       Tuple,
       Tag_internal,
       Tag,
       Variant_internal,
       Variant,
       Field_internal,
       Field,
       Record_internal,
       Record,
       same$0,
       same_witness$0,
       same_witness_exn$0,
       typename_of_t$1,
       head]);
    var
     typerep_of_int=0,
     typerep_of_int32=1,
     typerep_of_int64=2,
     typerep_of_nativeint=3,
     typerep_of_char=4,
     typerep_of_float=5,
     typerep_of_string=6,
     typerep_of_bytes=7,
     typerep_of_bool=8,
     typerep_of_unit=9;
    function typerep_of_option(rep){return [0,rep]}
    function typerep_of_list(rep){return [1,rep]}
    function typerep_of_array(rep){return [2,rep]}
    function typerep_of_lazy_t(rep){return [3,rep]}
    function typerep_of_ref(rep){return [4,rep]}
    function typerep_of_function(dom,rng){return [5,[0,dom,rng]]}
    var typerep_of_tuple0=9;
    function typerep_of_tuple2(a,b){return [6,[0,[0,a,b]]]}
    function typerep_of_tuple3(a,b,c){return [6,[1,[0,a,b,c]]]}
    function typerep_of_tuple4(a,b,c,d){return [6,[2,[0,a,b,c,d]]]}
    function typerep_of_tuple5(a,b,c,d,e){return [6,[3,[0,a,b,c,d,e]]]}
    var
     value_tuple0=0,
     match=
      Base_Int63[114][2]
       ?[0,typerep_of_int64,typename_of_int64]
       :[0,typerep_of_int,typename_of_int],
     typename_of_int63=match[2],
     typerep_of_int63=match[1],
     include$0=
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
    caml_register_global(75,include$0,"Typerep_lib__Std_internal");
    var Typerep_lib_Typerepable=[0];
    caml_register_global
     (76,Typerep_lib_Typerepable,"Typerep_lib__Typerepable");
    function repr_of_poly_variant(obj)
     {if(typeof obj === "number")return obj;
      var size=obj.length - 1;
      if(2 !== size)throw [0,Assert_failure,_D_];
      var repr=obj[1];
      if(typeof repr === "number")return repr;
      throw [0,Assert_failure,_C_]}
    function hash_variant(s)
     {var accu=[0,0],_bm_=runtime.caml_ml_string_length(s) - 1 | 0,_bl_=0;
      if(_bm_ >= 0)
       {var i=_bl_;
        for(;;)
         {var _bn_=runtime.caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _bn_ | 0;
          var _bo_=i + 1 | 0;
          if(_bm_ !== i){var i=_bo_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      return 1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1]}
    var _E_=hash_variant(cst_Latency_stats);
    if(repr_of_poly_variant(-894644482) !== _E_)throw [0,Assert_failure,_U_];
    var _F_=hash_variant(cst_zero);
    if(repr_of_poly_variant(-789508312) !== _F_)throw [0,Assert_failure,_T_];
    var double_array_value=0.;
    function has_double_array_tag(a)
     {var _bk_=caml_obj_tag(a);return Stdlib_Obj[15] === _bk_?1:0}
    var
     double$0=[254,double_array_value,double_array_value],
     simple=[0,double_array_value,double_array_value];
    if(! has_double_array_tag(double$0))throw [0,Assert_failure,_S_];
    if(has_double_array_tag(simple))throw [0,Assert_failure,_G_];
    var
     Typerep_lib_Typerep_obj=
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
    caml_register_global
     (78,Typerep_lib_Typerep_obj,"Typerep_lib__Typerep_obj");
    function M$0(X){return [0]}
    var Typerep_lib_Type_generic_intf=[0,M$0];
    caml_register_global
     (79,Typerep_lib_Type_generic_intf,"Typerep_lib__Type_generic_intf");
    function Helper(A,B)
     {function map_variant(param,variant)
       {var
         map=param[1],
         typename=caml_call1(A[4][1],variant),
         polymorphic=caml_call1(A[4][4],variant);
        function _bg_(index$0)
         {var
           tag$0=caml_call2(A[4][3],variant,index$0),
           tag=tag$0[1],
           label=caml_call1(A[2][1],tag),
           rep=caml_call1(map,caml_call1(A[2][8],tag)),
           arity=caml_call1(A[2][2],tag),
           args_labels=caml_call1(A[2][3],tag),
           index=caml_call1(A[2][4],tag),
           ocaml_repr=caml_call1(A[2][5],tag),
           tyid=caml_call1(A[2][7],tag),
           param=caml_call1(A[2][6],tag);
          if(0 === param[0])
           var fct=param[1],create=[0,fct];
          else
           var k=param[1],create=[1,k];
          return [0,
                  caml_call1
                   (B[2][9],
                    [0,label,rep,arity,args_labels,index,ocaml_repr,tyid,create])]}
        var
         _bh_=caml_call1(A[4][2],variant),
         tags=caml_call2(Stdlib_Array[2],_bh_,_bg_);
        function value(a)
         {var
           match=caml_call2(A[4][5],variant,a),
           a$0=match[2],
           atag=match[1],
           _bi_=caml_call1(A[2][4],atag),
           match$0=caml_check_bound(tags,_bi_)[1 + _bi_],
           btag=match$0[1],
           _bj_=caml_call1(B[2][7],btag);
          same_witness_exn(caml_call1(A[2][7],atag),_bj_);
          return [0,btag,a$0]}
        return caml_call1(B[4][7],[0,typename,tags,polymorphic,value])}
      function map_record(param,record)
       {var
         map=param[1],
         typename=caml_call1(A[8][1],record),
         has_double_array_tag=caml_call1(A[8][4],record);
        function _bc_(index$0)
         {var
           field$0=caml_call2(A[8][3],record,index$0),
           field=field$0[1],
           label=caml_call1(A[6][1],field),
           rep=caml_call1(map,caml_call1(A[6][6],field)),
           index=caml_call1(A[6][2],field),
           is_mutable=caml_call1(A[6][4],field),
           tyid=caml_call1(A[6][5],field),
           get=caml_call1(A[6][3],field);
          return [0,
                  caml_call1(B[6][7],[0,label,rep,index,tyid,get,is_mutable])]}
        var
         _bd_=caml_call1(A[8][2],record),
         fields=caml_call2(Stdlib_Array[2],_bd_,_bc_);
        function create(param)
         {var get=param[1];
          function get$0(afield)
           {var
             _be_=caml_call1(A[6][2],afield),
             match=caml_check_bound(fields,_be_)[1 + _be_],
             bfield=match[1],
             _bf_=caml_call1(B[6][5],bfield);
            same_witness_exn(caml_call1(A[6][5],afield),_bf_);
            return caml_call1(get,bfield)}
          return caml_call2(A[8][5],record,[0,get$0])}
        return caml_call1
                (B[8][7],[0,typename,fields,has_double_array_tag,create])}
      return [0,map_variant,map_record]}
    var
     Broken_dependency=
      [248,cst_Typerep_lib_Type_generic_I,caml_fresh_oo_id(0)];
    caml_call1(Stdlib_Hashtbl[26],[0,_i_[2],_i_[3]]);
    function _K_(X)
     {var
       _aq_=X[2],
       _ar_=X[1],
       include=caml_call1(Stdlib_Hashtbl[26],[0,_h_[2],_h_[3]]),
       _am_=include[1],
       _an_=include[7],
       _ao_=include[10],
       _ap_=include[11];
      function find(table,key)
       {if(! caml_call1(Stdlib_Lazy[3],table))return 0;
        var
         _a$_=caml_obj_tag(table),
         table$0=
          250 === _a$_
           ?table[1]
           :246 === _a$_?caml_call1(CamlinternalLazy[2],table):table;
        try
         {var _ba_=[0,caml_call2(_an_,table$0,key)];return _ba_}
        catch(_bb_)
         {_bb_ = caml_wrap_exception(_bb_);
          if(_bb_[1] !== Base[205] && _bb_ !== Caml[8])throw _bb_;
          return 0}}
      var
       check_dependencies=
        _aq_
         ?function(uid)
           {function _a8_(param)
             {var
               implements$0=param[2],
               name=param[1],
               _a9_=1 - caml_call1(implements$0,uid);
              if(! _a9_)return _a9_;
              var
               _a__=caml_call1(_h_[4],uid),
               message=caml_call4(Stdlib_Printf[4],_J_,_ar_,name,_a__);
              caml_call1(Stdlib[53],message);
              throw [0,Broken_dependency,message]}
            return caml_call2(Stdlib_List[17],_a8_,_aq_)}
         :function(param){return 0};
      function replace(table,key,value)
       {check_dependencies(key);
        var
         _a6_=caml_obj_tag(table),
         _a7_=
          250 === _a6_
           ?table[1]
           :246 === _a6_?caml_call1(CamlinternalLazy[2],table):table;
        return caml_call3(_ao_,_a7_,key,value)}
      function mem(table,key)
       {if(! caml_call1(Stdlib_Lazy[3],table))return 0;
        var
         _a5_=caml_obj_tag(table),
         table$0=
          250 === _a5_
           ?table[1]
           :246 === _a5_?caml_call1(CamlinternalLazy[2],table):table;
        return caml_call2(_ap_,table$0,key)}
      var
       size=256,
       table0=[246,function(_a4_){return caml_call1(_am_,size)}],
       table1=[246,function(_a3_){return caml_call1(_am_,size)}],
       table2=[246,function(_a2_){return caml_call1(_am_,size)}],
       table3=[246,function(_a1_){return caml_call1(_am_,size)}],
       table4=[246,function(_a0_){return caml_call1(_am_,size)}],
       table5=[246,function(_aZ_){return caml_call1(_am_,size)}];
      function is_registered(uid)
       {var _aT_=mem(table0,uid);
        if(_aT_)
         var _aU_=_aT_;
        else
         {var _aV_=mem(table1,uid);
          if(_aV_)
           var _aU_=_aV_;
          else
           {var _aW_=mem(table2,uid);
            if(_aW_)
             var _aU_=_aW_;
            else
             {var _aX_=mem(table3,uid);
              if(_aX_)
               var _aU_=_aX_;
              else
               {var _aY_=mem(table4,uid);
                if(! _aY_)return mem(table5,uid);
                var _aU_=_aY_}}}}
        return _aU_}
      var ident=[0,_ar_,is_registered];
      function register0(compute)
       {var uid=compute[2][1];return replace(table0,uid,compute)}
      function register1(compute)
       {var uid=caml_call1(compute[2],unit)[1];
        return replace(table1,uid,compute)}
      function register2(compute)
       {var uid=caml_call2(compute[2],unit,unit)[1];
        return replace(table2,uid,compute)}
      function register3(compute)
       {var uid=caml_call3(compute[2],unit,unit,unit)[1];
        return replace(table3,uid,compute)}
      function register4(compute)
       {var uid=caml_call4(compute[2],unit,unit,unit,unit)[1];
        return replace(table4,uid,compute)}
      function register5(compute)
       {var uid=caml_call5(compute[2],unit,unit,unit,unit,unit)[1];
        return replace(table5,uid,compute)}
      function register(typerep_of_a,compute)
       {var typename_of_t=caml_call1(Typerep[14],typerep_of_a);
        return register0([0,typerep_of_a,typename_of_t,compute])}
      var
       Not_implemented=
        [248,cst_Typerep_lib_Type_generic_M$0,caml_fresh_oo_id(0)],
       Memo=Table([0]),
       Helper$0=
        Helper
         ([0,
           Typerep[3],
           Typerep[4],
           Typerep[5],
           Typerep[6],
           Typerep[7],
           Typerep[8],
           Typerep[9],
           Typerep[10]],
          [0,X[3],X[4],X[5],X[6],X[7],X[8],X[9],X[10]]);
      function of_typerep(rep)
       {var
         context=caml_call1(X[33][1][1],0),
         memo_table=caml_call1(Memo[1],32);
        function of_typerep(param)
         {var param$0=param;
          for(;;)
           {if(typeof param$0 === "number")
             switch(param$0)
              {case 0:return X[11];
               case 1:return X[12];
               case 2:return X[13];
               case 3:return X[14];
               case 4:return X[15];
               case 5:return X[16];
               case 6:return X[17];
               case 7:return X[18];
               case 8:return X[19];
               default:return X[20]}
            switch(param$0[0])
             {case 0:
               var rep$11=param$0[1],_aI_=of_typerep(rep$11);
               return caml_call1(X[21],_aI_);
              case 1:
               var rep$12=param$0[1],_aJ_=of_typerep(rep$12);
               return caml_call1(X[22],_aJ_);
              case 2:
               var rep$13=param$0[1],_aK_=of_typerep(rep$13);
               return caml_call1(X[23],_aK_);
              case 3:
               var rep$14=param$0[1],_aL_=of_typerep(rep$14);
               return caml_call1(X[24],_aL_);
              case 4:
               var rep$15=param$0[1],_aM_=of_typerep(rep$15);
               return caml_call1(X[25],_aM_);
              case 5:
               var
                match$11=param$0[1],
                rng=match$11[2],
                dom=match$11[1],
                _aN_=of_typerep(rng),
                _aO_=of_typerep(dom);
               return caml_call2(X[26],_aO_,_aN_);
              case 6:
               var tuple=param$0[1];
               switch(tuple[0])
                {case 0:
                  var
                   match$12=tuple[1],
                   b=match$12[2],
                   a=match$12[1],
                   ra=of_typerep(a),
                   rb=of_typerep(b);
                  return caml_call2(X[27],ra,rb);
                 case 1:
                  var
                   match$13=tuple[1],
                   c=match$13[3],
                   b$0=match$13[2],
                   a$0=match$13[1],
                   ra$0=of_typerep(a$0),
                   rb$0=of_typerep(b$0),
                   rc=of_typerep(c);
                  return caml_call3(X[28],ra$0,rb$0,rc);
                 case 2:
                  var
                   match$14=tuple[1],
                   d=match$14[4],
                   c$0=match$14[3],
                   b$1=match$14[2],
                   a$1=match$14[1],
                   ra$1=of_typerep(a$1),
                   rb$1=of_typerep(b$1),
                   rc$0=of_typerep(c$0),
                   rd=of_typerep(d);
                  return caml_call4(X[29],ra$1,rb$1,rc$0,rd);
                 default:
                  var
                   match$15=tuple[1],
                   e=match$15[5],
                   d$0=match$15[4],
                   c$1=match$15[3],
                   b$2=match$15[2],
                   a$2=match$15[1],
                   ra$2=of_typerep(a$2),
                   rb$2=of_typerep(b$2),
                   rc$1=of_typerep(c$1),
                   rd$0=of_typerep(d$0),
                   re=of_typerep(e);
                  return caml_call5(X[30],ra$2,rb$2,rc$1,rd$0,re)}
              case 7:
               var
                record=param$0[1],
                _aP_=caml_call2(Helper$0[2],[0,of_typerep],record);
               return caml_call1(X[31],_aP_);
              case 8:
               var
                variant=param$0[1],
                _aQ_=caml_call2(Helper$0[1],[0,of_typerep],variant);
               return caml_call1(X[32],_aQ_);
              default:
               var
                match$16=param$0[1],
                content=match$16[2],
                named=match$16[1],
                typename=caml_call1(Typerep[1][2],named),
                match$17=caml_call2(Memo[4],memo_table,typename);
               if(match$17)
                {var shared=match$17[1];return caml_call1(X[33][3],shared)}
               switch(named[0])
                {case 0:
                  var rep$5=named[1],match=find(table0,rep$5[2][1]);
                  if(match)
                   {var
                     rep=match[1],
                     witness=same_witness_exn(rep[2],rep$5[1]),
                     L=Lift([0]),
                     _as_=rep[3];
                    caml_call1(L[1],witness);
                    var match$5=[0,_as_]}
                  else
                   var match$5=0;
                  if(match$5)
                   var custom=match$5[1],match$18=[0,custom];
                  else
                   var match$18=0;
                  break;
                 case 1:
                  var rep$6=named[1],match$0=find(table1,rep$6[3][1]);
                  if(match$0)
                   {var
                     rep$0=match$0[1],
                     typename_of_t=rep$6[2],
                     Conv$3=Same_witness_exn_1([0,rep$0[2]],[0,typename_of_t]),
                     L$0=Lift([0]),
                     _at_=rep$0[3];
                    caml_call1(L$0[1],Conv$3[1][1]);
                    var match$6=[0,_at_]}
                  else
                   var match$6=0;
                  if(match$6)
                   var
                    custom$0=match$6[1],
                    custom$1=caml_call1(custom$0,of_typerep(rep$6[1])),
                    match$18=[0,custom$1];
                  else
                   var match$18=0;
                  break;
                 case 2:
                  var rep$7=named[1],match$1=find(table2,rep$7[4][1]);
                  if(match$1)
                   {var
                     rep$1=match$1[1],
                     typename_of_t$0=rep$7[3],
                     Conv$2=Same_witness_exn_2([0,rep$1[2]],[0,typename_of_t$0]),
                     L$1=Lift([0]),
                     _au_=rep$1[3];
                    caml_call1(L$1[1],Conv$2[1][1]);
                    var match$7=[0,_au_]}
                  else
                   var match$7=0;
                  if(match$7)
                   var
                    custom$2=match$7[1],
                    _ay_=of_typerep(rep$7[2]),
                    custom$3=caml_call2(custom$2,of_typerep(rep$7[1]),_ay_),
                    match$18=[0,custom$3];
                  else
                   var match$18=0;
                  break;
                 case 3:
                  var rep$8=named[1],match$2=find(table3,rep$8[5][1]);
                  if(match$2)
                   {var
                     rep$2=match$2[1],
                     typename_of_t$1=rep$8[4],
                     Conv$1=Same_witness_exn_3([0,rep$2[2]],[0,typename_of_t$1]),
                     L$2=Lift([0]),
                     _av_=rep$2[3];
                    caml_call1(L$2[1],Conv$1[1][1]);
                    var match$8=[0,_av_]}
                  else
                   var match$8=0;
                  if(match$8)
                   var
                    custom$4=match$8[1],
                    _az_=of_typerep(rep$8[3]),
                    _aA_=of_typerep(rep$8[2]),
                    custom$5=caml_call3(custom$4,of_typerep(rep$8[1]),_aA_,_az_),
                    match$18=[0,custom$5];
                  else
                   var match$18=0;
                  break;
                 case 4:
                  var rep$9=named[1],match$3=find(table4,rep$9[6][1]);
                  if(match$3)
                   {var
                     rep$3=match$3[1],
                     typename_of_t$2=rep$9[5],
                     Conv$0=Same_witness_exn_4([0,rep$3[2]],[0,typename_of_t$2]),
                     L$3=Lift([0]),
                     _aw_=rep$3[3];
                    caml_call1(L$3[1],Conv$0[1][1]);
                    var match$9=[0,_aw_]}
                  else
                   var match$9=0;
                  if(match$9)
                   var
                    custom$6=match$9[1],
                    _aB_=of_typerep(rep$9[4]),
                    _aC_=of_typerep(rep$9[3]),
                    _aD_=of_typerep(rep$9[2]),
                    custom$7=
                     caml_call4(custom$6,of_typerep(rep$9[1]),_aD_,_aC_,_aB_),
                    match$18=[0,custom$7];
                  else
                   var match$18=0;
                  break;
                 default:
                  var rep$10=named[1],match$4=find(table5,rep$10[7][1]);
                  if(match$4)
                   {var
                     rep$4=match$4[1],
                     typename_of_t$3=rep$10[6],
                     Conv=Same_witness_exn_5([0,rep$4[2]],[0,typename_of_t$3]),
                     L$4=Lift([0]),
                     _ax_=rep$4[3];
                    caml_call1(L$4[1],Conv[1][1]);
                    var match$10=[0,_ax_]}
                  else
                   var match$10=0;
                  if(match$10)
                   var
                    custom$8=match$10[1],
                    _aE_=of_typerep(rep$10[5]),
                    _aF_=of_typerep(rep$10[4]),
                    _aG_=of_typerep(rep$10[3]),
                    _aH_=of_typerep(rep$10[2]),
                    custom$9=
                     caml_call5
                      (custom$8,of_typerep(rep$10[1]),_aH_,_aG_,_aF_,_aE_),
                    match$18=[0,custom$9];
                  else
                   var match$18=0}
               if(match$18){var computation=match$18[1];return computation}
               if(! content)
                {var string=caml_call1(_h_[4],typename[1]);
                 throw [0,Not_implemented,_ar_,string]}
               var
                _aR_=content[1],
                _aS_=caml_obj_tag(_aR_),
                content$0=
                 250 === _aS_
                  ?_aR_[1]
                  :246 === _aS_?caml_call1(CamlinternalLazy[2],_aR_):_aR_;
               if(caml_call1(X[33][5],content$0))
                {var shared$0=caml_call2(X[33][2],context,typename);
                 caml_call3(Memo[3],memo_table,typename,shared$0);
                 var computation$0=of_typerep(content$0);
                 return caml_call2(X[33][4],shared$0,computation$0)}
               var param$0=content$0;
               continue}}}
        var computation=of_typerep(rep);
        return [0,911962647,computation]}
      return [0,
              ident,
              Not_implemented,
              register0,
              register1,
              register2,
              register3,
              register4,
              register5,
              register,
              of_typerep,
              [0,
               X[3],
               X[4],
               X[5],
               X[6],
               X[7],
               X[8],
               X[9],
               X[10],
               X[11],
               X[12],
               X[13],
               X[14],
               X[15],
               X[16],
               X[17],
               X[18],
               X[19],
               X[20],
               X[21],
               X[22],
               X[23],
               X[24],
               X[25],
               X[26],
               X[27],
               X[28],
               X[29],
               X[30],
               X[31],
               X[32],
               X[33]]]}
    var
     _L_=[0],
     Typerep_lib_Type_generic=
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_ai_)
        {function create(_al_){return 0}
         var
          Context=[0,create],
          Undefined=[248,cst_Typerep_lib_Type_generic_M,caml_fresh_oo_id(0)];
         function init(param,name)
          {var
            path=caml_call1(_h_[4],name[1]),
            r=[0,function(param){throw [0,Undefined,path]}],
            _ak_=[0,0];
           return [0,function(input){return caml_call1(r[1],input)},r,_ak_]}
         function get_wip_computation(shared)
          {var _aj_=shared[3][1];
           if(! _aj_)return shared[1];
           var clos=_aj_[1];
           return clos}
         function set_final_computation(shared,computation)
          {var compiletime_dereference=shared[3];
           if(compiletime_dereference[1])throw [0,Assert_failure,_H_];
           if(caml_call2(Base[203],shared[1],computation))
            throw [0,Assert_failure,_I_];
           compiletime_dereference[1] = [0,computation];
           shared[2][1] = computation;
           return computation}
         function share(param){return 1}
         return [0,
                 Context,
                 init,
                 get_wip_computation,
                 set_final_computation,
                 share]},
       _L_,
       _K_];
    caml_register_global
     (81,Typerep_lib_Type_generic,"Typerep_lib__Type_generic");
    function _M_(X)
     {var Name_of_x=_b_(X),typename_of_t=Name_of_x[1];
      function named(of_p1,of_p2,of_p3,of_p4,of_p5)
       {var
         _ad_=caml_call1(Typerep[14],of_p5),
         _ae_=caml_call1(Typerep[14],of_p4),
         _af_=caml_call1(Typerep[14],of_p3),
         _ag_=caml_call1(Typerep[14],of_p2),
         _ah_=caml_call1(Typerep[14],of_p1),
         typename_of_t=caml_call5(Name_of_x[1],_ah_,_ag_,_af_,_ae_,_ad_),
         typename_of_named=Name_of_x[1];
        return [5,
                [0,
                 of_p1,
                 of_p2,
                 of_p3,
                 of_p4,
                 of_p5,
                 typename_of_named,
                 typename_of_t,
                 witness]]}
      return [0,named,typename_of_t]}
    function _N_(X)
     {var Name_of_x=_c_(X),typename_of_t=Name_of_x[1];
      function named(of_p1,of_p2,of_p3,of_p4)
       {var
         _$_=caml_call1(Typerep[14],of_p4),
         _aa_=caml_call1(Typerep[14],of_p3),
         _ab_=caml_call1(Typerep[14],of_p2),
         _ac_=caml_call1(Typerep[14],of_p1),
         typename_of_t=caml_call4(Name_of_x[1],_ac_,_ab_,_aa_,_$_),
         typename_of_named=Name_of_x[1];
        return [4,
                [0,
                 of_p1,
                 of_p2,
                 of_p3,
                 of_p4,
                 typename_of_named,
                 typename_of_t,
                 witness]]}
      return [0,named,typename_of_t]}
    function _O_(X)
     {var Name_of_x=_d_(X),typename_of_t=Name_of_x[1];
      function named(of_p1,of_p2,of_p3)
       {var
         _Y_=caml_call1(Typerep[14],of_p3),
         _Z_=caml_call1(Typerep[14],of_p2),
         ___=caml_call1(Typerep[14],of_p1),
         typename_of_t=caml_call3(Name_of_x[1],___,_Z_,_Y_),
         typename_of_named=Name_of_x[1];
        return [3,
                [0,of_p1,of_p2,of_p3,typename_of_named,typename_of_t,witness]]}
      return [0,named,typename_of_t]}
    function _P_(X)
     {var Name_of_x=_e_(X),typename_of_t=Name_of_x[1];
      function named(of_p1,of_p2)
       {var
         _W_=caml_call1(Typerep[14],of_p2),
         _X_=caml_call1(Typerep[14],of_p1),
         typename_of_t=caml_call2(Name_of_x[1],_X_,_W_),
         typename_of_named=Name_of_x[1];
        return [2,[0,of_p1,of_p2,typename_of_named,typename_of_t,witness]]}
      return [0,named,typename_of_t]}
    function _Q_(X)
     {var Name_of_x=_f_(X),typename_of_t=Name_of_x[1];
      function named(of_p1)
       {var
         _V_=caml_call1(Typerep[14],of_p1),
         typename_of_t=caml_call1(Name_of_x[1],_V_),
         typename_of_named=Name_of_x[1];
        return [1,[0,of_p1,typename_of_named,typename_of_t,witness]]}
      return [0,named,typename_of_t]}
    function _R_(X)
     {var
       Name_of_x=_g_(X),
       typename_of_t=Name_of_x[1],
       typename_of_named=Name_of_x[1],
       named=[0,[0,typename_of_named,typename_of_t,witness]];
      return [0,named,typename_of_t]}
    var Typerep_lib_Make_typename=[0,_R_,_Q_,_P_,_O_,_N_,_M_];
    caml_register_global
     (82,Typerep_lib_Make_typename,"Typerep_lib__Make_typename");
    function Make0(X)
     {var M=_R_(X),typerep_of_t=[9,[0,M[1],0]],typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    function Make1(X)
     {var M=_Q_(X);
      function typerep_of_t(of_p1){return [9,[0,caml_call1(M[1],of_p1),0]]}
      var typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    function Make2(X)
     {var M=_P_(X);
      function typerep_of_t(of_p1,of_p2)
       {return [9,[0,caml_call2(M[1],of_p1,of_p2),0]]}
      var typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    function Make3(X)
     {var M=_O_(X);
      function typerep_of_t(of_p1,of_p2,of_p3)
       {return [9,[0,caml_call3(M[1],of_p1,of_p2,of_p3),0]]}
      var typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    function Make4(X)
     {var M=_N_(X);
      function typerep_of_t(of_p1,of_p2,of_p3,of_p4)
       {return [9,[0,caml_call4(M[1],of_p1,of_p2,of_p3,of_p4),0]]}
      var typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    function Make5(X)
     {var M=_M_(X);
      function typerep_of_t(of_p1,of_p2,of_p3,of_p4,of_p5)
       {return [9,[0,caml_call5(M[1],of_p1,of_p2,of_p3,of_p4,of_p5),0]]}
      var typename_of_t=M[2];
      return [0,typerep_of_t,typename_of_t]}
    var Typerep_lib_Type_abstract=[0,Make0,Make1,Make2,Make3,Make4,Make5];
    caml_register_global
     (83,Typerep_lib_Type_abstract,"Typerep_lib__Type_abstract");
    var
     Typerep_lib_Std=
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
    caml_register_global(84,Typerep_lib_Std,"Typerep_lib__Std");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibmFtZSQxIiwibmFtZSQyIiwibmFtZSQzIiwibmFtZSQ0IiwibmFtZSQ1IiwibmFtZSQ2IiwibmFtZSQ3IiwibmFtZSQ4IiwibmFtZSQ5IiwibmFtZSQxMCIsIm5hbWUkMTEiLCJuYW1lJDEyIiwibmFtZSQxMyIsIm5hbWUkMTQiLCJuYW1lJDE1IiwibmFtZSQxNiIsIm5hbWUkMTciLCJuYW1lJDE4IiwibmFtZSQxOSIsIm5hbWUkMjAiLCJuYW1lJDIxIiwid2l0bmVzcyIsImNvbnYiLCJ4IiwibGlmdCIsImNvbXBhcmUiLCJhIiwiYiIsImVxdWFsIiwidWlkIiwibmV4dCIsIm5hbWUiLCJjb2RlIiwiaGFzaCIsInN0YXRpYyQwIiwiY21wIiwiazEiLCJrMiIsImNtcCQwIiwieXMiLCJ5IiwieHMiLCJuIiwiZXF1YWwkMCIsImhhc2gkMCIsInVuaXQiLCJrZXkiLCJ0IiwidWlkJDAiLCJuYW1lJDAiLCJjcmVhdGUiLCJvcHQiLCJzdGgiLCJzYW1lIiwibm0xIiwibm0yIiwic2FtZV93aXRuZXNzIiwic2FtZV93aXRuZXNzX2V4biIsImludCQwIiwibWVtIiwidGFibGUiLCJzZXQiLCJkYXRhIiwiZmluZCIsImRhdGEkMCIsImZhaWwiLCJ1aWRfYSIsInVpZF9iIiwibXNnIiwid2l0bmVzcyQwIiwidHlwZW5hbWVfb2ZfdCIsImMiLCJkIiwiZSIsImxhYmVsIiwiYXJpdHkiLCJhcmdzX2xhYmVscyIsImluZGV4Iiwib2NhbWxfcmVwciIsInR5aWQiLCJ0cmF2ZXJzZSIsImludGVybmFsX3VzZV9vbmx5IiwibGVuZ3RoIiwidGFnIiwiaXNfcG9seW1vcnBoaWMiLCJ2YWx1ZSIsImZvbGQiLCJpbml0IiwiZiIsImludGVybmFsX3VzZV9vbmx5JDAiLCJsYWJlbCQwIiwiaW5kZXgkMCIsImdldCIsImlzX211dGFibGUiLCJ0eWlkJDAiLCJ0cmF2ZXJzZSQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMSIsInR5cGVuYW1lX29mX3QkMCIsImxlbmd0aCQwIiwiZmllbGQiLCJoYXNfZG91YmxlX2FycmF5X3RhZyIsImNyZWF0ZSQwIiwiZm9sZCQwIiwiaW50ZXJuYWxfdXNlX29ubHkkMiIsInR5cGVuYW1lX29mX2ludCIsInR5cGVuYW1lX29mX2ludDMyIiwidHlwZW5hbWVfb2ZfaW50NjQiLCJ0eXBlbmFtZV9vZl9uYXRpdmVpbnQiLCJ0eXBlbmFtZV9vZl9jaGFyIiwidHlwZW5hbWVfb2ZfZmxvYXQiLCJ0eXBlbmFtZV9vZl9zdHJpbmciLCJ0eXBlbmFtZV9vZl9ieXRlcyIsInR5cGVuYW1lX29mX2Jvb2wiLCJ0eXBlbmFtZV9vZl91bml0IiwidHlwZW5hbWVfb2Zfb3B0aW9uIiwidHlwZW5hbWVfb2ZfbGlzdCIsInR5cGVuYW1lX29mX2FycmF5IiwidHlwZW5hbWVfb2ZfbGF6eV90IiwidHlwZW5hbWVfb2ZfcmVmIiwidHlwZW5hbWVfb2ZfZnVuY3Rpb24iLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTIiLCJ0eXBlbmFtZV9vZl90dXBsZTMiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTUiLCJyZXAiLCJyZXAkMCIsInJlcCQxIiwicmVwJDIiLCJyZXAkMyIsInJlcCQ0IiwibmFtZSQyMiIsImFyaXR5JDAiLCJiJDAiLCJhJDAiLCJjJDAiLCJiJDEiLCJhJDEiLCJkJDAiLCJjJDEiLCJiJDIiLCJhJDIiLCJ0eXBlbmFtZV9vZl90JDEiLCJybmciLCJkb20iLCJyZXAkNSIsInJlcCQ2Iiwic2FtZV93aXRuZXNzJDAiLCJ0MSIsInQyIiwidDEkMCIsInQyJDAiLCJyMiQwIiwicjIkMSIsIngkMCIsInIyJDIiLCJ4JDEiLCJyMiQzIiwieCQyIiwicjIkNCIsIngkMyIsInJuZzIiLCJkb20yIiwidDIkMiIsImIyIiwiYTIiLCJiMSIsImExIiwiYzIiLCJiMiQwIiwiYTIkMCIsImMxIiwiYjEkMCIsImExJDAiLCJkMiIsImMyJDAiLCJiMiQxIiwiYTIkMSIsImQxIiwiYzEkMCIsImIxJDEiLCJhMSQxIiwiZTIiLCJkMiQwIiwiYzIkMSIsImIyJDIiLCJhMiQyIiwiZTEiLCJkMSQwIiwiYzEkMSIsImIxJDIiLCJhMSQyIiwicjIkNSIsInIyJDYiLCJyMiQ3IiwibmFtZTIiLCJyMSQwIiwieCQ0IiwidDIkNCIsInQyJDMiLCJyMSIsInQxJDEiLCJyMiIsInQyJDEiLCJzYW1lJDAiLCJzYW1lX3dpdG5lc3NfZXhuJDAiLCJwcm9vZiIsImhlYWQiLCJ0JDEiLCJyZXByX29mX3BvbHlfdmFyaWFudCIsIm9iaiIsInNpemUiLCJyZXByIiwiaGFzaF92YXJpYW50IiwicyIsImFjY3UiLCJpIiwiZG91YmxlX2FycmF5X3ZhbHVlIiwiZG91YmxlJDAiLCJzaW1wbGUiLCJtYXBfdmFyaWFudCIsInZhcmlhbnQiLCJtYXAiLCJ0eXBlbmFtZSIsInBvbHltb3JwaGljIiwidGFnJDAiLCJmY3QiLCJrIiwidGFncyIsImF0YWciLCJidGFnIiwibWFwX3JlY29yZCIsInJlY29yZCIsImZpZWxkJDAiLCJmaWVsZHMiLCJnZXQkMCIsImFmaWVsZCIsImJmaWVsZCIsInRhYmxlJDAiLCJjaGVja19kZXBlbmRlbmNpZXMiLCJpbXBsZW1lbnRzJDAiLCJtZXNzYWdlIiwicmVwbGFjZSIsInRhYmxlMCIsInRhYmxlMSIsInRhYmxlMiIsInRhYmxlMyIsInRhYmxlNCIsInRhYmxlNSIsImlzX3JlZ2lzdGVyZWQiLCJpZGVudCIsInJlZ2lzdGVyMCIsImNvbXB1dGUiLCJyZWdpc3RlcjEiLCJyZWdpc3RlcjIiLCJyZWdpc3RlcjMiLCJyZWdpc3RlcjQiLCJyZWdpc3RlcjUiLCJyZWdpc3RlciIsInR5cGVyZXBfb2ZfYSIsIm9mX3R5cGVyZXAiLCJjb250ZXh0IiwibWVtb190YWJsZSIsInJlcCQxMSIsInJlcCQxMiIsInJlcCQxMyIsInJlcCQxNCIsInJlcCQxNSIsInR1cGxlIiwicmEiLCJyYiIsInJhJDAiLCJyYiQwIiwicmMiLCJyYSQxIiwicmIkMSIsInJjJDAiLCJyZCIsInJhJDIiLCJyYiQyIiwicmMkMSIsInJkJDAiLCJyZSIsImNvbnRlbnQiLCJuYW1lZCIsInNoYXJlZCIsImN1c3RvbSIsImN1c3RvbSQwIiwiY3VzdG9tJDEiLCJyZXAkNyIsImN1c3RvbSQyIiwiY3VzdG9tJDMiLCJyZXAkOCIsImN1c3RvbSQ0IiwiY3VzdG9tJDUiLCJyZXAkOSIsInR5cGVuYW1lX29mX3QkMiIsImN1c3RvbSQ2IiwiY3VzdG9tJDciLCJyZXAkMTAiLCJ0eXBlbmFtZV9vZl90JDMiLCJjdXN0b20kOCIsImN1c3RvbSQ5IiwiY29tcHV0YXRpb24iLCJzdHJpbmciLCJjb250ZW50JDAiLCJzaGFyZWQkMCIsImNvbXB1dGF0aW9uJDAiLCJwYXRoIiwiciIsImlucHV0IiwiZ2V0X3dpcF9jb21wdXRhdGlvbiIsImNsb3MiLCJzZXRfZmluYWxfY29tcHV0YXRpb24iLCJjb21waWxldGltZV9kZXJlZmVyZW5jZSIsInNoYXJlIiwib2ZfcDEiLCJvZl9wMiIsIm9mX3AzIiwib2ZfcDQiLCJvZl9wNSIsInR5cGVuYW1lX29mX25hbWVkIiwidHlwZXJlcF9vZl90Il0sInNvdXJjZXMiOlsiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3R5cGVyZXAvc3RkX2ludGVybmFsLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3R5cGVyZXAvbWFrZV90eXBlbmFtZS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi90eXBlcmVwL3R5cGVfZXF1YWwubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvdHlwZXJlcC90eXBlbmFtZS5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi90eXBlcmVwL3R5cGVfZ2VuZXJpYy5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi90eXBlcmVwL3ZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLm1sIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3R5cGVyZXAvdHlwZXJlcF9vYmoubWwiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvdHlwZXJlcC90eXBlX2dlbmVyaWNfaW50Zi5tbCIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi90eXBlcmVwL3R5cGVfYWJzdHJhY3QubWwiXSwibWFwcGluZ3MiOiI7Ozs7O0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FNWUE7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FXQUM7S0FTRkM7S0FRQUM7S0FRQUM7S0FRQUM7S0FRQUM7S0FRQUM7S0FVQUM7S0FRQUM7S0FRQUM7S0FRQUM7S0FRQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDREVDO2FDL0xSQyxXQUE0Q0MsR0FBSyxPQUFMQSxDQUFNO3FCQU0zQyxTQUFMQyxZQUFvRCxRQUFDLENBQWhELFVBQUxBLEtBQXFEO2tDQU52REYsS0QrTFFEOzthRWxLTkksUUFBUUMsRUFBRUMsR0FBSSxnQ0FBTkQsS0FBRUMsS0FBaUM7YUFDM0NDLE1BQU1GLEVBQUVDLEdBQUksT0FBTkQsU0FBRUMsUUFBMkI7UUFDbkNFO2FBRUFDLEtBQUtDLE1BQ1AsSUFBSUMsS0FIRkgsT0FHRixtQkFBSUcsS0FER0QsS0FHTzthQUdaRSxLQUFLUCxHQUFJLHFDQUFKQSxLQUF1QjthQUM1QkssS0FBS0wsR0FBSSxPQUFKQSxJQUFVO0lBQ04sSUFBVFEsU0FSQUo7SUFRUyxTQXpDREssSUFrRElDLEdBQUdDO01BQ2pCLEdBRGNELE9BQUdDLEdBRVo7TUFFTyxJQUFOQyxNQXpCSmIsUUFxQllXLE1BQUdDO01BSUwsU0FBTkMsTUFDYSxPQURiQTtNQUFNLElBckRDWixFQWlEQ1UsTUFqRENULEVBaURFVTtNQWhEZjthQURXWCxFQUdBLE9BSEVDO2VBSUY7UUFFRCxJQURNWSxHQUxIWixLQUtGYSxFQUxFYixLQUtOYyxHQUxJZixLQUtUSCxFQUxTRyxLQU1ELEVBUEZTLElBTU5aLEVBQVNpQjtRQUNELFNBQUpFLEVBQzBCLE9BRDFCQTtRQUFJLElBTkNoQixFQUtKZSxHQUxNZCxFQUtHWSxHQWlEbUQ7SUFkMUQsU0FpQlRJLFFBQU1qQixFQUFFQyxHQUFJLGFBMURKUSxJQTBERlQsRUFBRUMsTUFBbUI7SUFqQmxCLHNDQUFUTztJQUFTLFNBeUJYWSxJQUFJQyxHQUFJLE9BQUpBLENBQUs7SUF6QkUsU0EwQlhDLE1BQUlELEdBQUksT0FBSkEsSUFBYTtJQTFCTixTQTJCWEUsT0FBS0YsR0FBSSxPQUFKQSxPQUFzQjtJQTNCaEIsU0E2QlhHLE9BQVNDO01BQStCLEdBQS9CQSxJQUFPLFFBQVBBLFlBQU9DLGFBQVByQjtNQUEyQyxVQXJDbERELEtBcUNPQyxRQUF1RTtJQTdCckUsU0FrQ1RzQixLQUFpQkMsSUFBWUMsS0FBYSxhQTNFbENwQixJQTJFU21CLElBQVlDLFFBQW9DO0lBbEN4RCxTQW9DVEMsYUFBeUJGLElBQVlDLEtBQ3BDLGFBOUVPcEIsSUE2RWlCbUIsSUFBWUMsUUZrSC9CbEMsVUUvR0M7SUF2Q0UsU0EwQ1RvQyxpQkFBNkJILElBQVlDO01BQ3hDLGFBcEZPcEIsSUFtRnFCbUIsSUFBWUM7ZUY0R25DbEM7ZUV6R0gsbURBQW9DO0lBN0M5QiwrQ0FpQlRzQixRQUNBQztJQWxCUztlQXVJVE0sT0FBT1EsT0FBTSwrQkFBTkEsTUFBMEI7ZUFDakNDLElBQUlDLE1BQU03QixNLGdDQUFONkIsTUFBTTdCLEtBQXFDO2VBQy9DOEIsSUFBSUQsTUFBTTdCLEtBQUsrQjtRLGdDQUFYRixNQUFNN0IsYUFBSytCLE1BQTZEO2VBRTVFQyxLQUFjSCxNQUFPN0I7UTtVQUVaLG9DQUZLNkIsTUFBTzdCLE9BQ25CK0I7Ozs7O1FBSUosS0FKSUEsS0FLTTtrQkFMTkEsUUFNaUJFLGdCQUFQZjt3QkFDR0EsT0FBcUJhO2tCQUNiLGlCQURSYixPQVJNbEIsTUFTRSxVQURhK0IsS0FFZDtpQkFIVmIsT0FBT2UsT0FLYjtnQkFoQk5kLE9BQ0FTLElBQ0FFLElBRUFFO0lBM0lTLFNBMkpYRSxLQUFLQyxNQUFNQztNQUVYLElBREVDLElBQ0YsZ0NBRktGLFNBQU1DO01BRVgsNEJBREVDLElBR1E7SUEvSkM7TUFzS0M7YUFBSSxtQkNrWWR2QjtPRGpZVSxNQUFJLGdCQ2lZZEE7T0RoWUMsVUFuTERqQixNQWlMRXNDLE1BQ0FDLFVGakJJOUMsU0VLUjRDLEtBV0lDLE1BQ0FDO01BQ2tGLFVBSHBGRTtJQXJLUztNQWdMQzthQUFJLG1CQ3dYZHhCO09EdlhVLE1BQUksZ0JDdVhkQTtPRHRYQyxVQTdMRGpCLE1BMkxFc0MsTUFDQUMsVUYzQkk5QyxTRUtSNEMsS0FxQklDLE1BQ0FDO01BQ2tGLFVBSHBGRTtJQS9LUztNQTBMQzthQUFJLG1CQzhXZHhCO09EN1dVLE1BQUksZ0JDNldkQTtPRDVXQyxVQXZNRGpCLE1BcU1Fc0MsTUFDQUMsVUZyQ0k5QyxTRUtSNEMsS0ErQklDLE1BQ0FDO01BQ2tGLFVBSHBGRTtJQXpMUztNQW9NQzthQUFJLG1CQ29XZHhCO09EbldVLE1BQUksZ0JDbVdkQTtPRGxXQyxVQWpORGpCLE1BK01Fc0MsTUFDQUMsVUYvQ0k5QyxTRUtSNEMsS0F5Q0lDLE1BQ0FDO01BQ2tGLFVBSHBGRTtJQW5NUztNQWlOQzthQUFJLG1CQ3VWZHhCO09EdFZVLE1BQUksZ0JDc1ZkQTtPRHJWQyxVQTlORGpCLE1BNE5Fc0MsTUFDQUMsVUY1REk5QyxTRUtSNEMsS0FzRElDLE1BQ0FDO01BQ2tGLFVBSHBGRTtJQWhOUztNQTBISCxJQUFOeEMsSUFsSUFDO01Ba0lNLFNBQ053QyxjQUFjNUMsRUFBRUMsRUFBRTRDLEVBQUVDLEVBQUVDO1FBQUksVUFEMUI1QyxPQUNjSCxLQUFFQyxLQUFFNEMsS0FBRUMsS0FBRUMsU0FBMkM7Z0JBQWpFSDtJQTNIUztNQXFISCxJQUFOekMsSUE3SEFDO01BNkhNLFNBQ053QyxjQUFjNUMsRUFBRUMsRUFBRTRDLEVBQUVDO1FBQUksVUFEeEIzQyxPQUNjSCxLQUFFQyxLQUFFNEMsS0FBRUMsUUFBd0M7Z0JBQTVERjtJQXRIUztNQWdISCxJQUFOekMsSUF4SEFDO01Bd0hNLFNBQ053QyxjQUFjNUMsRUFBRUMsRUFBRTRDLEdBQUksVUFEdEIxQyxPQUNjSCxLQUFFQyxLQUFFNEMsT0FBcUM7Z0JBQXZERDtJQWpIUztNQTJHSCxJQUFOekMsSUFuSEFDO01BbUhNLFNBQ053QyxjQUFjNUMsRUFBRUMsR0FBSSxVQURwQkUsT0FDY0gsS0FBRUMsTUFBa0M7Z0JBQWxEMkM7SUE1R1M7TUFzR0gsSUFBTnpDLElBOUdBQztNQThHTSxTQUNOd0MsY0FBYzVDLEdBQUksVUFEbEJHLE9BQ2NILEtBQStCO2dCQUE3QzRDO0lBdkdTO01BaUdILFFBekdOeEMsY0F5R00saUJBQU5ELGlCQUNBeUM7SUFsR1M7WUFaVDdDLFFBQ0FHLE1BU0FLLEtBQ0FGO0tBQ1MsT0F6Q0RJLElBMERSUSxRQUNBQztLQWxCUzs7T0E2QlhNO09DMmdCRUw7T0R0Z0JBUTtPQUVBRztPQU1BQzs7T0FqQkZYOztPQUNBRTtPQUNBQzs7Ozs7Ozs7Ozs7OztJQTNCVztJRXpDTjtNQXlCZTtlQStMaEJ5QixNQUFNM0IsR0FBSSxPQUFKQSxJQUFXO01BL0xELFNBZ01oQjRCLE1BQU01QixHQUFJLE9BQUpBLElBQVc7TUFoTUQsU0FpTWhCNkIsWUFBWTdCLEdBQUksT0FBSkEsSUFBaUI7TUFqTWIsU0FrTWhCOEIsTUFBTTlCLEdBQUksT0FBSkEsSUFBVztNQWxNRCxTQW1NaEIrQixXQUFXL0IsR0FBSSxPQUFKQSxJQUFnQjtNQW5NWCxTQW9NaEJHLE9BQU9ILEdBQUksT0FBSkEsSUFBWTtNQXBNSCxTQXFNaEJnQyxLQUFLaEMsR0FBSSxPQUFKQSxJQUFVO01Bck1DLFNBc01oQmlDLFNBQVNqQyxHQUFJLE9BQUpBLElBQVM7TUF0TUYsU0F1TWhCa0Msa0JBQWtCbEMsR0FBSSxPQUFKQSxDQUFLO01Bdk1QOzs7U0ErTGhCMkI7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQTVCO1NBQ0E2QjtTQUNBQztTQUNBQztPQXZNZ0I7ZUFpUmhCWCxjQUFjdkIsR0FBSSxPQUFKQSxJQUFjO01BalJaLFNBa1JoQm1DLE9BQU9uQyxHQUFJLE9BQUpBLGVBQXVCO01BbFJkLFNBbVJoQm9DLElBQUlwQyxFQUFFOEIsT0FBUSx3QkFBVjlCLEtBQUU4QixpQkFBc0I7TUFuUlosU0FvUmhCTyxlQUFlckMsR0FBSSxPQUFKQSxJQUFpQjtNQXBSaEIsU0FxUmhCc0MsTUFBTXRDLEdBQUksT0FBSkEsSUFBVztNQXJSRCxTQXNSaEJ1QyxLQUFLdkMsRUFBR3dDLEtBQU1DLEdBQUksbUNBQUpBLEVBQU5ELEtBQUh4QyxLQUEwQztNQXRSL0IsU0F1UmhCMEMsb0JBQWtCMUMsR0FBSSxPQUFKQSxDQUFLO01BdlJQOzs7U0FpUmhCdUI7U0FDQVk7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUc7T0F2UmdCO2VBdVdoQkMsUUFBTTNDLEdBQUksT0FBSkEsSUFBVztNQXZXRCxTQXdXaEI0QyxRQUFNNUMsR0FBSSxPQUFKQSxJQUFXO01BeFdELFNBeVdoQjZDLElBQUk3QyxHQUFJLE9BQUpBLElBQVM7TUF6V0csU0EwV2hCOEMsV0FBVzlDLEdBQUksT0FBSkEsSUFBZ0I7TUExV1gsU0EyV2hCK0MsT0FBSy9DLEdBQUksT0FBSkEsSUFBVTtNQTNXQyxTQTRXaEJnRCxXQUFTaEQsR0FBSSxPQUFKQSxJQUFTO01BNVdGLFNBNldoQmlELG9CQUFrQmpELEdBQUksT0FBSkEsQ0FBSztNQTdXUDs7O1NBdVdoQjJDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO09BN1dnQjtlQTZiaEJDLGdCQUFjbEQsR0FBSSxPQUFKQSxJQUFjO01BN2JaLFNBOGJoQm1ELFNBQU9uRCxHQUFJLE9BQUpBLGVBQXlCO01BOWJoQixTQStiaEJvRCxNQUFNcEQsRUFBRThCLE9BQVEsd0JBQVY5QixLQUFFOEIsaUJBQXdCO01BL2JoQixTQWdjaEJ1QixxQkFBcUJyRCxHQUFJLE9BQUpBLElBQTBCO01BaGMvQixTQWljaEJzRCxTQUFPdEQsR0FBSSxPQUFKQSxJQUFZO01BamNILFNBa2NoQnVELE9BQUt2RCxFQUFHd0MsS0FBTUM7UUFBSSxtQ0FBSkEsRUFBTkQsS0FBSHhDLEtBQTRDO01BbGNqQyxTQW1jaEJ3RCxvQkFBa0J4RCxHQUFJLE9BQUpBLENBQUs7TUFuY1A7OztTQTZiaEJrRDtTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztNQW5jZ0I7Ozs7Ozs7O3FCQWVuQjtJQXhDSTs7Ozs7O0tMRGEsdUJBR1Z2RztLQUhVLHlCQWNWQztLQWRVLHlCQXlCVkM7S0F6QlUsNkJBb0NWQztLQXBDVSx3QkErQ1ZDO0tBL0NVLHlCQTBEVkM7S0ExRFUsMEJBcUVWQztLQXJFVSx5QkFnRlZDO0tBaEZVLHdCQTJGVkM7S0EzRlUsd0JBc0dWQztLQXRHVSxnQkErR1pDO0tBL0dZO21CQXVIWkM7S0F2SFk7b0JBK0haQztLQS9IWTtxQkF1SVpDO0tBdklZO2tCQStJWkM7S0EvSVk7dUJBdUpaQztLQXZKWTtxQkFpS1pDO0tBaktZO3FCQXlLWkM7S0F6S1k7cUJBaUxaQztLQWpMWTtxQkF5TFpDO0tBekxZO3FCQWlNWkM7S0FqTVk7O2FBc2pCZHVEO01BQVE7ZUFDQTtlQUNBO2VBQ0E7ZUFDQTtlQUNBO2dCQUNBLFNBQUM7SUE1akJLLFNBK2pCZEw7TUFBYztlQUVkLElBREd1RCxhQUNILE9BREdBO2VBSUgsSUFER0MsZUFDSCxPQURHQTtlQUlILElBREdDLGVBQ0gsT0FER0E7ZUFJSCxJQURHQyxlQUNILE9BREdBO2VBSUgsSUFER0MsZUFDSCxPQURHQTtnQkFJSCxJQURHQyxlQUNILE9BREdBLFNBRVk7SUFqbEJELFNBb2xCZEMsUUFBS047TUFBd0IsU0FyQjdCdkQsY0FxQkt1RCxRQUF3Qiw4QkFBa0M7SUFwbEJqRCxhQXNqQmRsRCxNQVNBTCxjQXFCQTZEO0lBcGxCYyxTQW9tQmRDOztlQUNzQixnQkFDQSxnQkFDQSxpQkFDQSxTQUFDO0lBeG1CVCxTQTJtQmRuQzs7O1NBRXFEOztVQUQ5Q3RFO1VBQUhEO1VBQ2lELDRCQUQ5Q0M7U0FDb0Isa0JBamM3QjhGLG1CQWljNkIsdUJBRHZCL0Y7O1NBTUY7O1VBSlE2QztVQUFIOEQ7VUFBSEM7VUFJRiw0QkFKUS9EO1VBR1IsNEJBSEs4RDtTQUVMO2tCQTViSlgsbUJBNGJJLHVCQUZFWTs7U0FVRjs7VUFMVzlEO1VBQUgrRDtVQUFIQztVQUFIQztVQUtGLDRCQUxXakU7VUFJWCw0QkFKUStEO1VBR1IsNEJBSEtDO1NBRUw7a0JBemJKYjtrQkF5YkksdUJBRkVjOzs7OztTQVlGOztVQU5jaEU7VUFBSGlFO1VBQUhDO1VBQUhDO1VBQUhDO1VBTUYsNEJBTmNwRTtVQUtkLDRCQUxXaUU7VUFJWCw0QkFKUUM7VUFHUiw0QkFIS0M7U0FFTDtrQkF2YkpoQjtrQkF1YkksdUJBRkVpQjs7Ozt3QkFNdUI7SUEvbkJiO2NBb21CZFQsUUFPQW5DO0tBM21CYzs7Ozs7Ozs7O2FBd29CWjZDOzs7Z0JBQ0csT0Ezb0JQdEM7Z0JBNG9CUyxPQWpvQlRDO2dCQWtvQlMsT0F2bkJUQztnQkF3bkJhLE9BN21CYkM7Z0JBOG1CUSxPQW5tQlJDO2dCQW9tQlMsT0F6bEJUQztnQkEwbEJVLE9BL2tCVkM7Z0JBZ2xCUyxPQXJrQlRDO2dCQXNrQlEsT0EzakJSQztpQkE0akJRLE9BampCUkM7TUF1aUJJOztTQVdVLElBQVBZO1NBQWtDLGtCQWppQnpDWCxtQkFzaEJJNEIsZ0JBV0dqQjs7U0FDSyxJQUFQQztTQUFnQyxrQkExaEJyQ1gsaUJBOGdCSTJCLGdCQVlDaEI7O1NBQ1EsSUFBUEM7U0FBaUMsa0JBbmhCdkNYLGtCQXNnQkkwQixnQkFhRWY7O1NBQ00sSUFBUEM7U0FBa0Msa0JBNWdCdkNYLG1CQThmSXlCLGdCQWNDZDs7U0FDTSxJQUFQQztTQUErQixrQkFyZ0JuQ1gsZ0JBc2ZJd0IsZ0JBZUFiOztTQUU2Qzs7VUFEbENjO1VBQUxDO1VBQ3VDLEtBakI3Q0YsZ0JBZ0JXQztTQUNjLGtCQS9mN0J4QixxQkE4ZUl1QixnQkFnQk1FO2VBRUcsSUFBUGQsZUFBTyxnQ0FBUEE7ZUFDUSxJQUFQZSxlQUFPLGlDQUFQQTtlQUNRLElBQVBDLGVBQU8sZ0NBQVBBOzs4QkFDRG5ILGlEQUFvQztJQTdwQjNCLFNBZ3FCWm9ILGVBQ0ZDLEdBQUdDO1VBQUhDLFFBQUdDO01BQ0w7O2tCQURFRDtTQUNGLE9BREVBOztzQkFBR0M7NEJBc0JTOztzQkF0QlRBOzs7OzRCQXVCYTs7c0JBdkJiQTs7Ozs0QkF3QmE7O3NCQXhCYkE7Ozs7NEJBeUJxQjs7c0JBekJyQkE7Ozs7NEJBMEJXOztzQkExQlhBOzs7OzRCQTJCYTs7c0JBM0JiQTs7Ozs0QkE0QmU7O3NCQTVCZkE7Ozs7NEJBNkJhOztzQkE3QmJBOzs7OzRCQThCVzs7c0JBOUJYQTs7Ozs0QkErQlc7O3NCQS9CWEE7O1NBQ0wsT0FERUQ7OztzQkFBR0M7OztnQkFpQ0gsU0FqQ0dBLFFBaUNJLEVBbENMSixvQkFpQ2dCSyxNQUNYLE9BQ0pqSTs7Ozs7Z0NBbENIK0g7c0JBQUdDOzs7Z0JBcUNILFNBckNHQSxRQXFDSSxJQXRDTEosb0JBcUNZTTtnQkFDUCxPQUNKQzs7Ozs7Z0NBdENISjtzQkFBR0M7Ozs7O2dCQXlDSCxTQXpDR0EsUUF5Q0ksSUExQ0xKLG9CQXlDY1E7Z0JBQ1QsT0FDSkM7Ozs7O2dDQTFDSE47c0JBQUdDOzs7OztnQkE2Q0gsU0E3Q0dBLFFBNkNJLElBOUNMSixvQkE2Q1lVO2dCQUNQLE9BQ0pDOzs7OztnQ0E5Q0hSO3NCQUFHQzs7Ozs7Z0JBaURILFNBakRHQSxRQWlESSxJQWxETEosb0JBaURVWTtnQkFDTCxPQUNKQzs7Ozs7cUJBbERIVjtzQkFBR0M7Ozs7O2dCQXFESTt5QkFyREpBO2lCQW9Eb0NVO2lCQUFOQztpQkFDMUIsUUF0RExmLG9CQXFEK0JlO2lCQUNGLFFBdEQ3QmYsb0JBcURxQ2M7Z0JBRWQ7Z0JBQ0Q7Ozs7O3FCQXZEeEJYO3NCQUFHQzs7Ozs7Z0JBeURILElBRGdCWSxLQXhEYlo7Z0JBeURIOzs7NEJBRGdCWSxRQStCQTttQkEzQk47NEJBSk1BO29CQUdZQztvQkFBSkM7b0JBQVhDO29CQUFKQztvQkFDQyxRQTdEUnBCLGVBNERPb0IsR0FBZUY7b0JBQ00sUUE3RDVCbEIsZUE0RFdtQixHQUFlRjttQkFFQTttQkFDRDs7OzRCQU5YRCxRQWdDQTttQkF4Qk47NEJBUk1BO29CQU9vQks7b0JBQUpDO29CQUFKQztvQkFBWEM7b0JBQUpDO29CQUFKQztvQkFDQyxRQWpFUjFCLGVBZ0VPMEIsS0FBbUJIO29CQUNFLFFBakU1QnZCLGVBZ0VXeUIsS0FBbUJIO29CQUNrQixRQWpFaER0QixlQWdFZXdCLEdBQW1CSDttQkFFRTttQkFDUTs7OzRCQVY5QkwsUUFpQ0E7bUJBcEJWOzZCQWJVQTtvQkFXNEJXO29CQUFKQztvQkFBSkM7b0JBQUpDO29CQUFYQztvQkFBSkM7b0JBQUpDO29CQUFKQztvQkFFSCxTQXRFSmxDLGVBb0VPa0MsS0FBdUJKO29CQUVOLFNBdEV4QjlCLGVBb0VXaUMsS0FBdUJKO29CQUVVLFNBdEU1QzdCLGVBb0VlZ0MsS0FBdUJKO29CQUUwQixTQXRFaEU1QixlQW9FbUIrQixHQUF1Qko7bUJBSUk7bUJBQ3VCOzs7NEJBaEJ2RFgsUUFrQ0E7bUJBZlI7NkJBbkJRQTtvQkFpQm9DbUI7b0JBQUpDO29CQUFKQztvQkFBSkM7b0JBQUpDO29CQUFYQztvQkFBSkM7b0JBQUpDO29CQUFKQztvQkFBSkM7b0JBRUQsU0E1RU41QyxlQTBFTzRDLEtBQTJCTDtvQkFHNUIsU0E3RU52QyxlQTBFVzJDLEtBQTJCTDtvQkFJaEMsU0E5RU50QyxlQTBFZTBDLEtBQTJCTDtvQkFLcEMsU0EvRU5yQyxlQTBFbUJ5QyxLQUEyQkw7b0JBTXhDLFNBaEZOcEMsZUEwRXVCd0MsR0FBMkJMO21CQVFNOzttQkFLaEM7Ozs7O2dDQXRGMUJoQztzQkFBR0M7Ozs7O2dCQTRGSCxTQTVGR0EsUUE4RkQsK0JBSGdCeUM7Z0JBRWhCLE9HaHJCSnhJLGFIZ3JCSTs7Ozs7Z0NBN0ZGOEY7c0JBQUdDOzs7OztnQkFnR0gsU0FoR0dBLFFBa0dELDhCQUhrQjBDO2dCQUVsQixPR3ByQkp6SSxhSG9yQkk7Ozs7O3FCQWpHRjhGO3NCQUFHQztjQUtrRDt3QkFMbERBO2VBRzhCMkM7ZUFBUEM7ZUFBWkM7ZUFFdUMseUJBRjNCRDtlQUV2QixJR3hsQkwzSSxhSHdsQjJCO2NBQXRCLEdBRUE2SSxJQUFpQixPQUFqQkE7Y0FFQSxLQU5XRDtxQkFBbUJGLEtBVWI7O3NCQVZhQTs7aUJBSDlCSTs7Ozs7O2NBS2tEO29CQUZ2Q0Y7Ozs7OztpQkFBbUJGOzs7O2lCQUg5Qks7Ozs7aUJBQUhqRDtpQkFBR0M7O2NBS2tELElBTHJERDs7Z0JBY1VrRDtvQkFHQzs7a0JBSERBOzthQWRWQzs7Ozs7OztvQkFBR2xELFFBa0JXbUQ7a0JBR0g7O2dCQUhHQTs7V0FsQlhDOzs7Ozs7a0JBQUhyRDs7O2tCQW9HWTtrQkFDQTtrQkFDSTtrQkFDTDtrQkFDQztrQkFDQztrQkFDRDtrQkFDRDttQkFDQTs7Z0JBNUdYQTs7a0JBNkdlO2tCQUNGO2tCQUNDO2tCQUNEO2tCQUNEO2tCQUNLO2tCQUNIO2tCQUNDO21CQUNDO1FBbEJOLFNBa0JVO0lBdHhCTixTQXl4QmhCc0QsT0FBS2xMLEVBQUVDLEdBQUksYUF6SFB3SCxlQXlIQ3pILEVBQUVDLE1BQTRCO0lBenhCbkIsU0EyeEJoQmtMLG1CQUFpQm5MLEVBQUVDO01BQ2YsVUE1SEF3SCxlQTJIYXpILEVBQUVDO01BQ2YsV0FFSTtNQUZKLElBQ0NtTDtNQUFTLE9BQVRBLEtBQ2U7SUE5eEJKLFNBaXlCWkM7TTtNQUFPOzs7Ozs7O2FBQ2tCQzs7Ozs7O1FBQ3hCLFdBQUM7SUFueUJVOzs7Ozs7Ozs7Ozs7Ozs7T0F5eEJoQko7T0F6SEl6RDtPQTJISjBEO09BbkpJL0Q7T0F5SkFpRTtJQWp5Qlk7Ozs7Ozs7Ozs7OytCQWl6QkFsRixLQUFNLFVBQU5BLElBQXdCO0lBanpCeEIseUJBa3pCRkEsS0FBTSxVQUFOQSxJQUFzQjtJQWx6QnBCLDBCQW16QkRBLEtBQU0sVUFBTkEsSUFBdUI7SUFuekJ0QiwyQkFvekJBQSxLQUFNLFVBQU5BLElBQXNCO0lBcHpCdEIsd0JBcXpCSEEsS0FBTSxVQUFOQSxJQUFxQjtJQXJ6QmxCLDZCQXN6QkVtQixJQUFJRCxLQUFNLGFBQVZDLElBQUlELEtBQWlDO0lBdHpCdkM7K0JBd3pCQXJILEVBQUVDLEdBQUksZ0JBQU5ELEVBQUVDLElBQTJDO0lBeHpCN0MsMkJBeXpCQUQsRUFBRUMsRUFBRTRDLEdBQUksZ0JBQVI3QyxFQUFFQyxFQUFFNEMsSUFBOEM7SUF6ekJsRCwyQkEwekJBN0MsRUFBRUMsRUFBRTRDLEVBQUVDLEdBQUksZ0JBQVY5QyxFQUFFQyxFQUFFNEMsRUFBRUMsSUFBaUQ7SUExekJ2RCwyQkEyekJBOUMsRUFBRUMsRUFBRTRDLEVBQUVDLEVBQUVDLEdBQUksZ0JBQVovQyxFQUFFQyxFQUFFNEMsRUFBRUMsRUFBRUMsSUFBb0Q7SUEzekI1RDs7S0FrMEJoQjs7NEJBOXlCQWlDOzBCQXRCQUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQVdBQztPQVdBQztPQVdBQzs7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FpQkFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDO09BVUFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDOztJQXBNZ0I7OztJTURwQixTQURFcUYscUJBRUVDO01BQUosVUFBSUEsaUJBRUMsT0FGREE7TUFHQyxJQUNDQyxLQUpGRDtNQUdDLFNBQ0NDO01BREQsSUFHQ0MsS0FORkY7TUFNUyxVQUFQRSxrQkFFSixPQUZJQTtrQ0FFUztJQVRmLFNBWUVDLGFBQWFDO01BQ2Ysa0RBRGVBLFdBQ2Y7O1lBQ0FFO1FBQ0U7VUFBa0MsaUNBSHJCRixFQUVmRTtVQUNvQyxpQkFGaENEO1VBRWdDLFNBRHBDQztVQUNvQyxZQURwQ0E7O01BSUEsVUFMSUQ7TUFLSixvQkFMSUEsd0NBT29EO0lBS0gsUUFibkRGO0lBYWEsR0ExQmJKO0lBMEJtRCxRQWJuREk7SUFjYSxHQTNCYko7SUEwQm1ELElBRW5EUTthQUNBckgscUJBQXFCMUU7TUFBMkIsc0JBQTNCQSxHQUEyQixrQ0FBb0I7O0tBY2hFZ00sY0FmSkQ7S0FnQklFLFVBaEJKRjtJQW1CSyxLQWxCTHJILHFCQWNJc0g7SUFLTSxHQW5CVnRILHFCQWVJdUg7Ozs7T0E1Q0pWO09BYUFJO09BZUFJO09BQ0FySDs7O0lDOUJLLGdCQUdULFVBc0RHO0lBekRNOzs7SUhHSztlQUdSd0gsa0JBQW9DQztRQUF4Qjs7U0E0QkMsNEJBNUJ1QkE7U0E2QnBCLCtCQTdCb0JBO1FBNkJwQixjQUUyQmxJO1VBQ2pDO29DQWhDMEJrSSxRQStCT2xJO1dBekIzQyxJQURVc0k7V0FHSSx5QkFERTlJO1dBRUosZUFUaUIySSxJQVNiLG1CQUZBM0k7V0FHRix5QkFIRUE7V0FJSSwrQkFKSkE7V0FLRix5QkFMRUE7V0FNRyw4QkFOSEE7V0FPSCx3QkFQR0E7V0FRVSx5QkFSVkE7VUFORDtXQUNLLGlCQWFkakMsVUFiT2dMOztXQUNNLGVBWWJoTCxVQVpRaUw7VUFjVjs7O3VCQVRFekosTUFDQW1ELElBQ0FsRCxNQUNBQyxZQUNBQyxNQUNBQyxXQUNBQyxLQUNBN0IsU0FpQmlDO1FBRDVCO2lDQS9CeUIySztTQStCcEM7aUJBR0V4SSxNQUFPM0Q7VUFDSDtvQ0FuQzhCbU0sUUFrQzNCbk07V0FDSDs7V0FHeUMsd0JBRjVCMk07V0FFc0IseUJBUnZDRDtXQVF1QztXQUdhLHdCQUhyQkU7VUFHdkIsaUJBQTBCLG1CQUxqQkQ7VUFLVCxVQUh1QkMsS0FGUmhHLElBV3BCO1FBaEJMLDZCQUhFeUYsU0FFQUssS0FEQUosWUFLQTNJLE9BZWlGO2VBR25Ga0osaUJBQWtDQztRQUF2Qjs7U0FjRSw0QkFkcUJBO1NBZVQsd0NBZlNBO1FBZVQsY0FFZ0I3STtVQUM3QjtzQ0FsQnNCNkksT0FpQk83STtXQWZ6QyxNQURZOEk7V0FHRSx5QkFER3RJO1dBRUwsZUFMZTJILElBS1gsbUJBRkMzSDtXQUdILHlCQUhHQTtXQUlFLDhCQUpGQTtXQUtKLHdCQUxJQTtXQU1MLHVCQU5LQTtVQVFiO3dDQVBFekIsTUFDQW1ELElBQ0FoRCxNQUVBRSxLQUNBYSxJQUZBQyxhQVdtQztRQUQ5QjtpQ0FqQnVCMkk7U0FpQmxDO2lCQUdFdEw7VSxJQUFTMEM7bUJBQ1ArSSxNQUFjQztZQUNGO3FDQURFQTthQUNWLHVCQU5ORjthQU1NO2FBSWlELHdCQUg3Qkc7WUFHbkIsaUJBQTBCLG1CQUxqQkQ7WUFLVCxrQkFORWhKLElBR2lCaUosT0FPaEI7b0NBOUJzQkwsVUFxQjlCRztRQUpKOzRCQUhFWixTQUVBVyxPQURBdEkscUJBS0FsRCxRQWVrRTtnQkF2RnBFMEssWUFvREFXO0lBdkRROzs7OztNQXVXaUI7Ozs7Ozs7O2VBUXZCeEssS0FBS0gsTUFBTWQ7UUFDViwrQkFESWMsT0FNRjtRQUpBOzJCQUZFQTtTQUVGOztZQUZFQTs7O1VBSUksNEJBRExrTCxRQUhPaE07Ozt1REFLOEI7bUJBQ2xDO01BNUtYO09BK0tJaU07O21CQTVLRWxOO1lBQ0Y7Y0FDRTs7O2VBQ1Usb0JBRFdtTixhQUZyQm5OO2NBR1UsVUFGWjtjQUNFO2VBV1MsdUJBYlRBO2VBU08sNkNBUE9FO2NBYVQsc0JBUElrTjtjQU9KLDJCQVBJQSxRQVErQjtZQWYxQyw0Q0FnQlU7MEJBbkJHLFFBQUU7ZUFnTGZDLFFBQVF0TCxNQUFNZCxJQUFJdUM7UUFDcEIsbUJBRGdCdkM7UUFDaEI7MkJBRFVjO1NBQ1Y7O1lBRFVBOztRQUVGLDRCQUZRZCxJQUFJdUMsTUFFZ0I7ZUFHbEMxQixJQUFJQyxNQUFNZDtRQUNULCtCQURHYyxPQUtEO1FBSEE7MkJBRkNBO1NBRUQ7O1lBRkNBOztRQUlKLHVCQURJa0wsUUFITWhNLElBS0Y7O09BSVZxSztPQUNBZ0MsMkIsdUJBREFoQztPQUVBaUMsMkIsdUJBRkFqQztPQUdBa0MsMkIsdUJBSEFsQztPQUlBbUMsMkIsdUJBSkFuQztPQUtBb0MsMkIsdUJBTEFwQztPQU1BcUMsMkIsdUJBTkFyQztlQVFBc0MsY0FBYzVOO1FBQ2hCLFNBbEJJOEIsSUFVRndMLE9BT2N0TjtRQUNoQjs7O1VBQ0csU0FuQkM4QixJQVdGeUwsT0FNY3ZOO1VBRWI7OztZQUNBLFNBcEJDOEIsSUFZRjBMLE9BS2N4TjtZQUdiOzs7Y0FDQSxTQXJCQzhCLElBYUYyTCxPQUljek47Y0FJYjs7O2dCQUNBLFNBdEJDOEIsSUFjRjRMLE9BR2MxTjtnQkFLYixpQkF0QkM4QixJQWVGNkwsT0FFYzNOO2dCQUtiO21CQUN3QjtVQWhMN0I2TixjQTBLSUQ7ZUF0R0pFLFVBMFNjQztRQUVGLElBQU4vTixJQUZRK04sY0FFRixPQTVOTlYsUUFlRkMsT0E2TUV0TixJQUZRK04sUUFHd0I7ZUE1U3RDQyxVQStTY0Q7UUFFRixJQUFOL04sSUFBbUIsV0FGWCtOLFdBUlYvTTtRQVVRLE9BbE9OcU0sUUFnQkZFLE9Ba05Fdk4sSUFGUStOLFFBR3dCO2VBalR0Q0UsVUFvVGNGO1FBRUYsSUFBTi9OLElBQW1CLFdBRlgrTixXQWRWL007UUFnQlEsT0F4T05xTSxRQWlCRkcsT0F1TkV4TixJQUZRK04sUUFHd0I7ZUF0VHRDRyxVQXlUY0g7UUFFRixJQUFOL04sSUFBbUIsV0FGWCtOLFdBcEJWL007UUFzQlEsT0E5T05xTSxRQWtCRkksT0E0TkV6TixJQUZRK04sUUFHd0I7ZUEzVHRDSSxVQThUY0o7UUFFRixJQUFOL04sSUFBbUIsV0FGWCtOLFdBMUJWL007UUE0QlEsT0FwUE5xTSxRQW1CRkssT0FpT0UxTixJQUZRK04sUUFHd0I7ZUFoVXRDSyxVQW1VY0w7UUFFRixJQUFOL04sSUFBbUIsV0FGWCtOLFdBaENWL007UUFrQ1EsT0ExUE5xTSxRQW9CRk0sT0FzT0UzTixJQUZRK04sUUFHd0I7ZUFuVXRDTSxTQXNVc0JDLGFBTWRQO1FBRmdCLElBQWhCdEwsY0FBZ0IsdUJBSkY2TDtRQUlFLE9BbFZ4QlIsYUE4VXNCUSxhQUlkN0wsY0FFQXNMLFNBR2tCOzs7Ozs7Ozs7Ozs7Ozs7OztlQW9IdEJRLFdBQVd2STtRQUNDOztTQUNHO2lCQUNUdUk7VTtVQUFBOzs7c0JBQ1c7c0JBQ0U7c0JBQ0E7c0JBQ0k7c0JBQ0w7c0JBQ0M7c0JBQ0M7c0JBQ0Q7c0JBQ0Q7dUJBQ0E7WUFWWjs7ZUFXa0Isc0JBQVMsS0FYM0JBLFdBV1dHO2VBQWdCOztlQUNYLHNCQUFPLEtBWnZCSCxXQVlTSTtlQUFjOztlQUNOLHNCQUFRLEtBYnpCSixXQWFVSztlQUFlOztlQUNULHNCQUFTLEtBZHpCTCxXQWNTTTtlQUFnQjs7ZUFDVixzQkFBTyxLQWZ0Qk4sV0FlUU87ZUFBYzs7ZUFDa0M7O2dCQUFyQzVIO2dCQUFMQztnQkFBMEMsS0FoQnhEb0gsV0FnQm1Cckg7Z0JBQW9CLEtBaEJ2Q3FILFdBZ0JjcEg7ZUFBeUI7O2VBSzNDLElBSmM0SDtlQUlkLE9BSmNBOztrQkFNRjs0QkFORUE7bUJBS1VqUDttQkFBSEQ7bUJBQ1QsR0F2QlIwTyxXQXNCaUIxTzttQkFFVCxHQXhCUjBPLFdBc0JvQnpPO2tCQUVaLHdCQURMa1AsR0FDQUM7O2tCQUdLOzRCQVZFRjttQkFTYXJNO21CQUFIOEQ7bUJBQUhDO21CQUNULEtBM0JSOEgsV0EwQmlCOUg7bUJBRVQsS0E1QlI4SCxXQTBCb0IvSDttQkFHWixHQTdCUitILFdBMEJ1QjdMO2tCQUdmLHdCQUZMd00sS0FDQUMsS0FDQUM7O2tCQUdLOzRCQWZFTDttQkFjZ0JwTTttQkFBSCtEO21CQUFIQzttQkFBSEM7bUJBQ1QsS0FoQ1IySCxXQStCaUIzSDttQkFFVCxLQWpDUjJILFdBK0JvQjVIO21CQUdaLEtBbENSNEgsV0ErQnVCN0g7bUJBSWYsR0FuQ1I2SCxXQStCMEI1TDtrQkFJbEIsd0JBSEwwTSxLQUNBQyxLQUNBQyxLQUNBQzs7a0JBR0s7NEJBckJFVDttQkFvQm1Cbk07bUJBQUhpRTttQkFBSEM7bUJBQUhDO21CQUFIQzttQkFDVCxLQXRDUnVILFdBcUNpQnZIO21CQUVULEtBdkNSdUgsV0FxQ29CeEg7bUJBR1osS0F4Q1J3SCxXQXFDdUJ6SDttQkFJZixLQXpDUnlILFdBcUMwQjFIO21CQUtsQixHQTFDUjBILFdBcUM2QjNMO2tCQUtyQix3QkFKTDZNLEtBQ0FDLEtBQ0FDLEtBQ0FDLEtBQ0FDOztlQUdQOztnQkFBUywrQkE3Q0x0QixZQTRDVzVCO2VBQ047O2VBRVQ7O2dCQUFVLCtCQS9DTjRCLFlBOENZdkM7ZUFDTjs7ZUFFSzs7Z0JBRE84RDtnQkFBUEM7Z0JBQ0Esa0NBREFBO2dCQUVSLDRCQW5EUHRCLFdBa0RJdkM7ZUFDRztpQkFDVyxJQUFWOEQsbUJBQVUsMkJBQVZBO2VBbkttQixPQWdLWkQ7O2tCQTlKakIsVUE4SmlCQSxTQXpZWCxNQWhESjdOLEtBMEJGb0wsT0FnUWlCbEc7a0JBMU9YO29CQUdKOztxQkFDYyxRRC9VaEJ4RixpQkM2VU9vRSxPQXdPVW9CO3FCQXRPRDswQkFGVHBCO29CQVFpQixnQkFObEJ4RztvQkFESjs7OzttQkE0T0Msa0NBREt5UTs7Ozs7a0JBS1IsVUFzSmlCRixTQXZYWCxRQWxFSjdOLEtBMkJGcUwsT0F1UWlCbEc7a0JBaE9YO29CQUdKOzttQ0E2TmVBO2tEQTlOVnBCLGFBUUt4RDs7MEJBUkx3RDtvQkFnQmlCO29CQWZ0Qjs7OzttQkFrT0M7O29CQUFjLG9CQURUaUssU0FtR0YzQixXQXZHV2xIO2dDQUtWOEk7Ozs7O2tCQUtQLFVBNklpQkosU0EzVlgsUUE5Rko3TixLQTRCRnNMLE9BK1FpQjRDO2tCQTdNWDtvQkFHSjs7cUNBME1lQTtrREEzTVZsSyxhQVFLOUI7OzBCQVJMOEI7b0JBZ0JpQjtvQkFmdEI7Ozs7bUJBK01DOztvQkFDNEIsS0F3RnpCcUksV0E5Rlc2QjtvQkFNWCxvQkFGRUMsU0EwRkY5QixXQTlGVzZCO2dDQUtWRTs7Ozs7a0JBT1AsVUFrSWlCUCxTQTNUWCxRQTlISjdOLEtBNkJGdUwsT0F5UmlCOEM7a0JBeExYO29CQUdKOztxQ0FxTGVBO2tEQXRMVnBLLGFBUUtjOzswQkFSTGQ7b0JBaUJpQjtvQkFoQnRCOzs7O21CQTBMQzs7b0JBQzhDLEtBNkUzQ29JLFdBbkZXZ0M7b0JBTWMsS0E2RXpCaEMsV0FuRldnQztvQkFNWCxvQkFGRUMsU0ErRUZqQyxXQW5GV2dDO2dDQUtWRTs7Ozs7a0JBUVAsVUFzSGlCVixTQXpSWCxRQWhLSjdOLEtBOEJGd0wsT0FvU2lCZ0Q7a0JBbEtYO29CQUdKOztxQ0ErSmVBO2tEQWhLVnRLLGFBUUt1Szs7MEJBUkx2SztvQkFxQmlCO29CQXBCdEI7Ozs7bUJBb0tDOztvQkFDZ0UsS0FpRTdEbUksV0F2RVdtQztvQkFNZ0MsS0FpRTNDbkMsV0F2RVdtQztvQkFNYyxLQWlFekJuQyxXQXZFV21DO29CQU1YO2dDQUZFRSxTQW1FRnJDLFdBdkVXbUM7Z0NBS1ZHOzs7OztrQkFRUCxXQTBHaUJkLFNBbFBYLFFBdk1KN04sS0ErQkZ5TCxPQStTaUJtRDtrQkF2SVg7b0JBR0o7O3FDQW9JZUE7Z0RBcklWekssYUFRSzBLOzswQkFSTDFLO29CQXNCaUI7b0JBckJ0Qjs7OzttQkF5SUM7O29CQU1LLEtBZ0RGa0ksV0EzRFd1QztvQkFVVCxLQWlERnZDLFdBM0RXdUM7b0JBU1QsS0FrREZ2QyxXQTNEV3VDO29CQVFULEtBbURGdkMsV0EzRFd1QztvQkFNWDs7dUJBRkVFLFNBdURGekMsV0EzRFd1QztnQ0FLVkc7Ozs0QkE0R3FCLElBQWZDLHdCQUFlLE9BQWZBO2VBRUwsS0FSZ0JwQjtpQkFVRixJQWhHQXFCLE9BZ0dBLGtCQVRoQmpGO2lCQXZGeUIsOEJBQVRpRjtlQXVGTDtxQkFET3JCOztnQkFZRnNCOzs7O2VBQ1IsdUJBRFFBO2lCQUdJLElBQVRDLFNBQVMsb0JBakV4QjdDLFFBbURJdEM7aUJBZU8sbUJBakVYdUMsV0FrREl2QyxTQWNXbUY7aUJBQVMsSUFFVEMsY0FqRVgvQyxXQTREZ0I2QztpQkFLUywyQkFGZEMsU0FFQUM7ZUFoQkEsWUFXS0Y7eUJBT2U7UUFFckIsSUFBZEYsWUFyRUkzQyxXQUhLdkk7UUF3RUssb0JBQWRrTCxZQUNnQjs7Y0F4bEJ0QnJEOztjQW9FQUM7Y0FDQUU7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FDQUM7Y0FHQUM7Y0FtY0lFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFydkJROzs7Ozs7O1NBd0pHLFNBQVRsTixhO1NBQVM7cUJBQVRBO1VBQVM7a0JBV1hxQyxXQUFReEQ7V0FDQzttQ0FEREE7WUFDQyxxQkFDVyxtQkFEbEJxUixLQUN3QztZQURqQzs4QkFFa0JFLE9BQVMsa0JBRGxDRCxLQUN5QkMsTUFBaUIsRUFEMUNELE9BSUg7U0FqQlksU0FvQlhFLG9CQUFvQjFCO1dBQ3RCLFNBRHNCQTtXQUN0QixVQUVVLE9BSFlBO1dBQ3RCLElBQ08yQjtXQUFRLE9BQVJBLElBQzZCO1NBdkJ2QixTQTBCWEMsc0JBQXNCNUIsT0FBT2tCO1dBQy9CLElBQUlXLHdCQURvQjdCO1dBQ3hCLEdBQUk2QiwyQkFFUTtXQUVQLHdCQUxtQjdCLFVBQU9rQjtZQUtrQztXQUMvRCxnQ0FONkJBO1dBTTdCLGVBTjZCQTtXQU03QixPQU42QkEsV0FRbEI7U0FsQ0EsU0FxQ1hZLGFBQVUsUUFBSTs7O2lCQTFCZHBPO2lCQVNBZ087aUJBTUFFO2lCQVdBRTs7O0lBN0xROztJSEREOzJCQTJKUHJQO2VBRUFzTixNQUE0QmdDLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU1DO1FBT2xEO3FDQVBrREE7U0FNbEQsNEJBTjRDRDtTQUs1Qyw0QkFMc0NEO1NBSXRDLDRCQUpnQ0Q7U0FHaEMsNEJBSDBCRDtTQUU1Qjs7OztpQkFGNEJBO2lCQUFNQztpQkFBTUM7aUJBQU1DO2lCQUFNQztpQkFrQzlDQztpQkFDQTNQO2lCQUNBakQsU0FFbUM7Z0JBdEN6Q3VRLE1BRkF0TjtJQTNKTzsyQkFpSFBBO2VBRUFzTixNQUF5QmdDLE1BQU1DLE1BQU1DLE1BQU1DO1FBTXpDO29DQU55Q0E7U0FLekMsNEJBTG1DRDtTQUluQyw0QkFKNkJEO1NBRzdCLDRCQUh1QkQ7U0FFekI7Ozs7aUJBRnlCQTtpQkFBTUM7aUJBQU1DO2lCQUFNQztpQkE2QnJDRTtpQkFDQTNQO2lCQWdEQWpELFNBN0MrQjtnQkFqQ3JDdVEsTUFGQXROO0lBakhPOzJCQTRFUEE7ZUFFQXNOLE1BQXNCZ0MsTUFBTUMsTUFBTUM7UUFLaEM7b0NBTGdDQTtTQUloQywyQkFKMEJEO1NBRzFCLDJCQUhvQkQ7U0FFdEI7OzttQkFGc0JBLE1BQU1DLE1BQU1DLE1Bd0I1Qkcsa0JBQ0EzUCxjQTBGQWpELFNBdkYyQjtnQkE1QmpDdVEsTUFGQXROO0lBNUVPOzJCQThDUEE7ZUFFQXNOLE1BQW1CZ0MsTUFBTUM7UUFFNkI7b0NBRjdCQTtTQUVELDJCQUZMRDtTQUVuQjs7cUJBRm1CQSxNQUFNQyxNQWlCbkJJLGtCQUNBM1AsY0ErSEFqRCxTQTVIdUI7Z0JBckI3QnVRLE1BRkF0TjtJQTlDTzsyQkFzQlBBO2VBRUFzTixNQUFnQmdDO1FBQzBCO29DQUQxQkE7U0FDRTs7cUJBREZBLE1BV1ZLLGtCQUNBM1AsY0E2SkFqRCxTQTFKaUI7Z0JBZnZCdVEsTUFGQXROO0lBdEJPOzs7T0FHUEE7T0FRTTJQO09BTk5yQyxZQU1NcUMsa0JBUk4zUCxjQThMTWpEO2dCQTVMTnVRLE1BRkF0TjtJQUhPOzs7SU9BQTttQkFHUDRQLDRCQUNBNVA7Z0JBREE0UCxhQUNBNVA7SUFKTztNO2VBVVA0UCxhQUFhTixPQUF1Qiw2QkFBdkJBLFVBQTJDO1VBQ3hEdFA7Z0JBREE0UCxhQUNBNVA7SUFYTztNO2VBa0JQNFAsYUFBYU4sTUFBTUM7UUFBdUIsNkJBQTdCRCxNQUFNQyxVQUFpRDtVQUNwRXZQO2dCQURBNFAsYUFDQTVQO0lBbkJPO007ZUEwQlA0UCxhQUFhTixNQUFNQyxNQUFNQztRQUF1Qiw2QkFBbkNGLE1BQU1DLE1BQU1DLFVBQXVEO1VBQ2hGeFA7Z0JBREE0UCxhQUNBNVA7SUEzQk87TTtlQWtDUDRQLGFBQWFOLE1BQU1DLE1BQU1DLE1BQU1DO1FBQ2xCLDZCQURBSCxNQUFNQyxNQUFNQyxNQUFNQyxVQUNvQjtVQUduRHpQO2dCQUpBNFAsYUFJQTVQO0lBdENPO007ZUE2Q1A0UCxhQUFhTixNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQztRQUN4Qiw2QkFEQUosTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsVUFDb0I7VUFHekQxUDtnQkFKQTRQLGFBSUE1UDtJQWpETzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09SRFBrQztPQVdBQztPQVdBQztPQVdBQzs7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FXQUM7T0FpQkFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDO09BVUFDO09BUUFDO09BUUFDO09BUUFDO09BUUFDO0lRck1PO1UiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgTmFtZV9vZiA9IHN0cnVjdFxuICBsZXQgdHlwZW5hbWVfb2ZfaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQzMiA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50MzJcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50MzJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2ludDY0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnQ2NFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJpbnQ2NFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfbmF0aXZlaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBuYXRpdmVpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwibmF0aXZlaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9jaGFyID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBjaGFyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImNoYXJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Zsb2F0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBmbG9hdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJmbG9hdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2Zfc3RyaW5nID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICBsZXQgbmFtZSA9IFwic3RyaW5nXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ieXRlcyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYnl0ZXNcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Jvb2wgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJvb2xcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYm9vbFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdW5pdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJ1bml0XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIG1vZHVsZSBNX29wdGlvbiA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gICAgICBsZXQgbmFtZSA9IFwib3B0aW9uXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX29wdGlvbiA9IE1fb3B0aW9uLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9saXN0ID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGlzdFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9saXN0ID0gTV9saXN0LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9hcnJheSA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbiAgICAgIGxldCBuYW1lID0gXCJhcnJheVwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9hcnJheSA9IE1fYXJyYXkudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2xhenlfdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGF6eV90XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2xhenlfdCA9IE1fbGF6eV90LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9yZWYgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZWZcblxuICAgICAgbGV0IG5hbWUgPSBcInJlZlwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9yZWYgPSBNX3JlZi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fZnVuY3Rpb24gPSBUeXBlbmFtZS5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSAtPiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwiZnVuY3Rpb25cIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfZnVuY3Rpb24gPSBNX2Z1bmN0aW9uLnR5cGVuYW1lX29mX3RcblxuICB0eXBlIHR1cGxlMCA9IHVuaXRcblxuICBtb2R1bGUgTV90dXBsZTAgPSBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICB0eXBlIHQgPSB0dXBsZTBcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlMFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTAgPSBNX3R1cGxlMC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUyID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgKiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGUyXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMiA9IE1fdHVwbGUyLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTMgPSBUeXBlbmFtZS5NYWtlMyAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2EgKiAnYiAqICdjXG5cbiAgICAgIGxldCBuYW1lID0gXCJ0dXBsZTNcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUzID0gTV90dXBsZTMudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNCA9IFR5cGVuYW1lLk1ha2U0IChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0ID0gJ2EgKiAnYiAqICdjICogJ2RcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlNFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTQgPSBNX3R1cGxlNC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGU1ID0gVHlwZW5hbWUuTWFrZTUgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gJ2EgKiAnYiAqICdjICogJ2QgKiAnZVxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGU1XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlNSA9IE1fdHVwbGU1LnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgcmVjIFR5cGVyZXAgOiBzaWdcbiAgdHlwZSBfIHQgPVxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEludDMyIDogaW50MzIgdFxuICAgIHwgSW50NjQgOiBpbnQ2NCB0XG4gICAgfCBOYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICAgIHwgQ2hhciA6IGNoYXIgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgQnl0ZXMgOiBieXRlcyB0XG4gICAgfCBCb29sIDogYm9vbCB0XG4gICAgfCBVbml0IDogdW5pdCB0XG4gICAgfCBPcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgfCBMaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB8IEFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gICAgfCBMYXp5IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICAgIHwgUmVmIDogJ2EgdCAtPiAnYSByZWYgdFxuICAgIHwgRnVuY3Rpb24gOiAoJ2RvbSB0ICogJ3JuZyB0KSAtPiAoJ2RvbSAtPiAncm5nKSB0XG4gICAgfCBUdXBsZSA6ICdhIFR5cGVyZXAuVHVwbGUudCAtPiAnYSB0XG4gICAgfCBSZWNvcmQgOiAnYSBUeXBlcmVwLlJlY29yZC50IC0+ICdhIHRcbiAgICB8IFZhcmlhbnQgOiAnYSBUeXBlcmVwLlZhcmlhbnQudCAtPiAnYSB0XG4gICAgfCBOYW1lZCA6ICgnYSBUeXBlcmVwLk5hbWVkLnQgKiAnYSB0IGxhenlfdCBvcHRpb24pIC0+ICdhIHRcblxuICB0eXBlIHBhY2tlZCA9IFQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFQwID0gc2lnXG4gICAgICB0eXBlIG5hbWVkXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQxID0gc2lnXG4gICAgICB0eXBlICdhIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgYSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMiA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2IgVHlwZW5hbWUudCAtPiAoJ2EsICdiKSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQzID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYykgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ0ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNSA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBlXG5cbiAgICAgIHZhbCBlIDogZSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdlIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQsIGUpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgICgqIHRoZXJlIHRoZSBtb2R1bGUgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggYSB0eXBlIFt0XSB3aXRoXG4gICAgICAgcGFyYW1ldGVycyB3aG9zZSBraW5kIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgdHlwZSB2YXJpYWJsZTogWydhICd0XSwgZXZlbiB3aXRoXG4gICAgICAgYSBnYWR0LiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFQwIG9mIChtb2R1bGUgVDAgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDEgb2YgKG1vZHVsZSBUMSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMiBvZiAobW9kdWxlIFQyIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQzIG9mIChtb2R1bGUgVDMgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDQgb2YgKG1vZHVsZSBUNCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNSBvZiAobW9kdWxlIFQ1IHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIFR1cGxlIDogc2lnXG4gICAgKCogdGhlc2UgY29uc3RydWN0b3JzIGNvdWxkIGJlIHBsdW5nZWQgYXQgdG9wbGV2ZWwgb2YgVHlwZXJlcC50LCBob3dldmVyIGl0IGlzIGxlc3NcbiAgICAgICB2ZXJib3NlIHRoYXQgd2F5ICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBUMiA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQpIC0+ICgnYSAqICdiKSB0XG4gICAgICB8IFQzIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCkgLT4gKCdhICogJ2IgKiAnYykgdFxuICAgICAgfCBUNCA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgICAgIHwgVDUgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQgKiAnZSBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkICogJ2UpIHRcblxuICAgIHZhbCBhcml0eSA6IF8gdCAtPiBpbnRcbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVHlwZXJlcC50XG5cbiAgdmFsIHNhbWUgOiBfIHQgLT4gXyB0IC0+IGJvb2xcbiAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG4gIHZhbCBzYW1lX3dpdG5lc3NfZXhuIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSwgJ2IpIFR5cGVfZXF1YWwudFxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICB2YWwgaGVhZCA6ICdhIHQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IGFyaXR5ID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgXyAtPiAwXG4gICAgICB8IFQxIF8gLT4gMVxuICAgICAgfCBUMiBfIC0+IDJcbiAgICAgIHwgVDMgXyAtPiAzXG4gICAgICB8IFQ0IF8gLT4gNFxuICAgICAgfCBUNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgKHR5cGUgYSkgPSBmdW5jdGlvblxuICAgICAgfCBUMCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMiByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMiB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMyByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgbmFtZSByZXAgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkICh0eXBlbmFtZV9vZl90IHJlcCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA9IHN0cnVjdFxuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGlzIHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICBsZXQgYXJpdHkgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIF8gLT4gMlxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIF8gLT4gM1xuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IF8gLT4gNFxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IF8gLT4gNVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgICB8IFQyIChhLCBiKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlMiAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgIHwgVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGUzXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICB8IFQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNFxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgIHwgVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGU1XG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBkKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLk0gKHN0cnVjdFxuICAgICAgdHlwZSAnYSByZXAgPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZXBcbiAgICBlbmQpXG5cbiAgbGV0IHJlYyB0eXBlbmFtZV9vZl90IDogdHlwZSBhLiBhIHQgLT4gYSBUeXBlbmFtZS50ID0gZnVuY3Rpb25cbiAgICB8IEludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2ludFxuICAgIHwgSW50MzIgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQzMlxuICAgIHwgSW50NjQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQ2NFxuICAgIHwgTmF0aXZlaW50IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbmF0aXZlaW50XG4gICAgfCBDaGFyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfY2hhclxuICAgIHwgRmxvYXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9mbG9hdFxuICAgIHwgU3RyaW5nIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfc3RyaW5nXG4gICAgfCBCeXRlcyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2J5dGVzXG4gICAgfCBCb29sIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfYm9vbFxuICAgIHwgVW5pdCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3VuaXRcbiAgICB8IE9wdGlvbiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9vcHRpb24gKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgTGlzdCByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9saXN0ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEFycmF5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2FycmF5ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExhenkgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGF6eV90ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IFJlZiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9yZWYgKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgRnVuY3Rpb24gKGRvbSwgcm5nKSAtPlxuICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl9mdW5jdGlvbiAodHlwZW5hbWVfb2ZfdCBkb20pICh0eXBlbmFtZV9vZl90IHJuZylcbiAgICB8IFR1cGxlIHJlcCAtPiBUeXBlcmVwLlR1cGxlLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBSZWNvcmQgcmVwIC0+IFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBWYXJpYW50IHJlcCAtPiBUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByZXBcbiAgICB8IE5hbWVkIChuYW1lLCBfKSAtPiBOYW1lZC50eXBlbmFtZV9vZl90IG5hbWVcbiAgOztcblxuICBsZXQgcmVjIHNhbWVfd2l0bmVzcyA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBUeXBlX2VxdWFsLnQgb3B0aW9uID1cbiAgICBmdW4gdDEgdDIgLT5cbiAgICAgIGxldCBtb2R1bGUgRSA9IFR5cGVfZXF1YWwgaW5cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IE5hbWVkIChuYW1lMSwgcjEpLCBOYW1lZCAobmFtZTIsIHIyKSAtPlxuICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUxKSAoTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lMilcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4XG4gICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHIxLCByMiB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgKGxhenkgdDEpLCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICAgIHwgU29tZSAobGF6eSB0MSksIE5vbmUgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgICB8IE5vbmUsIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgICAgfCBOb25lLCBOb25lIC0+IE5vbmUpKVxuICAgICAgfCBOYW1lZCAoXywgcjEpLCB0MiAtPlxuICAgICAgICAobWF0Y2ggcjEgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQxKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCB0MSwgTmFtZWQgKF8sIHIyKSAtPlxuICAgICAgICAobWF0Y2ggcjIgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBJbnQsIEludCAtPiBTb21lIEUuVFxuICAgICAgfCBJbnQzMiwgSW50MzIgLT4gU29tZSBFLlRcbiAgICAgIHwgSW50NjQsIEludDY0IC0+IFNvbWUgRS5UXG4gICAgICB8IE5hdGl2ZWludCwgTmF0aXZlaW50IC0+IFNvbWUgRS5UXG4gICAgICB8IENoYXIsIENoYXIgLT4gU29tZSBFLlRcbiAgICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRS5UXG4gICAgICB8IFN0cmluZywgU3RyaW5nIC0+IFNvbWUgRS5UXG4gICAgICB8IEJ5dGVzLCBCeXRlcyAtPiBTb21lIEUuVFxuICAgICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRS5UXG4gICAgICB8IFVuaXQsIFVuaXQgLT4gU29tZSBFLlRcbiAgICAgIHwgT3B0aW9uIHIxLCBPcHRpb24gcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGlzdCByMSwgTGlzdCByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBBcnJheSByMSwgQXJyYXkgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGF6eSByMSwgTGF6eSByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBSZWYgcjEsIFJlZiByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBGdW5jdGlvbiAoZG9tMSwgcm5nMSksIEZ1bmN0aW9uIChkb20yLCBybmcyKSAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGRvbTEgZG9tMiwgc2FtZV93aXRuZXNzIHJuZzEgcm5nMiB3aXRoXG4gICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgfCBUdXBsZSB0MSwgVHVwbGUgdDIgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gVHlwZXJlcC5UdXBsZSBpblxuICAgICAgICAobWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgIHwgVC5UMiAoYTEsIGIxKSwgVC5UMiAoYTIsIGIyKSAtPlxuICAgICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UMyAoYTEsIGIxLCBjMSksIFQuVDMgKGEyLCBiMiwgYzIpIC0+XG4gICAgICAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgYTEgYTIsIHNhbWVfd2l0bmVzcyBiMSBiMiwgc2FtZV93aXRuZXNzIGMxIGMyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UNCAoYTEsIGIxLCBjMSwgZDEpLCBULlQ0IChhMiwgYjIsIGMyLCBkMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfLCBfIHwgXywgTm9uZSwgXywgXyB8IF8sIF8sIE5vbmUsIF8gfCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICB8IFQuVDUgKGExLCBiMSwgYzEsIGQxLCBlMSksIFQuVDUgKGEyLCBiMiwgYzIsIGQyLCBlMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICggc2FtZV93aXRuZXNzIGExIGEyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGIxIGIyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGMxIGMyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGQxIGQyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGUxIGUyIClcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgICB8IE5vbmUsIF8sIF8sIF8sIF9cbiAgICAgICAgICAgIHwgXywgTm9uZSwgXywgXywgX1xuICAgICAgICAgICAgfCBfLCBfLCBOb25lLCBfLCBfXG4gICAgICAgICAgICB8IF8sIF8sIF8sIE5vbmUsIF9cbiAgICAgICAgICAgIHwgXywgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgfCBULlQyIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQzIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ0IF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ1IF8sIF8gLT4gTm9uZSlcbiAgICAgIHwgUmVjb3JkIHIxLCBSZWNvcmQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjIpXG4gICAgICB8IFZhcmlhbnQgcjEsIFZhcmlhbnQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuVmFyaWFudC50eXBlbmFtZV9vZl90IHIxKVxuICAgICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMilcbiAgICAgIHwgSW50LCBfIC0+IE5vbmVcbiAgICAgIHwgSW50MzIsIF8gLT4gTm9uZVxuICAgICAgfCBJbnQ2NCwgXyAtPiBOb25lXG4gICAgICB8IE5hdGl2ZWludCwgXyAtPiBOb25lXG4gICAgICB8IENoYXIsIF8gLT4gTm9uZVxuICAgICAgfCBGbG9hdCwgXyAtPiBOb25lXG4gICAgICB8IFN0cmluZywgXyAtPiBOb25lXG4gICAgICB8IEJ5dGVzLCBfIC0+IE5vbmVcbiAgICAgIHwgQm9vbCwgXyAtPiBOb25lXG4gICAgICB8IFVuaXQsIF8gLT4gTm9uZVxuICAgICAgfCBPcHRpb24gXywgXyAtPiBOb25lXG4gICAgICB8IExpc3QgXywgXyAtPiBOb25lXG4gICAgICB8IEFycmF5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBMYXp5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBSZWYgXywgXyAtPiBOb25lXG4gICAgICB8IEZ1bmN0aW9uIF8sIF8gLT4gTm9uZVxuICAgICAgfCBUdXBsZSBfLCBfIC0+IE5vbmVcbiAgICAgIHwgUmVjb3JkIF8sIF8gLT4gTm9uZVxuICAgICAgfCBWYXJpYW50IF8sIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lIGEgYiA9IHNhbWVfd2l0bmVzcyBhIGIgPD4gTm9uZVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIGEgYiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIGEgYiB3aXRoXG4gICAgfCBTb21lIHByb29mIC0+IHByb29mXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgaGVhZCA9IGZ1bmN0aW9uXG4gICAgfCBUeXBlcmVwLk5hbWVkIChfLCBTb21lIChsYXp5IHQpKSAtPiBoZWFkIHRcbiAgICB8IHQgLT4gdFxuICA7O1xuZW5kXG5cbmxldCB0eXBlcmVwX29mX2ludCA9IFR5cGVyZXAuSW50XG5sZXQgdHlwZXJlcF9vZl9pbnQzMiA9IFR5cGVyZXAuSW50MzJcbmxldCB0eXBlcmVwX29mX2ludDY0ID0gVHlwZXJlcC5JbnQ2NFxubGV0IHR5cGVyZXBfb2ZfbmF0aXZlaW50ID0gVHlwZXJlcC5OYXRpdmVpbnRcbmxldCB0eXBlcmVwX29mX2NoYXIgPSBUeXBlcmVwLkNoYXJcbmxldCB0eXBlcmVwX29mX2Zsb2F0ID0gVHlwZXJlcC5GbG9hdFxubGV0IHR5cGVyZXBfb2Zfc3RyaW5nID0gVHlwZXJlcC5TdHJpbmdcbmxldCB0eXBlcmVwX29mX2J5dGVzID0gVHlwZXJlcC5CeXRlc1xubGV0IHR5cGVyZXBfb2ZfYm9vbCA9IFR5cGVyZXAuQm9vbFxubGV0IHR5cGVyZXBfb2ZfdW5pdCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2Zfb3B0aW9uIHJlcCA9IFR5cGVyZXAuT3B0aW9uIHJlcFxubGV0IHR5cGVyZXBfb2ZfbGlzdCByZXAgPSBUeXBlcmVwLkxpc3QgcmVwXG5sZXQgdHlwZXJlcF9vZl9hcnJheSByZXAgPSBUeXBlcmVwLkFycmF5IHJlcFxubGV0IHR5cGVyZXBfb2ZfbGF6eV90IHJlcCA9IFR5cGVyZXAuTGF6eSByZXBcbmxldCB0eXBlcmVwX29mX3JlZiByZXAgPSBUeXBlcmVwLlJlZiByZXBcbmxldCB0eXBlcmVwX29mX2Z1bmN0aW9uIGRvbSBybmcgPSBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZylcbmxldCB0eXBlcmVwX29mX3R1cGxlMCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2ZfdHVwbGUyIGEgYiA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGUzIGEgYiBjID0gVHlwZXJlcC5UdXBsZSAoVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTQgYSBiIGMgZCA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU1IGEgYiBjIGQgZSA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpKVxuXG5pbmNsdWRlIE5hbWVfb2ZcblxubGV0IHZhbHVlX3R1cGxlMCA9ICgpXG5cbmxldCB0eXBlcmVwX29mX2ludDYzLCB0eXBlbmFtZV9vZl9pbnQ2MyA9XG4gIGxldCB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByXG4gICAgOiB0eXBlIGEgYi4gKGEsIGIpIEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLnQgLT4gYSBUeXBlcmVwLnQgKiBhIFR5cGVuYW1lLnRcbiAgICA9IGZ1bmN0aW9uXG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludCAtPiB0eXBlcmVwX29mX2ludCwgdHlwZW5hbWVfb2ZfaW50XG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludDY0IC0+IHR5cGVyZXBfb2ZfaW50NjQsIHR5cGVuYW1lX29mX2ludDY0XG4gIGluXG4gIHR5cGVyZXBfYW5kX3R5cGVuYW1lX29mX2ludDYzX3JlcHIgQmFzZS5JbnQ2My5Qcml2YXRlLnJlcHJcbjs7XG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCA9XG4gICAgVHlwZXJlcC5OYW1lZC5UMFxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBuYW1lZCA9IFgudFxuICAgICAgICB0eXBlIHQgPSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEpIG9mX3AxID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90IChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSBuYW1lZCA9ICdhIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIHQgPSBwMSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBwMSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIpIG9mX3AxIG9mX3AyID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMlxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZCA9ICgnYSwgJ2IpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyKSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMpIG9mX3AxIG9mX3AyIG9mX3AzID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UM1xuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWQgPSAoJ2EsICdiLCAnYykgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDRcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCkgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgZCA9IHA0XG5cbiAgICAgICAgbGV0IGQgPSBvZl9wNFxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0KSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMgcDQgcDUpIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A0KVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A1KVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UNVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIGUgPSBwNVxuXG4gICAgICAgIGxldCBlID0gb2ZfcDVcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnQpXG4gIDs7XG5lbmRcbiIsInR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIEJhc2UuVHlwZV9lcXVhbC50ID0gVCA6ICgnYSwgJ2EpIHRcbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmxldCByZWZsID0gVFxubGV0IGNvbnYgOiB0eXBlIGEgYi4gKGEsIGIpIHQgLT4gYSAtPiBiID0gZnVuIFQgeCAtPiB4XG5cbm1vZHVsZSBMaWZ0IChYIDogc2lnXG4gICAgdHlwZSAnYSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYSBYLnQsIGIgWC50KSB0ID0gVFxuZW5kXG4iLCIoKiB0aGlzIGxpYiBzaG91bGQgbm90IGRlcGVuZCBvbiBjb3JlICopXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgY29tcGFyZSBjbXAgYSBiID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gMFxuICAgICAgfCBbXSwgXyAtPiAtMVxuICAgICAgfCBfLCBbXSAtPiAxXG4gICAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgICAgIGlmIG4gPSAwIHRoZW4gbG9vcCB4cyB5cyBlbHNlIG5cbiAgICBpblxuICAgIGxvb3AgYSBiXG4gIDs7XG5lbmRcblxubW9kdWxlIFVpZCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIG5leHQgOiBzdHJpbmcgLT4gdFxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIHZhbCBuYW1lIDogdCAtPiBzdHJpbmdcbiAgdmFsIHN0YXRpYyA6IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgY29kZSA6IGludFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIH1cblxuICBsZXQgY29tcGFyZSBhIGIgPSBjb21wYXJlIChhLmNvZGUgOiBpbnQpIGIuY29kZVxuICBsZXQgZXF1YWwgYSBiID0gKGEuY29kZSA6IGludCkgPSBiLmNvZGVcbiAgbGV0IHVpZCA9IHJlZiAwXG5cbiAgbGV0IG5leHQgbmFtZSA9XG4gICAgbGV0IGNvZGUgPSAhdWlkIGluXG4gICAgaW5jciB1aWQ7XG4gICAgeyBjb2RlOyBuYW1lIH1cbiAgOztcblxuICBsZXQgaGFzaCBhID0gSGFzaHRibC5oYXNoIGEuY29kZVxuICBsZXQgbmFtZSBhID0gYS5uYW1lXG4gIGxldCBzdGF0aWMgPSBuZXh0IFwic3RhdGljXCJcbmVuZFxuXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyB1aWQgOiBVaWQudFxuICAgIDsgcGFyYW1zIDogdCBsaXN0XG4gICAgfVxuXG4gIGxldCByZWMgY29tcGFyZSBrMSBrMiA9XG4gICAgaWYgazEgPT0gazJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbXAgPSBVaWQuY29tcGFyZSBrMS51aWQgazIudWlkIGluXG4gICAgICBpZiBjbXAgPD4gMCB0aGVuIGNtcCBlbHNlIExpc3QuY29tcGFyZSBjb21wYXJlIGsxLnBhcmFtcyBrMi5wYXJhbXMpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuICBsZXQgaGFzaCA9IChIYXNodGJsLmhhc2ggOiB0IC0+IGludClcbiAgbGV0IHN0YXRpYyA9IHsgdWlkID0gVWlkLnN0YXRpYzsgcGFyYW1zID0gW10gfVxuZW5kXG5cbnR5cGUgJ2EgdCA9IEtleS50XG50eXBlICdhIHR5cGVuYW1lID0gJ2EgdFxuXG5sZXQga2V5IHQgPSB0XG5sZXQgdWlkIHQgPSB0LktleS51aWRcbmxldCBuYW1lIHQgPSBVaWQubmFtZSB0LktleS51aWRcbmxldCBzdGF0aWMgPSBLZXkuc3RhdGljXG5sZXQgY3JlYXRlID8obmFtZSA9IFwiVHlwZW5hbWUuY3JlYXRlXCIpICgpID0geyBLZXkudWlkID0gVWlkLm5leHQgbmFtZTsgcGFyYW1zID0gW10gfVxuXG5pbmNsdWRlIHN0cnVjdFxuICAoKiBUaGUgYXJndW1lbnQgZm9yIE9iai5tYWdpYyBoZXJlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gY29yZS90eXBlX2VxdWFsICopXG5cbiAgbGV0IHNhbWUgKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9IEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG5cbiAgbGV0IHNhbWVfd2l0bmVzcyAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gU29tZSAoT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpXG4gICAgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9XG4gICAgaWYgS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcbiAgICB0aGVuIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIGZhaWx3aXRoIFwiVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4blwiXG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAoJ2EsICdiKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2IgdHlwZW5hbWUgLT4gJ2MgdHlwZW5hbWUgLT4gKCdhLCAnYiwgJ2MpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdFxuICAgIDogICdhIHR5cGVuYW1lXG4gICAgLT4gJ2IgdHlwZW5hbWVcbiAgICAtPiAnYyB0eXBlbmFtZVxuICAgIC0+ICdkIHR5cGVuYW1lXG4gICAgLT4gJ2UgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gW10gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGIgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjOyBkIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCBlID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQ7IGUgXSB9XG5lbmRcblxubW9kdWxlIEtleV90YWJsZSA9IEhhc2h0YmwuTWFrZSAoS2V5KVxuXG5tb2R1bGUgVGFibGUgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBkYXRhID0gRGF0YSA6ICdhIHQgKiAnYSBYLnQgLT4gZGF0YVxuICB0eXBlIHQgPSBkYXRhIEtleV90YWJsZS50XG5cbiAgbGV0IGNyZWF0ZSBpbnQgPSBLZXlfdGFibGUuY3JlYXRlIGludFxuICBsZXQgbWVtIHRhYmxlIG5hbWUgPSBLZXlfdGFibGUubWVtIHRhYmxlIChrZXkgbmFtZSlcbiAgbGV0IHNldCB0YWJsZSBuYW1lIGRhdGEgPSBLZXlfdGFibGUucmVwbGFjZSB0YWJsZSAoa2V5IG5hbWUpIChEYXRhIChuYW1lLCBkYXRhKSlcblxuICBsZXQgZmluZCAodHlwZSBhKSB0YWJsZSAobmFtZSA6IGEgdHlwZW5hbWUpID1cbiAgICBsZXQgZGF0YSA9XG4gICAgICB0cnkgU29tZSAoS2V5X3RhYmxlLmZpbmQgdGFibGUgKGtleSBuYW1lKSkgd2l0aFxuICAgICAgfCBCYXNlLk5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAoRGF0YSAobmFtZScsIGRhdGEpKSAtPlxuICAgICAgKGZ1biAodHlwZSBiKSAobmFtZScgOiBiIHR5cGVuYW1lKSAoZGF0YSA6IGIgWC50KSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IChzYW1lX3dpdG5lc3NfZXhuIG5hbWUnIG5hbWUgOiAoYiwgYSkgVHlwZV9lcXVhbC50KSBpblxuICAgICAgICAgU29tZSAoZGF0YSA6IGEgWC50KSlcbiAgICAgICAgbmFtZSdcbiAgICAgICAgZGF0YVxuICA7O1xuZW5kXG5cbmxldCBmYWlsIHVpZF9hIHVpZF9iID1cbiAgbGV0IG1zZyA9XG4gICAgUHJpbnRmLnNwcmludGYgXCJUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuICVTICVTXCIgKFVpZC5uYW1lIHVpZF9hKSAoVWlkLm5hbWUgdWlkX2IpXG4gIGluXG4gIGZhaWx3aXRoIG1zZ1xuOztcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMSAoQSA6IFMxKSAoQiA6IFMxKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EuICgnYSBBLnQsICdhIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzIgKEEgOiBTMikgKEIgOiBTMikgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiLiAoKCdhLCAnYikgQS50LCAoJ2EsICdiKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzMgKEEgOiBTMykgKEIgOiBTMykgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiICdjLiAoKCdhLCAnYiwgJ2MpIEEudCwgKCdhLCAnYiwgJ2MpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgaWYgVWlkLmVxdWFsIHVpZF9hIHVpZF9iIHRoZW4geyBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl80IChBIDogUzQpIChCIDogUzQpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYiAnYyAnZC4gKCgnYSwgJ2IsICdjLCAnZCkgQS50LCAoJ2EsICdiLCAnYywgJ2QpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzUgKEEgOiBTNSkgKEIgOiBTNSkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGVxIDpcbiAgICAgICAgJ2EgJ2IgJ2MgJ2QgJ2UuICgoJ2EsICdiLCAnYywgJ2QsICdlKSBBLnQsICgnYSwgJ2IsICdjLCAnZCwgJ2UpIEIudCkgVHlwZV9lcXVhbC50XG4gICAgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgaWYgVWlkLmVxdWFsIHVpZF9hIHVpZF9iIHRoZW4geyBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcbm1vZHVsZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50ZiA9IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmXG5cbm1vZHVsZSBIZWxwZXIgKEEgOiBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TKSAoQiA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpID0gc3RydWN0XG4gIHR5cGUgbWFwID0geyBtYXAgOiAnYS4gJ2EgQS50IC0+ICdhIEIudCB9XG5cbiAgbGV0IG1hcF92YXJpYW50ICh0eXBlIHZhcmlhbnQpIHsgbWFwIH0gKHZhcmlhbnQgOiB2YXJpYW50IEEuVmFyaWFudC50KSA9XG4gICAgbGV0IG1hcF9jcmVhdGUgPSBmdW5jdGlvblxuICAgICAgfCBBLlRhZy5BcmdzIGZjdCAtPiBCLlRhZ19pbnRlcm5hbC5BcmdzIGZjdFxuICAgICAgfCBBLlRhZy5Db25zdCBrIC0+IEIuVGFnX2ludGVybmFsLkNvbnN0IGtcbiAgICBpblxuICAgIGxldCBtYXBfdGFnIHRhZyA9XG4gICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVGFnIHRhZyAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLlRhZy5sYWJlbCB0YWcgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5UYWcudHJhdmVyc2UgdGFnKSBpblxuICAgICAgICBsZXQgYXJpdHkgPSBBLlRhZy5hcml0eSB0YWcgaW5cbiAgICAgICAgbGV0IGFyZ3NfbGFiZWxzID0gQS5UYWcuYXJnc19sYWJlbHMgdGFnIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuVGFnLmluZGV4IHRhZyBpblxuICAgICAgICBsZXQgb2NhbWxfcmVwciA9IEEuVGFnLm9jYW1sX3JlcHIgdGFnIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5UYWcudHlpZCB0YWcgaW5cbiAgICAgICAgbGV0IGNyZWF0ZSA9IG1hcF9jcmVhdGUgKEEuVGFnLmNyZWF0ZSB0YWcpIGluXG4gICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5UYWdcbiAgICAgICAgICAoQi5UYWcuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuVGFnX2ludGVybmFsLmxhYmVsXG4gICAgICAgICAgICAgOyByZXBcbiAgICAgICAgICAgICA7IGFyaXR5XG4gICAgICAgICAgICAgOyBhcmdzX2xhYmVsc1xuICAgICAgICAgICAgIDsgaW5kZXhcbiAgICAgICAgICAgICA7IG9jYW1sX3JlcHJcbiAgICAgICAgICAgICA7IHR5aWRcbiAgICAgICAgICAgICA7IGNyZWF0ZVxuICAgICAgICAgICAgIH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCB2YXJpYW50IGluXG4gICAgbGV0IHBvbHltb3JwaGljID0gQS5WYXJpYW50LmlzX3BvbHltb3JwaGljIHZhcmlhbnQgaW5cbiAgICBsZXQgdGFncyA9XG4gICAgICBBcnJheS5pbml0IChBLlZhcmlhbnQubGVuZ3RoIHZhcmlhbnQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX3RhZyAoQS5WYXJpYW50LnRhZyB2YXJpYW50IGluZGV4KSlcbiAgICBpblxuICAgIGxldCB2YWx1ZSAoYSA6IHZhcmlhbnQpID1cbiAgICAgIG1hdGNoIEEuVmFyaWFudC52YWx1ZSB2YXJpYW50IGEgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVmFsdWUgKGF0YWcsIGEpIC0+XG4gICAgICAgIChmdW4gKHR5cGUgYXJncykgKGF0YWcgOiAodmFyaWFudCwgYXJncykgQS5UYWcudCkgKGEgOiBhcmdzKSAtPlxuICAgICAgICAgICBsZXQgKEIuVmFyaWFudF9pbnRlcm5hbC5UYWcgYnRhZykgPSB0YWdzLihBLlRhZy5pbmRleCBhdGFnKSBpblxuICAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5UYWcudHlpZCBhdGFnKSAoQi5UYWcudHlpZCBidGFnKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYnRhZyA9IChidGFnIDogKHZhcmlhbnQsIGFyZ3MpIEIuVGFnLnQpIGluXG4gICAgICAgICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5WYWx1ZSAoYnRhZywgYSkpXG4gICAgICAgICAgICAgYnRhZylcbiAgICAgICAgICBhdGFnXG4gICAgICAgICAgYVxuICAgIGluXG4gICAgQi5WYXJpYW50LmludGVybmFsX3VzZV9vbmx5IHsgQi5WYXJpYW50X2ludGVybmFsLnR5cGVuYW1lOyB0YWdzOyBwb2x5bW9ycGhpYzsgdmFsdWUgfVxuICA7O1xuXG4gIGxldCBtYXBfcmVjb3JkICh0eXBlIHJlY29yZCkgeyBtYXAgfSAocmVjb3JkIDogcmVjb3JkIEEuUmVjb3JkLnQpID1cbiAgICBsZXQgbWFwX2ZpZWxkIGZpZWxkID1cbiAgICAgIG1hdGNoIGZpZWxkIHdpdGhcbiAgICAgIHwgQS5SZWNvcmQuRmllbGQgZmllbGQgLT5cbiAgICAgICAgbGV0IGxhYmVsID0gQS5GaWVsZC5sYWJlbCBmaWVsZCBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLkZpZWxkLnRyYXZlcnNlIGZpZWxkKSBpblxuICAgICAgICBsZXQgaW5kZXggPSBBLkZpZWxkLmluZGV4IGZpZWxkIGluXG4gICAgICAgIGxldCBpc19tdXRhYmxlID0gQS5GaWVsZC5pc19tdXRhYmxlIGZpZWxkIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5GaWVsZC50eWlkIGZpZWxkIGluXG4gICAgICAgIGxldCBnZXQgPSBBLkZpZWxkLmdldCBmaWVsZCBpblxuICAgICAgICBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZFxuICAgICAgICAgIChCLkZpZWxkLmludGVybmFsX3VzZV9vbmx5XG4gICAgICAgICAgICAgeyBCLkZpZWxkX2ludGVybmFsLmxhYmVsOyByZXA7IGluZGV4OyBpc19tdXRhYmxlOyB0eWlkOyBnZXQgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVjb3JkIGluXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnID0gQS5SZWNvcmQuaGFzX2RvdWJsZV9hcnJheV90YWcgcmVjb3JkIGluXG4gICAgbGV0IGZpZWxkcyA9XG4gICAgICBBcnJheS5pbml0IChBLlJlY29yZC5sZW5ndGggcmVjb3JkKSAoZnVuIGluZGV4IC0+XG4gICAgICAgIG1hcF9maWVsZCAoQS5SZWNvcmQuZmllbGQgcmVjb3JkIGluZGV4KSlcbiAgICBpblxuICAgIGxldCBjcmVhdGUgeyBCLlJlY29yZF9pbnRlcm5hbC5nZXQgfSA9XG4gICAgICBsZXQgZ2V0ICh0eXBlIGEpIChhZmllbGQgOiAoXywgYSkgQS5GaWVsZC50KSA9XG4gICAgICAgIG1hdGNoIGZpZWxkcy4oQS5GaWVsZC5pbmRleCBhZmllbGQpIHdpdGhcbiAgICAgICAgfCBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZCBiZmllbGQgLT5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYmZpZWxkIDogKHJlY29yZCwgZXgpIEIuRmllbGQudCkgLT5cbiAgICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG4gKEEuRmllbGQudHlpZCBhZmllbGQpIChCLkZpZWxkLnR5aWQgYmZpZWxkKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICAgZ2V0IGJmaWVsZClcbiAgICAgICAgICAgIGJmaWVsZFxuICAgICAgaW5cbiAgICAgIEEuUmVjb3JkLmNyZWF0ZSByZWNvcmQgeyBBLlJlY29yZC5nZXQgfVxuICAgIGluXG4gICAgQi5SZWNvcmQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgIHsgQi5SZWNvcmRfaW50ZXJuYWwudHlwZW5hbWU7IGZpZWxkczsgaGFzX2RvdWJsZV9hcnJheV90YWc7IGNyZWF0ZSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgTmFtZWQgPSBzaWdcbiAgdHlwZSAnYSBjb21wdXRhdGlvblxuXG4gIG1vZHVsZSBDb250ZXh0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBpbml0IDogQ29udGV4dC50IC0+ICdhIFR5cGVuYW1lLnQgLT4gJ2EgdFxuICB2YWwgZ2V0X3dpcF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNldF9maW5hbF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNoYXJlIDogXyBUeXBlcmVwLnQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXB1dGF0aW9uID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGludCA6IGludCB0XG4gIHZhbCBpbnQzMiA6IGludDMyIHRcbiAgdmFsIGludDY0IDogaW50NjQgdFxuICB2YWwgbmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgdmFsIGZsb2F0IDogZmxvYXQgdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgdmFsIGJ5dGVzIDogYnl0ZXMgdFxuICB2YWwgYm9vbCA6IGJvb2wgdFxuICB2YWwgdW5pdCA6IHVuaXQgdFxuICB2YWwgb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICB2YWwgbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBhcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICB2YWwgbGF6eV90IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICB2YWwgcmVmXyA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgdmFsIGZ1bmN0aW9uXyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgLT4gJ2IpIHRcbiAgdmFsIHR1cGxlMiA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgdHVwbGUzIDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gKCdhICogJ2IgKiAnYykgdFxuICB2YWwgdHVwbGU0IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgdmFsIHR1cGxlNSA6ICdhIHQgLT4gJ2IgdCAtPiAnYyB0IC0+ICdkIHQgLT4gJ2UgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuICB2YWwgcmVjb3JkIDogJ2EgUmVjb3JkLnQgLT4gJ2EgdFxuICB2YWwgdmFyaWFudCA6ICdhIFZhcmlhbnQudCAtPiAnYSB0XG5cbiAgbW9kdWxlIE5hbWVkIDogTmFtZWQgd2l0aCB0eXBlICdhIGNvbXB1dGF0aW9uIDo9ICdhIHRcbmVuZFxuXG4oKiBzcGVjaWFsIGZ1bmN0b3IgYXBwbGljYXRpb24gZm9yIGNvbXB1dGF0aW9uIGFzIGNsb3N1cmUgb2YgdGhlIGZvcm0gW2EgLT4gYl0gKilcbm1vZHVsZSBNYWtlX25hbWVkX2Zvcl9jbG9zdXJlIChYIDogc2lnXG4gICAgdHlwZSAnYSBpbnB1dFxuICAgIHR5cGUgJ2Egb3V0cHV0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaW5wdXQgLT4gJ2Egb3V0cHV0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoaW1wbGVtZW50cyB1aWQpXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICBuYW1lJ1xuICAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgcHJlcnJfZW5kbGluZSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG4gIGVuZCkgOiBTX2ltcGxlbWVudGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFgudFxuICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuXG4gIGluY2x1ZGUgVHlwZV9nZW5lcmljX2ludGYuTSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIDs7XG5cbiAgICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzID0gSWRlbnQuY2hlY2tfZGVwZW5kZW5jaWVzIFgubmFtZSBYLnJlcXVpcmVkXG5cbiAgICBsZXQgcmVwbGFjZSB0YWJsZSBrZXkgdmFsdWUgPVxuICAgICAgY2hlY2tfZGVwZW5kZW5jaWVzIGtleTtcbiAgICAgIHJlcGxhY2UgKExhenkuZm9yY2UgdGFibGUpIGtleSB2YWx1ZVxuICAgIDs7XG5cbiAgICBsZXQgbWVtIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgbWVtIHRhYmxlIGtleSlcbiAgICAgIGVsc2UgZmFsc2VcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2l6ZSA9IDI1NlxuICBsZXQgdGFibGUwID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUxID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUyID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUzID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU0ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU1ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuXG4gIGxldCBpc19yZWdpc3RlcmVkIHVpZCA9XG4gICAgVWlkX3RhYmxlLm1lbSB0YWJsZTAgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTEgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTIgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTMgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTQgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTUgdWlkXG4gIDs7XG5cbiAgbGV0IGlkZW50ID0geyBJZGVudC5uYW1lID0gWC5uYW1lOyBpbXBsZW1lbnRzID0gaXNfcmVnaXN0ZXJlZCB9XG5cbiAgbW9kdWxlIEZpbmQwIChUIDogVHlwZXJlcC5OYW1lZC5UMCkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gVC5uYW1lZCBjb21wdXRhdGlvbiBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUwIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMgPSAodmFsIHJlcCA6IFMpIGluXG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biBTLnR5cGVuYW1lX29mX3QgVC50eXBlbmFtZV9vZl9uYW1lZCBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgd2l0bmVzcykgUy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMSAoVCA6IFR5cGVyZXAuTmFtZWQuVDEpIDogc2lnXG4gICAgdmFsIGNvbXB1dGUgOiB1bml0IC0+IChULmEgY29tcHV0YXRpb24gLT4gVC5hIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTEgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzEgPSAodmFsIHJlcCA6IFMxKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMVxuICAgICAgICAgICAgKFMxKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFMxLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQyIChUIDogVHlwZXJlcC5OYW1lZC5UMikgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKSBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUyIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMyID0gKHZhbCByZXAgOiBTMikgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzJcbiAgICAgICAgICAgIChTMilcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSBULmEgY29tcHV0YXRpb24gLT4gVC5iIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzIuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDMgKFQgOiBUeXBlcmVwLk5hbWVkLlQzKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTMgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIHJlcCA6IFMzKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fM1xuICAgICAgICAgICAgKFMzKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiBULmMgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNCAoVCA6IFR5cGVyZXAuTmFtZWQuVDQpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU0IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCByZXAgOiBTNCkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzRcbiAgICAgICAgICAgIChTNClcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgPSAoJ2EsICdiLCAnYywgJ2QpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzQuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDUgKFQgOiBUeXBlcmVwLk5hbWVkLlQ1KSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU1IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM1ID0gKHZhbCByZXAgOiBTNSkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzVcbiAgICAgICAgICAgIChTNSlcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzUuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdW5pdCA9IFR5cGVuYW1lLnN0YXRpY1xuXG4gIGxldCByZWdpc3RlcjAgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gKHZhbCBjb21wdXRlIDogUykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIFMudHlwZW5hbWVfb2ZfdCBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjEgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgY29tcHV0ZSA6IFMxKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMxLnR5cGVuYW1lX29mX3QgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTEgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIyIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIGNvbXB1dGUgOiBTMikgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMi50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTIgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIzIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIGNvbXB1dGUgOiBTMykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMy50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMyB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjQgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgY29tcHV0ZSA6IFM0KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM0LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTQgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXI1IGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIGNvbXB1dGUgOiBTNSkgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTNS50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTUgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIgKHR5cGUgYSkgdHlwZXJlcF9vZl9hIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFR5cGVyZXAudHlwZW5hbWVfb2ZfdCB0eXBlcmVwX29mX2FcbiAgICAgIGxldCB0eXBlcmVwX29mX3QgPSB0eXBlcmVwX29mX2FcbiAgICAgIGxldCBjb21wdXRlID0gY29tcHV0ZVxuICAgIGVuZFxuICAgIGluXG4gICAgcmVnaXN0ZXIwIChtb2R1bGUgUyA6IFMpXG4gIDs7XG5cbiAgKCogSU1QTEVNRU5UQVRJT04gKilcblxuICB0eXBlIGltcGxlbWVudGF0aW9uID0geyBnZW5lcmljIDogJ2EuICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiB9XG5cbiAgbGV0IGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gKHR5cGUgYSkgYXV4ID0gZnVuY3Rpb25cbiAgICB8IFR5cGVyZXAuTmFtZWQuVDAgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMCAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDEgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9IChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgOiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQyIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQyIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDIgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIDogKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQzIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQzIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDMgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ0IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ0IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDQgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jLCBULmQpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDUgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDUgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kNSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b21cbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYSlcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYilcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZClcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZSlcbiAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE5vdF9pbXBsZW1lbnRlZCBvZiBzdHJpbmcgKiBzdHJpbmdcblxuICBsZXQgcmFpc2Vfbm90X2ltcGxlbWVudGVkIHN0cmluZyA9IHJhaXNlIChOb3RfaW1wbGVtZW50ZWQgKFgubmFtZSwgc3RyaW5nKSlcblxuICBsZXQgX3VzaW5nX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgY29udGVudCA9XG4gICAgbWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiBhdXggcmVwIHdpdGhcbiAgICB8IFNvbWUgY29tcHV0YXRpb24gLT4gY29tcHV0YXRpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIChtYXRjaCBjb250ZW50IHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgY29udGVudCkgLT4gYXV4LmdlbmVyaWMgY29udGVudFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IHJlcCBpblxuICAgICAgICAgbGV0IG5hbWUgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIHR5cGVuYW1lKSBpblxuICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWUpXG4gIDs7XG5lbmRcblxubW9kdWxlIF8gPSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLktleSlcblxubW9kdWxlIE1ha2UgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5cbiAgICBpbmNsdWRlIENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIENvbXB1dGF0aW9uID0gWFxuICBpbmNsdWRlIE1ha2VfU19pbXBsZW1lbnRhdGlvbiAoWClcblxuICBtb2R1bGUgTWVtbyA9IFR5cGVuYW1lLlRhYmxlIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFguTmFtZWQudFxuICAgIGVuZClcblxuICBtb2R1bGUgSGVscGVyID0gSGVscGVyIChUeXBlcmVwKSAoQ29tcHV0YXRpb24pXG5cbiAgbGV0IG9mX3R5cGVyZXAgcmVwID1cbiAgICBsZXQgY29udGV4dCA9IFguTmFtZWQuQ29udGV4dC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgbWVtb190YWJsZSA9IE1lbW8uY3JlYXRlIDMyIGluXG4gICAgbGV0IHJlYyBvZl90eXBlcmVwIDogdHlwZSBhLiBhIFR5cGVyZXAudCAtPiBhIHQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLkludCAtPiBYLmludFxuICAgICAgfCBUeXBlcmVwLkludDMyIC0+IFguaW50MzJcbiAgICAgIHwgVHlwZXJlcC5JbnQ2NCAtPiBYLmludDY0XG4gICAgICB8IFR5cGVyZXAuTmF0aXZlaW50IC0+IFgubmF0aXZlaW50XG4gICAgICB8IFR5cGVyZXAuQ2hhciAtPiBYLmNoYXJcbiAgICAgIHwgVHlwZXJlcC5GbG9hdCAtPiBYLmZsb2F0XG4gICAgICB8IFR5cGVyZXAuU3RyaW5nIC0+IFguc3RyaW5nXG4gICAgICB8IFR5cGVyZXAuQnl0ZXMgLT4gWC5ieXRlc1xuICAgICAgfCBUeXBlcmVwLkJvb2wgLT4gWC5ib29sXG4gICAgICB8IFR5cGVyZXAuVW5pdCAtPiBYLnVuaXRcbiAgICAgIHwgVHlwZXJlcC5PcHRpb24gcmVwIC0+IFgub3B0aW9uIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MaXN0IHJlcCAtPiBYLmxpc3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkFycmF5IHJlcCAtPiBYLmFycmF5IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MYXp5IHJlcCAtPiBYLmxhenlfdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuUmVmIHJlcCAtPiBYLnJlZl8gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZykgLT4gWC5mdW5jdGlvbl8gKG9mX3R5cGVyZXAgZG9tKSAob2ZfdHlwZXJlcCBybmcpXG4gICAgICB8IFR5cGVyZXAuVHVwbGUgdHVwbGUgLT5cbiAgICAgICAgKCogZG8gTk9UIHdyaXRlIFtYLnR1cGxlMiAob2ZfdHlwZXJlcCBhKSAob2ZfdHlwZXJlcCBiKV1cbiAgICAgICAgICAgYmVjYXVzZSBvZl90eXBlcmVwIGNhbiBjb250YWluIGEgc2lkZSBlZmZlY3QgYW5kIFthXSBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgYmVmb3JlIFtiXSAqKVxuICAgICAgICAobWF0Y2ggdHVwbGUgd2l0aFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIFgudHVwbGUyIHJhIHJiXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIFgudHVwbGUzIHJhIHJiIHJjXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBYLnR1cGxlNCByYSByYiByYyByZFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgbGV0IHJlID0gb2ZfdHlwZXJlcCBlIGluXG4gICAgICAgICAgIFgudHVwbGU1IHJhIHJiIHJjIHJkIHJlKVxuICAgICAgfCBUeXBlcmVwLlJlY29yZCByZWNvcmQgLT5cbiAgICAgICAgWC5yZWNvcmQgKEhlbHBlci5tYXBfcmVjb3JkIHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSByZWNvcmQpXG4gICAgICB8IFR5cGVyZXAuVmFyaWFudCB2YXJpYW50IC0+XG4gICAgICAgIFgudmFyaWFudCAoSGVscGVyLm1hcF92YXJpYW50IHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSB2YXJpYW50KVxuICAgICAgfCBUeXBlcmVwLk5hbWVkIChuYW1lZCwgY29udGVudCkgLT5cbiAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IG5hbWVkIGluXG4gICAgICAgIChtYXRjaCBNZW1vLmZpbmQgbWVtb190YWJsZSB0eXBlbmFtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgc2hhcmVkIC0+IFguTmFtZWQuZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWRcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiB7IGdlbmVyaWMgPSBvZl90eXBlcmVwIH0gbmFtZWQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGNvbXB1dGF0aW9uIC0+IGNvbXB1dGF0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCB0eXBlbmFtZSkgaW5cbiAgICAgICAgICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPlxuICAgICAgICAgICAgICAgICBpZiBYLk5hbWVkLnNoYXJlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IHNoYXJlZCA9IFguTmFtZWQuaW5pdCBjb250ZXh0IHR5cGVuYW1lIGluXG4gICAgICAgICAgICAgICAgICAgTWVtby5zZXQgbWVtb190YWJsZSB0eXBlbmFtZSBzaGFyZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCBjb250ZW50IGluXG4gICAgICAgICAgICAgICAgICAgWC5OYW1lZC5zZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICAgICAgICBlbHNlIG9mX3R5cGVyZXAgY29udGVudCkpKVxuICAgIGluXG4gICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCByZXAgaW5cbiAgICBgZ2VuZXJpYyBjb21wdXRhdGlvblxuICA7O1xuZW5kXG4iLCIoKipcbiAgIFBsYWNlIGhvbGRlciBmb3IgY29tbW9uIFZhcmlhbnRzIGFuZCBGaWVsZHMgaW50ZXJmYWNlXG4qKVxuXG5tb2R1bGUgTSAoWCA6IHNpZ1xuICAgICgqKlxuICAgICAgIFRoaXMgZnVuY3RvciBpcyBlc3NlbnRpYWxseSB0aGVyZSBiZWNhdXNlIHdlIHVzZSB0aGlzIHNhbWUgaW50ZXJmYWNlIGluIGRpZmZlcmVudFxuICAgICAgIGNvbnRleHRzLCB3aXRoIGRpZmZlcmVudCB0eXBlcyBmb3IgWydhIHRdLlxuXG4gICAgICAgMSkgT25lIHVzZSBjYXNlIGZvciBpdCBpcyB3aGVyZSBbJ2EgWC50ID0gJ2EgVHlwZXJlcC50XS4gIFRoZXNlIGludGVyZmFjZXMgYXJlIHRoZW5cbiAgICAgICBwYXJ0IG9mIHRoZSB0eXBlIHdpdG5lc3MgYnVpbHQgZm9yIGEgdHlwZSBjb250YWluaW5nIGEgcmVjb3JkIG9yIGEgdmFyaWFudCBpbiBpdHNcbiAgICAgICBzdHJ1Y3R1cmUuIFt0cmF2ZXJzZV0gd2lsbCBnaXZlIGEgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlXG4gICAgICAgYXJndW1lbnRzIG9mIGEgdmFyaWFudCBvciByZWNvcmQgdHlwZS5cblxuICAgICAgIDIpIEFub3RoZXIgdXNlIGNhc2UgaXMgZm9yIGJ1aWxkaW5nIFwic3RhZ2VkIGdlbmVyaWMgY29tcHV0YXRpb25zXCIuIEluIHRoYXQgY2FzZSwgdGhlXG4gICAgICAgdHlwZSBbJ2EgWC50XSBpcyB0aGUgdHlwZSBvZiB0aGUgY29tcHV0YXRpb24gdGhhdCBpcyBiZWluZyBidWlsdC4gIFt0cmF2ZXJzZV1cbiAgICAgICByZXR1cm5zIHRoZSBjb21wdXRhdGlvbiBidWlsdCBmb3IgdGhlIGFyZ3VtZW50LiBUaGUgaW50ZXJmYWNlIG5vIGxvbmdlciBleHBvcnRzXG4gICAgICAgdGhlIHR5cGVyZXAgb2YgdGhlIGFyZ3VtZW50cyBpbiBob3BlcyBvZiBlbmZvcmNpbmcgdGhhdCBubyB0eXBlcmVwIHRyYXZlcnNhbFxuICAgICAgIGhhcHBlbnMgYXQgcnVudGltZSBpZiB0aGUgY29tcHV0YXRpb24gaGFwcGVuIHRvIGJlIGEgZnVuY3Rpb24uXG4gICAgKilcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgKCogVGhlIGZ1bmN0aW9ucyBwcmVmaXhlZCBieSBbaW50ZXJuYWxdIGFzIHdlbGwgYXMgdGhlIG1vZHVsZSBzdWZmaXhlZCBieSBbX2ludGVybmFsXVxuICAgICBhcmUgdXNlZCBieSB0aGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gW3dpdGggdHlwZXJlcF0gYXMgd2VsbCBhcyBzb21lXG4gICAgIGludGVybmFscyBvZiB0aGUgdHlwZXJlcCBsaWJyYXJ5LiBEbyBub3QgY29uc2lkZXIgdXNpbmcgdGhlc2Ugc29tZXdoZXJlIGVsc2UuICBUaGV5XG4gICAgIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBleHBvcnRlZCBvdXRzaWRlIHRoZSB0eXBlcmVwIGxpYnJhcnksIGJ1dCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgbmVlZHMgc29tZWhvdyB0byBhY2Nlc3MgdGhpcywgZXZlbiBvdXRzaWRlLiAqKVxuXG4gIG1vZHVsZSBUYWdfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0ID1cbiAgICAgIHsgbGFiZWwgOiBzdHJpbmdcbiAgICAgIDsgcmVwIDogJ2FyZ3MgWC50XG4gICAgICA7IGFyaXR5IDogaW50XG4gICAgICA7IGFyZ3NfbGFiZWxzIDogc3RyaW5nIGxpc3RcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgb2NhbWxfcmVwciA6IGludFxuICAgICAgOyB0eWlkIDogJ2FyZ3MgVHlwZW5hbWUudFxuICAgICAgOyBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGVcbiAgICAgIH1cbiAgZW5kXG5cbiAgKCoqXG4gICAgIFdpdG5lc3Mgb2YgYSB0YWcsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHZhcmlhbnQgdHlwZSwgYWxzbyBjYWxsZWQgYW4gXCJhcHBsaWVkXG4gICAgIHZhcmlhbnQgQ29uc3RydWN0b3JcIlxuXG4gICAgIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgdGFnXG4gICAgIHBhcmFtZXRlcnMuICBFeGFtcGxlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID1cbiAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgfCBCIG9mIHN0cmluZ1xuICAgICAgICAgfCBDIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG5cbiAgICAgdGhpcyB0eXBlIGhhcyB0aHJlZSBjb25zdHJ1Y3RvcnMuIEZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmdcbiAgICAgW1RhZy50XTpcblxuICAgICB7W1xuICAgICAgIHZhbCB0YWdfQSA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgICB2YWwgdGFnX0IgOiAodCwgc3RyaW5nICAgICAgICApIFRhZy50XG4gICAgICAgdmFsIHRhZ19DIDogKHQsIChpbnQgKiBzdHJpbmcpKSBUYWcudFxuICAgICBdfVxuXG4gICAgIE5vdGUsIGlubGluZSByZWNvcmQgaW4gdmFyaWFudCBhcmUgdHlwZWQgYXMgaWYgdGhlaXIgZGVmaW5pdGlvbiB3YXMgdXNpbmcgdHVwbGVzLFxuICAgICB3aXRob3V0IHRoZSBwYXJlbnRoZXNpcy4gIFRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZWlyIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24uICBCdXRcbiAgICAgdGhlIGRpc3RpbmN0aW9uIGlzIGNhcnJpZWQgYW5kIGF2YWlsYWJsZSBmb3IgaW50cm9zcGVjdGlvbiBhcyBwYXJ0IG9mIHRoZSBbVGFnLnRdLlxuICAgICBTZWUgW2FyZ3NfbGFiZWxzXS4gKilcbiAgbW9kdWxlIFRhZyA6IHNpZ1xuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgY3JlYXRlID1cbiAgICAgIHwgQXJncyBvZiAoJ2FyZ3MgLT4gJ3ZhcmlhbnQpXG4gICAgICB8IENvbnN0IG9mICd2YXJpYW50XG5cbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIHRcblxuICAgICgqKlxuICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBhcyBpdCBpcyBnaXZlbiBpbiB0aGUgY29uY3JldGUgc3ludGF4XG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7dlxuICAgICAgICAgQ29uc3RydWN0b3IgICAgICAgIHwgbGFiZWxcbiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIHwgQSBvZiBpbnQgICAgICAgICB8ICBcIkFcIlxuICAgICAgICAgfCBgYSBvZiBpbnQgICAgICAgIHwgIFwiYVwiXG4gICAgICAgICB8IGBBIG9mIGludCAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSB8ICBcIkFcIlxuICAgICAgIHZ9XG5cbiAgICAgICBmb3Igc3RhbmRhcmQgdmFyaWFudCwgdGhlIG9jYW1sIHN5bnRheCBpbXBsaWVzIHRoYXQgdGhpcyBsYWJlbCB3aWxsIGFsd2F5cyBzdGFydHNcbiAgICAgICB3aXRoIGEgY2FwaXRhbCBsZXR0ZXIuIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50cywgdGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSBjaGFyLlxuICAgICAgIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50LCB0aGlzIGxhYmVsIGRvZXMgbm90IGluY2x1ZGUgdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSBzaXplIG9mIHRoZSBvY2FtbCBoZWFwIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50c1xuXG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge3ZcbiAgICAgICAgICAwOiB8IEEgfCAnQVxuICAgICAgICAgIDE6IHwgQSBvZiBpbnQgfCBgQSBvZiBpbnQgfCBBIG9mIChpbnQgKiBpbnQpIHwgYEEgb2YgKGludCAqIGludClcbiAgICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnR9XG4gICAgICAgICAgMjogfCBBIG9mIGludCAqIGZsb2F0XG4gICAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgICAgZXRjLlxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJpdHkgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKiBUaGUgbGFiZWwgb2YgdGhlIGZpZWxkcyBmb3IgaW5saW5lIHJlY29yZHMuICBGb3Igb3RoZXIgZm9ybXMgb2YgdGFncywgdGhpcyBpcyB0aGVcbiAgICAgICAgZW1wdHkgbGlzdC4gIFdoZW4gdGhpcyByZXR1cm5zIGEgbm9uIGVtcHR5IGxpc3QsIHRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGxpc3RcbiAgICAgICAgaXMgZXF1YWwgdG8gdGhlIGFyaXR5LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAge3ZcbiAgICAgICAgICgxKSBFbXB0eTpcblxuICAgICAgICAgICB8IEEgfCAnQVxuICAgICAgICAgICB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgIHwgYEEgb2YgaW50ICogaW50XG4gICAgICAgICAgIHwgQSBvZiBpbnQgKiBmbG9hdFxuXG4gICAgICAgICAoMikgTm9uIGVtcHR5OlxuXG4gICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSAgICAgICAgICAgICAgIC0+IFsgXCJ4XCIgXVxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH0gICAtPiBbIFwieFwiIDsgXCJ5XCIgXVxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJnc19sYWJlbHMgOiAoXywgXykgdCAtPiBzdHJpbmcgbGlzdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb25zdHJ1Y3RvciBpbiB0aGUgbGlzdCBvZiBhbGwgdGhlIHZhcmlhbnQgdHlwZSdzIGNvbnN0cnVjdG9yc1xuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgQyBvZiBpbnQgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEQgb2YgY2hhciAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBFIG9mIHsgeCA6IGludCB9ICAoKiA0ICopXG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgb2NhbWxfcmVwciBpcyByZWxhdGVkIHRvIHRoZSBydW50aW1lIG9mIG9iamVjdHMuIHRoaXMgaXMgZXNzZW50aWFsbHkgYSB3YXkgb2ZcbiAgICAgICBnaXZpbmcgb25lIHRoZSBhYmlsaXR5IHRvIHJlYnVpbGQgZHluYW1pY2FsbHkgYW4gW09iai50XSByZXByZXNlbnRpbmcgYSB0YWcuXG5cbiAgICAgICBQb2x5bW9ycGhpYyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgaGFzaCBvZiB0aGUgbGFiZWwsIGFzIGRvbmUgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgYGJhcikgICgqIDQ4OTUxODcgKilcbiAgICAgICBwcmludF9pbnQgKE9iai5tYWdpYyAnZm9vKSAgKCogNTA5NzIyMiAqKVxuXG4gICAgICAgU3RhbmRhcmRzIHZhcmlhbnRzOlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgdGFnIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZS5cbiAgICAgICB0aGUgd2F5IGl0IHdvcmtzIGluIHRoZSBvY2FtbCBydW50aW1lIGlzIGJ5IHBhcnRpdGlvbmluZyB0aGUgY29uc3RydWN0b3JzIHJlZ2FyZGluZ1xuICAgICAgIGlmIHRoZXkgaGF2ZSBzb21lIGFyZ3VtZW50cyBvciBub3QsIHByZXNlcnZpbmcgdGhlIG9yZGVyLCB0aGVuIGFzc2lnbiBpbmNyZWFzaW5nXG4gICAgICAgaW5kZXggd2l0aGluZyBlYWNoIHBhcnRpdGlvbi5cbiAgICAgICBFeGFtcGxlOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9ICAgICAgICAgICAgICAgICAgKCogbm8gYXJnICopICAoKiBhcmdzICopXG4gICAgICAgICAgIHwgQSAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEIgb2YgaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEMgICAgICAgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBEIG9mIChmbG9hdCAqIHN0cmluZykgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBFICAgICAgICAgICAgICAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgRiAgICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgICAgICB8IEcgb2Ygc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEggb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgb2NhbWxfcmVwciA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2l2ZSBiYWNrIGEgd2F5IG9mIGNvbnN0cnVjdGluZyBhIHZhbHVlIG9mIHRoYXQgY29uc3RydWN0b3IgZnJvbSBpdHMgYXJndW1lbnRzLlxuXG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIChpbnQgKiBzdHJpbmcpXG4gICAgICAgICAgIHwgQiBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICB8IENcbiAgICAgICAgICAgfCBEIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgXX1cblxuICAgICAgIFtjcmVhdGVdIHdpbGwgcmV0dXJuIHNvbWV0aGluZyBlcXVpdmFsZW50IHRvOlxuICAgICAgIHRhZ19BIDogW0FyZ3MgKGZ1biAoZCA6IChpbnQgKiBzdHJpbmcpIC0+IEEgZCldXG4gICAgICAgdGFnX0IgOiBbQXJncyAoZnVuIChpLCBmKSAtPiBCIChpLCBmKSldXG4gICAgICAgdGFnX0MgOiBbQ29uc3QgQ11cbiAgICAgICB0YWdfRCA6IFtBcmdzIChmdW4gKHgsIHkpIC0+IEQgeyB4OyB5IH0pXVxuICAgICopXG4gICAgdmFsIGNyZWF0ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIHQgLT4gKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gbWlnaHQgYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgbG9va3VwIGJhc2VkXG4gICAgICAgIG9uIGl0IHdoaWxlIGJ1aWxkaW5nIGEgY29tcHV0YXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnYXJncykgdCAtPiAnYXJncyBUeXBlbmFtZS50XG5cbiAgICAoKiogZ2V0IHRoZSByZXByZXNlbnRhdGlvbi9jb21wdXRhdGlvbiBvZiB0aGUgYXJndW1lbnRzICopXG4gICAgdmFsIHRyYXZlcnNlIDogKF8sICdhcmdzKSB0IC0+ICdhcmdzIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgVGFnX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRhZ19pbnRlcm5hbFxuXG4gICAgbGV0IGxhYmVsIHQgPSB0LmxhYmVsXG4gICAgbGV0IGFyaXR5IHQgPSB0LmFyaXR5XG4gICAgbGV0IGFyZ3NfbGFiZWxzIHQgPSB0LmFyZ3NfbGFiZWxzXG4gICAgbGV0IGluZGV4IHQgPSB0LmluZGV4XG4gICAgbGV0IG9jYW1sX3JlcHIgdCA9IHQub2NhbWxfcmVwclxuICAgIGxldCBjcmVhdGUgdCA9IHQuY3JlYXRlXG4gICAgbGV0IHR5aWQgdCA9IHQudHlpZFxuICAgIGxldCB0cmF2ZXJzZSB0ID0gdC5yZXBcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhKSBUYWcudCAqICdhIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgdGFncyA6ICdhIHRhZyBhcnJheVxuICAgICAgOyBwb2x5bW9ycGhpYyA6IGJvb2xcbiAgICAgIDsgdmFsdWUgOiAnYSAtPiAnYSB2YWx1ZVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgVmFyaWFudCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSB0YWdzIGNvbnN0aXR1aW5nIGEgdmFyaWFudFxuICAgICAgIHR5cGUuIHRoZSBbJ3ZhcmlhbnRdIHBhcmFtZXRlciBpcyB0aGUgdmFyaWFudCB0eXBlLCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHRoZVxuICAgICAgIGNvbnN0cnVjdG9ycyBvZiB0aGF0IHZhcmlhbnQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgbWlnaHQgYmUgZGlmZmVyZW50XG4gICAgICAgZm9yIGVhY2ggY29uc3RydWN0b3IgYW5kIGlzIHRodXMgZXhpc3RlbnRpYWxcbiAgICAqKVxuICAgIHR5cGUgXyB0YWcgPSBUYWcgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAtPiAndmFyaWFudCB0YWdcblxuICAgICgqKlxuICAgICAgIEEgc2ltaWxhciBleGlzdGVudGlhbCBjb25zdHJ1Y3RvciB0byBbXyB0YWddIGJ1dCB0aGlzIG9uZSBob2xkcyBhIHZhbHVlIHdob3NlIHR5cGVcbiAgICAgICBpcyB0aGUgYXJndW1lbnRzIG9mIHRoZSB0YWcgY29uc3RydWN0b3IuICBBIHZhbHVlIG9mIHR5cGUgWydhIHZhbHVlXSBpcyBhIHBhaXIgb2ZcbiAgICAgICAoMSkgYSB2YWx1ZSBvZiB2YXJpYW50IHR5cGUgWydhXSBhbG9uZyB3aXRoICgyKSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZSBbJ2FdXG4gICAgKilcbiAgICB0eXBlIF8gdmFsdWUgPSBWYWx1ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIFRhZy50ICogJ2FyZ3MgLT4gJ3ZhcmlhbnQgdmFsdWVcblxuICAgICgqKlxuICAgICAgIFdpdG5lc3Mgb2YgYSB2YXJpYW50IHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHZhcmlhbnQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFncyBvZiB0aGlzIHZhcmlhbnQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCB0YWcgb2YgdGhpcyB2YXJpYW50IHR5cGUsIGluZGV4ZWQgZnJvbSAwLlxuICAgICopXG4gICAgdmFsIHRhZyA6ICdhIHQgLT4gaW50IC0+ICdhIHRhZ1xuXG4gICAgKCoqXG4gICAgICAgRGlzdGluZ3Vpc2ggcG9seW1vcnBoaWMgdmFyaWFudHMgYW5kIHN0YW5kYXJkIHZhcmlhbnRzLiBUeXBpY2FsbHksIHBvbHltb3JwaGljXG4gICAgICAgdmFyaWFudHMgdGFncyBzdGFydHMgd2l0aCB0aGUgW2BdIGNoYXJhY3Rlci5cbiAgICAgICBFeGFtcGxlXG4gICAgICAgcG9seW1vcnBoaWMgdmFyaWFudDogdHlwZSB0ID0gWyBgQSB8IGBCIF1cbiAgICAgICBzdGFuZGFyZCB2YXJpYW50OiAgICB0eXBlIHQgPSBBIHwgQlxuICAgICopXG4gICAgdmFsIGlzX3BvbHltb3JwaGljIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gYSB2YWx1ZSBvZiB0aGlzIHZhcmlhbnQgdHlwZS5cbiAgICAqKVxuICAgIHZhbCB2YWx1ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdmFsdWVcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIHRhZyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAnYSBWYXJpYW50X2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFZhcmlhbnRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQudGFnc1xuICAgIGxldCB0YWcgdCBpbmRleCA9IHQudGFncy4oaW5kZXgpXG4gICAgbGV0IGlzX3BvbHltb3JwaGljIHQgPSB0LnBvbHltb3JwaGljXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEFycmF5LmZvbGRfbGVmdCBmIGluaXQgdC50YWdzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBGaWVsZF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdmaWVsZCBYLnRcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdmaWVsZCBUeXBlbmFtZS50XG4gICAgICA7IGdldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgICA7ICgqIHNldCA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb247IChcXCogbXV0YWJsZSBmaWVsZCAqXFwpICopXG4gICAgICAgIGlzX211dGFibGUgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgZmllbGQsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHJlY29yZCB0eXBlLlxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgZmllbGQuXG4gICAgIEV4YW1wbGU6XG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50IDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG4gICAgIFRoaXMgdHlwZSBoYXMgdHdvIGZpZWxkcy4gZm9yIGVhY2ggb2YgdGhlbSB3ZSdsbCBoYXZlIGEgY29ycmVzcG9uZGluZyBbRmllbGQudF1cblxuICAgICB2YWwgZmllbGRfeCA6ICh0LCBpbnQpIEZpZWxkLnRcbiAgICAgdmFsIGZpZWxkX3kgOiAodCwgc3RyaW5nKSBGaWVsZC50XG4gICopXG4gIG1vZHVsZSBGaWVsZCA6IHNpZ1xuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdFxuXG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgZmllbGQgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB7IHggICA6IGludDsgICAgICgqIFwieFwiICopXG4gICAgICAgICAgIGZvbyA6IHN0cmluZzsgICgqIFwiZm9vXCIgKilcbiAgICAgICAgICAgYmFyIDogZmxvYXQ7ICAgKCogXCJiYXJcIiAqKVxuICAgICAgICAgfVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBmaWVsZCBpbiB0aGUgbGlzdCBvZiBhbGwgZmllbGRzIGZvciB0aGlzIHJlY29yZCB0eXBlLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgICAgeCAgIDogaW50OyAgICAgKCogMCAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiAxICopXG4gICAgICAgICAgIGJhciA6IHN0cmluZzsgICgqIDIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGluZGV4IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBGaWVsZCBhY2Nlc3NvcnMuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGRvdCBvcGVyYXRpb24uXG4gICAgICAgW0ZpZWxkLmdldCBiYXJfZmllbGQgdF0gcmV0dXJucyB0aGUgZmllbGQgW2Jhcl0gb2YgdGhlIHJlY29yZCB2YWx1ZSBbdF0sIGp1c3QgdGhlXG4gICAgICAgc2FtZSBhcyBbdC5iYXJdXG4gICAgKilcbiAgICB2YWwgZ2V0IDogKCdyZWNvcmQsICdmaWVsZCkgdCAtPiAncmVjb3JkIC0+ICdmaWVsZFxuXG4gICAgKCoqIHJldHVybiB3aGV0aGVyIHRoZSBmaWVsZCBpcyBtdXRhYmxlLCBpLmUuIHdoZXRoZXIgaXRzIGRlY2xhcmF0aW9uIGlzIHByZWZpeGVkIHdpdGhcbiAgICAgICAgdGhlIGtleXdvcmQgW211dGFibGVdICopXG4gICAgdmFsIGlzX211dGFibGUgOiAoXywgXykgdCAtPiBib29sXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gIE1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCAqKVxuICAgIHZhbCB0eWlkIDogKF8sICdmaWVsZCkgdCAtPiAnZmllbGQgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgRmllbGRfaW50ZXJuYWwudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRmllbGRfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBnZXQgdCA9IHQuZ2V0XG4gICAgbGV0IGlzX211dGFibGUgdCA9IHQuaXNfbXV0YWJsZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBSZWNvcmRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gZmllbGQgPSBGaWVsZCA6ICgncmVjb3JkLCAnYSkgRmllbGQudCAtPiAncmVjb3JkIGZpZWxkXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgZmllbGRzIDogJ2EgZmllbGQgYXJyYXlcbiAgICAgIDsgaGFzX2RvdWJsZV9hcnJheV90YWcgOiBib29sXG4gICAgICA7IGNyZWF0ZSA6ICdhIGZpZWxkcyAtPiAnYVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkIDogc2lnXG4gICAgKCoqXG4gICAgICAgQW4gZXhpc3RlbnRpYWwgdHlwZSB1c2VkIHRvIGdhdGhlciBhbGwgdGhlIGZpZWxkcyBjb25zdGl0dWluZyBhIHJlY29yZCB0eXBlLiB0aGVcbiAgICAgICBbJ3JlY29yZF0gcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGUgZmllbGQgb2YgdGhhdFxuICAgICAgIHJlY29yZCB0eXBlLiBUaGUgdHlwZSBvZiB0aGUgZmllbGRzIG1pZ2h0IGJlIGRpZmZlcmVudCBmb3IgZWFjaCBmaWVsZCBhbmQgaXMgdGh1c1xuICAgICAgIGV4aXN0ZW50aWFsLlxuICAgICopXG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgWydyZWNvcmQgZmllbGRzXSBpcyBhIHR5cGUgaXNvbW9ycGhpYyB0byBbJ3JlY29yZF0uICBUaGlzIGdpdmVzIGEgd2F5IHRvIGdldCB0aGVcbiAgICAgICBmaWVsZCB2YWx1ZSBmb3IgZWFjaCBmaWVsZCBvZiB0aGUgcmVjb3JkLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIHJlcHJlc2VudGF0aW9uIGlzXG4gICAgICAgdGhhdCBpdCBpcyBjb252ZW5pZW50IGZvciB3cml0aW5nIGdlbmVyaWMgY29tcHV0YXRpb25zLlxuICAgICopXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgcmVjb3JkIHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHJlY29yZCB0eXBlIHdpdG5lc3NlZC5cbiAgICAqKVxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcblxuICAgICgqKlxuICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBmaWVsZHMgb2YgdGhpcyByZWNvcmQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCBmaWVsZCBvZiB0aGlzIHJlY29yZCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCBmaWVsZCA6ICdhIHQgLT4gaW50IC0+ICdhIGZpZWxkXG5cbiAgICAoKipcbiAgICAgICBUaGlzIGlzIGEgbG93IGxldmVsIG1ldGFkYXRhIHJlZ2FyZGluZyB0aGUgd2F5IHRoZSBvY2FtbCBjb21waWxlciByZXByZXNlbnQgdGhlXG4gICAgICAgYXJyYXkgdW5kZXJuZWF0aCB0aGF0IGlzIHRoZSBydW50aW1lIHZhbHVlIG9mIGEgcmVjb3JkIG9mIHR5cGUgWydhXSBnaXZlbiBhIHdpdG5lc3NcbiAgICAgICBvZiB0eXBlIFsnYSB0XS4gW2hhc19kb3VibGVfYXJyYXlfdGFnIHddIHJldHVybnMgW3RydWVdIGlmIHRoZSBhcnJheSB0aGF0XG4gICAgICAgcmVwcmVzZW50cyBydW50aW1lIHZhbHVlcyBvZiB0aGlzIHR5cGUgaXMgYW4gb3B0aW1pemVkIG9jYW1sIGZsb2F0IGFycmF5LlxuICAgICAgIFR5cGljYWxseSwgdGhpcyB3aWxsIGJlIHRydWUgZm9yIHJlY29yZCB3aGVyZSBhbGwgZmllbGRzIGFyZSBzdGF0aWNhbGx5IGtub3duIGFzIHRvXG4gICAgICAgYmUgW2Zsb2F0c10uXG5cbiAgICAgICBOb3RlIHRoYXQgeW91IGNhbid0IGdldCB0aGlzIGluZm9ybWF0aW9uIGR5bmFtaWNhbGx5IGJ5IGluc3BlY3RpbmcgdGhlIHR5cGVyZXAgb25jZVxuICAgICAgIGl0IGlzIGFwcGxpZWQsIGJlY2F1c2UgdGhlcmUgaXMgYXQgdGhpcyBwb2ludCBubyB3YXkgdG8gdGVsbCB3aGV0aGVyIG9uZSBvZiB0aGVcbiAgICAgICBmaWVsZCBpcyBwb2x5bW9ycGhpYyBpbiB0aGUgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGhhc19kb3VibGVfYXJyYXlfdGFnIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIEV4cG9zZSBvbmUgZGlyZWN0aW9uIG9mIHRoZSBpc29tb3JwaGlzbSBiZXR3ZWVuIGEgdmFsdWUgb2YgdHlwZSBbJ2FdIGFuZCBhIHZhbHVlIG9mXG4gICAgICAgdHlwZSBbJ2EgZmllbGRzXS4gQmFzaWNhbGx5LCBnaXZlbiBhbiBlbmNvZGluZyB3YXkgb2YgYWNjZXNzaW5nIHRoZSB2YWx1ZSBvZiBhbGxcbiAgICAgICB0aGUgZmllbGRzIG9mIGEgcmVjb3JkLCBjcmVhdGUgdGhhdCByZWNvcmQgYW5kIHJldHVybiBpdC5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAnYSB0IC0+ICdhIGZpZWxkcyAtPiAnYVxuXG4gICAgKCoqXG4gICAgICAgZm9sZGluZyBhbG9uZyB0aGUgdGFncyBvZiB0aGUgdmFyaWFudCB0eXBlXG4gICAgKilcbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgZmllbGQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgUmVjb3JkX2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlY29yZF9pbnRlcm5hbFxuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgdCA9IHQudHlwZW5hbWVcbiAgICBsZXQgbGVuZ3RoIHQgPSBBcnJheS5sZW5ndGggdC5maWVsZHNcbiAgICBsZXQgZmllbGQgdCBpbmRleCA9IHQuZmllbGRzLihpbmRleClcbiAgICBsZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgdCA9IHQuaGFzX2RvdWJsZV9hcnJheV90YWdcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQuZmllbGRzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVwXG4gICAgZW5kKVxuZW5kXG4iLCIoKiB1c2luZyB0aGUgaGFzaF92YXJpYW50IG9mIHBhX3R5cGVfY29udiBhdCBjb21waWxlIHRpbWUgKilcbmxldCByZXByX29mX3BvbHlfdmFyaWFudCA6IFs+IF0gLT4gaW50ID1cbiAgZnVuIHZhcmlhbnQgLT5cbiAgbGV0IG9iaiA9IE9iai5yZXByIHZhcmlhbnQgaW5cbiAgaWYgT2JqLmlzX2ludCBvYmpcbiAgdGhlbiBPYmoub2JqIG9ialxuICBlbHNlIChcbiAgICBsZXQgc2l6ZSA9IE9iai5zaXplIG9iaiBpblxuICAgIGFzc2VydCAoc2l6ZSA9IDIpO1xuICAgIGxldCByZXByID0gT2JqLmZpZWxkIG9iaiAwIGluXG4gICAgYXNzZXJ0IChPYmouaXNfaW50IHJlcHIpO1xuICAgIE9iai5vYmogcmVwcilcbjs7XG5cbmxldCBoYXNoX3ZhcmlhbnQgcyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9ICgyMjMgKiAhYWNjdSkgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgoMSBsc2wgMzEpIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3Vcbjs7XG5cbigqIGEgZmV3IHVuaXQgdGVzdHMgb2YgY2FzZXMgdGhhdCBoYXZlIHRyaWdnZXJlZCBkaWZmcyBpbiB0aGUgcGFzdCBvZiB0aGlzXG4gICBsaWIgKilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYExhdGVuY3lfc3RhdHMgPSBoYXNoX3ZhcmlhbnQgXCJMYXRlbmN5X3N0YXRzXCIpXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGB6ZXJvID0gaGFzaF92YXJpYW50IFwiemVyb1wiKVxubGV0IGRvdWJsZV9hcnJheV92YWx1ZSA9IE9iai5tYWdpYyAwLlxubGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIGEgPSBPYmouZG91YmxlX2FycmF5X3RhZyA9IE9iai50YWcgKE9iai5yZXByIGEpXG5cbmxldCAoKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgZG91YmxlID1cbiAgICAgIHsgYSA6IGZsb2F0XG4gICAgICA7IGIgOiBmbG9hdFxuICAgICAgfVxuXG4gICAgdHlwZSBzaW1wbGUgPVxuICAgICAgeyBjIDogZmxvYXRcbiAgICAgIDsgZCA6IGludFxuICAgICAgfVxuXG4gICAgbGV0IGRvdWJsZSA9IHsgYSA9IGRvdWJsZV9hcnJheV92YWx1ZTsgYiA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gICAgbGV0IHNpbXBsZSA9IHsgYyA9IGRvdWJsZV9hcnJheV92YWx1ZTsgZCA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gIGVuZFxuICBpblxuICBhc3NlcnQgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uZG91YmxlKTtcbiAgYXNzZXJ0IChub3QgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uc2ltcGxlKSlcbjs7XG4iLCJtb2R1bGUgTSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIGNvbXB1dGUgOiB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gKCdhLCAnYikgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAoJ2EsICdiLCAnYykgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAnZCBYLnQgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgWC50XG4gICAgICAtPiAnYiBYLnRcbiAgICAgIC0+ICdjIFgudFxuICAgICAgLT4gJ2QgWC50XG4gICAgICAtPiAnZSBYLnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgWC50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgOiBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgOiBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpIDogVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgWC50ID1cbnN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTIgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgOlxuICBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTMgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2U0IChYIDogTmFtZWRfaW50Zi5TNCkgOlxuICBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0ID1cbiAgICBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0LCBOb25lKVxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgOlxuICBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgb2ZfcDUgPVxuICAgIFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgb2ZfcDUsIE5vbmUpXG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuIl19
