// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$48=caml_string_of_jsbytes(""),
     cst$46=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes(""),
     cst$42=caml_string_of_jsbytes(":"),
     cst$43=caml_string_of_jsbytes(""),
     cst$44=caml_string_of_jsbytes(":"),
     cst$45=caml_string_of_jsbytes("::"),
     cst_too_many_parts_in_IPv6_add=
      caml_string_of_jsbytes("too many parts in IPv6 address"),
     cst$40=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes("."),
     cst$39=caml_string_of_jsbytes("."),
     cst_invalid_octect=caml_string_of_jsbytes("invalid octect"),
     cst$37=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$35=caml_string_of_jsbytes(""),
     cst$33=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst$32=caml_string_of_jsbytes(""),
     cst$31=caml_string_of_jsbytes(","),
     cst$29=caml_string_of_jsbytes("/"),
     cst$30=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(""),
     cst$26=caml_string_of_jsbytes(""),
     cst$27=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes(""),
     cst_localhost$0=caml_string_of_jsbytes("localhost"),
     cst$21=caml_string_of_jsbytes("//"),
     cst$22=caml_string_of_jsbytes("/"),
     cst$23=caml_string_of_jsbytes(":"),
     cst$24=caml_string_of_jsbytes("./"),
     cst$19=caml_string_of_jsbytes("/"),
     cst$20=caml_string_of_jsbytes("/"),
     cst$18=caml_string_of_jsbytes(","),
     cst$17=caml_string_of_jsbytes("&"),
     cst$16=caml_string_of_jsbytes("/"),
     cst$13=caml_string_of_jsbytes("/"),
     cst$14=caml_string_of_jsbytes("/"),
     cst$15=caml_string_of_jsbytes("/"),
     cst$12=caml_string_of_jsbytes("/"),
     cst$11=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes("."),
     cst$0=caml_string_of_jsbytes(".."),
     cst$1=caml_string_of_jsbytes("/"),
     cst$5=caml_string_of_jsbytes("."),
     cst$6=caml_string_of_jsbytes(".."),
     cst$7=caml_string_of_jsbytes("/"),
     cst$8=caml_string_of_jsbytes("/"),
     cst$9=caml_string_of_jsbytes("/"),
     cst$10=caml_string_of_jsbytes("/"),
     cst$2=caml_string_of_jsbytes(".."),
     e=caml_string_of_jsbytes("/"),
     cst$3=caml_string_of_jsbytes("/"),
     cst$4=caml_string_of_jsbytes("/"),
     cst_int_of_hex_char=caml_string_of_jsbytes("int_of_hex_char"),
     cst_int_of_hex_char$0=caml_string_of_jsbytes("int_of_hex_char"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_urn=caml_string_of_jsbytes("urn"),
     cst_localhost=caml_string_of_jsbytes("localhost"),
     subd=caml_string_of_jsbytes("!$&'()*+,;="),
     always_safe=
      caml_string_of_jsbytes
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~"),
     cst$47=caml_string_of_jsbytes(""),
     cst$49=caml_string_of_jsbytes("//"),
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Angstrom=global_data.Angstrom,
     Stdlib_String=global_data.Stdlib__String,
     Stdlib=global_data.Stdlib,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Format=global_data.Stdlib__Format,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stringext=global_data.Stringext,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Stdlib_Bytes=global_data.Stdlib__Bytes,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Char=global_data.Stdlib__Char,
     _G_=[0,0,0],
     _F_=[0,caml_string_of_jsbytes(""),0],
     _o_=
      [0,
       [11,caml_string_of_jsbytes("/?"),[2,0,0]],
       caml_string_of_jsbytes("/?%s")],
     _n_=[0,[2,0,[12,63,[2,0,0]]],caml_string_of_jsbytes("%s?%s")],
     _m_=[0,caml_string_of_jsbytes("")],
     _l_=[0,0],
     _g_=[0,caml_string_of_jsbytes(""),0],
     _h_=[0,caml_string_of_jsbytes(""),0],
     _i_=[0,2],
     _j_=[0,[0,caml_string_of_jsbytes(""),0],0],
     _d_=[0,2],
     _e_=[0,caml_string_of_jsbytes(""),0],
     _c_=[0,[12,37,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes("%%%02X")],
     _b_=[0,caml_string_of_jsbytes("")],
     _a_=[0,caml_string_of_jsbytes("/"),0],
     _aj_=[0,0,0,0];
    function iter_concat(fn,sep,buf,param)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var _d5_=param$0[1];
        if(! param$0[2])return caml_call2(fn,buf,_d5_);
        var rest=param$0[2];
        caml_call2(fn,buf,_d5_);
        caml_call2(Stdlib_Buffer[16],buf,sep);
        var param$0=rest}}
    function compare_opt(c,t$0,t)
     {if(! t$0)return t?-1:0;
      var _d4_=t$0[1];
      if(! t)return 1;
      var b=t[1];
      return caml_call2(c,_d4_,b)}
    function compare_list(f,t$0,t)
     {var t$2=t$0,t$1=t;
      for(;;)
       {if(! t$2)return t$1?-1:0;
        var _d2_=t$2[2],_d3_=t$2[1];
        if(! t$1)return 1;
        var ys=t$1[2],y=t$1[1],c=caml_call2(f,_d3_,y);
        if(0 !== c)return c;
        var t$2=_d2_,t$1=ys}}
    function sub_delims(a)
     {var i=0;
      for(;;)
       {var c=caml_string_get(subd,i);
        caml_check_bound(a,c)[1 + c] = 1;
        var _d1_=i + 1 | 0;
        if(10 === i)return a;
        var i=_d1_}}
    var a=caml_make_vect(256,0),i=0;
    for(;;)
     {var c=caml_string_get(always_safe,i);
      caml_check_bound(a,c)[1 + c] = 1;
      var _aK_=i + 1 | 0;
      if(65 !== i){var i=_aK_;continue}
      var pchar=sub_delims(caml_call1(Stdlib_Array[8],a));
      caml_check_bound(pchar,58)[59] = 1;
      caml_check_bound(pchar,64)[65] = 1;
      var safe_chars_for_scheme=caml_call1(Stdlib_Array[8],a);
      caml_check_bound(safe_chars_for_scheme,43)[44] = 1;
      var safe_chars_for_path=sub_delims(caml_call1(Stdlib_Array[8],pchar));
      caml_check_bound(safe_chars_for_path,47)[48] = 0;
      var safe_chars_for_fragment=caml_call1(Stdlib_Array[8],pchar);
      caml_check_bound(safe_chars_for_fragment,47)[48] = 1;
      caml_check_bound(safe_chars_for_fragment,63)[64] = 1;
      caml_check_bound(safe_chars_for_fragment,38)[39] = 0;
      caml_check_bound(safe_chars_for_fragment,59)[60] = 0;
      caml_check_bound(safe_chars_for_fragment,43)[44] = 0;
      var
       safe_chars_for_query_key=
        caml_call1(Stdlib_Array[8],safe_chars_for_fragment);
      caml_check_bound(safe_chars_for_query_key,61)[62] = 0;
      var
       safe_chars_for_query_value=
        caml_call1(Stdlib_Array[8],safe_chars_for_fragment);
      caml_check_bound(safe_chars_for_query_value,44)[45] = 0;
      var a$0=caml_call1(Stdlib_Array[8],a);
      caml_check_bound(a$0,58)[59] = 0;
      var
       safe_chars_for_component=
        function(param)
         {if(typeof param === "number")
           if(-145160102 <= param)
            {if(127343601 <= param)
              {if(795008922 === param)return safe_chars_for_query_value;
               if(892015045 === param)return safe_chars_for_path}
             else
              if(61643255 !== param && 127343600 <= param)
               return safe_chars_for_fragment}
           else
            if(-250086679 <= param)
             {if(-178940859 === param)return safe_chars_for_scheme;
              if(-145160103 <= param)return a$0}
            else
             {if(-911188600 === param)return safe_chars_for_query_key;
              if(-250086680 <= param)return safe_chars_for_fragment}
          else
           if(-198771759 === param[1])
            {var
              match=param[2],
              unsafe=match[3],
              safe=match[2],
              component=match[1],
              _dU_=safe_chars_for_component(component),
              safe_chars=caml_call1(Stdlib_Array[8],_dU_),
              _dW_=caml_ml_string_length(safe) - 1 | 0,
              _dV_=0;
             if(_dW_ >= 0)
              {var i$0=_dV_;
               for(;;)
                {var c$0=caml_string_get(safe,i$0);
                 caml_check_bound(safe_chars,c$0)[1 + c$0] = 1;
                 var _d0_=i$0 + 1 | 0;
                 if(_dW_ !== i$0){var i$0=_d0_;continue}
                 break}}
             var _dY_=caml_ml_string_length(unsafe) - 1 | 0,_dX_=0;
             if(_dY_ >= 0)
              {var i=_dX_;
               for(;;)
                {var c=caml_string_get(unsafe,i);
                 caml_check_bound(safe_chars,c)[1 + c] = 0;
                 var _dZ_=i + 1 | 0;
                 if(_dY_ !== i){var i=_dZ_;continue}
                 break}}
             return safe_chars}
          return a},
       normalize_host=function(hso){return hso},
       canonicalize_port=function(port){return port},
       canonicalize_path=function(path){return path},
       Generic=
        [0,
         safe_chars_for_component,
         normalize_host,
         canonicalize_port,
         canonicalize_path],
       safe_chars_for_component$0=Generic[1],
       normalize_host$0=
        function(param)
         {if(! param)return 0;
          var hs=param[1];
          return [0,caml_call1(Stdlib_String[26],hs)]},
       canonicalize_port$0=
        function(param)
         {if(! param)return 0;var _dT_=param[1];return 80 === _dT_?0:[0,_dT_]},
       canonicalize_path$0=function(x){return x?x:_a_},
       Http=
        [0,
         safe_chars_for_component$0,
         normalize_host$0,
         canonicalize_port$0,
         canonicalize_path$0],
       safe_chars_for_component$1=Http[1],
       normalize_host$1=Http[2],
       canonicalize_path$1=Http[4],
       canonicalize_port$1=
        function(param)
         {if(! param)return 0;
          var _dS_=param[1];
          return 443 === _dS_?0:[0,_dS_]},
       Https=
        [0,
         safe_chars_for_component$1,
         normalize_host$1,
         canonicalize_port$1,
         canonicalize_path$1],
       safe_chars_for_component$2=Generic[1],
       canonicalize_port$2=Generic[3],
       canonicalize_path$2=Generic[4],
       normalize_host$2=
        function(param)
         {if(! param)return 0;
          var hs=param[1],hs$0=caml_call1(Stdlib_String[26],hs);
          return caml_string_equal(hs$0,cst_localhost)?_b_:[0,hs$0]},
       File=
        [0,
         safe_chars_for_component$2,
         normalize_host$2,
         canonicalize_port$2,
         canonicalize_path$2],
       safe_chars_for_component$3=Generic[1],
       normalize_host$3=Generic[2],
       canonicalize_port$3=Generic[3],
       canonicalize_path$3=Generic[4],
       Urn=
        [0,
         safe_chars_for_component$3,
         normalize_host$3,
         canonicalize_port$3,
         canonicalize_path$3],
       module_of_scheme=
        function(param)
         {if(! param)return Generic;
          var s=param[1],match=caml_call1(Stdlib_String[26],s);
          return caml_string_notequal(match,cst_file)
                  ?caml_string_notequal(match,cst_http)
                    ?caml_string_notequal(match,cst_https)
                      ?caml_string_notequal(match,cst_urn)?Generic:Urn
                      :Https
                    :Http
                  :File},
       encode=
        function(scheme,opt,b)
         {if(opt)var sth=opt[1],component=sth;else var component=892015045;
          var
           Scheme=module_of_scheme(scheme),
           safe_chars=caml_call1(Scheme[1],component),
           len=caml_ml_string_length(b),
           buf=caml_call1(Stdlib_Buffer[1],len),
           start=0,
           cur=0;
          for(;;)
           {if(len <= cur)
             {caml_call4(Stdlib_Buffer[18],buf,b,start,cur - start | 0);
              return caml_call1(Stdlib_Buffer[2],buf)}
            var c=caml_string_get(b,cur);
            if(caml_check_bound(safe_chars,c)[1 + c])
             {var cur$0=cur + 1 | 0,cur=cur$0;continue}
            if(start < cur)
             caml_call4(Stdlib_Buffer[18],buf,b,start,cur - start | 0);
            var _dR_=caml_call2(Stdlib_Printf[4],_c_,c);
            caml_call2(Stdlib_Buffer[16],buf,_dR_);
            var cur$1=cur + 1 | 0,start$0=cur + 1 | 0,start=start$0,cur=cur$1}},
       int_of_hex_char=
        function(c)
         {var c$0=caml_call1(Stdlib_Char[6],c) - 48 | 0;
          if(9 >= c$0)
           return 0 <= c$0?c$0:caml_call1(Stdlib[2],cst_int_of_hex_char$0);
          if(16 < c$0 && 23 > c$0)return c$0 - 7 | 0;
          return caml_call1(Stdlib[2],cst_int_of_hex_char)},
       decode=
        function(b)
         {var
           len=caml_ml_string_length(b),
           buf=caml_call1(Stdlib_Buffer[1],len);
          function scan(start,cur)
           {var start$0=start,cur$0=cur;
            for(;;)
             {if(len <= cur$0)
               return caml_call4
                       (Stdlib_Buffer[18],buf,b,start$0,cur$0 - start$0 | 0);
              if(37 !== caml_string_get(b,cur$0))
               {var cur$4=cur$0 + 1 | 0,cur$0=cur$4;continue}
              caml_call4(Stdlib_Buffer[18],buf,b,start$0,cur$0 - start$0 | 0);
              var cur$1=cur$0 + 1 | 0;
              if(len <= cur$1)return caml_call2(Stdlib_Buffer[12],buf,37);
              try
               {var highbits=int_of_hex_char(caml_string_get(b,cur$1))}
              catch(_dQ_)
               {caml_call2(Stdlib_Buffer[12],buf,37);
                var start$0=cur$1,cur$0=cur$1;
                continue}
              var cur$2=cur$1 + 1 | 0;
              if(len <= cur$2)
               {caml_call2(Stdlib_Buffer[12],buf,37);
                var _dM_=caml_string_get(b,cur$2 - 1 | 0);
                return caml_call2(Stdlib_Buffer[12],buf,_dM_)}
              try
               {var
                 switch$0=0,
                 lowbits=int_of_hex_char(caml_string_get(b,cur$2));
                switch$0 = 1}
              catch(_dP_)
               {caml_call2(Stdlib_Buffer[12],buf,37);
                var _dN_=caml_string_get(b,cur$2 - 1 | 0);
                caml_call2(Stdlib_Buffer[12],buf,_dN_);
                var cur$3=cur$2}
              if(switch$0)
               {var
                 _dO_=
                  caml_call1(Stdlib_Char[1],(highbits << 4) + lowbits | 0);
                caml_call2(Stdlib_Buffer[12],buf,_dO_);
                var cur$3=cur$2 + 1 | 0}
              var start$0=cur$3,cur$0=cur$3}}
          scan(0,0);
          return caml_call1(Stdlib_Buffer[2],buf)},
       pct_encode=
        function(scheme,opt,s)
         {if(opt)var sth=opt[1],component=sth;else var component=892015045;
          return encode(scheme,[0,component],s)},
       pct_encoder=
        function(opt,_dL_,_dK_,_dJ_,_dI_,_dH_,_dG_,param)
         {if(opt)var sth=opt[1],scheme=sth;else var scheme=-178940859;
          if(_dL_)
           var sth$0=_dL_[1],userinfo=sth$0;
          else
           var userinfo=-145160103;
          if(_dK_)var sth$1=_dK_[1],host=sth$1;else var host=803994504;
          if(_dJ_)var sth$2=_dJ_[1],path=sth$2;else var path=892015045;
          if(_dI_)
           var sth$3=_dI_[1],query_key=sth$3;
          else
           var query_key=-911188600;
          if(_dH_)
           var sth$4=_dH_[1],query_value=sth$4;
          else
           var query_value=795008922;
          if(_dG_)
           var sth$5=_dG_[1],fragment=sth$5;
          else
           var fragment=127343600;
          return [0,scheme,userinfo,host,path,query_key,query_value,fragment]},
       pct_decode=function(s){return decode(s)},
       compare=
        function(param,_dF_)
         {var
           p=_dF_[2],
           u=_dF_[1],
           p$0=param[2],
           u$0=param[1],
           c=caml_call2(Stdlib_String[9],u$0,u);
          return 0 === c?compare_opt(Stdlib_String[9],p$0,p):c},
       userinfo_of_encoded=
        function(us)
         {var match=caml_call3(Stringext[3],_d_,us,58);
          if(! match)return _e_;
          var _dC_=match[2],_dD_=match[1];
          if(! _dC_)return [0,pct_decode(_dD_),0];
          var p=_dC_[1],_dE_=[0,pct_decode(p)];
          return [0,pct_decode(_dD_),_dE_]},
       encoded_of_userinfo=
        function(scheme,component)
         {return function(param)
           {var po=param[2],u=param[1];
            if(po)var p=po[1],_dz_=caml_ml_string_length(p);else var _dz_=0;
            var
             len=(1 + caml_ml_string_length(u) | 0) + _dz_ | 0,
             buf=caml_call1(Stdlib_Buffer[1],len),
             _dA_=pct_encode(scheme,[0,component],u);
            caml_call2(Stdlib_Buffer[16],buf,_dA_);
            if(po)
             {var p$0=po[1];
              caml_call2(Stdlib_Buffer[12],buf,58);
              var _dB_=pct_encode(scheme,[0,component],p$0);
              caml_call2(Stdlib_Buffer[16],buf,_dB_)}
            return caml_call1(Stdlib_Buffer[2],buf)}},
       _f_=Stdlib_String[9],
       path_of_encoded=
        function(ps)
         {var tokl=caml_call2(Stringext[4],ps,47);
          return caml_call2(Stdlib_List[19],pct_decode,tokl)},
       remove_dot_segments=
        function(p)
         {var
           param$1=caml_call1(Stdlib_List[9],p),
           ascension=0,
           outp=0,
           param$2=param$1;
          for(;;)
           {var switch$0=0;
            if(param$2)
             {var _dv_=param$2[1],switch$1=0;
              if(caml_string_notequal(_dv_,cst))
               {var switch$2=0;
                if(caml_string_notequal(_dv_,cst$0))
                 if(caml_string_notequal(_dv_,cst$1))
                  {switch$1 = 1;switch$2 = 1}
                 else
                  {var _dx_=param$2[2];
                   if(_dx_)
                    {var _dy_=_dx_[1];
                     if(caml_string_notequal(_dy_,cst$5))
                      if(caml_string_notequal(_dy_,cst$6))
                       {if(! caml_string_notequal(_dy_,cst$7))
                         {var r$0=_dx_[2];
                          if(0 < ascension)
                           {var
                             param$4=[0,cst$8,r$0],
                             ascension$1=ascension - 1 | 0,
                             ascension=ascension$1,
                             param$2=param$4;
                            continue}}
                        var r=_dx_[2];
                        if(0 < ascension)
                         {var
                           ascension$0=ascension - 1 | 0,
                           ascension=ascension$0,
                           param$2=r;
                          continue}
                        switch$1 = 1;
                        switch$2 = 1}
                      else
                       var param$5=_dx_[2];
                     else
                      {var param$6=_dx_[2];switch$2 = 1}}
                   else
                    {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
                else
                 var param$5=param$2[2];
                if(! switch$2)
                 {var
                   ascension$2=ascension + 1 | 0,
                   ascension=ascension$2,
                   param$2=param$5;
                  continue}}
              else
               var param$6=param$2[2];
              if(! switch$1){var param$2=param$6;continue}}
            else
             switch$0 = 1;
            if
             (switch$0
              &&
              0
              <
              caml_call1(Stdlib_List[1],p)
              &&
              caml_string_equal(caml_call1(Stdlib_List[5],p),cst$9))
             return [0,cst$10,outp];
            if(param$2)
             {var
               param$3=param$2[2],
               s=param$2[1],
               outp$0=[0,s,outp],
               ascension=0,
               outp=outp$0,
               param$2=param$3;
              continue}
            if(0 >= ascension)
             {if
               (0
                <
                caml_call1(Stdlib_List[1],outp)
                &&
                caml_string_equal(caml_call1(Stdlib_List[5],outp),cst$4))
               return caml_call1(Stdlib_List[6],outp);
              return outp}
            var
             lst=
              caml_call1(Stdlib_Array[11],caml_make_vect(ascension,cst$2));
            if(lst)
             {var t=lst[2],h=lst[1],acc$1=[0,h,0],acc=acc$1,param=t;
              for(;;)
               {if(param)
                 {var
                   param$0=param[2],
                   x=param[1],
                   acc$0=[0,x,[0,e,acc]],
                   acc=acc$0,
                   param=param$0;
                  continue}
                var _dw_=acc;
                break}}
            else
             var _dw_=0;
            return caml_call2(Stdlib_List[12],[0,cst$3,_dw_],outp)}},
       encoded_of_path=
        function(scheme,component)
         {return function(p)
           {var _ds_=0;
            function _dt_(c,tok){return caml_ml_string_length(tok) + c | 0}
            var
             len=caml_call3(Stdlib_List[25],_dt_,_ds_,p),
             buf=caml_call1(Stdlib_Buffer[1],len);
            iter_concat
             (function(buf,seg)
               {if(! caml_string_notequal(seg,cst$12))
                 return caml_call2(Stdlib_Buffer[12],buf,47);
                var _du_=pct_encode(scheme,[0,component],seg);
                return caml_call2(Stdlib_Buffer[16],buf,_du_)},
              cst$11,
              buf,
              p);
            return caml_call1(Stdlib_Buffer[2],buf)}},
       find=
        function(q,k)
         {try
           {var _dq_=[0,caml_call2(Stdlib_List[46],k,q)];return _dq_}
          catch(_dr_)
           {_dr_ = caml_wrap_exception(_dr_);
            if(_dr_ === Stdlib[8])return 0;
            throw _dr_}},
       query_of_encoded=
        function(qs)
         {var els=caml_call3(Stringext[3],0,qs,38);
          function plus_to_space(s)
           {var
             s$0=caml_call1(Stdlib_Bytes[49],s),
             _do_=runtime.caml_ml_bytes_length(s$0) - 1 | 0,
             _dn_=0;
            if(_do_ >= 0)
             {var i=_dn_;
              for(;;)
               {if(43 === runtime.caml_bytes_get(s$0,i))
                 runtime.caml_bytes_set(s$0,i,32);
                var _dp_=i + 1 | 0;
                if(_do_ !== i){var i=_dp_;continue}
                break}}
            return caml_call1(Stdlib_Bytes[48],s$0)}
          if(els)
           {var
             _dj_=function(el){return caml_call3(Stringext[3],_i_,el,61)},
             param$1=caml_call2(Stdlib_List[21],_dj_,els),
             acc=0,
             param=param$1;
            for(;;)
             {if(param)
               {var _df_=param[1];
                if(! _df_)
                 {var
                   param$0=param[2],
                   acc$2=[0,_h_,acc],
                   acc=acc$2,
                   param=param$0;
                  continue}
                var _dg_=_df_[2],_dh_=_df_[1];
                if(_dg_)
                 {var
                   tl=param[2],
                   v=_dg_[1],
                   _di_=plus_to_space(v),
                   l=caml_call3(Stringext[3],0,_di_,44),
                   l$0=l || _g_,
                   n=[0,plus_to_space(_dh_),l$0],
                   acc$0=[0,n,acc],
                   acc=acc$0,
                   param=tl;
                  continue}
                var
                 tl$0=param[2],
                 n$0=[0,plus_to_space(_dh_),0],
                 acc$1=[0,n$0,acc],
                 acc=acc$1,
                 param=tl$0;
                continue}
              var _dk_=acc;
              break}}
          else
           var _dk_=_j_;
          function _dl_(param)
           {var
             v=param[2],
             k=param[1],
             _dm_=caml_call2(Stdlib_List[19],pct_decode,v);
            return [0,pct_decode(k),_dm_]}
          return caml_call2(Stdlib_List[19],_dl_,_dk_)},
       encoded_of_query=
        function(scheme,opt,l)
         {if(opt)
           var sth=opt[1],pct_encoder$0=sth;
          else
           var pct_encoder$0=pct_encoder(0,0,0,0,0,0,0,0);
          var _c__=-1;
          function _c$_(a,param)
           {var v=param[2],k=param[1],_dd_=0;
            function _de_(a,s)
             {return (a + caml_ml_string_length(s) | 0) + 1 | 0}
            return ((a + caml_ml_string_length(k) | 0)
                    +
                    caml_call3(Stdlib_List[25],_de_,_dd_,v)
                    |
                    0)
                   +
                   2
                   |
                   0}
          var
           len=caml_call3(Stdlib_List[25],_c$_,_c__,l),
           buf=caml_call1(Stdlib_Buffer[1],len);
          iter_concat
           (function(buf,param)
             {var
               v=param[2],
               k=param[1],
               _da_=pct_encode(scheme,[0,pct_encoder$0[5]],k);
              caml_call2(Stdlib_Buffer[16],buf,_da_);
              var _db_=0 !== v?1:0;
              return _db_
                      ?(caml_call2(Stdlib_Buffer[12],buf,61),
                        iter_concat
                         (function(buf,s)
                           {var _dc_=pct_encode(scheme,[0,pct_encoder$0[6]],s);
                            return caml_call2(Stdlib_Buffer[16],buf,_dc_)},
                          cst$18,
                          buf,
                          v))
                      :_db_},
            cst$17,
            buf,
            l);
          return caml_call1(Stdlib_Buffer[2],buf)},
       of_raw=
        function(qs)
         {function _c9_(param){return query_of_encoded(qs)}
          var lazy_query=caml_call1(Stdlib_Lazy[6],_c9_);
          return [1,[0,qs],lazy_query]},
       kv=
        function(param)
         {if(0 === param[0])
           var kv=param[1];
          else
           var
            _c6_=param[2],
            _c7_=caml_obj_tag(_c6_),
            _c8_=
             250 === _c7_
              ?_c6_[1]
              :246 === _c7_?caml_call1(CamlinternalLazy[2],_c6_):_c6_,
            kv=_c8_;
          return kv},
       encoded_of_query$0=
        function(scheme)
         {return function(_c4_,_c5_)
           {return encoded_of_query(scheme,_c4_,_c5_)}},
       empty=[0,0,0,0,0,0,[1,0,caml_call1(Stdlib_Lazy[4],0)],0],
       _k_=Stdlib_String[9],
       compare_decoded_opt=
        function(_c2_,_c3_){return compare_opt(_k_,_c2_,_c3_)},
       compare$0=
        function(t$0,t)
         {var c=compare_decoded_opt(t$0[3],t[3]);
          if(0 !== c)return c;
          var c$0=compare_decoded_opt(t$0[1],t[1]);
          if(0 !== c$0)return c$0;
          var
           _cX_=t[4],
           _cY_=t$0[4],
           c$1=
            compare_opt
             (function(p$0,p){return p$0 < p?-1:p < p$0?1:0},_cY_,_cX_);
          if(0 !== c$1)return c$1;
          var c$2=compare_opt(compare,t$0[2],t[2]);
          if(0 !== c$2)return c$2;
          var c$4=compare_list(_f_,t$0[5],t[5]);
          if(0 !== c$4)return c$4;
          var _cZ_=t[6],_c0_=t$0[6],switch$0=0;
          if(0 === _c0_[0])
           {var _cP_=_c0_[1];
            if(0 === _cZ_[0])
             var kvl$0=_cZ_[1],kvl=_cP_;
            else
             var
              _cQ_=_cZ_[2],
              _cR_=caml_obj_tag(_cQ_),
              _cS_=
               250 === _cR_
                ?_cQ_[1]
                :246 === _cR_?caml_call1(CamlinternalLazy[2],_cQ_):_cQ_,
              kvl$0=_cS_,
              kvl=_cP_}
          else
           {var _cT_=_c0_[2],_cU_=_c0_[1];
            if(0 === _cZ_[0])
             var
              _cV_=caml_obj_tag(_cT_),
              _cW_=
               250 === _cV_
                ?_cT_[1]
                :246 === _cV_?caml_call1(CamlinternalLazy[2],_cT_):_cT_,
              kvl$0=_cZ_[1],
              kvl=_cW_;
            else
             {var raw=_cZ_[1],c$3=compare_opt(Stdlib_String[9],_cU_,raw);
              switch$0 = 1}}
          if(! switch$0)
           var
            c$3=
             compare_list
              (function(param,_c1_)
                {var
                  vl=_c1_[2],
                  k=_c1_[1],
                  vl$0=param[2],
                  k$0=param[1],
                  c=caml_call2(Stdlib_String[9],k$0,k);
                 return 0 === c?compare_list(Stdlib_String[9],vl$0,vl):c},
               kvl,
               kvl$0);
          return 0 === c$3?compare_decoded_opt(t$0[7],t[7]):c$3},
       equal=function(t$0,t){return 0 === compare$0(t$0,t)?1:0},
       uncast_opt=
        function(param){if(! param)return 0;var h=param[1];return [0,h]},
       normalize=
        function(schem,init)
         {var
           Scheme=module_of_scheme(uncast_opt(schem)),
           _cF_=init[7],
           _cG_=init[6],
           _cH_=init[5],
           _cI_=init[4],
           _cJ_=uncast_opt(init[3]),
           param=caml_call1(Scheme[2],_cJ_);
          if(param)var h=param[1],_cK_=[0,h];else var _cK_=0;
          var _cM_=init[1],_cL_=init[2],_cN_=Stdlib_String[26];
          if(_cM_)var x=_cM_[1],_cO_=[0,caml_call1(_cN_,x)];else var _cO_=0;
          return [0,_cO_,_cL_,_cK_,_cI_,_cH_,_cG_,_cF_]},
       make=
        function(scheme,userinfo,host,port,path,query,fragment,param)
         {function decode(param)
           {if(! param)return 0;var x=param[1];return [0,x]}
          var switch$0=0;
          if(! host)
           {var switch$1=0;
            if(! port && ! userinfo)switch$1 = 1;
            if(! switch$1){var host$0=_m_;switch$0 = 1}}
          if(! switch$0)var host$0=host;
          if(userinfo)
           var u=userinfo[1],userinfo$0=[0,userinfo_of_encoded(u)];
          else
           var userinfo$0=0;
          if(path)
           {var p=path[1],path$0=path_of_encoded(p),switch$2=0;
            if(host$0 && path$0 && caml_string_notequal(path$0[1],cst$19))
             {var _cD_=[0,cst$20,path$0];switch$2 = 1}
            if(! switch$2)var _cD_=path$0;
            var path$1=_cD_}
          else
           var path$1=0;
          if(query)var p$0=query[1],query$0=[0,p$0];else var query$0=_l_;
          var scheme$0=decode(scheme),_cE_=decode(fragment);
          return normalize
                  (scheme$0,
                   [0,
                    scheme$0,
                    userinfo$0,
                    decode(host$0),
                    port,
                    path$1,
                    query$0,
                    _cE_])},
       to_string=
        function(opt,uri)
         {if(opt)
           var sth=opt[1],pct_encoder$0=sth;
          else
           var pct_encoder$0=pct_encoder(0,0,0,0,0,0,0,0);
          var _cf_=uri[1];
          if(_cf_)var s=_cf_[1],scheme=[0,s];else var scheme=0;
          var buf=caml_call1(Stdlib_Buffer[1],128);
          function add_pct_string(opt,x)
           {if(opt)var sth=opt[1],component=sth;else var component=892015045;
            var _cC_=encode(scheme,[0,component],x);
            return caml_call2(Stdlib_Buffer[16],buf,_cC_)}
          var _cg_=uri[1];
          if(_cg_)
           {var x=_cg_[1];
            add_pct_string([0,pct_encoder$0[1]],x);
            caml_call2(Stdlib_Buffer[12],buf,58)}
          var switch$0=0,_ch_=uri[3],_ci_=uri[4];
          if(! uri[2] && ! _ch_ && ! _ci_){var _cj_=0;switch$0 = 1}
          if(! switch$0)var _cj_=1;
          if(_cj_)caml_call2(Stdlib_Buffer[16],buf,cst$21);
          var _ck_=uri[2];
          if(_ck_)
           {var
             userinfo=_ck_[1],
             _cl_=
              caml_call1
               (encoded_of_userinfo(scheme,pct_encoder$0[2]),userinfo);
            caml_call2(Stdlib_Buffer[16],buf,_cl_);
            caml_call2(Stdlib_Buffer[12],buf,64)}
          var _cm_=uri[3];
          if(_cm_){var host=_cm_[1];add_pct_string([0,pct_encoder$0[3]],host)}
          var _cn_=uri[4];
          if(_cn_)
           {var port=_cn_[1];
            caml_call2(Stdlib_Buffer[12],buf,58);
            var _co_=caml_call1(Stdlib[33],port);
            caml_call2(Stdlib_Buffer[16],buf,_co_)}
          var _cp_=uri[5];
          if(_cp_)
           {var _cq_=_cp_[1];
            if(caml_string_notequal(_cq_,cst$22))
             {if(uri[3])
               caml_call2(Stdlib_Buffer[12],buf,47);
              else
               {var match=caml_call3(Stringext[12],0,_cq_,cst$23);
                if(match && ! scheme)caml_call2(Stdlib_Buffer[16],buf,cst$24)}
              var
               _cr_=uri[5],
               _cs_=caml_call1(encoded_of_path(scheme,pct_encoder$0[4]),_cr_);
              caml_call2(Stdlib_Buffer[16],buf,_cs_)}
            else
             {var
               _cA_=uri[5],
               _cB_=caml_call1(encoded_of_path(scheme,pct_encoder$0[4]),_cA_);
              caml_call2(Stdlib_Buffer[16],buf,_cB_)}}
          var _ct_=uri[6],switch$1=0;
          if(0 === _ct_[0])
           {var _cu_=_ct_[1];if(_cu_){var q=_cu_;switch$1 = 1}}
          else
           if(_ct_[1])
            {var
              _cx_=_ct_[2],
              _cy_=caml_obj_tag(_cx_),
              _cz_=
               250 === _cy_
                ?_cx_[1]
                :246 === _cy_?caml_call1(CamlinternalLazy[2],_cx_):_cx_,
              q=_cz_;
             switch$1 = 1}
          if(switch$1)
           {caml_call2(Stdlib_Buffer[12],buf,63);
            var _cv_=encoded_of_query(scheme,[0,pct_encoder$0],q);
            caml_call2(Stdlib_Buffer[16],buf,_cv_)}
          var _cw_=uri[7];
          if(_cw_)
           {var f=_cw_[1];
            caml_call2(Stdlib_Buffer[12],buf,35);
            add_pct_string([0,pct_encoder$0[7]],f)}
          return caml_call1(Stdlib_Buffer[2],buf)},
       get_decoded_opt=
        function(param){if(! param)return 0;var x=param[1];return [0,x]},
       scheme=function(uri){return get_decoded_opt(uri[1])},
       with_scheme=
        function(uri,param)
         {if(! param)return [0,0,uri[2],uri[3],uri[4],uri[5],uri[6],uri[7]];
          var scheme=param[1];
          return [0,[0,scheme],uri[2],uri[3],uri[4],uri[5],uri[6],uri[7]]},
       host=function(uri){return get_decoded_opt(uri[3])},
       with_host=
        function(uri,param)
         {if(! param)return [0,uri[1],uri[2],0,uri[4],uri[5],uri[6],uri[7]];
          var host=param[1];
          return [0,uri[1],uri[2],[0,host],uri[4],uri[5],uri[6],uri[7]]},
       host_with_default=
        function(opt,uri)
         {if(opt)
           var sth=opt[1],default$0=sth;
          else
           var default$0=cst_localhost$0;
          var match=host(uri);
          if(! match)return default$0;
          var h=match[1];
          return h},
       userinfo=
        function(opt,uri)
         {if(opt)
           var sth=opt[1],pct_encoder$0=sth;
          else
           var pct_encoder$0=pct_encoder(0,0,0,0,0,0,0,0);
          var _cc_=uri[2];
          if(! _cc_)return 0;
          var userinfo=_cc_[1],_cd_=uri[1];
          if(_cd_)
           var
            s=_cd_[1],
            _ce_=
             caml_call1(encoded_of_userinfo([0,s],pct_encoder$0[2]),userinfo);
          else
           var
            _ce_=
             caml_call1(encoded_of_userinfo(0,pct_encoder$0[2]),userinfo);
          return [0,_ce_]},
       with_userinfo=
        function(uri,userinfo)
         {if(userinfo)
           var u=userinfo[1],userinfo$0=[0,userinfo_of_encoded(u)];
          else
           var userinfo$0=0;
          var match=host(uri);
          return match
                  ?[0,uri[1],userinfo$0,uri[3],uri[4],uri[5],uri[6],uri[7]]
                  :[0,
                    uri[1],
                    userinfo$0,
                    [0,cst$25],
                    uri[4],
                    uri[5],
                    uri[6],
                    uri[7]]},
       user=
        function(uri)
         {var _cb_=uri[2];
          if(! _cb_)return 0;
          var match=_cb_[1],user=match[1];
          return [0,user]},
       password=
        function(uri)
         {var _b$_=uri[2];
          if(_b$_)
           {var _ca_=_b$_[1][2];if(_ca_){var pass=_ca_[1];return [0,pass]}}
          return 0},
       with_password=
        function(uri,password)
         {function result(userinfo)
           {var match=host(uri);
            return match
                    ?[0,uri[1],userinfo,uri[3],uri[4],uri[5],uri[6],uri[7]]
                    :[0,uri[1],userinfo,[0,cst$26],uri[4],uri[5],uri[6],uri[7]]}
          var _b__=uri[2];
          if(! _b__)return password?result([0,[0,cst$27,password]]):uri;
          var match=_b__[1],user=match[1];
          return result([0,[0,user,password]])},
       port=function(uri){return uri[4]},
       with_port=
        function(uri,port)
         {var match=host(uri);
          return match
                  ?[0,uri[1],uri[2],uri[3],port,uri[5],uri[6],uri[7]]
                  :port
                    ?[0,uri[1],uri[2],[0,cst$28],port,uri[5],uri[6],uri[7]]
                    :[0,uri[1],uri[2],0,0,uri[5],uri[6],uri[7]]},
       path=
        function(opt,uri)
         {if(opt)
           var sth=opt[1],pct_encoder$0=sth;
          else
           var pct_encoder$0=pct_encoder(0,0,0,0,0,0,0,0);
          var _b6_=uri[1];
          if(_b6_)
           var
            s=_b6_[1],
            _b7_=uri[5],
            _b8_=caml_call1(encoded_of_path([0,s],pct_encoder$0[4]),_b7_);
          else
           var
            _b9_=uri[5],
            _b8_=caml_call1(encoded_of_path(0,pct_encoder$0[4]),_b9_);
          return _b8_},
       with_path=
        function(uri,path)
         {var path$0=path_of_encoded(path),match=host(uri);
          if(match && path$0 && caml_string_notequal(path$0[1],cst$29))
           return [0,
                   uri[1],
                   uri[2],
                   uri[3],
                   uri[4],
                   [0,cst$30,path$0],
                   uri[6],
                   uri[7]];
          return [0,uri[1],uri[2],uri[3],uri[4],path$0,uri[6],uri[7]]},
       fragment=function(uri){return get_decoded_opt(uri[7])},
       with_fragment=
        function(uri,param)
         {if(! param)return [0,uri[1],uri[2],uri[3],uri[4],uri[5],uri[6],0];
          var frag=param[1];
          return [0,uri[1],uri[2],uri[3],uri[4],uri[5],uri[6],[0,frag]]},
       query=function(uri){return kv(uri[6])},
       verbatim_query=
        function(opt,uri)
         {if(opt)
           var sth=opt[1],pct_encoder$0=sth;
          else
           var pct_encoder$0=pct_encoder(0,0,0,0,0,0,0,0);
          var _b4_=uri[6];
          if(0 === _b4_[0])
           {var _b5_=_b4_[1];
            return _b5_
                    ?[0,encoded_of_query(scheme(uri),[0,pct_encoder$0],_b5_)]
                    :0}
          var qs=_b4_[1];
          return qs},
       get_query_param=function(uri,k){return find(kv(uri[6]),k)},
       get_query_param$0=
        function(uri,k)
         {var match=get_query_param(uri,k);
          if(! match)return 0;
          var v=match[1];
          return [0,caml_call2(Stdlib_String[6],cst$31,v)]},
       with_query=
        function(uri,query)
         {return [0,uri[1],uri[2],uri[3],uri[4],uri[5],[0,query],uri[7]]},
       q_s=
        function(q)
         {function _b3_(param){var v=param[2],k=param[1];return [0,k,[0,v,0]]}
          return caml_call2(Stdlib_List[19],_b3_,q)},
       with_query$0=function(uri,query){return with_query(uri,q_s(query))},
       add_query_param=
        function(init,p)
         {var _b1_=init[7],_b2_=[0,[0,p,kv(init[6])]];
          return [0,init[1],init[2],init[3],init[4],init[5],_b2_,_b1_]},
       add_query_param$0=
        function(init,param)
         {var
           v=param[2],
           k=param[1],
           _bZ_=init[7],
           _b0_=[0,[0,[0,k,[0,v,0]],kv(init[6])]];
          return [0,init[1],init[2],init[3],init[4],init[5],_b0_,_bZ_]},
       add_query_params=
        function(init,ps)
         {var
           _bW_=init[7],
           _bX_=kv(init[6]),
           _bY_=[0,caml_call2(Stdlib[37],ps,_bX_)];
          return [0,init[1],init[2],init[3],init[4],init[5],_bY_,_bW_]},
       add_query_params$0=
        function(init,ps)
         {var
           _bS_=init[7],
           _bT_=kv(init[6]),
           _bU_=q_s(ps),
           _bV_=[0,caml_call2(Stdlib[37],_bU_,_bT_)];
          return [0,init[1],init[2],init[3],init[4],init[5],_bV_,_bS_]},
       remove_query_param=
        function(init,k)
         {var _bO_=init[7],_bP_=kv(init[6]);
          function _bQ_(param)
           {var k$0=param[1];return caml_string_notequal(k,k$0)}
          var _bR_=[0,caml_call2(Stdlib_List[41],_bQ_,_bP_)];
          return [0,init[1],init[2],init[3],init[4],init[5],_bR_,_bO_]},
       with_uri=
        function(scheme,userinfo,host,port,path,query,fragment,uri)
         {function with_path_opt(u,o)
           {if(! o)return with_path(u,cst$32);
            var p=o[1];
            return with_path(u,p)}
          function with_query_opt(u,o)
           {if(! o)return with_query(u,0);var q=o[1];return with_query(u,q)}
          function with$0(f,o,u)
           {if(! o)return u;var x=o[1];return caml_call2(f,u,x)}
          return with$0
                  (with_fragment,
                   fragment,
                   with$0
                    (with_query_opt,
                     query,
                     with$0
                      (with_path_opt,
                       path,
                       with$0
                        (with_port,
                         port,
                         with$0
                          (with_host,
                           host,
                           with$0
                            (with_userinfo,userinfo,with$0(with_scheme,scheme,uri)))))))},
       path_and_query=
        function(uri)
         {var match=path(0,uri),match$0=query(uri);
          if(caml_string_notequal(match,cst$33))
           {if(! match$0)return match;
            var
             scheme=uncast_opt(uri[1]),
             _bM_=caml_call2(encoded_of_query$0(scheme),0,match$0);
            return caml_call3(Stdlib_Printf[4],_n_,match,_bM_)}
          if(! match$0)return cst$34;
          var
           scheme$0=uncast_opt(uri[1]),
           _bN_=caml_call2(encoded_of_query$0(scheme$0),0,match$0);
          return caml_call2(Stdlib_Printf[4],_o_,_bN_)},
       resolve=
        function(schem,base,uri)
         {var match$0=scheme(base);
          if(match$0)
           var scheme$0=match$0[1],scheme$1=scheme$0;
          else
           var scheme$1=schem;
          var
           schem$0=[0,scheme$1],
           match$1=scheme(uri),
           match$2=userinfo(0,uri),
           match$3=host(uri);
          if(match$1)
           var
            _bt_=uri[7],
            _bu_=uri[6],
            _bv_=remove_dot_segments(uri[5]),
            _bw_=[0,uri[1],uri[2],uri[3],uri[4],_bv_,_bu_,_bt_];
          else
           {var switch$0=0;
            if(match$2 || match$3)
             switch$0 = 1;
            else
             {var
               init=[0,base[1],base[2],base[3],base[4],uri[5],uri[6],uri[7]],
               path_str=path(0,init);
              if(caml_string_equal(path_str,cst$35))
               var
                _bA_=init[7],
                _bB_=init[6][1]?init[6]:base[6],
                _bC_=[0,init[1],init[2],init[3],init[4],base[5],_bB_,_bA_];
              else
               if(47 === caml_string_get(path_str,0))
                var
                 _bD_=init[7],
                 _bE_=init[6],
                 _bF_=remove_dot_segments(init[5]),
                 _bC_=[0,init[1],init[2],init[3],init[4],_bF_,_bE_,_bD_];
               else
                {var
                  _bI_=init[5],
                  _bG_=init[7],
                  _bH_=init[6],
                  _bJ_=base[3],
                  match=caml_call1(Stdlib_List[9],base[5]),
                  switch$1=0;
                 if(_bJ_ && ! match)
                  var _bK_=[0,cst$16,_bI_];
                 else
                  switch$1 = 1;
                 if(switch$1)
                  {var switch$2=0;
                   if(match)
                    {var switch$3=0;
                     if(caml_string_notequal(match[1],cst$13))
                      {var _bs_=match[2];
                       if(_bs_ && ! caml_string_notequal(_bs_[1],cst$14))
                        var rbpath=_bs_[2];
                       else
                        switch$3 = 1}
                     else
                      var rbpath=match[2];
                     if(! switch$3)
                      {var
                        _bK_=
                         caml_call2(Stdlib_List[12],[0,cst$15,rbpath],_bI_);
                       switch$2 = 1}}
                   if(! switch$2)var _bK_=_bI_}
                 var
                  _bL_=remove_dot_segments(_bK_),
                  _bC_=[0,init[1],init[2],init[3],init[4],_bL_,_bH_,_bG_]}
              var _bw_=_bC_}
            if(switch$0)
             var
              _bx_=uri[7],
              _by_=uri[6],
              _bz_=remove_dot_segments(uri[5]),
              _bw_=[0,base[1],uri[2],uri[3],uri[4],_bz_,_by_,_bx_]}
          return normalize(schem$0,_bw_)},
       canonicalize=
        function(uri)
         {var
           init=resolve(cst$36,empty,uri),
           Scheme=module_of_scheme(uncast_opt(init[1])),
           _bo_=init[7],
           _bp_=init[6],
           _bq_=caml_call1(Scheme[4],init[5]),
           _br_=caml_call1(Scheme[3],init[4]);
          return [0,init[1],init[2],init[3],_br_,_bq_,_bp_,_bo_]},
       pp=
        function(ppf,uri)
         {var _bn_=to_string(0,uri);
          return caml_call2(Stdlib_Format[13],ppf,_bn_)},
       pp_hum=
        function(ppf,uri)
         {var _bm_=to_string(0,uri);
          return caml_call2(Stdlib_Format[13],ppf,_bm_)},
       string_of_char=caml_call1(Stdlib_String[1],1),
       string_of_char_list=
        function(chars)
         {var _bl_=caml_call2(Stdlib_List[19],string_of_char,chars);
          return caml_call2(Stdlib_String[6],cst$37,_bl_)},
       _p_=caml_call1(Angstrom[50],0),
       _q_=caml_call1(Angstrom[4],58),
       _r_=
        function(c)
         {var _bh_=58 !== c?1:0;
          if(_bh_)
           {var _bi_=47 !== c?1:0;
            if(_bi_)
             var _bj_=63 !== c?1:0,_bk_=_bj_?35 !== c?1:0:_bj_;
            else
             var _bk_=_bi_}
          else
           var _bk_=_bh_;
          return _bk_},
       _s_=caml_call1(Angstrom[13],_r_),
       _t_=caml_call2(Angstrom[58],_s_,_q_),
       _u_=function(s){return [0,decode(s)]},
       _v_=caml_call2(Angstrom[59],_u_,_t_),
       scheme$0=caml_call2(Angstrom[46],_v_,_p_),
       is_digit=function(param){return 9 < param - 48 >>> 0?0:1},
       _w_=
        function(param)
         {var _bg_=param - 48 | 0,switch$0=0;
          if(22 < _bg_ >>> 0)
           {if(5 >= _bg_ - 49 >>> 0)switch$0 = 1}
          else
           if(6 < _bg_ - 10 >>> 0)switch$0 = 1;
          return switch$0?1:0},
       hex_digit=caml_call1(Angstrom[7],_w_),
       _x_=caml_call1(Angstrom[38],hex_digit),
       hexadecimal=caml_call2(Angstrom[59],string_of_char_list,_x_),
       c_dot=caml_call1(Angstrom[4],46),
       c_at=caml_call1(Angstrom[4],64),
       c_colon=caml_call1(Angstrom[4],58),
       _y_=
        function(num)
         {return 256 <= caml_int_of_string(num)
                  ?caml_call1(Angstrom[51],cst_invalid_octect)
                  :caml_call1(Angstrom[50],num)},
       _z_=function(param){return 9 < param - 48 >>> 0?0:1},
       _A_=caml_call1(Angstrom[14],_z_),
       dec_octet=caml_call2(Angstrom[52],_A_,_y_),
       _B_=caml_call2(Angstrom[58],dec_octet,c_dot),
       _C_=caml_call2(Angstrom[37],3,_B_),
       _D_=
        function(three,one)
         {var
           _be_=caml_call2(Stdlib[28],cst$38,one),
           _bf_=caml_call2(Stdlib_String[6],cst$39,three);
          return caml_call2(Stdlib[28],_bf_,_be_)},
       ipv4_address=caml_call3(Angstrom[60],_D_,_C_,dec_octet),
       _E_=
        function(f)
         {var
           _a__=caml_call1(Angstrom[50],0),
           _a$_=caml_call2(Angstrom[57],c_colon,f),
           _ba_=caml_call2(Angstrom[46],_a$_,_a__);
          function _bb_(x,y){return [0,x,y]}
          var
           _bc_=caml_call3(Angstrom[60],_bb_,hexadecimal,_ba_),
           _bd_=caml_call1(Angstrom[36],[0,ipv4_address,0]);
          return caml_call2(Angstrom[46],_bd_,_bc_)},
       after_double_colon=caml_call1(Angstrom[45],_E_),
       double_colon=
        function(count)
         {var _a7_=caml_call1(Angstrom[50],_F_);
          function _a8_(rest)
           {var
             filler_length=
              (8 - count | 0) - caml_call1(Stdlib_List[1],rest) | 0;
            return 0 < filler_length
                    ?caml_call1(Angstrom[50],[0,cst$40,rest])
                    :caml_call1(Angstrom[51],cst_too_many_parts_in_IPv6_add)}
          var _a9_=caml_call2(Angstrom[52],after_double_colon,_a8_);
          return caml_call2(Angstrom[46],_a9_,_a7_)},
       hex_part=
        function(n)
         {var
           _a1_=part(n + 1 | 0),
           _a2_=double_colon(n + 1 | 0),
           _a3_=caml_call2(Angstrom[57],c_colon,_a2_),
           _a4_=caml_call2(Angstrom[46],_a3_,_a1_),
           _a5_=caml_call2(Angstrom[57],c_colon,_a4_);
          function _a6_(x,y){return [0,x,y]}
          return caml_call3(Angstrom[60],_a6_,hexadecimal,_a5_)},
       part=
        function(n)
         {if(6 === n)
           {var
             _aY_=hex_part(6),
             _aZ_=caml_call1(Angstrom[36],[0,ipv4_address,0]);
            return caml_call2(Angstrom[46],_aZ_,_aY_)}
          if(7 !== n)return hex_part(n);
          function _a0_(x){return [0,x,0]}
          return caml_call2(Angstrom[59],_a0_,hexadecimal)},
       split_with=
        function(f,xs)
         {if(! xs)return _G_;
          var ys=xs[2],y=xs[1];
          if(! caml_call1(f,y))return [0,0,xs];
          var match=split_with(f,ys),ts=match[2],zs=match[1];
          return [0,[0,y,zs],ts]},
       format_addr=
        function(segments)
         {var
           match=
            split_with
             (function(segment){return caml_string_notequal(segment,cst$41)},
              segments),
           after_double_colon=match[2],
           before_double_colon=match[1],
           before=caml_call2(Stdlib_String[6],cst$42,before_double_colon),
           switch$0=0;
          if
           (after_double_colon
            &&
            !
            caml_string_notequal(after_double_colon[1],cst$43))
           {var
             xs=after_double_colon[2],
             _aW_=caml_call2(Stdlib_String[6],cst$44,xs),
             _aX_=caml_call2(Stdlib[28],cst$45,_aW_),
             res=caml_call2(Stdlib[28],before,_aX_);
            switch$0 = 1}
          if(! switch$0)var res=before;
          return res},
       _H_=part(0),
       _I_=double_colon(0),
       _J_=caml_call2(Angstrom[57],c_colon,c_colon),
       _K_=caml_call2(Angstrom[57],_J_,_I_),
       _L_=caml_call2(Angstrom[46],_K_,_H_),
       ipv6=caml_call2(Angstrom[59],format_addr,_L_),
       _M_=caml_call1(Angstrom[4],93),
       _N_=caml_call1(Angstrom[4],91),
       _O_=
        function(lb,ip,rb)
         {var
           _aU_=[0,ip,[0,caml_call1(string_of_char,rb),0]],
           _aV_=[0,caml_call1(string_of_char,lb),_aU_];
          return caml_call2(Stdlib_String[6],cst$46,_aV_)},
       ipv6_address=caml_call4(Angstrom[61],_O_,_N_,ipv6,_M_),
       _P_=caml_call2(Angstrom[37],2,hex_digit),
       _Q_=caml_call1(Angstrom[4],37),
       _R_=function(pct,digits){return string_of_char_list([0,pct,digits])},
       pct_encoded=caml_call3(Angstrom[60],_R_,_Q_,_P_),
       _S_=
        function(param)
         {var _aS_=param - 59 | 0,switch$0=0;
          if(2 < _aS_ >>> 0)
           {var _aT_=_aS_ + 26 | 0;
            if(11 >= _aT_ >>> 0)
             switch(_aT_){case 1:case 2:case 4:break;default:switch$0 = 1}}
          else
           if(1 !== _aS_)switch$0 = 1;
          return switch$0?1:0},
       sub_delims$0=caml_call1(Angstrom[7],_S_),
       _T_=
        function(param)
         {var switch$0=0;
          if(91 <= param)
           {var _aQ_=param - 95 | 0;
            if(27 < _aQ_ >>> 0)
             {if(31 === _aQ_)switch$0 = 1}
            else
             if(1 !== _aQ_)switch$0 = 1}
          else
           {var _aR_=param - 45 | 0;
            if(12 < _aR_ >>> 0)
             {if(20 <= _aR_)switch$0 = 1}
            else
             if(2 !== _aR_)switch$0 = 1}
          return switch$0?1:0},
       unreserved=caml_call1(Angstrom[7],_T_),
       _U_=
        [0,
         pct_encoded,
         [0,caml_call2(Angstrom[56],string_of_char,sub_delims$0),0]],
       _V_=[0,caml_call2(Angstrom[56],string_of_char,unreserved),_U_],
       _W_=caml_call2(Angstrom[47],0,_V_),
       _X_=caml_call1(Angstrom[38],_W_),
       _Y_=caml_call1(Stdlib_String[6],cst$47),
       reg_name=caml_call2(Angstrom[59],_Y_,_X_),
       _Z_=
        caml_call2
         (Angstrom[47],0,[0,reg_name,[0,ipv4_address,[0,ipv6_address,0]]]),
       ___=function(s){return decode(s)},
       host$0=caml_call2(Angstrom[59],___,_Z_),
       _$_=caml_call1(Angstrom[50],0),
       _aa_=[0,caml_call2(Angstrom[56],string_of_char,c_colon),0],
       _ab_=
        [0,
         pct_encoded,
         [0,caml_call2(Angstrom[56],string_of_char,sub_delims$0),_aa_]],
       _ac_=[0,caml_call2(Angstrom[56],string_of_char,unreserved),_ab_],
       _ad_=caml_call2(Angstrom[47],0,_ac_),
       _ae_=caml_call1(Angstrom[38],_ad_),
       _af_=caml_call2(Angstrom[58],_ae_,c_at),
       _ag_=
        function(x)
         {var s=caml_call2(Stdlib_String[6],cst$48,x);
          return [0,userinfo_of_encoded(s)]},
       _ah_=caml_call2(Angstrom[59],_ag_,_af_),
       userinfo$0=caml_call2(Angstrom[46],_ah_,_$_),
       _ai_=
        function(param)
         {if(param && 58 === param[1])
           {var
             _aL_=
              function(port)
               {var decoded=decode(port);
                try
                 {var _aO_=[0,caml_int_of_string(decoded)];return _aO_}
                catch(_aP_){return 0}},
             _aM_=caml_call1(Angstrom[13],is_digit),
             _aN_=caml_call2(Angstrom[57],c_colon,_aM_);
            return caml_call2(Angstrom[54],_aN_,_aL_)}
          return caml_call1(Angstrom[50],0)},
       port$0=caml_call2(Angstrom[52],Angstrom[1],_ai_),
       _ak_=caml_call1(Angstrom[50],_aj_),
       _al_=function(userinfo,host,port){return [0,userinfo,[0,host],port]},
       _am_=caml_call4(Angstrom[61],_al_,userinfo$0,host$0,port$0),
       _an_=caml_call1(Angstrom[8],cst$49),
       _ao_=caml_call2(Angstrom[57],_an_,_am_),
       authority=caml_call2(Angstrom[46],_ao_,_ak_),
       _ap_=function(param){if(35 !== param && 63 !== param)return 1;return 0},
       _aq_=caml_call1(Angstrom[13],_ap_),
       path$0=caml_call2(Angstrom[59],path_of_encoded,_aq_),
       _ar_=[1,0,caml_call1(Stdlib_Lazy[4],0)],
       _as_=caml_call1(Angstrom[50],_ar_),
       _at_=function(param){return 35 === param?1:0},
       _au_=caml_call1(Angstrom[15],_at_),
       _av_=caml_call1(Angstrom[4],63),
       _aw_=caml_call2(Angstrom[57],_av_,_au_),
       _ax_=caml_call2(Angstrom[59],of_raw,_aw_),
       query$0=caml_call2(Angstrom[46],_ax_,_as_),
       _ay_=caml_call1(Angstrom[50],0),
       _az_=function(param){return 1},
       _aA_=caml_call1(Angstrom[13],_az_),
       _aB_=caml_call1(Angstrom[4],35),
       _aC_=caml_call2(Angstrom[57],_aB_,_aA_),
       _aD_=function(s){return [0,decode(s)]},
       _aE_=caml_call2(Angstrom[59],_aD_,_aC_),
       fragment$0=caml_call2(Angstrom[46],_aE_,_ay_),
       _aF_=
        function(scheme,param,path,query,fragment)
         {var port=param[3],host=param[2],userinfo=param[1];
          return normalize
                  (scheme,[0,scheme,userinfo,host,port,path,query,fragment])},
       _aG_=caml_call5(Angstrom[62],_aF_,scheme$0,authority,path$0,query$0),
       uri_reference=caml_call2(Angstrom[55],_aG_,fragment$0),
       _aH_=
        function(s)
         {var match=caml_call3(Angstrom[74],1,uri_reference,s);
          if(0 !== match[0])return empty;
          var t=match[1];
          return t},
       _aI_=function(param){return 10 === param?0:1},
       _aJ_=caml_call1(Angstrom[13],_aI_),
       uri_reference$0=caml_call2(Angstrom[54],_aJ_,_aH_),
       of_string=
        function(s)
         {var match=caml_call3(Angstrom[74],0,uri_reference$0,s);
          if(0 !== match[0])return empty;
          var t=match[1];
          return t},
       Uri=
        [0,
         empty,
         compare$0,
         equal,
         pct_encode,
         pct_encoder,
         pct_decode,
         of_string,
         to_string,
         resolve,
         canonicalize,
         make,
         with_uri,
         query,
         verbatim_query,
         encoded_of_query$0,
         query_of_encoded,
         with_query,
         with_query$0,
         get_query_param,
         get_query_param$0,
         add_query_param,
         add_query_param$0,
         add_query_params,
         add_query_params$0,
         remove_query_param,
         path,
         path_and_query,
         with_path,
         scheme,
         with_scheme,
         userinfo,
         with_userinfo,
         user,
         password,
         with_password,
         host,
         with_host,
         host_with_default,
         port,
         with_port,
         fragment,
         with_fragment,
         pp,
         pp_hum,
         [0,ipv6,uri_reference$0]];
      runtime.caml_register_global(94,Uri,"Uri");
      return}}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImUiLCJzdWJkIiwiYWx3YXlzX3NhZmUiLCJpdGVyX2NvbmNhdCIsImZuIiwic2VwIiwiYnVmIiwicmVzdCIsImNvbXBhcmVfb3B0IiwiYyIsInQkMCIsInQiLCJiIiwiY29tcGFyZV9saXN0IiwiZiIsInQkMiIsInQkMSIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJhIiwiaSIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX2ZyYWdtZW50Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJhJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQiLCJ1bnNhZmUiLCJzYWZlIiwiY29tcG9uZW50Iiwic2FmZV9jaGFycyIsImkkMCIsImMkMCIsIm5vcm1hbGl6ZV9ob3N0IiwiaHNvIiwiY2Fub25pY2FsaXplX3BvcnQiLCJwb3J0IiwiY2Fub25pY2FsaXplX3BhdGgiLCJwYXRoIiwic2FmZV9jaGFyc19mb3JfY29tcG9uZW50JDAiLCJub3JtYWxpemVfaG9zdCQwIiwiaHMiLCJjYW5vbmljYWxpemVfcG9ydCQwIiwiY2Fub25pY2FsaXplX3BhdGgkMCIsIngiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwic2NhbiIsImN1ciQ0IiwiaGlnaGJpdHMiLCJjdXIkMiIsImxvd2JpdHMiLCJjdXIkMyIsInBjdF9lbmNvZGUiLCJwY3RfZW5jb2RlciIsInN0aCQwIiwidXNlcmluZm8iLCJzdGgkMSIsImhvc3QiLCJzdGgkMiIsInN0aCQzIiwicXVlcnlfa2V5Iiwic3RoJDQiLCJxdWVyeV92YWx1ZSIsInN0aCQ1IiwiZnJhZ21lbnQiLCJwY3RfZGVjb2RlIiwiY29tcGFyZSIsInAiLCJ1IiwicCQwIiwidSQwIiwidXNlcmluZm9fb2ZfZW5jb2RlZCIsInVzIiwiZW5jb2RlZF9vZl91c2VyaW5mbyIsInBvIiwicGF0aF9vZl9lbmNvZGVkIiwicHMiLCJ0b2tsIiwicmVtb3ZlX2RvdF9zZWdtZW50cyIsInBhcmFtJDEiLCJyJDAiLCJyIiwicGFyYW0kNSIsInBhcmFtJDYiLCJwYXJhbSQzIiwibHN0IiwiaCIsInBhcmFtJDAiLCJlbmNvZGVkX29mX3BhdGgiLCJ0b2siLCJzZWciLCJmaW5kIiwicSIsImsiLCJxdWVyeV9vZl9lbmNvZGVkIiwicXMiLCJlbHMiLCJwbHVzX3RvX3NwYWNlIiwicyQwIiwiZWwiLCJ0bCIsInYiLCJsIiwibCQwIiwibiIsInRsJDAiLCJuJDAiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkX29wdCIsImNvbXBhcmUkMCIsImMkMSIsImMkMiIsImMkNCIsImt2bCQwIiwia3ZsIiwicmF3IiwiYyQzIiwidmwiLCJ2bCQwIiwiayQwIiwiZXF1YWwiLCJ1bmNhc3Rfb3B0Iiwibm9ybWFsaXplIiwic2NoZW0iLCJpbml0IiwibWFrZSIsInF1ZXJ5IiwiaG9zdCQwIiwidXNlcmluZm8kMCIsInBhdGgkMCIsInBhdGgkMSIsInF1ZXJ5JDAiLCJzY2hlbWUkMCIsInRvX3N0cmluZyIsInVyaSIsImFkZF9wY3Rfc3RyaW5nIiwiZ2V0X2RlY29kZWRfb3B0Iiwid2l0aF9zY2hlbWUiLCJ3aXRoX2hvc3QiLCJob3N0X3dpdGhfZGVmYXVsdCIsImRlZmF1bHQkMCIsIndpdGhfdXNlcmluZm8iLCJ1c2VyIiwicGFzc3dvcmQiLCJwYXNzIiwid2l0aF9wYXNzd29yZCIsInJlc3VsdCIsIndpdGhfcG9ydCIsIndpdGhfcGF0aCIsIndpdGhfZnJhZ21lbnQiLCJmcmFnIiwidmVyYmF0aW1fcXVlcnkiLCJnZXRfcXVlcnlfcGFyYW0iLCJnZXRfcXVlcnlfcGFyYW0kMCIsIndpdGhfcXVlcnkiLCJxX3MiLCJ3aXRoX3F1ZXJ5JDAiLCJhZGRfcXVlcnlfcGFyYW0iLCJhZGRfcXVlcnlfcGFyYW0kMCIsImFkZF9xdWVyeV9wYXJhbXMiLCJhZGRfcXVlcnlfcGFyYW1zJDAiLCJyZW1vdmVfcXVlcnlfcGFyYW0iLCJ3aXRoX3VyaSIsIndpdGhfcGF0aF9vcHQiLCJvIiwid2l0aF9xdWVyeV9vcHQiLCJ3aXRoJDAiLCJwYXRoX2FuZF9xdWVyeSIsIm1hdGNoIiwibWF0Y2gkMCIsInJlc29sdmUiLCJiYXNlIiwic2NoZW1lJDEiLCJzY2hlbSQwIiwicGF0aF9zdHIiLCJyYnBhdGgiLCJjYW5vbmljYWxpemUiLCJwcCIsInBwZiIsInBwX2h1bSIsInN0cmluZ19vZl9jaGFyIiwic3RyaW5nX29mX2NoYXJfbGlzdCIsImNoYXJzIiwiaXNfZGlnaXQiLCJoZXhfZGlnaXQiLCJoZXhhZGVjaW1hbCIsImNfZG90IiwiY19hdCIsImNfY29sb24iLCJudW0iLCJkZWNfb2N0ZXQiLCJ0aHJlZSIsIm9uZSIsImlwdjRfYWRkcmVzcyIsImFmdGVyX2RvdWJsZV9jb2xvbiIsImRvdWJsZV9jb2xvbiIsImNvdW50IiwiZmlsbGVyX2xlbmd0aCIsImhleF9wYXJ0IiwicGFydCIsInNwbGl0X3dpdGgiLCJ4cyIsInRzIiwienMiLCJmb3JtYXRfYWRkciIsInNlZ21lbnRzIiwic2VnbWVudCIsImJlZm9yZV9kb3VibGVfY29sb24iLCJiZWZvcmUiLCJyZXMiLCJpcHY2IiwibGIiLCJpcCIsInJiIiwiaXB2Nl9hZGRyZXNzIiwicGN0IiwiZGlnaXRzIiwicGN0X2VuY29kZWQiLCJzdWJfZGVsaW1zJDAiLCJ1bnJlc2VydmVkIiwicmVnX25hbWUiLCJkZWNvZGVkIiwicG9ydCQwIiwiYXV0aG9yaXR5IiwiZnJhZ21lbnQkMCIsInVyaV9yZWZlcmVuY2UiLCJ1cmlfcmVmZXJlbmNlJDAiLCJvZl9zdHJpbmciXSwic291cmNlcyI6WyIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvdXJpL3VyaS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW9Ea0JBOzs7Ozs7Ozs7O0tBcUNWQztLQVNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQXREQUMsWUFBWUMsR0FBR0MsSUFBSUM7TTs7cUJBTWpCOzt3QkFMTSxrQkFESUYsR0FBT0U7WUFFbkJDO1FBQ0osV0FIZ0JILEdBQU9FO1FBSXZCLDZCQUp1QkEsSUFBSkQ7b0JBRWZFO2FBY0pDLFlBQVlDLEVBQUVDLElBQUVDO01BQUssS0FBUEQsSUFHSSxPQUhGQztlQUFGRDtXQUFFQyxFQUVFO01BRUEsSUFBTEMsRUFKR0Q7TUFJRSxrQkFKTkYsT0FJQ0csRUFBVTthQUVuQkMsYUFBYUMsRUFBRUosSUFBRUM7VUFBRkksUUFBRUM7TUFBSzthQUFQRCxJQUdILE9BSEtDO2lCQUFGRDthQUFFQyxJQUVKO1FBR1gsSUFESUMsR0FKV0QsT0FJZEUsRUFKY0YsT0FLZixhQUxXRixPQUlWSTtRQUNELFNBQXVDVCxFQUFLLE9BQUxBO1FBQXZDLElBTGFNLFNBQUVDLElBSVhDLEdBQ3lD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RTtTQWhDQTlGO1NBQ0F1RjtTQUtBQztTQW9DQXZJO1NBQ0ErSTtTQW1CQXpGO1NBQ0EyRjtTQTRHQTRCO1NBQ0FFO1lBeUZFK0IsS0E2SEFnQjtNQUNGO2EiLCJzb3VyY2VzQ29udGVudCI6WyIoKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IERhdmlkIFNoZWV0cyA8c2hlZXRzQGFsdW0ubWl0LmVkdT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuXG50eXBlIGNvbXBvbmVudCA9IFtcbiAgfCBgU2NoZW1lXG4gIHwgYEF1dGhvcml0eVxuICB8IGBVc2VyaW5mbyAoKiBzdWJjb21wb25lbnQgb2YgYXV0aG9yaXR5IGluIHNvbWUgc2NoZW1lcyAqKVxuICB8IGBIb3N0ICgqIHN1YmNvbXBvbmVudCBvZiBhdXRob3JpdHkgaW4gc29tZSBzY2hlbWVzICopXG4gIHwgYFBhdGhcbiAgfCBgUXVlcnlcbiAgfCBgUXVlcnlfa2V5XG4gIHwgYFF1ZXJ5X3ZhbHVlXG4gIHwgYEZyYWdtZW50XG4gIHwgYEdlbmVyaWNcbiAgfCBgQ3VzdG9tIG9mIChjb21wb25lbnQgKiBzdHJpbmcgKiBzdHJpbmcpICgqIChjb21wb25lbnQgKiBzYWZlIGNoYXJzICogdW5zYWZlIGNoYXJzKSAqKVxuXVxuXG50eXBlIHBjdF9lbmNvZGVyID0ge1xuICAgIHNjaGVtZTogY29tcG9uZW50O1xuICAgIHVzZXJpbmZvOiBjb21wb25lbnQ7XG4gICAgaG9zdDogY29tcG9uZW50O1xuICAgIHBhdGg6IGNvbXBvbmVudDtcbiAgICBxdWVyeV9rZXk6IGNvbXBvbmVudDtcbiAgICBxdWVyeV92YWx1ZTogY29tcG9uZW50O1xuICAgIGZyYWdtZW50OiBjb21wb25lbnQ7XG4gIH1cblxubGV0IHJlYyBpdGVyX2NvbmNhdCBmbiBzZXAgYnVmID0gZnVuY3Rpb25cbiAgfCBsYXN0OjpbXSAtPiBmbiBidWYgbGFzdFxuICB8IGVsOjpyZXN0IC0+XG4gICAgZm4gYnVmIGVsO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzZXA7XG4gICAgaXRlcl9jb25jYXQgZm4gc2VwIGJ1ZiByZXN0XG4gIHwgW10gLT4gKClcblxubGV0IHJldl9pbnRlcmplY3QgZSBsc3QgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gIC0+IGFjY1xuICAgIHwgeDo6eHMgLT4gYXV4ICh4OjplOjphY2MpIHhzXG4gIGluIG1hdGNoIGxzdCB3aXRoXG4gIHwgW10gIC0+IFtdXG4gIHwgaDo6dCAtPiBhdXggW2hdIHRcblxubGV0IGNvbXBhcmVfb3B0IGMgdCB0JyA9IG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCAgIE5vbmUgICAtPiAwXG4gIHwgU29tZSBfLCBOb25lICAgLT4gMVxuICB8IE5vbmUsICAgU29tZSBfIC0+IC0xXG4gIHwgU29tZSBhLCBTb21lIGIgLT4gYyBhIGJcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgZiB0IHQnID0gbWF0Y2ggdCwgdCcgd2l0aFxuICB8IFtdLCAgICBbXSAgICAtPiAgMFxuICB8IF86Ol8sICBbXSAgICAtPiAgMVxuICB8IFtdLCAgICBfOjpfICAtPiAtMVxuICB8IHg6OnhzLCB5Ojp5cyAtPlxuICAgIG1hdGNoIGYgeCB5IHdpdGggMCAtPiBjb21wYXJlX2xpc3QgZiB4cyB5cyB8IGMgLT4gY1xuXG4oKiogU2FmZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBhbGxvd2VkIGluIGEgVVJJXG4gICogVW5mb3J0dW5hdGVseSwgdGhpcyB2YXJpZXMgZGVwZW5kaW5nIG9uIHdoaWNoIGJpdCBvZiB0aGUgVVJJXG4gICogaXMgYmVpbmcgcGFyc2VkLCBzbyB0aGVyZSBhcmUgbXVsdGlwbGUgdmFyaWFudHMgKGFuZCB0aGlzXG4gICogc2V0IGlzIHByb2JhYmx5IG5vdCBleGhhdXN0aXZlLiBUT0RPOiBjaGVjay5cbiopXG50eXBlIHNhZmVfY2hhcnMgPSBib29sIGFycmF5XG5cbm1vZHVsZSB0eXBlIFNjaGVtZSA9IHNpZ1xuICB2YWwgc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IDogY29tcG9uZW50IC0+IHNhZmVfY2hhcnNcbiAgdmFsIG5vcm1hbGl6ZV9ob3N0IDogc3RyaW5nIG9wdGlvbiAtPiBzdHJpbmcgb3B0aW9uXG4gIHZhbCBjYW5vbmljYWxpemVfcG9ydCA6IGludCBvcHRpb24gLT4gaW50IG9wdGlvblxuICB2YWwgY2Fub25pY2FsaXplX3BhdGggOiBzdHJpbmcgbGlzdCAtPiBzdHJpbmcgbGlzdFxuZW5kXG5cbm1vZHVsZSBHZW5lcmljIDogU2NoZW1lID0gc3RydWN0XG4gIGxldCBzdWJfZGVsaW1zIGEgPVxuICAgIGxldCBzdWJkID0gXCIhJCYnKCkqKyw7PVwiIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3ViZCAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIHN1YmQuW2ldIGluXG4gICAgICBhLihjKSA8LSB0cnVlXG4gICAgZG9uZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnMgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5Lm1ha2UgMjU2IGZhbHNlIGluXG4gICAgbGV0IGFsd2F5c19zYWZlID1cbiAgICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLi1+XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBhbHdheXNfc2FmZSAtIDEgZG9cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIGFsd2F5c19zYWZlLltpXSBpblxuICAgICAgYS4oYykgPC0gdHJ1ZVxuICAgIGRvbmU7XG4gICAgYVxuXG4gIGxldCBwY2hhciA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gc3ViX2RlbGltcyAoQXJyYXkuY29weSBzYWZlX2NoYXJzKSBpblxuICAgIGEuKENoYXIuY29kZSAnOicpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICdAJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3NjaGVtZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzIGluXG4gICAgYS4oQ2hhci5jb2RlICcrJykgPC0gdHJ1ZTtcbiAgICBhXG5cbiAgKCoqIFNhZmUgY2hhcmFjdGVycyBmb3IgdGhlIHBhdGggY29tcG9uZW50IG9mIGEgVVJJICopXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9wYXRoIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBzdWJfZGVsaW1zIChBcnJheS5jb3B5IHBjaGFyKSBpblxuICAgICgqIGRlbGltaXRlcjogbm9uLXNlZ21lbnQgZGVsaW1pdGluZyB1c2VzIHNob3VsZCBiZSBwY3QgZW5jb2RlZCAqKVxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnkgOiBzYWZlX2NoYXJzID1cbiAgICAoKiBUT0RPOiBXaGF0IGFib3V0IHtcIiFcIixcIiRcIixcIixcIn0/IFNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2F2c20vb2NhbWwtdXJpL2NvbW1pdC8xZWYzZjFkZmI0MWJkYjRmMzNmMjIzZmZlMTZlNjJhMzM5NzU2NjFhI2RpZmYtNzQwZjJkZTUzYzllYjM2ZTk2NzBkZGZiZGI5YmE5MTRSMTcxPiAqKVxuICAgIGxldCBhID0gQXJyYXkuY29weSBwY2hhciBpblxuICAgIGEuKENoYXIuY29kZSAnLycpIDwtIHRydWU7XG4gICAgYS4oQ2hhci5jb2RlICc/JykgPC0gdHJ1ZTtcbiAgICAoKiAnJicgaXMgc2FmZSBidXQgd2Ugc2hvdWxkIGVuY29kZSBsaXRlcmFscyB0byBhdm9pZCBhbWJpZ3VpdHlcbiAgICAgICB3aXRoIHRoZSBhbHJlYWR5IHBhcnNlZCBxcyBwYXJhbXMgKilcbiAgICBhLihDaGFyLmNvZGUgJyYnKSA8LSBmYWxzZTtcbiAgICAoKiAnOycgaXMgc2FmZSBidXQgc29tZSBzeXN0ZW1zIHRyZWF0IGl0IGxpa2UgJyYnLiAqKVxuICAgIGEuKENoYXIuY29kZSAnOycpIDwtIGZhbHNlO1xuICAgIGEuKENoYXIuY29kZSAnKycpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5IDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IGluXG4gICAgYS4oQ2hhci5jb2RlICc9JykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeV92YWx1ZSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzX2Zvcl9xdWVyeSBpblxuICAgIGEuKENoYXIuY29kZSAnLCcpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfZnJhZ21lbnQgOiBzYWZlX2NoYXJzID0gc2FmZV9jaGFyc19mb3JfcXVlcnlcblxuICAoKiogU2FmZSBjaGFyYWN0ZXJzIGZvciB0aGUgdXNlcmluZm8gc3ViY29tcG9uZW50IG9mIGEgVVJJLlxuICAgICAgVE9ETzogdGhpcyBuZWVkcyBtb3JlIHJlc2VydmVkIGNoYXJhY3RlcnMgYWRkZWQgKilcbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnMgaW5cbiAgICAoKiBkZWxpbWl0ZXI6IG5vbi1zZWdtZW50IGRlbGltaXRpbmcgdXNlcyBzaG91bGQgYmUgcGN0IGVuY29kZWQgKilcbiAgICBhLihDaGFyLmNvZGUgJzonKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHJlYyBzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgPSBmdW5jdGlvblxuICAgIHwgYFBhdGggLT4gc2FmZV9jaGFyc19mb3JfcGF0aFxuICAgIHwgYFVzZXJpbmZvIC0+IHNhZmVfY2hhcnNfZm9yX3VzZXJpbmZvXG4gICAgfCBgUXVlcnkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlcbiAgICB8IGBRdWVyeV9rZXkgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5XG4gICAgfCBgUXVlcnlfdmFsdWUgLT4gc2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWVcbiAgICB8IGBGcmFnbWVudCAtPiBzYWZlX2NoYXJzX2Zvcl9mcmFnbWVudFxuICAgIHwgYFNjaGVtZSAtPiBzYWZlX2NoYXJzX2Zvcl9zY2hlbWVcbiAgICB8IGBDdXN0b20gKChjb21wb25lbnQgOiBjb21wb25lbnQpLCBzYWZlLCB1bnNhZmUpIC0+XG4gICAgICAgbGV0IHNhZmVfY2hhcnMgPSBBcnJheS5jb3B5IChzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQgY29tcG9uZW50KSBpblxuICAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHNhZmUgLSAxIGRvXG4gICAgICAgICBsZXQgYyA9IENoYXIuY29kZSBzYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gdHJ1ZVxuICAgICAgIGRvbmU7XG4gICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggdW5zYWZlIC0gMSBkb1xuICAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgdW5zYWZlLltpXSBpblxuICAgICAgICAgc2FmZV9jaGFycy4oYykgPC0gZmFsc2VcbiAgICAgICBkb25lO1xuICAgICAgIHNhZmVfY2hhcnNcbiAgICB8IGBHZW5lcmljXG4gICAgfCBfIC0+IHNhZmVfY2hhcnNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHNvID0gaHNvXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0IHBvcnQgPSBwb3J0XG4gIGxldCBjYW5vbmljYWxpemVfcGF0aCBwYXRoID0gcGF0aFxuZW5kXG5cbm1vZHVsZSBIdHRwIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCA9IGZ1bmN0aW9uXG4gICAgfCBTb21lIGhzIC0+IFNvbWUgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHMpXG4gICAgfCBOb25lIC0+IE5vbmVcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDgwIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIHhcblxuICBsZXQgY2Fub25pY2FsaXplX3BhdGggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW1wiL1wiXVxuICAgIHwgeCAgLT4geFxuZW5kXG5cbm1vZHVsZSBIdHRwcyA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEh0dHBcblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIDQ0MyAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSB4XG5lbmRcblxubW9kdWxlIEZpbGUgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0ID0gZnVuY3Rpb25cbiAgICB8IFNvbWUgaHMgLT5cbiAgICAgIGxldCBocyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHMgaW5cbiAgICAgIGlmIGhzPVwibG9jYWxob3N0XCIgdGhlbiBTb21lIFwiXCIgZWxzZSBTb21lIGhzXG4gICAgfCBOb25lIC0+IE5vbmVcbmVuZFxuXG5tb2R1bGUgVXJuIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG5lbmRcblxubGV0IG1vZHVsZV9vZl9zY2hlbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgcyAtPiBiZWdpbiBtYXRjaCBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgd2l0aFxuICAgICAgfCBcImh0dHBcIiAtPiAobW9kdWxlIEh0dHAgOiBTY2hlbWUpXG4gICAgICB8IFwiaHR0cHNcIiAgLT4gKG1vZHVsZSBIdHRwcyA6IFNjaGVtZSlcbiAgICAgIHwgXCJmaWxlXCIgLT4gKG1vZHVsZSBGaWxlIDogU2NoZW1lKVxuICAgICAgfCBcInVyblwiICAtPiAobW9kdWxlIFVybiA6IFNjaGVtZSlcbiAgICAgIHwgXyAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG4gICAgZW5kXG4gIHwgTm9uZSAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG5cbigqKiBQb3J0aW9ucyBvZiB0aGUgVVJMIG11c3QgYmUgY29udmVydGVkIHRvLWFuZC1mcm9tIHBlcmNlbnQtZW5jb2RpbmdcbiAgKiBhbmQgdGhpcyByZWFsbHksIHJlYWxseSBzaG91bGRuJ3QgYmUgbWl4ZWQgdXAuIFNvIHRoaXMgUGN0IG1vZHVsZVxuICAqIGRlZmluZXMgYWJzdHJhY3QgUGN0LmVuY29kZWQgYW5kIFBjdC5kZWNvZGVkIHR5cGVzIHdoaWNoIHNldHMgdGhlXG4gICogc3RhdGUgb2YgdGhlIHVuZGVybHlpbmcgc3RyaW5nLiAgVGhlcmUgYXJlIGZ1bmN0aW9ucyB0byBcImNhc3RcIiB0b1xuICAqIGFuZCBmcm9tIHRoZXNlIGFuZCBub3JtYWwgc3RyaW5ncywgYW5kIHRoaXMgcHJvbW90ZXMgYSBiaXQgb2ZcbiAgKiBpbnRlcm5hbCBzYWZldHkuICBUaGVzZSB0eXBlcyBhcmUgbm90IGV4cG9zZWQgdG8gdGhlIGV4dGVybmFsXG4gICogaW50ZXJmYWNlLCBhcyBjYXN0aW5nIHRvLWFuZC1mcm9tIGlzIHF1aXRlIGEgYml0IG9mIGhhc3NsZSBhbmRcbiAgKiBwcm9iYWJseSBub3QgYSBsb3Qgb2YgdXNlIHRvIHRoZSBhdmVyYWdlIGNvbnN1bWVyIG9mIHRoaXMgbGlicmFyeVxuKilcbm1vZHVsZSBQY3QgOiBzaWdcbiAgdHlwZSBlbmNvZGVkXG4gIHR5cGUgZGVjb2RlZFxuXG4gIHZhbCBlbmNvZGUgOiA/c2NoZW1lOnN0cmluZyAtPiA/Y29tcG9uZW50OmNvbXBvbmVudCAtPiBkZWNvZGVkIC0+IGVuY29kZWRcbiAgdmFsIGRlY29kZSA6IGVuY29kZWQgLT4gZGVjb2RlZFxuXG4gICgqIFRoZSBlbXB0eSBkZWNvZGVkIHN0cmluZyAqKVxuICB2YWwgZW1wdHlfZGVjb2RlZCA6IGRlY29kZWRcbiAgKCogSWRlbnRpdHkgZnVuY3Rpb25zIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSBjYXN0IHdoZW4gdXNpbmcgdGhlbSBiZWxvdyAqKVxuICB2YWwgY2FzdF9lbmNvZGVkIDogc3RyaW5nIC0+IGVuY29kZWRcbiAgdmFsIGNhc3RfZGVjb2RlZCA6IHN0cmluZyAtPiBkZWNvZGVkXG4gIHZhbCB1bmNhc3RfZW5jb2RlZCA6IGVuY29kZWQgLT4gc3RyaW5nXG4gIHZhbCB1bmNhc3RfZGVjb2RlZCA6IGRlY29kZWQgLT4gc3RyaW5nXG4gICgqIExpZnQgSE9GcyBmb3IgbWFwcyBvdmVyIGVuY29kaW5ncywgZGVjb2RpbmdzLCBhbmQgc3RyaW5ncyAqKVxuICB2YWwgbGlmdF9lbmNvZGVkIDogKGVuY29kZWQgLT4gZW5jb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgbGlmdF9kZWNvZGVkIDogKGRlY29kZWQgLT4gZGVjb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgdW5saWZ0X2VuY29kZWQgOiAoc3RyaW5nIC0+IHN0cmluZykgLT4gZW5jb2RlZCAtPiBlbmNvZGVkXG4gIHZhbCB1bmxpZnRfZGVjb2RlZCA6IChzdHJpbmcgLT4gc3RyaW5nKSAtPiBkZWNvZGVkIC0+IGRlY29kZWRcbiAgdmFsIHVubGlmdF9kZWNvZGVkMiA6IChzdHJpbmcgLT4gc3RyaW5nIC0+ICdhKSAtPiBkZWNvZGVkIC0+IGRlY29kZWQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlIGVuY29kZWQgPSBzdHJpbmdcbiAgdHlwZSBkZWNvZGVkID0gc3RyaW5nXG4gIGxldCBjYXN0X2VuY29kZWQgeCA9IHhcbiAgbGV0IGNhc3RfZGVjb2RlZCB4ID0geFxuICBsZXQgZW1wdHlfZGVjb2RlZCA9IFwiXCJcbiAgbGV0IHVuY2FzdF9kZWNvZGVkIHggPSB4XG4gIGxldCB1bmNhc3RfZW5jb2RlZCB4ID0geFxuXG4gIGxldCBsaWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IGxpZnRfZGVjb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9kZWNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZGVjb2RlZDIgZiA9IGZcblxuICAoKiogU2NhbiBmb3IgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgcmVwbGFjZSB0aGVtIHdpdGhcbiAgICAgIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50cy5cbiAgICAgIEByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBlbmNvZGUgP3NjaGVtZSA/KGNvbXBvbmVudD1gUGF0aCkgYiA9XG4gICAgbGV0IG1vZHVsZSBTY2hlbWUgPSAodmFsIChtb2R1bGVfb2Zfc2NoZW1lIHNjaGVtZSkgOiBTY2hlbWUpIGluXG4gICAgbGV0IHNhZmVfY2hhcnMgPSBTY2hlbWUuc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IGNvbXBvbmVudCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBjID0gQ2hhci5jb2RlIGIuW2N1cl0gaW5cbiAgICAgICAgaWYgc2FmZV9jaGFycy4oYykgdGhlblxuICAgICAgICAgIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgaWYgY3VyID4gc3RhcnQgdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFByaW50Zi5zcHJpbnRmIFwiJSUlMDJYXCIgYyk7XG4gICAgICAgICAgc2NhbiAoY3VyKzEpIChjdXIrMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBpblxuICAgIHNjYW4gMCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgaW50X29mX2hleF9jaGFyIGMgPVxuICAgIGxldCBjID0gaW50X29mX2NoYXIgKENoYXIudXBwZXJjYXNlX2FzY2lpIGMpIC0gNDggaW5cbiAgICBpZiBjID4gOVxuICAgIHRoZW4gaWYgYyA+IDE2ICYmIGMgPCAyM1xuICAgICAgdGhlbiBjIC0gN1xuICAgICAgZWxzZSBmYWlsd2l0aCBcImludF9vZl9oZXhfY2hhclwiXG4gICAgZWxzZSBpZiBjID49IDBcbiAgICB0aGVuIGNcbiAgICBlbHNlIGZhaWx3aXRoIFwiaW50X29mX2hleF9jaGFyXCJcblxuICAoKiogU2NhbiBmb3IgcGVyY2VudC1lbmNvZGluZyBhbmQgY29udmVydCB0aGVtIGludG8gQVNDSUkuXG4gICAgICBAcmV0dXJuIGEgcGVyY2VudC1kZWNvZGVkIHN0cmluZyAqKVxuICBsZXQgZGVjb2RlIGIgPVxuICAgICgqIFRPRE86IFNob3VsZCBib3RoIHN0cmljdCBhbmQgbm9uLXN0cmljdCB2ZXJzaW9ucyBiZSBleHBvc2VkPyAqKVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KVxuICAgICAgZWxzZSBpZiBiLltjdXJdID0gJyUnIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICAgIGxldCBjdXIgPSBjdXIgKyAxIGluXG4gICAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICclJ1xuICAgICAgICBlbHNlIG1hdGNoIGludF9vZl9oZXhfY2hhciBiLltjdXJdIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgIHNjYW4gY3VyIGN1clxuICAgICAgICB8IGhpZ2hiaXRzIC0+IGJlZ2luXG4gICAgICAgICAgbGV0IGN1ciA9IGN1ciArIDEgaW5cbiAgICAgICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBiLltjdXItMV1cbiAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgbGV0IHN0YXJ0X2F0ID1cbiAgICAgICAgICAgICAgbWF0Y2ggaW50X29mX2hleF9jaGFyIGIuW2N1cl0gd2l0aFxuICAgICAgICAgICAgICB8IGxvd2JpdHMgLT5cbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIChDaGFyLmNociAoaGlnaGJpdHMgbHNsIDQgKyBsb3diaXRzKSk7XG4gICAgICAgICAgICAgICAgY3VyKzFcbiAgICAgICAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYi5bY3VyLTFdO1xuICAgICAgICAgICAgICAgIGN1clxuICAgICAgICAgICAgaW4gc2NhbiBzdGFydF9hdCBzdGFydF9hdFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgIGluXG4gICAgc2NhbiAwIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuZW5kXG5cbigqIFBlcmNlbnQgZW5jb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2VuY29kZSA/c2NoZW1lID8oY29tcG9uZW50PWBQYXRoKSBzID1cbiAgUGN0Lih1bmNhc3RfZW5jb2RlZCAoZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCAoY2FzdF9kZWNvZGVkIHMpKSlcblxubGV0IHBjdF9lbmNvZGVyXG4gICAgICA/KHNjaGVtZT1gU2NoZW1lKVxuICAgICAgPyh1c2VyaW5mbz1gVXNlcmluZm8pXG4gICAgICA/KGhvc3Q9YEhvc3QpXG4gICAgICA/KHBhdGg9YFBhdGgpXG4gICAgICA/KHF1ZXJ5X2tleT1gUXVlcnlfa2V5KVxuICAgICAgPyhxdWVyeV92YWx1ZT1gUXVlcnlfdmFsdWUpXG4gICAgICA/KGZyYWdtZW50PWBGcmFnbWVudClcbiAgICAgICgpID1cbiAgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwYXRoOyBxdWVyeV9rZXk7IHF1ZXJ5X3ZhbHVlOyBmcmFnbWVudCB9XG5cbigqIFBlcmNlbnQgZGVjb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2RlY29kZSBzID0gUGN0Lih1bmNhc3RfZGVjb2RlZCAoZGVjb2RlIChjYXN0X2VuY29kZWQgcykpKVxuXG4oKiBVc2VyaW5mbyBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGFuIGlkICogY3JlZGVudGlhbCBwYWlyICopXG5tb2R1bGUgVXNlcmluZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nICogc3RyaW5nIG9wdGlvblxuXG4gIGxldCBjb21wYXJlICh1LHApICh1JyxwJykgPVxuICAgIG1hdGNoIFN0cmluZy5jb21wYXJlIHUgdScgd2l0aFxuICAgIHwgMCAtPiBjb21wYXJlX29wdCBTdHJpbmcuY29tcGFyZSBwIHAnXG4gICAgfCBjIC0+IGNcblxuICBsZXQgdXNlcmluZm9fb2ZfZW5jb2RlZCB1cyA9XG4gICAgbWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5tYXg6MiB+b246JzonIHVzIHdpdGhcbiAgICB8IFtdIC0+IChcIlwiLE5vbmUpXG4gICAgfCBbdV0gLT4gKHBjdF9kZWNvZGUgdSxOb25lKVxuICAgIHwgdTo6cDo6XyAtPiAocGN0X2RlY29kZSB1LFNvbWUgKHBjdF9kZWNvZGUgcCkpXG5cbiAgbGV0IGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50ICh1LHBvKSA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy4oXG4gICAgICAxICsgKGxlbmd0aCB1KSArIChtYXRjaCBwbyB3aXRoIE5vbmUgLT4gMCB8IFNvbWUgcCAtPiBsZW5ndGggcCkpXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHUpO1xuICAgIGJlZ2luIG1hdGNoIHBvIHdpdGggTm9uZSAtPiAoKTtcbiAgICB8IFNvbWUgcCAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOic7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHApXG4gICAgZW5kO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5lbmRcblxubGV0IHVzZXJpbmZvX29mX2VuY29kZWQgPSBVc2VyaW5mby51c2VyaW5mb19vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQgPSBVc2VyaW5mby5lbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudFxuXG4oKiBQYXRoIHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYSBsaXN0IG9mIHBhdGggdG9rZW5zICopXG5tb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAoKiBJbnZhcmlhbnQ6IGV2ZXJ5IGVsZW1lbnQgaXMgbm9uLXplcm8sIHNsYXNoZXMgKC8pIG9ubHkgb2NjdXIgYWxvbmUuICopXG4gICgqIFllcywgaXQncyBiZXR0ZXIgdGhpcyB3YXkuIFRoaXMgbWVhbnMgeW91IGNhbiByZXRhaW4gc2VwYXJhdG9yXG4gICAgIGNvbnRleHQgaW4gcmVjdXJzaW9uIChlLmcuIHJlbW92ZV9kb3Rfc2VnbWVudHMgZm9yIHJlbGF0aXZlIHJlc29sdXRpb24pLiAqKVxuXG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0XG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlX2xpc3QgU3RyaW5nLmNvbXBhcmVcblxuICAoKiBNYWtlIGEgcGF0aCB0b2tlbiBsaXN0IGZyb20gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBwYXRoX29mX2VuY29kZWQgcHMgPVxuICAgIGxldCB0b2tsID0gU3RyaW5nZXh0LmZ1bGxfc3BsaXQgcHMgfm9uOicvJyBpblxuICAgIExpc3QubWFwIHBjdF9kZWNvZGUgdG9rbFxuXG4gICgqIFN1YnJvdXRpbmUgZm9yIHJlc29sdmUgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuND4gKilcbiAgbGV0IHJlbW92ZV9kb3Rfc2VnbWVudHMgcCA9XG4gICAgbGV0IHJldnAgPSBMaXN0LnJldiBwIGluXG4gICAgbGV0IHJlYyBsb29wIGFzY2Vuc2lvbiBvdXRwID0gZnVuY3Rpb25cbiAgICAgIHwgXCIvXCI6OlwiLi5cIjo6ciB8IFwiLi5cIjo6ciAtPiBsb29wIChhc2NlbnNpb24gKyAxKSBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OlwiLlwiOjpyICB8IFwiLlwiOjpyICAtPiBsb29wIGFzY2Vuc2lvbiBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OltdIHwgW10gd2hlbiBMaXN0LihsZW5ndGggcCA+IDAgJiYgaGQgcCA9IFwiL1wiKSAtPiBcIi9cIjo6b3V0cFxuICAgICAgfCBbXSB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gTGlzdC5yZXZfYXBwZW5kXG4gICAgICAgIChcIi9cIjo6KHJldl9pbnRlcmplY3QgXCIvXCIgQXJyYXkuKHRvX2xpc3QgKG1ha2UgYXNjZW5zaW9uIFwiLi5cIikpKSkgb3V0cFxuICAgICAgfCBbXSAtPiBMaXN0LihpZiBsZW5ndGggb3V0cCA+IDAgJiYgaGQgb3V0cCA9IFwiL1wiIHRoZW4gdGwgb3V0cCBlbHNlIG91dHApXG4gICAgICB8IFwiL1wiOjpcIi9cIjo6ciB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gbG9vcCAoYXNjZW5zaW9uIC0gMSkgb3V0cCAoXCIvXCI6OnIpXG4gICAgICB8IFwiL1wiOjpfOjpyIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBsb29wIChhc2NlbnNpb24gLSAxKSBvdXRwIHJcbiAgICAgIHwgczo6ciAtPiBsb29wIDAgKHM6Om91dHApIHJcbiAgICBpbiBsb29wIDAgW10gcmV2cFxuXG4gIGxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50IHAgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGMgdG9rIC0+IFN0cmluZy5sZW5ndGggdG9rICsgYykgMCBwIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgaXRlcl9jb25jYXQgKGZ1biBidWYgLT4gZnVuY3Rpb25cbiAgICB8IFwiL1wiIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nXG4gICAgfCBzZWcgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCBzZWcpXG4gICAgKSBcIlwiIGJ1ZiBwO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5cbiAgKCogU3Vicm91dGluZSBmb3IgcmVzb2x2ZSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi4zPiAqKVxuICBsZXQgbWVyZ2UgYmhvc3QgYnBhdGggcmVscGF0aCA9XG4gICAgbWF0Y2ggYmhvc3QsIExpc3QucmV2IGJwYXRoIHdpdGhcbiAgICB8IFNvbWUgXywgW10gLT4gXCIvXCI6OnJlbHBhdGhcbiAgICB8IF8sIChcIi9cIjo6cmJwYXRoIHwgXzo6XCIvXCI6OnJicGF0aCkgLT4gTGlzdC5yZXZfYXBwZW5kIChcIi9cIjo6cmJwYXRoKSByZWxwYXRoXG4gICAgfCBfLCBfIC0+IHJlbHBhdGhcbmVuZFxuXG5sZXQgcGF0aF9vZl9lbmNvZGVkID0gUGF0aC5wYXRoX29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50ID0gUGF0aC5lbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50XG5cbigqIFF1ZXJ5IHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYW4gYXNzb2MgbGlzdCBvZiBrZXkvdmFsdWVzICopXG5tb2R1bGUgUXVlcnkgPSBzdHJ1Y3RcblxuICB0eXBlIGt2ID0gKHN0cmluZyAqIHN0cmluZyBsaXN0KSBsaXN0XG5cbiAgdHlwZSB0ID1cbiAgICB8IEtWIG9mIGt2XG4gICAgfCBSYXcgb2Ygc3RyaW5nIG9wdGlvbiAqIGt2IExhenkudFxuXG4gIGxldCBjb21wYXJlIHggeSA9IG1hdGNoIHgsIHkgd2l0aFxuICAgIHwgS1Yga3ZsLCBLViBrdmwnXG4gICAgfCBSYXcgKF8sIGxhenkga3ZsKSwgS1Yga3ZsJ1xuICAgIHwgS1Yga3ZsLCBSYXcgKF8sIGxhenkga3ZsJykgLT5cbiAgICAgIGNvbXBhcmVfbGlzdCAoZnVuIChrLHZsKSAoaycsdmwnKSAtPlxuICAgICAgICBtYXRjaCBTdHJpbmcuY29tcGFyZSBrIGsnIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbGlzdCBTdHJpbmcuY29tcGFyZSB2bCB2bCdcbiAgICAgICAgfCBjIC0+IGNcbiAgICAgICkga3ZsIGt2bCdcbiAgICB8IFJhdyAocmF3LF8pLCBSYXcgKHJhdycsXykgLT4gY29tcGFyZV9vcHQgU3RyaW5nLmNvbXBhcmUgcmF3IHJhdydcblxuICBsZXQgZmluZCBxIGsgPSB0cnkgU29tZSAoTGlzdC5hc3NvYyBrIHEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuICBsZXQgc3BsaXRfcXVlcnkgcXMgPVxuICAgIGxldCBlbHMgPSBTdHJpbmdleHQuc3BsaXQgfm9uOicmJyBxcyBpblxuICAgICgqIFJlcGxhY2UgYSArIGluIGEgcXVlcnkgc3RyaW5nIHdpdGggYSBzcGFjZSBpbi1wbGFjZSAqKVxuICAgIGxldCBwbHVzX3RvX3NwYWNlIHMgPVxuICAgICAgbGV0IHMgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIHMgaW5cbiAgICAgIGZvciBpID0gMCB0byBCeXRlcy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgaWYgQnl0ZXMuZ2V0IHMgaSA9ICcrJyB0aGVuIEJ5dGVzLnNldCBzIGkgJyAnXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgKGs6OnY6Ol8pOjp0bCAtPlxuICAgICAgICBsZXQgbiA9IHBsdXNfdG9fc3BhY2UgayxcbiAgICAgICAgICAgICAgICAobWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5vbjonLCcgKHBsdXNfdG9fc3BhY2Ugdikgd2l0aFxuICAgICAgICAgICAgICAgICB8IFtdIC0+IFtcIlwiXSB8IGwgLT4gbCkgaW5cbiAgICAgICAgbG9vcCAobjo6YWNjKSB0bFxuICAgICAgfCBba106OnRsIC0+XG4gICAgICAgIGxldCBuID0gcGx1c190b19zcGFjZSBrLCBbXSBpblxuICAgICAgICBsb29wIChuOjphY2MpIHRsXG4gICAgICB8IFtdOjp0bCAtPiBsb29wICgoXCJcIiwgW10pOjphY2MpIHRsXG4gICAgICB8IFtdIC0+IGFjY1xuICAgIGluXG4gICAgbWF0Y2ggZWxzIHdpdGhcbiAgICB8IFtdICAtPiBbXCJcIixbXV1cbiAgICB8IGVscyAtPiBsb29wIFtdXG4gICAgICAoTGlzdC5yZXZfbWFwIChmdW4gZWwgLT4gU3RyaW5nZXh0LnNwbGl0IH5vbjonPScgZWwgfm1heDoyKSBlbHMpXG5cbiAgKCogTWFrZSBhIHF1ZXJ5IHR1cGxlIGxpc3QgZnJvbSBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IHF1ZXJ5X29mX2VuY29kZWQgcXMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChrLCB2KSAtPiAocGN0X2RlY29kZSBrLCBMaXN0Lm1hcCBwY3RfZGVjb2RlIHYpKVxuICAgICAgKHNwbGl0X3F1ZXJ5IHFzKVxuXG4gICgqIEFzc2VtYmxlIGEgcXVlcnkgc3RyaW5nIHN1aXRhYmxlIGZvciBwdXR0aW5nIGludG8gYSBVUkkuXG4gICAqIFR1cGxlIGlucHV0cyBhcmUgcGVyY2VudCBkZWNvZGVkIGFuZCB3aWxsIGJlIGVuY29kZWQgYnlcbiAgICogdGhpcyBmdW5jdGlvbi5cbiAgKilcbiAgbGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBhIChrLHYpIC0+XG4gICAgICAgIGEgKyAoU3RyaW5nLmxlbmd0aCBrKVxuICAgICAgICArIChMaXN0LmZvbGRfbGVmdCAoZnVuIGEgcyAtPiBhKyhTdHJpbmcubGVuZ3RoIHMpKzEpIDAgdikgKyAyKSAoLTEpIGwgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiAoayx2KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnF1ZXJ5X2tleSBrKTtcbiAgICAgICAgaWYgdiA8PiBbXSB0aGVuIChcbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc9JztcbiAgICAgICAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiBzIC0+XG4gICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgICAgICAgICAgIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5xdWVyeV92YWx1ZSBzKVxuICAgICAgICAgICAgKSBcIixcIiBidWYgdilcbiAgICAgICkgXCImXCIgYnVmIGw7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4gIGxldCBvZl9yYXcgcXMgPVxuICAgIGxldCBsYXp5X3F1ZXJ5ID0gTGF6eS5mcm9tX2Z1biAoZnVuICgpIC0+IHF1ZXJ5X29mX2VuY29kZWQgcXMpIGluXG4gICAgUmF3IChTb21lIHFzLCBsYXp5X3F1ZXJ5KVxuXG4gIGxldCBrdiA9IGZ1bmN0aW9uIFJhdyAoXywgbGF6eSBrdikgfCBLViBrdiAtPiBrdlxuZW5kXG5cbmxldCBxdWVyeV9vZl9lbmNvZGVkID0gUXVlcnkucXVlcnlfb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA9IFF1ZXJ5LmVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZVxuXG4oKiBUeXBlIG9mIHRoZSBVUkksIHdpdGggbW9zdCBiaXRzIGJlaW5nIG9wdGlvbmFsICopXG50eXBlIHQgPSB7XG4gIHNjaGVtZTogUGN0LmRlY29kZWQgb3B0aW9uO1xuICB1c2VyaW5mbzogVXNlcmluZm8udCBvcHRpb247XG4gIGhvc3Q6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbiAgcG9ydDogaW50IG9wdGlvbjtcbiAgcGF0aDogUGF0aC50O1xuICBxdWVyeTogUXVlcnkudDtcbiAgZnJhZ21lbnQ6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbn1cblxubGV0IGVtcHR5ID0ge1xuICBzY2hlbWUgPSBOb25lO1xuICB1c2VyaW5mbyA9IE5vbmU7XG4gIGhvc3QgPSBOb25lO1xuICBwb3J0ID0gTm9uZTtcbiAgcGF0aCA9IFtdO1xuICBxdWVyeSA9IFF1ZXJ5LlJhdyAoTm9uZSwgTGF6eS5mcm9tX3ZhbCBbXSk7XG4gIGZyYWdtZW50ID0gTm9uZTtcbn1cblxubGV0IGNvbXBhcmVfZGVjb2RlZCA9IFBjdC51bmxpZnRfZGVjb2RlZDIgU3RyaW5nLmNvbXBhcmVcbmxldCBjb21wYXJlX2RlY29kZWRfb3B0ID0gY29tcGFyZV9vcHQgY29tcGFyZV9kZWNvZGVkXG5sZXQgY29tcGFyZSB0IHQnID1cbiAgKG1hdGNoIGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5ob3N0IHQnLmhvc3Qgd2l0aFxuICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5zY2hlbWUgdCcuc2NoZW1lIHdpdGhcbiAgICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfb3B0IChmdW4gcCBwJyAtPlxuICAgICAgaWYgcCA8IHAnIHRoZW4gLTEgZWxzZSBpZiBwID4gcCcgdGhlbiAxIGVsc2UgMFxuICAgICkgdC5wb3J0IHQnLnBvcnQgd2l0aFxuICAgICAgfCAwIC0+IChtYXRjaCBjb21wYXJlX29wdCBVc2VyaW5mby5jb21wYXJlIHQudXNlcmluZm8gdCcudXNlcmluZm8gd2l0aFxuICAgICAgICB8IDAgLT4gKG1hdGNoIFBhdGguY29tcGFyZSB0LnBhdGggdCcucGF0aCB3aXRoXG4gICAgICAgICAgfCAwIC0+IChtYXRjaCBRdWVyeS5jb21wYXJlIHQucXVlcnkgdCcucXVlcnkgd2l0aFxuICAgICAgICAgICAgfCAwIC0+IGNvbXBhcmVfZGVjb2RlZF9vcHQgdC5mcmFnbWVudCB0Jy5mcmFnbWVudFxuICAgICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgICAgfCBjIC0+IGMpXG4gICAgICAgIHwgYyAtPiBjKVxuICAgICAgfCBjIC0+IGMpXG4gICAgfCBjIC0+IGMpXG4gIHwgYyAtPiBjKVxuXG5sZXQgZXF1YWwgdCB0JyA9IGNvbXBhcmUgdCB0JyA9IDBcblxubGV0IHVuY2FzdF9vcHQgPSBmdW5jdGlvblxuICB8IFNvbWUgaCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgaClcbiAgfCBOb25lIC0+IE5vbmVcblxubGV0IGNhc3Rfb3B0ID0gZnVuY3Rpb25cbiAgfCBTb21lIGggLT4gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCBoKVxuICB8IE5vbmUgLT4gTm9uZVxuXG5sZXQgbm9ybWFsaXplIHNjaGVtIHVyaSA9XG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHNjaGVtKSkgOiBTY2hlbWUpIGluXG4gIGxldCBkb2IgZiA9IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT4gU29tZSAoUGN0LnVubGlmdF9kZWNvZGVkIGYgeClcbiAgICB8IE5vbmUgLT4gTm9uZVxuICBpbiB7dXJpIHdpdGhcbiAgICAgIHNjaGVtZT1kb2IgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSB1cmkuc2NoZW1lO1xuICAgICAgaG9zdD1jYXN0X29wdCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0ICh1bmNhc3Rfb3B0IHVyaS5ob3N0KSlcbiAgICAgfVxuXG4oKiBNYWtlIGEgVVJJIHJlY29yZC4gVGhpcyBpcyBhIGJpdCBtb3JlIGluZWZmaWNpZW50IHRoYW4gaXQgbmVlZHMgdG8gYmUgZHVlIHRvIHRoZVxuICogY2FzdGluZy91bmNhc3RpbmcgKHdoaWNoIGlzbid0IGZ1bGx5IGlkZW50aXR5IGR1ZSB0byB0aGUgb3B0aW9uIGJveCksIGJ1dCBpdCBpc1xuICogbm8gYmlnIGRlYWwgZm9yIG5vdy5cbiopXG5sZXQgbWFrZSA/c2NoZW1lID91c2VyaW5mbyA/aG9zdCA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50ICgpID1cbiAgbGV0IGRlY29kZSA9IGZ1bmN0aW9uXG4gICAgfFNvbWUgeCAtPiBTb21lIChQY3QuY2FzdF9kZWNvZGVkIHgpIHxOb25lIC0+IE5vbmUgaW5cbiAgbGV0IGhvc3QgPSBtYXRjaCB1c2VyaW5mbywgaG9zdCwgcG9ydCB3aXRoXG4gICAgfCBfLCBTb21lIF8sIF8gfCBOb25lLCBOb25lLCBOb25lIC0+IGhvc3RcbiAgICB8IFNvbWUgXywgTm9uZSwgXyB8IF8sIE5vbmUsIFNvbWUgXyAtPiBTb21lIFwiXCJcbiAgaW5cbiAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSkgaW5cbiAgbGV0IHBhdGggPSBtYXRjaCBwYXRoIHdpdGhcbiAgICB8Tm9uZSAtPiBbXSB8IFNvbWUgcCAtPlxuICAgICAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcCBpblxuICAgICAgbWF0Y2ggaG9zdCwgcGF0aCB3aXRoXG4gICAgICB8IE5vbmUsIF8gfCBTb21lIF8sIFwiL1wiOjpfIHwgU29tZSBfLCBbXSAtPiBwYXRoXG4gICAgICB8IFNvbWUgXywgXyAgLT4gXCIvXCI6OnBhdGhcbiAgaW5cbiAgbGV0IHF1ZXJ5ID0gbWF0Y2ggcXVlcnkgd2l0aFxuICAgIHwgTm9uZSAtPiBRdWVyeS5LViBbXVxuICAgIHwgU29tZSBwIC0+IFF1ZXJ5LktWIHBcbiAgaW5cbiAgbGV0IHNjaGVtZSA9IGRlY29kZSBzY2hlbWUgaW5cbiAgbm9ybWFsaXplIHNjaGVtZVxuICAgIHsgc2NoZW1lOyB1c2VyaW5mbztcbiAgICAgIGhvc3Q9ZGVjb2RlIGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudD1kZWNvZGUgZnJhZ21lbnQgfVxuXG4oKiogQ29udmVydCBhIFVSSSBzdHJ1Y3R1cmUgaW50byBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmdcbiAgICA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMz5cbiopXG5sZXQgdG9fc3RyaW5nID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9XG4gIGxldCBzY2hlbWUgPSBtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgcylcbiAgICB8IE5vbmUgLT4gTm9uZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMjggaW5cbiAgKCogUGVyY2VudCBlbmNvZGUgYSBkZWNvZGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBidWZmZXIgKilcbiAgbGV0IGFkZF9wY3Rfc3RyaW5nID8oY29tcG9uZW50PWBQYXRoKSB4ID1cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFBjdC51bmNhc3RfZW5jb2RlZCAoUGN0LmVuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgeCkpXG4gIGluXG4gIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgIHxOb25lIC0+ICgpXG4gICB8U29tZSB4IC0+XG4gICAgIGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuc2NoZW1lIHg7XG4gICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonXG4gICk7XG4gICgqIFVSSSBoYXMgYSBob3N0IGlmIGFueSBob3N0LXJlbGF0ZWQgY29tcG9uZW50IGlzIHNldC4gRGVmYXVsdHMgdG8gXCJcIi4gKilcbiAgaWYgKG1hdGNoIHVyaS51c2VyaW5mbywgdXJpLmhvc3QsIHVyaS5wb3J0IHdpdGhcbiAgfCBTb21lIF8sIF8sIF8gfCBfLCBTb21lIF8sIF8gfCBfLCBfLCBTb21lIF8gLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpXG4gIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLy9cIjtcbiAgKG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIHVzZXJpbmZvIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mbykpO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ0AnXG4gICk7XG4gIChtYXRjaCB1cmkuaG9zdCB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIGhvc3QgLT5cbiAgICBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLmhvc3QgaG9zdDtcbiAgKTtcbiAgKG1hdGNoIHVyaS5wb3J0IHdpdGhcbiAgfE5vbmUgLT4gKClcbiAgfFNvbWUgcG9ydCAtPlxuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBwb3J0KVxuICApO1xuICAobWF0Y2ggdXJpLnBhdGggd2l0aCAoKiBIYW5kbGUgcmVsYXRpdmUgcGF0aHMgY29ycmVjdGx5ICopXG4gIHwgW10gLT4gKClcbiAgfCBcIi9cIjo6XyAtPlxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoUGN0LnVuY2FzdF9lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKSlcbiAgfCBmaXJzdF9zZWdtZW50OjpfIC0+XG4gICAgKG1hdGNoIHVyaS5ob3N0IHdpdGhcbiAgICAgfCBTb21lIF8gLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLydcbiAgICAgfCBOb25lIC0+XG4gICAgICAgKCogZW5zdXJlIHJvdW5kdHJpcCBieSBmb3JjaW5nIHJlbGF0aXZlIHBhdGggaW50ZXJwcmV0YXRpb24gbm90IHNjaGVtZSAqKVxuICAgICAgIG1hdGNoIFN0cmluZ2V4dC5maW5kX2Zyb20gZmlyc3Rfc2VnbWVudCB+cGF0dGVybjpcIjpcIiB3aXRoXG4gICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgfCBTb21lIF8gLT4gbWF0Y2ggc2NoZW1lIHdpdGhcbiAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgICB8IE5vbmUgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLi9cIlxuICAgICk7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpKVxuICApO1xuICBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICB8IFJhdyAoTm9uZSxfKSB8IEtWIFtdIC0+ICgpXG4gICAgfCBSYXcgKF8sbGF6eSBxKSB8IEtWIHEgLT4gKCogbm9ybWFsaXplIGUuZy4gcGVyY2VudCBjYXBpdGFsaXphdGlvbiAqKVxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSB+cGN0X2VuY29kZXIgcSlcbiAgKTtcbiAgKG1hdGNoIHVyaS5mcmFnbWVudCB3aXRoXG4gICB8Tm9uZSAtPiAoKVxuICAgfFNvbWUgZiAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcjJzsgYWRkX3BjdF9zdHJpbmcgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5mcmFnbWVudCBmXG4gICk7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxuKCogVmFyaW91cyBhY2Nlc3NvciBmdW5jdGlvbnMsIGFzIHRoZSBleHRlcm5hbCB1cmkgdHlwZSBpcyBhYnN0cmFjdCAgKilcbmxldCBnZXRfZGVjb2RlZF9vcHQgPSBmdW5jdGlvbiBOb25lIC0+IE5vbmUgfFNvbWUgeCAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgeClcbmxldCBzY2hlbWUgdXJpID0gZ2V0X2RlY29kZWRfb3B0IHVyaS5zY2hlbWVcbmxldCB3aXRoX3NjaGVtZSB1cmkgPVxuICBmdW5jdGlvblxuICB8U29tZSBzY2hlbWUgLT4geyB1cmkgd2l0aCBzY2hlbWU9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBzY2hlbWUpIH1cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBzY2hlbWU9Tm9uZSB9XG5cbmxldCBob3N0IHVyaSA9IGdldF9kZWNvZGVkX29wdCB1cmkuaG9zdFxubGV0IHdpdGhfaG9zdCB1cmkgPVxuICBmdW5jdGlvblxuICB8U29tZSBob3N0IC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIGhvc3QpIH1cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PU5vbmUgfVxuXG5sZXQgaG9zdF93aXRoX2RlZmF1bHQgPyhkZWZhdWx0PVwibG9jYWxob3N0XCIpIHVyaSA9XG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfE5vbmUgLT4gZGVmYXVsdFxuICB8U29tZSBoIC0+IGhcblxubGV0IHVzZXJpbmZvID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB1c2VyaW5mbyAtPiBTb21lIChQY3QudW5jYXN0X2VuY29kZWQgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICAgIHwgTm9uZSAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm9cbiAgICB8IFNvbWUgcyAtPiBlbmNvZGVkX29mX3VzZXJpbmZvIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvKSlcbmxldCB3aXRoX3VzZXJpbmZvIHVyaSB1c2VyaW5mbyA9XG4gIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgaW5cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKFBjdC5jYXN0X2RlY29kZWQgXCJcIik7IHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG5cbmxldCB1c2VyIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAodXNlciwgXykgLT4gU29tZSB1c2VyXG5cbmxldCBwYXNzd29yZCB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgfCBTb21lIChfLCBOb25lKSAtPiBOb25lXG4gIHwgU29tZSAoXywgU29tZSBwYXNzKSAtPiBTb21lIHBhc3NcbmxldCB3aXRoX3Bhc3N3b3JkIHVyaSBwYXNzd29yZCA9XG4gIGxldCByZXN1bHQgdXNlcmluZm8gPSBtYXRjaCBob3N0IHVyaSB3aXRoXG4gICAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpOyB1c2VyaW5mbz11c2VyaW5mbyB9XG4gICAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG4gIGluXG4gIG1hdGNoIHVyaS51c2VyaW5mbywgcGFzc3dvcmQgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdXJpXG4gIHwgTm9uZSwgU29tZSBfIC0+IHJlc3VsdCAoU29tZSAoXCJcIixwYXNzd29yZCkpXG4gIHwgU29tZSAodXNlcixfKSwgXyAtPiByZXN1bHQgKFNvbWUgKHVzZXIsIHBhc3N3b3JkKSlcblxubGV0IHBvcnQgdXJpID0gdXJpLnBvcnRcbmxldCB3aXRoX3BvcnQgdXJpIHBvcnQgPVxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggcG9ydD1wb3J0IH1cbiAgfCBOb25lIC0+IGJlZ2luXG4gICAgIG1hdGNoIHBvcnQgd2l0aFxuICAgICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PU5vbmU7IHBvcnQ9Tm9uZSB9XG4gICAgIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpOyBwb3J0PXBvcnQgfVxuICBlbmRcblxuKCogUmV0dXJuIHRoZSBwYXRoIGNvbXBvbmVudCAqKVxubGV0IHBhdGggPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gUGN0LnVuY2FzdF9lbmNvZGVkIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgfCBOb25lIC0+IGVuY29kZWRfb2ZfcGF0aCB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGhcbiAgfCBTb21lIHMgLT4gZW5jb2RlZF9vZl9wYXRoIH5zY2hlbWU6KFBjdC51bmNhc3RfZGVjb2RlZCBzKSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpXG5sZXQgd2l0aF9wYXRoIHVyaSBwYXRoID1cbiAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcGF0aCBpblxuICBtYXRjaCBob3N0IHVyaSwgcGF0aCB3aXRoXG4gIHwgTm9uZSwgXyB8IFNvbWUgXywgXCIvXCI6Ol8gfCBTb21lIF8sIFtdIC0+IHsgdXJpIHdpdGggcGF0aD1wYXRoIH1cbiAgfCBTb21lIF8sIF8gIC0+IHsgdXJpIHdpdGggcGF0aD1cIi9cIjo6cGF0aCB9XG5cbmxldCBmcmFnbWVudCB1cmkgPSBnZXRfZGVjb2RlZF9vcHQgdXJpLmZyYWdtZW50XG5sZXQgd2l0aF9mcmFnbWVudCB1cmkgPVxuICBmdW5jdGlvblxuICB8Tm9uZSAtPiB7IHVyaSB3aXRoIGZyYWdtZW50PU5vbmUgfVxuICB8U29tZSBmcmFnIC0+IHsgdXJpIHdpdGggZnJhZ21lbnQ9U29tZSAoUGN0LmNhc3RfZGVjb2RlZCBmcmFnKSB9XG5cbmxldCBxdWVyeSB1cmkgPSBRdWVyeS5rdiB1cmkucXVlcnlcbmxldCB2ZXJiYXRpbV9xdWVyeSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBRdWVyeS4obWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgfCBSYXcgKHFzLF8pIC0+IHFzXG4gIHwgS1YgW10gLT4gTm9uZVxuICB8IEtWIGt2IC0+IFNvbWUgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZTooc2NoZW1lIHVyaSkgfnBjdF9lbmNvZGVyIGt2KVxuKVxubGV0IGdldF9xdWVyeV9wYXJhbScgdXJpIGsgPSBRdWVyeS4oZmluZCAoa3YgdXJpLnF1ZXJ5KSBrKVxubGV0IGdldF9xdWVyeV9wYXJhbSB1cmkgayA9XG4gIG1hdGNoIGdldF9xdWVyeV9wYXJhbScgdXJpIGsgd2l0aFxuICB8Tm9uZSAtPiBOb25lXG4gIHxTb21lIHYgLT4gU29tZSAoU3RyaW5nLmNvbmNhdCBcIixcIiB2KVxuXG5sZXQgd2l0aF9xdWVyeSB1cmkgcXVlcnkgPSB7IHVyaSB3aXRoIHF1ZXJ5PVF1ZXJ5LktWIHF1ZXJ5IH1cbmxldCBxX3MgcSA9IExpc3QubWFwIChmdW4gKGssdikgLT4gayxbdl0pIHFcbmxldCB3aXRoX3F1ZXJ5JyB1cmkgcXVlcnkgPSB3aXRoX3F1ZXJ5IHVyaSAocV9zIHF1ZXJ5KVxubGV0IGFkZF9xdWVyeV9wYXJhbSB1cmkgcCA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW0nIHVyaSAoayx2KSA9XG4gIFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWICgoayxbdl0pOjooa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zIHVyaSBwcyA9IFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWIChwc0Aoa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCBhZGRfcXVlcnlfcGFyYW1zJyB1cmkgcHMgPVxuICBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAoKHFfcyBwcylAKGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgcmVtb3ZlX3F1ZXJ5X3BhcmFtIHVyaSBrID0gUXVlcnkuKFxuICB7IHVyaSB3aXRoIHF1ZXJ5PUtWIChMaXN0LmZpbHRlciAoZnVuIChrJyxfKSAtPiBrPD5rJykgKGt2IHVyaS5xdWVyeSkpIH1cbilcblxubGV0IHdpdGhfdXJpID9zY2hlbWUgP3VzZXJpbmZvID9ob3N0ID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgdXJpID1cbiAgbGV0IHdpdGhfcGF0aF9vcHQgdSBvID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gd2l0aF9wYXRoIHUgXCJcIlxuICAgIHwgU29tZSBwIC0+IHdpdGhfcGF0aCB1IHBcbiAgaW5cbiAgbGV0IHdpdGhfcXVlcnlfb3B0IHUgbyA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHdpdGhfcXVlcnkgdSBbXVxuICAgIHwgU29tZSBxIC0+IHdpdGhfcXVlcnkgdSBxXG4gIGluXG4gIGxldCB3aXRoXyBmIG8gdSA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHVcbiAgICB8IFNvbWUgeCAtPiBmIHUgeFxuICBpblxuICB3aXRoXyB3aXRoX3NjaGVtZSBzY2hlbWUgdXJpXG4gIHw+IHdpdGhfIHdpdGhfdXNlcmluZm8gdXNlcmluZm9cbiAgfD4gd2l0aF8gd2l0aF9ob3N0IGhvc3RcbiAgfD4gd2l0aF8gd2l0aF9wb3J0IHBvcnRcbiAgfD4gd2l0aF8gd2l0aF9wYXRoX29wdCBwYXRoXG4gIHw+IHdpdGhfIHdpdGhfcXVlcnlfb3B0IHF1ZXJ5XG4gIHw+IHdpdGhfIHdpdGhfZnJhZ21lbnQgZnJhZ21lbnRcblxuKCogQ29uc3RydWN0IGVuY29kZWQgcGF0aCBhbmQgcXVlcnkgY29tcG9uZW50cyAqKVxubGV0IHBhdGhfYW5kX3F1ZXJ5IHVyaSA9XG4gIG1hdGNoIChwYXRoIHVyaSksIChxdWVyeSB1cmkpIHdpdGhcbiAgfFwiXCIsIFtdIC0+IFwiL1wiICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gIHxcIlwiLCBxIC0+ICgqIFRPRE86IFdoYXQgYWJvdXQgc2FtZSBkb2N1bWVudD8gKC8pICopXG4gICAgbGV0IHNjaGVtZSA9IHVuY2FzdF9vcHQgdXJpLnNjaGVtZSBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiLz8lc1wiIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgcSlcbiAgfHAsIFtdIC0+IHBcbiAgfHAsIHEgLT5cbiAgICBsZXQgc2NoZW1lID0gdW5jYXN0X29wdCB1cmkuc2NoZW1lIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIlcz8lc1wiIHAgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSBxKVxuXG4oKiBUT0RPOiBmdW5jdGlvbnMgdG8gYWRkIGFuZCByZW1vdmUgZnJvbSBhIFVSSSAqKVxuXG4oKiBSZXNvbHZlIGEgVVJJIHdydCBhIGJhc2UgVVJJIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yPiAqKVxubGV0IHJlc29sdmUgc2NoZW0gYmFzZSB1cmkgPVxuICBsZXQgc2NoZW0gPSBTb21lIChQY3QuY2FzdF9kZWNvZGVkIChtYXRjaCBzY2hlbWUgYmFzZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gIHNjaGVtXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+IHNjaGVtZVxuICAgICkpIGluXG4gIG5vcm1hbGl6ZSBzY2hlbVxuICAgIFBhdGguKG1hdGNoIHNjaGVtZSB1cmksIHVzZXJpbmZvIHVyaSwgaG9zdCB1cmkgd2l0aFxuICAgIHwgU29tZSBfLCBfLCBfIC0+XG4gICAgICB7dXJpIHdpdGggcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgIHwgTm9uZSwgU29tZSBfLCBfXG4gICAgfCBOb25lLCBfLCBTb21lIF8gLT5cbiAgICAgIHt1cmkgd2l0aCBzY2hlbWU9YmFzZS5zY2hlbWU7IHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT5cbiAgICAgIGxldCB1cmkgPSB7dXJpIHdpdGggc2NoZW1lPWJhc2Uuc2NoZW1lOyB1c2VyaW5mbz1iYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0PWJhc2UuaG9zdDsgcG9ydD1iYXNlLnBvcnR9IGluXG4gICAgICBsZXQgcGF0aF9zdHIgPSBwYXRoIHVyaSBpblxuICAgICAgaWYgcGF0aF9zdHI9XCJcIlxuICAgICAgdGhlbiB7IHVyaSB3aXRoXG4gICAgICAgICAgICAgcGF0aD1iYXNlLnBhdGg7XG4gICAgICAgICAgICAgcXVlcnk9bWF0Y2ggdXJpLnF1ZXJ5IHdpdGhcbiAgICAgICAgICAgICAgIHwgUXVlcnkuUmF3IChOb25lLF8pIHwgUXVlcnkuS1YgW10gLT4gYmFzZS5xdWVyeVxuICAgICAgICAgICAgICAgfCBfIC0+IHVyaS5xdWVyeVxuICAgICAgICAgICB9XG4gICAgICBlbHNlIGlmIHBhdGhfc3RyLlswXT0nLydcbiAgICAgIHRoZW4ge3VyaSB3aXRoIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICAgIGVsc2Uge3VyaSB3aXRoXG4gICAgICAgIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyAobWVyZ2UgYmFzZS5ob3N0IGJhc2UucGF0aCB1cmkucGF0aCk7XG4gICAgICB9XG4gICAgKVxuXG5sZXQgY2Fub25pY2FsaXplIHVyaSA9XG4gIGxldCB1cmkgPSByZXNvbHZlIFwiXCIgZW1wdHkgdXJpIGluXG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHVyaS5zY2hlbWUpKSA6IFNjaGVtZSkgaW5cbiAgeyB1cmkgd2l0aFxuICAgIHBvcnQ9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wb3J0IHVyaS5wb3J0O1xuICAgIHBhdGg9U2NoZW1lLmNhbm9uaWNhbGl6ZV9wYXRoIHVyaS5wYXRoO1xuICB9XG5cbmxldCBwcCBwcGYgdXJpID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyB1cmkpXG5sZXQgcHBfaHVtIHBwZiB1cmkgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nIHVyaSlcblxubW9kdWxlIFBhcnNlciA9IHN0cnVjdFxuICBvcGVuIEFuZ3N0cm9tXG5cbiAgbGV0IHN0cmluZ19vZl9jaGFyID0gU3RyaW5nLm1ha2UgMVxuXG4gIGxldCBzdHJpbmdfb2ZfY2hhcl9saXN0IGNoYXJzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIHN0cmluZ19vZl9jaGFyIGNoYXJzKVxuXG4gIGxldCBzY2hlbWUgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBTb21lIChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgICh0YWtlX3doaWxlIChmdW4gYyAtPiBjIDw+ICc6JyAmJiBjIDw+ICcvJyAmJiBjIDw+ICc/JyAmJiBjIDw+ICcjJylcbiAgICAgIDwqIGNoYXIgJzonKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBpc19kaWdpdCA9IGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICBsZXQgaGV4X2RpZ2l0ID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgZmFsc2UpXG5cbiAgbGV0IGhleGFkZWNpbWFsID0gbGlmdCBzdHJpbmdfb2ZfY2hhcl9saXN0IChtYW55IGhleF9kaWdpdClcblxuICBsZXQgY19kb3QgPSBjaGFyICcuJ1xuXG4gIGxldCBjX2F0ID0gY2hhciAnQCdcblxuICBsZXQgY19jb2xvbiA9IGNoYXIgJzonXG5cbiAgbGV0IGRlY19vY3RldCA9XG4gICAgdGFrZV93aGlsZTEgKGZ1bmN0aW9uICcwJyAuLiAnOScgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpID4+PSBmdW4gbnVtIC0+XG4gICAgaWYgaW50X29mX3N0cmluZyBudW0gPCAyNTYgdGhlblxuICAgICAgcmV0dXJuIG51bVxuICAgIGVsc2VcbiAgICAgIGZhaWwgXCJpbnZhbGlkIG9jdGVjdFwiXG5cbiAgbGV0IGlwdjRfYWRkcmVzcyA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4gdGhyZWUgb25lIC0+IFN0cmluZy5jb25jYXQgXCIuXCIgdGhyZWUgXiBcIi5cIiBeIG9uZSlcbiAgICAgIChjb3VudCAzIChkZWNfb2N0ZXQgPCogY19kb3QpKVxuICAgICAgZGVjX29jdGV0XG5cbiAgKCogLS0gYWZ0ZXIgZG91YmxlIGNvbG9uLCBJUHY0IGRvdHRlZCBub3RhdGlvbiBjb3VsZCBhcHBlYXIgYW55d2hlcmUgKilcbiAgbGV0IGFmdGVyX2RvdWJsZV9jb2xvbiA9XG4gICAgZml4IChmdW4gZiAtPlxuICAgICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF1cbiAgICAgICAgPHw+IGxpZnQyIChmdW4geCB5IC0+IHggOjogeSkgaGV4YWRlY2ltYWwgKGNfY29sb24gKj4gZiA8fD4gcmV0dXJuIFtdKSlcblxuICBsZXQgZG91YmxlX2NvbG9uIGNvdW50ID1cbiAgICBhZnRlcl9kb3VibGVfY29sb24gPj49IChmdW4gcmVzdCAtPlxuICAgIGxldCBmaWxsZXJfbGVuZ3RoID0gOCAtIGNvdW50IC0gTGlzdC5sZW5ndGggcmVzdCBpblxuICAgIGlmIGZpbGxlcl9sZW5ndGggPD0gMCB0aGVuXG4gICAgICBmYWlsIFwidG9vIG1hbnkgcGFydHMgaW4gSVB2NiBhZGRyZXNzXCJcbiAgICBlbHNlXG4gICAgICByZXR1cm4gKFwiXCIgOjogcmVzdCkpXG4gICAgPHw+IHJldHVybiBbXCJcIl1cblxuICBsZXQgcmVjIHBhcnQgPSBmdW5jdGlvblxuICAgIHwgNyAtPlxuICAgICAgKCogbWF4IDggcGFydHMgaW4gYW4gSVB2NiBhZGRyZXNzICopXG4gICAgICBsaWZ0IChmdW4geCAtPiBbIHggXSkgaGV4YWRlY2ltYWxcbiAgICB8IDYgLT5cbiAgICAgICgqIGFmdGVyIDYgcGFydHMgaXQgY291bGQgZW5kIGluIElQdjQgZG90dGVkIG5vdGF0aW9uICopXG4gICAgICBsaXN0IFsgaXB2NF9hZGRyZXNzIF0gPHw+IGhleF9wYXJ0IDZcbiAgICB8IG4gLT5cbiAgICAgIGhleF9wYXJ0IG5cblxuICBhbmQgaGV4X3BhcnQgbiA9XG4gICAgbGlmdDJcbiAgICAgIChmdW4geCB5IC0+IHggOjogeSlcbiAgICAgIGhleGFkZWNpbWFsXG4gICAgICAoY19jb2xvbiAqPiAoY19jb2xvbiAqPiBkb3VibGVfY29sb24gKG4gKyAxKSA8fD4gcGFydCAobiArIDEpKSlcblxuICBsZXQgcmVjIHNwbGl0X3dpdGggZiB4cyA9XG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIFtdLCBbXVxuICAgIHwgeSA6OiB5cyAtPlxuICAgICAgaWYgZiB5IHRoZW5cbiAgICAgICAgbGV0IHpzLCB0cyA9IHNwbGl0X3dpdGggZiB5cyBpblxuICAgICAgICB5IDo6IHpzLCB0c1xuICAgICAgZWxzZVxuICAgICAgICBbXSwgeHNcblxuICBsZXQgaXB2NiA9XG4gICAgbGV0IGZvcm1hdF9hZGRyIHNlZ21lbnRzID1cbiAgICAgIGxldCBiZWZvcmVfZG91YmxlX2NvbG9uLCBhZnRlcl9kb3VibGVfY29sb24gPVxuICAgICAgICBzcGxpdF93aXRoIChmdW4gc2VnbWVudCAtPiBzZWdtZW50IDw+IFwiXCIpIHNlZ21lbnRzXG4gICAgICBpblxuICAgICAgbGV0IGJlZm9yZSA9IFN0cmluZy5jb25jYXQgXCI6XCIgYmVmb3JlX2RvdWJsZV9jb2xvbiBpblxuICAgICAgbGV0IHJlcyA9XG4gICAgICAgIG1hdGNoIGFmdGVyX2RvdWJsZV9jb2xvbiB3aXRoXG4gICAgICAgIHwgXCJcIiA6OiB4cyAtPlxuICAgICAgICAgIGJlZm9yZSBeIFwiOjpcIiBeIFN0cmluZy5jb25jYXQgXCI6XCIgeHNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgYmVmb3JlXG4gICAgICBpblxuICAgICAgcmVzXG4gICAgaW5cbiAgICBsaWZ0IGZvcm1hdF9hZGRyIChjX2NvbG9uICo+IGNfY29sb24gKj4gZG91YmxlX2NvbG9uIDAgPHw+IHBhcnQgMClcblxuICBsZXQgaXB2Nl9hZGRyZXNzID1cbiAgICBsaWZ0M1xuICAgICAgKGZ1biBsYiBpcCByYiAtPlxuICAgICAgICBTdHJpbmcuY29uY2F0IFwiXCIgWyBzdHJpbmdfb2ZfY2hhciBsYjsgaXA7IHN0cmluZ19vZl9jaGFyIHJiIF0pXG4gICAgICAoY2hhciAnWycpXG4gICAgICBpcHY2XG4gICAgICAoY2hhciAnXScpXG5cbiAgbGV0IHBjdF9lbmNvZGVkID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biBwY3QgZGlnaXRzIC0+IHN0cmluZ19vZl9jaGFyX2xpc3QgKHBjdCA6OiBkaWdpdHMpKVxuICAgICAgKGNoYXIgJyUnKVxuICAgICAgKGNvdW50IDIgaGV4X2RpZ2l0KVxuXG4gIGxldCBzdWJfZGVsaW1zID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICchJyB8ICckJyB8ICcmJyB8ICdcXCcnIHwgJygnIHwgJyknIHwgJyonIHwgJysnIHwgJywnIHwgJzsnIHwgJz0nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgdW5yZXNlcnZlZCA9XG4gICAgKCogXCJbQS1aYS16MC05LS5ffl1cIiAqKVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgfCAnMCcgLi4gJzknIHwgJy0nIHwgJy4nIHwgJ18nIHwgJ34nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgcmVnX25hbWUgPVxuICAgIGxpZnRcbiAgICAgIChTdHJpbmcuY29uY2F0IFwiXCIpXG4gICAgICAobWFueVxuICAgICAgICAgKGNob2ljZVxuICAgICAgICAgICAgWyBzdHJpbmdfb2ZfY2hhciA8JD4gdW5yZXNlcnZlZFxuICAgICAgICAgICAgOyBwY3RfZW5jb2RlZFxuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gc3ViX2RlbGltc1xuICAgICAgICAgICAgXSkpXG5cbiAgbGV0IGhvc3QgPVxuICAgIGxpZnRcbiAgICAgIChmdW4gcyAtPiBQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKVxuICAgICAgKGNob2ljZVxuICAgICAgICAgWyByZWdfbmFtZTsgaXB2NF9hZGRyZXNzOyBpcHY2X2FkZHJlc3MgKCogfCBpcHY0X2xpdGVyYWwgVE9ETyAqKSBdKVxuXG4gIGxldCB1c2VyaW5mbyA9XG4gICAgbGlmdFxuICAgICAgKGZ1biB4IC0+XG4gICAgICAgIGxldCBzID0gU3RyaW5nLmNvbmNhdCBcIlwiIHggaW5cbiAgICAgICAgU29tZSAoVXNlcmluZm8udXNlcmluZm9fb2ZfZW5jb2RlZCBzKSlcbiAgICAgIChtYW55XG4gICAgICAgICAoY2hvaWNlXG4gICAgICAgICAgICBbIHN0cmluZ19vZl9jaGFyIDwkPiB1bnJlc2VydmVkXG4gICAgICAgICAgICA7IHBjdF9lbmNvZGVkXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBzdWJfZGVsaW1zXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBjX2NvbG9uXG4gICAgICAgICAgICBdKVxuICAgICAgPCogY19hdClcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgcG9ydCA9XG4gICAgcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSAnOicgLT5cbiAgICAgIGNfY29sb24gKj4gdGFrZV93aGlsZSBpc19kaWdpdCA+PnwgZnVuIHBvcnQgLT5cbiAgICAgIGxldCBkZWNvZGVkID0gUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBwb3J0KSBpblxuICAgICAgKHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIChQY3QudW5jYXN0X2RlY29kZWQgZGVjb2RlZCkpIHdpdGggXyAtPiBOb25lKVxuICAgIHwgU29tZSBfIHwgTm9uZSAtPlxuICAgICAgcmV0dXJuIE5vbmVcblxuICBsZXQgYXV0aG9yaXR5ID1cbiAgICBzdHJpbmcgXCIvL1wiXG4gICAgKj4gbGlmdDNcbiAgICAgICAgIChmdW4gdXNlcmluZm8gaG9zdCBwb3J0IC0+IHVzZXJpbmZvLCBTb21lIGhvc3QsIHBvcnQpXG4gICAgICAgICB1c2VyaW5mb1xuICAgICAgICAgaG9zdFxuICAgICAgICAgcG9ydFxuICAgIDx8PiByZXR1cm4gKE5vbmUsIE5vbmUsIE5vbmUpXG5cbiAgbGV0IHBhdGggPVxuICAgIGxpZnRcbiAgICAgIFBhdGgucGF0aF9vZl9lbmNvZGVkXG4gICAgICAodGFrZV93aGlsZSAoZnVuY3Rpb24gJz8nIHwgJyMnIC0+IGZhbHNlIHwgXyAtPiB0cnVlKSlcblxuICBsZXQgcXVlcnkgPVxuICAgIGxpZnRcbiAgICAgIFF1ZXJ5Lm9mX3Jhd1xuICAgICAgKGNoYXIgJz8nICo+IHRha2VfdGlsbCAoZnVuY3Rpb24gJyMnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSlcbiAgICA8fD4gcmV0dXJuIChRdWVyeS5SYXcgKE5vbmUsIExhenkuZnJvbV92YWwgW10pKVxuXG4gIGxldCBmcmFnbWVudCA9XG4gICAgbGlmdFxuICAgICAgKGZ1biBzIC0+IFNvbWUgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKGNoYXIgJyMnICo+IHRha2Vfd2hpbGUgKGZ1biBfIC0+IHRydWUpKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBfdXJpX3JlZmVyZW5jZSA9XG4gICAgbGlmdDRcbiAgICAgIChmdW4gc2NoZW1lICh1c2VyaW5mbywgaG9zdCwgcG9ydCkgcGF0aCBxdWVyeSBmcmFnbWVudCAtPlxuICAgICAgICBub3JtYWxpemUgc2NoZW1lIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH0pXG4gICAgICBzY2hlbWVcbiAgICAgIGF1dGhvcml0eVxuICAgICAgcGF0aFxuICAgICAgcXVlcnlcbiAgICA8Kj4gZnJhZ21lbnRcblxuICAoKiBYWFgoYW5tb250ZWlybyk6IEZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMgd2l0aCB0aGUgb2xkIHJlZ2V4IHBhcnNlciwgd2VcbiAgICogb25seSBwYXJzZSB1bnRpbCB0aGUgZmlyc3QgbmV3bGluZSBjaGFyYWN0ZXIgYW5kIGRyb3AgZXZlcnl0aGluZyBlbHNlXG4gICAqIGFmdGVyIHRoYXQgKilcbiAgbGV0IHVyaV9yZWZlcmVuY2UgPVxuICAgIHRha2Vfd2hpbGUgKGZ1bmN0aW9uIHwgJ1xcbicgLT4gZmFsc2UgfCBfIC0+IHRydWUpID4+fCBmdW4gcyAtPlxuICAgICAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBfdXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgICAgIHwgT2sgdCAtPiB0XG4gICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgICAgIGVtcHR5XG5lbmRcblxubGV0IG9mX3N0cmluZyBzID1cbiAgKCogVG8gcHJlc2VydmUgdGhlIG9sZCByZWdleCBwYXJzZXIncyBiZWhhdmlvciwgd2Ugb25seSBwYXJzZSBhIHByZWZpeCwgYW5kXG4gICAqIHN0b3Agd2hlbmV2ZXIgd2UgY2FuJ3QgcGFyc2UgbW9yZS4gKilcbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOlByZWZpeCBQYXJzZXIudXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgfCBPayB0IC0+IHRcbiAgfCBFcnJvciBfIC0+XG4gICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgZW1wdHlcbiJdfQ==
