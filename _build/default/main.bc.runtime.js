// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {var joo_global_object=globalThis;
    (function()
       {var
         DefaultLocale=
          {days:
           ["Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"],
           shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
           months:
           ["January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"],
           shortMonths:
           ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"],
           AM:"AM",
           PM:"PM",
           am:"am",
           pm:"pm",
           formats:
           {D:"%m/%d/%y",
            F:"%Y-%m-%d",
            R:"%H:%M",
            T:"%H:%M:%S",
            X:"%T",
            c:"%a %b %d %X %Y",
            r:"%I:%M:%S %p",
            v:"%e-%b-%Y",
            x:"%D"}},
         defaultStrftime=new Strftime(DefaultLocale,0,false),
         isCommonJS=typeof module !== "undefined",
         namespace;
        if(isCommonJS)
         {namespace = module.exports = adaptedStrftime;
          namespace.strftime = deprecatedStrftime;
          if(joo_global_object)joo_global_object.strftime = adaptedStrftime}
        else
         {namespace
          =
          joo_global_object
          ||
          function(){return this || (1,eval)("this")}();
          namespace.strftime = adaptedStrftime}
        var
         _require=isCommonJS?"require('strftime')":"strftime",
         _deprecationWarnings={};
        function deprecationWarning(name,instead)
         {if(! _deprecationWarnings[name])
           {if
             (typeof console
              !==
              "undefined"
              &&
              typeof console.warn
              ==
              "function")
             console.warn
              ("[WARNING] "
               +
               name
               +
               " is deprecated and will be removed in version 1.0. Instead, use `"
               +
               instead
               +
               "`.");
            _deprecationWarnings[name] = true}}
        namespace.strftimeTZ = deprecatedStrftimeTZ;
        namespace.strftimeUTC = deprecatedStrftimeUTC;
        namespace.localizedStrftime = deprecatedStrftimeLocalized;
        function adaptForwards(fn)
         {fn.localize = defaultStrftime.localize.bind(defaultStrftime);
          fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
          fn.utc = defaultStrftime.utc.bind(defaultStrftime)}
        adaptForwards(adaptedStrftime);
        function adaptedStrftime(fmt,d,locale)
         {if(d && d.days){locale = d;d = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + "(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        adaptForwards(deprecatedStrftime);
        function deprecatedStrftime(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftime(format, [date], [locale])`",
             "var s = " + _require + ".localize(locale); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftime(format, [date])`",
             _require + "(format, [date])");
          var
           strftime=
            locale?defaultStrftime.localize(locale):defaultStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeTZ(fmt,d,locale,timezone)
         {if
           ((typeof locale == "number" || typeof locale == "string")
            &&
            timezone
            ==
            null)
           {timezone = locale;locale = undefined}
          if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
             +
             _require
             +
             ".localize(locale); s.timezone(tz)(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeTZ(format, date, tz)`",
             "var s = "
             +
             _require
             +
             ".timezone(tz); s(format, [date])` or `"
             +
             _require
             +
             ".timezone(tz)(format, [date])");
          var
           strftime=
            (locale?defaultStrftime.localize(locale):defaultStrftime).timezone
             (timezone);
          return strftime(fmt,d)}
        var utcStrftime=defaultStrftime.utc();
        function deprecatedStrftimeUTC(fmt,d,locale)
         {if(locale)
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, date, locale)`",
             "var s = "
             +
             _require
             +
             ".localize(locale).utc(); s(format, [date])");
          else
           deprecationWarning
            ("`" + _require + ".strftimeUTC(format, [date])`",
             "var s = " + _require + ".utc(); s(format, [date])");
          var strftime=locale?utcStrftime.localize(locale):utcStrftime;
          return strftime(fmt,d)}
        function deprecatedStrftimeLocalized(locale)
         {deprecationWarning
           ("`" + _require + ".localizedStrftime(locale)`",
            _require + ".localize(locale)");
          return defaultStrftime.localize(locale)}
        if(typeof Date.now !== "function")
         Date.now = function(){return + new Date()};
        function Strftime(locale,customTimezoneOffset,useUtcTimezone)
         {var
           _locale=locale || DefaultLocale,
           _customTimezoneOffset=customTimezoneOffset || 0,
           _useUtcBasedDate=useUtcTimezone || false,
           _cachedDateTimestamp=0,
           _cachedDate;
          function _strftime(format,date)
           {var timestamp;
            if(! date)
             {var currentTimestamp=Date.now();
              if(currentTimestamp > _cachedDateTimestamp)
               {_cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if(_useUtcBasedDate)
                 _cachedDate
                 =
                 new
                  Date
                  (_cachedDateTimestamp
                   +
                   getTimestampToUtcOffsetFor(_cachedDate)
                   +
                   _customTimezoneOffset)}
              date = _cachedDate}
            else
             {timestamp = date.getTime();
              if(_useUtcBasedDate)
               date
               =
               new
                Date
                (date.getTime()
                 +
                 getTimestampToUtcOffsetFor(date)
                 +
                 _customTimezoneOffset)}
            return _processFormat(format,date,_locale,timestamp)}
          function _processFormat(format,date,locale,timestamp)
           {var
             resultString="",
             padding=null,
             isInScope=false,
             length=format.length,
             extendedTZ=false;
            for(var i=0;i < length;i++)
             {var currentCharCode=format.charCodeAt(i);
              if(isInScope === true)
               {if(currentCharCode === 45)
                 {padding = "";continue}
                else
                 if(currentCharCode === 95)
                  {padding = " ";continue}
                 else
                  if(currentCharCode === 48)
                   {padding = "0";continue}
                  else
                   if(currentCharCode === 58)
                    {if(extendedTZ)
                      if
                       (typeof console
                        !==
                        "undefined"
                        &&
                        typeof console.warn
                        ==
                        "function")
                       console.warn
                        ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                     extendedTZ = true;
                     continue}
                switch(currentCharCode)
                 {case 65:resultString += locale.days[date.getDay()];break;
                  case 66:
                   resultString += locale.months[date.getMonth()];break;
                  case 67:
                   resultString
                   +=
                   padTill2(Math.floor(date.getFullYear() / 100),padding);
                   break;
                  case 68:
                   resultString
                   +=
                   _processFormat(locale.formats.D,date,locale,timestamp);
                   break;
                  case 70:
                   resultString
                   +=
                   _processFormat(locale.formats.F,date,locale,timestamp);
                   break;
                  case 72:
                   resultString += padTill2(date.getHours(),padding);break;
                  case 73:
                   resultString += padTill2(hours12(date.getHours()),padding);
                   break;
                  case 76:
                   resultString += padTill3(Math.floor(timestamp % 1000));
                   break;
                  case 77:
                   resultString += padTill2(date.getMinutes(),padding);break;
                  case 80:
                   resultString += date.getHours() < 12?locale.am:locale.pm;
                   break;
                  case 82:
                   resultString
                   +=
                   _processFormat(locale.formats.R,date,locale,timestamp);
                   break;
                  case 83:
                   resultString += padTill2(date.getSeconds(),padding);break;
                  case 84:
                   resultString
                   +=
                   _processFormat(locale.formats.T,date,locale,timestamp);
                   break;
                  case 85:
                   resultString += padTill2(weekNumber(date,"sunday"),padding);
                   break;
                  case 87:
                   resultString += padTill2(weekNumber(date,"monday"),padding);
                   break;
                  case 88:
                   resultString
                   +=
                   _processFormat(locale.formats.X,date,locale,timestamp);
                   break;
                  case 89:resultString += date.getFullYear();break;
                  case 90:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += "GMT";
                   else
                    {var tzString=date.toString().match(/\(([\w\s]+)\)/);
                     resultString += tzString && tzString[1] || ""}
                   break;
                  case 97:
                   resultString += locale.shortDays[date.getDay()];break;
                  case 98:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 99:
                   resultString
                   +=
                   _processFormat(locale.formats.c,date,locale,timestamp);
                   break;
                  case 100:
                   resultString += padTill2(date.getDate(),padding);break;
                  case 101:
                   resultString
                   +=
                   padTill2(date.getDate(),padding == null?" ":padding);
                   break;
                  case 104:
                   resultString += locale.shortMonths[date.getMonth()];break;
                  case 106:
                   var
                    y=new Date(date.getFullYear(),0,1),
                    day=
                     Math.ceil
                      ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                   resultString += padTill3(day);
                   break;
                  case 107:
                   resultString
                   +=
                   padTill2(date.getHours(),padding == null?" ":padding);
                   break;
                  case 108:
                   resultString
                   +=
                   padTill2
                    (hours12(date.getHours()),padding == null?" ":padding);
                   break;
                  case 109:
                   resultString += padTill2(date.getMonth() + 1,padding);break;
                  case 110:resultString += "\n";break;
                  case 111:
                   resultString
                   +=
                   String(date.getDate())
                   +
                   ordinal(date.getDate());
                   break;
                  case 112:
                   resultString += date.getHours() < 12?locale.AM:locale.PM;
                   break;
                  case 114:
                   resultString
                   +=
                   _processFormat(locale.formats.r,date,locale,timestamp);
                   break;
                  case 115:resultString += Math.floor(timestamp / 1000);break;
                  case 116:resultString += "\t";break;
                  case 117:
                   var day=date.getDay();resultString += day === 0?7:day;break;
                  case 118:
                   resultString
                   +=
                   _processFormat(locale.formats.v,date,locale,timestamp);
                   break;
                  case 119:resultString += date.getDay();break;
                  case 120:
                   resultString
                   +=
                   _processFormat(locale.formats.x,date,locale,timestamp);
                   break;
                  case 121:
                   resultString += ("" + date.getFullYear()).slice(2);break;
                  case 122:
                   if(_useUtcBasedDate && _customTimezoneOffset === 0)
                    resultString += extendedTZ?"+00:00":"+0000";
                   else
                    {var off;
                     if(_customTimezoneOffset !== 0)
                      off = _customTimezoneOffset / (60 * 1000);
                     else
                      off = - date.getTimezoneOffset();
                     var
                      sign=off < 0?"-":"+",
                      sep=extendedTZ?":":"",
                      hours=Math.floor(Math.abs(off / 60)),
                      mins=Math.abs(off % 60);
                     resultString
                     +=
                     sign
                     +
                     padTill2(hours)
                     +
                     sep
                     +
                     padTill2(mins)}
                   break;
                  default:resultString += format[i];break}
                padding = null;
                isInScope = false;
                continue}
              if(currentCharCode === 37){isInScope = true;continue}
              resultString += format[i]}
            return resultString}
          var strftime=_strftime;
          strftime.localize
          =
          function(locale)
           {return new
                    Strftime
                    (locale || _locale,_customTimezoneOffset,_useUtcBasedDate)};
          strftime.timezone
          =
          function(timezone)
           {var
             customTimezoneOffset=_customTimezoneOffset,
             useUtcBasedDate=_useUtcBasedDate,
             timezoneType=typeof timezone;
            if(timezoneType === "number" || timezoneType === "string")
             {useUtcBasedDate = true;
              if(timezoneType === "string")
               {var
                 sign=timezone[0] === "-"?- 1:1,
                 hours=parseInt(timezone.slice(1,3),10),
                 minutes=parseInt(timezone.slice(3,5),10);
                customTimezoneOffset
                =
                sign
                *
                (60 * hours + minutes)
                *
                60
                *
                1000}
              else
               if(timezoneType === "number")
                customTimezoneOffset = timezone * 60 * 1000}
            return new Strftime(_locale,customTimezoneOffset,useUtcBasedDate)};
          strftime.utc
          =
          function(){return new Strftime(_locale,_customTimezoneOffset,true)};
          return strftime}
        function padTill2(numberToPad,paddingChar)
         {if(paddingChar === "" || numberToPad > 9)return numberToPad;
          if(paddingChar == null)paddingChar = "0";
          return paddingChar + numberToPad}
        function padTill3(numberToPad)
         {if(numberToPad > 99)return numberToPad;
          if(numberToPad > 9)return "0" + numberToPad;
          return "00" + numberToPad}
        function hours12(hour)
         {if(hour === 0)return 12;else if(hour > 12)return hour - 12;
          return hour}
        function weekNumber(date,firstWeekday)
         {firstWeekday = firstWeekday || "sunday";
          var weekday=date.getDay();
          if(firstWeekday === "monday")
           if(weekday === 0)weekday = 6;else weekday--;
          var
           firstDayOfYearUtc=Date.UTC(date.getFullYear(),0,1),
           dateUtc=Date.UTC(date.getFullYear(),date.getMonth(),date.getDate()),
           yday=Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
           weekNum=(yday + 7 - weekday) / 7;
          return Math.floor(weekNum)}
        function ordinal(number)
         {var i=number % 10,ii=number % 100;
          if(ii >= 11 && ii <= 13 || i === 0 || i >= 4)return "th";
          switch(i){case 1:return "st";case 2:return "nd";case 3:return "rd"}}
        function getTimestampToUtcOffsetFor(date)
         {return (date.getTimezoneOffset() || 0) * 60000}}
      ())}
  (globalThis));
(function(globalThis)
   {(function(f)
       {if(typeof exports === "object" && typeof module !== "undefined")
         module.exports = f();
        else
         if(typeof define === "function" && define.amd)
          define([],f);
         else
          {var g;
           if(typeof window !== "undefined")
            g = window;
           else
            if(typeof global !== "undefined")
             g = global;
            else
             if(typeof self !== "undefined")g = self;else g = this;
           g.VirtualDom = f()}}
      (function()
        {var define,module,exports;
         return function e(t,n,r)
                   {function s(o,u)
                     {if(! n[o])
                       {if(! t[o])
                         {var a=typeof require == "function" && require;
                          if(! u && a)return a(o,! 0);
                          if(i)return i(o,! 0);
                          var f=new Error("Cannot find module '" + o + "'");
                          throw f.code = "MODULE_NOT_FOUND",f}
                        var l=n[o] = {exports:{}};
                        t[o][0].call
                         (l.exports,
                          function(e){var n=t[o][1][e];return s(n?n:e)},
                          l,
                          l.exports,
                          e,
                          t,
                          n,
                          r)}
                      return n[o].exports}
                    var i=typeof require == "function" && require;
                    for(var o=0;o < r.length;o++)s(r[o]);
                    return s}
                  ({1:
                    [function(require,module,exports)
                      {var createElement=require("./vdom/create-element.js");
                       module.exports = createElement},
                     {"./vdom/create-element.js":24}],
                    2:
                    [function(require,module,exports)
                      {var diff=require("./vtree/diff.js");module.exports = diff},
                     {"./vtree/diff.js":47}],
                    3:
                    [function(require,module,exports)
                      {module.exports
                       =
                       function(undef)
                         {var
                           nativeSplit=String.prototype.split,
                           compliantExecNpcg=/()??/.exec("")[1] === undef,
                           self;
                          self
                          =
                          function(str,separator,limit)
                           {if
                             (Object.prototype.toString.call(separator)
                              !==
                              "[object RegExp]")
                             return nativeSplit.call(str,separator,limit);
                            var
                             output=[],
                             flags=
                              (separator.ignoreCase?"i":"")
                              +
                              (separator.multiline?"m":"")
                              +
                              (separator.extended?"x":"")
                              +
                              (separator.sticky?"y":""),
                             lastLastIndex=0,
                             separator=new RegExp(separator.source,flags + "g"),
                             separator2,
                             match,
                             lastIndex,
                             lastLength;
                            str += "";
                            if(! compliantExecNpcg)
                             separator2
                             =
                             new RegExp("^" + separator.source + "$(?!\\s)",flags);
                            limit = limit === undef?- 1 >>> 0:limit >>> 0;
                            while(match = separator.exec(str))
                             {lastIndex = match.index + match[0].length;
                              if(lastIndex > lastLastIndex)
                               {output.push(str.slice(lastLastIndex,match.index));
                                if(! compliantExecNpcg && match.length > 1)
                                 match[0].replace
                                  (separator2,
                                   function()
                                    {for(var i=1;i < arguments.length - 2;i++)
                                      if(arguments[i] === undef)match[i] = undef});
                                if(match.length > 1 && match.index < str.length)
                                 Array.prototype.push.apply(output,match.slice(1));
                                lastLength = match[0].length;
                                lastLastIndex = lastIndex;
                                if(output.length >= limit)break}
                              if(separator.lastIndex === match.index)separator.lastIndex++}
                            if(lastLastIndex === str.length)
                             {if(lastLength || ! separator.test(""))output.push("")}
                            else
                             output.push(str.slice(lastLastIndex));
                            return output.length > limit?output.slice(0,limit):output};
                          return self}
                        ()},
                     {}],
                    4:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        OneVersionConstraint=require("individual/one-version"),
                        MY_VERSION="7";
                       OneVersionConstraint("ev-store",MY_VERSION);
                       var hashKey="__EV_STORE_KEY@" + MY_VERSION;
                       module.exports = EvStore;
                       function EvStore(elem)
                        {var hash=elem[hashKey];
                         if(! hash)hash = elem[hashKey] = {};
                         return hash}},
                     {"individual/one-version":6}],
                    5:
                    [function(require,module,exports)
                      {(function(global)
                          {"use strict";
                           var
                            root=
                             typeof window !== "undefined"
                              ?window
                              :typeof global !== "undefined"?global:{};
                           module.exports = Individual;
                           function Individual(key,value)
                            {if(key in root)return root[key];
                             root[key] = value;
                             return value}}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {}],
                    6:
                    [function(require,module,exports)
                      {"use strict";
                       var Individual=require("./index.js");
                       module.exports = OneVersion;
                       function OneVersion(moduleName,version,defaultValue)
                        {var
                          key="__INDIVIDUAL_ONE_VERSION_" + moduleName,
                          enforceKey=key + "_ENFORCE_SINGLETON",
                          versionValue=Individual(enforceKey,version);
                         if(versionValue !== version)
                          throw new
                                 Error
                                 ("Can only have one copy of "
                                  +
                                  moduleName
                                  +
                                  ".\n"
                                  +
                                  "You already have version "
                                  +
                                  versionValue
                                  +
                                  " installed.\n"
                                  +
                                  "This means you cannot install version "
                                  +
                                  version);
                         return Individual(key,defaultValue)}},
                     {"./index.js":5}],
                    7:
                    [function(require,module,exports)
                      {(function(global)
                          {var
                            topLevel=
                             typeof global !== "undefined"
                              ?global
                              :typeof window !== "undefined"?window:{},
                            minDoc=require("min-document");
                           if(typeof document !== "undefined")
                            module.exports = document;
                           else
                            {var doccy=topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                             if(! doccy)
                              doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
                             module.exports = doccy}}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {"min-document":17}],
                    8:
                    [function(require,module,exports)
                      {var
                        domWalk=require("dom-walk"),
                        Comment=require("./dom-comment.js"),
                        DOMText=require("./dom-text.js"),
                        DOMElement=require("./dom-element.js"),
                        DocumentFragment=require("./dom-fragment.js"),
                        Event=require("./event.js"),
                        dispatchEvent=require("./event/dispatch-event.js"),
                        addEventListener=require("./event/add-event-listener.js"),
                        removeEventListener=
                         require("./event/remove-event-listener.js");
                       module.exports = Document;
                       function Document()
                        {if(! (this instanceof Document))return new Document();
                         this.head = this.createElement("head");
                         this.body = this.createElement("body");
                         this.documentElement = this.createElement("html");
                         this.documentElement.appendChild(this.head);
                         this.documentElement.appendChild(this.body);
                         this.childNodes = [this.documentElement];
                         this.nodeType = 9}
                       var proto=Document.prototype;
                       proto.createTextNode
                       =
                       function(value){return new DOMText(value,this)};
                       proto.createElementNS
                       =
                       function(namespace,tagName)
                        {var ns=namespace === null?null:String(namespace);
                         return new DOMElement(tagName,this,ns)};
                       proto.createElement
                       =
                       function(tagName){return new DOMElement(tagName,this)};
                       proto.createDocumentFragment
                       =
                       function(){return new DocumentFragment(this)};
                       proto.createEvent
                       =
                       function(family){return new Event(family)};
                       proto.createComment
                       =
                       function(data){return new Comment(data,this)};
                       proto.getElementById
                       =
                       function(id)
                        {id = String(id);
                         var
                          result=
                           domWalk
                            (this.childNodes,
                             function(node){if(String(node.id) === id)return node});
                         return result || null};
                       proto.getElementsByClassName
                       =
                       DOMElement.prototype.getElementsByClassName;
                       proto.getElementsByTagName
                       =
                       DOMElement.prototype.getElementsByTagName;
                       proto.contains = DOMElement.prototype.contains;
                       proto.removeEventListener = removeEventListener;
                       proto.addEventListener = addEventListener;
                       proto.dispatchEvent = dispatchEvent},
                     {"./dom-comment.js":9,
                      "./dom-element.js":10,
                      "./dom-fragment.js":11,
                      "./dom-text.js":12,
                      "./event.js":13,
                      "./event/add-event-listener.js":14,
                      "./event/dispatch-event.js":15,
                      "./event/remove-event-listener.js":16,
                      "dom-walk":18}],
                    9:
                    [function(require,module,exports)
                      {module.exports = Comment;
                       function Comment(data,owner)
                        {if(! (this instanceof Comment))
                          return new Comment(data,owner);
                         this.data = data;
                         this.nodeValue = data;
                         this.length = data.length;
                         this.ownerDocument = owner || null}
                       Comment.prototype.nodeType = 8;
                       Comment.prototype.nodeName = "#comment";
                       Comment.prototype.toString
                       =
                       function(){return "[object Comment]"}},
                     {}],
                    10:
                    [function(require,module,exports)
                      {var
                        domWalk=require("dom-walk"),
                        dispatchEvent=require("./event/dispatch-event.js"),
                        addEventListener=require("./event/add-event-listener.js"),
                        removeEventListener=
                         require("./event/remove-event-listener.js"),
                        serializeNode=require("./serialize.js"),
                        htmlns="http://www.w3.org/1999/xhtml";
                       module.exports = DOMElement;
                       function DOMElement(tagName,owner,namespace)
                        {if(! (this instanceof DOMElement))
                          return new DOMElement(tagName);
                         var ns=namespace === undefined?htmlns:namespace || null;
                         this.tagName
                         =
                         ns === htmlns?String(tagName).toUpperCase():tagName;
                         this.nodeName = this.tagName;
                         this.className = "";
                         this.dataset = {};
                         this.childNodes = [];
                         this.parentNode = null;
                         this.style = {};
                         this.ownerDocument = owner || null;
                         this.namespaceURI = ns;
                         this._attributes = {};
                         if(this.tagName === "INPUT")this.type = "text"}
                       DOMElement.prototype.type = "DOMElement";
                       DOMElement.prototype.nodeType = 1;
                       DOMElement.prototype.appendChild
                       =
                       function(child)
                        {if(child.parentNode)child.parentNode.removeChild(child);
                         this.childNodes.push(child);
                         child.parentNode = this;
                         return child};
                       DOMElement.prototype.replaceChild
                       =
                       function(elem,needle)
                        {if(elem.parentNode)elem.parentNode.removeChild(elem);
                         var index=this.childNodes.indexOf(needle);
                         needle.parentNode = null;
                         this.childNodes[index] = elem;
                         elem.parentNode = this;
                         return needle};
                       DOMElement.prototype.removeChild
                       =
                       function(elem)
                        {var index=this.childNodes.indexOf(elem);
                         this.childNodes.splice(index,1);
                         elem.parentNode = null;
                         return elem};
                       DOMElement.prototype.insertBefore
                       =
                       function(elem,needle)
                        {if(elem.parentNode)elem.parentNode.removeChild(elem);
                         var
                          index=
                           needle === null || needle === undefined
                            ?- 1
                            :this.childNodes.indexOf(needle);
                         if(index > - 1)
                          this.childNodes.splice(index,0,elem);
                         else
                          this.childNodes.push(elem);
                         elem.parentNode = this;
                         return elem};
                       DOMElement.prototype.setAttributeNS
                       =
                       function(namespace,name,value)
                        {var
                          prefix=null,
                          localName=name,
                          colonPosition=name.indexOf(":");
                         if(colonPosition > - 1)
                          {prefix = name.substr(0,colonPosition);
                           localName = name.substr(colonPosition + 1)}
                         var
                          attributes=
                           this._attributes[namespace]
                           ||
                           (this._attributes[namespace] = {});
                         attributes[localName] = {value:value,prefix:prefix}};
                       DOMElement.prototype.getAttributeNS
                       =
                       function(namespace,name)
                        {var
                          attributes=this._attributes[namespace],
                          value=
                           attributes
                           &&
                           attributes[name]
                           &&
                           attributes[name].value;
                         if(typeof value !== "string")return null;
                         return value};
                       DOMElement.prototype.removeAttributeNS
                       =
                       function(namespace,name)
                        {var attributes=this._attributes[namespace];
                         if(attributes)delete attributes[name]};
                       DOMElement.prototype.hasAttributeNS
                       =
                       function(namespace,name)
                        {var attributes=this._attributes[namespace];
                         return ! ! attributes && name in attributes};
                       DOMElement.prototype.setAttribute
                       =
                       function(name,value)
                        {return this.setAttributeNS(null,name,value)};
                       DOMElement.prototype.getAttribute
                       =
                       function(name){return this.getAttributeNS(null,name)};
                       DOMElement.prototype.removeAttribute
                       =
                       function(name){return this.removeAttributeNS(null,name)};
                       DOMElement.prototype.hasAttribute
                       =
                       function(name){return this.hasAttributeNS(null,name)};
                       DOMElement.prototype.removeEventListener
                       =
                       removeEventListener;
                       DOMElement.prototype.addEventListener = addEventListener;
                       DOMElement.prototype.dispatchEvent = dispatchEvent;
                       DOMElement.prototype.focus = function(){return void 0};
                       DOMElement.prototype.toString
                       =
                       function(){return serializeNode(this)};
                       DOMElement.prototype.getElementsByClassName
                       =
                       function(classNames)
                        {var classes=classNames.split(" "),elems=[];
                         domWalk
                          (this,
                           function(node)
                            {if(node.nodeType === 1)
                              {var
                                nodeClassName=node.className || "",
                                nodeClasses=nodeClassName.split(" ");
                               if
                                (classes.every
                                  (function(item){return nodeClasses.indexOf(item) !== - 1}))
                                elems.push(node)}});
                         return elems};
                       DOMElement.prototype.getElementsByTagName
                       =
                       function(tagName)
                        {tagName = tagName.toLowerCase();
                         var elems=[];
                         domWalk
                          (this.childNodes,
                           function(node)
                            {if
                              (node.nodeType
                               ===
                               1
                               &&
                               (tagName === "*" || node.tagName.toLowerCase() === tagName))
                              elems.push(node)});
                         return elems};
                       DOMElement.prototype.contains
                       =
                       function(element)
                        {return domWalk
                                 (this,function(node){return element === node})
                                ||
                                false}},
                     {"./event/add-event-listener.js":14,
                      "./event/dispatch-event.js":15,
                      "./event/remove-event-listener.js":16,
                      "./serialize.js":19,
                      "dom-walk":18}],
                    11:
                    [function(require,module,exports)
                      {var DOMElement=require("./dom-element.js");
                       module.exports = DocumentFragment;
                       function DocumentFragment(owner)
                        {if(! (this instanceof DocumentFragment))
                          return new DocumentFragment();
                         this.childNodes = [];
                         this.parentNode = null;
                         this.ownerDocument = owner || null}
                       DocumentFragment.prototype.type = "DocumentFragment";
                       DocumentFragment.prototype.nodeType = 11;
                       DocumentFragment.prototype.nodeName = "#document-fragment";
                       DocumentFragment.prototype.appendChild
                       =
                       DOMElement.prototype.appendChild;
                       DocumentFragment.prototype.replaceChild
                       =
                       DOMElement.prototype.replaceChild;
                       DocumentFragment.prototype.removeChild
                       =
                       DOMElement.prototype.removeChild;
                       DocumentFragment.prototype.toString
                       =
                       function()
                        {return this.childNodes.map
                                  (function(node){return String(node)}).join
                                 ("")}},
                     {"./dom-element.js":10}],
                    12:
                    [function(require,module,exports)
                      {module.exports = DOMText;
                       function DOMText(value,owner)
                        {if(! (this instanceof DOMText))return new DOMText(value);
                         this.data = value || "";
                         this.length = this.data.length;
                         this.ownerDocument = owner || null}
                       DOMText.prototype.type = "DOMTextNode";
                       DOMText.prototype.nodeType = 3;
                       DOMText.prototype.nodeName = "#text";
                       DOMText.prototype.toString = function(){return this.data};
                       DOMText.prototype.replaceData
                       =
                       function(index,length,value)
                        {var
                          current=this.data,
                          left=current.substring(0,index),
                          right=current.substring(index + length,current.length);
                         this.data = left + value + right;
                         this.length = this.data.length}},
                     {}],
                    13:
                    [function(require,module,exports)
                      {module.exports = Event;
                       function Event(family){}
                       Event.prototype.initEvent
                       =
                       function(type,bubbles,cancelable)
                        {this.type = type;
                         this.bubbles = bubbles;
                         this.cancelable = cancelable};
                       Event.prototype.preventDefault = function(){}},
                     {}],
                    14:
                    [function(require,module,exports)
                      {module.exports = addEventListener;
                       function addEventListener(type,listener)
                        {var elem=this;
                         if(! elem.listeners)elem.listeners = {};
                         if(! elem.listeners[type])elem.listeners[type] = [];
                         if(elem.listeners[type].indexOf(listener) === - 1)
                          elem.listeners[type].push(listener)}},
                     {}],
                    15:
                    [function(require,module,exports)
                      {module.exports = dispatchEvent;
                       function dispatchEvent(ev)
                        {var elem=this,type=ev.type;
                         if(! ev.target)ev.target = elem;
                         if(! elem.listeners)elem.listeners = {};
                         var listeners=elem.listeners[type];
                         if(listeners)
                          return listeners.forEach
                                  (function(listener)
                                    {ev.currentTarget = elem;
                                     if(typeof listener === "function")
                                      listener(ev);
                                     else
                                      listener.handleEvent(ev)});
                         if(elem.parentNode)elem.parentNode.dispatchEvent(ev)}},
                     {}],
                    16:
                    [function(require,module,exports)
                      {module.exports = removeEventListener;
                       function removeEventListener(type,listener)
                        {var elem=this;
                         if(! elem.listeners)return;
                         if(! elem.listeners[type])return;
                         var list=elem.listeners[type],index=list.indexOf(listener);
                         if(index !== - 1)list.splice(index,1)}},
                     {}],
                    17:
                    [function(require,module,exports)
                      {var Document=require("./document.js");
                       module.exports = new Document()},
                     {"./document.js":8}],
                    18:
                    [function(require,module,exports)
                      {var slice=Array.prototype.slice;
                       module.exports = iterativelyWalk;
                       function iterativelyWalk(nodes,cb)
                        {if(! ("length" in nodes))nodes = [nodes];
                         nodes = slice.call(nodes);
                         while(nodes.length)
                          {var node=nodes.shift(),ret=cb(node);
                           if(ret)return ret;
                           if(node.childNodes && node.childNodes.length)
                            nodes = slice.call(node.childNodes).concat(nodes)}}},
                     {}],
                    19:
                    [function(require,module,exports)
                      {module.exports = serializeNode;
                       var
                        voidElements=
                         /area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr/i;
                       function serializeNode(node)
                        {switch(node.nodeType)
                          {case 3:return escapeText(node.data);
                           case 8:return "<!--" + node.data + "-->";
                           default:return serializeElement(node)}}
                       function serializeElement(elem)
                        {var strings=[],tagname=elem.tagName;
                         if(elem.namespaceURI === "http://www.w3.org/1999/xhtml")
                          tagname = tagname.toLowerCase();
                         strings.push
                          ("<" + tagname + properties(elem) + datasetify(elem));
                         if(voidElements.test(tagname))
                          strings.push(" />");
                         else
                          {strings.push(">");
                           if(elem.childNodes.length)
                            strings.push.apply
                             (strings,elem.childNodes.map(serializeNode));
                           else
                            if(elem.textContent || elem.innerText)
                             strings.push(escapeText(elem.textContent || elem.innerText));
                            else
                             if(elem.innerHTML)strings.push(elem.innerHTML);
                           strings.push("<\/" + tagname + ">")}
                         return strings.join("")}
                       function isProperty(elem,key)
                        {var type=typeof elem[key];
                         if(key === "style" && Object.keys(elem.style).length > 0)
                          return true;
                         return elem.hasOwnProperty(key)
                                &&
                                (type
                                 ===
                                 "string"
                                 ||
                                 type
                                 ===
                                 "boolean"
                                 ||
                                 type
                                 ===
                                 "number")
                                &&
                                key
                                !==
                                "nodeName"
                                &&
                                key
                                !==
                                "className"
                                &&
                                key
                                !==
                                "tagName"
                                &&
                                key
                                !==
                                "textContent"
                                &&
                                key
                                !==
                                "innerText"
                                &&
                                key
                                !==
                                "namespaceURI"
                                &&
                                key
                                !==
                                "innerHTML"}
                       function stylify(styles)
                        {if(typeof styles === "string")return styles;
                         var attr="";
                         Object.keys(styles).forEach
                          (function(key)
                            {var value=styles[key];
                             key
                             =
                             key.replace
                              (/[A-Z]/g,function(c){return "-" + c.toLowerCase()});
                             attr += key + ":" + value + ";"});
                         return attr}
                       function datasetify(elem)
                        {var ds=elem.dataset,props=[];
                         for(var key in ds)
                          props.push({name:"data-" + key,value:ds[key]});
                         return props.length?stringify(props):""}
                       function stringify(list)
                        {var attributes=[];
                         list.forEach
                          (function(tuple)
                            {var name=tuple.name,value=tuple.value;
                             if(name === "style")value = stylify(value);
                             attributes.push
                              (name + "=" + '"' + escapeAttributeValue(value) + '"')});
                         return attributes.length?" " + attributes.join(" "):""}
                       function properties(elem)
                        {var props=[];
                         for(var key in elem)
                          if(isProperty(elem,key))
                           props.push({name:key,value:elem[key]});
                         for(var ns in elem._attributes)
                          for(var attribute in elem._attributes[ns])
                           {var
                             prop=elem._attributes[ns][attribute],
                             name=(prop.prefix?prop.prefix + ":":"") + attribute;
                            props.push({name:name,value:prop.value})}
                         if(elem.className)
                          props.push({name:"class",value:elem.className});
                         return props.length?stringify(props):""}
                       function escapeText(s)
                        {var str="";
                         if(typeof s === "string")
                          str = s;
                         else
                          if(s)str = s.toString();
                         return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace
                                 (/>/g,"&gt;")}
                       function escapeAttributeValue(str)
                        {return escapeText(str).replace(/"/g,"&quot;")}},
                     {}],
                    20:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports
                       =
                       function(x){return typeof x === "object" && x !== null}},
                     {}],
                    21:
                    [function(require,module,exports)
                      {var
                        nativeIsArray=Array.isArray,
                        toString=Object.prototype.toString;
                       module.exports = nativeIsArray || isArray;
                       function isArray(obj)
                        {return toString.call(obj) === "[object Array]"}},
                     {}],
                    22:
                    [function(require,module,exports)
                      {var patch=require("./vdom/patch.js");
                       module.exports = patch},
                     {"./vdom/patch.js":27}],
                    23:
                    [function(require,module,exports)
                      {var
                        isObject=require("is-object"),
                        isHook=require("../vnode/is-vhook.js");
                       module.exports = applyProperties;
                       function applyProperties(node,props,previous)
                        {for(var propName in props)
                          {var propValue=props[propName];
                           if(propValue === undefined)
                            removeProperty(node,propName,propValue,previous);
                           else
                            if(isHook(propValue))
                             {removeProperty(node,propName,propValue,previous);
                              if(propValue.hook)
                               propValue.hook
                                (node,propName,previous?previous[propName]:undefined)}
                            else
                             if(isObject(propValue))
                              patchObject(node,props,previous,propName,propValue);
                             else
                              node[propName] = propValue}}
                       function removeProperty(node,propName,propValue,previous)
                        {if(previous)
                          {var previousValue=previous[propName];
                           if(! isHook(previousValue))
                            if(propName === "attributes")
                             for(var attrName in previousValue)
                              node.removeAttribute(attrName);
                            else
                             if(propName === "style")
                              for(var i in previousValue)node.style[i] = "";
                             else
                              if(typeof previousValue === "string")
                               node[propName] = "";
                              else
                               node[propName] = null;
                           else
                            if(previousValue.unhook)
                             previousValue.unhook(node,propName,propValue)}}
                       function patchObject(node,props,previous,propName,propValue)
                        {var previousValue=previous?previous[propName]:undefined;
                         if(propName === "attributes")
                          {for(var attrName in propValue)
                            {var attrValue=propValue[attrName];
                             if(attrValue === undefined)
                              node.removeAttribute(attrName);
                             else
                              node.setAttribute(attrName,attrValue)}
                           return}
                         if
                          (previousValue
                           &&
                           isObject(previousValue)
                           &&
                           getPrototype(previousValue)
                           !==
                           getPrototype(propValue))
                          {node[propName] = propValue;return}
                         if(! isObject(node[propName]))node[propName] = {};
                         var replacer=propName === "style"?"":undefined;
                         for(var k in propValue)
                          {var value=propValue[k];
                           node[propName][k] = value === undefined?replacer:value}}
                       function getPrototype(value)
                        {if(Object.getPrototypeOf)
                          return Object.getPrototypeOf(value);
                         else
                          if(value.__proto__)
                           return value.__proto__;
                          else
                           if(value.constructor)return value.constructor.prototype}},
                     {"../vnode/is-vhook.js":38,"is-object":20}],
                    24:
                    [function(require,module,exports)
                      {var
                        document=require("global/document"),
                        applyProperties=require("./apply-properties"),
                        isVNode=require("../vnode/is-vnode.js"),
                        isVText=require("../vnode/is-vtext.js"),
                        isWidget=require("../vnode/is-widget.js"),
                        handleThunk=require("../vnode/handle-thunk.js");
                       module.exports = createElement;
                       function createElement(vnode,opts)
                        {var
                          doc=opts?opts.document || document:document,
                          warn=opts?opts.warn:null;
                         vnode = handleThunk(vnode).a;
                         if(isWidget(vnode))
                          return vnode.init();
                         else
                          if(isVText(vnode))
                           return doc.createTextNode(vnode.text);
                          else
                           if(! isVNode(vnode))
                            {if(warn)warn("Item is not a valid virtual dom node",vnode);
                             return null}
                         var
                          node=
                           vnode.namespace === null
                            ?doc.createElement(vnode.tagName)
                            :doc.createElementNS(vnode.namespace,vnode.tagName),
                          props=vnode.properties;
                         applyProperties(node,props);
                         var children=vnode.children;
                         for(var i=0;i < children.length;i++)
                          {var childNode=createElement(children[i],opts);
                           if(childNode)node.appendChild(childNode)}
                         return node}},
                     {"../vnode/handle-thunk.js":36,
                      "../vnode/is-vnode.js":39,
                      "../vnode/is-vtext.js":40,
                      "../vnode/is-widget.js":41,
                      "./apply-properties":23,
                      "global/document":7}],
                    25:
                    [function(require,module,exports)
                      {var noChild={};
                       module.exports = domIndex;
                       function domIndex(rootNode,tree,indices,nodes)
                        {if(! indices || indices.length === 0)
                          return {};
                         else
                          {indices.sort(ascending);
                           return recurse(rootNode,tree,indices,nodes,0)}}
                       function recurse(rootNode,tree,indices,nodes,rootIndex)
                        {nodes = nodes || {};
                         if(rootNode)
                          {if(indexInRange(indices,rootIndex,rootIndex))
                            nodes[rootIndex] = rootNode;
                           var vChildren=tree.children;
                           if(vChildren)
                            {var childNodes=rootNode.childNodes;
                             for(var i=0;i < tree.children.length;i++)
                              {rootIndex += 1;
                               var
                                vChild=vChildren[i] || noChild,
                                nextIndex=rootIndex + (vChild.count || 0);
                               if(indexInRange(indices,rootIndex,nextIndex))
                                recurse(childNodes[i],vChild,indices,nodes,rootIndex);
                               rootIndex = nextIndex}}}
                         return nodes}
                       function indexInRange(indices,left,right)
                        {if(indices.length === 0)return false;
                         var
                          minIndex=0,
                          maxIndex=indices.length - 1,
                          currentIndex,
                          currentItem;
                         while(minIndex <= maxIndex)
                          {currentIndex = (maxIndex + minIndex) / 2 >> 0;
                           currentItem = indices[currentIndex];
                           if(minIndex === maxIndex)
                            return currentItem >= left && currentItem <= right;
                           else
                            if(currentItem < left)
                             minIndex = currentIndex + 1;
                            else
                             if(currentItem > right)
                              maxIndex = currentIndex - 1;
                             else
                              return true}
                         return false}
                       function ascending(a,b){return a > b?1:- 1}},
                     {}],
                    26:
                    [function(require,module,exports)
                      {var
                        applyProperties=require("./apply-properties"),
                        isWidget=require("../vnode/is-widget.js"),
                        VPatch=require("../vnode/vpatch.js"),
                        updateWidget=require("./update-widget");
                       module.exports = applyPatch;
                       function applyPatch(vpatch,domNode,renderOptions)
                        {var type=vpatch.type,vNode=vpatch.vNode,patch=vpatch.patch;
                         switch(type)
                          {case VPatch.REMOVE:return removeNode(domNode,vNode);
                           case VPatch.INSERT:
                            return insertNode(domNode,patch,renderOptions);
                           case VPatch.VTEXT:
                            return stringPatch(domNode,vNode,patch,renderOptions);
                           case VPatch.WIDGET:
                            return widgetPatch(domNode,vNode,patch,renderOptions);
                           case VPatch.VNODE:
                            return vNodePatch(domNode,vNode,patch,renderOptions);
                           case VPatch.ORDER:
                            reorderChildren(domNode,patch);return domNode;
                           case VPatch.PROPS:
                            applyProperties(domNode,patch,vNode.properties);
                            return domNode;
                           case VPatch.THUNK:
                            return replaceRoot
                                    (domNode,renderOptions.patch(domNode,patch,renderOptions));
                           default:return domNode}}
                       function removeNode(domNode,vNode)
                        {var parentNode=domNode.parentNode;
                         if(parentNode)parentNode.removeChild(domNode);
                         destroyWidget(domNode,vNode);
                         return null}
                       function insertNode(parentNode,vNode,renderOptions)
                        {var newNode=renderOptions.render(vNode,renderOptions);
                         if(parentNode)parentNode.appendChild(newNode);
                         return parentNode}
                       function stringPatch(domNode,leftVNode,vText,renderOptions)
                        {var newNode;
                         if(domNode.nodeType === 3)
                          {domNode.replaceData(0,domNode.length,vText.text);
                           newNode = domNode}
                         else
                          {var parentNode=domNode.parentNode;
                           newNode = renderOptions.render(vText,renderOptions);
                           if(parentNode && newNode !== domNode)
                            parentNode.replaceChild(newNode,domNode)}
                         return newNode}
                       function widgetPatch(domNode,leftVNode,widget,renderOptions)
                        {var updating=updateWidget(leftVNode,widget),newNode;
                         if(updating)
                          newNode = widget.update(leftVNode,domNode) || domNode;
                         else
                          newNode = renderOptions.render(widget,renderOptions);
                         var parentNode=domNode.parentNode;
                         if(parentNode && newNode !== domNode)
                          parentNode.replaceChild(newNode,domNode);
                         if(! updating)destroyWidget(domNode,leftVNode);
                         return newNode}
                       function vNodePatch(domNode,leftVNode,vNode,renderOptions)
                        {var
                          parentNode=domNode.parentNode,
                          newNode=renderOptions.render(vNode,renderOptions);
                         if(parentNode && newNode !== domNode)
                          parentNode.replaceChild(newNode,domNode);
                         return newNode}
                       function destroyWidget(domNode,w)
                        {if(typeof w.destroy === "function" && isWidget(w))
                          w.destroy(domNode)}
                       function reorderChildren(domNode,moves)
                        {var
                          childNodes=domNode.childNodes,
                          keyMap={},
                          node,
                          remove,
                          insert;
                         for(var i=0;i < moves.removes.length;i++)
                          {remove = moves.removes[i];
                           node = childNodes[remove.from];
                           if(remove.key)keyMap[remove.key] = node;
                           domNode.removeChild(node)}
                         var length=childNodes.length;
                         for(var j=0;j < moves.inserts.length;j++)
                          {insert = moves.inserts[j];
                           node = keyMap[insert.key];
                           domNode.insertBefore
                            (node,insert.to >= length++?null:childNodes[insert.to])}}
                       function replaceRoot(oldRoot,newRoot)
                        {if
                          (oldRoot
                           &&
                           newRoot
                           &&
                           oldRoot
                           !==
                           newRoot
                           &&
                           oldRoot.parentNode)
                          oldRoot.parentNode.replaceChild(newRoot,oldRoot);
                         return newRoot}},
                     {"../vnode/is-widget.js":41,
                      "../vnode/vpatch.js":44,
                      "./apply-properties":23,
                      "./update-widget":28}],
                    27:
                    [function(require,module,exports)
                      {var
                        document=require("global/document"),
                        isArray=require("x-is-array"),
                        render=require("./create-element"),
                        domIndex=require("./dom-index"),
                        patchOp=require("./patch-op");
                       module.exports = patch;
                       function patch(rootNode,patches,renderOptions)
                        {renderOptions = renderOptions || {};
                         renderOptions.patch
                         =
                         renderOptions.patch && renderOptions.patch !== patch
                          ?renderOptions.patch
                          :patchRecursive;
                         renderOptions.render = renderOptions.render || render;
                         return renderOptions.patch(rootNode,patches,renderOptions)}
                       function patchRecursive(rootNode,patches,renderOptions)
                        {var indices=patchIndices(patches);
                         if(indices.length === 0)return rootNode;
                         var
                          index=domIndex(rootNode,patches.a,indices),
                          ownerDocument=rootNode.ownerDocument;
                         if(! renderOptions.document && ownerDocument !== document)
                          renderOptions.document = ownerDocument;
                         for(var i=0;i < indices.length;i++)
                          {var nodeIndex=indices[i];
                           rootNode
                           =
                           applyPatch
                            (rootNode,index[nodeIndex],patches[nodeIndex],renderOptions)}
                         return rootNode}
                       function applyPatch
                        (rootNode,domNode,patchList,renderOptions)
                        {if(! domNode)return rootNode;
                         var newNode;
                         if(isArray(patchList))
                          for(var i=0;i < patchList.length;i++)
                           {newNode = patchOp(patchList[i],domNode,renderOptions);
                            if(domNode === rootNode)rootNode = newNode}
                         else
                          {newNode = patchOp(patchList,domNode,renderOptions);
                           if(domNode === rootNode)rootNode = newNode}
                         return rootNode}
                       function patchIndices(patches)
                        {var indices=[];
                         for(var key in patches)
                          if(key !== "a")indices.push(Number(key));
                         return indices}},
                     {"./create-element":24,
                      "./dom-index":25,
                      "./patch-op":26,
                      "global/document":7,
                      "x-is-array":21}],
                    28:
                    [function(require,module,exports)
                      {var isWidget=require("../vnode/is-widget.js");
                       module.exports = updateWidget;
                       function updateWidget(a,b)
                        {if(isWidget(a) && isWidget(b))
                          return "name" in a && "name" in b
                                  ?a.id === b.id
                                  :a.init === b.init;
                         return false}},
                     {"../vnode/is-widget.js":41}],
                    29:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports = AttributeHook;
                       function AttributeHook(namespace,value)
                        {if(! (this instanceof AttributeHook))
                          return new AttributeHook(namespace,value);
                         this.namespace = namespace;
                         this.value = value}
                       AttributeHook.prototype.hook
                       =
                       function(node,prop,prev)
                        {if
                          (prev
                           &&
                           prev.type
                           ===
                           "AttributeHook"
                           &&
                           prev.value
                           ===
                           this.value
                           &&
                           prev.namespace
                           ===
                           this.namespace)
                          return;
                         node.setAttributeNS(this.namespace,prop,this.value)};
                       AttributeHook.prototype.unhook
                       =
                       function(node,prop,next)
                        {if
                          (next
                           &&
                           next.type
                           ===
                           "AttributeHook"
                           &&
                           next.namespace
                           ===
                           this.namespace)
                          return;
                         var
                          colonPosition=prop.indexOf(":"),
                          localName=
                           colonPosition > - 1?prop.substr(colonPosition + 1):prop;
                         node.removeAttributeNS(this.namespace,localName)};
                       AttributeHook.prototype.type = "AttributeHook"},
                     {}],
                    30:
                    [function(require,module,exports)
                      {"use strict";
                       var EvStore=require("ev-store");
                       module.exports = EvHook;
                       function EvHook(value)
                        {if(! (this instanceof EvHook))return new EvHook(value);
                         this.value = value}
                       EvHook.prototype.hook
                       =
                       function(node,propertyName)
                        {var es=EvStore(node),propName=propertyName.substr(3);
                         es[propName] = this.value};
                       EvHook.prototype.unhook
                       =
                       function(node,propertyName)
                        {var es=EvStore(node),propName=propertyName.substr(3);
                         es[propName] = undefined}},
                     {"ev-store":4}],
                    31:
                    [function(require,module,exports)
                      {"use strict";
                       module.exports = SoftSetHook;
                       function SoftSetHook(value)
                        {if(! (this instanceof SoftSetHook))
                          return new SoftSetHook(value);
                         this.value = value}
                       SoftSetHook.prototype.hook
                       =
                       function(node,propertyName)
                        {if(node[propertyName] !== this.value)
                          node[propertyName] = this.value}},
                     {}],
                    32:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        isArray=require("x-is-array"),
                        VNode=require("../vnode/vnode.js"),
                        VText=require("../vnode/vtext.js"),
                        isVNode=require("../vnode/is-vnode"),
                        isVText=require("../vnode/is-vtext"),
                        isWidget=require("../vnode/is-widget"),
                        isHook=require("../vnode/is-vhook"),
                        isVThunk=require("../vnode/is-thunk"),
                        parseTag=require("./parse-tag.js"),
                        softSetHook=require("./hooks/soft-set-hook.js"),
                        evHook=require("./hooks/ev-hook.js");
                       module.exports = h;
                       function h(tagName,properties,children)
                        {var childNodes=[],tag,props,key,namespace;
                         if(! children && isChildren(properties))
                          {children = properties;props = {}}
                         props = props || properties || {};
                         tag = parseTag(tagName,props);
                         if(props.hasOwnProperty("key"))
                          {key = props.key;props.key = undefined}
                         if(props.hasOwnProperty("namespace"))
                          {namespace = props.namespace;props.namespace = undefined}
                         if
                          (tag
                           ===
                           "INPUT"
                           &&
                           !
                           namespace
                           &&
                           props.hasOwnProperty("value")
                           &&
                           props.value
                           !==
                           undefined
                           &&
                           !
                           isHook(props.value))
                          props.value = softSetHook(props.value);
                         transformProperties(props);
                         if(children !== undefined && children !== null)
                          addChild(children,childNodes,tag,props);
                         return new VNode(tag,props,childNodes,key,namespace)}
                       function addChild(c,childNodes,tag,props)
                        {if(typeof c === "string")
                          childNodes.push(new VText(c));
                         else
                          if(typeof c === "number")
                           childNodes.push(new VText(String(c)));
                          else
                           if(isChild(c))
                            childNodes.push(c);
                           else
                            if(isArray(c))
                             for(var i=0;i < c.length;i++)
                              addChild(c[i],childNodes,tag,props);
                            else
                             if(c === null || c === undefined)
                              return;
                             else
                              throw UnexpectedVirtualElement
                                     ({foreignObject:c,
                                       parentVnode:{tagName:tag,properties:props}})}
                       function transformProperties(props)
                        {for(var propName in props)
                          if(props.hasOwnProperty(propName))
                           {var value=props[propName];
                            if(isHook(value))continue;
                            if(propName.substr(0,3) === "ev-")
                             props[propName] = evHook(value)}}
                       function isChild(x)
                        {return isVNode(x)
                                ||
                                isVText(x)
                                ||
                                isWidget(x)
                                ||
                                isVThunk(x)}
                       function isChildren(x)
                        {return typeof x === "string" || isArray(x) || isChild(x)}
                       function UnexpectedVirtualElement(data)
                        {var err=new Error();
                         err.type = "virtual-hyperscript.unexpected.virtual-element";
                         err.message
                         =
                         "Unexpected virtual child passed to h().\n"
                         +
                         "Expected a VNode / Vthunk / VWidget / string but:\n"
                         +
                         "got:\n"
                         +
                         errorString(data.foreignObject)
                         +
                         ".\n"
                         +
                         "The parent vnode is:\n"
                         +
                         errorString(data.parentVnode);
                         "\n"
                         +
                         "Suggested fix: change your `h(..., [ ... ])` callsite.";
                         err.foreignObject = data.foreignObject;
                         err.parentVnode = data.parentVnode;
                         return err}
                       function errorString(obj)
                        {try
                          {return JSON.stringify(obj,null,"    ")}
                         catch(e){return String(obj)}}},
                     {"../vnode/is-thunk":37,
                      "../vnode/is-vhook":38,
                      "../vnode/is-vnode":39,
                      "../vnode/is-vtext":40,
                      "../vnode/is-widget":41,
                      "../vnode/vnode.js":43,
                      "../vnode/vtext.js":45,
                      "./hooks/ev-hook.js":30,
                      "./hooks/soft-set-hook.js":31,
                      "./parse-tag.js":33,
                      "x-is-array":21}],
                    33:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        split=require("browser-split"),
                        classIdSplit=/([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/,
                        notClassId=/^\.|#/;
                       module.exports = parseTag;
                       function parseTag(tag,props)
                        {if(! tag)return "DIV";
                         var
                          noId=! props.hasOwnProperty("id"),
                          tagParts=split(tag,classIdSplit),
                          tagName=null;
                         if(notClassId.test(tagParts[1]))tagName = "DIV";
                         var classes,part,type,i;
                         for(i = 0;i < tagParts.length;i++)
                          {part = tagParts[i];
                           if(! part)continue;
                           type = part.charAt(0);
                           if(! tagName)
                            tagName = part;
                           else
                            if(type === ".")
                             {classes = classes || [];
                              classes.push(part.substring(1,part.length))}
                            else
                             if(type === "#" && noId)
                              props.id = part.substring(1,part.length)}
                         if(classes)
                          {if(props.className)classes.push(props.className);
                           props.className = classes.join(" ")}
                         return props.namespace?tagName:tagName.toUpperCase()}},
                     {"browser-split":3}],
                    34:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        DEFAULT_NAMESPACE=null,
                        EV_NAMESPACE="http://www.w3.org/2001/xml-events",
                        XLINK_NAMESPACE="http://www.w3.org/1999/xlink",
                        XML_NAMESPACE="http://www.w3.org/XML/1998/namespace",
                        SVG_PROPERTIES=
                         {"about":DEFAULT_NAMESPACE,
                          "accent-height":DEFAULT_NAMESPACE,
                          "accumulate":DEFAULT_NAMESPACE,
                          "additive":DEFAULT_NAMESPACE,
                          "alignment-baseline":DEFAULT_NAMESPACE,
                          "alphabetic":DEFAULT_NAMESPACE,
                          "amplitude":DEFAULT_NAMESPACE,
                          "arabic-form":DEFAULT_NAMESPACE,
                          "ascent":DEFAULT_NAMESPACE,
                          "attributeName":DEFAULT_NAMESPACE,
                          "attributeType":DEFAULT_NAMESPACE,
                          "azimuth":DEFAULT_NAMESPACE,
                          "bandwidth":DEFAULT_NAMESPACE,
                          "baseFrequency":DEFAULT_NAMESPACE,
                          "baseProfile":DEFAULT_NAMESPACE,
                          "baseline-shift":DEFAULT_NAMESPACE,
                          "bbox":DEFAULT_NAMESPACE,
                          "begin":DEFAULT_NAMESPACE,
                          "bias":DEFAULT_NAMESPACE,
                          "by":DEFAULT_NAMESPACE,
                          "calcMode":DEFAULT_NAMESPACE,
                          "cap-height":DEFAULT_NAMESPACE,
                          "class":DEFAULT_NAMESPACE,
                          "clip":DEFAULT_NAMESPACE,
                          "clip-path":DEFAULT_NAMESPACE,
                          "clip-rule":DEFAULT_NAMESPACE,
                          "clipPathUnits":DEFAULT_NAMESPACE,
                          "color":DEFAULT_NAMESPACE,
                          "color-interpolation":DEFAULT_NAMESPACE,
                          "color-interpolation-filters":DEFAULT_NAMESPACE,
                          "color-profile":DEFAULT_NAMESPACE,
                          "color-rendering":DEFAULT_NAMESPACE,
                          "content":DEFAULT_NAMESPACE,
                          "contentScriptType":DEFAULT_NAMESPACE,
                          "contentStyleType":DEFAULT_NAMESPACE,
                          "cursor":DEFAULT_NAMESPACE,
                          "cx":DEFAULT_NAMESPACE,
                          "cy":DEFAULT_NAMESPACE,
                          "d":DEFAULT_NAMESPACE,
                          "datatype":DEFAULT_NAMESPACE,
                          "defaultAction":DEFAULT_NAMESPACE,
                          "descent":DEFAULT_NAMESPACE,
                          "diffuseConstant":DEFAULT_NAMESPACE,
                          "direction":DEFAULT_NAMESPACE,
                          "display":DEFAULT_NAMESPACE,
                          "divisor":DEFAULT_NAMESPACE,
                          "dominant-baseline":DEFAULT_NAMESPACE,
                          "dur":DEFAULT_NAMESPACE,
                          "dx":DEFAULT_NAMESPACE,
                          "dy":DEFAULT_NAMESPACE,
                          "edgeMode":DEFAULT_NAMESPACE,
                          "editable":DEFAULT_NAMESPACE,
                          "elevation":DEFAULT_NAMESPACE,
                          "enable-background":DEFAULT_NAMESPACE,
                          "end":DEFAULT_NAMESPACE,
                          "ev:event":EV_NAMESPACE,
                          "event":DEFAULT_NAMESPACE,
                          "exponent":DEFAULT_NAMESPACE,
                          "externalResourcesRequired":DEFAULT_NAMESPACE,
                          "fill":DEFAULT_NAMESPACE,
                          "fill-opacity":DEFAULT_NAMESPACE,
                          "fill-rule":DEFAULT_NAMESPACE,
                          "filter":DEFAULT_NAMESPACE,
                          "filterRes":DEFAULT_NAMESPACE,
                          "filterUnits":DEFAULT_NAMESPACE,
                          "flood-color":DEFAULT_NAMESPACE,
                          "flood-opacity":DEFAULT_NAMESPACE,
                          "focusHighlight":DEFAULT_NAMESPACE,
                          "focusable":DEFAULT_NAMESPACE,
                          "font-family":DEFAULT_NAMESPACE,
                          "font-size":DEFAULT_NAMESPACE,
                          "font-size-adjust":DEFAULT_NAMESPACE,
                          "font-stretch":DEFAULT_NAMESPACE,
                          "font-style":DEFAULT_NAMESPACE,
                          "font-variant":DEFAULT_NAMESPACE,
                          "font-weight":DEFAULT_NAMESPACE,
                          "format":DEFAULT_NAMESPACE,
                          "from":DEFAULT_NAMESPACE,
                          "fx":DEFAULT_NAMESPACE,
                          "fy":DEFAULT_NAMESPACE,
                          "g1":DEFAULT_NAMESPACE,
                          "g2":DEFAULT_NAMESPACE,
                          "glyph-name":DEFAULT_NAMESPACE,
                          "glyph-orientation-horizontal":DEFAULT_NAMESPACE,
                          "glyph-orientation-vertical":DEFAULT_NAMESPACE,
                          "glyphRef":DEFAULT_NAMESPACE,
                          "gradientTransform":DEFAULT_NAMESPACE,
                          "gradientUnits":DEFAULT_NAMESPACE,
                          "handler":DEFAULT_NAMESPACE,
                          "hanging":DEFAULT_NAMESPACE,
                          "height":DEFAULT_NAMESPACE,
                          "horiz-adv-x":DEFAULT_NAMESPACE,
                          "horiz-origin-x":DEFAULT_NAMESPACE,
                          "horiz-origin-y":DEFAULT_NAMESPACE,
                          "id":DEFAULT_NAMESPACE,
                          "ideographic":DEFAULT_NAMESPACE,
                          "image-rendering":DEFAULT_NAMESPACE,
                          "in":DEFAULT_NAMESPACE,
                          "in2":DEFAULT_NAMESPACE,
                          "initialVisibility":DEFAULT_NAMESPACE,
                          "intercept":DEFAULT_NAMESPACE,
                          "k":DEFAULT_NAMESPACE,
                          "k1":DEFAULT_NAMESPACE,
                          "k2":DEFAULT_NAMESPACE,
                          "k3":DEFAULT_NAMESPACE,
                          "k4":DEFAULT_NAMESPACE,
                          "kernelMatrix":DEFAULT_NAMESPACE,
                          "kernelUnitLength":DEFAULT_NAMESPACE,
                          "kerning":DEFAULT_NAMESPACE,
                          "keyPoints":DEFAULT_NAMESPACE,
                          "keySplines":DEFAULT_NAMESPACE,
                          "keyTimes":DEFAULT_NAMESPACE,
                          "lang":DEFAULT_NAMESPACE,
                          "lengthAdjust":DEFAULT_NAMESPACE,
                          "letter-spacing":DEFAULT_NAMESPACE,
                          "lighting-color":DEFAULT_NAMESPACE,
                          "limitingConeAngle":DEFAULT_NAMESPACE,
                          "local":DEFAULT_NAMESPACE,
                          "marker-end":DEFAULT_NAMESPACE,
                          "marker-mid":DEFAULT_NAMESPACE,
                          "marker-start":DEFAULT_NAMESPACE,
                          "markerHeight":DEFAULT_NAMESPACE,
                          "markerUnits":DEFAULT_NAMESPACE,
                          "markerWidth":DEFAULT_NAMESPACE,
                          "mask":DEFAULT_NAMESPACE,
                          "maskContentUnits":DEFAULT_NAMESPACE,
                          "maskUnits":DEFAULT_NAMESPACE,
                          "mathematical":DEFAULT_NAMESPACE,
                          "max":DEFAULT_NAMESPACE,
                          "media":DEFAULT_NAMESPACE,
                          "mediaCharacterEncoding":DEFAULT_NAMESPACE,
                          "mediaContentEncodings":DEFAULT_NAMESPACE,
                          "mediaSize":DEFAULT_NAMESPACE,
                          "mediaTime":DEFAULT_NAMESPACE,
                          "method":DEFAULT_NAMESPACE,
                          "min":DEFAULT_NAMESPACE,
                          "mode":DEFAULT_NAMESPACE,
                          "name":DEFAULT_NAMESPACE,
                          "nav-down":DEFAULT_NAMESPACE,
                          "nav-down-left":DEFAULT_NAMESPACE,
                          "nav-down-right":DEFAULT_NAMESPACE,
                          "nav-left":DEFAULT_NAMESPACE,
                          "nav-next":DEFAULT_NAMESPACE,
                          "nav-prev":DEFAULT_NAMESPACE,
                          "nav-right":DEFAULT_NAMESPACE,
                          "nav-up":DEFAULT_NAMESPACE,
                          "nav-up-left":DEFAULT_NAMESPACE,
                          "nav-up-right":DEFAULT_NAMESPACE,
                          "numOctaves":DEFAULT_NAMESPACE,
                          "observer":DEFAULT_NAMESPACE,
                          "offset":DEFAULT_NAMESPACE,
                          "opacity":DEFAULT_NAMESPACE,
                          "operator":DEFAULT_NAMESPACE,
                          "order":DEFAULT_NAMESPACE,
                          "orient":DEFAULT_NAMESPACE,
                          "orientation":DEFAULT_NAMESPACE,
                          "origin":DEFAULT_NAMESPACE,
                          "overflow":DEFAULT_NAMESPACE,
                          "overlay":DEFAULT_NAMESPACE,
                          "overline-position":DEFAULT_NAMESPACE,
                          "overline-thickness":DEFAULT_NAMESPACE,
                          "panose-1":DEFAULT_NAMESPACE,
                          "path":DEFAULT_NAMESPACE,
                          "pathLength":DEFAULT_NAMESPACE,
                          "patternContentUnits":DEFAULT_NAMESPACE,
                          "patternTransform":DEFAULT_NAMESPACE,
                          "patternUnits":DEFAULT_NAMESPACE,
                          "phase":DEFAULT_NAMESPACE,
                          "playbackOrder":DEFAULT_NAMESPACE,
                          "pointer-events":DEFAULT_NAMESPACE,
                          "points":DEFAULT_NAMESPACE,
                          "pointsAtX":DEFAULT_NAMESPACE,
                          "pointsAtY":DEFAULT_NAMESPACE,
                          "pointsAtZ":DEFAULT_NAMESPACE,
                          "preserveAlpha":DEFAULT_NAMESPACE,
                          "preserveAspectRatio":DEFAULT_NAMESPACE,
                          "primitiveUnits":DEFAULT_NAMESPACE,
                          "propagate":DEFAULT_NAMESPACE,
                          "property":DEFAULT_NAMESPACE,
                          "r":DEFAULT_NAMESPACE,
                          "radius":DEFAULT_NAMESPACE,
                          "refX":DEFAULT_NAMESPACE,
                          "refY":DEFAULT_NAMESPACE,
                          "rel":DEFAULT_NAMESPACE,
                          "rendering-intent":DEFAULT_NAMESPACE,
                          "repeatCount":DEFAULT_NAMESPACE,
                          "repeatDur":DEFAULT_NAMESPACE,
                          "requiredExtensions":DEFAULT_NAMESPACE,
                          "requiredFeatures":DEFAULT_NAMESPACE,
                          "requiredFonts":DEFAULT_NAMESPACE,
                          "requiredFormats":DEFAULT_NAMESPACE,
                          "resource":DEFAULT_NAMESPACE,
                          "restart":DEFAULT_NAMESPACE,
                          "result":DEFAULT_NAMESPACE,
                          "rev":DEFAULT_NAMESPACE,
                          "role":DEFAULT_NAMESPACE,
                          "rotate":DEFAULT_NAMESPACE,
                          "rx":DEFAULT_NAMESPACE,
                          "ry":DEFAULT_NAMESPACE,
                          "scale":DEFAULT_NAMESPACE,
                          "seed":DEFAULT_NAMESPACE,
                          "shape-rendering":DEFAULT_NAMESPACE,
                          "slope":DEFAULT_NAMESPACE,
                          "snapshotTime":DEFAULT_NAMESPACE,
                          "spacing":DEFAULT_NAMESPACE,
                          "specularConstant":DEFAULT_NAMESPACE,
                          "specularExponent":DEFAULT_NAMESPACE,
                          "spreadMethod":DEFAULT_NAMESPACE,
                          "startOffset":DEFAULT_NAMESPACE,
                          "stdDeviation":DEFAULT_NAMESPACE,
                          "stemh":DEFAULT_NAMESPACE,
                          "stemv":DEFAULT_NAMESPACE,
                          "stitchTiles":DEFAULT_NAMESPACE,
                          "stop-color":DEFAULT_NAMESPACE,
                          "stop-opacity":DEFAULT_NAMESPACE,
                          "strikethrough-position":DEFAULT_NAMESPACE,
                          "strikethrough-thickness":DEFAULT_NAMESPACE,
                          "string":DEFAULT_NAMESPACE,
                          "stroke":DEFAULT_NAMESPACE,
                          "stroke-dasharray":DEFAULT_NAMESPACE,
                          "stroke-dashoffset":DEFAULT_NAMESPACE,
                          "stroke-linecap":DEFAULT_NAMESPACE,
                          "stroke-linejoin":DEFAULT_NAMESPACE,
                          "stroke-miterlimit":DEFAULT_NAMESPACE,
                          "stroke-opacity":DEFAULT_NAMESPACE,
                          "stroke-width":DEFAULT_NAMESPACE,
                          "surfaceScale":DEFAULT_NAMESPACE,
                          "syncBehavior":DEFAULT_NAMESPACE,
                          "syncBehaviorDefault":DEFAULT_NAMESPACE,
                          "syncMaster":DEFAULT_NAMESPACE,
                          "syncTolerance":DEFAULT_NAMESPACE,
                          "syncToleranceDefault":DEFAULT_NAMESPACE,
                          "systemLanguage":DEFAULT_NAMESPACE,
                          "tableValues":DEFAULT_NAMESPACE,
                          "target":DEFAULT_NAMESPACE,
                          "targetX":DEFAULT_NAMESPACE,
                          "targetY":DEFAULT_NAMESPACE,
                          "text-anchor":DEFAULT_NAMESPACE,
                          "text-decoration":DEFAULT_NAMESPACE,
                          "text-rendering":DEFAULT_NAMESPACE,
                          "textLength":DEFAULT_NAMESPACE,
                          "timelineBegin":DEFAULT_NAMESPACE,
                          "title":DEFAULT_NAMESPACE,
                          "to":DEFAULT_NAMESPACE,
                          "transform":DEFAULT_NAMESPACE,
                          "transformBehavior":DEFAULT_NAMESPACE,
                          "type":DEFAULT_NAMESPACE,
                          "typeof":DEFAULT_NAMESPACE,
                          "u1":DEFAULT_NAMESPACE,
                          "u2":DEFAULT_NAMESPACE,
                          "underline-position":DEFAULT_NAMESPACE,
                          "underline-thickness":DEFAULT_NAMESPACE,
                          "unicode":DEFAULT_NAMESPACE,
                          "unicode-bidi":DEFAULT_NAMESPACE,
                          "unicode-range":DEFAULT_NAMESPACE,
                          "units-per-em":DEFAULT_NAMESPACE,
                          "v-alphabetic":DEFAULT_NAMESPACE,
                          "v-hanging":DEFAULT_NAMESPACE,
                          "v-ideographic":DEFAULT_NAMESPACE,
                          "v-mathematical":DEFAULT_NAMESPACE,
                          "values":DEFAULT_NAMESPACE,
                          "version":DEFAULT_NAMESPACE,
                          "vert-adv-y":DEFAULT_NAMESPACE,
                          "vert-origin-x":DEFAULT_NAMESPACE,
                          "vert-origin-y":DEFAULT_NAMESPACE,
                          "viewBox":DEFAULT_NAMESPACE,
                          "viewTarget":DEFAULT_NAMESPACE,
                          "visibility":DEFAULT_NAMESPACE,
                          "width":DEFAULT_NAMESPACE,
                          "widths":DEFAULT_NAMESPACE,
                          "word-spacing":DEFAULT_NAMESPACE,
                          "writing-mode":DEFAULT_NAMESPACE,
                          "x":DEFAULT_NAMESPACE,
                          "x-height":DEFAULT_NAMESPACE,
                          "x1":DEFAULT_NAMESPACE,
                          "x2":DEFAULT_NAMESPACE,
                          "xChannelSelector":DEFAULT_NAMESPACE,
                          "xlink:actuate":XLINK_NAMESPACE,
                          "xlink:arcrole":XLINK_NAMESPACE,
                          "xlink:href":XLINK_NAMESPACE,
                          "xlink:role":XLINK_NAMESPACE,
                          "xlink:show":XLINK_NAMESPACE,
                          "xlink:title":XLINK_NAMESPACE,
                          "xlink:type":XLINK_NAMESPACE,
                          "xml:base":XML_NAMESPACE,
                          "xml:id":XML_NAMESPACE,
                          "xml:lang":XML_NAMESPACE,
                          "xml:space":XML_NAMESPACE,
                          "y":DEFAULT_NAMESPACE,
                          "y1":DEFAULT_NAMESPACE,
                          "y2":DEFAULT_NAMESPACE,
                          "yChannelSelector":DEFAULT_NAMESPACE,
                          "z":DEFAULT_NAMESPACE,
                          "zoomAndPan":DEFAULT_NAMESPACE};
                       module.exports = SVGAttributeNamespace;
                       function SVGAttributeNamespace(value)
                        {if(SVG_PROPERTIES.hasOwnProperty(value))
                          return SVG_PROPERTIES[value]}},
                     {}],
                    35:
                    [function(require,module,exports)
                      {"use strict";
                       var
                        isArray=require("x-is-array"),
                        h=require("./index.js"),
                        SVGAttributeNamespace=require("./svg-attribute-namespace"),
                        attributeHook=require("./hooks/attribute-hook"),
                        SVG_NAMESPACE="http://www.w3.org/2000/svg";
                       module.exports = svg;
                       function svg(tagName,properties,children)
                        {if(! children && isChildren(properties))
                          {children = properties;properties = {}}
                         properties = properties || {};
                         properties.namespace = SVG_NAMESPACE;
                         var
                          attributes=
                           properties.attributes || (properties.attributes = {});
                         for(var key in properties)
                          {if(! properties.hasOwnProperty(key))continue;
                           var namespace=SVGAttributeNamespace(key);
                           if(namespace === undefined)continue;
                           var value=properties[key];
                           if
                            (typeof value
                             !==
                             "string"
                             &&
                             typeof value
                             !==
                             "number"
                             &&
                             typeof value
                             !==
                             "boolean")
                            continue;
                           if(namespace !== null)
                            {properties[key] = attributeHook(namespace,value);continue}
                           attributes[key] = value;
                           properties[key] = undefined}
                         return h(tagName,properties,children)}
                       function isChildren(x)
                        {return typeof x === "string" || isArray(x)}},
                     {"./hooks/attribute-hook":29,
                      "./index.js":32,
                      "./svg-attribute-namespace":34,
                      "x-is-array":21}],
                    36:
                    [function(require,module,exports)
                      {var
                        isVNode=require("./is-vnode"),
                        isVText=require("./is-vtext"),
                        isWidget=require("./is-widget"),
                        isThunk=require("./is-thunk");
                       module.exports = handleThunk;
                       function handleThunk(a,b)
                        {var renderedA=a,renderedB=b;
                         if(isThunk(b))renderedB = renderThunk(b,a);
                         if(isThunk(a))renderedA = renderThunk(a,null);
                         return {a:renderedA,b:renderedB}}
                       function renderThunk(thunk,previous)
                        {var renderedThunk=thunk.vnode;
                         if(! renderedThunk)
                          renderedThunk = thunk.vnode = thunk.render(previous);
                         if
                          (!
                           (isVNode(renderedThunk)
                            ||
                            isVText(renderedThunk)
                            ||
                            isWidget(renderedThunk)))
                          throw new Error("thunk did not return a valid node");
                         return renderedThunk}},
                     {"./is-thunk":37,
                      "./is-vnode":39,
                      "./is-vtext":40,
                      "./is-widget":41}],
                    37:
                    [function(require,module,exports)
                      {module.exports = isThunk;
                       function isThunk(t){return t && t.type === "Thunk"}},
                     {}],
                    38:
                    [function(require,module,exports)
                      {module.exports = isHook;
                       function isHook(hook)
                        {return hook
                                &&
                                (typeof hook.hook
                                 ===
                                 "function"
                                 &&
                                 !
                                 hook.hasOwnProperty("hook")
                                 ||
                                 typeof hook.unhook
                                 ===
                                 "function"
                                 &&
                                 !
                                 hook.hasOwnProperty("unhook"))}},
                     {}],
                    39:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = isVirtualNode;
                       function isVirtualNode(x)
                        {return x
                                &&
                                x.type
                                ===
                                "VirtualNode"
                                &&
                                x.version
                                ===
                                version}},
                     {"./version":42}],
                    40:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = isVirtualText;
                       function isVirtualText(x)
                        {return x
                                &&
                                x.type
                                ===
                                "VirtualText"
                                &&
                                x.version
                                ===
                                version}},
                     {"./version":42}],
                    41:
                    [function(require,module,exports)
                      {module.exports = isWidget;
                       function isWidget(w){return w && w.type === "Widget"}},
                     {}],
                    42:
                    [function(require,module,exports){module.exports = "2"},{}],
                    43:
                    [function(require,module,exports)
                      {var
                        version=require("./version"),
                        isVNode=require("./is-vnode"),
                        isWidget=require("./is-widget"),
                        isThunk=require("./is-thunk"),
                        isVHook=require("./is-vhook");
                       module.exports = VirtualNode;
                       var noProperties={},noChildren=[];
                       function VirtualNode
                        (tagName,properties,children,key,namespace)
                        {this.tagName = tagName;
                         this.properties = properties || noProperties;
                         this.children = children || noChildren;
                         this.key = key != null?String(key):undefined;
                         this.namespace
                         =
                         typeof namespace === "string"?namespace:null;
                         var
                          count=children && children.length || 0,
                          descendants=0,
                          hasWidgets=false,
                          hasThunks=false,
                          descendantHooks=false,
                          hooks;
                         for(var propName in properties)
                          if(properties.hasOwnProperty(propName))
                           {var property=properties[propName];
                            if(isVHook(property) && property.unhook)
                             {if(! hooks)hooks = {};hooks[propName] = property}}
                         for(var i=0;i < count;i++)
                          {var child=children[i];
                           if(isVNode(child))
                            {descendants += child.count || 0;
                             if(! hasWidgets && child.hasWidgets)hasWidgets = true;
                             if(! hasThunks && child.hasThunks)hasThunks = true;
                             if
                              (!
                               descendantHooks
                               &&
                               (child.hooks || child.descendantHooks))
                              descendantHooks = true}
                           else
                            if(! hasWidgets && isWidget(child))
                             {if(typeof child.destroy === "function")hasWidgets = true}
                            else
                             if(! hasThunks && isThunk(child))hasThunks = true}
                         this.count = count + descendants;
                         this.hasWidgets = hasWidgets;
                         this.hasThunks = hasThunks;
                         this.hooks = hooks;
                         this.descendantHooks = descendantHooks}
                       VirtualNode.prototype.version = version;
                       VirtualNode.prototype.type = "VirtualNode"},
                     {"./is-thunk":37,
                      "./is-vhook":38,
                      "./is-vnode":39,
                      "./is-widget":41,
                      "./version":42}],
                    44:
                    [function(require,module,exports)
                      {var version=require("./version");
                       VirtualPatch.NONE = 0;
                       VirtualPatch.VTEXT = 1;
                       VirtualPatch.VNODE = 2;
                       VirtualPatch.WIDGET = 3;
                       VirtualPatch.PROPS = 4;
                       VirtualPatch.ORDER = 5;
                       VirtualPatch.INSERT = 6;
                       VirtualPatch.REMOVE = 7;
                       VirtualPatch.THUNK = 8;
                       module.exports = VirtualPatch;
                       function VirtualPatch(type,vNode,patch)
                        {this.type = Number(type);
                         this.vNode = vNode;
                         this.patch = patch}
                       VirtualPatch.prototype.version = version;
                       VirtualPatch.prototype.type = "VirtualPatch"},
                     {"./version":42}],
                    45:
                    [function(require,module,exports)
                      {var version=require("./version");
                       module.exports = VirtualText;
                       function VirtualText(text){this.text = String(text)}
                       VirtualText.prototype.version = version;
                       VirtualText.prototype.type = "VirtualText"},
                     {"./version":42}],
                    46:
                    [function(require,module,exports)
                      {var
                        isObject=require("is-object"),
                        isHook=require("../vnode/is-vhook");
                       module.exports = diffProps;
                       function diffProps(a,b)
                        {var diff;
                         for(var aKey in a)
                          {if(! (aKey in b)){diff = diff || {};diff[aKey] = undefined}
                           var aValue=a[aKey],bValue=b[aKey];
                           if(aValue === bValue)
                            continue;
                           else
                            if(isObject(aValue) && isObject(bValue))
                             if(getPrototype(bValue) !== getPrototype(aValue))
                              {diff = diff || {};diff[aKey] = bValue}
                             else
                              if(isHook(bValue))
                               {diff = diff || {};diff[aKey] = bValue}
                              else
                               {var objectDiff=diffProps(aValue,bValue);
                                if(objectDiff){diff = diff || {};diff[aKey] = objectDiff}}
                            else
                             {diff = diff || {};diff[aKey] = bValue}}
                         for(var bKey in b)
                          if(! (bKey in a)){diff = diff || {};diff[bKey] = b[bKey]}
                         return diff}
                       function getPrototype(value)
                        {if(Object.getPrototypeOf)
                          return Object.getPrototypeOf(value);
                         else
                          if(value.__proto__)
                           return value.__proto__;
                          else
                           if(value.constructor)return value.constructor.prototype}},
                     {"../vnode/is-vhook":38,"is-object":20}],
                    47:
                    [function(require,module,exports)
                      {var
                        isArray=require("x-is-array"),
                        VPatch=require("../vnode/vpatch"),
                        isVNode=require("../vnode/is-vnode"),
                        isVText=require("../vnode/is-vtext"),
                        isWidget=require("../vnode/is-widget"),
                        isThunk=require("../vnode/is-thunk"),
                        handleThunk=require("../vnode/handle-thunk"),
                        diffProps=require("./diff-props");
                       module.exports = diff;
                       function diff(a,b)
                        {var patch={a:a};walk(a,b,patch,0);return patch}
                       function walk(a,b,patch,index)
                        {if(a === b)return;
                         var apply=patch[index],applyClear=false;
                         if(isThunk(a) || isThunk(b))
                          thunks(a,b,patch,index);
                         else
                          if(b == null)
                           {if(! isWidget(a))
                             {clearState(a,patch,index);apply = patch[index]}
                            apply = appendPatch(apply,new VPatch(VPatch.REMOVE,a,b))}
                          else
                           if(isVNode(b))
                            if(isVNode(a))
                             if
                              (a.tagName
                               ===
                               b.tagName
                               &&
                               a.namespace
                               ===
                               b.namespace
                               &&
                               a.key
                               ===
                               b.key)
                              {var propsPatch=diffProps(a.properties,b.properties);
                               if(propsPatch)
                                apply
                                =
                                appendPatch(apply,new VPatch(VPatch.PROPS,a,propsPatch));
                               apply = diffChildren(a,b,patch,apply,index)}
                             else
                              {apply = appendPatch(apply,new VPatch(VPatch.VNODE,a,b));
                               applyClear = true}
                            else
                             {apply = appendPatch(apply,new VPatch(VPatch.VNODE,a,b));
                              applyClear = true}
                           else
                            if(isVText(b))
                             {if(! isVText(a))
                               {apply = appendPatch(apply,new VPatch(VPatch.VTEXT,a,b));
                                applyClear = true}
                              else
                               if(a.text !== b.text)
                                apply = appendPatch(apply,new VPatch(VPatch.VTEXT,a,b))}
                            else
                             if(isWidget(b))
                              {if(! isWidget(a))applyClear = true;
                               apply = appendPatch(apply,new VPatch(VPatch.WIDGET,a,b))}
                         if(apply)patch[index] = apply;
                         if(applyClear)clearState(a,patch,index)}
                       function diffChildren(a,b,patch,apply,index)
                        {var
                          aChildren=a.children,
                          orderedSet=reorder(aChildren,b.children),
                          bChildren=orderedSet.children,
                          aLen=aChildren.length,
                          bLen=bChildren.length,
                          len=aLen > bLen?aLen:bLen;
                         for(var i=0;i < len;i++)
                          {var leftNode=aChildren[i],rightNode=bChildren[i];
                           index += 1;
                           if(! leftNode)
                            {if(rightNode)
                              apply
                              =
                              appendPatch(apply,new VPatch(VPatch.INSERT,null,rightNode))}
                           else
                            walk(leftNode,rightNode,patch,index);
                           if(isVNode(leftNode) && leftNode.count)
                            index += leftNode.count}
                         if(orderedSet.moves)
                          apply
                          =
                          appendPatch
                           (apply,new VPatch(VPatch.ORDER,a,orderedSet.moves));
                         return apply}
                       function clearState(vNode,patch,index)
                        {unhook(vNode,patch,index);
                         destroyWidgets(vNode,patch,index)}
                       function destroyWidgets(vNode,patch,index)
                        {if(isWidget(vNode))
                          {if(typeof vNode.destroy === "function")
                            patch[index]
                            =
                            appendPatch
                             (patch[index],new VPatch(VPatch.REMOVE,vNode,null))}
                         else
                          if(isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks))
                           {var children=vNode.children,len=children.length;
                            for(var i=0;i < len;i++)
                             {var child=children[i];
                              index += 1;
                              destroyWidgets(child,patch,index);
                              if(isVNode(child) && child.count)index += child.count}}
                          else
                           if(isThunk(vNode))thunks(vNode,null,patch,index)}
                       function thunks(a,b,patch,index)
                        {var
                          nodes=handleThunk(a,b),
                          thunkPatch=diff(nodes.a,nodes.b);
                         if(hasPatches(thunkPatch))
                          patch[index] = new VPatch(VPatch.THUNK,null,thunkPatch)}
                       function hasPatches(patch)
                        {for(var index in patch)if(index !== "a")return true;
                         return false}
                       function unhook(vNode,patch,index)
                        {if(isVNode(vNode))
                          {if(vNode.hooks)
                            patch[index]
                            =
                            appendPatch
                             (patch[index],
                              new VPatch(VPatch.PROPS,vNode,undefinedKeys(vNode.hooks)));
                           if(vNode.descendantHooks || vNode.hasThunks)
                            {var children=vNode.children,len=children.length;
                             for(var i=0;i < len;i++)
                              {var child=children[i];
                               index += 1;
                               unhook(child,patch,index);
                               if(isVNode(child) && child.count)index += child.count}}}
                         else
                          if(isThunk(vNode))thunks(vNode,null,patch,index)}
                       function undefinedKeys(obj)
                        {var result={};
                         for(var key in obj)result[key] = undefined;
                         return result}
                       function reorder(aChildren,bChildren)
                        {var
                          bChildIndex=keyIndex(bChildren),
                          bKeys=bChildIndex.keys,
                          bFree=bChildIndex.free;
                         if(bFree.length === bChildren.length)
                          return {children:bChildren,moves:null};
                         var
                          aChildIndex=keyIndex(aChildren),
                          aKeys=aChildIndex.keys,
                          aFree=aChildIndex.free;
                         if(aFree.length === aChildren.length)
                          return {children:bChildren,moves:null};
                         var
                          newChildren=[],
                          freeIndex=0,
                          freeCount=bFree.length,
                          deletedItems=0;
                         for(var i=0;i < aChildren.length;i++)
                          {var aItem=aChildren[i],itemIndex;
                           if(aItem.key)
                            if(bKeys.hasOwnProperty(aItem.key))
                             {itemIndex = bKeys[aItem.key];
                              newChildren.push(bChildren[itemIndex])}
                            else
                             {itemIndex = i - deletedItems++;newChildren.push(null)}
                           else
                            if(freeIndex < freeCount)
                             {itemIndex = bFree[freeIndex++];
                              newChildren.push(bChildren[itemIndex])}
                            else
                             {itemIndex = i - deletedItems++;newChildren.push(null)}}
                         var
                          lastFreeIndex=
                           freeIndex >= bFree.length?bChildren.length:bFree[freeIndex];
                         for(var j=0;j < bChildren.length;j++)
                          {var newItem=bChildren[j];
                           if(newItem.key)
                            {if(! aKeys.hasOwnProperty(newItem.key))
                              newChildren.push(newItem)}
                           else
                            if(j >= lastFreeIndex)newChildren.push(newItem)}
                         var
                          simulate=newChildren.slice(),
                          simulateIndex=0,
                          removes=[],
                          inserts=[],
                          simulateItem;
                         for(var k=0;k < bChildren.length;)
                          {var wantedItem=bChildren[k];
                           simulateItem = simulate[simulateIndex];
                           while(simulateItem === null && simulate.length)
                            {removes.push(remove(simulate,simulateIndex,null));
                             simulateItem = simulate[simulateIndex]}
                           if(! simulateItem || simulateItem.key !== wantedItem.key)
                            {if(wantedItem.key)
                              {if(simulateItem && simulateItem.key)
                                if(bKeys[simulateItem.key] !== k + 1)
                                 {removes.push
                                   (remove(simulate,simulateIndex,simulateItem.key));
                                  simulateItem = simulate[simulateIndex];
                                  if(! simulateItem || simulateItem.key !== wantedItem.key)
                                   inserts.push({key:wantedItem.key,to:k});
                                  else
                                   simulateIndex++}
                                else
                                 inserts.push({key:wantedItem.key,to:k});
                               else
                                inserts.push({key:wantedItem.key,to:k});
                               k++}
                             else
                              if(simulateItem && simulateItem.key)
                               removes.push
                                (remove(simulate,simulateIndex,simulateItem.key))}
                           else
                            {simulateIndex++;k++}}
                         while(simulateIndex < simulate.length)
                          {simulateItem = simulate[simulateIndex];
                           removes.push
                            (remove
                              (simulate,simulateIndex,simulateItem && simulateItem.key))}
                         if(removes.length === deletedItems && ! inserts.length)
                          return {children:newChildren,moves:null};
                         return {children:newChildren,
                                 moves:{removes:removes,inserts:inserts}}}
                       function remove(arr,index,key)
                        {arr.splice(index,1);return {from:index,key:key}}
                       function keyIndex(children)
                        {var keys={},free=[],length=children.length;
                         for(var i=0;i < length;i++)
                          {var child=children[i];
                           if(child.key)keys[child.key] = i;else free.push(i)}
                         return {keys:keys,free:free}}
                       function appendPatch(apply,patch)
                        {if(apply)
                          {if(isArray(apply))
                            apply.push(patch);
                           else
                            apply = [apply,patch];
                           return apply}
                         else
                          return patch}},
                     {"../vnode/handle-thunk":36,
                      "../vnode/is-thunk":37,
                      "../vnode/is-vnode":39,
                      "../vnode/is-vtext":40,
                      "../vnode/is-widget":41,
                      "../vnode/vpatch":44,
                      "./diff-props":46,
                      "x-is-array":21}],
                    48:
                    [function(require,module,exports)
                      {(function(global)
                          {var
                            vdom=
                             {VNode:require("virtual-dom/vnode/vnode"),
                              VText:require("virtual-dom/vnode/vtext"),
                              diff:require("virtual-dom/diff"),
                              patch:require("virtual-dom/patch"),
                              createElement:require("virtual-dom/create-element"),
                              svg:require("virtual-dom/virtual-hyperscript/svg")};
                           global.VirtualDom = vdom;
                           module.exports = vdom}.call
                         (this,
                          typeof global !== "undefined"
                           ?global
                           :typeof self !== "undefined"
                             ?self
                             :typeof window !== "undefined"?window:{}))},
                     {"virtual-dom/create-element":1,
                      "virtual-dom/diff":2,
                      "virtual-dom/patch":22,
                      "virtual-dom/virtual-hyperscript/svg":35,
                      "virtual-dom/vnode/vnode":43,
                      "virtual-dom/vnode/vtext":45}]},
                   {},
                   [48])
                 (48)}))}
  (globalThis));
(function(globalThis)
   {var joo_global_object=globalThis;
    joo_global_object.SoftSetHook
    =
    function(value)
     {if(! (this instanceof SoftSetHook))return new SoftSetHook(value);
      this.value = value};
    joo_global_object.SoftSetHook.prototype.hook
    =
    function(node,propertyName)
     {if(node[propertyName] !== this.value)node[propertyName] = this.value};
    function GenericHook(init,update,destroy,id,extra)
     {if(! (this instanceof GenericHook))
       return new GenericHook(init,update,destroy,id,extra);
      this.init = init;
      this.update = update;
      this.destroy = destroy;
      this.id = id;
      this.extra = extra}
    var hook_state_key="vdom_hook_state_key";
    if(this.Symbol)hook_state_key = Symbol(hook_state_key);
    GenericHook.write_state
    =
    function(node,propName,state)
     {if(! node[hook_state_key])node[hook_state_key] = {};
      node[hook_state_key][propName] = state};
    GenericHook.read_state
    =
    function(node,propName){return node[hook_state_key][propName]};
    GenericHook.remove_state
    =
    function(node,propName){delete node[hook_state_key][propName]};
    GenericHook.canTransition
    =
    function(from,to)
     {return from instanceof this
             &&
             to instanceof this
             &&
             from.id
             ===
             to.id
             &&
             to.update};
    GenericHook.prototype.hook
    =
    function(node,propName,prev)
     {if(GenericHook.canTransition(prev,this))
       {var state=GenericHook.read_state(node,propName);
        state = this.update(state,node);
        GenericHook.write_state(node,propName,state)}
      else
       {var state=this.init(node);
        GenericHook.write_state(node,propName,state)}};
    GenericHook.prototype.unhook
    =
    function(node,propName,next)
     {if(GenericHook.canTransition(this,next))
       ;
      else
       {var state=GenericHook.read_state(node,propName);
        this.destroy(state,node);
        GenericHook.remove_state(node,propName)}};
    joo_global_object.GenericHook = GenericHook}
  (globalThis));
(function(globalThis)
   {"use strict";
    var joo_global_object=globalThis;
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += f.uppercase?"0X":"0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_ml_condition_broadcast(t){return 0}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a)
     {if(! (a instanceof Uint8Array))a = new Uint8Array(a);
      return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_convert_bytes_to_array(s)
     {var a=new Uint8Array(s.l),b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_uint8_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.constructor = MlFakeFile;
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(caml_bytes_of_array(buf),pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)len = clen - offset;
      if(len)
       {var data=caml_create_bytes(len | 0);
        caml_blit_bytes(this.data,offset,data,0,len);
        buf.set(caml_uint8_array_of_bytes(data),pos)}
      return len};
    function MlFakeFd(name,file,flags)
     {this.file = file;this.name = name;this.flags = flags}
    MlFakeFd.prototype.err_closed
    =
    function()
     {caml_raise_sys_error(this.name + ": file descriptor already closed")};
    MlFakeFd.prototype.length
    =
    function(){if(this.file)return this.file.length();this.err_closed()};
    MlFakeFd.prototype.write
    =
    function(offset,buf,pos,len)
     {if(this.file)return this.file.write(offset,buf,pos,len);
      this.err_closed()};
    MlFakeFd.prototype.read
    =
    function(offset,buf,pos,len)
     {if(this.file)return this.file.read(offset,buf,pos,len);
      this.err_closed()};
    MlFakeFd.prototype.close = function(){this.file = undefined};
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.opendir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       a=this.readdir(name),
       c=false,
       i=0;
      return {readSync:
              function()
               {if(c)
                 if(unix_error)
                  caml_raise_with_args
                   (unix_error,
                    make_unix_err_args("EBADF","closedir",this.nm(name)));
                 else
                  caml_raise_sys_error(name + ": closedir failed");
                if(i == a.length)return null;
                var entry=a[i];
                i++;
                return {name:entry}},
              closeSync:
              function()
               {if(c)
                 if(unix_error)
                  caml_raise_with_args
                   (unix_error,
                    make_unix_err_args("EBADF","closedir",this.nm(name)));
                 else
                  caml_raise_sys_error(name + ": closedir failed");
                c = true;
                a = []}}};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {var file;
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if(f.truncate)file.truncate()}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         file = this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name),file,f)};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {var file;
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if(f.truncate)file.truncate()}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         file = this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name),file,f)};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_uint8_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFd(fd,flags)
     {this.fs = require("fs");this.fd = fd;this.flags = flags}
    MlNodeFd.prototype = new MlFile();
    MlNodeFd.prototype.constructor = MlNodeFd;
    MlNodeFd.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {try
       {if(this.flags.isCharacterDevice)
         this.fs.writeSync(this.fd,buf,buf_offset,len);
        else
         this.fs.writeSync(this.fd,buf,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFd.prototype.read
    =
    function(offset,a,buf_offset,len)
     {try
       {if(this.flags.isCharacterDevice)
         var read=this.fs.readSync(this.fd,a,buf_offset,len);
        else
         var read=this.fs.readSync(this.fd,a,buf_offset,len,offset);
        return read}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd);return 0}
      catch(err){caml_raise_sys_error(err.toString())}};
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var
         fd=this.fs.openSync(this.nm(name),res),
         isCharacterDevice=
          this.fs.lstatSync(this.nm(name)).isCharacterDevice();
        f.isCharacterDevice = isCharacterDevice;
        return new MlNodeFd(fd,f)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.opendir
    =
    function(name,raise_unix)
     {try
       {return this.fs.opendirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var process=globalThis.process,n=caml_jsstring_of_string(name);
      if(process && process.env && process.env[n] != undefined)
       return caml_string_of_jsstring(process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof globalThis.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function(){this.objs = [];this.lookup = new (globalThis.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.log10(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    var caml_ml_channels=new Array();
    function caml_refill(chan)
     {if(chan.refill != null)
       {var str=chan.refill(),str_a=caml_uint8_array_of_string(str);
        if(str_a.length == 0)
         chan.refill = null;
        else
         {if(chan.buffer.length < chan.buffer_max + str_a.length)
           {var b=new Uint8Array(chan.buffer_max + str_a.length);
            b.set(chan.buffer);
            chan.buffer = b}
          chan.buffer.set(str_a,chan.buffer_max);
          chan.offset += str_a.length;
          chan.buffer_max += str_a.length}}
      else
       {var
         nread=
          chan.file.read
           (chan.offset,
            chan.buffer,
            chan.buffer_max,
            chan.buffer.length - chan.buffer_max);
        chan.offset += nread;
        chan.buffer_max += nread}}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid],p=chan.buffer_curr;
      do
       if(p >= chan.buffer_max)
        {if(chan.buffer_curr > 0)
          {chan.buffer.set(chan.buffer.subarray(chan.buffer_curr),0);
           p -= chan.buffer_curr;
           chan.buffer_max -= chan.buffer_curr;
           chan.buffer_curr = 0}
         if(chan.buffer_max >= chan.buffer.length)return - chan.buffer_max;
         var prev_max=chan.buffer_max;
         caml_refill(chan);
         if(prev_max == chan.buffer_max)return - chan.buffer_max}
      while
      (chan.buffer[p++] != 10);
      return p - chan.buffer_curr}
    function caml_gc_minor(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc(true);return 0}
    function core_gc_heap_chunks(){return 0}
    function caml_ml_condition_new(unit){return {condition:1}}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function bigstringaf_memcmp_bigstring(ba1,ba1_off,ba2,ba2_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba1,ba1_off + i),caml_ba_get_1(ba2,ba2_off + i));
        if(c != 0)return c}
      return 0}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function bigstring_blit_bigstring_bytes_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_get_continuation_callstack(){return [0]}
    var caml_parser_trace=0;
    function caml_set_parser_trace(bool)
     {var oldflag=caml_parser_trace;caml_parser_trace = bool;return oldflag}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    var caml_callback=caml_call_gen;
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(caml_jsbytes_of_string(dir))}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_obj_update_tag(b,o,n)
     {if(b[0] == o){b[0] = n;return 1}return 0}
    var caml_ml_domain_unique_token_=[0];
    function caml_ml_domain_unique_token(unit)
     {return caml_ml_domain_unique_token_}
    function caml_lazy_update_to_forcing(o)
     {var t=caml_obj_tag(o);
      if(t != 246 && t != 250 && t != 244)return 4;
      if(caml_obj_update_tag(o,246,244))
       return 0;
      else
       {var field0=o[1];
        t = o[0];
        if(t == 244)
         return field0 == caml_ml_domain_unique_token(0)?1:2;
        else
         if(t == 250)return 3;else return 2}}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_uint8_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_string_to_ba(src,src_off,dst,dst_off,len)}
    function caml_unix_closedir(dir_handle)
     {try
       {dir_handle.pointer.closeSync()}
      catch(e)
       {var unix_error=caml_named_value("Unix.Unix_error");
        caml_raise_with_args
         (unix_error,make_unix_err_args("EBADF","closedir",dir_handle.path))}}
    function caml_unix_opendir(path)
     {var root=resolve_fs_device(path);
      if(! root.device.opendir)
       caml_failwith("caml_unix_opendir: not implemented");
      var dir_handle=root.device.opendir(root.rest,true);
      return {pointer:dir_handle,path:path}}
    function caml_unix_rewinddir(dir_handle)
     {caml_unix_closedir(dir_handle);
      var new_dir_handle=caml_unix_opendir(dir_handle.path);
      dir_handle.pointer = new_dir_handle.pointer;
      return 0}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_unix_readdir(dir_handle)
     {var entry;
      try
       {entry = dir_handle.pointer.readSync()}
      catch(e)
       {var unix_error=caml_named_value("Unix.Unix_error");
        caml_raise_with_args
         (unix_error,make_unix_err_args("EBADF","readdir",dir_handle.path))}
      if(entry === null)
       caml_raise_end_of_file();
      else
       return caml_string_of_jsstring(entry.name)}
    function caml_unix_findfirst(path)
     {var path_js=caml_jsstring_of_string(path);
      path_js = path_js.replace(/(^|[\\\/])\*\.\*$/,"");
      path = caml_string_of_jsstring(path_js);
      var
       dir_handle=caml_unix_opendir(path),
       first_entry=caml_unix_readdir(dir_handle);
      return [0,first_entry,dir_handle]}
    function caml_is_continuation_tag(t){return 0}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new Float32Array(1);
      float32a[0] = x;
      var int32a=new Int32Array(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var view;
      switch(kind)
       {case 0:view = Float32Array;break;
        case 1:view = Float64Array;break;
        case 2:view = Int8Array;break;
        case 3:view = Uint8Array;break;
        case 4:view = Int16Array;break;
        case 5:view = Uint16Array;break;
        case 6:view = Int32Array;break;
        case 7:view = Int32Array;break;
        case 8:view = Int32Array;break;
        case 9:view = Int32Array;break;
        case 10:view = Float32Array;break;
        case 11:view = Float64Array;break;
        case 12:view = Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new Int32Array(1);
      int32a[0] = x;
      var float32a=new Float32Array(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(caml_is_continuation_tag(tag_a))
              {caml_invalid_argument("compare: continuation value");break}
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new Int32Array(x);this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var process=globalThis.process,main="a.out",args=[];
         if(process && process.argv && process.argv.length > 1)
          {var argv=process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {if(globalThis.quit)globalThis.quit(code);
      if(globalThis.process && globalThis.process.exit)
       globalThis.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var expect_test_collector_saved_stderr,expect_test_collector_saved_stdout;
    function expect_test_collector_before_test(voutput,vstdout,vstderr)
     {expect_test_collector_saved_stderr = caml_ml_channels[vstderr];
      expect_test_collector_saved_stdout = caml_ml_channels[vstdout];
      var output=caml_ml_channels[voutput];
      caml_ml_channels[vstdout] = output;
      caml_ml_channels[vstderr] = output;
      return 0}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function bigstring_is_mmapped_stub(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_check_bound_bigstring(bigstring,i)
     {if(i >>> 0 >= bigstring.data.length)caml_array_bound_error()}
    function bin_prot_blit_buf_float_array_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(dst,dst_pos);
      caml_check_bound(dst,dst_pos + len - 1);
      caml_check_bound_bigstring(src,src_pos);
      caml_check_bound_bigstring(src,src_pos + len * 8 - 1);
      var
       view=new (joo_global_object.Float64Array)(len),
       buffer=new (joo_global_object.Uint8Array)(view.buffer);
      buffer.set(src.data.subarray(src_pos,src_pos + len * 8));
      for(var i=0;i < len;i++)dst[dst_pos + i + 1] = view[i];
      return 0}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    var
     caml_MD5Transform=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         return function(w,buffer)
          {var a=w[0],b=w[1],c=w[2],d=w[3];
           a = ff(a,b,c,d,buffer[0],7,0xD76AA478);
           d = ff(d,a,b,c,buffer[1],12,0xE8C7B756);
           c = ff(c,d,a,b,buffer[2],17,0x242070DB);
           b = ff(b,c,d,a,buffer[3],22,0xC1BDCEEE);
           a = ff(a,b,c,d,buffer[4],7,0xF57C0FAF);
           d = ff(d,a,b,c,buffer[5],12,0x4787C62A);
           c = ff(c,d,a,b,buffer[6],17,0xA8304613);
           b = ff(b,c,d,a,buffer[7],22,0xFD469501);
           a = ff(a,b,c,d,buffer[8],7,0x698098D8);
           d = ff(d,a,b,c,buffer[9],12,0x8B44F7AF);
           c = ff(c,d,a,b,buffer[10],17,0xFFFF5BB1);
           b = ff(b,c,d,a,buffer[11],22,0x895CD7BE);
           a = ff(a,b,c,d,buffer[12],7,0x6B901122);
           d = ff(d,a,b,c,buffer[13],12,0xFD987193);
           c = ff(c,d,a,b,buffer[14],17,0xA679438E);
           b = ff(b,c,d,a,buffer[15],22,0x49B40821);
           a = gg(a,b,c,d,buffer[1],5,0xF61E2562);
           d = gg(d,a,b,c,buffer[6],9,0xC040B340);
           c = gg(c,d,a,b,buffer[11],14,0x265E5A51);
           b = gg(b,c,d,a,buffer[0],20,0xE9B6C7AA);
           a = gg(a,b,c,d,buffer[5],5,0xD62F105D);
           d = gg(d,a,b,c,buffer[10],9,0x02441453);
           c = gg(c,d,a,b,buffer[15],14,0xD8A1E681);
           b = gg(b,c,d,a,buffer[4],20,0xE7D3FBC8);
           a = gg(a,b,c,d,buffer[9],5,0x21E1CDE6);
           d = gg(d,a,b,c,buffer[14],9,0xC33707D6);
           c = gg(c,d,a,b,buffer[3],14,0xF4D50D87);
           b = gg(b,c,d,a,buffer[8],20,0x455A14ED);
           a = gg(a,b,c,d,buffer[13],5,0xA9E3E905);
           d = gg(d,a,b,c,buffer[2],9,0xFCEFA3F8);
           c = gg(c,d,a,b,buffer[7],14,0x676F02D9);
           b = gg(b,c,d,a,buffer[12],20,0x8D2A4C8A);
           a = hh(a,b,c,d,buffer[5],4,0xFFFA3942);
           d = hh(d,a,b,c,buffer[8],11,0x8771F681);
           c = hh(c,d,a,b,buffer[11],16,0x6D9D6122);
           b = hh(b,c,d,a,buffer[14],23,0xFDE5380C);
           a = hh(a,b,c,d,buffer[1],4,0xA4BEEA44);
           d = hh(d,a,b,c,buffer[4],11,0x4BDECFA9);
           c = hh(c,d,a,b,buffer[7],16,0xF6BB4B60);
           b = hh(b,c,d,a,buffer[10],23,0xBEBFBC70);
           a = hh(a,b,c,d,buffer[13],4,0x289B7EC6);
           d = hh(d,a,b,c,buffer[0],11,0xEAA127FA);
           c = hh(c,d,a,b,buffer[3],16,0xD4EF3085);
           b = hh(b,c,d,a,buffer[6],23,0x04881D05);
           a = hh(a,b,c,d,buffer[9],4,0xD9D4D039);
           d = hh(d,a,b,c,buffer[12],11,0xE6DB99E5);
           c = hh(c,d,a,b,buffer[15],16,0x1FA27CF8);
           b = hh(b,c,d,a,buffer[2],23,0xC4AC5665);
           a = ii(a,b,c,d,buffer[0],6,0xF4292244);
           d = ii(d,a,b,c,buffer[7],10,0x432AFF97);
           c = ii(c,d,a,b,buffer[14],15,0xAB9423A7);
           b = ii(b,c,d,a,buffer[5],21,0xFC93A039);
           a = ii(a,b,c,d,buffer[12],6,0x655B59C3);
           d = ii(d,a,b,c,buffer[3],10,0x8F0CCC92);
           c = ii(c,d,a,b,buffer[10],15,0xFFEFF47D);
           b = ii(b,c,d,a,buffer[1],21,0x85845DD1);
           a = ii(a,b,c,d,buffer[8],6,0x6FA87E4F);
           d = ii(d,a,b,c,buffer[15],10,0xFE2CE6E0);
           c = ii(c,d,a,b,buffer[6],15,0xA3014314);
           b = ii(b,c,d,a,buffer[13],21,0x4E0811A1);
           a = ii(a,b,c,d,buffer[4],6,0xF7537E82);
           d = ii(d,a,b,c,buffer[11],10,0xBD3AF235);
           c = ii(c,d,a,b,buffer[2],15,0x2AD7D2BB);
           b = ii(b,c,d,a,buffer[9],21,0xEB86D391);
           w[0] = add(a,w[0]);
           w[1] = add(b,w[1]);
           w[2] = add(c,w[2]);
           w[3] = add(d,w[3])}}
       ();
    function caml_MD5Update(ctx,input,input_len)
     {var in_buf=ctx.len & 0x3f,input_pos=0;
      ctx.len += input_len;
      if(in_buf)
       {var missing=64 - in_buf;
        if(input_len < missing)
         {ctx.b8.set(input.subarray(0,input_len),in_buf);return}
        ctx.b8.set(input.subarray(0,missing),in_buf);
        caml_MD5Transform(ctx.w,ctx.b32);
        input_len -= missing;
        input_pos += missing}
      while(input_len >= 64)
       {ctx.b8.set(input.subarray(input_pos,input_pos + 64),0);
        caml_MD5Transform(ctx.w,ctx.b32);
        input_len -= 64;
        input_pos += 64}
      if(input_len)
       ctx.b8.set(input.subarray(input_pos,input_pos + input_len),0)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_str_initialize(unit){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_gc_major(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc();return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var
       c,
       state=start_state,
       buffer=caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function caml_ml_debug_info_status(){return 0}
    function caml_atomic_fetch_add(ref,i)
     {var old=ref[1];ref[1] += i;return old}
    var
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    function MlMutex(){this.locked = false}
    function caml_ml_mutex_new(unit){return new MlMutex()}
    var caml_ephe_key_offset=3;
    function caml_ephe_check_key(x,i)
     {var weak=x[caml_ephe_key_offset + i];
      if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
       weak = weak.deref();
      return weak === undefined?0:1}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var
       c,
       state=start_state,
       buffer=caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_MD5Init()
     {var
       buffer=new ArrayBuffer(64),
       b32=new Uint32Array(buffer),
       b8=new Uint8Array(buffer);
      return {len:0,
              w:new Uint32Array([0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476]),
              b32:b32,
              b8:b8}}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer_curr == 0)return 0;
      if(chan.output)
       chan.output(caml_subarray_to_jsbytes(chan.buffer,0,chan.buffer_curr));
      else
       chan.file.write(chan.offset,chan.buffer,0,chan.buffer_curr);
      chan.offset += chan.buffer_curr;
      chan.buffer_curr = 0;
      return 0}
    function caml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);
      var chan=caml_ml_channels[chanid];
      chan.offset = pos;
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {var pos=caml_int64_to_float(pos);return caml_seek_out(chanid,pos)}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    var js_performance={mark:function(){},measure:function(){}};
    if(typeof joo_global_object.performance !== "undefined")
     js_performance = joo_global_object.performance;
    else
     try
      {js_performance = require("perf_hooks").performance}
     catch(_e)
      {joo_global_object.console.warn("couldn't load performance hooks")}
    function js_prof_mark(name)
     {try
       {js_performance.mark(caml_jsbytes_of_string(name))}
      catch(e){joo_global_object.console.warn(e)}
      return 0}
    function caml_unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function caml_ml_set_buffered(chanid,v)
     {caml_ml_channels[chanid].buffered = v;
      if(! v)caml_ml_flush(chanid);
      return 0}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             if(caml_is_continuation_tag(v[0]))break;
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_gc_compaction(){return 0}
    function bin_prot_blit_float_array_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(len == 0)return 0;
      caml_check_bound(src,src_pos);
      caml_check_bound(src,src_pos + len - 1);
      caml_check_bound_bigstring(dst,dst_pos);
      caml_check_bound_bigstring(dst,dst_pos + len * 8 - 1);
      src_pos = src_pos + 1;
      var
       float64=
        new (joo_global_object.Float64Array)(src.slice(src_pos,src_pos + len)),
       float64_uint8=new (joo_global_object.Uint8Array)(float64.buffer),
       view=dst.data.subarray(dst_pos,dst_pos + len * 8);
      view.set(float64_uint8);
      return 0}
    function caml_sys_open_for_node(fd,flags)
     {if(flags.name)
       try
        {var fs=require("fs"),fd2=fs.openSync(flags.name,"rs");
         return new MlNodeFd(fd2,flags)}
       catch(e){}
      return new MlNodeFd(fd,flags)}
    var caml_sys_fds=new Array(3);
    function MlFakeFd_out(fd,flags)
     {MlFakeFile.call(this,caml_create_bytes(0));
      this.log = function(s){return 0};
      if(fd == 1 && typeof console.log == "function")
       this.log = console.log;
      else
       if(fd == 2 && typeof console.error == "function")
        this.log = console.error;
       else
        if(typeof console.log == "function")this.log = console.log;
      this.flags = flags}
    MlFakeFd_out.prototype.length = function(){return 0};
    MlFakeFd_out.prototype.write
    =
    function(offset,buf,pos,len)
     {if(this.log)
       {if
         (len
          >
          0
          &&
          pos
          >=
          0
          &&
          pos
          +
          len
          <=
          buf.length
          &&
          buf[pos + len - 1]
          ==
          10)
         len--;
        var src=caml_create_bytes(len);
        caml_blit_bytes(caml_bytes_of_array(buf),pos,src,0,len);
        this.log(src.toUtf16());
        return 0}
      caml_raise_sys_error(this.fd + ": file descriptor already closed")};
    MlFakeFd_out.prototype.read
    =
    function(offset,buf,pos,len)
     {caml_raise_sys_error(this.fd + ": file descriptor is write only")};
    MlFakeFd_out.prototype.close = function(){this.log = undefined};
    function caml_sys_open_internal(file,idx)
     {if(idx == undefined)idx = caml_sys_fds.length;
      caml_sys_fds[idx] = file;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var root=resolve_fs_device(name),file=root.device.open(root.rest,f);
      return caml_sys_open_internal(file,undefined)}
    (function()
       {function file(fd,flags)
         {return fs_node_supported()
                  ?caml_sys_open_for_node(fd,flags)
                  :new MlFakeFd_out(fd,flags)}
        caml_sys_open_internal
         (file(0,{rdonly:1,altname:"/dev/stdin",isCharacterDevice:true}),0);
        caml_sys_open_internal
         (file(1,{buffered:2,wronly:1,isCharacterDevice:true}),1);
        caml_sys_open_internal
         (file(2,{buffered:2,wronly:1,isCharacterDevice:true}),2)}
      ());
    function caml_ml_open_descriptor_in(fd)
     {var file=caml_sys_fds[fd];
      if(file.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       refill=null,
       channel=
        {file:file,
         offset:file.flags.append?file.length():0,
         fd:fd,
         opened:true,
         out:false,
         buffer_curr:0,
         buffer_max:0,
         buffer:new Uint8Array(65536),
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_MD5Final(ctx)
     {var in_buf=ctx.len & 0x3f;
      ctx.b8[in_buf] = 0x80;
      in_buf++;
      if(in_buf > 56)
       {for(var j=in_buf;j < 64;j++)ctx.b8[j] = 0;
        caml_MD5Transform(ctx.w,ctx.b32);
        for(var j=0;j < 56;j++)ctx.b8[j] = 0}
      else
       for(var j=in_buf;j < 56;j++)ctx.b8[j] = 0;
      ctx.b32[14] = ctx.len << 3;
      ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
      caml_MD5Transform(ctx.w,ctx.b32);
      var t=new Uint8Array(16);
      for(var i=0;i < 4;i++)
       for(var j=0;j < 4;j++)t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
      return t}
    function caml_ml_input_block(chanid,ba,i,l)
     {var
       chan=caml_ml_channels[chanid],
       n=l,
       avail=chan.buffer_max - chan.buffer_curr;
      if(l <= avail)
       {ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + l),i);
        chan.buffer_curr += l}
      else
       if(avail > 0)
        {ba.set
          (chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + avail),i);
         chan.buffer_curr += avail;
         n = avail}
       else
        {chan.buffer_curr = 0;
         chan.buffer_max = 0;
         caml_refill(chan);
         var avail=chan.buffer_max - chan.buffer_curr;
         if(n > avail)n = avail;
         ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + n),i);
         chan.buffer_curr += n}
      return n}
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_md5_chan(chanid,toread)
     {var ctx=caml_MD5Init(),buffer=new Uint8Array(4096);
      if(toread < 0)
       while(true)
        {var read=caml_ml_input_block(chanid,buffer,0,buffer.length);
         if(read == 0)break;
         caml_MD5Update(ctx,buffer.subarray(0,read),read)}
      else
       while(toread > 0)
        {var
          read=
           caml_ml_input_block
            (chanid,buffer,0,toread > buffer.length?buffer.length:toread);
         if(read == 0)caml_raise_end_of_file();
         caml_MD5Update(ctx,buffer.subarray(0,read),read);
         toread -= read}
      return caml_string_of_array(caml_MD5Final(ctx))}
    function caml_sys_close(fd)
     {var file=caml_sys_fds[fd];
      if(file)file.close();
      delete caml_sys_fds[fd];
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      chan.opened = false;
      caml_sys_close(chan.fd);
      return 0}
    function core_md5_fd(fd)
     {var ic=caml_ml_open_descriptor_in(fd);
      try {return caml_md5_chan(ic,- 1)}finally {caml_ml_close_channel(ic)}}
    function caml_ephe_get_key(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      var weak=x[caml_ephe_key_offset + i];
      if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
       weak = weak.deref();
      return weak === undefined?0:[0,weak]}
    function caml_unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=caml_unix_localtime(t);
      return [0,t,tm2]}
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_uint8_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (globalThis.Error)("Js exception containing backtrace");
      return exn}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function caml_atomic_exchange(ref,v){var r=ref[1];ref[1] = v;return r}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function caml_unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)
       caml_failwith("caml_unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    function caml_unix_lstat_64(name)
     {var r=caml_unix_lstat(name);r[9] = caml_int64_of_int32(r[9])}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_continuation_use_noexc(cont)
     {var stack=cont[1];cont[1] = 0;return stack}
    function caml_unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)
       caml_failwith("caml_unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function caml_log2_float(x){return Math.log2(x)}
    function caml_gc_huge_fallback_count(unit){return 0}
    function bin_prot_blit_bytes_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         Uint8Array
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function bin_prot_blit_buf_stub(src_pos,src,dst_pos,dst,len)
     {if(src.kind != 12)src = bigstring_of_typed_array(src.data);
      if(dst.kind != 12)dst = bigstring_of_typed_array(dst.data);
      return caml_bigstring_blit_ba_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      if
       (pos
        >=
        chan.offset
        -
        chan.buffer_max
        &&
        pos
        <=
        chan.offset
        &&
        chan.file.flags.binary)
       chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
      else
       {chan.offset = pos;chan.buffer_curr = 0;chan.buffer_max = 0}
      return 0}
    function caml_ml_seek_in_64(chanid,pos)
     {var pos=caml_int64_to_float(pos);return caml_seek_in(chanid,pos)}
    var caml_domain_id=0;
    function caml_ml_mutex_unlock(t){t.locked = false;return 0}
    var caml_domain_latest_idx=1;
    function caml_domain_spawn(f,mutex)
     {var id=caml_domain_latest_idx++,old=caml_domain_id;
      caml_domain_id = id;
      caml_callback(f,[0]);
      caml_domain_id = old;
      caml_ml_mutex_unlock(mutex);
      return id}
    function caml_unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)
       caml_failwith("caml_unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i]}
        else
         args = [undefined];
        var res=caml_callback(f,args);
        return res instanceof Function?caml_js_wrap_callback(res):res}}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        var res=caml_callback(f,args);
        return res instanceof Function?caml_js_wrap_callback(res):res}}
    function caml_is_js(){return 1}
    var Base_internalhash_fold_float=caml_hash_mix_float;
    function caml_lazy_update_to_forward(o)
     {caml_obj_update_tag(o,244,250);return 0}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    var caml_ephe_data_offset=2;
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    function caml_ephe_create(n){var x=caml_weak_create(n);return x}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      v_bstr.__is_deallocated = true;
      v_bstr.data = new (v_bstr.data.__proto__.constructor)(0);
      v_bstr.dims = [0];
      return 0}
    function bigstring_realloc(bigstring,size)
     {if(bigstring.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_realloc: bigstring is already deallocated");
      var new_data=new (bigstring.data.__proto__.constructor)(size);
      new_data.set(bigstring.data.slice(0,size));
      var
       new_bigstring=
        caml_ba_create_unsafe(bigstring.kind,bigstring.layout,[size],new_data);
      bigstring_destroy_stub(bigstring);
      return new_bigstring}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_maybe_print_stats(unit){return 0}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_unix_has_symlink(unit){return fs_node_supported()?1:0}
    function caml_ephe_set_key(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      if(v instanceof Object && globalThis.WeakRef)
       {if(x[1].register)x[1].register(v,undefined,v);
        x[caml_ephe_key_offset + i] = new (globalThis.WeakRef)(v)}
      else
       x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_ephe_unset_key(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      if
       (globalThis.WeakRef
        &&
        x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
        &&
        x[1].unregister)
       {var old=x[caml_ephe_key_offset + i].deref();
        if(old !== undefined)
         {var count=0;
          for(var j=caml_ephe_key_offset;j < x.length;j++)
           {var key=x[j];
            if(key instanceof globalThis.WeakRef)
             {key = key.deref();if(key === old)count++}}
          if(count == 1)x[1].unregister(old)}}
      x[caml_ephe_key_offset + i] = undefined;
      return 0}
    function caml_weak_set(x,i,v)
     {if(v == 0)caml_ephe_unset_key(x,i);else caml_ephe_set_key(x,i,v[1]);
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(caml_jsbytes_of_string(name));
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_unix_inet_addr_of_string(){return 0}
    function Base_am_testing(x){return 0}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_off,dst,dst_off,len)}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.buffer_curr >= chan.buffer_max)
       {chan.buffer_curr = 0;chan.buffer_max = 0;caml_refill(chan)}
      if(chan.buffer_curr >= chan.buffer_max)caml_raise_end_of_file();
      var res=chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      return res}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],res=0;
      for(var i=0;i < 4;i++)res = (res << 8) + caml_ml_input_char(chanid);
      return res}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lxm_next(v)
     {function shift_l(x,k){return caml_int64_shift_left(x,k)}
      function shift_r(x,k){return caml_int64_shift_right_unsigned(x,k)}
      function or(a,b){return caml_int64_or(a,b)}
      function xor(a,b){return caml_int64_xor(a,b)}
      function add(a,b){return caml_int64_add(a,b)}
      function mul(a,b){return caml_int64_mul(a,b)}
      function rotl(x,k){return or(shift_l(x,k),shift_r(x,64 - k))}
      function get(a,i){return caml_ba_get_1(a,i)}
      function set(a,i,x){return caml_ba_set_1(a,i,x)}
      var
       M=caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
       daba=caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
       z,
       q0,
       q1,
       st=v,
       a=get(st,0),
       s=get(st,1),
       x0=get(st,2),
       x1=get(st,3);
      z = add(s,x0);
      z = mul(xor(z,shift_r(z,32)),daba);
      z = mul(xor(z,shift_r(z,32)),daba);
      z = xor(z,shift_r(z,32));
      set(st,1,add(mul(s,M),a));
      var q0=x0,q1=x1;
      q1 = xor(q1,q0);
      q0 = rotl(q0,24);
      q0 = xor(xor(q0,q1),shift_l(q1,16));
      q1 = rotl(q1,37);
      set(st,2,q0);
      set(st,3,q1);
      return z}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(caml_is_continuation_tag(v[0]))
                 caml_invalid_argument("output_value: continuation value");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if(typeof require != "undefined")
       {var child_process=require("child_process");
        if(child_process && child_process.execSync)
         try
          {child_process.execSync(cmd,{stdio:"inherit"});return 0}
         catch(e){return 1}}
      else
       return 127}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function caml_unix_getuid(unit)
     {if(globalThis.process && globalThis.process.getuid)
       return globalThis.process.getuid();
      caml_raise_not_found()}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],header=new Uint8Array(20);
      function block(buffer,offset,n)
       {var r=0;
        while(r < n)
         {if(chan.buffer_curr >= chan.buffer_max)
           {chan.buffer_curr = 0;chan.buffer_max = 0;caml_refill(chan)}
          if(chan.buffer_curr >= chan.buffer_max)break;
          buffer[offset + r] = chan.buffer[chan.buffer_curr];
          chan.buffer_curr++;
          r++}
        return r}
      var r=block(header,0,20);
      if(r == 0)
       caml_raise_end_of_file();
      else
       if(r < 20)caml_failwith("input_value: truncated object");
      var
       len=caml_marshal_data_size(caml_bytes_of_array(header),0),
       buf=new Uint8Array(len + 20);
      buf.set(header,0);
      var r=block(buf,20,len);
      if(r < len)
       caml_failwith("input_value: truncated object " + r + "  " + len);
      var
       offset=[0],
       res=caml_input_value_from_bytes(caml_bytes_of_array(buf),offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_input_value_to_outside_heap(c){return caml_input_value(c)}
    function caml_atomic_cas(ref,o,n)
     {if(ref[1] === o){ref[1] = n;return 1}return 0}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_atomic_load(ref){return ref[1]}
    function caml_md5_bytes(s,ofs,len)
     {var ctx=caml_MD5Init(),a=caml_uint8_array_of_bytes(s);
      caml_MD5Update(ctx,a.subarray(ofs,ofs + len),len);
      return caml_string_of_array(caml_MD5Final(ctx))}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ml_condition_wait(t,mutext){return 0}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function core_gc_minor_collections(){return 0}
    function caml_pos_in(chanid)
     {var chan=caml_ml_channels[chanid];
      return chan.offset - (chan.buffer_max - chan.buffer_curr)}
    function caml_ml_pos_in(chanid){return caml_pos_in(chanid)}
    function caml_int64_and(x,y){return x.and(y)}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=caml_int64_create_lo_hi(1,0),mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[caml_int64_lo32(exponent) & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function caml_unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)
       caml_failwith("caml_unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_uint8_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function core_gc_compactions(){return 0}
    function caml_gc_full_major(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc();return 0}
    function caml_ml_mutex_try_lock(t)
     {if(! t.locked){t.locked = true;return 1}return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_ba_kind_of_typed_array(ta)
     {var kind;
      if(ta instanceof Float32Array)
       kind = 0;
      else
       if(ta instanceof Float64Array)
        kind = 1;
       else
        if(ta instanceof Int8Array)
         kind = 2;
        else
         if(ta instanceof Uint8Array)
          kind = 3;
         else
          if(ta instanceof Int16Array)
           kind = 4;
          else
           if(ta instanceof Uint16Array)
            kind = 5;
           else
            if(ta instanceof Int32Array)
             kind = 6;
            else
             if(ta instanceof Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos){return caml_seek_out(chanid,pos)}
    function caml_js_typeof(o){return typeof o}
    function caml_string_hash(h,v)
     {var h=caml_hash_mix_string(h,v),h=caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function Base_int_math_int32_ctz(x)
     {if(x === 0)return 32;
      var n=1;
      if((x & 0x0000FFFF) === 0){n = n + 16;x = x >> 16}
      if((x & 0x000000FF) === 0){n = n + 8;x = x >> 8}
      if((x & 0x0000000F) === 0){n = n + 4;x = x >> 4}
      if((x & 0x00000003) === 0){n = n + 2;x = x >> 2}
      return n - (x & 1)}
    function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x)}
    function expect_test_collector_after_test(vstdout,vstderr)
     {caml_ml_channels[vstdout] = expect_test_collector_saved_stdout;
      caml_ml_channels[vstderr] = expect_test_collector_saved_stderr;
      return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_function_arity(f){return f.length}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=caml_js_function_arity(f) - 1,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_callback(f,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         caml_callback(handler,[err,false]);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)caml_callback(at_exit,[0]);
          console.error("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(chanid,name)
     {var chan=caml_ml_channels[chanid];chan.name = name;return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function bigstring_memcmp_bytes_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_bytes_get(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_ml_domain_cpu_relax(unit){return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    function bigstring_memset_stub(bigstring,v_pos,v_len,v_char)
     {for(var i=0;i < v_len;i++)caml_ba_set_1(bigstring,v_pos + i,v_char)}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_condition_signal(t){return 0}
    function caml_unix_findnext(dir_handle)
     {return caml_unix_readdir(dir_handle)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var buffer=caml_uint8_array_of_bytes(buffer);
      buffer = buffer.subarray(offset,offset + len);
      if(chan.buffer_curr + buffer.length > chan.buffer.length)
       {var b=new Uint8Array(chan.buffer_curr + buffer.length);
        b.set(chan.buffer);
        chan.buffer = b}
      switch(chan.buffered)
       {case 0:
         chan.buffer.set(buffer,chan.buffer_curr);
         chan.buffer_curr += buffer.length;
         caml_ml_flush(chanid);
         break;
        case 1:
         chan.buffer.set(buffer,chan.buffer_curr);
         chan.buffer_curr += buffer.length;
         if(chan.buffer_curr >= chan.buffer.length)caml_ml_flush(chanid);
         break;
        case 2:
         var id=buffer.lastIndexOf(10);
         if(id < 0)
          {chan.buffer.set(buffer,chan.buffer_curr);
           chan.buffer_curr += buffer.length;
           if(chan.buffer_curr >= chan.buffer.length)caml_ml_flush(chanid)}
         else
          {chan.buffer.set(buffer.subarray(0,id + 1),chan.buffer_curr);
           chan.buffer_curr += id + 1;
           caml_ml_flush(chanid);
           chan.buffer.set(buffer.subarray(id + 1),chan.buffer_curr);
           chan.buffer_curr += buffer.length - id - 1}
         break
        }
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ml_domain_id(unit){return caml_domain_id}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {if(typeof globalThis.XMLHttpRequest !== "undefined")
       try {return new (globalThis.XMLHttpRequest)()}catch(e){}
      if(typeof globalThis.activeXObject !== "undefined")
       {try
         {return new (globalThis.activeXObject)("Msxml2.XMLHTTP")}
        catch(e){}
        try
         {return new (globalThis.activeXObject)("Msxml3.XMLHTTP")}
        catch(e){}
        try
         {return new (globalThis.activeXObject)("Microsoft.XMLHTTP")}
        catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_is_buffered(chanid)
     {return caml_ml_channels[chanid].buffered?1:0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    var internalhash_fold_bigstring=caml_hash_mix_bigstring;
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_unix_time(){return Math.floor(caml_unix_gettimeofday())}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function js_prof_clear_marks()
     {try
       {js_performance.clearMarks()}
      catch(e){joo_global_object.console.warn(e)}
      return 0}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    function caml_js_expr(s)
     {console.error("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function caml_ojs_iterate_properties(o,f)
     {var name;
      for(name in o)if(o.hasOwnProperty(name))f(caml_js_to_string(name))}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function core_gc_run_memprof_callbacks(){return 0}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_array_of_string(x){return caml_uint8_array_of_string(x)}
    function caml_jsoo_flags_use_js_string(unit){return 0}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function core_gc_top_heap_words(){return 0}
    function caml_unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("caml_unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function jsoo_create_file_extern(name,content)
     {if(globalThis.jsoo_create_file)
       globalThis.jsoo_create_file(name,content);
      else
       {if(! globalThis.caml_fs_tmp)globalThis.caml_fs_tmp = [];
        globalThis.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_unix_stat_64(name)
     {var r=caml_unix_stat(name);r[9] = caml_int64_of_int32(r[9])}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_ml_mutex_lock(t)
     {if(t.locked)
       caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
      else
       t.locked = true;
      return 0}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos){return caml_seek_in(chanid,pos)}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       console.error
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_unset_data(x)
     {if(globalThis.FinalizationRegistry && globalThis.WeakRef)
       if(x[1] instanceof globalThis.FinalizationRegistry)
        for(var j=caml_ephe_key_offset;j < x.length;j++)
         {var key=x[j];
          if(key instanceof globalThis.WeakRef)
           {key = key.deref();if(key)x[1].unregister(key)}}
      x[caml_ephe_data_offset] = undefined;
      return 0}
    function caml_ephe_set_data(x,data)
     {if(globalThis.FinalizationRegistry && globalThis.WeakRef)
       if(! (x[1] instanceof globalThis.FinalizationRegistry))
        {x[1]
         =
         new
          (globalThis.FinalizationRegistry)
          (function(){caml_ephe_unset_data(x)});
         for(var j=caml_ephe_key_offset;j < x.length;j++)
          {var key=x[j];
           if(key instanceof globalThis.WeakRef)
            {key = key.deref();if(key)x[1].register(key,undefined,key)}}}
      x[caml_ephe_data_offset] = data;
      return 0}
    function caml_ephe_blit_data(src,dst)
     {var n=src[caml_ephe_data_offset];
      if(n === undefined)
       caml_ephe_unset_data(dst);
      else
       caml_ephe_set_data(dst,n);
      return 0}
    var Base_internalhash_fold_int64=caml_hash_mix_int64;
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new Uint32Array(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var buff=globalThis.crypto.randomBytes(4),a=new Uint32Array(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    var all_finalizers=new (globalThis.Set)();
    function caml_final_register_called_without_value(cb,a)
     {if(globalThis.FinalizationRegistry && a instanceof Object)
       {var
         x=
          new
           (globalThis.FinalizationRegistry)
           (function(x){all_finalizers.delete(x);cb(0);return});
        x.register(a,x);
        all_finalizers.add(x)}
      return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_lazy_reset_to_lazy(o)
     {caml_obj_update_tag(o,244,246);return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function caml_obj_compare_and_swap(x,i,old,n)
     {if(x[i + 1] == old){x[i + 1] = n;return 1}return 0}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_js_wrap_callback_unsafe(f)
     {return function()
       {var len=caml_js_function_arity(f),args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,args)}}
    function caml_ba_kind(ba){return ba.kind}
    function caml_out_channel_pos_fd(chan)
     {var info=caml_ml_channels[chan];return info.offset}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_js_pure_expr(f){return caml_callback(f,[0])}
    var core_array_unsafe_int_blit=caml_array_blit;
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,b,i,l)
     {var ba=caml_uint8_array_of_bytes(b);
      return caml_ml_input_block(chanid,ba,i,l)}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_record_backtrace(){return 0}
    function caml_unix_cleanup(){}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function core_heap_block_is_heap_block(x){return + (x instanceof Array)}
    function caml_obj_is_shared(x){return 1}
    function core_gc_promoted_words(){return 0}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_asinh_float(x){return Math.asinh(x)}
    function caml_pos_out(chanid)
     {var chan=caml_ml_channels[chanid];return chan.offset + chan.buffer_curr}
    function bigstring_of_array_buffer(ab)
     {var ta=new Uint8Array(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function caml_unix_filedescr_of_fd(x){return x}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_unix_startup(){}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function js_prof_clear_measures()
     {try
       {js_performance.clearMeasures()}
      catch(e){joo_global_object.console.warn(e)}
      return 0}
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_ml_domain_set_name(_name){return 0}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    function caml_ephe_get_key_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_ephe_get_key(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function bigstringaf_memcmp_string(ba,ba_off,str,str_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba,ba_off + i),
            caml_string_unsafe_get(str,str_off + i));
        if(c != 0)return c}
      return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = caml_callback(globalThis.toplevelReloc,[name_opt]);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function core_md5_digest_subbigstring(buf,ofs,len,res)
     {var bytes=caml_create_bytes(len);
      bigstring_blit_bigstring_bytes_stub(buf,ofs,bytes,0,len);
      var res2=caml_md5_string(caml_string_of_bytes(bytes),0,len);
      caml_blit_string(res2,0,res,0,16);
      return 0}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_get_major_credit(n){return 0}
    function bigstringaf_memchr(ba,ba_off,chr,len)
     {for(var i=0;i < len;i++)
       if(caml_ba_get_1(ba,ba_off + i) == chr)return ba_off + i;
      return - 1}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function bin_prot_blit_buf_bytes_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_pos,dst,dst_pos,len)}
    function caml_js_get_console()
     {var
       c=console,
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_round_float(x){return Math.round(x)}
    function js_prof_measure(name,start,end)
     {try
       {js_performance.measure
         (caml_jsbytes_of_string(name),
          caml_jsbytes_of_string(start),
          caml_jsbytes_of_string(end))}
      catch(e){joo_global_object.console.warn(e)}
      return 0}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_domain_dls=[0];
    function caml_domain_dls_set(a){caml_domain_dls = a}
    function caml_lazy_read_result(o){return caml_obj_tag(o) == 250?o[1]:o}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function core_gc_major_plus_minor_words(){return 0}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var
         n=arguments.length,
         args=new Array(arity),
         len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c?1:0}
    function caml_get_major_bucket(n){return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x)}
    function bigstring_blit_string_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_pos_in(chanid))}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (globalThis.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function caml_unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith
        ("caml_unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("caml_unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function Base_int_math_int64_ctz(x)
     {if(caml_int64_is_zero(x))return 64;
      var n=1;
      function is_zero(x){return caml_int64_is_zero(x)}
      function land(x,y){return caml_int64_and(x,y)}
      function small_int64(x){return caml_int64_create_lo_mi_hi(x,0,0)}
      if
       (is_zero(land(x,caml_int64_create_lo_mi_hi(0xFFFFFF,0x0000FF,0x0000))))
       {n = n + 32;x = caml_int64_shift_right_unsigned(x,32)}
      if(is_zero(land(x,small_int64(0x00FFFF))))
       {n = n + 16;x = caml_int64_shift_right_unsigned(x,16)}
      if(is_zero(land(x,small_int64(0x0000FF))))
       {n = n + 8;x = caml_int64_shift_right_unsigned(x,8)}
      if(is_zero(land(x,small_int64(0x00000F))))
       {n = n + 4;x = caml_int64_shift_right_unsigned(x,4)}
      if(is_zero(land(x,small_int64(0x000003))))
       {n = n + 2;x = caml_int64_shift_right_unsigned(x,2)}
      return n - caml_int64_to_int32(caml_int64_and(x,small_int64(0x000001)))}
    function caml_ml_pos_out(chanid){return caml_pos_out(chanid)}
    var core_array_unsafe_float_blit=caml_array_blit;
    function Base_caml_exn_is_most_recent_exn(x){return 1}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_bytes_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_recommended_domain_count(unit){return 1}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid];
      chan.file.flags.text = ! mode;
      chan.file.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function core_gc_major_collections(){return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    function caml_ephe_blit_key(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_unix_getpwuid(unit){caml_raise_not_found()}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_domain_dls_get(unit){return caml_domain_dls}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function bigstring_blit_bytes_bigstring_stub(src,src_pos,dst,dst_pos,len)
     {return caml_bigstring_blit_bytes_to_ba(src,src_pos,dst,dst_pos,len)}
    function core_time_ns_format(time,format)
     {var
       d=new Date(time * 1000),
       formatjs=caml_jsbytes_of_string(format),
       jstring=joo_global_object.strftime(formatjs,d);
      return caml_string_of_jsbytes(jstring)}
    function caml_ojs_wrap_fun_arguments(f)
     {return function(){return caml_js_wrap_callback(f)(arguments)}}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_js_error_option_of_exception(exn)
     {if(exn.js_error)return [0,exn.js_error];return 0}
    function caml_ml_pos_out_64(chanid)
     {return caml_int64_of_float(caml_pos_out(chanid))}
    function caml_unix_findclose(dir_handle)
     {return caml_unix_closedir(dir_handle)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! globalThis.jsoo_static_env)globalThis.jsoo_static_env = {};
      globalThis.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function core_gc_heap_words(){return 0}
    function jsoo_effect_not_supported()
     {caml_failwith("Effect handlers are not supported")}
    function caml_continuation_use_and_update_handler_noexc
     (cont,hval,hexn,heff)
     {var stack=caml_continuation_use_noexc(cont);
      stack[3] = [0,hval,hexn,heff];
      return stack}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function core_gc_minor_words(){return 0}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var file=caml_sys_fds[fd];
      if(file.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       buffered=file.flags.buffered !== undefined?file.flags.buffered:1,
       channel=
        {file:file,
         offset:file.flags.append?file.length():0,
         fd:fd,
         opened:true,
         out:true,
         buffer_curr:0,
         buffer:new Uint8Array(65536),
         buffered:buffered};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=globalThis.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_memprof_stop(unit){return 0}
    function caml_eventlog_pause(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    function bigstringaf_blit_to_bigstring(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_ba_to_ba(src,src_off,dst,dst_off,len)}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var ua=globalThis.navigator?globalThis.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_alloc_stack(hv,hx,hf){return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function bin_prot_blit_string_buf_stub(src_pos,src,dst_pos,dst,len)
     {return caml_bigstring_blit_string_to_ba(src,src_pos,dst,dst_pos,len)}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_callback(f,args)}}
    function caml_unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("caml_unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_backtrace_status(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13,
       tbl_names_const=15,
       tbl_names_block=16;
      function log(x)
       {var s=caml_string_of_jsbytes(x + "\n");
        caml_ml_output(2,s,0,caml_ml_string_length(s))}
      function token_name(names,number)
       {var str=caml_jsstring_of_string(names);
        if(str[0] == "\x00")return "<unknown token>";
        return str.split("\x00")[number]}
      function print_token(state,tok)
       {var token,kind;
        if(tok instanceof Array)
         {token = token_name(tables[tbl_names_block],tok[0]);
          if(typeof tok[1] == "number")
           kind = "" + tok[1];
          else
           if(typeof tok[1] == "string")
            kind = tok[1];
           else
            if(tok[1] instanceof MlBytes)
             kind = caml_jsbytes_of_string(tok[1]);
            else
             kind = "_";
          log("State " + state + ": read token " + token + "(" + kind + ")")}
        else
         {token = token_name(tables[tbl_names_const],tok);
          log("State " + state + ": read token " + token)}}
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       next:
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
          if(caml_parser_trace)print_token(state,arg);
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {if(caml_parser_trace)log("Recovering in state " + state1);
                cmd = shift_recover;
                break next}
              else
               {if(caml_parser_trace)log("Discarding state " + state1);
                if(sp <= env[env_stackbase])
                 {if(caml_parser_trace)log("No more states to discard");
                  return RAISE_PARSE_ERROR}
                sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            if(caml_parser_trace)log("Discarding last token read");
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          if(caml_parser_trace)
           log("State " + state + ": shift to state " + tables.table[n2]);
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          if(caml_parser_trace)
           log("State " + state + ": reduce by rule " + n);
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_jsoo_flags_effects(unit){return 0}
    function core_gc_major_words(){return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {return caml_bigstring_blit_ba_to_ba(s1,i1,s2,i2,len)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      chan.output = function(s){f(s)};
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=new Uint8Array(len);
        file.read(0,buf,0,len);
        return caml_string_of_array(buf)}
      caml_raise_no_such_file(caml_jsbytes_of_string(name))}
    function caml_js_to_float(x){return x}
    function caml_setup_uncaught_exception_handler()
     {var process=globalThis.process;
      if(process && process.on)
       process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);process.exit(2)});
      else
       if(globalThis.addEventListener)
        globalThis.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    globalThis.jsoo_runtime
    =
    {js_performance:js_performance,
     js_prof_mark:js_prof_mark,
     js_prof_measure:js_prof_measure,
     js_prof_clear_marks:js_prof_clear_marks,
     js_prof_clear_measures:js_prof_clear_measures,
     bigstringaf_blit_to_bytes:bigstringaf_blit_to_bytes,
     bigstringaf_blit_to_bigstring:bigstringaf_blit_to_bigstring,
     bigstringaf_blit_from_bytes:bigstringaf_blit_from_bytes,
     bigstringaf_memcmp_bigstring:bigstringaf_memcmp_bigstring,
     bigstringaf_memcmp_string:bigstringaf_memcmp_string,
     bigstringaf_memchr:bigstringaf_memchr,
     caml_ojs_wrap_fun_arguments:caml_ojs_wrap_fun_arguments,
     caml_ojs_iterate_properties:caml_ojs_iterate_properties,
     core_array_unsafe_int_blit:core_array_unsafe_int_blit,
     core_array_unsafe_float_blit:core_array_unsafe_float_blit,
     core_time_ns_format:core_time_ns_format,
     core_gc_compactions:core_gc_compactions,
     core_gc_heap_chunks:core_gc_heap_chunks,
     core_gc_heap_words:core_gc_heap_words,
     core_gc_major_collections:core_gc_major_collections,
     core_gc_major_plus_minor_words:core_gc_major_plus_minor_words,
     core_gc_major_words:core_gc_major_words,
     core_gc_minor_collections:core_gc_minor_collections,
     core_gc_minor_words:core_gc_minor_words,
     core_gc_promoted_words:core_gc_promoted_words,
     core_gc_top_heap_words:core_gc_top_heap_words,
     core_gc_run_memprof_callbacks:core_gc_run_memprof_callbacks,
     core_heap_block_is_heap_block:core_heap_block_is_heap_block,
     core_md5_fd:core_md5_fd,
     core_md5_digest_subbigstring:core_md5_digest_subbigstring,
     bigstring_destroy_stub:bigstring_destroy_stub,
     bigstring_realloc:bigstring_realloc,
     bigstring_alloc:bigstring_alloc,
     bigstring_is_mmapped_stub:bigstring_is_mmapped_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     bigstring_memset_stub:bigstring_memset_stub,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_memcmp_bytes_stub:bigstring_memcmp_bytes_stub,
     internalhash_fold_bigstring:internalhash_fold_bigstring,
     bigstring_find:bigstring_find,
     expect_test_collector_saved_stdout:expect_test_collector_saved_stdout,
     expect_test_collector_saved_stderr:expect_test_collector_saved_stderr,
     expect_test_collector_before_test:expect_test_collector_before_test,
     expect_test_collector_after_test:expect_test_collector_after_test,
     caml_out_channel_pos_fd:caml_out_channel_pos_fd,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     caml_check_bound_bigstring:caml_check_bound_bigstring,
     bin_prot_blit_buf_float_array_stub:bin_prot_blit_buf_float_array_stub,
     bin_prot_blit_buf_bytes_stub:bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_float_array_buf_stub:bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_string_buf_stub:bin_prot_blit_string_buf_stub,
     bin_prot_blit_bytes_buf_stub:bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_buf_stub:bin_prot_blit_buf_stub,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_caml_exn_is_most_recent_exn:Base_caml_exn_is_most_recent_exn,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_int32_ctz:Base_int_math_int32_ctz,
     Base_int_math_int_ctz:Base_int_math_int_ctz,
     Base_int_math_nativeint_ctz:Base_int_math_nativeint_ctz,
     Base_int_math_int64_ctz:Base_int_math_int64_ctz,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_hash_string:Base_hash_string,
     Base_hash_double:Base_hash_double,
     Base_am_testing:Base_am_testing,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     caml_alloc_stack:caml_alloc_stack,
     caml_continuation_use_noexc:caml_continuation_use_noexc,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_get_continuation_callstack:caml_get_continuation_callstack,
     caml_ml_condition_new:caml_ml_condition_new,
     caml_ml_condition_wait:caml_ml_condition_wait,
     caml_ml_condition_broadcast:caml_ml_condition_broadcast,
     caml_ml_condition_signal:caml_ml_condition_signal,
     jsoo_effect_not_supported:jsoo_effect_not_supported,
     MlMutex:MlMutex,
     caml_ml_mutex_new:caml_ml_mutex_new,
     caml_ml_mutex_lock:caml_ml_mutex_lock,
     caml_ml_mutex_try_lock:caml_ml_mutex_try_lock,
     caml_ml_mutex_unlock:caml_ml_mutex_unlock,
     caml_lxm_next:caml_lxm_next,
     caml_domain_dls:caml_domain_dls,
     caml_domain_dls_set:caml_domain_dls_set,
     caml_domain_dls_get:caml_domain_dls_get,
     caml_atomic_load:caml_atomic_load,
     caml_atomic_cas:caml_atomic_cas,
     caml_atomic_fetch_add:caml_atomic_fetch_add,
     caml_atomic_exchange:caml_atomic_exchange,
     caml_ml_domain_unique_token:caml_ml_domain_unique_token,
     caml_ml_domain_set_name:caml_ml_domain_set_name,
     caml_recommended_domain_count:caml_recommended_domain_count,
     caml_domain_id:caml_domain_id,
     caml_domain_spawn:caml_domain_spawn,
     caml_ml_domain_id:caml_ml_domain_id,
     caml_ml_domain_cpu_relax:caml_ml_domain_cpu_relax,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_create:caml_weak_create,
     caml_weak_set:caml_weak_set,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_unix_gettimeofday:caml_unix_gettimeofday,
     caml_unix_time:caml_unix_time,
     caml_unix_gmtime:caml_unix_gmtime,
     caml_unix_localtime:caml_unix_localtime,
     caml_unix_mktime:caml_unix_mktime,
     caml_unix_startup:caml_unix_startup,
     caml_unix_cleanup:caml_unix_cleanup,
     caml_unix_filedescr_of_fd:caml_unix_filedescr_of_fd,
     caml_unix_isatty:caml_unix_isatty,
     make_unix_err_args:make_unix_err_args,
     caml_unix_stat:caml_unix_stat,
     caml_unix_stat_64:caml_unix_stat_64,
     caml_unix_lstat:caml_unix_lstat,
     caml_unix_lstat_64:caml_unix_lstat_64,
     caml_unix_mkdir:caml_unix_mkdir,
     caml_unix_rmdir:caml_unix_rmdir,
     caml_unix_symlink:caml_unix_symlink,
     caml_unix_readlink:caml_unix_readlink,
     caml_unix_unlink:caml_unix_unlink,
     caml_unix_getuid:caml_unix_getuid,
     caml_unix_getpwuid:caml_unix_getpwuid,
     caml_unix_has_symlink:caml_unix_has_symlink,
     caml_unix_opendir:caml_unix_opendir,
     caml_unix_readdir:caml_unix_readdir,
     caml_unix_closedir:caml_unix_closedir,
     caml_unix_rewinddir:caml_unix_rewinddir,
     caml_unix_findfirst:caml_unix_findfirst,
     caml_unix_findnext:caml_unix_findnext,
     caml_unix_findclose:caml_unix_findclose,
     caml_unix_inet_addr_of_string:caml_unix_inet_addr_of_string,
     re_match:re_match,
     re_search_forward:re_search_forward,
     re_search_backward:re_search_backward,
     re_string_match:re_string_match,
     re_partial_match:re_partial_match,
     re_replacement_text:re_replacement_text,
     caml_str_initialize:caml_str_initialize,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_sys_exit:caml_sys_exit,
     caml_is_special_exception:caml_is_special_exception,
     caml_format_exception:caml_format_exception,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     caml_set_static_env:caml_set_static_env,
     caml_sys_getenv:caml_sys_getenv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_argv:caml_argv,
     caml_executable_name:caml_executable_name,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_time:caml_sys_time,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     os_type:os_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_variant:caml_runtime_variant,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_call_gen:caml_call_gen,
     caml_named_values:caml_named_values,
     caml_register_named_value:caml_register_named_value,
     caml_named_value:caml_named_value,
     caml_global_data:caml_global_data,
     caml_register_global:caml_register_global,
     caml_get_global_data:caml_get_global_data,
     caml_is_printable:caml_is_printable,
     caml_maybe_print_stats:caml_maybe_print_stats,
     caml_parser_trace:caml_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_update_dummy:caml_update_dummy,
     caml_obj_is_block:caml_obj_is_block,
     caml_obj_tag:caml_obj_tag,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_dup:caml_obj_dup,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_compare_and_swap:caml_obj_compare_and_swap,
     caml_obj_is_shared:caml_obj_is_shared,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_get_public_method:caml_get_public_method,
     caml_oo_last_id:caml_oo_last_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_add_offset:caml_obj_add_offset,
     caml_obj_update_tag:caml_obj_update_tag,
     caml_lazy_update_to_forcing:caml_lazy_update_to_forcing,
     caml_lazy_update_to_forward:caml_lazy_update_to_forward,
     caml_lazy_reset_to_lazy:caml_lazy_reset_to_lazy,
     caml_lazy_read_result:caml_lazy_read_result,
     caml_is_continuation_tag:caml_is_continuation_tag,
     initialize_nat:initialize_nat,
     MlNat:MlNat,
     caml_hash_nat:caml_hash_nat,
     nat_of_array:nat_of_array,
     create_nat:create_nat,
     set_to_zero_nat:set_to_zero_nat,
     blit_nat:blit_nat,
     set_digit_nat:set_digit_nat,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat_native:nth_digit_nat_native,
     num_digits_nat:num_digits_nat,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     is_digit_int:is_digit_int,
     is_digit_zero:is_digit_zero,
     is_digit_odd:is_digit_odd,
     incr_nat:incr_nat,
     add_nat:add_nat,
     complement_nat:complement_nat,
     decr_nat:decr_nat,
     sub_nat:sub_nat,
     mult_digit_nat:mult_digit_nat,
     mult_nat:mult_nat,
     square_nat:square_nat,
     shift_left_nat:shift_left_nat,
     div_helper:div_helper,
     div_digit_nat:div_digit_nat,
     div_nat:div_nat,
     shift_right_nat:shift_right_nat,
     compare_digits_nat:compare_digits_nat,
     compare_nat:compare_nat,
     compare_nat_real:compare_nat_real,
     land_digit_nat:land_digit_nat,
     lor_digit_nat:lor_digit_nat,
     lxor_digit_nat:lxor_digit_nat,
     serialize_nat:serialize_nat,
     deserialize_nat:deserialize_nat,
     caml_str_repeat:caml_str_repeat,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_get:caml_string_get,
     caml_string_get16:caml_string_get16,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get32:caml_string_get32,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get64:caml_string_get64,
     caml_bytes_get64:caml_bytes_get64,
     caml_bytes_get:caml_bytes_get,
     caml_string_set:caml_string_set,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set16:caml_string_set16,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set32:caml_string_set32,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set64:caml_string_set64,
     caml_bytes_set:caml_bytes_set,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     MlBytes:MlBytes,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_uint8_array_of_bytes:caml_uint8_array_of_bytes,
     caml_uint8_array_of_string:caml_uint8_array_of_string,
     caml_create_string:caml_create_string,
     caml_create_bytes:caml_create_bytes,
     caml_string_of_array:caml_string_of_array,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_fill_bytes:caml_fill_bytes,
     caml_blit_bytes:caml_blit_bytes,
     caml_blit_string:caml_blit_string,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_compare:caml_string_compare,
     caml_string_equal:caml_string_equal,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_ml_bytes_content:caml_ml_bytes_content,
     caml_is_ml_string:caml_is_ml_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_new_string:caml_new_string,
     caml_js_from_string:caml_js_from_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_to_string:caml_js_to_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_md5_chan:caml_md5_chan,
     caml_md5_string:caml_md5_string,
     caml_MD5Transform:caml_MD5Transform,
     caml_MD5Init:caml_MD5Init,
     caml_MD5Update:caml_MD5Update,
     caml_MD5Final:caml_MD5Final,
     caml_md5_bytes:caml_md5_bytes,
     caml_marshal_constants:caml_marshal_constants,
     MlStringReader:MlStringReader,
     BigStringReader:BigStringReader,
     caml_float_of_bytes:caml_float_of_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_custom_ops:caml_custom_ops,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_marshal_data_size:caml_marshal_data_size,
     MlObjectTable:MlObjectTable,
     caml_legacy_custom_code:caml_legacy_custom_code,
     caml_output_val:caml_output_val,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_lex_array:caml_lex_array,
     caml_lex_engine:caml_lex_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_get_console:caml_js_get_console,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_js_set:caml_js_set,
     caml_js_get:caml_js_get,
     caml_js_delete:caml_js_delete,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_typeof:caml_js_typeof,
     caml_trampoline:caml_trampoline,
     caml_trampoline_return:caml_trampoline_return,
     caml_callback:caml_callback,
     caml_is_js:caml_is_js,
     caml_jsoo_flags_use_js_string:caml_jsoo_flags_use_js_string,
     caml_jsoo_flags_effects:caml_jsoo_flags_effects,
     caml_wrap_exception:caml_wrap_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_js_error_option_of_exception:caml_js_error_option_of_exception,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_array:caml_js_to_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_js_var:caml_js_var,
     caml_js_call:caml_js_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_new:caml_js_new,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_unsafe:caml_js_wrap_callback_unsafe,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_function_arity:caml_js_function_arity,
     caml_js_equals:caml_js_equals,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_expr:caml_js_expr,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_object:caml_js_object,
     caml_sys_fds:caml_sys_fds,
     caml_sys_close:caml_sys_close,
     caml_sys_open:caml_sys_open,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_ml_channels:caml_ml_channels,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_refill:caml_refill,
     caml_ml_input:caml_ml_input,
     caml_ml_input_block:caml_ml_input_block,
     caml_input_value:caml_input_value,
     caml_input_value_to_outside_heap:caml_input_value_to_outside_heap,
     caml_ml_input_char:caml_ml_input_char,
     caml_ml_input_int:caml_ml_input_int,
     caml_seek_in:caml_seek_in,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_pos_in:caml_pos_in,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_flush:caml_ml_flush,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_output:caml_ml_output,
     caml_ml_output_char:caml_ml_output_char,
     caml_output_value:caml_output_value,
     caml_seek_out:caml_seek_out,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_pos_out:caml_pos_out,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_is_buffered:caml_ml_is_buffered,
     caml_ml_set_buffered:caml_ml_set_buffered,
     caml_format_int:caml_format_int,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_parse_digit:caml_parse_digit,
     caml_int_of_string:caml_int_of_string,
     caml_mul:caml_mul,
     caml_div:caml_div,
     caml_mod:caml_mod,
     caml_bswap16:caml_bswap16,
     caml_int32_bswap:caml_int32_bswap,
     caml_int64_bswap:caml_int64_bswap,
     caml_int64_offset:caml_int64_offset,
     MlInt64:MlInt64,
     caml_int64_ult:caml_int64_ult,
     caml_int64_compare:caml_int64_compare,
     caml_int64_neg:caml_int64_neg,
     caml_int64_add:caml_int64_add,
     caml_int64_sub:caml_int64_sub,
     caml_int64_mul:caml_int64_mul,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_and:caml_int64_and,
     caml_int64_or:caml_int64_or,
     caml_int64_xor:caml_int64_xor,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_div:caml_int64_div,
     caml_int64_mod:caml_int64_mod,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_format:caml_int64_format,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_hash:caml_int64_hash,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_nextafter_float:caml_nextafter_float,
     caml_trunc_float:caml_trunc_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_classify_float:caml_classify_float,
     caml_modf_float:caml_modf_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_frexp_float:caml_frexp_float,
     caml_float_compare:caml_float_compare,
     caml_copysign_float:caml_copysign_float,
     caml_signbit_float:caml_signbit_float,
     caml_expm1_float:caml_expm1_float,
     caml_exp2_float:caml_exp2_float,
     caml_log1p_float:caml_log1p_float,
     caml_log2_float:caml_log2_float,
     caml_hypot_float:caml_hypot_float,
     caml_log10_float:caml_log10_float,
     caml_cosh_float:caml_cosh_float,
     caml_acosh_float:caml_acosh_float,
     caml_sinh_float:caml_sinh_float,
     caml_asinh_float:caml_asinh_float,
     caml_tanh_float:caml_tanh_float,
     caml_atanh_float:caml_atanh_float,
     caml_round_float:caml_round_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_erf_float:caml_erf_float,
     caml_erfc_float:caml_erfc_float,
     caml_fma_float:caml_fma_float,
     caml_format_float:caml_format_float,
     caml_float_of_string:caml_float_of_string,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash:caml_hash,
     caml_string_hash:caml_string_hash,
     caml_gr_state:caml_gr_state,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gc_minor:caml_gc_minor,
     caml_gc_major:caml_gc_major,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_counters:caml_gc_counters,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_stat:caml_gc_stat,
     caml_gc_set:caml_gc_set,
     caml_gc_get:caml_gc_get,
     caml_memprof_set:caml_memprof_set,
     caml_final_register:caml_final_register,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_release:caml_final_release,
     caml_memprof_start:caml_memprof_start,
     caml_memprof_stop:caml_memprof_stop,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_get_minor_free:caml_get_minor_free,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_major_credit:caml_get_major_credit,
     fs_node_supported:fs_node_supported,
     MlNodeDevice:MlNodeDevice,
     MlNodeFd:MlNodeFd,
     caml_sys_open_for_node:caml_sys_open_for_node,
     MlFakeDevice:MlFakeDevice,
     MlFakeFile:MlFakeFile,
     MlFakeFd_out:MlFakeFd_out,
     MlFakeFd:MlFakeFd,
     caml_trailing_slash:caml_trailing_slash,
     caml_current_dir:caml_current_dir,
     caml_get_root:caml_get_root,
     caml_root:caml_root,
     MlFile:MlFile,
     path_is_absolute:path_is_absolute,
     caml_make_path:caml_make_path,
     jsoo_mount_point:jsoo_mount_point,
     caml_list_mount_point:caml_list_mount_point,
     resolve_fs_device:resolve_fs_device,
     caml_mount_autoload:caml_mount_autoload,
     caml_unmount:caml_unmount,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_sys_chdir:caml_sys_chdir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_rename:caml_sys_rename,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_ba_map_file:caml_ba_map_file,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     jsoo_create_file_extern:jsoo_create_file_extern,
     caml_fs_init:caml_fs_init,
     caml_create_file:caml_create_file,
     jsoo_create_file:jsoo_create_file,
     caml_read_file_content:caml_read_file_content,
     caml_parse_format:caml_parse_format,
     caml_finish_formatting:caml_finish_formatting,
     caml_raise_constant:caml_raise_constant,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_raise_with_args:caml_raise_with_args,
     caml_raise_with_string:caml_raise_with_string,
     caml_failwith:caml_failwith,
     caml_invalid_argument:caml_invalid_argument,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_not_found:caml_raise_not_found,
     caml_array_bound_error:caml_array_bound_error,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val:caml_compare_val,
     caml_compare:caml_compare,
     caml_int_compare:caml_int_compare,
     caml_equal:caml_equal,
     caml_notequal:caml_notequal,
     caml_greaterequal:caml_greaterequal,
     caml_greaterthan:caml_greaterthan,
     caml_lessequal:caml_lessequal,
     caml_lessthan:caml_lessthan,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_of_typed_array:bigstring_of_typed_array,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_ba_init:caml_ba_init,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_custom_name:caml_ba_custom_name,
     Ml_Bigarray:Ml_Bigarray,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     caml_ba_compare:caml_ba_compare,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_create:caml_ba_create,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_layout:caml_ba_layout,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_dim:caml_ba_dim,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_sub:caml_ba_sub,
     caml_ba_slice:caml_ba_slice,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_hash:caml_ba_hash,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_backtrace_status:caml_backtrace_status,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_array_sub:caml_array_sub,
     caml_array_append:caml_array_append,
     caml_array_concat:caml_array_concat,
     caml_array_blit:caml_array_blit,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_set:caml_array_set,
     caml_array_get:caml_array_get,
     caml_array_fill:caml_array_fill,
     caml_check_bound:caml_check_bound,
     caml_make_vect:caml_make_vect,
     caml_make_float_vect:caml_make_float_vect,
     caml_floatarray_create:caml_floatarray_create};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtYWluLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiT2JqZWN0IiwiZ2xvYmFsVGhpcyIsInRoaXMiLCJnZXQiLCJfVF8iLCJnbG9iYWwiLCJzZWxmIiwiRGVmYXVsdExvY2FsZSIsImRlZmF1bHRTdHJmdGltZSIsIlN0cmZ0aW1lIiwiaXNDb21tb25KUyIsIm1vZHVsZSIsIm5hbWVzcGFjZSIsImFkYXB0ZWRTdHJmdGltZSIsImRlcHJlY2F0ZWRTdHJmdGltZSIsImpvb19nbG9iYWxfb2JqZWN0IiwiZXZhbCIsIl9yZXF1aXJlIiwiX2RlcHJlY2F0aW9uV2FybmluZ3MiLCJkZXByZWNhdGlvbldhcm5pbmciLCJuYW1lIiwiaW5zdGVhZCIsImNvbnNvbGUiLCJkZXByZWNhdGVkU3RyZnRpbWVUWiIsImRlcHJlY2F0ZWRTdHJmdGltZVVUQyIsImRlcHJlY2F0ZWRTdHJmdGltZUxvY2FsaXplZCIsImFkYXB0Rm9yd2FyZHMiLCJmbiIsImZtdCIsImQiLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJzdHJmdGltZSIsInRpbWV6b25lIiwibnVsbCIsInV0Y1N0cmZ0aW1lIiwiRGF0ZSIsImN1c3RvbVRpbWV6b25lT2Zmc2V0IiwidXNlVXRjVGltZXpvbmUiLCJfbG9jYWxlIiwiX2N1c3RvbVRpbWV6b25lT2Zmc2V0IiwiX3VzZVV0Y0Jhc2VkRGF0ZSIsIl9jYWNoZWREYXRlVGltZXN0YW1wIiwiX2NhY2hlZERhdGUiLCJfc3RyZnRpbWUiLCJmb3JtYXQiLCJkYXRlIiwidGltZXN0YW1wIiwiY3VycmVudFRpbWVzdGFtcCIsImdldFRpbWVzdGFtcFRvVXRjT2Zmc2V0Rm9yIiwiX3Byb2Nlc3NGb3JtYXQiLCJyZXN1bHRTdHJpbmciLCJwYWRkaW5nIiwiaXNJblNjb3BlIiwibGVuZ3RoIiwiZXh0ZW5kZWRUWiIsImkiLCJjdXJyZW50Q2hhckNvZGUiLCJwYWRUaWxsMiIsIk1hdGgiLCJob3VyczEyIiwicGFkVGlsbDMiLCJ3ZWVrTnVtYmVyIiwidHpTdHJpbmciLCJ5IiwiZGF5IiwiU3RyaW5nIiwib3JkaW5hbCIsIm9mZiIsInNpZ24iLCJzZXAiLCJob3VycyIsIm1pbnMiLCJ1c2VVdGNCYXNlZERhdGUiLCJ0aW1lem9uZVR5cGUiLCJwYXJzZUludCIsIm1pbnV0ZXMiLCJudW1iZXJUb1BhZCIsInBhZGRpbmdDaGFyIiwiaG91ciIsImZpcnN0V2Vla2RheSIsIndlZWtkYXkiLCJmaXJzdERheU9mWWVhclV0YyIsImRhdGVVdGMiLCJ5ZGF5Iiwid2Vla051bSIsIm51bWJlciIsImlpIiwiZiIsImV4cG9ydHMiLCJkZWZpbmUiLCJnIiwid2luZG93IiwiZSIsInQiLCJuIiwiciIsInMiLCJvIiwidSIsImEiLCJyZXF1aXJlIiwiRXJyb3IiLCJsIiwiY3JlYXRlRWxlbWVudCIsImRpZmYiLCJ1bmRlZiIsIm5hdGl2ZVNwbGl0IiwiY29tcGxpYW50RXhlY05wY2ciLCJzdHIiLCJzZXBhcmF0b3IiLCJsaW1pdCIsIm91dHB1dCIsImZsYWdzIiwibGFzdExhc3RJbmRleCIsIlJlZ0V4cCIsInNlcGFyYXRvcjIiLCJtYXRjaCIsImxhc3RJbmRleCIsImxhc3RMZW5ndGgiLCJhcmd1bWVudHMiLCJBcnJheSIsIk9uZVZlcnNpb25Db25zdHJhaW50IiwiTVlfVkVSU0lPTiIsImhhc2hLZXkiLCJFdlN0b3JlIiwiZWxlbSIsImhhc2giLCJyb290IiwiSW5kaXZpZHVhbCIsImtleSIsInZhbHVlIiwiT25lVmVyc2lvbiIsIm1vZHVsZU5hbWUiLCJ2ZXJzaW9uIiwiZGVmYXVsdFZhbHVlIiwiZW5mb3JjZUtleSIsInZlcnNpb25WYWx1ZSIsInRvcExldmVsIiwibWluRG9jIiwiZG9jdW1lbnQiLCJkb2NjeSIsImRvbVdhbGsiLCJDb21tZW50IiwiRE9NVGV4dCIsIkRPTUVsZW1lbnQiLCJEb2N1bWVudEZyYWdtZW50IiwiRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJEb2N1bWVudCIsInByb3RvIiwidGFnTmFtZSIsIm5zIiwiZmFtaWx5IiwiZGF0YSIsImlkIiwicmVzdWx0Iiwibm9kZSIsIm93bmVyIiwic2VyaWFsaXplTm9kZSIsImh0bWxucyIsImNoaWxkIiwibmVlZGxlIiwiaW5kZXgiLCJwcmVmaXgiLCJsb2NhbE5hbWUiLCJjb2xvblBvc2l0aW9uIiwiYXR0cmlidXRlcyIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwiZWxlbXMiLCJub2RlQ2xhc3NOYW1lIiwibm9kZUNsYXNzZXMiLCJpdGVtIiwiZWxlbWVudCIsImN1cnJlbnQiLCJsZWZ0IiwicmlnaHQiLCJ0eXBlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJsaXN0ZW5lciIsImV2IiwibGlzdGVuZXJzIiwibGlzdCIsInNsaWNlIiwiaXRlcmF0aXZlbHlXYWxrIiwibm9kZXMiLCJjYiIsInJldCIsInZvaWRFbGVtZW50cyIsImVzY2FwZVRleHQiLCJzZXJpYWxpemVFbGVtZW50Iiwic3RyaW5ncyIsInRhZ25hbWUiLCJwcm9wZXJ0aWVzIiwiZGF0YXNldGlmeSIsImlzUHJvcGVydHkiLCJzdHlsaWZ5Iiwic3R5bGVzIiwiYXR0ciIsImMiLCJkcyIsInByb3BzIiwic3RyaW5naWZ5IiwidHVwbGUiLCJlc2NhcGVBdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZSIsInByb3AiLCJ4IiwibmF0aXZlSXNBcnJheSIsInRvU3RyaW5nIiwiaXNBcnJheSIsIm9iaiIsInBhdGNoIiwiaXNPYmplY3QiLCJpc0hvb2siLCJhcHBseVByb3BlcnRpZXMiLCJwcmV2aW91cyIsInByb3BOYW1lIiwicHJvcFZhbHVlIiwicmVtb3ZlUHJvcGVydHkiLCJwYXRjaE9iamVjdCIsInByZXZpb3VzVmFsdWUiLCJhdHRyTmFtZSIsImF0dHJWYWx1ZSIsImdldFByb3RvdHlwZSIsInJlcGxhY2VyIiwiayIsImlzVk5vZGUiLCJpc1ZUZXh0IiwiaXNXaWRnZXQiLCJoYW5kbGVUaHVuayIsInZub2RlIiwib3B0cyIsImRvYyIsIndhcm4iLCJjaGlsZHJlbiIsImNoaWxkTm9kZSIsIm5vQ2hpbGQiLCJkb21JbmRleCIsInJvb3ROb2RlIiwidHJlZSIsImluZGljZXMiLCJhc2NlbmRpbmciLCJyZWN1cnNlIiwicm9vdEluZGV4IiwiaW5kZXhJblJhbmdlIiwidkNoaWxkcmVuIiwiY2hpbGROb2RlcyIsInZDaGlsZCIsIm5leHRJbmRleCIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50SXRlbSIsImIiLCJWUGF0Y2giLCJ1cGRhdGVXaWRnZXQiLCJhcHBseVBhdGNoIiwidnBhdGNoIiwiZG9tTm9kZSIsInJlbmRlck9wdGlvbnMiLCJ2Tm9kZSIsInJlbW92ZU5vZGUiLCJpbnNlcnROb2RlIiwic3RyaW5nUGF0Y2giLCJ3aWRnZXRQYXRjaCIsInZOb2RlUGF0Y2giLCJyZW9yZGVyQ2hpbGRyZW4iLCJyZXBsYWNlUm9vdCIsInBhcmVudE5vZGUiLCJkZXN0cm95V2lkZ2V0IiwibmV3Tm9kZSIsImxlZnRWTm9kZSIsInZUZXh0Iiwid2lkZ2V0IiwidXBkYXRpbmciLCJ3IiwibW92ZXMiLCJrZXlNYXAiLCJyZW1vdmUiLCJpbnNlcnQiLCJqIiwib2xkUm9vdCIsIm5ld1Jvb3QiLCJyZW5kZXIiLCJwYXRjaE9wIiwicGF0Y2hlcyIsInBhdGNoUmVjdXJzaXZlIiwicGF0Y2hJbmRpY2VzIiwib3duZXJEb2N1bWVudCIsIm5vZGVJbmRleCIsInBhdGNoTGlzdCIsIk51bWJlciIsIkF0dHJpYnV0ZUhvb2siLCJwcmV2IiwibmV4dCIsIkV2SG9vayIsInByb3BlcnR5TmFtZSIsImVzIiwiU29mdFNldEhvb2siLCJWTm9kZSIsIlZUZXh0IiwiaXNWVGh1bmsiLCJwYXJzZVRhZyIsInNvZnRTZXRIb29rIiwiZXZIb29rIiwiaCIsInRhZyIsImlzQ2hpbGRyZW4iLCJ0cmFuc2Zvcm1Qcm9wZXJ0aWVzIiwiYWRkQ2hpbGQiLCJpc0NoaWxkIiwiVW5leHBlY3RlZFZpcnR1YWxFbGVtZW50IiwiZXJyIiwiZXJyb3JTdHJpbmciLCJKU09OIiwic3BsaXQiLCJjbGFzc0lkU3BsaXQiLCJub3RDbGFzc0lkIiwibm9JZCIsInRhZ1BhcnRzIiwicGFydCIsIkRFRkFVTFRfTkFNRVNQQUNFIiwiRVZfTkFNRVNQQUNFIiwiWExJTktfTkFNRVNQQUNFIiwiWE1MX05BTUVTUEFDRSIsIlNWR19QUk9QRVJUSUVTIiwiU1ZHQXR0cmlidXRlTmFtZXNwYWNlIiwiYXR0cmlidXRlSG9vayIsIlNWR19OQU1FU1BBQ0UiLCJzdmciLCJpc1RodW5rIiwicmVuZGVyZWRBIiwicmVuZGVyZWRCIiwicmVuZGVyVGh1bmsiLCJ0aHVuayIsInJlbmRlcmVkVGh1bmsiLCJob29rIiwiaXNWaXJ0dWFsTm9kZSIsImlzVmlydHVhbFRleHQiLCJpc1ZIb29rIiwiVmlydHVhbE5vZGUiLCJub1Byb3BlcnRpZXMiLCJub0NoaWxkcmVuIiwiY291bnQiLCJkZXNjZW5kYW50cyIsImhhc1dpZGdldHMiLCJoYXNUaHVua3MiLCJkZXNjZW5kYW50SG9va3MiLCJob29rcyIsInByb3BlcnR5IiwiVmlydHVhbFBhdGNoIiwiVmlydHVhbFRleHQiLCJ0ZXh0IiwiZGlmZlByb3BzIiwiYUtleSIsImFWYWx1ZSIsImJWYWx1ZSIsIm9iamVjdERpZmYiLCJiS2V5Iiwid2FsayIsImFwcGx5IiwiYXBwbHlDbGVhciIsInRodW5rcyIsImNsZWFyU3RhdGUiLCJhcHBlbmRQYXRjaCIsInByb3BzUGF0Y2giLCJkaWZmQ2hpbGRyZW4iLCJhQ2hpbGRyZW4iLCJvcmRlcmVkU2V0IiwicmVvcmRlciIsImJDaGlsZHJlbiIsImFMZW4iLCJiTGVuIiwibGVuIiwibGVmdE5vZGUiLCJyaWdodE5vZGUiLCJ1bmhvb2siLCJkZXN0cm95V2lkZ2V0cyIsInRodW5rUGF0Y2giLCJoYXNQYXRjaGVzIiwidW5kZWZpbmVkS2V5cyIsImJDaGlsZEluZGV4Iiwia2V5SW5kZXgiLCJiS2V5cyIsImJGcmVlIiwiYUNoaWxkSW5kZXgiLCJhS2V5cyIsImFGcmVlIiwibmV3Q2hpbGRyZW4iLCJmcmVlSW5kZXgiLCJmcmVlQ291bnQiLCJkZWxldGVkSXRlbXMiLCJhSXRlbSIsIml0ZW1JbmRleCIsImxhc3RGcmVlSW5kZXgiLCJuZXdJdGVtIiwic2ltdWxhdGUiLCJzaW11bGF0ZUluZGV4IiwicmVtb3ZlcyIsImluc2VydHMiLCJzaW11bGF0ZUl0ZW0iLCJ3YW50ZWRJdGVtIiwiYXJyIiwia2V5cyIsImZyZWUiLCJ2ZG9tIiwiR2VuZXJpY0hvb2siLCJpbml0IiwidXBkYXRlIiwiZGVzdHJveSIsImV4dHJhIiwiaG9va19zdGF0ZV9rZXkiLCJTeW1ib2wiLCJzdGF0ZSIsImZyb20iLCJ0byIsImNhbWxfaW50NjRfaXNfemVybyIsImNhbWxfc3RyX3JlcGVhdCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV9jb25zdGFudCIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsIm9mZnNldCIsIm1vZHVsdXMiLCJkaXZpc29yIiwicXVvdGllbnQiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJhcmciLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYzEiLCJjMiIsInYiLCJNbEJ5dGVzIiwiY29udGVudHMiLCJjb250ZW50IiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9zdHJpbmdfb2ZfanNieXRlcyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX3BhcnNlX2Zvcm1hdCIsImNhbWxfZmluaXNoX2Zvcm1hdHRpbmciLCJyYXdidWZmZXIiLCJidWZmZXIiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJwIiwiY2FtbF9leHBtMV9mbG9hdCIsImNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJtYWtlX3BhdGhfaXNfYWJzb2x1dGUiLCJwb3NpeCIsInBhdGgiLCJ3aW4zMiIsInNwbGl0RGV2aWNlUmUiLCJkZXZpY2UiLCJpc1VuYyIsIkJvb2xlYW4iLCJwYXRoX2lzX2Fic29sdXRlIiwiY2FtbF90cmFpbGluZ19zbGFzaCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAwIiwiY29tcCIsIm5jb21wIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwidW5peF9lcnJvciIsIm1ha2VfdW5peF9lcnJfYXJncyIsImNvZGUiLCJzeXNjYWxsIiwiZXJybm8iLCJ2YXJpYW50IiwiYXJncyIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9yYWlzZV93aXRoX2FyZ3MiLCJjYW1sX2lzX21sX2J5dGVzIiwiY2FtbF9pc19tbF9zdHJpbmciLCJjYW1sX2J5dGVzX29mX2FycmF5IiwiVWludDhBcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfY29udmVydF9ieXRlc190b19hcnJheSIsImNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9ibGl0X2J5dGVzIiwiczEiLCJpMSIsInMyIiwiaTIiLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwiYnVmIiwicG9zIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsIk1sRmFrZUZkIiwiZmlsZSIsIk1sRmFrZURldmljZSIsInJlcyIsIm5hbWVfc2xhc2giLCJtb2RlIiwicmFpc2VfdW5peCIsInBhcmVudCIsInNlZW4iLCJtIiwiZW50cnkiLCJvayIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmQiLCJmZCIsImJ1Zl9vZmZzZXQiLCJyZWFkIiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwiaXNDaGFyYWN0ZXJEZXZpY2UiLCJqc19zdGF0cyIsInRvX2RpciIsInRhcmdldCIsImxpbmsiLCJmaWxlX2tpbmQiLCJjYW1sX2dldF9yb290IiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfcm9vdCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52IiwicHJvY2VzcyIsInNoaWZ0X3JpZ2h0X25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibmJpdHMiLCJ3cmFwIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImltIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfc3lzX3JlbmFtZSIsIm9fcm9vdCIsIm5fcm9vdCIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwiY2FtbF9tbF9jaGFubmVscyIsImNhbWxfcmVmaWxsIiwiY2hhbiIsInN0cl9hIiwibnJlYWQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjaGFuaWQiLCJwcmV2X21heCIsImNhbWxfZ2NfbWlub3IiLCJ1bml0IiwiY29yZV9nY19oZWFwX2NodW5rcyIsImNhbWxfbWxfY29uZGl0aW9uX25ldyIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfaW50X2NvbXBhcmUiLCJiaWdzdHJpbmdhZl9tZW1jbXBfYmlnc3RyaW5nIiwiYmExIiwiYmExX29mZiIsImJhMiIsImJhMl9vZmYiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwicG9zMSIsImJ5dGVzMiIsInBvczIiLCJiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YiIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJqc29vX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmciLCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrIiwiY2FtbF9wYXJzZXJfdHJhY2UiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJvbGRmbGFnIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3NMZW4iLCJleHRyYV9hcmdzIiwibmFyZ3MiLCJjYW1sX2NhbGxiYWNrIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9vYmpfdGFnIiwiRnVuY3Rpb24iLCJjYW1sX29ial91cGRhdGVfdGFnIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyIsImNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbiIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyIsImZpZWxkMCIsImNhbWxfZ2NfY291bnRlcnMiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwiYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzIiwic3JjX29mZiIsImRzdF9vZmYiLCJjYW1sX3VuaXhfY2xvc2VkaXIiLCJkaXJfaGFuZGxlIiwiY2FtbF91bml4X29wZW5kaXIiLCJjYW1sX3VuaXhfcmV3aW5kZGlyIiwibmV3X2Rpcl9oYW5kbGUiLCJjYW1sX3JhaXNlX2VuZF9vZl9maWxlIiwiY2FtbF91bml4X3JlYWRkaXIiLCJjYW1sX3VuaXhfZmluZGZpcnN0IiwicGF0aF9qcyIsImZpcnN0X2VudHJ5IiwiY2FtbF9pc19jb250aW51YXRpb25fdGFnIiwibG9nMl9vayIsImpzb29fZmxvb3JfbG9nMiIsIkluZmluaXR5IiwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IiwiZmxvYXQzMmEiLCJGbG9hdDMyQXJyYXkiLCJpbnQzMmEiLCJJbnQzMkFycmF5IiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJleHAiLCJyMyIsInIyIiwicjEiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJGbG9hdDY0QXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImRpdl9oZWxwZXIiLCJ6IiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJ4MyIsImRlY3JfbmF0IiwiYm9ycm93Iiwic3ViX25hdCIsImNvbXBhcmVfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsImlzX2RpZ2l0X2ludCIsImNhbWxfaW50NjRfZGl2IiwiYmlnc3RyaW5nX2ZpbmQiLCJicyIsImNociIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJzZXJpYWxpemVfbmF0IiwiY2FtbF9tZW1wcm9mX3NldCIsIl9jb250cm9sIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yIiwiY2FtbF9qc19mcm9tX2FycmF5IiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyIiwiZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dCIsImV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdCIsInZvdXRwdXQiLCJ2c3Rkb3V0IiwidnN0ZGVyciIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dldF9nbG9iYWxfZGF0YSIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQiLCJjYW1sX2JhX3VpbnQ4X2dldDE2IiwiYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1YiIsImNhbWxfY2hlY2tfYm91bmQiLCJhcnJheSIsImNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nIiwiYmlnc3RyaW5nIiwiYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YiIsImNhbWxfY29tcGFyZSIsImNhbWxfTUQ1VHJhbnNmb3JtIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJjYW1sX01ENVVwZGF0ZSIsImN0eCIsImlucHV0IiwiaW5wdXRfbGVuIiwiaW5fYnVmIiwiaW5wdXRfcG9zIiwibWlzc2luZyIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iaWdzdHJpbmdfbWVtY21wIiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9lcmZfZmxvYXQiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9nY19tYWpvciIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwiYmFzZSIsImJhY2t0cmsiLCJjYW1sX3N5c19maWxlX2V4aXN0cyIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX2FycmF5X3N1YiIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2dyX3NpemVfeCIsIkJhc2VfaW50X21hdGhfaW50MzJfY2x6IiwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyIsImNhbWxfYXRvbWljX2ZldGNoX2FkZCIsInJlZiIsIm9zX3R5cGUiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiTWxNdXRleCIsImNhbWxfbWxfbXV0ZXhfbmV3IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfa2V5Iiwid2VhayIsImNhbWxfaGFzaF9taXhfZmluYWwiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfbGV4X3J1bl9tZW0iLCJtZW0iLCJjdXJyX3BvcyIsImNhbWxfbGV4X3J1bl90YWciLCJjYW1sX25ld19sZXhfZW5naW5lIiwibGV4X21lbSIsImxleF9iYXNlX2NvZGUiLCJsZXhfYmFja3Rya19jb2RlIiwibGV4X2RlZmF1bHRfY29kZSIsImxleF90cmFuc19jb2RlIiwibGV4X2NoZWNrX2NvZGUiLCJsZXhfY29kZSIsInBjX29mZiIsInBzdGF0ZSIsImJhc2VfY29kZSIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfYWNvc2hfZmxvYXQiLCJjYW1sX01ENUluaXQiLCJBcnJheUJ1ZmZlciIsImIzMiIsIlVpbnQzMkFycmF5IiwiY2FtbF9tbF9mbHVzaCIsImNhbWxfc2Vla19vdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJqc19wZXJmb3JtYW5jZSIsIl9lIiwianNfcHJvZl9tYXJrIiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9tbF9zZXRfYnVmZmVyZWQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfbWxfYnl0ZXNfY29udGVudCIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2giLCJzZWVkIiwicXVldWUiLCJyZCIsIndyIiwiQmFzZV9oYXNoX3N0cmluZyIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImJpbl9wcm90X2JsaXRfZmxvYXRfYXJyYXlfYnVmX3N0dWIiLCJmbG9hdDY0IiwiZmxvYXQ2NF91aW50OCIsImNhbWxfc3lzX29wZW5fZm9yX25vZGUiLCJmcyIsImZkMiIsImNhbWxfc3lzX2ZkcyIsIk1sRmFrZUZkX291dCIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJyZWZpbGwiLCJjaGFubmVsIiwiY2FtbF9NRDVGaW5hbCIsImNhbWxfbWxfaW5wdXRfYmxvY2siLCJhdmFpbCIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9tZDVfY2hhbiIsInRvcmVhZCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY29yZV9tZDVfZmQiLCJpYyIsImNhbWxfZXBoZV9nZXRfa2V5IiwiY2FtbF91bml4X2xvY2FsdGltZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX3VuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIiwiZXhwb25lbnQiLCJvbmUiLCJtdWwiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsImNhbWxfdW5peF9sc3RhdCIsImNhbWxfdW5peF9sc3RhdF82NCIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMiLCJjb250IiwiY2FtbF91bml4X3JtZGlyIiwiY2FtbF9sb2cyX2Zsb2F0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiIsImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwidGEiLCJiaW5fcHJvdF9ibGl0X2J1Zl9zdHViIiwiY2FtbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9kb21haW5faWQiLCJjYW1sX21sX211dGV4X3VubG9jayIsImNhbWxfZG9tYWluX2xhdGVzdF9pZHgiLCJjYW1sX2RvbWFpbl9zcGF3biIsIm11dGV4IiwiY2FtbF91bml4X21rZGlyIiwicGVybSIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXQiLCJjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmQiLCJjYW1sX2JhX2RpbSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfZXBoZV9kYXRhX29mZnNldCIsImNhbWxfd2Vha19jcmVhdGUiLCJjYW1sX2VwaGVfY3JlYXRlIiwiYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YiIsInZfYnN0ciIsImJpZ3N0cmluZ19yZWFsbG9jIiwibmV3X2RhdGEiLCJuZXdfYmlnc3RyaW5nIiwiY2FtbF9qc190b19ieXRlX3N0cmluZyIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfbWF5YmVfcHJpbnRfc3RhdHMiLCJjYW1sX2J5dGVzX2dldDY0IiwiY2FtbF91bml4X2hhc19zeW1saW5rIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX2VwaGVfdW5zZXRfa2V5IiwiY2FtbF93ZWFrX3NldCIsImNhbWxfc3lzX3JlbW92ZSIsImNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF91bml4X2luZXRfYWRkcl9vZl9zdHJpbmciLCJCYXNlX2FtX3Rlc3RpbmciLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2x4bV9uZXh0Iiwic2hpZnRfbCIsInNoaWZ0X3IiLCJvciIsInhvciIsInJvdGwiLCJzZXQiLCJNIiwiZGFiYSIsInEwIiwicTEiLCJzdCIsIngwIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjbWQiLCJjaGlsZF9wcm9jZXNzIiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJjYW1sX3VuaXhfZ2V0dWlkIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJiaWdzdHJpbmdfbWVtY21wX3N0dWIiLCJ2X3MxIiwidl9zMV9wb3MiLCJ2X3MyIiwidl9zMl9wb3MiLCJ2X2xlbiIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJibG9jayIsImNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwIiwiY2FtbF9hdG9taWNfY2FzIiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX21kNV9ieXRlcyIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX21sX2NvbmRpdGlvbl93YWl0IiwibXV0ZXh0IiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJjYW1sX2dyX3NpemVfeSIsImNvcmVfZ2NfbWlub3JfY29sbGVjdGlvbnMiLCJjYW1sX3Bvc19pbiIsImNhbWxfbWxfcG9zX2luIiwiY2FtbF9pbnQ2NF9hbmQiLCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF91bml4X3VubGluayIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImJpZ3N0cmluZ19hbGxvYyIsIl8iLCJjYW1sX3N0cmluZ19nZXQiLCJyZV9tYXRjaCIsInJlX3dvcmRfbGV0dGVycyIsIm9wY29kZXMiLCJpc193b3JkX2xldHRlciIsImluX2JpdHNldCIsInJlX21hdGNoX2ltcGwiLCJwYXJ0aWFsIiwicHJvZyIsImNwb29sIiwibm9ybXRhYmxlIiwibnVtZ3JvdXBzIiwibnVtcmVnaXN0ZXJzIiwic3RhcnRjaGFycyIsInBjIiwicXVpdCIsImdyb3VwcyIsInJlX3JlZ2lzdGVyIiwiYmFja3RyYWNrIiwicHVzaCIsImFjY2VwdCIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsInJlX3NlYXJjaF9iYWNrd2FyZCIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwibmV3X2RpbXMiLCJjb3JlX2djX2NvbXBhY3Rpb25zIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9tbF9tdXRleF90cnlfbG9jayIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfdW5peF9nbXRpbWUiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2dyX2N1cnJlbnRfeCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfc3RyaW5nX2hhc2giLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImJ0IiwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHoiLCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHoiLCJleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9qc19mdW5jdGlvbl9hcml0eSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uIiwiY2FtbF9mb3JtYXRfZXhjZXB0aW9uIiwiYnVja2V0Iiwic3RhcnQiLCJjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImhhbmRsZXIiLCJhdF9leGl0IiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2V4cDJfZmxvYXQiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiYmlnc3RyaW5nX21lbWNtcF9ieXRlc19zdHViIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQiLCJjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHoiLCJiaWdzdHJpbmdfbWVtc2V0X3N0dWIiLCJ2X3BvcyIsInZfY2hhciIsImNhbWxfYXRhbmhfZmxvYXQiLCJjYW1sX21sX2NvbmRpdGlvbl9zaWduYWwiLCJjYW1sX3VuaXhfZmluZG5leHQiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9tbF9kb21haW5faWQiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX21sX2lzX2J1ZmZlcmVkIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmciLCJCYXNlX2ludF9tYXRoX2ludDY0X2NseiIsImNhbWxfYXJyYXlfYXBwZW5kIiwibDEiLCJsMiIsImNhbWxfdW5peF9nZXR0aW1lb2ZkYXkiLCJjYW1sX3VuaXhfdGltZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwianNfcHJvZl9jbGVhcl9tYXJrcyIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfanNfZXhwciIsImNhbWxfanNfdG9fc3RyaW5nIiwiY2FtbF9vanNfaXRlcmF0ZV9wcm9wZXJ0aWVzIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjb3JlX2djX3J1bl9tZW1wcm9mX2NhbGxiYWNrcyIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9ldmVudGxvZ19yZXN1bWUiLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmciLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJyZV9yZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJjdXIiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImNhbWxfYmxpdF9zdHJpbmciLCJibGl0X25hdCIsImNvcmVfZ2NfdG9wX2hlYXBfd29yZHMiLCJjYW1sX3VuaXhfc3RhdCIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJqc29vX2NyZWF0ZV9maWxlX2V4dGVybiIsImNhbWxfdW5peF9zdGF0XzY0IiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX21sX211dGV4X2xvY2siLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeSIsImNhbWxfbWxfb3V0cHV0X2NoYXIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIiLCJjYW1sX29ial9pc19ibG9jayIsImNhbWxfb2JqX3NldF9yYXdfZmllbGQiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0IiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsImJ1ZmYiLCJub3ciLCJhbGxfZmluYWxpemVycyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsImNhbWxfbGF6eV9yZXNldF90b19sYXp5IiwiY2FtbF9qc19kZWxldGUiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX2xpc3RfbW91bnRfcG9pbnQiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9qc19lcXVhbHMiLCJjYW1sX29ial9jb21wYXJlX2FuZF9zd2FwIiwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9ncl9hcmNfYXV4IiwiY3giLCJjeSIsInJ5IiwicngiLCJyb3QiLCJ4UG9zIiwieVBvcyIsInhQb3NfcHJldiIsInlQb3NfcHJldiIsInNwYWNlIiwiZGVsdGEiLCJjYW1sX2dyX2ZpbGxfYXJjIiwiY2FtbF9iYV9zbGljZSIsIm51bV9pbmRzIiwic3ViX2RpbXMiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9vdXRfY2hhbm5lbF9wb3NfZmQiLCJpbmZvIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfZ2NfbWFqb3Jfc2xpY2UiLCJ3b3JrIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwiY2FtbF91bml4X2NsZWFudXAiLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY29yZV9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2siLCJjYW1sX29ial9pc19zaGFyZWQiLCJjb3JlX2djX3Byb21vdGVkX3dvcmRzIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImNhbWxfYXNpbmhfZmxvYXQiLCJjYW1sX3Bvc19vdXQiLCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIiwiYWIiLCJjYW1sX21vZCIsImNhbWxfYmFfaW5pdCIsImNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF91bml4X3N0YXJ0dXAiLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwiY2FtbF9tb3VudF9hdXRvbG9hZCIsIkJhc2VfaW50X21hdGhfaW50X2NseiIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwianNfcHJvZl9jbGVhcl9tZWFzdXJlcyIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2RpdiIsImNhbWxfb2JqX2R1cCIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX21sX2RvbWFpbl9zZXRfbmFtZSIsIl9uYW1lIiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nIiwiYmFfb2ZmIiwic3RyX29mZiIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJtdWx0X25hdCIsImxlbjMiLCJzcXVhcmVfbmF0IiwiY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyIsInJlczIiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0IiwiYmlnc3RyaW5nYWZfbWVtY2hyIiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImJpbl9wcm90X2JsaXRfYnVmX2J5dGVzX3N0dWIiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9zeXNfdW5zYWZlX2dldGVudiIsImNhbWxfcm91bmRfZmxvYXQiLCJqc19wcm9mX21lYXN1cmUiLCJjYW1sX29qc19uZXdfYXJyIiwiRiIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9kb21haW5fZGxzIiwiY2FtbF9kb21haW5fZGxzX3NldCIsImNhbWxfbGF6eV9yZWFkX3Jlc3VsdCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY29yZV9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzIiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfZ3Jfc3RhdGVfc2V0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCIsImFyaXR5IiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX2ludDMyX2Jzd2FwIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJkaWdpdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfdGFuaF9mbG9hdCIsIkJhc2VfaW50X21hdGhfaW50X2N0eiIsImJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YiIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfc3RyaW5nX3NldCIsImNhbWxfc3lzX3JtZGlyIiwiY2FtbF91bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHoiLCJpc196ZXJvIiwibGFuZCIsInNtYWxsX2ludDY0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCIsIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuIiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWUiLCJjYW1sX2ZtYV9mbG9hdCIsIlNQTElUIiwiTUlOX1ZBTFVFIiwiRVBTSUxPTiIsIkMiLCJBIiwiQiIsIm11bHRpcGx5IiwiYXQiLCJhaGkiLCJhbG8iLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJjYW1sX2dyX2RyYXdfcmVjdCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY29yZV9nY19tYWpvcl9jb2xsZWN0aW9ucyIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfaW5pdGlhbF90aW1lIiwiY2FtbF9zeXNfdGltZSIsImNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbiIsIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIiwiY2FtbF91bml4X2dldHB3dWlkIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfZG9tYWluX2Rsc19nZXQiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViIiwiY29yZV90aW1lX25zX2Zvcm1hdCIsInRpbWUiLCJmb3JtYXRqcyIsImpzdHJpbmciLCJjYW1sX29qc193cmFwX2Z1bl9hcmd1bWVudHMiLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvbiIsImNhbWxfbWxfcG9zX291dF82NCIsImNhbWxfdW5peF9maW5kY2xvc2UiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9nZXRfbWlub3JfZnJlZSIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJCYXNlX2hhc2hfZG91YmxlIiwiY2FtbF9qc19uZXciLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZm9ybWF0X2ludCIsImNvcmVfZ2NfaGVhcF93b3JkcyIsImpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjIiwiaHZhbCIsImhleG4iLCJoZWZmIiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjb3JlX2djX21pbm9yX3dvcmRzIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJidWZmZXJlZCIsImNhbWxfYXJyYXlfY29uY2F0IiwiY2FtbF9ncl9vcGVuX2dyYXBoIiwic3BlY3MiLCJzdGF0dXMiLCJ3aW4iLCJ0aXRsZSIsImJvZHkiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfY2JydF9mbG9hdCIsImNhbWxfbWVtcHJvZl9zdG9wIiwiY2FtbF9ldmVudGxvZ19wYXVzZSIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiYmlnc3RyaW5nYWZfYmxpdF90b19iaWdzdHJpbmciLCJtc190b19uYW5vIiwidGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvIiwibXMiLCJtc19pNjMiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYWxsb2Nfc3RhY2siLCJodiIsImh4IiwiaGYiLCJjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YiIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfdW5peF9yZWFkbGluayIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwibG9vcCIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsInRibF9uYW1lc19jb25zdCIsInRibF9uYW1lc19ibG9jayIsImxvZyIsInRva2VuX25hbWUiLCJuYW1lcyIsInByaW50X3Rva2VuIiwidG9rIiwidG9rZW4iLCJuMSIsIm4yIiwic3RhdGUxIiwic3AiLCJlcnJmbGFnIiwiYXNwIiwiY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHMiLCJjb3JlX2djX21ham9yX3dvcmRzIiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N5c19ta2RpciIsImJpZ3N0cmluZ19ibGl0X3N0dWIiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX2dyX21ha2VfaW1hZ2UiLCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwib3JpZ2luIiwiZXZlbnQiXSwic291cmNlcyI6WyIiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvY29yZS9zdHJmdGltZS5qcyIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi92aXJ0dWFsX2RvbS92aXJ0dWFsZG9tLmNvbXBpbGVkLmpzIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL3ZpcnR1YWxfZG9tL2hvb2tzLmpzIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK2VmZmVjdC5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvY29yZS9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmlnc3RyaW5nYWYvcnVudGltZS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZV9iaWdzdHJpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytpbnRzLmpzIiwiL2J1aWx0aW4vK2hhc2guanMiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvYmFzZS9iYXNlX2ludGVybmFsaGFzaF90eXBlcy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2RvbWFpbi5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi9wcHhfZXhwZWN0L2NvbGxlY3Rvci9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jpbl9wcm90L3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL2Jhc2UvcnVudGltZS5qcyIsIi9idWlsdGluLytzeW5jLmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvaG9tZS9iZW4vLm9wYW0vNC4xNC9saWIvaW5jcl9kb20vamF2YXNjcmlwdF9wcm9maWxpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytwcm5nLmpzIiwiL2hvbWUvYmVuLy5vcGFtLzQuMTQvbGliL29qcy9vanNfcnVudGltZS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL2Jlbi8ub3BhbS80LjE0L2xpYi90aW1lX25vdy9ydW50aW1lLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBLENBQUM7SUFBVUE7SUFDVCxPQUFPQzs7OztLQUNMQztPQUNFO1FBQ0M7VUFBc0JGLDhDQUVoQkc7UUFDSEM7SUFFUixTQUFTRDtNQUNQLElBQUlFLE9BQVNILFFBQVFJO01BQ3JCLG9CQUFvQkQ7TUFDcEIsT0FBT0wsb0JBQ1QsQ0FiRDtHQWNDQTs7O0lDSkQsQ0FBQztRQUVFO1NBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQXFCRSxvQkFBTVMsU0FBU0Y7U0FDcEIsa0JBQVNJO1NBQ3BCQztRQUdKLEdBQUlGO1NBQVksQ0FDWixZQUFZQyxpQkFBaUJFO1VBQzdCLHFCQUFxQkM7VUFDckIsR0FBR0Msa0JBQW1CLDZCQUE2QkY7O1NBR2xELENBRUQ7O1VBQVlFOztVQUFzQixXQUFhLE9BQU9iLFFBQVEsR0FBR2MsYUFB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VSIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiLy9cbi8vIHN0cmZ0aW1lXG4vLyBnaXRodWIuY29tL3NhbXNvbmpzL3N0cmZ0aW1lXG4vLyBAX3Nqc1xuLy9cbi8vIENvcHlyaWdodCAyMDEwIC0gMjAxNSBTYW1pIFNhbWh1cmkgPHNhbWlAc2FtaHVyaS5uZXQ+XG4vL1xuLy8gTUlUIExpY2Vuc2Vcbi8vIGh0dHA6Ly9zanMubWl0LWxpY2Vuc2Uub3JnXG4vL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIERlZmF1bHRMb2NhbGUgPSB7XG4gICAgICAgICAgICBkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICBzaG9ydERheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgICAgICAgICBtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgICAgICAgc2hvcnRNb250aHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAgICAgICAgIEFNOiAnQU0nLFxuICAgICAgICAgICAgUE06ICdQTScsXG4gICAgICAgICAgICBhbTogJ2FtJyxcbiAgICAgICAgICAgIHBtOiAncG0nLFxuICAgICAgICAgICAgZm9ybWF0czoge1xuICAgICAgICAgICAgICAgIEQ6ICclbS8lZC8leScsXG4gICAgICAgICAgICAgICAgRjogJyVZLSVtLSVkJyxcbiAgICAgICAgICAgICAgICBSOiAnJUg6JU0nLFxuICAgICAgICAgICAgICAgIFQ6ICclSDolTTolUycsXG4gICAgICAgICAgICAgICAgWDogJyVUJyxcbiAgICAgICAgICAgICAgICBjOiAnJWEgJWIgJWQgJVggJVknLFxuICAgICAgICAgICAgICAgIHI6ICclSTolTTolUyAlcCcsXG4gICAgICAgICAgICAgICAgdjogJyVlLSViLSVZJyxcbiAgICAgICAgICAgICAgICB4OiAnJUQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRTdHJmdGltZSA9IG5ldyBTdHJmdGltZShEZWZhdWx0TG9jYWxlLCAwLCBmYWxzZSksXG4gICAgICAgIGlzQ29tbW9uSlMgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgbmFtZXNwYWNlO1xuXG4gICAgLy8gQ29tbW9uSlMgLyBOb2RlIG1vZHVsZVxuICAgIGlmIChpc0NvbW1vbkpTKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IG1vZHVsZS5leHBvcnRzID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgICAgICBuYW1lc3BhY2Uuc3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWU7XG4gICAgICAgIGlmKGpvb19nbG9iYWxfb2JqZWN0KSBqb29fZ2xvYmFsX29iamVjdC5zdHJmdGltZSA9IGFkYXB0ZWRTdHJmdGltZTtcbiAgICB9XG4gICAgLy8gQnJvd3NlcnMgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAgIGVsc2Uge1xuICAgICAgICAvLyBHZXQgdGhlIGdsb2JhbCBvYmplY3QuIFdvcmtzIGluIEVTMywgRVM1LCBhbmQgRVM1IHN0cmljdCBtb2RlLlxuICAgICAgICBuYW1lc3BhY2UgPSBqb29fZ2xvYmFsX29iamVjdCB8fCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIHx8ICgxLGV2YWwpKCd0aGlzJyk7IH0oKSk7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGFkYXB0ZWRTdHJmdGltZTtcbiAgICB9XG5cbiAgICAvLyBEZXByZWNhdGVkIEFQSSwgdG8gYmUgcmVtb3ZlZCBpbiB2MS4wXG4gICAgdmFyIF9yZXF1aXJlID0gaXNDb21tb25KUyA/IFwicmVxdWlyZSgnc3RyZnRpbWUnKVwiIDogXCJzdHJmdGltZVwiO1xuICAgIHZhciBfZGVwcmVjYXRpb25XYXJuaW5ncyA9IHt9O1xuICAgIGZ1bmN0aW9uIGRlcHJlY2F0aW9uV2FybmluZyhuYW1lLCBpbnN0ZWFkKSB7XG4gICAgICAgIGlmICghX2RlcHJlY2F0aW9uV2FybmluZ3NbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddIFwiICsgbmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDEuMC4gSW5zdGVhZCwgdXNlIGBcIiArIGluc3RlYWQgKyBcImAuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2RlcHJlY2F0aW9uV2FybmluZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmFtZXNwYWNlLnN0cmZ0aW1lVFogPSBkZXByZWNhdGVkU3RyZnRpbWVUWjtcbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVVVEMgPSBkZXByZWNhdGVkU3RyZnRpbWVVVEM7XG4gICAgbmFtZXNwYWNlLmxvY2FsaXplZFN0cmZ0aW1lID0gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkO1xuXG4gICAgLy8gQWRhcHQgdGhlIG9sZCBBUEkgd2hpbGUgcHJlc2VydmluZyB0aGUgbmV3IEFQSS5cbiAgICBmdW5jdGlvbiBhZGFwdEZvcndhcmRzKGZuKSB7XG4gICAgICAgIGZuLmxvY2FsaXplID0gZGVmYXVsdFN0cmZ0aW1lLmxvY2FsaXplLmJpbmQoZGVmYXVsdFN0cmZ0aW1lKTtcbiAgICAgICAgZm4udGltZXpvbmUgPSBkZWZhdWx0U3RyZnRpbWUudGltZXpvbmUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi51dGMgPSBkZWZhdWx0U3RyZnRpbWUudXRjLmJpbmQoZGVmYXVsdFN0cmZ0aW1lKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGFkYXB0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gYWRhcHRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIGQgYW5kIGxvY2FsZSBhcmUgb3B0aW9uYWwsIGNoZWNrIGlmIHRoaXMgaXMgKGZvcm1hdCwgbG9jYWxlKVxuICAgICAgICBpZiAoZCAmJiBkLmRheXMpIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGQ7XG4gICAgICAgICAgICBkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgYWRhcHRGb3J3YXJkcyhkZXByZWNhdGVkU3RyZnRpbWUpO1xuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWRTdHJmdGltZShmbXQsIGQsIGxvY2FsZSkge1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lKGZvcm1hdCwgW2RhdGVdLCBbbG9jYWxlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcyhmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lKGZvcm1hdCwgW2RhdGVdKWBcIiwgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gbG9jYWxlID8gZGVmYXVsdFN0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiBkZWZhdWx0U3RyZnRpbWU7XG4gICAgICAgIHJldHVybiBzdHJmdGltZShmbXQsIGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWRTdHJmdGltZVRaKGZtdCwgZCwgbG9jYWxlLCB0aW1lem9uZSkge1xuICAgICAgICAvLyBsb2NhbGUgaXMgb3B0aW9uYWwsIGNoZWNrIGlmIHRoaXMgaXMgKGZvcm1hdCwgZGF0ZSwgdGltZXpvbmUpXG4gICAgICAgIGlmICgodHlwZW9mIGxvY2FsZSA9PSAnbnVtYmVyJyB8fCB0eXBlb2YgbG9jYWxlID09ICdzdHJpbmcnKSAmJiB0aW1lem9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lem9uZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVUWihmb3JtYXQsIGRhdGUsIGxvY2FsZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudGltZXpvbmUodHopOyBzKGZvcm1hdCwgW2RhdGVdKWAgb3IgYHZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVUWihmb3JtYXQsIGRhdGUsIHR6KWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KShmb3JtYXQsIFtkYXRlXSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyZnRpbWUgPSAobG9jYWxlID8gZGVmYXVsdFN0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiBkZWZhdWx0U3RyZnRpbWUpLnRpbWV6b25lKHRpbWV6b25lKTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgdmFyIHV0Y1N0cmZ0aW1lID0gZGVmYXVsdFN0cmZ0aW1lLnV0YygpO1xuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWRTdHJmdGltZVVUQyhmbXQsIGQsIGxvY2FsZSkge1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLnN0cmZ0aW1lVVRDKGZvcm1hdCwgZGF0ZSwgbG9jYWxlKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpLnV0YygpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBbZGF0ZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnV0YygpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyB1dGNTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogdXRjU3RyZnRpbWU7XG4gICAgICAgIHJldHVybiBzdHJmdGltZShmbXQsIGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWRTdHJmdGltZUxvY2FsaXplZChsb2NhbGUpIHtcbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZWRTdHJmdGltZShsb2NhbGUpYFwiLCBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSlcIik7XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKTtcbiAgICB9XG4gICAgLy8gRW5kIG9mIGRlcHJlY2F0ZWQgQVBJXG5cbiAgICAvLyBQb2x5ZmlsbCBEYXRlLm5vdyBmb3Igb2xkIGJyb3dzZXJzLlxuICAgIGlmICh0eXBlb2YgRGF0ZS5ub3cgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gK25ldyBEYXRlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU3RyZnRpbWUobG9jYWxlLCBjdXN0b21UaW1lem9uZU9mZnNldCwgdXNlVXRjVGltZXpvbmUpIHtcbiAgICAgICAgdmFyIF9sb2NhbGUgPSBsb2NhbGUgfHwgRGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIF9jdXN0b21UaW1lem9uZU9mZnNldCA9IGN1c3RvbVRpbWV6b25lT2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBfdXNlVXRjQmFzZWREYXRlID0gdXNlVXRjVGltZXpvbmUgfHwgZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIHdlIHN0b3JlIHVuaXggdGltZXN0YW1wIHZhbHVlIGhlcmUgdG8gbm90IGNyZWF0ZSBuZXcgRGF0ZSgpIGVhY2ggaXRlcmF0aW9uIChlYWNoIG1pbGxpc2Vjb25kKVxuICAgICAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyAyIHRpbWVzIGZhc3RlciB0aGFuIG5ldyBEYXRlKClcbiAgICAgICAgICAgIC8vIHdoaWxlIG1pbGxpc2Vjb25kIHByZWNpc2UgaXMgZW5vdWdoIGhlcmVcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgdmVyeSBoZWxwZnVsIHdoZW4gc3RyZnRpbWUgdHJpZ2dlcmVkIGEgbG90IG9mIHRpbWVzIG9uZSBieSBvbmVcbiAgICAgICAgICAgIF9jYWNoZWREYXRlVGltZXN0YW1wID0gMCxcbiAgICAgICAgICAgIF9jYWNoZWREYXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9zdHJmdGltZShmb3JtYXQsIGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXA7XG5cbiAgICAgICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRpbWVzdGFtcCA+IF9jYWNoZWREYXRlVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlVGltZXN0YW1wID0gY3VycmVudFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGUgPSBuZXcgRGF0ZShfY2FjaGVkRGF0ZVRpbWVzdGFtcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gX2NhY2hlZERhdGVUaW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvdyB0byBhdm9pZCBkdXBsaWNhdGlvbiBvZiBkYXRlIGluc3RhbnRpYXRpb24gZm9yIHV0YyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGllZCB0byBnZXRUaW1lem9uZU9mZnNldCBvZiB0aGUgY3VycmVudCBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoX2NhY2hlZERhdGUpICsgX2N1c3RvbVRpbWV6b25lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRlID0gX2NhY2hlZERhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGdldFRpbWVzdGFtcFRvVXRjT2Zmc2V0Rm9yKGRhdGUpICsgX2N1c3RvbVRpbWV6b25lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcHJvY2Vzc0Zvcm1hdChmb3JtYXQsIGRhdGUsIF9sb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfcHJvY2Vzc0Zvcm1hdChmb3JtYXQsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0U3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGwsXG4gICAgICAgICAgICAgICAgaXNJblNjb3BlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZm9ybWF0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFRaID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhckNvZGUgPSBmb3JtYXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0luU2NvcGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJy0nXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnXydcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICcwJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDQ4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzonXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWRUWikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddIGRldGVjdGVkIHVzZSBvZiB1bnN1cHBvcnRlZCAlOjogb3IgJTo6OiBtb2RpZmllcnMgdG8gc3RyZnRpbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhhbXBsZXMgZm9yIG5ldyBEYXRlKDApIGluIEdNVFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1cnNkYXknXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5kYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFudWFyeSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLm1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTknXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gMTAwKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMS8wMS83MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuRCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTk3MC0wMS0wMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuRiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0SG91cnMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxMidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0knOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoaG91cnMxMihkYXRlLmdldEhvdXJzKCkpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3NjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDMoTWF0aC5mbG9vcih0aW1lc3RhbXAgJSAxMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRNaW51dGVzKCksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnYW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gbG9jYWxlLmFtIDogbG9jYWxlLnBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDA6MDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdSJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLlIsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDgzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldFNlY29uZHMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuVCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ3N1bmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMih3ZWVrTnVtYmVyKGRhdGUsICdtb25kYXknKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxNjowMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4ODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuWCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTk3MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1knOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnR01UJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gXCJHTVRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeG1lIG9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0elN0cmluZyA9IGRhdGUudG9TdHJpbmcoKS5tYXRjaCgvXFwoKFtcXHdcXHNdKylcXCkvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHR6U3RyaW5nICYmIHR6U3RyaW5nWzFdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1RodSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLnNob3J0RGF5c1tkYXRlLmdldERheSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLnNob3J0TW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLmMsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXREYXRlKCksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyA9PSBudWxsID8gJyAnIDogcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2onOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VGltZSgpIC0geS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDMoZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJyAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnayc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoaG91cnMxMihkYXRlLmdldEhvdXJzKCkpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRNb250aCgpICsgMSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXG4nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzFzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZyhkYXRlLmdldERhdGUoKSkgKyBvcmRpbmFsKGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0FNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuQU0gOiBsb2NhbGUuUE07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxMjowMDowMCBBTSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLnIsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnXFx0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF5ID09PSAwID8gNyA6IGRheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMSAtIDcsIE1vbmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJyAxLUphbi0xOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMudiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIDAgLSA2LCBTdW5kYXkgaXMgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxMi8zMS82OSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IF9wcm9jZXNzRm9ybWF0KGxvY2FsZS5mb3JtYXRzLngsIGRhdGUsIGxvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gKCcnICsgZGF0ZS5nZXRGdWxsWWVhcigpKS5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJyswMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSAmJiBfY3VzdG9tVGltZXpvbmVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGV4dGVuZGVkVFogPyBcIiswMDowMFwiIDogXCIrMDAwMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jdXN0b21UaW1lem9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmID0gX2N1c3RvbVRpbWV6b25lT2Zmc2V0IC8gKDYwICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSAtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gb2ZmIDwgMCA/ICctJyA6ICcrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcCA9IGV4dGVuZGVkVFogPyAnOicgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmYgLyA2MCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlucyA9IE1hdGguYWJzKG9mZiAlIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHNpZ24gKyBwYWRUaWxsMihob3VycykgKyBzZXAgKyBwYWRUaWxsMihtaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gJyUnXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gMzcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJblNjb3BlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGZvcm1hdFtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IF9zdHJmdGltZTtcblxuICAgICAgICBzdHJmdGltZS5sb2NhbGl6ZSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJmdGltZShsb2NhbGUgfHwgX2xvY2FsZSwgX2N1c3RvbVRpbWV6b25lT2Zmc2V0LCBfdXNlVXRjQmFzZWREYXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdHJmdGltZS50aW1lem9uZSA9IGZ1bmN0aW9uKHRpbWV6b25lKSB7XG4gICAgICAgICAgICB2YXIgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdXNlVXRjQmFzZWREYXRlID0gX3VzZVV0Y0Jhc2VkRGF0ZTtcblxuICAgICAgICAgICAgdmFyIHRpbWV6b25lVHlwZSA9IHR5cGVvZiB0aW1lem9uZTtcbiAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdudW1iZXInIHx8IHRpbWV6b25lVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB1c2VVdGNCYXNlZERhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gSVNPIDg2MDEgZm9ybWF0IHRpbWV6b25lIHN0cmluZywgWy0rXUhITU1cbiAgICAgICAgICAgICAgICBpZiAodGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHRpbWV6b25lWzBdID09PSAnLScgPyAtMSA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VycyA9IHBhcnNlSW50KHRpbWV6b25lLnNsaWNlKDEsIDMpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMywgNSksIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXN0b21UaW1lem9uZU9mZnNldCA9IHNpZ24gKiAoKDYwICogaG91cnMpICsgbWludXRlcykgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIG1pbnV0ZXM6IDQyMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lem9uZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gdGltZXpvbmUgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnV0YyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJmdGltZShfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHJmdGltZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMihudW1iZXJUb1BhZCwgcGFkZGluZ0NoYXIpIHtcbiAgICAgICAgaWYgKHBhZGRpbmdDaGFyID09PSAnJyB8fCBudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFkZGluZ0NoYXIgPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmdDaGFyICsgbnVtYmVyVG9QYWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkVGlsbDMobnVtYmVyVG9QYWQpIHtcbiAgICAgICAgaWYgKG51bWJlclRvUGFkID4gOTkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5KSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnICsgbnVtYmVyVG9QYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcwMCcgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBob3VyczEyKGhvdXIpIHtcbiAgICAgICAgaWYgKGhvdXIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob3VyID4gMTIpIHtcbiAgICAgICAgICAgIHJldHVybiBob3VyIC0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuXG4gICAgLy8gZmlyc3RXZWVrZGF5OiAnc3VuZGF5JyBvciAnbW9uZGF5JywgZGVmYXVsdCBpcyAnc3VuZGF5J1xuICAgIC8vXG4gICAgLy8gUGlsZmVyZWQgJiBwb3J0ZWQgZnJvbSBSdWJ5J3Mgc3RyZnRpbWUgaW1wbGVtZW50YXRpb24uXG4gICAgZnVuY3Rpb24gd2Vla051bWJlcihkYXRlLCBmaXJzdFdlZWtkYXkpIHtcbiAgICAgICAgZmlyc3RXZWVrZGF5ID0gZmlyc3RXZWVrZGF5IHx8ICdzdW5kYXknO1xuXG4gICAgICAgIC8vIFRoaXMgd29ya3MgYnkgc2hpZnRpbmcgdGhlIHdlZWtkYXkgYmFjayBieSBvbmUgZGF5IGlmIHdlXG4gICAgICAgIC8vIGFyZSB0cmVhdGluZyBNb25kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgdmFyIHdlZWtkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICBpZiAoZmlyc3RXZWVrZGF5ID09PSAnbW9uZGF5Jykge1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPT09IDApIC8vIFN1bmRheVxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSA2O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdlZWtkYXktLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdERheU9mWWVhclV0YyA9IERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAgICBkYXRlVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKSxcbiAgICAgICAgICAgIHlkYXkgPSBNYXRoLmZsb29yKChkYXRlVXRjIC0gZmlyc3REYXlPZlllYXJVdGMpIC8gODY0MDAwMDApLFxuICAgICAgICAgICAgd2Vla051bSA9ICh5ZGF5ICsgNyAtIHdlZWtkYXkpIC8gNztcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih3ZWVrTnVtKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG9yZGluYWwgc3VmZml4IGZvciBhIG51bWJlcjogc3QsIG5kLCByZCwgb3IgdGhcbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICB2YXIgaSA9IG51bWJlciAlIDEwO1xuICAgICAgICB2YXIgaWkgPSBudW1iZXIgJSAxMDA7XG5cbiAgICAgICAgaWYgKChpaSA+PSAxMSAmJiBpaSA8PSAxMykgfHwgaSA9PT0gMCB8fCBpID49IDQpIHtcbiAgICAgICAgICAgIHJldHVybiAndGgnO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gJ3N0JztcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuICduZCc7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiAncmQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkge1xuICAgICAgICByZXR1cm4gKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSB8fCAwKSAqIDYwMDAwO1xuICAgIH1cblxufSgpKTtcbiIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLlZpcnR1YWxEb20gPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoXCIuL3Zkb20vY3JlYXRlLWVsZW1lbnQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFbGVtZW50XG5cbn0se1wiLi92ZG9tL2NyZWF0ZS1lbGVtZW50LmpzXCI6MjR9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkaWZmID0gcmVxdWlyZShcIi4vdnRyZWUvZGlmZi5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcblxufSx7XCIuL3Z0cmVlL2RpZmYuanNcIjo0N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIE9uZVZlcnNpb25Db25zdHJhaW50ID0gcmVxdWlyZSgnaW5kaXZpZHVhbC9vbmUtdmVyc2lvbicpO1xuXG52YXIgTVlfVkVSU0lPTiA9ICc3Jztcbk9uZVZlcnNpb25Db25zdHJhaW50KCdldi1zdG9yZScsIE1ZX1ZFUlNJT04pO1xuXG52YXIgaGFzaEtleSA9ICdfX0VWX1NUT1JFX0tFWUAnICsgTVlfVkVSU0lPTjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdlN0b3JlO1xuXG5mdW5jdGlvbiBFdlN0b3JlKGVsZW0pIHtcbiAgICB2YXIgaGFzaCA9IGVsZW1baGFzaEtleV07XG5cbiAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgaGFzaCA9IGVsZW1baGFzaEtleV0gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbn1cblxufSx7XCJpbmRpdmlkdWFsL29uZS12ZXJzaW9uXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG5cbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID9cbiAgICBnbG9iYWwgOiB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRpdmlkdWFsO1xuXG5mdW5jdGlvbiBJbmRpdmlkdWFsKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Rba2V5XTtcbiAgICB9XG5cbiAgICByb290W2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEluZGl2aWR1YWwgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT25lVmVyc2lvbjtcblxuZnVuY3Rpb24gT25lVmVyc2lvbihtb2R1bGVOYW1lLCB2ZXJzaW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIga2V5ID0gJ19fSU5ESVZJRFVBTF9PTkVfVkVSU0lPTl8nICsgbW9kdWxlTmFtZTtcbiAgICB2YXIgZW5mb3JjZUtleSA9IGtleSArICdfRU5GT1JDRV9TSU5HTEVUT04nO1xuXG4gICAgdmFyIHZlcnNpb25WYWx1ZSA9IEluZGl2aWR1YWwoZW5mb3JjZUtleSwgdmVyc2lvbik7XG5cbiAgICBpZiAodmVyc2lvblZhbHVlICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgaGF2ZSBvbmUgY29weSBvZiAnICtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgKyAnLlxcbicgK1xuICAgICAgICAgICAgJ1lvdSBhbHJlYWR5IGhhdmUgdmVyc2lvbiAnICsgdmVyc2lvblZhbHVlICtcbiAgICAgICAgICAgICcgaW5zdGFsbGVkLlxcbicgK1xuICAgICAgICAgICAgJ1RoaXMgbWVhbnMgeW91IGNhbm5vdCBpbnN0YWxsIHZlcnNpb24gJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBJbmRpdmlkdWFsKGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxufSx7XCIuL2luZGV4LmpzXCI6NX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIHRvcExldmVsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge31cbnZhciBtaW5Eb2MgPSByZXF1aXJlKCdtaW4tZG9jdW1lbnQnKTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICB2YXIgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddO1xuXG4gICAgaWYgKCFkb2NjeSkge1xuICAgICAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J10gPSBtaW5Eb2M7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkb2NjeTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIm1pbi1kb2N1bWVudFwiOjE3fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZG9tV2FsayA9IHJlcXVpcmUoXCJkb20td2Fsa1wiKVxuXG52YXIgQ29tbWVudCA9IHJlcXVpcmUoXCIuL2RvbS1jb21tZW50LmpzXCIpXG52YXIgRE9NVGV4dCA9IHJlcXVpcmUoXCIuL2RvbS10ZXh0LmpzXCIpXG52YXIgRE9NRWxlbWVudCA9IHJlcXVpcmUoXCIuL2RvbS1lbGVtZW50LmpzXCIpXG52YXIgRG9jdW1lbnRGcmFnbWVudCA9IHJlcXVpcmUoXCIuL2RvbS1mcmFnbWVudC5qc1wiKVxudmFyIEV2ZW50ID0gcmVxdWlyZShcIi4vZXZlbnQuanNcIilcbnZhciBkaXNwYXRjaEV2ZW50ID0gcmVxdWlyZShcIi4vZXZlbnQvZGlzcGF0Y2gtZXZlbnQuanNcIilcbnZhciBhZGRFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vZXZlbnQvYWRkLWV2ZW50LWxpc3RlbmVyLmpzXCIpXG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2V2ZW50L3JlbW92ZS1ldmVudC1saXN0ZW5lci5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50O1xuXG5mdW5jdGlvbiBEb2N1bWVudCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhlYWQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIpXG4gICAgdGhpcy5ib2R5ID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKVxuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiaHRtbFwiKVxuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaGVhZClcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmJvZHkpXG4gICAgdGhpcy5jaGlsZE5vZGVzID0gW3RoaXMuZG9jdW1lbnRFbGVtZW50XVxuICAgIHRoaXMubm9kZVR5cGUgPSA5XG59XG5cbnZhciBwcm90byA9IERvY3VtZW50LnByb3RvdHlwZTtcbnByb3RvLmNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IERPTVRleHQodmFsdWUsIHRoaXMpXG59XG5cbnByb3RvLmNyZWF0ZUVsZW1lbnROUyA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICB2YXIgbnMgPSBuYW1lc3BhY2UgPT09IG51bGwgPyBudWxsIDogU3RyaW5nKG5hbWVzcGFjZSlcbiAgICByZXR1cm4gbmV3IERPTUVsZW1lbnQodGFnTmFtZSwgdGhpcywgbnMpXG59XG5cbnByb3RvLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gbmV3IERPTUVsZW1lbnQodGFnTmFtZSwgdGhpcylcbn1cblxucHJvdG8uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KHRoaXMpXG59XG5cbnByb3RvLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnQoZmFtaWx5KSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudChmYW1pbHkpXG59XG5cbnByb3RvLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVDb21tZW50KGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENvbW1lbnQoZGF0YSwgdGhpcylcbn1cblxucHJvdG8uZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgIGlkID0gU3RyaW5nKGlkKVxuXG4gICAgdmFyIHJlc3VsdCA9IGRvbVdhbGsodGhpcy5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoU3RyaW5nKG5vZGUuaWQpID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0IHx8IG51bGxcbn1cblxucHJvdG8uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IERPTUVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWVcbnByb3RvLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gRE9NRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVcbnByb3RvLmNvbnRhaW5zID0gRE9NRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnNcblxucHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXJcbnByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyXG5wcm90by5kaXNwYXRjaEV2ZW50ID0gZGlzcGF0Y2hFdmVudFxuXG59LHtcIi4vZG9tLWNvbW1lbnQuanNcIjo5LFwiLi9kb20tZWxlbWVudC5qc1wiOjEwLFwiLi9kb20tZnJhZ21lbnQuanNcIjoxMSxcIi4vZG9tLXRleHQuanNcIjoxMixcIi4vZXZlbnQuanNcIjoxMyxcIi4vZXZlbnQvYWRkLWV2ZW50LWxpc3RlbmVyLmpzXCI6MTQsXCIuL2V2ZW50L2Rpc3BhdGNoLWV2ZW50LmpzXCI6MTUsXCIuL2V2ZW50L3JlbW92ZS1ldmVudC1saXN0ZW5lci5qc1wiOjE2LFwiZG9tLXdhbGtcIjoxOH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50XG5cbmZ1bmN0aW9uIENvbW1lbnQoZGF0YSwgb3duZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tZW50KGRhdGEsIG93bmVyKVxuICAgIH1cblxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLm5vZGVWYWx1ZSA9IGRhdGFcbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gICAgdGhpcy5vd25lckRvY3VtZW50ID0gb3duZXIgfHwgbnVsbFxufVxuXG5Db21tZW50LnByb3RvdHlwZS5ub2RlVHlwZSA9IDhcbkNvbW1lbnQucHJvdG90eXBlLm5vZGVOYW1lID0gXCIjY29tbWVudFwiXG5cbkNvbW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gX0NvbW1lbnRfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBDb21tZW50XVwiXG59XG5cbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkb21XYWxrID0gcmVxdWlyZShcImRvbS13YWxrXCIpXG52YXIgZGlzcGF0Y2hFdmVudCA9IHJlcXVpcmUoXCIuL2V2ZW50L2Rpc3BhdGNoLWV2ZW50LmpzXCIpXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2V2ZW50L2FkZC1ldmVudC1saXN0ZW5lci5qc1wiKVxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9ldmVudC9yZW1vdmUtZXZlbnQtbGlzdGVuZXIuanNcIilcbnZhciBzZXJpYWxpemVOb2RlID0gcmVxdWlyZShcIi4vc2VyaWFsaXplLmpzXCIpXG5cbnZhciBodG1sbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUVsZW1lbnRcblxuZnVuY3Rpb24gRE9NRWxlbWVudCh0YWdOYW1lLCBvd25lciwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERPTUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NRWxlbWVudCh0YWdOYW1lKVxuICAgIH1cblxuICAgIHZhciBucyA9IG5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkID8gaHRtbG5zIDogKG5hbWVzcGFjZSB8fCBudWxsKVxuXG4gICAgdGhpcy50YWdOYW1lID0gbnMgPT09IGh0bWxucyA/IFN0cmluZyh0YWdOYW1lKS50b1VwcGVyQ2FzZSgpIDogdGFnTmFtZVxuICAgIHRoaXMubm9kZU5hbWUgPSB0aGlzLnRhZ05hbWVcbiAgICB0aGlzLmNsYXNzTmFtZSA9IFwiXCJcbiAgICB0aGlzLmRhdGFzZXQgPSB7fVxuICAgIHRoaXMuY2hpbGROb2RlcyA9IFtdXG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbFxuICAgIHRoaXMuc3R5bGUgPSB7fVxuICAgIHRoaXMub3duZXJEb2N1bWVudCA9IG93bmVyIHx8IG51bGxcbiAgICB0aGlzLm5hbWVzcGFjZVVSSSA9IG5zXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9XG5cbiAgICBpZiAodGhpcy50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICB0aGlzLnR5cGUgPSAndGV4dCdcbiAgICB9XG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnR5cGUgPSBcIkRPTUVsZW1lbnRcIlxuRE9NRWxlbWVudC5wcm90b3R5cGUubm9kZVR5cGUgPSAxXG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gX0VsZW1lbnRfYXBwZW5kQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSkge1xuICAgICAgICBjaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKVxuICAgIH1cblxuICAgIHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKVxuICAgIGNoaWxkLnBhcmVudE5vZGUgPSB0aGlzXG5cbiAgICByZXR1cm4gY2hpbGRcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkID1cbiAgICBmdW5jdGlvbiBfRWxlbWVudF9yZXBsYWNlQ2hpbGQoZWxlbSwgbmVlZGxlKSB7XG4gICAgICAgIC8vIFRPRE86IFRocm93IE5vdEZvdW5kRXJyb3IgaWYgbmVlZGxlLnBhcmVudE5vZGUgIT09IHRoaXNcblxuICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG5lZWRsZSlcblxuICAgICAgICBuZWVkbGUucGFyZW50Tm9kZSA9IG51bGxcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzW2luZGV4XSA9IGVsZW1cbiAgICAgICAgZWxlbS5wYXJlbnROb2RlID0gdGhpc1xuXG4gICAgICAgIHJldHVybiBuZWVkbGVcbiAgICB9XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gX0VsZW1lbnRfcmVtb3ZlQ2hpbGQoZWxlbSkge1xuICAgIC8vIFRPRE86IFRocm93IE5vdEZvdW5kRXJyb3IgaWYgZWxlbS5wYXJlbnROb2RlICE9PSB0aGlzXG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihlbGVtKVxuICAgIHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UoaW5kZXgsIDEpXG5cbiAgICBlbGVtLnBhcmVudE5vZGUgPSBudWxsXG4gICAgcmV0dXJuIGVsZW1cbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID1cbiAgICBmdW5jdGlvbiBfRWxlbWVudF9pbnNlcnRCZWZvcmUoZWxlbSwgbmVlZGxlKSB7XG4gICAgICAgIC8vIFRPRE86IFRocm93IE5vdEZvdW5kRXJyb3IgaWYgcmVmZXJlbmNlRWxlbWVudCBpcyBhIGRvbSBub2RlXG4gICAgICAgIC8vIGFuZCBwYXJlbnROb2RlICE9PSB0aGlzXG5cbiAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSBuZWVkbGUgPT09IG51bGwgfHwgbmVlZGxlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YobmVlZGxlKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAwLCBlbGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goZWxlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0ucGFyZW50Tm9kZSA9IHRoaXNcbiAgICAgICAgcmV0dXJuIGVsZW1cbiAgICB9XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID1cbiAgICBmdW5jdGlvbiBfRWxlbWVudF9zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBudWxsXG4gICAgICAgIHZhciBsb2NhbE5hbWUgPSBuYW1lXG4gICAgICAgIHZhciBjb2xvblBvc2l0aW9uID0gbmFtZS5pbmRleE9mKFwiOlwiKVxuICAgICAgICBpZiAoY29sb25Qb3NpdGlvbiA+IC0xKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBuYW1lLnN1YnN0cigwLCBjb2xvblBvc2l0aW9uKVxuICAgICAgICAgICAgbG9jYWxOYW1lID0gbmFtZS5zdWJzdHIoY29sb25Qb3NpdGlvbiArIDEpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVzcGFjZV0gfHwgKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZXNwYWNlXSA9IHt9KVxuICAgICAgICBhdHRyaWJ1dGVzW2xvY2FsTmFtZV0gPSB7dmFsdWU6IHZhbHVlLCBwcmVmaXg6IHByZWZpeH1cbiAgICB9XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TID1cbiAgICBmdW5jdGlvbiBfRWxlbWVudF9nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVzcGFjZV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlc1tuYW1lXSAmJiBhdHRyaWJ1dGVzW25hbWVdLnZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZU5TID1cbiAgICBmdW5jdGlvbiBfRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVzcGFjZV07XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1tuYW1lXVxuICAgICAgICB9XG4gICAgfVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5oYXNBdHRyaWJ1dGVOUyA9XG4gICAgZnVuY3Rpb24gX0VsZW1lbnRfaGFzQXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lc3BhY2VdXG4gICAgICAgIHJldHVybiAhIWF0dHJpYnV0ZXMgJiYgbmFtZSBpbiBhdHRyaWJ1dGVzO1xuICAgIH1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gX0VsZW1lbnRfc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgdmFsdWUpXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9FbGVtZW50X2dldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSlcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX0VsZW1lbnRfcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhudWxsLCBuYW1lKVxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfRWxlbWVudF9oYXNBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZU5TKG51bGwsIG5hbWUpXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyXG5ET01FbGVtZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lclxuRE9NRWxlbWVudC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGRpc3BhdGNoRXZlbnRcblxuLy8gVW4taW1wbGVtZW50ZWRcbkRPTUVsZW1lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gX0VsZW1lbnRfZm9jdXMoKSB7XG4gICAgcmV0dXJuIHZvaWQgMFxufVxuXG5ET01FbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIF9FbGVtZW50X3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBzZXJpYWxpemVOb2RlKHRoaXMpXG59XG5cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiBfRWxlbWVudF9nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZXMpIHtcbiAgICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgIHZhciBlbGVtcyA9IFtdXG5cbiAgICBkb21XYWxrKHRoaXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lIHx8IFwiXCJcbiAgICAgICAgICAgIHZhciBub2RlQ2xhc3NlcyA9IG5vZGVDbGFzc05hbWUuc3BsaXQoXCIgXCIpXG5cbiAgICAgICAgICAgIGlmIChjbGFzc2VzLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVDbGFzc2VzLmluZGV4T2YoaXRlbSkgIT09IC0xXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGVsZW1zLnB1c2gobm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gZWxlbXNcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBmdW5jdGlvbiBfRWxlbWVudF9nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSB7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIHZhciBlbGVtcyA9IFtdXG5cbiAgICBkb21XYWxrKHRoaXMuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKHRhZ05hbWUgPT09ICcqJyB8fCBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGVsZW1zLnB1c2gobm9kZSlcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gZWxlbXNcbn1cblxuRE9NRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBfRWxlbWVudF9jb250YWlucyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvbVdhbGsodGhpcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG5vZGVcbiAgICB9KSB8fCBmYWxzZVxufVxuXG59LHtcIi4vZXZlbnQvYWRkLWV2ZW50LWxpc3RlbmVyLmpzXCI6MTQsXCIuL2V2ZW50L2Rpc3BhdGNoLWV2ZW50LmpzXCI6MTUsXCIuL2V2ZW50L3JlbW92ZS1ldmVudC1saXN0ZW5lci5qc1wiOjE2LFwiLi9zZXJpYWxpemUuanNcIjoxOSxcImRvbS13YWxrXCI6MTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRE9NRWxlbWVudCA9IHJlcXVpcmUoXCIuL2RvbS1lbGVtZW50LmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRGcmFnbWVudFxuXG5mdW5jdGlvbiBEb2N1bWVudEZyYWdtZW50KG93bmVyKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZE5vZGVzID0gW11cbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsXG4gICAgdGhpcy5vd25lckRvY3VtZW50ID0gb3duZXIgfHwgbnVsbFxufVxuXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50eXBlID0gXCJEb2N1bWVudEZyYWdtZW50XCJcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLm5vZGVUeXBlID0gMTFcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLm5vZGVOYW1lID0gXCIjZG9jdW1lbnQtZnJhZ21lbnRcIlxuXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZCAgPSBET01FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZFxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gRE9NRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCAgPSBET01FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZFxuXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gX0RvY3VtZW50RnJhZ21lbnRfdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG5vZGUpXG4gICAgICAgIH0pLmpvaW4oXCJcIilcbiAgICB9XG5cbn0se1wiLi9kb20tZWxlbWVudC5qc1wiOjEwfV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBET01UZXh0XG5cbmZ1bmN0aW9uIERPTVRleHQodmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERPTVRleHQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NVGV4dCh2YWx1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSB2YWx1ZSB8fCBcIlwiXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoXG4gICAgdGhpcy5vd25lckRvY3VtZW50ID0gb3duZXIgfHwgbnVsbFxufVxuXG5ET01UZXh0LnByb3RvdHlwZS50eXBlID0gXCJET01UZXh0Tm9kZVwiXG5ET01UZXh0LnByb3RvdHlwZS5ub2RlVHlwZSA9IDNcbkRPTVRleHQucHJvdG90eXBlLm5vZGVOYW1lID0gXCIjdGV4dFwiXG5cbkRPTVRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gX1RleHRfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVxufVxuXG5ET01UZXh0LnByb3RvdHlwZS5yZXBsYWNlRGF0YSA9IGZ1bmN0aW9uIHJlcGxhY2VEYXRhKGluZGV4LCBsZW5ndGgsIHZhbHVlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmRhdGFcbiAgICB2YXIgbGVmdCA9IGN1cnJlbnQuc3Vic3RyaW5nKDAsIGluZGV4KVxuICAgIHZhciByaWdodCA9IGN1cnJlbnQuc3Vic3RyaW5nKGluZGV4ICsgbGVuZ3RoLCBjdXJyZW50Lmxlbmd0aClcbiAgICB0aGlzLmRhdGEgPSBsZWZ0ICsgdmFsdWUgKyByaWdodFxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aFxufVxuXG59LHt9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50XG5cbmZ1bmN0aW9uIEV2ZW50KGZhbWlseSkge31cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uIF9FdmVudF9pbml0RXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLmJ1YmJsZXMgPSBidWJibGVzXG4gICAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZVxufVxuXG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBfRXZlbnRfcHJldmVudERlZmF1bHQoKSB7XG4gICAgXG59XG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gYWRkRXZlbnRMaXN0ZW5lclxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzXG5cbiAgICBpZiAoIWVsZW0ubGlzdGVuZXJzKSB7XG4gICAgICAgIGVsZW0ubGlzdGVuZXJzID0ge31cbiAgICB9XG5cbiAgICBpZiAoIWVsZW0ubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIGVsZW0ubGlzdGVuZXJzW3R5cGVdID0gW11cbiAgICB9XG5cbiAgICBpZiAoZWxlbS5saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgIGVsZW0ubGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpXG4gICAgfVxufVxuXG59LHt9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoRXZlbnRcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldikge1xuICAgIHZhciBlbGVtID0gdGhpc1xuICAgIHZhciB0eXBlID0gZXYudHlwZVxuXG4gICAgaWYgKCFldi50YXJnZXQpIHtcbiAgICAgICAgZXYudGFyZ2V0ID0gZWxlbVxuICAgIH1cblxuICAgIGlmICghZWxlbS5saXN0ZW5lcnMpIHtcbiAgICAgICAgZWxlbS5saXN0ZW5lcnMgPSB7fVxuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBlbGVtLmxpc3RlbmVyc1t0eXBlXVxuXG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldi5jdXJyZW50VGFyZ2V0ID0gZWxlbVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudChldilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsZW0ucGFyZW50Tm9kZS5kaXNwYXRjaEV2ZW50KGV2KVxuICAgIH1cbn1cblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSByZW1vdmVFdmVudExpc3RlbmVyXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgZWxlbSA9IHRoaXNcblxuICAgIGlmICghZWxlbS5saXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFlbGVtLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbGlzdCA9IGVsZW0ubGlzdGVuZXJzW3R5cGVdXG4gICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGxpc3RlbmVyKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxufVxuXG59LHt9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IERvY3VtZW50KCk7XG5cbn0se1wiLi9kb2N1bWVudC5qc1wiOjh9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcblxubW9kdWxlLmV4cG9ydHMgPSBpdGVyYXRpdmVseVdhbGtcblxuZnVuY3Rpb24gaXRlcmF0aXZlbHlXYWxrKG5vZGVzLCBjYikge1xuICAgIGlmICghKCdsZW5ndGgnIGluIG5vZGVzKSkge1xuICAgICAgICBub2RlcyA9IFtub2Rlc11cbiAgICB9XG4gICAgXG4gICAgbm9kZXMgPSBzbGljZS5jYWxsKG5vZGVzKVxuXG4gICAgd2hpbGUobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXMuc2hpZnQoKSxcbiAgICAgICAgICAgIHJldCA9IGNiKG5vZGUpXG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlcyA9IHNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzKS5jb25jYXQobm9kZXMpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gc2VyaWFsaXplTm9kZVxuXG52YXIgdm9pZEVsZW1lbnRzID0gL2FyZWF8YmFzZXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1lbnVpdGVtfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdici9pO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVRleHQobm9kZS5kYXRhKVxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gXCI8IS0tXCIgKyBub2RlLmRhdGEgKyBcIi0tPlwiXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudChub2RlKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudChlbGVtKSB7XG4gICAgdmFyIHN0cmluZ3MgPSBbXVxuXG4gICAgdmFyIHRhZ25hbWUgPSBlbGVtLnRhZ05hbWVcblxuICAgIGlmIChlbGVtLm5hbWVzcGFjZVVSSSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpIHtcbiAgICAgICAgdGFnbmFtZSA9IHRhZ25hbWUudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICAgIHN0cmluZ3MucHVzaChcIjxcIiArIHRhZ25hbWUgKyBwcm9wZXJ0aWVzKGVsZW0pICsgZGF0YXNldGlmeShlbGVtKSlcblxuICAgIGlmICh2b2lkRWxlbWVudHMudGVzdCh0YWduYW1lKSkge1xuICAgICAgICBzdHJpbmdzLnB1c2goXCIgLz5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmdzLnB1c2goXCI+XCIpXG5cbiAgICAgICAgaWYgKGVsZW0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaC5hcHBseShzdHJpbmdzLCBlbGVtLmNoaWxkTm9kZXMubWFwKHNlcmlhbGl6ZU5vZGUpKVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQpIHtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChlc2NhcGVUZXh0KGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQpKVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goZWxlbS5pbm5lckhUTUwpXG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmdzLnB1c2goXCI8L1wiICsgdGFnbmFtZSArIFwiPlwiKVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdzLmpvaW4oXCJcIilcbn1cblxuZnVuY3Rpb24gaXNQcm9wZXJ0eShlbGVtLCBrZXkpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBlbGVtW2tleV1cblxuICAgIGlmIChrZXkgPT09IFwic3R5bGVcIiAmJiBPYmplY3Qua2V5cyhlbGVtLnN0eWxlKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIikgJiZcbiAgICAgICAga2V5ICE9PSBcIm5vZGVOYW1lXCIgJiYga2V5ICE9PSBcImNsYXNzTmFtZVwiICYmIGtleSAhPT0gXCJ0YWdOYW1lXCIgJiZcbiAgICAgICAga2V5ICE9PSBcInRleHRDb250ZW50XCIgJiYga2V5ICE9PSBcImlubmVyVGV4dFwiICYmIGtleSAhPT0gXCJuYW1lc3BhY2VVUklcIiAmJiAga2V5ICE9PSBcImlubmVySFRNTFwiXG59XG5cbmZ1bmN0aW9uIHN0eWxpZnkoc3R5bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSByZXR1cm4gc3R5bGVzXG4gICAgdmFyIGF0dHIgPSBcIlwiXG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV1cbiAgICAgICAga2V5ID0ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICAgICAgYXR0ciArPSBrZXkgKyBcIjpcIiArIHZhbHVlICsgXCI7XCJcbiAgICB9KVxuICAgIHJldHVybiBhdHRyXG59XG5cbmZ1bmN0aW9uIGRhdGFzZXRpZnkoZWxlbSkge1xuICAgIHZhciBkcyA9IGVsZW0uZGF0YXNldFxuICAgIHZhciBwcm9wcyA9IFtdXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZHMpIHtcbiAgICAgICAgcHJvcHMucHVzaCh7IG5hbWU6IFwiZGF0YS1cIiArIGtleSwgdmFsdWU6IGRzW2tleV0gfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMubGVuZ3RoID8gc3RyaW5naWZ5KHByb3BzKSA6IFwiXCJcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGxpc3QpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IFtdXG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHR1cGxlLm5hbWVcbiAgICAgICAgdmFyIHZhbHVlID0gdHVwbGUudmFsdWVcblxuICAgICAgICBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0eWxpZnkodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobmFtZSArIFwiPVwiICsgXCJcXFwiXCIgKyBlc2NhcGVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkgKyBcIlxcXCJcIilcbiAgICB9KVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMubGVuZ3RoID8gXCIgXCIgKyBhdHRyaWJ1dGVzLmpvaW4oXCIgXCIpIDogXCJcIlxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0aWVzKGVsZW0pIHtcbiAgICB2YXIgcHJvcHMgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBlbGVtKSB7XG4gICAgICAgIGlmIChpc1Byb3BlcnR5KGVsZW0sIGtleSkpIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2goeyBuYW1lOiBrZXksIHZhbHVlOiBlbGVtW2tleV0gfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIG5zIGluIGVsZW0uX2F0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBlbGVtLl9hdHRyaWJ1dGVzW25zXSkge1xuICAgICAgICB2YXIgcHJvcCA9IGVsZW0uX2F0dHJpYnV0ZXNbbnNdW2F0dHJpYnV0ZV1cbiAgICAgICAgdmFyIG5hbWUgPSAocHJvcC5wcmVmaXggPyBwcm9wLnByZWZpeCArIFwiOlwiIDogXCJcIikgKyBhdHRyaWJ1dGVcbiAgICAgICAgcHJvcHMucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiBwcm9wLnZhbHVlIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW0uY2xhc3NOYW1lKSB7XG4gICAgICAgIHByb3BzLnB1c2goeyBuYW1lOiBcImNsYXNzXCIsIHZhbHVlOiBlbGVtLmNsYXNzTmFtZSB9KVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5sZW5ndGggPyBzdHJpbmdpZnkocHJvcHMpIDogXCJcIlxufVxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0KHMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBpZiAodHlwZW9mKHMpID09PSAnc3RyaW5nJykgeyBcbiAgICAgICAgc3RyID0gczsgXG4gICAgfSBlbHNlIGlmIChzKSB7XG4gICAgICAgIHN0ciA9IHMudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxufVxuXG5mdW5jdGlvbiBlc2NhcGVBdHRyaWJ1dGVWYWx1ZShzdHIpIHtcbiAgICByZXR1cm4gZXNjYXBlVGV4dChzdHIpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG59XG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0cmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGw7XG59O1xuXG59LHt9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXlcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVJc0FycmF5IHx8IGlzQXJyYXlcblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbn1cblxufSx7fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHBhdGNoID0gcmVxdWlyZShcIi4vdmRvbS9wYXRjaC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbn0se1wiLi92ZG9tL3BhdGNoLmpzXCI6Mjd9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiaXMtb2JqZWN0XCIpXG52YXIgaXNIb29rID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZob29rLmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhub2RlLCBwcm9wcywgcHJldmlvdXMpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdXG5cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIb29rKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZVByb3BlcnR5KG5vZGUsIHByb3BOYW1lLCBwcm9wVmFsdWUsIHByZXZpb3VzKVxuICAgICAgICAgICAgaWYgKHByb3BWYWx1ZS5ob29rKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlLmhvb2sobm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaE9iamVjdChub2RlLCBwcm9wcywgcHJldmlvdXMsIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cykge1xuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzW3Byb3BOYW1lXVxuXG4gICAgICAgIGlmICghaXNIb29rKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtpXSA9IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2aW91c1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBcIlwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUudW5ob29rKSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlLnVuaG9vayhub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaE9iamVjdChub2RlLCBwcm9wcywgcHJldmlvdXMsIHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkXG5cbiAgICAvLyBTZXQgYXR0cmlidXRlc1xuICAgIGlmIChwcm9wTmFtZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gcHJvcFZhbHVlW2F0dHJOYW1lXVxuXG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmKHByZXZpb3VzVmFsdWUgJiYgaXNPYmplY3QocHJldmlvdXNWYWx1ZSkgJiZcbiAgICAgICAgZ2V0UHJvdG90eXBlKHByZXZpb3VzVmFsdWUpICE9PSBnZXRQcm90b3R5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KG5vZGVbcHJvcE5hbWVdKSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHt9XG4gICAgfVxuXG4gICAgdmFyIHJlcGxhY2VyID0gcHJvcE5hbWUgPT09IFwic3R5bGVcIiA/IFwiXCIgOiB1bmRlZmluZWRcblxuICAgIGZvciAodmFyIGsgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BWYWx1ZVtrXVxuICAgICAgICBub2RlW3Byb3BOYW1lXVtrXSA9ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IHJlcGxhY2VyIDogdmFsdWVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSlcbiAgICB9IGVsc2UgaWYgKHZhbHVlLl9fcHJvdG9fXykge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19wcm90b19fXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlXG4gICAgfVxufVxuXG59LHtcIi4uL3Zub2RlL2lzLXZob29rLmpzXCI6MzgsXCJpcy1vYmplY3RcIjoyMH1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoXCJnbG9iYWwvZG9jdW1lbnRcIilcblxudmFyIGFwcGx5UHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL2FwcGx5LXByb3BlcnRpZXNcIilcblxudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdm5vZGUuanNcIilcbnZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0LmpzXCIpXG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCIpXG52YXIgaGFuZGxlVGh1bmsgPSByZXF1aXJlKFwiLi4vdm5vZGUvaGFuZGxlLXRodW5rLmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRWxlbWVudFxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHZub2RlLCBvcHRzKSB7XG4gICAgdmFyIGRvYyA9IG9wdHMgPyBvcHRzLmRvY3VtZW50IHx8IGRvY3VtZW50IDogZG9jdW1lbnRcbiAgICB2YXIgd2FybiA9IG9wdHMgPyBvcHRzLndhcm4gOiBudWxsXG5cbiAgICB2bm9kZSA9IGhhbmRsZVRodW5rKHZub2RlKS5hXG5cbiAgICBpZiAoaXNXaWRnZXQodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS5pbml0KClcbiAgICB9IGVsc2UgaWYgKGlzVlRleHQodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dClcbiAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHZub2RlKSkge1xuICAgICAgICBpZiAod2Fybikge1xuICAgICAgICAgICAgd2FybihcIkl0ZW0gaXMgbm90IGEgdmFsaWQgdmlydHVhbCBkb20gbm9kZVwiLCB2bm9kZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBub2RlID0gKHZub2RlLm5hbWVzcGFjZSA9PT0gbnVsbCkgP1xuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudCh2bm9kZS50YWdOYW1lKSA6XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50TlModm5vZGUubmFtZXNwYWNlLCB2bm9kZS50YWdOYW1lKVxuXG4gICAgdmFyIHByb3BzID0gdm5vZGUucHJvcGVydGllc1xuICAgIGFwcGx5UHJvcGVydGllcyhub2RlLCBwcm9wcylcblxuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBjcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldLCBvcHRzKVxuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG59XG5cbn0se1wiLi4vdm5vZGUvaGFuZGxlLXRodW5rLmpzXCI6MzYsXCIuLi92bm9kZS9pcy12bm9kZS5qc1wiOjM5LFwiLi4vdm5vZGUvaXMtdnRleHQuanNcIjo0MCxcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOjQxLFwiLi9hcHBseS1wcm9wZXJ0aWVzXCI6MjMsXCJnbG9iYWwvZG9jdW1lbnRcIjo3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gTWFwcyBhIHZpcnR1YWwgRE9NIHRyZWUgb250byBhIHJlYWwgRE9NIHRyZWUgaW4gYW4gZWZmaWNpZW50IG1hbm5lci5cbi8vIFdlIGRvbid0IHdhbnQgdG8gcmVhZCBhbGwgb2YgdGhlIERPTSBub2RlcyBpbiB0aGUgdHJlZSBzbyB3ZSB1c2Vcbi8vIHRoZSBpbi1vcmRlciB0cmVlIGluZGV4aW5nIHRvIGVsaW1pbmF0ZSByZWN1cnNpb24gZG93biBjZXJ0YWluIGJyYW5jaGVzLlxuLy8gV2Ugb25seSByZWN1cnNlIGludG8gYSBET00gbm9kZSBpZiB3ZSBrbm93IHRoYXQgaXQgY29udGFpbnMgYSBjaGlsZCBvZlxuLy8gaW50ZXJlc3QuXG5cbnZhciBub0NoaWxkID0ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkb21JbmRleFxuXG5mdW5jdGlvbiBkb21JbmRleChyb290Tm9kZSwgdHJlZSwgaW5kaWNlcywgbm9kZXMpIHtcbiAgICBpZiAoIWluZGljZXMgfHwgaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kaWNlcy5zb3J0KGFzY2VuZGluZylcbiAgICAgICAgcmV0dXJuIHJlY3Vyc2Uocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzLCAwKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzZShyb290Tm9kZSwgdHJlZSwgaW5kaWNlcywgbm9kZXMsIHJvb3RJbmRleCkge1xuICAgIG5vZGVzID0gbm9kZXMgfHwge31cblxuXG4gICAgaWYgKHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChpbmRleEluUmFuZ2UoaW5kaWNlcywgcm9vdEluZGV4LCByb290SW5kZXgpKSB7XG4gICAgICAgICAgICBub2Rlc1tyb290SW5kZXhdID0gcm9vdE5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2Q2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuXG5cbiAgICAgICAgaWYgKHZDaGlsZHJlbikge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHJvb3ROb2RlLmNoaWxkTm9kZXNcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcm9vdEluZGV4ICs9IDFcblxuICAgICAgICAgICAgICAgIHZhciB2Q2hpbGQgPSB2Q2hpbGRyZW5baV0gfHwgbm9DaGlsZFxuICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSByb290SW5kZXggKyAodkNoaWxkLmNvdW50IHx8IDApXG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIHJlY3Vyc2lvbiBkb3duIHRoZSB0cmVlIGlmIHRoZXJlIGFyZSBubyBub2RlcyBkb3duIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhJblJhbmdlKGluZGljZXMsIHJvb3RJbmRleCwgbmV4dEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKGNoaWxkTm9kZXNbaV0sIHZDaGlsZCwgaW5kaWNlcywgbm9kZXMsIHJvb3RJbmRleClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb290SW5kZXggPSBuZXh0SW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlc1xufVxuXG4vLyBCaW5hcnkgc2VhcmNoIGZvciBhbiBpbmRleCBpbiB0aGUgaW50ZXJ2YWwgW2xlZnQsIHJpZ2h0XVxuZnVuY3Rpb24gaW5kZXhJblJhbmdlKGluZGljZXMsIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBtaW5JbmRleCA9IDBcbiAgICB2YXIgbWF4SW5kZXggPSBpbmRpY2VzLmxlbmd0aCAtIDFcbiAgICB2YXIgY3VycmVudEluZGV4XG4gICAgdmFyIGN1cnJlbnRJdGVtXG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gKChtYXhJbmRleCArIG1pbkluZGV4KSAvIDIpID4+IDBcbiAgICAgICAgY3VycmVudEl0ZW0gPSBpbmRpY2VzW2N1cnJlbnRJbmRleF1cblxuICAgICAgICBpZiAobWluSW5kZXggPT09IG1heEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEl0ZW0gPj0gbGVmdCAmJiBjdXJyZW50SXRlbSA8PSByaWdodFxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRJdGVtIDwgbGVmdCkge1xuICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxXG4gICAgICAgIH0gZWxzZSAgaWYgKGN1cnJlbnRJdGVtID4gcmlnaHQpIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogLTFcbn1cblxufSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFwcGx5UHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL2FwcGx5LXByb3BlcnRpZXNcIilcblxudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiKVxudmFyIFZQYXRjaCA9IHJlcXVpcmUoXCIuLi92bm9kZS92cGF0Y2guanNcIilcblxudmFyIHVwZGF0ZVdpZGdldCA9IHJlcXVpcmUoXCIuL3VwZGF0ZS13aWRnZXRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseVBhdGNoXG5cbmZ1bmN0aW9uIGFwcGx5UGF0Y2godnBhdGNoLCBkb21Ob2RlLCByZW5kZXJPcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSB2cGF0Y2gudHlwZVxuICAgIHZhciB2Tm9kZSA9IHZwYXRjaC52Tm9kZVxuICAgIHZhciBwYXRjaCA9IHZwYXRjaC5wYXRjaFxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgVlBhdGNoLlJFTU9WRTpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVOb2RlKGRvbU5vZGUsIHZOb2RlKVxuICAgICAgICBjYXNlIFZQYXRjaC5JTlNFUlQ6XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0Tm9kZShkb21Ob2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guVlRFWFQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nUGF0Y2goZG9tTm9kZSwgdk5vZGUsIHBhdGNoLCByZW5kZXJPcHRpb25zKVxuICAgICAgICBjYXNlIFZQYXRjaC5XSURHRVQ6XG4gICAgICAgICAgICByZXR1cm4gd2lkZ2V0UGF0Y2goZG9tTm9kZSwgdk5vZGUsIHBhdGNoLCByZW5kZXJPcHRpb25zKVxuICAgICAgICBjYXNlIFZQYXRjaC5WTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB2Tm9kZVBhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgY2FzZSBWUGF0Y2guT1JERVI6XG4gICAgICAgICAgICByZW9yZGVyQ2hpbGRyZW4oZG9tTm9kZSwgcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgICAgICBjYXNlIFZQYXRjaC5QUk9QUzpcbiAgICAgICAgICAgIGFwcGx5UHJvcGVydGllcyhkb21Ob2RlLCBwYXRjaCwgdk5vZGUucHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBkb21Ob2RlXG4gICAgICAgIGNhc2UgVlBhdGNoLlRIVU5LOlxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VSb290KGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy5wYXRjaChkb21Ob2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucykpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShkb21Ob2RlLCB2Tm9kZSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG5cbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbU5vZGUpXG4gICAgfVxuXG4gICAgZGVzdHJveVdpZGdldChkb21Ob2RlLCB2Tm9kZSk7XG5cbiAgICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudE5vZGUsIHZOb2RlLCByZW5kZXJPcHRpb25zKSB7XG4gICAgdmFyIG5ld05vZGUgPSByZW5kZXJPcHRpb25zLnJlbmRlcih2Tm9kZSwgcmVuZGVyT3B0aW9ucylcblxuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBzdHJpbmdQYXRjaChkb21Ob2RlLCBsZWZ0Vk5vZGUsIHZUZXh0LCByZW5kZXJPcHRpb25zKSB7XG4gICAgdmFyIG5ld05vZGVcblxuICAgIGlmIChkb21Ob2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIGRvbU5vZGUucmVwbGFjZURhdGEoMCwgZG9tTm9kZS5sZW5ndGgsIHZUZXh0LnRleHQpXG4gICAgICAgIG5ld05vZGUgPSBkb21Ob2RlXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBkb21Ob2RlLnBhcmVudE5vZGVcbiAgICAgICAgbmV3Tm9kZSA9IHJlbmRlck9wdGlvbnMucmVuZGVyKHZUZXh0LCByZW5kZXJPcHRpb25zKVxuXG4gICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5ld05vZGUgIT09IGRvbU5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZVxufVxuXG5mdW5jdGlvbiB3aWRnZXRQYXRjaChkb21Ob2RlLCBsZWZ0Vk5vZGUsIHdpZGdldCwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciB1cGRhdGluZyA9IHVwZGF0ZVdpZGdldChsZWZ0Vk5vZGUsIHdpZGdldClcbiAgICB2YXIgbmV3Tm9kZVxuXG4gICAgaWYgKHVwZGF0aW5nKSB7XG4gICAgICAgIG5ld05vZGUgPSB3aWRnZXQudXBkYXRlKGxlZnRWTm9kZSwgZG9tTm9kZSkgfHwgZG9tTm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld05vZGUgPSByZW5kZXJPcHRpb25zLnJlbmRlcih3aWRnZXQsIHJlbmRlck9wdGlvbnMpXG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE5vZGUgPSBkb21Ob2RlLnBhcmVudE5vZGVcblxuICAgIGlmIChwYXJlbnROb2RlICYmIG5ld05vZGUgIT09IGRvbU5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgZG9tTm9kZSlcbiAgICB9XG5cbiAgICBpZiAoIXVwZGF0aW5nKSB7XG4gICAgICAgIGRlc3Ryb3lXaWRnZXQoZG9tTm9kZSwgbGVmdFZOb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBuZXdOb2RlXG59XG5cbmZ1bmN0aW9uIHZOb2RlUGF0Y2goZG9tTm9kZSwgbGVmdFZOb2RlLCB2Tm9kZSwgcmVuZGVyT3B0aW9ucykge1xuICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlXG4gICAgdmFyIG5ld05vZGUgPSByZW5kZXJPcHRpb25zLnJlbmRlcih2Tm9kZSwgcmVuZGVyT3B0aW9ucylcblxuICAgIGlmIChwYXJlbnROb2RlICYmIG5ld05vZGUgIT09IGRvbU5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgZG9tTm9kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZVxufVxuXG5mdW5jdGlvbiBkZXN0cm95V2lkZ2V0KGRvbU5vZGUsIHcpIHtcbiAgICBpZiAodHlwZW9mIHcuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiICYmIGlzV2lkZ2V0KHcpKSB7XG4gICAgICAgIHcuZGVzdHJveShkb21Ob2RlKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVvcmRlckNoaWxkcmVuKGRvbU5vZGUsIG1vdmVzKSB7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBkb21Ob2RlLmNoaWxkTm9kZXNcbiAgICB2YXIga2V5TWFwID0ge31cbiAgICB2YXIgbm9kZVxuICAgIHZhciByZW1vdmVcbiAgICB2YXIgaW5zZXJ0XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdmVzLnJlbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlID0gbW92ZXMucmVtb3Zlc1tpXVxuICAgICAgICBub2RlID0gY2hpbGROb2Rlc1tyZW1vdmUuZnJvbV1cbiAgICAgICAgaWYgKHJlbW92ZS5rZXkpIHtcbiAgICAgICAgICAgIGtleU1hcFtyZW1vdmUua2V5XSA9IG5vZGVcbiAgICAgICAgfVxuICAgICAgICBkb21Ob2RlLnJlbW92ZUNoaWxkKG5vZGUpXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb3Zlcy5pbnNlcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGluc2VydCA9IG1vdmVzLmluc2VydHNbal1cbiAgICAgICAgbm9kZSA9IGtleU1hcFtpbnNlcnQua2V5XVxuICAgICAgICAvLyB0aGlzIGlzIHRoZSB3ZWlyZGVzdCBidWcgaSd2ZSBldmVyIHNlZW4gaW4gd2Via2l0XG4gICAgICAgIGRvbU5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGluc2VydC50byA+PSBsZW5ndGgrKyA/IG51bGwgOiBjaGlsZE5vZGVzW2luc2VydC50b10pXG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlUm9vdChvbGRSb290LCBuZXdSb290KSB7XG4gICAgaWYgKG9sZFJvb3QgJiYgbmV3Um9vdCAmJiBvbGRSb290ICE9PSBuZXdSb290ICYmIG9sZFJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICBvbGRSb290LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1Jvb3QsIG9sZFJvb3QpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1Jvb3Q7XG59XG5cbn0se1wiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCI6NDEsXCIuLi92bm9kZS92cGF0Y2guanNcIjo0NCxcIi4vYXBwbHktcHJvcGVydGllc1wiOjIzLFwiLi91cGRhdGUtd2lkZ2V0XCI6Mjh9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKFwiZ2xvYmFsL2RvY3VtZW50XCIpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoXCJ4LWlzLWFycmF5XCIpXG5cbnZhciByZW5kZXIgPSByZXF1aXJlKFwiLi9jcmVhdGUtZWxlbWVudFwiKVxudmFyIGRvbUluZGV4ID0gcmVxdWlyZShcIi4vZG9tLWluZGV4XCIpXG52YXIgcGF0Y2hPcCA9IHJlcXVpcmUoXCIuL3BhdGNoLW9wXCIpXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoKHJvb3ROb2RlLCBwYXRjaGVzLCByZW5kZXJPcHRpb25zKSB7XG4gICAgcmVuZGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMgfHwge31cbiAgICByZW5kZXJPcHRpb25zLnBhdGNoID0gcmVuZGVyT3B0aW9ucy5wYXRjaCAmJiByZW5kZXJPcHRpb25zLnBhdGNoICE9PSBwYXRjaFxuICAgICAgICA/IHJlbmRlck9wdGlvbnMucGF0Y2hcbiAgICAgICAgOiBwYXRjaFJlY3Vyc2l2ZVxuICAgIHJlbmRlck9wdGlvbnMucmVuZGVyID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIgfHwgcmVuZGVyXG5cbiAgICByZXR1cm4gcmVuZGVyT3B0aW9ucy5wYXRjaChyb290Tm9kZSwgcGF0Y2hlcywgcmVuZGVyT3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcGF0Y2hSZWN1cnNpdmUocm9vdE5vZGUsIHBhdGNoZXMsIHJlbmRlck9wdGlvbnMpIHtcbiAgICB2YXIgaW5kaWNlcyA9IHBhdGNoSW5kaWNlcyhwYXRjaGVzKVxuXG4gICAgaWYgKGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByb290Tm9kZVxuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGRvbUluZGV4KHJvb3ROb2RlLCBwYXRjaGVzLmEsIGluZGljZXMpXG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSByb290Tm9kZS5vd25lckRvY3VtZW50XG5cbiAgICBpZiAoIXJlbmRlck9wdGlvbnMuZG9jdW1lbnQgJiYgb3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgcmVuZGVyT3B0aW9ucy5kb2N1bWVudCA9IG93bmVyRG9jdW1lbnRcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IGluZGljZXNbaV1cbiAgICAgICAgcm9vdE5vZGUgPSBhcHBseVBhdGNoKHJvb3ROb2RlLFxuICAgICAgICAgICAgaW5kZXhbbm9kZUluZGV4XSxcbiAgICAgICAgICAgIHBhdGNoZXNbbm9kZUluZGV4XSxcbiAgICAgICAgICAgIHJlbmRlck9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3ROb2RlXG59XG5cbmZ1bmN0aW9uIGFwcGx5UGF0Y2gocm9vdE5vZGUsIGRvbU5vZGUsIHBhdGNoTGlzdCwgcmVuZGVyT3B0aW9ucykge1xuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICByZXR1cm4gcm9vdE5vZGVcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZVxuXG4gICAgaWYgKGlzQXJyYXkocGF0Y2hMaXN0KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3Tm9kZSA9IHBhdGNoT3AocGF0Y2hMaXN0W2ldLCBkb21Ob2RlLCByZW5kZXJPcHRpb25zKVxuXG4gICAgICAgICAgICBpZiAoZG9tTm9kZSA9PT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZSA9IG5ld05vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld05vZGUgPSBwYXRjaE9wKHBhdGNoTGlzdCwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucylcblxuICAgICAgICBpZiAoZG9tTm9kZSA9PT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgIHJvb3ROb2RlID0gbmV3Tm9kZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3ROb2RlXG59XG5cbmZ1bmN0aW9uIHBhdGNoSW5kaWNlcyhwYXRjaGVzKSB7XG4gICAgdmFyIGluZGljZXMgPSBbXVxuXG4gICAgZm9yICh2YXIga2V5IGluIHBhdGNoZXMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJhXCIpIHtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChOdW1iZXIoa2V5KSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzXG59XG5cbn0se1wiLi9jcmVhdGUtZWxlbWVudFwiOjI0LFwiLi9kb20taW5kZXhcIjoyNSxcIi4vcGF0Y2gtb3BcIjoyNixcImdsb2JhbC9kb2N1bWVudFwiOjcsXCJ4LWlzLWFycmF5XCI6MjF9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gdXBkYXRlV2lkZ2V0XG5cbmZ1bmN0aW9uIHVwZGF0ZVdpZGdldChhLCBiKSB7XG4gICAgaWYgKGlzV2lkZ2V0KGEpICYmIGlzV2lkZ2V0KGIpKSB7XG4gICAgICAgIGlmIChcIm5hbWVcIiBpbiBhICYmIFwibmFtZVwiIGluIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmlkID09PSBiLmlkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbml0ID09PSBiLmluaXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxufVxuXG59LHtcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOjQxfV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZUhvb2s7XG5cbmZ1bmN0aW9uIEF0dHJpYnV0ZUhvb2sobmFtZXNwYWNlLCB2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBdHRyaWJ1dGVIb29rKSkge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZUhvb2sobmFtZXNwYWNlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5BdHRyaWJ1dGVIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3AsIHByZXYpIHtcbiAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdBdHRyaWJ1dGVIb29rJyAmJlxuICAgICAgICBwcmV2LnZhbHVlID09PSB0aGlzLnZhbHVlICYmXG4gICAgICAgIHByZXYubmFtZXNwYWNlID09PSB0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwgcHJvcCwgdGhpcy52YWx1ZSk7XG59O1xuXG5BdHRyaWJ1dGVIb29rLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcCwgbmV4dCkge1xuICAgIGlmIChuZXh0ICYmIG5leHQudHlwZSA9PT0gJ0F0dHJpYnV0ZUhvb2snICYmXG4gICAgICAgIG5leHQubmFtZXNwYWNlID09PSB0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbG9uUG9zaXRpb24gPSBwcm9wLmluZGV4T2YoJzonKTtcbiAgICB2YXIgbG9jYWxOYW1lID0gY29sb25Qb3NpdGlvbiA+IC0xID8gcHJvcC5zdWJzdHIoY29sb25Qb3NpdGlvbiArIDEpIDogcHJvcDtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKHRoaXMubmFtZXNwYWNlLCBsb2NhbE5hbWUpO1xufTtcblxuQXR0cmlidXRlSG9vay5wcm90b3R5cGUudHlwZSA9ICdBdHRyaWJ1dGVIb29rJztcblxufSx7fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZTdG9yZSA9IHJlcXVpcmUoJ2V2LXN0b3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZIb29rO1xuXG5mdW5jdGlvbiBFdkhvb2sodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXZIb29rKSkge1xuICAgICAgICByZXR1cm4gbmV3IEV2SG9vayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5Fdkhvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGVzID0gRXZTdG9yZShub2RlKTtcbiAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eU5hbWUuc3Vic3RyKDMpO1xuXG4gICAgZXNbcHJvcE5hbWVdID0gdGhpcy52YWx1ZTtcbn07XG5cbkV2SG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24obm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGVzID0gRXZTdG9yZShub2RlKTtcbiAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eU5hbWUuc3Vic3RyKDMpO1xuXG4gICAgZXNbcHJvcE5hbWVdID0gdW5kZWZpbmVkO1xufTtcblxufSx7XCJldi1zdG9yZVwiOjR9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU29mdFNldEhvb2s7XG5cbmZ1bmN0aW9uIFNvZnRTZXRIb29rKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvZnRTZXRIb29rKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvZnRTZXRIb29rKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cblNvZnRTZXRIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BlcnR5TmFtZSkge1xuICAgIGlmIChub2RlW3Byb3BlcnR5TmFtZV0gIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdGhpcy52YWx1ZTtcbiAgICB9XG59O1xuXG59LHt9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgneC1pcy1hcnJheScpO1xuXG52YXIgVk5vZGUgPSByZXF1aXJlKCcuLi92bm9kZS92bm9kZS5qcycpO1xudmFyIFZUZXh0ID0gcmVxdWlyZSgnLi4vdm5vZGUvdnRleHQuanMnKTtcbnZhciBpc1ZOb2RlID0gcmVxdWlyZSgnLi4vdm5vZGUvaXMtdm5vZGUnKTtcbnZhciBpc1ZUZXh0ID0gcmVxdWlyZSgnLi4vdm5vZGUvaXMtdnRleHQnKTtcbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoJy4uL3Zub2RlL2lzLXdpZGdldCcpO1xudmFyIGlzSG9vayA9IHJlcXVpcmUoJy4uL3Zub2RlL2lzLXZob29rJyk7XG52YXIgaXNWVGh1bmsgPSByZXF1aXJlKCcuLi92bm9kZS9pcy10aHVuaycpO1xuXG52YXIgcGFyc2VUYWcgPSByZXF1aXJlKCcuL3BhcnNlLXRhZy5qcycpO1xudmFyIHNvZnRTZXRIb29rID0gcmVxdWlyZSgnLi9ob29rcy9zb2Z0LXNldC1ob29rLmpzJyk7XG52YXIgZXZIb29rID0gcmVxdWlyZSgnLi9ob29rcy9ldi1ob29rLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaDtcblxuZnVuY3Rpb24gaCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZE5vZGVzID0gW107XG4gICAgdmFyIHRhZywgcHJvcHMsIGtleSwgbmFtZXNwYWNlO1xuXG4gICAgaWYgKCFjaGlsZHJlbiAmJiBpc0NoaWxkcmVuKHByb3BlcnRpZXMpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gcHJvcGVydGllcztcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICBwcm9wcyA9IHByb3BzIHx8IHByb3BlcnRpZXMgfHwge307XG4gICAgdGFnID0gcGFyc2VUYWcodGFnTmFtZSwgcHJvcHMpO1xuXG4gICAgLy8gc3VwcG9ydCBrZXlzXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICBrZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgIHByb3BzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IG5hbWVzcGFjZVxuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZXNwYWNlJykpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgICBwcm9wcy5uYW1lc3BhY2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZml4IGN1cnNvciBidWdcbiAgICBpZiAodGFnID09PSAnSU5QVVQnICYmXG4gICAgICAgICFuYW1lc3BhY2UgJiZcbiAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiZcbiAgICAgICAgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhaXNIb29rKHByb3BzLnZhbHVlKVxuICAgICkge1xuICAgICAgICBwcm9wcy52YWx1ZSA9IHNvZnRTZXRIb29rKHByb3BzLnZhbHVlKTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1Qcm9wZXJ0aWVzKHByb3BzKTtcblxuICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgIGFkZENoaWxkKGNoaWxkcmVuLCBjaGlsZE5vZGVzLCB0YWcsIHByb3BzKTtcbiAgICB9XG5cblxuICAgIHJldHVybiBuZXcgVk5vZGUodGFnLCBwcm9wcywgY2hpbGROb2Rlcywga2V5LCBuYW1lc3BhY2UpO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZChjLCBjaGlsZE5vZGVzLCB0YWcsIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobmV3IFZUZXh0KGMpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09PSAnbnVtYmVyJykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobmV3IFZUZXh0KFN0cmluZyhjKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNDaGlsZChjKSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2goYyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkQ2hpbGQoY1tpXSwgY2hpbGROb2RlcywgdGFnLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgfHwgYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBVbmV4cGVjdGVkVmlydHVhbEVsZW1lbnQoe1xuICAgICAgICAgICAgZm9yZWlnbk9iamVjdDogYyxcbiAgICAgICAgICAgIHBhcmVudFZub2RlOiB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUHJvcGVydGllcyhwcm9wcykge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgaWYgKGlzSG9vayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BOYW1lLnN1YnN0cigwLCAzKSA9PT0gJ2V2LScpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgZXYtZm9vIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBldkhvb2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0NoaWxkKHgpIHtcbiAgICByZXR1cm4gaXNWTm9kZSh4KSB8fCBpc1ZUZXh0KHgpIHx8IGlzV2lkZ2V0KHgpIHx8IGlzVlRodW5rKHgpO1xufVxuXG5mdW5jdGlvbiBpc0NoaWxkcmVuKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IGlzQXJyYXkoeCkgfHwgaXNDaGlsZCh4KTtcbn1cblxuZnVuY3Rpb24gVW5leHBlY3RlZFZpcnR1YWxFbGVtZW50KGRhdGEpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG5cbiAgICBlcnIudHlwZSA9ICd2aXJ0dWFsLWh5cGVyc2NyaXB0LnVuZXhwZWN0ZWQudmlydHVhbC1lbGVtZW50JztcbiAgICBlcnIubWVzc2FnZSA9ICdVbmV4cGVjdGVkIHZpcnR1YWwgY2hpbGQgcGFzc2VkIHRvIGgoKS5cXG4nICtcbiAgICAgICAgJ0V4cGVjdGVkIGEgVk5vZGUgLyBWdGh1bmsgLyBWV2lkZ2V0IC8gc3RyaW5nIGJ1dDpcXG4nICtcbiAgICAgICAgJ2dvdDpcXG4nICtcbiAgICAgICAgZXJyb3JTdHJpbmcoZGF0YS5mb3JlaWduT2JqZWN0KSArXG4gICAgICAgICcuXFxuJyArXG4gICAgICAgICdUaGUgcGFyZW50IHZub2RlIGlzOlxcbicgK1xuICAgICAgICBlcnJvclN0cmluZyhkYXRhLnBhcmVudFZub2RlKVxuICAgICAgICAnXFxuJyArXG4gICAgICAgICdTdWdnZXN0ZWQgZml4OiBjaGFuZ2UgeW91ciBgaCguLi4sIFsgLi4uIF0pYCBjYWxsc2l0ZS4nO1xuICAgIGVyci5mb3JlaWduT2JqZWN0ID0gZGF0YS5mb3JlaWduT2JqZWN0O1xuICAgIGVyci5wYXJlbnRWbm9kZSA9IGRhdGEucGFyZW50Vm5vZGU7XG5cbiAgICByZXR1cm4gZXJyO1xufVxuXG5mdW5jdGlvbiBlcnJvclN0cmluZyhvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAnICAgICcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICAgIH1cbn1cblxufSx7XCIuLi92bm9kZS9pcy10aHVua1wiOjM3LFwiLi4vdm5vZGUvaXMtdmhvb2tcIjozOCxcIi4uL3Zub2RlL2lzLXZub2RlXCI6MzksXCIuLi92bm9kZS9pcy12dGV4dFwiOjQwLFwiLi4vdm5vZGUvaXMtd2lkZ2V0XCI6NDEsXCIuLi92bm9kZS92bm9kZS5qc1wiOjQzLFwiLi4vdm5vZGUvdnRleHQuanNcIjo0NSxcIi4vaG9va3MvZXYtaG9vay5qc1wiOjMwLFwiLi9ob29rcy9zb2Z0LXNldC1ob29rLmpzXCI6MzEsXCIuL3BhcnNlLXRhZy5qc1wiOjMzLFwieC1pcy1hcnJheVwiOjIxfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3BsaXQgPSByZXF1aXJlKCdicm93c2VyLXNwbGl0Jyk7XG5cbnZhciBjbGFzc0lkU3BsaXQgPSAvKFtcXC4jXT9bYS16QS1aMC05XFx1MDA3Ri1cXHVGRkZGXzotXSspLztcbnZhciBub3RDbGFzc0lkID0gL15cXC58Iy87XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VUYWc7XG5cbmZ1bmN0aW9uIHBhcnNlVGFnKHRhZywgcHJvcHMpIHtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICByZXR1cm4gJ0RJVic7XG4gICAgfVxuXG4gICAgdmFyIG5vSWQgPSAhKHByb3BzLmhhc093blByb3BlcnR5KCdpZCcpKTtcblxuICAgIHZhciB0YWdQYXJ0cyA9IHNwbGl0KHRhZywgY2xhc3NJZFNwbGl0KTtcbiAgICB2YXIgdGFnTmFtZSA9IG51bGw7XG5cbiAgICBpZiAobm90Q2xhc3NJZC50ZXN0KHRhZ1BhcnRzWzFdKSkge1xuICAgICAgICB0YWdOYW1lID0gJ0RJVic7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMsIHBhcnQsIHR5cGUsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFnUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydCA9IHRhZ1BhcnRzW2ldO1xuXG4gICAgICAgIGlmICghcGFydCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gcGFydC5jaGFyQXQoMCk7XG5cbiAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICB0YWdOYW1lID0gcGFydDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLicpIHtcbiAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJyMnICYmIG5vSWQpIHtcbiAgICAgICAgICAgIHByb3BzLmlkID0gcGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsYXNzZXMpIHtcbiAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHByb3BzLmNsYXNzTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMubmFtZXNwYWNlID8gdGFnTmFtZSA6IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbn1cblxufSx7XCJicm93c2VyLXNwbGl0XCI6M31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIERFRkFVTFRfTkFNRVNQQUNFID0gbnVsbDtcbnZhciBFVl9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzJztcbnZhciBYTElOS19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG52YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkdUaW55MTIvYXR0cmlidXRlVGFibGUuaHRtbFxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbnZhciBTVkdfUFJPUEVSVElFUyA9IHtcbiAgICAnYWJvdXQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYWNjZW50LWhlaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhY2N1bXVsYXRlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2FkZGl0aXZlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2FsaWdubWVudC1iYXNlbGluZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhbHBoYWJldGljJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2FtcGxpdHVkZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhcmFiaWMtZm9ybSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhc2NlbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYXR0cmlidXRlTmFtZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdhdHRyaWJ1dGVUeXBlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2F6aW11dGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmFuZHdpZHRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Jhc2VGcmVxdWVuY3knOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmFzZVByb2ZpbGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmFzZWxpbmUtc2hpZnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnYmJveCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdiZWdpbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdiaWFzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2J5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NhbGNNb2RlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NhcC1oZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY2xhc3MnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY2xpcCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjbGlwLXBhdGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY2xpcC1ydWxlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2NsaXBQYXRoVW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29sb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29sb3ItaW50ZXJwb2xhdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29sb3ItcHJvZmlsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjb2xvci1yZW5kZXJpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnY29udGVudCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjb250ZW50U2NyaXB0VHlwZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjb250ZW50U3R5bGVUeXBlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2N1cnNvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjeCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdjeSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2RhdGF0eXBlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2RlZmF1bHRBY3Rpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZGVzY2VudCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkaWZmdXNlQ29uc3RhbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZGlyZWN0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Rpc3BsYXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZGl2aXNvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkb21pbmFudC1iYXNlbGluZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdkdXInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZHgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZWRnZU1vZGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZWRpdGFibGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZWxldmF0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2VuZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdldjpldmVudCc6IEVWX05BTUVTUEFDRSxcbiAgICAnZXZlbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZXhwb25lbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmaWxsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZpbGwtb3BhY2l0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmaWxsLXJ1bGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZmlsdGVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZpbHRlclJlcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmaWx0ZXJVbml0cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmbG9vZC1jb2xvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmbG9vZC1vcGFjaXR5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZvY3VzSGlnaGxpZ2h0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ZvY3VzYWJsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb250LWZhbWlseSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb250LXNpemUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC1zaXplLWFkanVzdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb250LXN0cmV0Y2gnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC1zdHlsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdmb250LXZhcmlhbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9udC13ZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZm9ybWF0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2Zyb20nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZngnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZnknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZzEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZzInOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnZ2x5cGgtbmFtZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2dseXBoUmVmJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2dyYWRpZW50VHJhbnNmb3JtJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2dyYWRpZW50VW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaGFuZGxlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdoYW5naW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2hlaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdob3Jpei1hZHYteCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdob3Jpei1vcmlnaW4teCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdob3Jpei1vcmlnaW4teSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdpZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdpZGVvZ3JhcGhpYyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdpbWFnZS1yZW5kZXJpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaW4nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnaW4yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2luaXRpYWxWaXNpYmlsaXR5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2ludGVyY2VwdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2sxJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2syJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2szJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2s0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2tlcm5lbE1hdHJpeCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdrZXJuZWxVbml0TGVuZ3RoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2tlcm5pbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAna2V5UG9pbnRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ2tleVNwbGluZXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAna2V5VGltZXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbGFuZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdsZW5ndGhBZGp1c3QnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbGV0dGVyLXNwYWNpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbGlnaHRpbmctY29sb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbGltaXRpbmdDb25lQW5nbGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbG9jYWwnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFya2VyLWVuZCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXJrZXItbWlkJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hcmtlci1zdGFydCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXJrZXJIZWlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFya2VyVW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFya2VyV2lkdGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWFzayc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXNrQ29udGVudFVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21hc2tVbml0cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtYXRoZW1hdGljYWwnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWF4JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21lZGlhJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21lZGlhQ2hhcmFjdGVyRW5jb2RpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWVkaWFDb250ZW50RW5jb2RpbmdzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21lZGlhU2l6ZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtZWRpYVRpbWUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbWV0aG9kJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ21pbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdtb2RlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hbWUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LWRvd24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LWRvd24tbGVmdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtZG93bi1yaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtbGVmdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtbmV4dCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtcHJldic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICduYXYtcmlnaHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnbmF2LXVwJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hdi11cC1sZWZ0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ25hdi11cC1yaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdudW1PY3RhdmVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ29ic2VydmVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ29mZnNldCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcGFjaXR5JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ29wZXJhdG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ29yZGVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ29yaWVudCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcmllbnRhdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvcmlnaW4nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3ZlcmZsb3cnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnb3ZlcmxheSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvdmVybGluZS1wb3NpdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdvdmVybGluZS10aGlja25lc3MnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGFub3NlLTEnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGF0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwYXRoTGVuZ3RoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BhdHRlcm5Db250ZW50VW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGF0dGVyblRyYW5zZm9ybSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwYXR0ZXJuVW5pdHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGhhc2UnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncGxheWJhY2tPcmRlcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwb2ludGVyLWV2ZW50cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwb2ludHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncG9pbnRzQXRYJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3BvaW50c0F0WSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwb2ludHNBdFonOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncHJlc2VydmVBbHBoYSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ByaW1pdGl2ZVVuaXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Byb3BhZ2F0ZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdwcm9wZXJ0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JhZGl1cyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZWZYJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlZlknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVsJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlbmRlcmluZy1pbnRlbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVwZWF0Q291bnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVwZWF0RHVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlcXVpcmVkRXh0ZW5zaW9ucyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyZXF1aXJlZEZlYXR1cmVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JlcXVpcmVkRm9udHMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVxdWlyZWRGb3JtYXRzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Jlc291cmNlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Jlc3RhcnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAncmVzdWx0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Jldic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyb2xlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3JvdGF0ZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyeCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdyeSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzY2FsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzZWVkJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3NoYXBlLXJlbmRlcmluZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzbG9wZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzbmFwc2hvdFRpbWUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3BhY2luZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzcGVjdWxhckNvbnN0YW50JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3NwZWN1bGFyRXhwb25lbnQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3ByZWFkTWV0aG9kJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0YXJ0T2Zmc2V0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0ZERldmlhdGlvbic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdGVtaCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdGVtdic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdGl0Y2hUaWxlcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdG9wLWNvbG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0b3Atb3BhY2l0eSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N0cmluZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJva2UnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJva2UtZGFzaG9mZnNldCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJva2UtbGluZWNhcCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzdHJva2UtbGluZWpvaW4nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLW1pdGVybGltaXQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLW9wYWNpdHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3Ryb2tlLXdpZHRoJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N1cmZhY2VTY2FsZSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzeW5jQmVoYXZpb3InOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3luY0JlaGF2aW9yRGVmYXVsdCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICdzeW5jTWFzdGVyJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3N5bmNUb2xlcmFuY2UnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3luY1RvbGVyYW5jZURlZmF1bHQnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnc3lzdGVtTGFuZ3VhZ2UnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGFibGVWYWx1ZXMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGFyZ2V0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RhcmdldFgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGFyZ2V0WSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0ZXh0LWFuY2hvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGV4dC1yZW5kZXJpbmcnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndGV4dExlbmd0aCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0aW1lbGluZUJlZ2luJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RpdGxlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RvJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3RyYW5zZm9ybSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0cmFuc2Zvcm1CZWhhdmlvcic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd0eXBlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3R5cGVvZic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1MSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1Mic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1bmRlcmxpbmUtcG9zaXRpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1bmljb2RlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3VuaWNvZGUtYmlkaSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd1bmljb2RlLXJhbmdlJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3VuaXRzLXBlci1lbSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2LWFscGhhYmV0aWMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndi1oYW5naW5nJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3YtaWRlb2dyYXBoaWMnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndi1tYXRoZW1hdGljYWwnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndmFsdWVzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ZlcnNpb24nOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndmVydC1hZHYteSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2ZXJ0LW9yaWdpbi14JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3ZlcnQtb3JpZ2luLXknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAndmlld0JveCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd2aWV3VGFyZ2V0JzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3Zpc2liaWxpdHknOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnd2lkdGgnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnd2lkdGhzJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3dvcmQtc3BhY2luZyc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd3cml0aW5nLW1vZGUnOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAneCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd4LWhlaWdodCc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd4MSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd4Mic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd4Q2hhbm5lbFNlbGVjdG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOmFjdHVhdGUnOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOmFyY3JvbGUnOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOmhyZWYnOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOnJvbGUnOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOnNob3cnOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgJ3hsaW5rOnRpdGxlJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bGluazp0eXBlJzogWExJTktfTkFNRVNQQUNFLFxuICAgICd4bWw6YmFzZSc6IFhNTF9OQU1FU1BBQ0UsXG4gICAgJ3htbDppZCc6IFhNTF9OQU1FU1BBQ0UsXG4gICAgJ3htbDpsYW5nJzogWE1MX05BTUVTUEFDRSxcbiAgICAneG1sOnNwYWNlJzogWE1MX05BTUVTUEFDRSxcbiAgICAneSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd5MSc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd5Mic6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICd5Q2hhbm5lbFNlbGVjdG9yJzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgJ3onOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAnem9vbUFuZFBhbic6IERFRkFVTFRfTkFNRVNQQUNFXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0F0dHJpYnV0ZU5hbWVzcGFjZTtcblxuZnVuY3Rpb24gU1ZHQXR0cmlidXRlTmFtZXNwYWNlKHZhbHVlKSB7XG4gIGlmIChTVkdfUFJPUEVSVElFUy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gU1ZHX1BST1BFUlRJRVNbdmFsdWVdO1xuICB9XG59XG5cbn0se31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCd4LWlzLWFycmF5Jyk7XG5cbnZhciBoID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuXG5cbnZhciBTVkdBdHRyaWJ1dGVOYW1lc3BhY2UgPSByZXF1aXJlKCcuL3N2Zy1hdHRyaWJ1dGUtbmFtZXNwYWNlJyk7XG52YXIgYXR0cmlidXRlSG9vayA9IHJlcXVpcmUoJy4vaG9va3MvYXR0cmlidXRlLWhvb2snKTtcblxudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN2ZztcblxuZnVuY3Rpb24gc3ZnKHRhZ05hbWUsIHByb3BlcnRpZXMsIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbiAmJiBpc0NoaWxkcmVuKHByb3BlcnRpZXMpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gcHJvcGVydGllcztcbiAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgIH1cblxuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuXG4gICAgLy8gc2V0IG5hbWVzcGFjZSBmb3Igc3ZnXG4gICAgcHJvcGVydGllcy5uYW1lc3BhY2UgPSBTVkdfTkFNRVNQQUNFO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBwcm9wZXJ0aWVzLmF0dHJpYnV0ZXMgfHwgKHByb3BlcnRpZXMuYXR0cmlidXRlcyA9IHt9KTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBTVkdBdHRyaWJ1dGVOYW1lc3BhY2Uoa2V5KTtcblxuICAgICAgICBpZiAobmFtZXNwYWNlID09PSB1bmRlZmluZWQpIHsgLy8gbm90IGEgc3ZnIGF0dHJpYnV0ZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBudWxsKSB7IC8vIG5hbWVzcGFjZWQgYXR0cmlidXRlXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSBhdHRyaWJ1dGVIb29rKG5hbWVzcGFjZSwgdmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGlzQ2hpbGRyZW4oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgfHwgaXNBcnJheSh4KTtcbn1cblxufSx7XCIuL2hvb2tzL2F0dHJpYnV0ZS1ob29rXCI6MjksXCIuL2luZGV4LmpzXCI6MzIsXCIuL3N2Zy1hdHRyaWJ1dGUtbmFtZXNwYWNlXCI6MzQsXCJ4LWlzLWFycmF5XCI6MjF9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNWTm9kZSA9IHJlcXVpcmUoXCIuL2lzLXZub2RlXCIpXG52YXIgaXNWVGV4dCA9IHJlcXVpcmUoXCIuL2lzLXZ0ZXh0XCIpXG52YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi9pcy13aWRnZXRcIilcbnZhciBpc1RodW5rID0gcmVxdWlyZShcIi4vaXMtdGh1bmtcIilcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVUaHVua1xuXG5mdW5jdGlvbiBoYW5kbGVUaHVuayhhLCBiKSB7XG4gICAgdmFyIHJlbmRlcmVkQSA9IGFcbiAgICB2YXIgcmVuZGVyZWRCID0gYlxuXG4gICAgaWYgKGlzVGh1bmsoYikpIHtcbiAgICAgICAgcmVuZGVyZWRCID0gcmVuZGVyVGh1bmsoYiwgYSlcbiAgICB9XG5cbiAgICBpZiAoaXNUaHVuayhhKSkge1xuICAgICAgICByZW5kZXJlZEEgPSByZW5kZXJUaHVuayhhLCBudWxsKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGE6IHJlbmRlcmVkQSxcbiAgICAgICAgYjogcmVuZGVyZWRCXG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUaHVuayh0aHVuaywgcHJldmlvdXMpIHtcbiAgICB2YXIgcmVuZGVyZWRUaHVuayA9IHRodW5rLnZub2RlXG5cbiAgICBpZiAoIXJlbmRlcmVkVGh1bmspIHtcbiAgICAgICAgcmVuZGVyZWRUaHVuayA9IHRodW5rLnZub2RlID0gdGh1bmsucmVuZGVyKHByZXZpb3VzKVxuICAgIH1cblxuICAgIGlmICghKGlzVk5vZGUocmVuZGVyZWRUaHVuaykgfHxcbiAgICAgICAgICAgIGlzVlRleHQocmVuZGVyZWRUaHVuaykgfHxcbiAgICAgICAgICAgIGlzV2lkZ2V0KHJlbmRlcmVkVGh1bmspKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aHVuayBkaWQgbm90IHJldHVybiBhIHZhbGlkIG5vZGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkVGh1bmtcbn1cblxufSx7XCIuL2lzLXRodW5rXCI6MzcsXCIuL2lzLXZub2RlXCI6MzksXCIuL2lzLXZ0ZXh0XCI6NDAsXCIuL2lzLXdpZGdldFwiOjQxfV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBpc1RodW5rXHJcblxyXG5mdW5jdGlvbiBpc1RodW5rKHQpIHtcclxuICAgIHJldHVybiB0ICYmIHQudHlwZSA9PT0gXCJUaHVua1wiXHJcbn1cclxuXG59LHt9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9va1xuXG5mdW5jdGlvbiBpc0hvb2soaG9vaykge1xuICAgIHJldHVybiBob29rICYmXG4gICAgICAodHlwZW9mIGhvb2suaG9vayA9PT0gXCJmdW5jdGlvblwiICYmICFob29rLmhhc093blByb3BlcnR5KFwiaG9va1wiKSB8fFxuICAgICAgIHR5cGVvZiBob29rLnVuaG9vayA9PT0gXCJmdW5jdGlvblwiICYmICFob29rLmhhc093blByb3BlcnR5KFwidW5ob29rXCIpKVxufVxuXG59LHt9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcblxubW9kdWxlLmV4cG9ydHMgPSBpc1ZpcnR1YWxOb2RlXG5cbmZ1bmN0aW9uIGlzVmlydHVhbE5vZGUoeCkge1xuICAgIHJldHVybiB4ICYmIHgudHlwZSA9PT0gXCJWaXJ0dWFsTm9kZVwiICYmIHgudmVyc2lvbiA9PT0gdmVyc2lvblxufVxuXG59LHtcIi4vdmVyc2lvblwiOjQyfV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaXNWaXJ0dWFsVGV4dFxuXG5mdW5jdGlvbiBpc1ZpcnR1YWxUZXh0KHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGUgPT09IFwiVmlydHVhbFRleHRcIiAmJiB4LnZlcnNpb24gPT09IHZlcnNpb25cbn1cblxufSx7XCIuL3ZlcnNpb25cIjo0Mn1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gaXNXaWRnZXRcblxuZnVuY3Rpb24gaXNXaWRnZXQodykge1xuICAgIHJldHVybiB3ICYmIHcudHlwZSA9PT0gXCJXaWRnZXRcIlxufVxuXG59LHt9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFwiMlwiXG5cbn0se31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxudmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi9pcy12bm9kZVwiKVxudmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4vaXMtd2lkZ2V0XCIpXG52YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuL2lzLXRodW5rXCIpXG52YXIgaXNWSG9vayA9IHJlcXVpcmUoXCIuL2lzLXZob29rXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gVmlydHVhbE5vZGVcblxudmFyIG5vUHJvcGVydGllcyA9IHt9XG52YXIgbm9DaGlsZHJlbiA9IFtdXG5cbmZ1bmN0aW9uIFZpcnR1YWxOb2RlKHRhZ05hbWUsIHByb3BlcnRpZXMsIGNoaWxkcmVuLCBrZXksIG5hbWVzcGFjZSkge1xuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWVcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IG5vUHJvcGVydGllc1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBub0NoaWxkcmVuXG4gICAgdGhpcy5rZXkgPSBrZXkgIT0gbnVsbCA/IFN0cmluZyhrZXkpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5uYW1lc3BhY2UgPSAodHlwZW9mIG5hbWVzcGFjZSA9PT0gXCJzdHJpbmdcIikgPyBuYW1lc3BhY2UgOiBudWxsXG5cbiAgICB2YXIgY291bnQgPSAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB8fCAwXG4gICAgdmFyIGRlc2NlbmRhbnRzID0gMFxuICAgIHZhciBoYXNXaWRnZXRzID0gZmFsc2VcbiAgICB2YXIgaGFzVGh1bmtzID0gZmFsc2VcbiAgICB2YXIgZGVzY2VuZGFudEhvb2tzID0gZmFsc2VcbiAgICB2YXIgaG9va3NcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXVxuICAgICAgICAgICAgaWYgKGlzVkhvb2socHJvcGVydHkpICYmIHByb3BlcnR5LnVuaG9vaykge1xuICAgICAgICAgICAgICAgIGlmICghaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSB7fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhvb2tzW3Byb3BOYW1lXSA9IHByb3BlcnR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBkZXNjZW5kYW50cyArPSBjaGlsZC5jb3VudCB8fCAwXG5cbiAgICAgICAgICAgIGlmICghaGFzV2lkZ2V0cyAmJiBjaGlsZC5oYXNXaWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgaGFzV2lkZ2V0cyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNUaHVua3MgJiYgY2hpbGQuaGFzVGh1bmtzKSB7XG4gICAgICAgICAgICAgICAgaGFzVGh1bmtzID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRlc2NlbmRhbnRIb29rcyAmJiAoY2hpbGQuaG9va3MgfHwgY2hpbGQuZGVzY2VuZGFudEhvb2tzKSkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRIb29rcyA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaGFzV2lkZ2V0cyAmJiBpc1dpZGdldChjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFzV2lkZ2V0cyA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaGFzVGh1bmtzICYmIGlzVGh1bmsoY2hpbGQpKSB7XG4gICAgICAgICAgICBoYXNUaHVua3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb3VudCA9IGNvdW50ICsgZGVzY2VuZGFudHNcbiAgICB0aGlzLmhhc1dpZGdldHMgPSBoYXNXaWRnZXRzXG4gICAgdGhpcy5oYXNUaHVua3MgPSBoYXNUaHVua3NcbiAgICB0aGlzLmhvb2tzID0gaG9va3NcbiAgICB0aGlzLmRlc2NlbmRhbnRIb29rcyA9IGRlc2NlbmRhbnRIb29rc1xufVxuXG5WaXJ0dWFsTm9kZS5wcm90b3R5cGUudmVyc2lvbiA9IHZlcnNpb25cblZpcnR1YWxOb2RlLnByb3RvdHlwZS50eXBlID0gXCJWaXJ0dWFsTm9kZVwiXG5cbn0se1wiLi9pcy10aHVua1wiOjM3LFwiLi9pcy12aG9va1wiOjM4LFwiLi9pcy12bm9kZVwiOjM5LFwiLi9pcy13aWRnZXRcIjo0MSxcIi4vdmVyc2lvblwiOjQyfV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpXG5cblZpcnR1YWxQYXRjaC5OT05FID0gMFxuVmlydHVhbFBhdGNoLlZURVhUID0gMVxuVmlydHVhbFBhdGNoLlZOT0RFID0gMlxuVmlydHVhbFBhdGNoLldJREdFVCA9IDNcblZpcnR1YWxQYXRjaC5QUk9QUyA9IDRcblZpcnR1YWxQYXRjaC5PUkRFUiA9IDVcblZpcnR1YWxQYXRjaC5JTlNFUlQgPSA2XG5WaXJ0dWFsUGF0Y2guUkVNT1ZFID0gN1xuVmlydHVhbFBhdGNoLlRIVU5LID0gOFxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxQYXRjaFxuXG5mdW5jdGlvbiBWaXJ0dWFsUGF0Y2godHlwZSwgdk5vZGUsIHBhdGNoKSB7XG4gICAgdGhpcy50eXBlID0gTnVtYmVyKHR5cGUpXG4gICAgdGhpcy52Tm9kZSA9IHZOb2RlXG4gICAgdGhpcy5wYXRjaCA9IHBhdGNoXG59XG5cblZpcnR1YWxQYXRjaC5wcm90b3R5cGUudmVyc2lvbiA9IHZlcnNpb25cblZpcnR1YWxQYXRjaC5wcm90b3R5cGUudHlwZSA9IFwiVmlydHVhbFBhdGNoXCJcblxufSx7XCIuL3ZlcnNpb25cIjo0Mn1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxUZXh0XG5cbmZ1bmN0aW9uIFZpcnR1YWxUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSBTdHJpbmcodGV4dClcbn1cblxuVmlydHVhbFRleHQucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uXG5WaXJ0dWFsVGV4dC5wcm90b3R5cGUudHlwZSA9IFwiVmlydHVhbFRleHRcIlxuXG59LHtcIi4vdmVyc2lvblwiOjQyfV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZShcImlzLW9iamVjdFwiKVxudmFyIGlzSG9vayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy12aG9va1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZQcm9wc1xuXG5mdW5jdGlvbiBkaWZmUHJvcHMoYSwgYikge1xuICAgIHZhciBkaWZmXG5cbiAgICBmb3IgKHZhciBhS2V5IGluIGEpIHtcbiAgICAgICAgaWYgKCEoYUtleSBpbiBiKSkge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgIGRpZmZbYUtleV0gPSB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhVmFsdWUgPSBhW2FLZXldXG4gICAgICAgIHZhciBiVmFsdWUgPSBiW2FLZXldXG5cbiAgICAgICAgaWYgKGFWYWx1ZSA9PT0gYlZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGFWYWx1ZSkgJiYgaXNPYmplY3QoYlZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGdldFByb3RvdHlwZShiVmFsdWUpICE9PSBnZXRQcm90b3R5cGUoYVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICAgICAgZGlmZlthS2V5XSA9IGJWYWx1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hvb2soYlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgICAgICBkaWZmW2FLZXldID0gYlZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3REaWZmID0gZGlmZlByb3BzKGFWYWx1ZSwgYlZhbHVlKVxuICAgICAgICAgICAgICAgIGlmIChvYmplY3REaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIGRpZmZbYUtleV0gPSBvYmplY3REaWZmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge31cbiAgICAgICAgICAgIGRpZmZbYUtleV0gPSBiVmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGJLZXkgaW4gYikge1xuICAgICAgICBpZiAoIShiS2V5IGluIGEpKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fVxuICAgICAgICAgICAgZGlmZltiS2V5XSA9IGJbYktleV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWZmXG59XG5cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSlcbiAgfSBlbHNlIGlmICh2YWx1ZS5fX3Byb3RvX18pIHtcbiAgICByZXR1cm4gdmFsdWUuX19wcm90b19fXG4gIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlXG4gIH1cbn1cblxufSx7XCIuLi92bm9kZS9pcy12aG9va1wiOjM4LFwiaXMtb2JqZWN0XCI6MjB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoXCJ4LWlzLWFycmF5XCIpXG5cbnZhciBWUGF0Y2ggPSByZXF1aXJlKFwiLi4vdm5vZGUvdnBhdGNoXCIpXG52YXIgaXNWTm9kZSA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy12bm9kZVwiKVxudmFyIGlzVlRleHQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdnRleHRcIilcbnZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXRcIilcbnZhciBpc1RodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXRodW5rXCIpXG52YXIgaGFuZGxlVGh1bmsgPSByZXF1aXJlKFwiLi4vdm5vZGUvaGFuZGxlLXRodW5rXCIpXG5cbnZhciBkaWZmUHJvcHMgPSByZXF1aXJlKFwiLi9kaWZmLXByb3BzXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuXG5mdW5jdGlvbiBkaWZmKGEsIGIpIHtcbiAgICB2YXIgcGF0Y2ggPSB7IGE6IGEgfVxuICAgIHdhbGsoYSwgYiwgcGF0Y2gsIDApXG4gICAgcmV0dXJuIHBhdGNoXG59XG5cbmZ1bmN0aW9uIHdhbGsoYSwgYiwgcGF0Y2gsIGluZGV4KSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGFwcGx5ID0gcGF0Y2hbaW5kZXhdXG4gICAgdmFyIGFwcGx5Q2xlYXIgPSBmYWxzZVxuXG4gICAgaWYgKGlzVGh1bmsoYSkgfHwgaXNUaHVuayhiKSkge1xuICAgICAgICB0aHVua3MoYSwgYiwgcGF0Y2gsIGluZGV4KVxuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG5cbiAgICAgICAgLy8gSWYgYSBpcyBhIHdpZGdldCB3ZSB3aWxsIGFkZCBhIHJlbW92ZSBwYXRjaCBmb3IgaXRcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFueSBjaGlsZCB3aWRnZXRzL2hvb2tzIG11c3QgYmUgZGVzdHJveWVkLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGFkZGluZyB0d28gcmVtb3ZlIHBhdGNoZXMgZm9yIGEgd2lkZ2V0LlxuICAgICAgICBpZiAoIWlzV2lkZ2V0KGEpKSB7XG4gICAgICAgICAgICBjbGVhclN0YXRlKGEsIHBhdGNoLCBpbmRleClcbiAgICAgICAgICAgIGFwcGx5ID0gcGF0Y2hbaW5kZXhdXG4gICAgICAgIH1cblxuICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5SRU1PVkUsIGEsIGIpKVxuICAgIH0gZWxzZSBpZiAoaXNWTm9kZShiKSkge1xuICAgICAgICBpZiAoaXNWTm9kZShhKSkge1xuICAgICAgICAgICAgaWYgKGEudGFnTmFtZSA9PT0gYi50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgYS5uYW1lc3BhY2UgPT09IGIubmFtZXNwYWNlICYmXG4gICAgICAgICAgICAgICAgYS5rZXkgPT09IGIua2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzUGF0Y2ggPSBkaWZmUHJvcHMoYS5wcm9wZXJ0aWVzLCBiLnByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWUGF0Y2goVlBhdGNoLlBST1BTLCBhLCBwcm9wc1BhdGNoKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHkgPSBkaWZmQ2hpbGRyZW4oYSwgYiwgcGF0Y2gsIGFwcGx5LCBpbmRleClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVk5PREUsIGEsIGIpKVxuICAgICAgICAgICAgICAgIGFwcGx5Q2xlYXIgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5WTk9ERSwgYSwgYikpXG4gICAgICAgICAgICBhcHBseUNsZWFyID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZUZXh0KGIpKSB7XG4gICAgICAgIGlmICghaXNWVGV4dChhKSkge1xuICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVlRFWFQsIGEsIGIpKVxuICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChhLnRleHQgIT09IGIudGV4dCkge1xuICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVlRFWFQsIGEsIGIpKVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1dpZGdldChiKSkge1xuICAgICAgICBpZiAoIWlzV2lkZ2V0KGEpKSB7XG4gICAgICAgICAgICBhcHBseUNsZWFyID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guV0lER0VULCBhLCBiKSlcbiAgICB9XG5cbiAgICBpZiAoYXBwbHkpIHtcbiAgICAgICAgcGF0Y2hbaW5kZXhdID0gYXBwbHlcbiAgICB9XG5cbiAgICBpZiAoYXBwbHlDbGVhcikge1xuICAgICAgICBjbGVhclN0YXRlKGEsIHBhdGNoLCBpbmRleClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZDaGlsZHJlbihhLCBiLCBwYXRjaCwgYXBwbHksIGluZGV4KSB7XG4gICAgdmFyIGFDaGlsZHJlbiA9IGEuY2hpbGRyZW5cbiAgICB2YXIgb3JkZXJlZFNldCA9IHJlb3JkZXIoYUNoaWxkcmVuLCBiLmNoaWxkcmVuKVxuICAgIHZhciBiQ2hpbGRyZW4gPSBvcmRlcmVkU2V0LmNoaWxkcmVuXG5cbiAgICB2YXIgYUxlbiA9IGFDaGlsZHJlbi5sZW5ndGhcbiAgICB2YXIgYkxlbiA9IGJDaGlsZHJlbi5sZW5ndGhcbiAgICB2YXIgbGVuID0gYUxlbiA+IGJMZW4gPyBhTGVuIDogYkxlblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBhQ2hpbGRyZW5baV1cbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IGJDaGlsZHJlbltpXVxuICAgICAgICBpbmRleCArPSAxXG5cbiAgICAgICAgaWYgKCFsZWZ0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0Tm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VzcyBub2RlcyBpbiBiIG5lZWQgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LFxuICAgICAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5JTlNFUlQsIG51bGwsIHJpZ2h0Tm9kZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YWxrKGxlZnROb2RlLCByaWdodE5vZGUsIHBhdGNoLCBpbmRleClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ZOb2RlKGxlZnROb2RlKSAmJiBsZWZ0Tm9kZS5jb3VudCkge1xuICAgICAgICAgICAgaW5kZXggKz0gbGVmdE5vZGUuY291bnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcmRlcmVkU2V0Lm1vdmVzKSB7XG4gICAgICAgIC8vIFJlb3JkZXIgbm9kZXMgbGFzdFxuICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFxuICAgICAgICAgICAgVlBhdGNoLk9SREVSLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIG9yZGVyZWRTZXQubW92ZXNcbiAgICAgICAgKSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHlcbn1cblxuZnVuY3Rpb24gY2xlYXJTdGF0ZSh2Tm9kZSwgcGF0Y2gsIGluZGV4KSB7XG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIGEgc2luZ2xlIHdhbGssIG5vdCB0d29cbiAgICB1bmhvb2sodk5vZGUsIHBhdGNoLCBpbmRleClcbiAgICBkZXN0cm95V2lkZ2V0cyh2Tm9kZSwgcGF0Y2gsIGluZGV4KVxufVxuXG4vLyBQYXRjaCByZWNvcmRzIGZvciBhbGwgZGVzdHJveWVkIHdpZGdldHMgbXVzdCBiZSBhZGRlZCBiZWNhdXNlIHdlIG5lZWRcbi8vIGEgRE9NIG5vZGUgcmVmZXJlbmNlIGZvciB0aGUgZGVzdHJveSBmdW5jdGlvblxuZnVuY3Rpb24gZGVzdHJveVdpZGdldHModk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgIGlmIChpc1dpZGdldCh2Tm9kZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2Tm9kZS5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGVuZFBhdGNoKFxuICAgICAgICAgICAgICAgIHBhdGNoW2luZGV4XSxcbiAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5SRU1PVkUsIHZOb2RlLCBudWxsKVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZOb2RlKHZOb2RlKSAmJiAodk5vZGUuaGFzV2lkZ2V0cyB8fCB2Tm9kZS5oYXNUaHVua3MpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuXG4gICAgICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgICAgICAgIGluZGV4ICs9IDFcblxuICAgICAgICAgICAgZGVzdHJveVdpZGdldHMoY2hpbGQsIHBhdGNoLCBpbmRleClcblxuICAgICAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpICYmIGNoaWxkLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gY2hpbGQuY291bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUaHVuayh2Tm9kZSkpIHtcbiAgICAgICAgdGh1bmtzKHZOb2RlLCBudWxsLCBwYXRjaCwgaW5kZXgpXG4gICAgfVxufVxuXG4vLyBDcmVhdGUgYSBzdWItcGF0Y2ggZm9yIHRodW5rc1xuZnVuY3Rpb24gdGh1bmtzKGEsIGIsIHBhdGNoLCBpbmRleCkge1xuICAgIHZhciBub2RlcyA9IGhhbmRsZVRodW5rKGEsIGIpXG4gICAgdmFyIHRodW5rUGF0Y2ggPSBkaWZmKG5vZGVzLmEsIG5vZGVzLmIpXG4gICAgaWYgKGhhc1BhdGNoZXModGh1bmtQYXRjaCkpIHtcbiAgICAgICAgcGF0Y2hbaW5kZXhdID0gbmV3IFZQYXRjaChWUGF0Y2guVEhVTkssIG51bGwsIHRodW5rUGF0Y2gpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXRjaGVzKHBhdGNoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggaW4gcGF0Y2gpIHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBcImFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxufVxuXG4vLyBFeGVjdXRlIGhvb2tzIHdoZW4gdHdvIG5vZGVzIGFyZSBpZGVudGljYWxcbmZ1bmN0aW9uIHVuaG9vayh2Tm9kZSwgcGF0Y2gsIGluZGV4KSB7XG4gICAgaWYgKGlzVk5vZGUodk5vZGUpKSB7XG4gICAgICAgIGlmICh2Tm9kZS5ob29rcykge1xuICAgICAgICAgICAgcGF0Y2hbaW5kZXhdID0gYXBwZW5kUGF0Y2goXG4gICAgICAgICAgICAgICAgcGF0Y2hbaW5kZXhdLFxuICAgICAgICAgICAgICAgIG5ldyBWUGF0Y2goXG4gICAgICAgICAgICAgICAgICAgIFZQYXRjaC5QUk9QUyxcbiAgICAgICAgICAgICAgICAgICAgdk5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZEtleXModk5vZGUuaG9va3MpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZOb2RlLmRlc2NlbmRhbnRIb29rcyB8fCB2Tm9kZS5oYXNUaHVua3MpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuXG4gICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgICAgICAgICAgICBpbmRleCArPSAxXG5cbiAgICAgICAgICAgICAgICB1bmhvb2soY2hpbGQsIHBhdGNoLCBpbmRleClcblxuICAgICAgICAgICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSAmJiBjaGlsZC5jb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBjaGlsZC5jb3VudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUaHVuayh2Tm9kZSkpIHtcbiAgICAgICAgdGh1bmtzKHZOb2RlLCBudWxsLCBwYXRjaCwgaW5kZXgpXG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bmRlZmluZWRLZXlzKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fVxuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbn1cblxuLy8gTGlzdCBkaWZmLCBuYWl2ZSBsZWZ0IHRvIHJpZ2h0IHJlb3JkZXJpbmdcbmZ1bmN0aW9uIHJlb3JkZXIoYUNoaWxkcmVuLCBiQ2hpbGRyZW4pIHtcbiAgICAvLyBPKE0pIHRpbWUsIE8oTSkgbWVtb3J5XG4gICAgdmFyIGJDaGlsZEluZGV4ID0ga2V5SW5kZXgoYkNoaWxkcmVuKVxuICAgIHZhciBiS2V5cyA9IGJDaGlsZEluZGV4LmtleXNcbiAgICB2YXIgYkZyZWUgPSBiQ2hpbGRJbmRleC5mcmVlXG5cbiAgICBpZiAoYkZyZWUubGVuZ3RoID09PSBiQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogYkNoaWxkcmVuLFxuICAgICAgICAgICAgbW92ZXM6IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE8oTikgdGltZSwgTyhOKSBtZW1vcnlcbiAgICB2YXIgYUNoaWxkSW5kZXggPSBrZXlJbmRleChhQ2hpbGRyZW4pXG4gICAgdmFyIGFLZXlzID0gYUNoaWxkSW5kZXgua2V5c1xuICAgIHZhciBhRnJlZSA9IGFDaGlsZEluZGV4LmZyZWVcblxuICAgIGlmIChhRnJlZS5sZW5ndGggPT09IGFDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBiQ2hpbGRyZW4sXG4gICAgICAgICAgICBtb3ZlczogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTyhNQVgoTiwgTSkpIG1lbW9yeVxuICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdXG5cbiAgICB2YXIgZnJlZUluZGV4ID0gMFxuICAgIHZhciBmcmVlQ291bnQgPSBiRnJlZS5sZW5ndGhcbiAgICB2YXIgZGVsZXRlZEl0ZW1zID0gMFxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGEgYW5kIG1hdGNoIGEgbm9kZSBpbiBiXG4gICAgLy8gTyhOKSB0aW1lLFxuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGFDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYUl0ZW0gPSBhQ2hpbGRyZW5baV1cbiAgICAgICAgdmFyIGl0ZW1JbmRleFxuXG4gICAgICAgIGlmIChhSXRlbS5rZXkpIHtcbiAgICAgICAgICAgIGlmIChiS2V5cy5oYXNPd25Qcm9wZXJ0eShhSXRlbS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggdXAgdGhlIG9sZCBrZXlzXG4gICAgICAgICAgICAgICAgaXRlbUluZGV4ID0gYktleXNbYUl0ZW0ua2V5XVxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYkNoaWxkcmVuW2l0ZW1JbmRleF0pXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBrZXllZCBpdGVtc1xuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGkgLSBkZWxldGVkSXRlbXMrK1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1hdGNoIHRoZSBpdGVtIGluIGEgd2l0aCB0aGUgbmV4dCBmcmVlIGl0ZW0gaW4gYlxuICAgICAgICAgICAgaWYgKGZyZWVJbmRleCA8IGZyZWVDb3VudCkge1xuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IGJGcmVlW2ZyZWVJbmRleCsrXVxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYkNoaWxkcmVuW2l0ZW1JbmRleF0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBmcmVlIGl0ZW1zIGluIGIgdG8gbWF0Y2ggd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBmcmVlIGl0ZW1zIGluIGEsIHNvIHRoZSBleHRyYSBmcmVlIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgaXRlbUluZGV4ID0gaSAtIGRlbGV0ZWRJdGVtcysrXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RGcmVlSW5kZXggPSBmcmVlSW5kZXggPj0gYkZyZWUubGVuZ3RoID9cbiAgICAgICAgYkNoaWxkcmVuLmxlbmd0aCA6XG4gICAgICAgIGJGcmVlW2ZyZWVJbmRleF1cblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBiIGFuZCBhcHBlbmQgYW55IG5ldyBrZXlzXG4gICAgLy8gTyhNKSB0aW1lXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5ld0l0ZW0gPSBiQ2hpbGRyZW5bal1cblxuICAgICAgICBpZiAobmV3SXRlbS5rZXkpIHtcbiAgICAgICAgICAgIGlmICghYUtleXMuaGFzT3duUHJvcGVydHkobmV3SXRlbS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFueSBuZXcga2V5ZWQgaXRlbXNcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWRkaW5nIG5ldyBpdGVtcyB0byB0aGUgZW5kIGFuZCB0aGVuIHNvcnRpbmcgdGhlbVxuICAgICAgICAgICAgICAgIC8vIGluIHBsYWNlLiBJbiBmdXR1cmUgd2Ugc2hvdWxkIGluc2VydCBuZXcgaXRlbXMgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXdJdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGogPj0gbGFzdEZyZWVJbmRleCkge1xuICAgICAgICAgICAgLy8gQWRkIGFueSBsZWZ0b3ZlciBub24ta2V5ZWQgaXRlbXNcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3SXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW11bGF0ZSA9IG5ld0NoaWxkcmVuLnNsaWNlKClcbiAgICB2YXIgc2ltdWxhdGVJbmRleCA9IDBcbiAgICB2YXIgcmVtb3ZlcyA9IFtdXG4gICAgdmFyIGluc2VydHMgPSBbXVxuICAgIHZhciBzaW11bGF0ZUl0ZW1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYkNoaWxkcmVuLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIHdhbnRlZEl0ZW0gPSBiQ2hpbGRyZW5ba11cbiAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF1cblxuICAgICAgICAvLyByZW1vdmUgaXRlbXNcbiAgICAgICAgd2hpbGUgKHNpbXVsYXRlSXRlbSA9PT0gbnVsbCAmJiBzaW11bGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIG51bGwpKVxuICAgICAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2ltdWxhdGVJdGVtIHx8IHNpbXVsYXRlSXRlbS5rZXkgIT09IHdhbnRlZEl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBuZWVkIGEga2V5IGluIHRoaXMgcG9zaXRpb24uLi5cbiAgICAgICAgICAgIGlmICh3YW50ZWRJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgIGlmIChzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbiBpbnNlcnQgZG9lc24ndCBwdXQgdGhpcyBrZXkgaW4gcGxhY2UsIGl0IG5lZWRzIHRvIG1vdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJLZXlzW3NpbXVsYXRlSXRlbS5rZXldICE9PSBrICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3Zlcy5wdXNoKHJlbW92ZShzaW11bGF0ZSwgc2ltdWxhdGVJbmRleCwgc2ltdWxhdGVJdGVtLmtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZUl0ZW0gPSBzaW11bGF0ZVtzaW11bGF0ZUluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlbW92ZSBkaWRuJ3QgcHV0IHRoZSB3YW50ZWQgaXRlbSBpbiBwbGFjZSwgd2UgbmVlZCB0byBpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2ltdWxhdGVJdGVtIHx8IHNpbXVsYXRlSXRlbS5rZXkgIT09IHdhbnRlZEl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0cy5wdXNoKHtrZXk6IHdhbnRlZEl0ZW0ua2V5LCB0bzoga30pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtcyBhcmUgbWF0Y2hpbmcsIHNvIHNraXAgYWhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlSW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0cy5wdXNoKHtrZXk6IHdhbnRlZEl0ZW0ua2V5LCB0bzoga30pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7a2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGt9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGEga2V5IGluIHNpbXVsYXRlIGhhcyBubyBtYXRjaGluZyB3YW50ZWQga2V5LCByZW1vdmUgaXRcbiAgICAgICAgICAgIGVsc2UgaWYgKHNpbXVsYXRlSXRlbSAmJiBzaW11bGF0ZUl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgcmVtb3Zlcy5wdXNoKHJlbW92ZShzaW11bGF0ZSwgc2ltdWxhdGVJbmRleCwgc2ltdWxhdGVJdGVtLmtleSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW11bGF0ZUluZGV4KytcbiAgICAgICAgICAgIGsrK1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCB0aGUgcmVtYWluaW5nIG5vZGVzIGZyb20gc2ltdWxhdGVcbiAgICB3aGlsZShzaW11bGF0ZUluZGV4IDwgc2ltdWxhdGUubGVuZ3RoKSB7XG4gICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdXG4gICAgICAgIHJlbW92ZXMucHVzaChyZW1vdmUoc2ltdWxhdGUsIHNpbXVsYXRlSW5kZXgsIHNpbXVsYXRlSXRlbSAmJiBzaW11bGF0ZUl0ZW0ua2V5KSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBtb3ZlcyB3ZSBoYXZlIGFyZSBkZWxldGVzIHRoZW4gd2UgY2FuIGp1c3RcbiAgICAvLyBsZXQgdGhlIGRlbGV0ZSBwYXRjaCByZW1vdmUgdGhlc2UgaXRlbXMuXG4gICAgaWYgKHJlbW92ZXMubGVuZ3RoID09PSBkZWxldGVkSXRlbXMgJiYgIWluc2VydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV3Q2hpbGRyZW4sXG4gICAgICAgICAgICBtb3ZlczogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuLFxuICAgICAgICBtb3Zlczoge1xuICAgICAgICAgICAgcmVtb3ZlczogcmVtb3ZlcyxcbiAgICAgICAgICAgIGluc2VydHM6IGluc2VydHNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGFyciwgaW5kZXgsIGtleSkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBpbmRleCxcbiAgICAgICAga2V5OiBrZXlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGtleUluZGV4KGNoaWxkcmVuKSB7XG4gICAgdmFyIGtleXMgPSB7fVxuICAgIHZhciBmcmVlID0gW11cbiAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cbiAgICAgICAgaWYgKGNoaWxkLmtleSkge1xuICAgICAgICAgICAga2V5c1tjaGlsZC5rZXldID0gaVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJlZS5wdXNoKGkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlzOiBrZXlzLCAgICAgLy8gQSBoYXNoIG9mIGtleSBuYW1lIHRvIGluZGV4XG4gICAgICAgIGZyZWU6IGZyZWUgICAgICAvLyBBbiBhcnJheSBvZiB1bmtleWVkIGl0ZW0gaW5kaWNlc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kUGF0Y2goYXBwbHksIHBhdGNoKSB7XG4gICAgaWYgKGFwcGx5KSB7XG4gICAgICAgIGlmIChpc0FycmF5KGFwcGx5KSkge1xuICAgICAgICAgICAgYXBwbHkucHVzaChwYXRjaClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5ID0gW2FwcGx5LCBwYXRjaF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcHBseVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRjaFxuICAgIH1cbn1cblxufSx7XCIuLi92bm9kZS9oYW5kbGUtdGh1bmtcIjozNixcIi4uL3Zub2RlL2lzLXRodW5rXCI6MzcsXCIuLi92bm9kZS9pcy12bm9kZVwiOjM5LFwiLi4vdm5vZGUvaXMtdnRleHRcIjo0MCxcIi4uL3Zub2RlL2lzLXdpZGdldFwiOjQxLFwiLi4vdm5vZGUvdnBhdGNoXCI6NDQsXCIuL2RpZmYtcHJvcHNcIjo0NixcIngtaXMtYXJyYXlcIjoyMX1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciB2ZG9tID0ge1xuICBWTm9kZTogcmVxdWlyZSgndmlydHVhbC1kb20vdm5vZGUvdm5vZGUnKSxcbiAgVlRleHQ6IHJlcXVpcmUoJ3ZpcnR1YWwtZG9tL3Zub2RlL3Z0ZXh0JyksXG4gIGRpZmY6IHJlcXVpcmUoJ3ZpcnR1YWwtZG9tL2RpZmYnKSxcbiAgcGF0Y2g6IHJlcXVpcmUoJ3ZpcnR1YWwtZG9tL3BhdGNoJyksXG4gIGNyZWF0ZUVsZW1lbnQ6IHJlcXVpcmUoJ3ZpcnR1YWwtZG9tL2NyZWF0ZS1lbGVtZW50JyksXG4gIHN2ZzogcmVxdWlyZShcInZpcnR1YWwtZG9tL3ZpcnR1YWwtaHlwZXJzY3JpcHQvc3ZnXCIpLFxufTtcblxuZ2xvYmFsLlZpcnR1YWxEb20gPSB2ZG9tO1xubW9kdWxlLmV4cG9ydHMgPSB2ZG9tO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1widmlydHVhbC1kb20vY3JlYXRlLWVsZW1lbnRcIjoxLFwidmlydHVhbC1kb20vZGlmZlwiOjIsXCJ2aXJ0dWFsLWRvbS9wYXRjaFwiOjIyLFwidmlydHVhbC1kb20vdmlydHVhbC1oeXBlcnNjcmlwdC9zdmdcIjozNSxcInZpcnR1YWwtZG9tL3Zub2RlL3Zub2RlXCI6NDMsXCJ2aXJ0dWFsLWRvbS92bm9kZS92dGV4dFwiOjQ1fV19LHt9LFs0OF0pKDQ4KVxufSk7XG4iLCIvLyBVc2VkIGJ5IHdvcmthcm91bmQgZm9yIGlucHV0IGVsZW1lbnQgdmFsdWUgZmllbGRcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0LUVzY2gvdmlydHVhbC1kb20vYmxvYi85NDdlY2Y5MmI2N2QyNWJiNjkzYTBmNjI1ZmE4ZTkwYzA5OTg4N2Q1L3ZpcnR1YWwtaHlwZXJzY3JpcHQvaG9va3Mvc29mdC1zZXQtaG9vay5qc1xuXG5qb29fZ2xvYmFsX29iamVjdC5Tb2Z0U2V0SG9vayA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvZnRTZXRIb29rKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvZnRTZXRIb29rKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuXG5qb29fZ2xvYmFsX29iamVjdC5Tb2Z0U2V0SG9vay5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxuXG52YXIgR2VuZXJpY0hvb2sgPSBmdW5jdGlvbiAoaW5pdCwgdXBkYXRlLCBkZXN0cm95LCBpZCwgZXh0cmEpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2VuZXJpY0hvb2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0hvb2soaW5pdCwgdXBkYXRlLCBkZXN0cm95LCBpZCwgZXh0cmEpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgdGhpcy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5leHRyYSA9IGV4dHJhO1xufTtcblxudmFyIGhvb2tfc3RhdGVfa2V5ID0gXCJ2ZG9tX2hvb2tfc3RhdGVfa2V5XCI7XG5cbmlmICh0aGlzLlN5bWJvbCkge1xuICAgIGhvb2tfc3RhdGVfa2V5ID0gU3ltYm9sKGhvb2tfc3RhdGVfa2V5KTtcbn1cblxuR2VuZXJpY0hvb2sud3JpdGVfc3RhdGUgPSBmdW5jdGlvbiAobm9kZSwgcHJvcE5hbWUsIHN0YXRlKSB7XG4gICAgaWYgKCFub2RlW2hvb2tfc3RhdGVfa2V5XSkge1xuICAgICAgICBub2RlW2hvb2tfc3RhdGVfa2V5XSA9IHt9O1xuICAgIH1cbiAgICBub2RlW2hvb2tfc3RhdGVfa2V5XVtwcm9wTmFtZV0gPSBzdGF0ZTtcbn1cblxuR2VuZXJpY0hvb2sucmVhZF9zdGF0ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBub2RlW2hvb2tfc3RhdGVfa2V5XVtwcm9wTmFtZV07XG59XG5cbkdlbmVyaWNIb29rLnJlbW92ZV9zdGF0ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wTmFtZSkge1xuICAgIGRlbGV0ZSBub2RlW2hvb2tfc3RhdGVfa2V5XVtwcm9wTmFtZV07XG59XG5cbkdlbmVyaWNIb29rLmNhblRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIHRoaXMgJiYgdG8gaW5zdGFuY2VvZiB0aGlzICYmIGZyb20uaWQgPT09IHRvLmlkICYmIHRvLnVwZGF0ZTtcbn07XG5cbkdlbmVyaWNIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BOYW1lLCBwcmV2KSB7XG4gICAgaWYgKEdlbmVyaWNIb29rLmNhblRyYW5zaXRpb24ocHJldiwgdGhpcykpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gR2VuZXJpY0hvb2sucmVhZF9zdGF0ZShub2RlLCBwcm9wTmFtZSk7XG4gICAgICAgIHN0YXRlID0gdGhpcy51cGRhdGUoc3RhdGUsIG5vZGUpO1xuICAgICAgICBHZW5lcmljSG9vay53cml0ZV9zdGF0ZShub2RlLCBwcm9wTmFtZSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuaW5pdChub2RlKTtcbiAgICAgICAgR2VuZXJpY0hvb2sud3JpdGVfc3RhdGUobm9kZSwgcHJvcE5hbWUsIHN0YXRlKTtcbiAgICB9XG59O1xuXG5HZW5lcmljSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BOYW1lLCBuZXh0KSB7XG4gICAgaWYgKEdlbmVyaWNIb29rLmNhblRyYW5zaXRpb24odGhpcywgbmV4dCkpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZywgdGhlIGltcGVuZGluZyBbaG9va10gd2lsbCBoYW5kbGUgdGhlIGNhbGwgdG8gdXBkYXRlLlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IEdlbmVyaWNIb29rLnJlYWRfc3RhdGUobm9kZSwgcHJvcE5hbWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koc3RhdGUsIG5vZGUpO1xuICAgICAgICBHZW5lcmljSG9vay5yZW1vdmVfc3RhdGUobm9kZSwgcHJvcE5hbWUpO1xuICAgIH1cbn07XG5cbmpvb19nbG9iYWxfb2JqZWN0LkdlbmVyaWNIb29rID0gR2VuZXJpY0hvb2s7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KHMubCk7XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL0FsaWFzOiBjYW1sX2ZpbGxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSxiLGMsZCxlKSB7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfY29udGVudChzKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmM7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcy5jXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyh4KSB7IHJldHVybiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHgpIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyAodGFnLCBhcmdzKSB7IHRocm93IFswLCB0YWddLmNvbmNhdChhcmdzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlPVsyNDgsY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIkZhaWx1cmVcIiksLTNdO1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiAhZWZmZWN0c1xuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiBlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZiAoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGgtMV0oZik7XG4gIHZhciBuID0gZi5sZW5ndGggfCAwO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMCkge1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKG4gLSAxKTtcbiAgICB2YXIgayA9IGFyZ3MgW2FyZ3NMZW4gLSAxXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgwLCBuKTtcbiAgICBhcmdzW24gLSAxXSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICB2YXIgYXJncyA9IHJlc3Quc2xpY2UoKTtcbiAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGs7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihnLCBhcmdzKTsgfTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzTGVuLS07XG4gICAgdmFyIGsgPSBhcmdzIFthcmdzTGVuXTtcbiAgICByZXR1cm4gayAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIGV4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKVxuICAgICAgICBuYXJnc1thcmdzTGVuICsgaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9KTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZihuYW1lX29wdCAmJiBnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGNhbWxfY2FsbGJhY2soZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jLCBbbmFtZV9vcHRdKTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWF5YmVfcHJpbnRfc3RhdHNcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfcHJpbnRfc3RhdHModW5pdCkgeyByZXR1cm4gMCB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IGYudXBwZXJjYXNlP1wiMFhcIjpcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmV4cG0xKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2V4cDJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLnBvdygyLCB4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzFwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzIoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHsgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgubG9nMTAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYWNvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYWNvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYWNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXNpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXNpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXRhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXRhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY2JydF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jYnJ0X2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNicnQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXJmX2Zsb2F0KHgpIHtcbiAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XG4gIHZhciBhMiA9IC0wLjI4NDQ5NjczNjtcbiAgdmFyIGEzID0gMS40MjE0MTM3NDE7XG4gIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgdmFyIGE1ID0gMS4wNjE0MDU0Mjk7XG4gIHZhciBwID0gMC4zMjc1OTExO1xuXG4gIHZhciBzaWduID0gMTtcbiAgaWYgKHggPCAwKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICB2YXIgeSA9IDEuMCAtICgoKChhNSAqIHQgKyBhNCkgKiB0ICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gc2lnbiAqIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmY19mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9lcmZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfZXJmY19mbG9hdCh4KSB7XG4gIHJldHVybiAxIC0gY2FtbF9lcmZfZmxvYXQoeCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9mbWFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZm1hX2Zsb2F0KHgsIHksIHopIHtcbiAgdmFyIFNQTElUID0gTWF0aC5wb3coMiwgMjcpICsgMTtcbiAgdmFyIE1JTl9WQUxVRSA9IE1hdGgucG93KDIsIC0xMDIyKTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICB2YXIgQyA9IDQxNjtcbiAgdmFyIEEgPSBNYXRoLnBvdygyLCArQyk7XG4gIHZhciBCID0gTWF0aC5wb3coMiwgLUMpO1xuXG4gIGZ1bmN0aW9uIG11bHRpcGx5IChhLCBiKSB7XG4gICAgdmFyIGF0ID0gU1BMSVQgKiBhO1xuICAgIHZhciBhaGkgPSBhdCAtIChhdCAtIGEpO1xuICAgIHZhciBhbG8gPSBhIC0gYWhpO1xuICAgIHZhciBidCA9IFNQTElUICogYjtcbiAgICB2YXIgYmhpID0gYnQgLSAoYnQgLSBiKTtcbiAgICB2YXIgYmxvID0gYiAtIGJoaTtcbiAgICB2YXIgcCA9IGEgKiBiO1xuICAgIHZhciBlID0gKChhaGkgKiBiaGkgLSBwKSArIGFoaSAqIGJsbyArIGFsbyAqIGJoaSkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB2YXIgcyA9IGEgKyBiO1xuICAgIHZhciB2ID0gcyAtIGE7XG4gICAgdmFyIGUgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdCAoeCwgeSkge1xuICAgIHJldHVybiB4ICE9PSAwICYmIHkgIT09IDAgJiYgU1BMSVQgKiB4IC0gKFNQTElUICogeCAtIHgpID09PSB4ID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pIDogeDtcbiAgfTtcblxuICBpZiAoeCA9PT0gMCB8fCB4ICE9PSB4IHx8IHggPT09ICsxIC8gMCB8fCB4ID09PSAtMSAvIDAgfHxcbiAgICAgIHkgPT09IDAgfHwgeSAhPT0geSB8fCB5ID09PSArMSAvIDAgfHwgeSA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICsgejtcbiAgfVxuICBpZiAoeiA9PT0gMCkge1xuICAgIHJldHVybiB4ICogeTtcbiAgfVxuICBpZiAoeiAhPT0geiB8fCB6ID09PSArMSAvIDAgfHwgeiA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxO1xuICB3aGlsZSAoTWF0aC5hYnMoeCkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB4ICo9IEI7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeSAqPSBCO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKiBzY2FsZTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeCkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB4ICo9IEE7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeSAqPSBBO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHhzID0geDtcbiAgdmFyIHlzID0geTtcbiAgdmFyIHpzID0geiAvIHNjYWxlO1xuXG4gIGlmIChNYXRoLmFicyh6cykgPiBNYXRoLmFicyh4cyAqIHlzKSAqIDQgLyBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cbiAgaWYgKE1hdGguYWJzKHpzKSA8IE1hdGguYWJzKHhzICogeXMpICogRVBTSUxPTiAvIDQgKiBFUFNJTE9OIC8gNCkge1xuICAgIHpzID0gKHogPCAwID8gLTEgOiArMSkgKiBNSU5fVkFMVUU7XG4gIH1cblxuICB2YXIgeHkgPSBtdWx0aXBseSh4cywgeXMpO1xuICB2YXIgcyA9IGFkZCh4eS5wLCB6cyk7XG4gIHZhciB1ID0gYWRkKHh5LmUsIHMuZSk7XG4gIHZhciBpID0gYWRkKHMucywgdS5zKTtcblxuICB2YXIgZiA9IGkucyArIGFkanVzdChpLmUsIHUuZSk7XG4gIGlmIChmID09PSAwKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICB2YXIgZnMgPSBmICogc2NhbGU7XG4gIGlmIChNYXRoLmFicyhmcykgPiBNSU5fVkFMVUUpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cblxuICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIHdhcyBleHRyYSByb3VuZGluZyBmb3IgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG4gIHJldHVybiBmcyArIGFkanVzdChmIC0gZnMgLyBzY2FsZSwgaS5lKSAqIHNjYWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8vaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNV18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8qXG5UbyBkZWFsIHdpdGggZWZmZWN0cywgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGlzIGludHVpdGl2ZWx5IGNvbXBvc2VkIG9mXG5hIHN0YWNrIG9mIGZpYmVycy4gRWFjaCBmaWJlciBoYXMgYSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb25cbihvbmUtYXJndW1lbnQgSmF2YVNjcmlwdCBmdW5jdGlvbiksIGEgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZFxuYSB0cmlwbGUgb2YgaGFuZGxlcnMsIHdoaWNoIGFyZSBpbnZva2VkIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXNcbihlaXRoZXIgd2l0aCBhIHZhbHVlIG9yIGFuIGV4Y2VwdGlvbikgb3Igd2hlbiBhbiBlZmZlY3QgaXMgcGVyZm9ybWVkLlxuVGhlIGxvdy1sZXZlbCBjb250aW51YXRpb24gb2YgdGhlIHRvcG1vc3QgZmliZXIgKHdoaWNoIGlzIGN1cnJlbnRseVxuZXhlY3V0aW5nKSBpcyBwYXNzZWQgZnJvbSBmdW5jdGlvbiB0byBmdW5jdGlvbiBhcyBhbiBhZGRpdGlvbmFsXG5hcmd1bWVudC4gSXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBpcyBzdG9yZWQgaW5cbltjYW1sX2V4bl9zdGFja10uIEV4Y2VwdGlvbiBoYW5kbGVycyBhcmUgcHVzaGVkIGludG8gdGhpcyBzdGFjayB3aGVuXG5lbnRlcmluZyBhIFt0cnkgLi4uIHdpdGggLi4uXSBhbmQgcG9wcGVkIG9uIGV4aXQuIFRoZW4sIGhhbmRsZXJzIGFuZFxudGhlIHJlbWFpbmluZyBmaWJlcnMgYXJlIHN0b3JlZCBpbiBbY2FtbF9maWJlcl9zdGFja10uIFRvIGluc3RhbGwgYW5cbmVmZmVjdCBoYW5kbGVyLCB3ZSBwdXNoIGEgbmV3IGZpYmVyIGludG8gdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuXG5XZSBoYXZlIGJhc2ljYWxseSB0aGUgZm9sbG93aW5nIHR5cGUgZm9yIHJlaWZpZWQgY29udGludWF0aW9ucyAodHlwZVxuW2NvbnRpbnVhdGlvbl0gaW4gbW9kdWxlIFtFZmZlY3RdIG9mIHRoZSBzdGFuZGFyZCBsaWJyYXJ5KTpcblxuICB0eXBlICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiA9ICgnYSwgJ2IpIHN0YWNrIHJlZlxuXG4gIGFuZCAoXywgXykgc3RhY2sgPVxuICAgICAgQ29ucyA6ICgnYiAtPiB1bml0KSAqICAgICAgICAgICAgICgqIGxvdy1sZXZlbCBjb250aW51YXRpb24gKilcbiAgICAgICAgICAgICAoZXhuIC0+IHVuaXQpIGxpc3QgKiAgICAgICAoKiBleGNlcHRpb24gaGFuZGxlcnMgKilcbiAgICAgICAgICAgICAoJ2IsICdjKSBoYW5kbGVyICpcbiAgICAgICAgICAgICAoJ2EsICdiKSBzdGFja1xuICAgICAgICAgICAgIC0+ICgnYSwgJ2MpIHN0YWNrXG4gICAgfCBFbXB0eSA6ICgnYSwgJ2EpIHN0YWNrXG5cbiAgYW5kICgnYSwnYikgaGFuZGxlciA9ICAgKCogQXMgaW4gbW9kdWxlIEVmZmVjdCBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG4gICAgeyByZXRjOiAnYSAtPiAnYjtcbiAgICAgIGV4bmM6IGV4biAtPiAnYjtcbiAgICAgIGVmZmM6ICdjLidjIEVmZmVjdC50IC0+ICgoJ2MsJ2IpIGNvbnRpbnVhdGlvbiAtPiAnYikgb3B0aW9uIH1cblxuQ29udGludWF0aW9ucyBhcmUgb25lLXNob3QuIEEgY29udGludWF0aW9uIFtyZWYgRW1wdHldIGhhcyBhbHJlYWR5XG5iZWVuIHJlc3VtZWQuXG5cbkEgY29udGludWF0aW9uIGlzIGJhc2ljYWxseSBjb21wb3NlZCBvZiBhIGxpc3Qgb2YgZmliZXJzLCB3aGljaCBlYWNoXG5oYXMgaXRzIGxvdy1sZXZlbCBjb250aW51YXRpb24sIGl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgYW5kIGFcbnRyaXBsZSBvZiBoYW5kbGVycyB0byBkZWFsIHdpdGggd2hlbiB0aGUgZmliZXIgdGVybWluYXRlcyBvciBhblxuZWZmZWN0IGlzIHBlcmZvcm1lZC4gV2hlbiByZXN1bWluZyBhIGNvbnRpbnVhdGlvbiwgdGhlIGlubmVybW9zdCBmaWJlclxuaXMgcmVzdW1lZCBmaXJzdC5cblxuVGhlIGhhbmRsZXJzIGFyZSBDUFMtdHJhbnNmb3JtZWQgZnVuY3Rpb25zOiB0aGV5IGFjdHVhbGx5IHRha2UgYW5cbmFkZGl0aW9uYWwgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb24uXG4qL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBpcyBhbiBPQ2FtbCBsaXN0IG9mIGV4Y2VwdGlvbiBoYW5kbGVyc1xudmFyIGNhbWxfZXhuX3N0YWNrID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9wdXNoX3RyYXBcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3B1c2hfdHJhcChoYW5kbGVyKSB7XG4gIGNhbWxfZXhuX3N0YWNrPVswLGhhbmRsZXIsY2FtbF9leG5fc3RhY2tdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfdHJhcCgpIHtcbiAgaWYgKCFjYW1sX2V4bl9zdGFjaykgcmV0dXJuIGZ1bmN0aW9uKHgpe3Rocm93IHg7fVxuICB2YXIgaCA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICBjYW1sX2V4bl9zdGFjaz1jYW1sX2V4bl9zdGFja1syXTtcbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBoYXMgdGhlIHNoYXBlIHtoLCByOntrLCB4LCBlfX0gd2hlcmUgaCBpcyBhIHRyaXBsZSBvZiBoYW5kbGVyc1xuLy8gKHNlZSBlZmZlY3QuanMpIGFuZCBrLCB4IGFuZCBlIGFyZSB0aGUgc2F2ZWQgY29udGludWF0aW9uLFxuLy8gZXhjZXB0aW9uIHN0YWNrIGFuZCBmaWJlciBzdGFjayBvZiB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNhbWxfZmliZXJfc3RhY2s7XG5cbi8vUHJvdmlkZXM6Y2FtbF9yZXN1bWVfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3Jlc3VtZV9zdGFjayhzdGFjaywgaykge1xuICBpZiAoIXN0YWNrKSBjYW1sX3JhaXNlX2NvbnN0YW50XG4gICAgICAgICAgICAgICAgIChjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LkNvbnRpbnVhdGlvbl9hbHJlYWR5X3Jlc3VtZWRcIikpO1xuICAvLyBVcGRhdGUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHdpdGggdGhlIHN0YWNrIG9mIGZpYmVycyBpbiBbc3RhY2tdIGluXG4gIC8vIG9yZGVyIHRvIHJlc3VtZSB0aGUgY29udGludWF0aW9uXG4gIGRvIHtcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID1cbiAgICAgIHtoOnN0YWNrWzNdLCByOntrOmssIHg6Y2FtbF9leG5fc3RhY2ssIGU6Y2FtbF9maWJlcl9zdGFja319O1xuICAgIGsgPSBzdGFja1sxXTtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHN0YWNrWzJdO1xuICAgIHN0YWNrID0gc3RhY2tbNF07XG4gIH0gd2hpbGUgKHN0YWNrKVxuICByZXR1cm4gaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfZmliZXJcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3BvcF9maWJlcigpIHtcbiAgLy8gTW92ZSB0byB0aGUgcGFyZW50IGZpYmVyLCByZXR1cm5pbmcgdGhlIHBhcmVudCdzIGxvdy1sZXZlbCBjb250aW51YXRpb25cbiAgdmFyIHJlbSA9IGNhbWxfZmliZXJfc3RhY2sucjtcbiAgY2FtbF9leG5fc3RhY2sgPSByZW0ueDtcbiAgY2FtbF9maWJlcl9zdGFjayA9IHJlbS5lO1xuICByZXR1cm4gcmVtLms7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGVyZm9ybV9lZmZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoLCBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wZXJmb3JtX2VmZmVjdChlZmYsIGNvbnQsIGswKSB7XG4gIC8vIEFsbG9jYXRlIGEgY29udGludWF0aW9uIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKCFjb250KSBjb250ID0gWzI0NSAvKmNvbnRpbnVhdGlvbiovLCAwXTtcbiAgLy8gR2V0IGN1cnJlbnQgZWZmZWN0IGhhbmRsZXJcbiAgdmFyIGhhbmRsZXIgPSBjYW1sX2ZpYmVyX3N0YWNrLmhbM107XG4gIC8vIENvbnMgdGhlIGN1cnJlbnQgZmliZXIgb250byB0aGUgY29udGludWF0aW9uOlxuICAvLyAgIGNvbnQgOj0gQ29ucyAoaywgZXhuX3N0YWNrLCBoYW5kbGVycywgIWNvbnQpXG4gIGNvbnRbMV0gPSBbMCxrMCxjYW1sX2V4bl9zdGFjayxjYW1sX2ZpYmVyX3N0YWNrLmgsY29udFsxXV07XG4gIC8vIE1vdmUgdG8gcGFyZW50IGZpYmVyIGFuZCBleGVjdXRlIHRoZSBlZmZlY3QgaGFuZGxlciB0aGVyZVxuICAvLyBUaGUgaGFuZGxlciBpcyBkZWZpbmVkIGluIFN0ZGxpYi5FZmZlY3QsIHNvIHdlIGtub3cgdGhhdCB0aGUgYXJpdHkgbWF0Y2hlc1xuICB2YXIgazEgPSBjYW1sX3BvcF9maWJlcigpO1xuICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpP2hhbmRsZXIoZWZmLGNvbnQsazEsazEpXG4gICAgICAgICA6Y2FtbF90cmFtcG9saW5lX3JldHVybihoYW5kbGVyLFtlZmYsY29udCxrMSxrMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FsbG9jX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9maWJlcl9zdGFjaywgY2FtbF9jYWxsX2dlblxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9hbGxvY19zdGFjayhodiwgaHgsIGhmKSB7XG4gIGZ1bmN0aW9uIGh2YWwoeCkge1xuICAgIC8vIENhbGwgW2h2XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgdmFyIGY9Y2FtbF9maWJlcl9zdGFjay5oWzFdO1xuICAgIHZhciBrPWNhbWxfcG9wX2ZpYmVyKCk7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3gsIGtdKTtcbiAgfVxuICBmdW5jdGlvbiBoZXhuKGUpIHtcbiAgICAvLyBDYWxsIFtoeF0gaW4gdGhlIHBhcmVudCBmaWJlclxuICAgIHZhciBmPWNhbWxfZmliZXJfc3RhY2suaFsyXTtcbiAgICB2YXIgaz1jYW1sX3BvcF9maWJlcigpO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFtlLCBrXSk7XG4gIH1cbiAgcmV0dXJuIFswLCBodmFsLCBbMCwgaGV4biwgMF0sIFswLCBodiwgaHgsIGhmXSwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2Nfc3RhY2tcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpIHtcbiAgdmFyIHN0YWNrPWNvbnRbMV07XG4gIGNvbnRbMV09MDtcbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMoY29udCwgaHZhbCwgaGV4biwgaGVmZikge1xuICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gIHN0YWNrWzNdID0gWzAsIGh2YWwsIGhleG4sIGhlZmZdO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcbmZ1bmN0aW9uIGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX25ld1xuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fbmV3KHVuaXQpe1xuICAgIHJldHVybiB7Y29uZGl0aW9uOjF9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl93YWl0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl93YWl0KHQsbXV0ZXh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyFJZjogZWZmZWN0c1xuZnVuY3Rpb24ganNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiRWZmZWN0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpXG59XG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZkLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJEZXZpY2UgPSB0aGlzLmZzLmxzdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0NoYXJhY3RlckRldmljZSgpO1xuICAgIGYuaXNDaGFyYWN0ZXJEZXZpY2UgPSBpc0NoYXJhY3RlckRldmljZTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbih0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmModGhpcy5ubSh0YXJnZXQpLCB0aGlzLm5tKHBhdGgpLCB0b19kaXIgPyAnZGlyJyA6ICdmaWxlJyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCAndXRmOCcpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhsaW5rKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLm9wZW5kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKCkge1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGZChmZCwgZmxhZ3Mpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbE5vZGVGZC5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxOb2RlRmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmQ7XG5cbk1sTm9kZUZkLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYSxidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgIGVsc2VcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gICAgcmV0dXJuIHJlYWQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRmQoKXtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL1JlcXVpcmVzOiBNbE5vZGVGZFxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3Mpe1xuICBpZihmbGFncy5uYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgIHZhciBmZDIgPSBmcy5vcGVuU3luYyhmbGFncy5uYW1lLCBcInJzXCIpO1xuICAgICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZDIsIGZsYWdzKTtcbiAgICB9IGNhdGNoKGUpIHsgIH1cbiAgfVxuICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmbGFncyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKXtcbiAgcmV0dXJuIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpID8gKG5hbWUgKyBcIi9cIikgOiBuYW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmNhbWxfY3VycmVudF9kaXIgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKGNhbWxfY3VycmVudF9kaXIpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9yb290XG4vL1JlcXVpcmVzOiBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX2dldF9yb290KHBhdGgpe1xuICB2YXIgeCA9IHBhdGhfaXNfYWJzb2x1dGUocGF0aCk7XG4gIGlmICgheCkgcmV0dXJuO1xuICByZXR1cm4geFswXSArIFwiL1wifVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X3Jvb3QsIGNhbWxfY3VycmVudF9kaXIsIGNhbWxfZmFpbHdpdGhcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2dldF9yb290KGNhbWxfY3VycmVudF9kaXIpIHx8IGNhbWxfZmFpbHdpdGgoXCJ1bmFibGUgdG8gY29tcHV0ZSBjYW1sX3Jvb3RcIik7XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogcGF0aF9pc19hYnNvbHV0ZVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpIHtcbiAgZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSByZXR1cm4gW1wiXCIsIHBhdGguc3Vic3RyaW5nKDEpXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiB3aW4zMihwYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcbiAgICB2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXC9dezJ9W15cXFxcL10rW1xcXFwvXStbXlxcXFwvXSspPyhbXFxcXC9dKT8oW1xcc1xcU10qPykkLztcbiAgICB2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuICAgIHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG4gICAgdmFyIGlzVW5jID0gQm9vbGVhbihkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonKTtcblxuICAgIC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG4gICAgaWYgKEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKSkge1xuICAgICAgdmFyIHJvb3QgPSAocmVzdWx0WzFdIHx8ICcnKTtcbiAgICAgIHZhciBzZXAgPSAocmVzdWx0WzJdIHx8ICcnKTtcbiAgICAgIHJldHVybiBbcm9vdCwgcGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGggKyBzZXAubGVuZ3RoKV1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbiAgfVxuICBlbHNlIHJldHVybiBwb3NpeFxufVxudmFyIHBhdGhfaXNfYWJzb2x1dGUgPSBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZiggIXBhdGhfaXNfYWJzb2x1dGUobmFtZSkgKVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAwID0gcGF0aF9pc19hYnNvbHV0ZShuYW1lKTtcbiAgdmFyIGNvbXAgPSBjb21wMFsxXS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC51bnNoaWZ0KGNvbXAwWzBdKTtcbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpcIi9zdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKFwiL3N0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2V0X3Jvb3QsIE1sTm9kZURldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIGlmKCAhcmVzICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgcm9vdCA9IGNhbWxfZ2V0X3Jvb3QobmFtZSk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSl7XG4gICAgICB2YXIgbSA9IHtwYXRoOnJvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2Uocm9vdCl9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgICB9XG4gIH1cbiAgaWYoIHJlcyApIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocm9vdC5wYXRoICsgcm9vdC5yZXN0KTtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhkaXIpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N5c19ta2RpcihuYW1lLCBwZXJtKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub3RfYV9kaXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3JtZGlyKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX3N5c19mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSlcbiAgICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWdsb2JhbFRoaXMuY2FtbF9mc190bXApIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBqc29vX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9Z2xvYmFsVGhpcy5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAganNvb19jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSA9IGpzb29fY3JlYXRlX2ZpbGU7XG4gIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpO1xuICB2YXIgY29udGVudCA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk7XG4gIHJldHVybiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsIGNvbnRlbnQpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF90aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGNhbWxfdW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ210aW1lXG4vL0FsaWFzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvY2FsdGltZVxuLy9BbGlhczogdW5peF9ta3RpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gY2FtbF91bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXJ0dXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9zdGFydHVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbGVhbnVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fY2xlYW51cFxuZnVuY3Rpb24gY2FtbF91bml4X2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIGNvbnN0XG4vL0FsaWFzOiB3aW5faGFuZGxlX2ZkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKT8xOjA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaXNhdHR5XG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLCBcIkVBQ0NFU1wiLCBcIkVBR0FJTlwiLCBcIkVCQURGXCIsIFwiRUJVU1lcIiwgXCJFQ0hJTERcIiwgXCJFREVBRExLXCIsIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLCBcIkVGQVVMVFwiLCBcIkVGQklHXCIsIFwiRUlOVFJcIiwgXCJFSU5WQUxcIiwgXCJFSU9cIiwgXCJFSVNESVJcIiwgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIiwgXCJFTkFNRVRPT0xPTkdcIiwgXCJFTkZJTEVcIiwgXCJFTk9ERVZcIiwgXCJFTk9FTlRcIiwgXCJFTk9FWEVDXCIsIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsIFwiRU5PU1BDXCIsIFwiRU5PU1lTXCIsIFwiRU5PVERJUlwiLCBcIkVOT1RFTVBUWVwiLCBcIkVOT1RUWVwiLCBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIiwgXCJFUElQRVwiLCBcIkVSQU5HRVwiLCBcIkVST0ZTXCIsIFwiRVNQSVBFXCIsIFwiRVNSQ0hcIiwgXCJFWERFVlwiLCBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIiwgXCJFQUxSRUFEWVwiLCBcIkVOT1RTT0NLXCIsIFwiRURFU1RBRERSUkVRXCIsIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsIFwiRU5PUFJPVE9PUFRcIiwgXCJFUFJPVE9OT1NVUFBPUlRcIiwgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsIFwiRVBGTk9TVVBQT1JUXCIsIFwiRUFGTk9TVVBQT1JUXCIsIFwiRUFERFJJTlVTRVwiLCBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLCBcIkVORVRVTlJFQUNIXCIsIFwiRU5FVFJFU0VUXCIsIFwiRUNPTk5BQk9SVEVEXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsIFwiRU5PVENPTk5cIiwgXCJFU0hVVERPV05cIiwgXCJFVE9PTUFOWVJFRlNcIiwgXCJFVElNRURPVVRcIiwgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIiwgXCJFSE9TVFVOUkVBQ0hcIiwgXCJFTE9PUFwiLCBcIkVPVkVSRkxPV1wiXG5dO1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIGVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKVxuICBdO1xuICByZXR1cm4gYXJncztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X3N0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXRfNjQobmFtZSkge1xuICB2YXIgciA9IGNhbWxfdW5peF9zdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9sc3RhdFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbHN0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubHN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sc3RhdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxuLy9BbGlhczogdW5peF9sc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHIgPSBjYW1sX3VuaXhfbHN0YXQobmFtZSk7XG4gIHJbOV0gPSBjYW1sX2ludDY0X29mX2ludDMyKHJbOV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X21rZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWtkaXIobmFtZSwgcGVybSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm1rZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9ta2Rpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QsIHBlcm0sIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfcm1kaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ybWRpcihuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uucm1kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3JtZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N5bWxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N5bWxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9zeW1saW5rKHRvX2Rpciwgc3JjLCBkc3QpIHtcbiAgdmFyIHNyY19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uoc3JjKTtcbiAgdmFyIGRzdF9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZHN0KTtcbiAgaWYoc3JjX3Jvb3QuZGV2aWNlICE9IGRzdF9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IGNhbm5vdCBzeW1saW5rIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1zXCIpO1xuICBpZiAoIXNyY19yb290LmRldmljZS5zeW1saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zeW1saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNyY19yb290LmRldmljZS5zeW1saW5rKHRvX2Rpciwgc3JjX3Jvb3QucmVzdCwgZHN0X3Jvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRsaW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9yZWFkbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRsaW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5yZWFkbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcmVhZGxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UucmVhZGxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdW5saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF91bmxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF91bmxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnVubGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfdW5saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL0FsaWFzOiB1bml4X2dldHVpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHVpZCh1bml0KSB7XG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKXtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCgpO1xuICB9XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXRwd3VpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vQWxpYXM6IHVuaXhfZ2V0cHd1aWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXRwd3VpZCh1bml0KSB7XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9oYXNfc3ltbGlua1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vQWxpYXM6IHVuaXhfaGFzX3N5bWxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9oYXNfc3ltbGluayh1bml0KSB7XG4gIHJldHVybiBmc19ub2RlX3N1cHBvcnRlZCgpPzE6MFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfb3BlbmRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfb3BlbmRpclxuZnVuY3Rpb24gY2FtbF91bml4X29wZW5kaXIocGF0aCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHBhdGgpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm9wZW5kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X29wZW5kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICB2YXIgZGlyX2hhbmRsZSA9IHJvb3QuZGV2aWNlLm9wZW5kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xuICByZXR1cm4geyBwb2ludGVyIDogZGlyX2hhbmRsZSwgcGF0aDogcGF0aCB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZWFkZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZVxuLy9BbGlhczogdW5peF9yZWFkZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKSB7XG4gIHZhciBlbnRyeTtcbiAgdHJ5IHtcbiAgICAgIGVudHJ5ID0gZGlyX2hhbmRsZS5wb2ludGVyLnJlYWRTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcInJlYWRkaXJcIiwgZGlyX2hhbmRsZS5wYXRoKSk7XG4gIH1cbiAgaWYgKGVudHJ5ID09PSBudWxsKSB7XG4gICAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZW50cnkubmFtZSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2Nsb3NlZGlyXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL0FsaWFzOiB1bml4X2Nsb3NlZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSkge1xuICB0cnkge1xuICAgICAgZGlyX2hhbmRsZS5wb2ludGVyLmNsb3NlU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCBkaXJfaGFuZGxlLnBhdGgpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmV3aW5kZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXIsIGNhbWxfdW5peF9vcGVuZGlyXG4vL0FsaWFzOiB1bml4X3Jld2luZGRpclxuZnVuY3Rpb24gY2FtbF91bml4X3Jld2luZGRpcihkaXJfaGFuZGxlKSB7XG4gIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKTtcbiAgdmFyIG5ld19kaXJfaGFuZGxlID0gY2FtbF91bml4X29wZW5kaXIoZGlyX2hhbmRsZS5wYXRoKTtcbiAgZGlyX2hhbmRsZS5wb2ludGVyID0gbmV3X2Rpcl9oYW5kbGUucG9pbnRlcjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kZmlyc3Rcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91bml4X29wZW5kaXIsIGNhbWxfdW5peF9yZWFkZGlyXG4vL0FsaWFzOiB3aW5fZmluZGZpcnN0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZGZpcnN0KHBhdGgpIHtcbiAgLy8gVGhlIFdpbmRvd3MgY29kZSBhZGRzIHRoaXMgZ2xvYiB0byB0aGUgcGF0aCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXRcbiAgdmFyIHBhdGhfanMgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwYXRoKTtcbiAgcGF0aF9qcyA9IHBhdGhfanMucmVwbGFjZSgvKF58W1xcXFxcXC9dKVxcKlxcLlxcKiQvLCBcIlwiKTtcbiAgcGF0aCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGhfanMpO1xuICAvLyAqLiogaXMgbm93IHN0cmlwcGVkXG4gIHZhciBkaXJfaGFuZGxlID0gY2FtbF91bml4X29wZW5kaXIocGF0aCk7XG4gIHZhciBmaXJzdF9lbnRyeSA9IGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xuICAvLyBUaGUgV2luZG93cyBiaW5kaW5ncyB0eXBlIGRpcl9oYW5kbGUgYXMgYW4gYGludGAgYnV0IGl0J3Mgbm90IGluIEpTXG4gIHJldHVybiBbMCwgZmlyc3RfZW50cnksIGRpcl9oYW5kbGVdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZG5leHRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9yZWFkZGlyXG4vL0FsaWFzOiB3aW5fZmluZG5leHRcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kbmV4dChkaXJfaGFuZGxlKSB7XG4gIHJldHVybiBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRjbG9zZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2Nsb3NlZGlyXG4vL0FsaWFzOiB3aW5fZmluZGNsb3NlXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZGNsb3NlKGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuLy9BbGlhczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIGlmKGdsb2JhbFRoaXMucXVpdCkgZ2xvYmFsVGhpcy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQpXG4gICAgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb24sIGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgY2FtbF9jYWxsYmFjayhoYW5kbGVyLCBbZXJyLGZhbHNlXSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbXNnID0gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGVycik7XG4gICAgICB2YXIgYXRfZXhpdCA9IGNhbWxfbmFtZWRfdmFsdWUoXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIik7XG4gICAgICBpZihhdF9leGl0KSBjYW1sX2NhbGxiYWNrKGF0X2V4aXQsIFswXSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIiArIG1zZyArIFwiXFxuXCIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudilcbiAgICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYocHJvY2Vzc1xuICAgICAmJiBwcm9jZXNzLmVudlxuICAgICAmJiBwcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHByb2Nlc3MuZW52W25dKTtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuYXJndlxuICAgICAmJiBwcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiKXtcbiAgICB2YXIgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbiAgICBpZihjaGlsZF9wcm9jZXNzICYmIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMpXG4gICAgICB0cnkge1xuICAgICAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pO1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKiAwLjAwMTtcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWUgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgcmV0dXJuIG5vdyAqIDAuMDAxIC0gY2FtbF9pbml0aWFsX3RpbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlblxuLy9SZXF1aXJlczogY2FtbF9zeXNfdGltZVxuZnVuY3Rpb24gY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuKGIpIHtcbiAgcmV0dXJuIGNhbWxfc3lzX3RpbWUoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICBpZihnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpe1xuICAgICAgLy8gV2ViYnJvd3NlcnNcbiAgICAgIHZhciBhID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH0gZWxzZSBpZihnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBOb2RlanNcbiAgICAgIHZhciBidWZmID0gZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICB2YXIgYSA9IG5ldyBVaW50MzJBcnJheShidWZmKTtcbiAgICAgIHJldHVybiBbMCxhWzBdXTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIlVuaXhcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiBvc190eXBlID09IFwiV2luMzJcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJDeWd3aW5cIiA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBvc190eXBlXG52YXIgb3NfdHlwZSA9IChnbG9iYWxUaGlzLnByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09IFwid2luMzJcIikgPyBcIkN5Z3dpblwiIDogXCJVbml4XCI7XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhvc190eXBlKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgaWYocHJvY2VzcyAmJiBwcm9jZXNzLm9uKSB7XG4gICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBmdW5jdGlvbiAoZXJyLCBvcmlnaW4pIHtcbiAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycik7XG4gICAgICBwcm9jZXNzLmV4aXQgKDIpO1xuICAgIH0pXG4gIH1cbiAgZWxzZSBpZihnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBpZihldmVudC5lcnJvcil7XG4gICAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBNbEZha2VGZCwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZXNcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY3JlYXRlX2Rpcl9pZl9uZWVkZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciByZXMgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY29tcC5sZW5ndGggLSAxOyBpKyspe1xuICAgIHJlcyArPSBjb21wW2ldICsgXCIvXCI7XG4gICAgaWYodGhpcy5jb250ZW50W3Jlc10pIGNvbnRpbnVlO1xuICAgIHRoaXMuY29udGVudFtyZXNdID0gU3ltYm9sKFwiZGlyZWN0b3J5XCIpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnNsYXNoID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiAvXFwvJC8udGVzdChuYW1lKT9uYW1lOihuYW1lICsgXCIvXCIpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgICB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gICAgfVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVfc2xhc2hdKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSxtb2RlLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUVYSVNUXCIsIFwibWtkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogRmlsZSBleGlzdHNcIik7XG4gICAgfVxuICB9XG4gIHZhciBwYXJlbnQgPSAvXiguKilcXC9bXi9dKy8uZXhlYyhuYW1lKTtcbiAgcGFyZW50ID0gKHBhcmVudCAmJiBwYXJlbnRbMV0pIHx8ICcnO1xuICBpZighdGhpcy5leGlzdHMocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZihuLm1hdGNoKHIpKSB7XG4gICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URU1QVFlcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCI6IERpcmVjdG9yeSBub3QgZW1wdHlcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF07XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgfVxuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW5kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcblxuICB2YXIgYSA9IHRoaXMucmVhZGRpcihuYW1lKTtcbiAgdmFyIGMgPSBmYWxzZTtcbiAgdmFyIGkgPSAwO1xuICByZXR1cm4geyByZWFkU3luYyA6IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGMpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihpID09IGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZW50cnkgPSBhW2ldO1xuICAgIGkrKztcbiAgICByZXR1cm4geyBuYW1lOiBlbnRyeSB9XG4gIH0pXG4gICAgLCBjbG9zZVN5bmM6IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjID0gdHJ1ZTtcbiAgICAgIGEgPSBbXTtcbiAgICB9KVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYobmFtZSA9PSBcIlwiKSAgcmV0dXJuIHRydWU7XG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBmaWxlO1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEZha2VGZCh0aGlzLm5tKG5hbWUpLCBmaWxlLCBmKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIHZhciBmaWxlO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgaWYoZmlsZSl7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBmaWxlO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICBsZW4gPSBjbGVuIC0gb2Zmc2V0O1xuICB9XG4gIGlmKGxlbikge1xuICAgIHZhciBkYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICAgIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgZGF0YSwgMCwgbGVuKTtcbiAgICBidWYuc2V0KGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoZGF0YSksIHBvcyk7XG4gIH1cbiAgcmV0dXJuIGxlblxufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkX291dChmZCxmbGFncykge1xuICBNbEZha2VGaWxlLmNhbGwodGhpcywgY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICB0aGlzLmxvZyA9IChmdW5jdGlvbiAocykgeyByZXR1cm4gMCB9KTtcbiAgaWYoZmQgPT0gMSAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5sb2c7XG4gIGVsc2UgaWYoZmQgPT0gMiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmVycm9yO1xuICBlbHNlIGlmKHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZ1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9mZnNldCxidWYscG9zLGxlbikge1xuICBpZih0aGlzLmxvZykge1xuICAgIGlmKGxlbiA+IDBcbiAgICAgICAmJiBwb3MgPj0gMFxuICAgICAgICYmIHBvcytsZW4gPD0gYnVmLmxlbmd0aFxuICAgICAgICYmIGJ1Zltwb3MrbGVuLTFdID09IDEwKVxuICAgICAgbGVuIC0tO1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIHZhciBzcmMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgc3JjLCAwLCBsZW4pO1xuICAgIHRoaXMubG9nKHNyYy50b1V0ZjE2KCkpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMuZmQgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGlzIHdyaXRlIG9ubHlcIik7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvZyA9IHVuZGVmaW5lZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkKG5hbWUsIGZpbGUsZmxhZ3MpIHtcbiAgdGhpcy5maWxlID0gZmlsZTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuXG5NbEZha2VGZC5wcm90b3R5cGUuZXJyX2Nsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5uYW1lICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgYWxyZWFkeSBjbG9zZWRcIik7XG59XG5NbEZha2VGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5sZW5ndGggKClcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS53cml0ZShvZmZzZXQsYnVmLHBvcyxsZW4pXG4gIHRoaXMuZXJyX2Nsb3NlZCgpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5yZWFkKG9mZnNldCwgYnVmLCBwb3MsIGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmlsZSA9IHVuZGVmaW5lZDtcbn1cbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoeCk7XG4gIC8vIGxlbmd0aF9uYXQgaXNuJ3QgZXh0ZXJuYWwsIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGUgT2JqLnNpemVcbiAgLy8gd29yayBvdXQgcmlnaHQuIFRoZSArMiB0byBhcnJheSBsZW5ndGggc2VlbXMgdG8gd29yay5cbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoICsgMlxufVxuXG5NbE5hdC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9uYXRcIjtcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCl7XG4gIHJldHVybiBuZXcgTWxOYXQobCk7XG59XG5cbi8vUHJvdmlkZXM6IGNyZWF0ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBjcmVhdGVfbmF0KHNpemUpIHtcbiAgdmFyIGFyciA9IG5ldyBNbE5hdChzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGFyci5kYXRhW2ldID0gLTE7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy9Qcm92aWRlczogc2V0X3RvX3plcm9fbmF0XG5mdW5jdGlvbiBzZXRfdG9femVyb19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBibGl0X25hdFxuZnVuY3Rpb24gYmxpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMiwgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gbmF0Mi5kYXRhW29mczIraV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXQobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXQobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gbnVtX2RpZ2l0c19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmKG5hdC5kYXRhW29mcytpXSAhPSAwKSByZXR1cm4gaSsxO1xuICB9XG4gIHJldHVybiAxOyAvLyAwIGNvdW50cyBhcyAxIGRpZ2l0XG59XG5cbi8vUHJvdmlkZXM6IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdFxuZnVuY3Rpb24gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdCwgb2ZzKSB7XG4gIHZhciBhID0gbmF0LmRhdGFbb2ZzXTtcbiAgdmFyIGIgPSAwO1xuICBpZihhICYgMHhGRkZGMDAwMCkgeyBiICs9MTY7IGEgPj4+PTE2OyB9XG4gIGlmKGEgJiAweEZGMDApICAgICB7IGIgKz0gODsgYSA+Pj49IDg7IH1cbiAgaWYoYSAmIDB4RjApICAgICAgIHsgYiArPSA0OyBhID4+Pj0gNDsgfVxuICBpZihhICYgMTIpICAgICAgICAgeyBiICs9IDI7IGEgPj4+PSAyOyB9XG4gIGlmKGEgJiAyKSAgICAgICAgICB7IGIgKz0gMTsgYSA+Pj49IDE7IH1cbiAgaWYoYSAmIDEpICAgICAgICAgIHsgYiArPSAxOyB9XG4gIHJldHVybiAzMiAtIGI7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X2ludFxuZnVuY3Rpb24gaXNfZGlnaXRfaW50KG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID49IDApIHJldHVybiAxXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gPT0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9vZGRcbmZ1bmN0aW9uIGlzX2RpZ2l0X29kZChuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdICYgMSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbmNyX25hdFxuZnVuY3Rpb24gaW5jcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoeCB8IDApO1xuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogYWRkX25hdFxuLy9SZXF1aXJlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5jcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIGNhcnJ5KTtcbn1cblxuLy9Qcm92aWRlczogY29tcGxlbWVudF9uYXRcbmZ1bmN0aW9uIGNvbXBsZW1lbnRfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKC0xID4+PiAwKSAtIChuYXQuZGF0YVtvZnMraV0gPj4+IDApO1xuICB9XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vL1Byb3ZpZGVzOiBkZWNyX25hdFxuZnVuY3Rpb24gZGVjcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+MCkgLSBib3Jyb3c7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAoYm9ycm93ID09IDEpID8gMCA6IDE7XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IHN1Yl9uYXRcbi8vUmVxdWlyZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBzdWJfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSAtIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgLSBib3Jyb3c7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgKGJvcnJvdz09MSk/MDoxKTtcbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1tvZnMzXVxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBtdWx0X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogYWRkX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBhID0gKG5hdDMuZGF0YVtvZnMzXSA+Pj4gMCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeDEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhICYgMHgwMDAwRkZGRikgKyBjYXJyeTtcbiAgICB2YXIgeDIgPSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgPj4+IDE2KTtcbiAgICBjYXJyeSA9IE1hdGguZmxvb3IoeDIvNjU1MzYpO1xuICAgIHZhciB4MyA9IHgxICsgKHgyICUgNjU1MzYpICogNjU1MzY7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4MztcbiAgICBjYXJyeSArPSBNYXRoLmZsb29yKHgzLzQyOTQ5NjcyOTYpO1xuICB9XG5cbiAgaWYobGVuMiA8IGxlbjEgJiYgY2FycnkpIHtcbiAgICByZXR1cm4gYWRkX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgbmF0X29mX2FycmF5KFtjYXJyeV0pLCAwLCAxLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH1cbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1xuLy8gbGVuMSA+PSBsZW4yICsgbGVuMy5cbi8vUHJvdmlkZXM6IG11bHRfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X2RpZ2l0X25hdFxuZnVuY3Rpb24gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMywgbGVuMykge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMzsgaSsrKSB7XG4gICAgY2FycnkgKz0gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMStpLCBsZW4xLWksIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMraSk7XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBuYXQxID0gMiAqIG5hdDEgKyBuYXQyICogbmF0MlxuLy8gbGVuMSA+PSAyICogbGVuMlxuLy9Qcm92aWRlczogc3F1YXJlX25hdFxuLy9SZXF1aXJlczogbXVsdF9uYXQsIGFkZF9uYXRcbmZ1bmN0aW9uIHNxdWFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgY2FycnkgPSAwO1xuICBjYXJyeSArPSBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDEsIG9mczEsIGxlbjEsIDApO1xuICBjYXJyeSArPSBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKTtcbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfbGVmdF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIHZhciBhID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhIDw8IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPj4+ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy8gQXNzdW1pbmcgYyA+IGEsIHJldHVybnMgW3F1b3RpZW50LCByZW1haW5kZXJdIG9mIChhPDwzMiArIGIpL2Ncbi8vUHJvdmlkZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9oZWxwZXIoYSwgYiwgYykge1xuICB2YXIgeCA9IGEgKiA2NTUzNiArIChiPj4+MTYpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IoeC9jKSAqIDY1NTM2O1xuICB2YXIgeiA9ICh4ICUgYykgKiA2NTUzNjtcbiAgdmFyIHcgPSB6ICsgKGIgJiAweDAwMDBGRkZGKTtcbiAgcmV0dXJuIFt5ICsgTWF0aC5mbG9vcih3L2MpLCB3ICUgY107XG59XG5cbi8vIG5hdDFbb2ZzMStsZW5dIDwgbmF0MltvZnMyXVxuLy9Qcm92aWRlczogZGl2X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2RpZ2l0X25hdChuYXRxLCBvZnNxLCBuYXRyLCBvZnNyLCBuYXQxLCBvZnMxLCBsZW4sIG5hdDIsIG9mczIpIHtcbiAgdmFyIHJlbSA9IChuYXQxLmRhdGFbb2ZzMStsZW4tMV0gPj4+MCk7XG4gIC8vIG5hdHFbb2ZzcStsZW4tMV0gaXMgZ3VhcmFudGVlZCB0byBiZSB6ZXJvIChkdWUgdG8gdGhlIE1TRCByZXF1aXJlbWVudCksXG4gIC8vIGFuZCBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8uXG4gIGZvcih2YXIgaSA9IGxlbi0yOyBpID49IDA7IGktLSkge1xuICAgIHZhciB4ID0gZGl2X2hlbHBlcihyZW0sIChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQyLmRhdGFbb2ZzMl0gPj4+IDApKTtcbiAgICBuYXRxLmRhdGFbb2ZzcStpXSA9IHhbMF07XG4gICAgcmVtID0geFsxXTtcbiAgfVxuICBuYXRyLmRhdGFbb2Zzcl0gPSByZW07XG4gIHJldHVybiAwO1xufVxuXG4vLyBuYXQxW25hdDI6XSA6PSBuYXQxIC8gbmF0MlxuLy8gbmF0MVs6bmF0Ml0gOj0gbmF0MSAlIG5hdDJcbi8vIGxlbjEgPiBsZW4yLCBuYXQyW29mczIrbGVuMi0xXSA+IG5hdDFbb2ZzMStsZW4xLTFdXG4vL1Byb3ZpZGVzOiBkaXZfbmF0XG4vL1JlcXVpcmVzOiBkaXZfZGlnaXRfbmF0LCBkaXZfaGVscGVyLCBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQsIHNoaWZ0X2xlZnRfbmF0LCBzaGlmdF9yaWdodF9uYXQsIGNyZWF0ZV9uYXQsIHNldF90b196ZXJvX25hdCwgbXVsdF9kaWdpdF9uYXQsIHN1Yl9uYXQsIGNvbXBhcmVfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIGRpdl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICBpZihsZW4yID09IDEpIHtcbiAgICBkaXZfZGlnaXRfbmF0KG5hdDEsIG9mczErMSwgbmF0MSwgb2ZzMSwgbmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcyA9IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQyLCBvZnMyK2xlbjItMSk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuXG4gIHZhciBkID0gKG5hdDIuZGF0YVtvZnMyK2xlbjItMV0gPj4+IDApICsgMTtcbiAgdmFyIGEgPSBjcmVhdGVfbmF0KGxlbjIrMSk7XG4gIGZvciAodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSBsZW4yOyBpLS0pIHtcbiAgICAvLyBEZWNlbnQgbG93ZXIgYm91bmQgb24gcXVvXG4gICAgdmFyIHF1byA9IGQgPT0gNDI5NDk2NzI5NiA/IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgOiBkaXZfaGVscGVyKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQxLmRhdGFbb2ZzMStpLTFdID4+PjApLCBkKVswXTtcbiAgICBzZXRfdG9femVyb19uYXQoYSwgMCwgbGVuMisxKTtcbiAgICBtdWx0X2RpZ2l0X25hdChhLCAwLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbcXVvXSksIDApO1xuICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgYSwgMCwgbGVuMisxLCAxKTtcblxuICAgIHdoaWxlIChuYXQxLmRhdGFbb2ZzMStpXSAhPSAwIHx8IGNvbXBhcmVfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKSA+PSAwKSB7XG4gICAgICBxdW8gPSBxdW8gKyAxO1xuICAgICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCAxKTtcbiAgICB9XG5cbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHF1bztcbiAgfVxuXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHNoaWZ0IHJlbWFpbmRlclxuICBzaGlmdF9yaWdodF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyByZXN0b3JlXG4gIHJldHVybiAwO1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfcmlnaHRfbmF0XG5mdW5jdGlvbiBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSBsZW4xLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSBuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMDtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhID4+PiBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhIDw8ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPiBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAxO1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPCBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0XG4vL1JlcXVpcmVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgYSA9IG51bV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIGxlbjEpO1xuICB2YXIgYiA9IG51bV9kaWdpdHNfbmF0KG5hdDIsIG9mczIsIGxlbjIpO1xuICBpZihhID4gYikgcmV0dXJuIDE7XG4gIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gIGZvcih2YXIgaSA9IGxlbjEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApID4gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIDE7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPCAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0X3JlYWxcbi8vUmVxdWlyZXM6IGNvbXBhcmVfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdF9yZWFsKG5hdDEsbmF0Mil7XG4gIHJldHVybiBjb21wYXJlX25hdChuYXQxLDAsbmF0MS5kYXRhLmxlbmd0aCxuYXQyLDAsbmF0Mi5kYXRhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGxhbmRfZGlnaXRfbmF0XG5mdW5jdGlvbiBsYW5kX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSAmPSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBsb3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBsb3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIHw9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGx4b3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBseG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSBePSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IHNlcmlhbGl6ZV9uYXRcbmZ1bmN0aW9uIHNlcmlhbGl6ZV9uYXQod3JpdGVyLCBuYXQsIHN6KXtcbiAgdmFyIGxlbiA9IG5hdC5kYXRhLmxlbmd0aDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIHdyaXRlci53cml0ZSgzMiwgbmF0LmRhdGFbaV0pO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgc3pbMV0gPSBsZW4gKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBkZXNlcmlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZV9uYXQocmVhZGVyLCBzeil7XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIgbmF0ID0gbmV3IE1sTmF0KGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgbmF0LmRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgcmV0dXJuIG5hdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBIdWdvIEhldXphcmRcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVcbnZhciBjYW1sX2dyX3N0YXRlO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmKGNhbWxfZ3Jfc3RhdGUpIHtcbiAgICByZXR1cm4gY2FtbF9ncl9zdGF0ZTtcbiAgfVxuICB0aHJvdyBbMCxjYW1sX25hbWVkX3ZhbHVlKFwiR3JhcGhpY3MuR3JhcGhpY19mYWlsdXJlXCIpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiTm90IGluaXRpYWxpemVkXCIpXVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZT1jdHg7XG4gIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKXtcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpe1xuICAgIHZhciByZXMgPSBpbmZvLm1hdGNoKFwiKF58LCkgKlwiK25hbWUrXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZighKGluZm89PVwiXCIpKSBzcGVjcy5wdXNoKGluZm8pO1xuICB2YXIgdGFyZ2V0ID0gZ2V0KFwidGFyZ2V0XCIpO1xuICBpZighdGFyZ2V0KSB0YXJnZXQ9XCJcIjtcbiAgdmFyIHN0YXR1cyA9IGdldChcInN0YXR1c1wiKTtcbiAgaWYoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpXG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHc/cGFyc2VJbnQodyk6MjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIrdyk7XG5cbiAgdmFyIGggPSBnZXQoXCJoZWlnaHRcIik7XG4gIGggPSBoP3BhcnNlSW50KGgpOjIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIitoKTtcblxuICB2YXIgd2luID0gZ2xvYmFsVGhpcy5vcGVuKFwiYWJvdXQ6YmxhbmtcIix0YXJnZXQsc3BlY3Muam9pbihcIixcIikpO1xuICBpZighd2luKSB7Y2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIil9XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG4gIHZhciBjdHggPSBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpe1xuICBjYW1sX2dyX21vdmV0byhjYW1sX2dyX3N0YXRlLngsY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCl7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhcyA6IGNhbnZhcyxcbiAgICB4IDogMCxcbiAgICB5IDogMCxcbiAgICB3aWR0aCA6IHcsXG4gICAgaGVpZ2h0IDogaCxcbiAgICBsaW5lX3dpZHRoIDogMSxcbiAgICBmb250IDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImZpeGVkXCIpLFxuICAgIHRleHRfc2l6ZSA6IDI2LFxuICAgIGNvbG9yIDogMHgwMDAwMDAsXG4gICAgdGl0bGUgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZihzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2VfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihzLnNldF90aXRsZSkgcy5zZXRfdGl0bGUoanNuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyh3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KClcbiAgcy53aWR0aCA9IHc7XG4gIHMuaGVpZ2h0ID0gaDtcbiAgcy5jYW52YXMud2lkdGggPSB3O1xuICBzLmNhbnZhcy5oZWlnaHQgPSBoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbGVhcl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xlYXJfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmhlaWdodDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSAnJyArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSAnMCcgKyBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXJcbiAgciA9IChjb2xvciA+PiAxNikgJiAweGZmLFxuICBnID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsXG4gIGIgPSAoY29sb3IgPj4gMCkgICYgMHhmZjtcbiAgcy5jb2xvcj1jb2xvcjtcbiAgdmFyIGNfc3RyID0gJyMnICsgY29udmVydChyKSArIGNvbnZlcnQoZykgKyBjb252ZXJ0KGIpO1xuICBzLmNvbnRleHQuZmlsbFN0eWxlID0gICBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICBkWzBdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7IC8vclxuICBkWzFdID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsIC8vZ1xuICBkWzJdID0gKGNvbG9yID4+IDApICAmIDB4ZmY7IC8vYlxuICBkWzNdID0gMHhGRjsgLy9hXG4gIHMueD14O1xuICBzLnk9eTtcbiAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbSx4LHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSB5LDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgcmV0dXJuIChkWzBdIDw8IDE2KSArIChkWzFdIDw8IDgpICsgZFsyXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbW92ZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tb3ZldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueFxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8ocy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsY3gsY3kscnkscngsYTEsYTIpe1xuICB3aGlsZShhMT5hMikgYTIrPTM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLHhQb3MseVBvcyx4UG9zX3ByZXYseVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCtyeSkvMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKGEyIC0gYTEpICogTWF0aC5QSSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGo9MDtqPD1udW07aisrKXtcbiAgICB4UG9zID0gY3ggLSAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9IGN5ICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB5UG9zID0geVBvcy50b0ZpeGVkKDIpO1xuICAgIGlmIChqPT0wKSB7XG4gICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgIH0gZWxzZSBpZiAoeFBvc19wcmV2IT14UG9zIHx8IHlQb3NfcHJldiE9eVBvcyl7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXY9eFBvcztcbiAgICB5UG9zX3ByZXY9eVBvcztcbiAgICBpLT0gZGVsdGE7Ly9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodyl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5saW5lX3dpZHRoID0gdztcbiAgcy5jb250ZXh0LmxpbmVXaWR0aCA9IHdcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0scy5oZWlnaHQgLSBhcltpXVsyXSk7XG4gIHMuY29udGV4dC5saW5lVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0cixzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpe1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzdHIpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfZm9udChmKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgdyA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0eHQpKS53aWR0aDtcbiAgcmV0dXJuIFswLHcscy50ZXh0X3NpemVdO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbWFrZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbWFrZV9pbWFnZShhcnIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDEgO1xuICB2YXIgdyA9IGFyclsxXS5sZW5ndGggLSAxO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XG4gIGZvcih2YXIgaT0wO2k8aDtpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8dztqKyspe1xuICAgICAgdmFyIGMgPSBhcnJbaSsxXVtqKzFdO1xuICAgICAgdmFyIG8gPSBpKih3KjQpICsgKGogKiA0KTtcbiAgICAgIGlmKGMgPT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSBjID4+IDE2ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSBjID4+ICA4ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSBjID4+ICAwICYgMFhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHVtcF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHVtcF9pbWFnZShpbSl7XG4gIHZhciBkYXRhID0gWzBdXG4gIGZvcih2YXIgaT0wOyBpPGltLmhlaWdodDtpKyspe1xuICAgIGRhdGFbaSsxXSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPGltLndpZHRoO2orKyl7XG4gICAgICB2YXIgbyA9IGkqKGltLndpZHRoKjQpICsgKGogKiA0KSxcbiAgICAgICAgICByID0gaW0uZGF0YVtvKzBdLFxuICAgICAgICAgIGcgPSBpbS5kYXRhW28rMV0sXG4gICAgICAgICAgYiA9IGltLmRhdGFbbysyXTtcbiAgICAgIGRhdGFbaSsxXVtqKzFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiXG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBpZighaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwwLDApO1xuICAgIHZhciBpbWFnZSA9IG5ldyBnbG9iYWxUaGlzLkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICB2YXIgX21hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgdmFyIF9ibG9ja19sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAoKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgY2FzZSAweDE4OiAvL2NzdC5DT0RFX0NVU1RPTV9MRU46XG4gICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgdmFyIGMsIHMgPSBcIlwiO1xuICAgICAgICAgIHdoaWxlICgoYyA9IHJlYWRlci5yZWFkOHUgKCkpICE9IDApIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRfc2l6ZTtcbiAgICAgICAgICBpZighb3BzKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxOTogLy8gY3N0LkNPREVfQ1VTVE9NX0ZJWEVEXG4gICAgICAgICAgICBpZighb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICByZWFkZXIucmVhZDMycygpOyByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgdmFyIHYgPSBvcHMuZGVzZXJpYWxpemUocmVhZGVyLCBzaXplKTtcbiAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHNpemVbMF0pXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMikgPDwgOCkgfFxuICAgICAgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgfVxuICBpZiAoZ2V0MzIocywgb2ZzKSAhPSAoMHg4NDk1QTZCRXwwKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gIHJldHVybiAoZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE9iamVjdFRhYmxlXG52YXIgTWxPYmplY3RUYWJsZTtcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9pc19jb250aW51YXRpb25fdGFnXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBjb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodlswXSkpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19mZHNcbnZhciBjYW1sX3N5c19mZHMgPSBuZXcgQXJyYXkoMyk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZSkgZmlsZS5jbG9zZSgpO1xuICBkZWxldGUgY2FtbF9zeXNfZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSxpZHgpIHtcbiAgaWYoaWR4ID09IHVuZGVmaW5lZCl7XG4gICAgaWR4ID0gY2FtbF9zeXNfZmRzLmxlbmd0aDtcbiAgfVxuICBjYW1sX3N5c19mZHNbaWR4XSA9IGZpbGU7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuIChuYW1lLCBmbGFncywgX3Blcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlKGZsYWdzKXtcbiAgICBzd2l0Y2goZmxhZ3NbMV0pe1xuICAgIGNhc2UgMDogZi5yZG9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMTogZi53cm9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMjogZi5hcHBlbmQgPSAxO2JyZWFrO1xuICAgIGNhc2UgMzogZi5jcmVhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNDogZi50cnVuY2F0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA1OiBmLmV4Y2wgPSAxOyBicmVhaztcbiAgICBjYXNlIDY6IGYuYmluYXJ5ID0gMTticmVhaztcbiAgICBjYXNlIDc6IGYudGV4dCA9IDE7YnJlYWs7XG4gICAgY2FzZSA4OiBmLm5vbmJsb2NrID0gMTticmVhaztcbiAgICB9XG4gICAgZmxhZ3M9ZmxhZ3NbMl07XG4gIH1cbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoZmlsZSwgdW5kZWZpbmVkKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGZpbGUoZmQsIGZsYWdzKSB7XG4gICAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG5ldyBNbEZha2VGZF9vdXQoZmQsIGZsYWdzKVxuICB9XG4gIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSgwLHtyZG9ubHk6MSxhbHRuYW1lOlwiL2Rldi9zdGRpblwiLGlzQ2hhcmFjdGVyRGV2aWNlOnRydWV9KSwgMCk7XG4gIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSgxLHtidWZmZXJlZDoyLHdyb25seToxLGlzQ2hhcmFjdGVyRGV2aWNlOnRydWV9KSwgMSk7XG4gIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSgyLHtidWZmZXJlZDoyLHdyb25seToxLGlzQ2hhcmFjdGVyRGV2aWNlOnRydWV9KSwgMik7XG59KSgpXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoY2hhbmlkLCBuYW1lKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGJ1ZmZlcmVkID0gKGZpbGUuZmxhZ3MuYnVmZmVyZWQgIT09IHVuZGVmaW5lZCkgPyBmaWxlLmZsYWdzLmJ1ZmZlcmVkIDogMTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyX2N1cnI6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIGJ1ZmZlcmVkOmJ1ZmZlcmVkXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICBidWZmZXJfY3VycjowLFxuICAgIGJ1ZmZlcl9tYXg6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIHJlZmlsbDpyZWZpbGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuLy9BbGlhczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLmZpbGUuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2hhbi5vdXRwdXQgPSAoZnVuY3Rpb24gKHMpIHtmKHMpfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWZpbGwgKGNoYW4pIHtcbiAgaWYoY2hhbi5yZWZpbGwgIT0gbnVsbCl7XG4gICAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gICAgdmFyIHN0cl9hID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyX2EubGVuZ3RoID09IDApIHtcbiAgICAgIGNoYW4ucmVmaWxsID0gbnVsbFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyLmxlbmd0aCA8IGNoYW4uYnVmZmVyX21heCArIHN0cl9hLmxlbmd0aCl7XG4gICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKTtcbiAgICAgICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgICAgICBjaGFuLmJ1ZmZlciA9IGI7XG4gICAgICB9XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoc3RyX2EsY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIGNoYW4ub2Zmc2V0ICs9IHN0cl9hLmxlbmd0aDtcbiAgICAgIGNoYW4uYnVmZmVyX21heCArPSBzdHJfYS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBucmVhZCA9IGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgY2hhbi5idWZmZXJfbWF4LCBjaGFuLmJ1ZmZlci5sZW5ndGggLSBjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgIGNoYW4ub2Zmc2V0ICs9IG5yZWFkO1xuICAgIGNoYW4uYnVmZmVyX21heCArPSBucmVhZDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9yZWZpbGwsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfYmxvY2sgKGNoYW5pZCwgYmEsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBuID0gbDtcbiAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgaWYobCA8PSBhdmFpbCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBsKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBsO1xuICB9XG4gIGVsc2UgaWYoYXZhaWwgPiAwKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIGF2YWlsKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBhdmFpbDtcbiAgICBuID0gYXZhaWw7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICB2YXIgYXZhaWwgPSBjaGFuLmJ1ZmZlcl9tYXggLSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgIGlmKG4gPiBhdmFpbCkgbiA9IGF2YWlsO1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBuKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBuO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JlZmlsbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICBmdW5jdGlvbiBibG9jayhidWZmZXIsIG9mZnNldCwgbikge1xuICAgIHZhciByID0gMDtcbiAgICB3aGlsZShyIDwgbil7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCl7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgICAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICAgICAgYnJlYWs7XG4gICAgICBidWZmZXJbb2Zmc2V0K3JdID0gY2hhbi5idWZmZXJbY2hhbi5idWZmZXJfY3Vycl07XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyKys7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHZhciByID0gYmxvY2soaGVhZGVyLCAwLCAyMCk7XG4gIGlmKHIgPT0gMClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIGVsc2UgaWYgKHIgPCAyMClcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3RcIik7XG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChjYW1sX2J5dGVzX29mX2FycmF5KGhlYWRlciksIDApO1xuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuICsgMjApO1xuICBidWYuc2V0KGhlYWRlciwwKTtcbiAgdmFyIHIgPSBibG9jayhidWYsIDIwLCBsZW4pXG4gIGlmKHIgPCBsZW4pXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0IFwiICsgciArIFwiICBcIiArIGxlbik7XG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcFxuLy9SZXF1aXJlczogY2FtbF9pbnB1dF92YWx1ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAoYykge1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZShjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICB9XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgY2hhbi5idWZmZXJfY3VycisrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9jaGFyLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgcmVzID0gKHJlcyA8PCA4KSArIGNhbWxfbWxfaW5wdXRfY2hhcihjaGFuaWQpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc2Vla19pbihjaGFuaWQsIHBvcykge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBpZihwb3MgPj0gY2hhbi5vZmZzZXQgLSBjaGFuLmJ1ZmZlcl9tYXhcbiAgICAgJiYgcG9zIDw9IGNoYW4ub2Zmc2V0XG4gICAgICYmIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkpIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gY2hhbi5idWZmZXJfbWF4IC0gKGNoYW4ub2Zmc2V0IC0gcG9zKTtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLm9mZnNldCA9IHBvcztcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19pblxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCxwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19pblxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgcG9zID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfcG9zX2luKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4ub2Zmc2V0IC0gKGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX2luXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9wb3NfaW4oY2hhbmlkKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBwID0gY2hhbi5idWZmZXJfY3VycjtcbiAgZG8ge1xuICAgIGlmKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID4gMCkge1xuICAgICAgICBjaGFuLmJ1ZmZlci5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VyciksMCk7XG4gICAgICAgIHAgLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4IC09IGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgfVxuICAgICAgaWYoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZfbWF4ID0gY2hhbi5idWZmZXJfbWF4O1xuICAgICAgY2FtbF9yZWZpbGwgKGNoYW4pO1xuICAgICAgaWYocHJldl9tYXggPT0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICAgIHJldHVybiAtKGNoYW4uYnVmZmVyX21heCk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChjaGFuLmJ1ZmZlcltwKytdICE9IDEwKTtcbiAgcmV0dXJuIHAgLSBjaGFuLmJ1ZmZlcl9jdXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlcl9jdXJyID09IDApIHJldHVybiAwO1xuICBpZihjaGFuLm91dHB1dCkge1xuICAgIGNoYW4ub3V0cHV0KGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3VycikpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgY2hhbi5idWZmZXIsIDAsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICB9XG4gIGNoYW4ub2Zmc2V0ICs9IGNoYW4uYnVmZmVyX2N1cnI7XG4gIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgaWYoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGggPiBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgY2hhbi5idWZmZXIgPSBiXG4gIH1cbiAgc3dpdGNoKGNoYW4uYnVmZmVyZWQpe1xuICBjYXNlIDA6IC8vIFVuYnVmZmVyZWRcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVha1xuICBjYXNlIDE6IC8vIEJ1ZmZlcmVkICh0aGUgZGVmYXVsdClcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8vIEJ1ZmZlcmVkIChvbmx5IGZvciBzdGRvdXQgYW5kIHN0ZGVycilcbiAgICB2YXIgaWQgPSBidWZmZXIubGFzdEluZGV4T2YoMTApXG4gICAgaWYoaWQgPCAwKSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgaWQgKyAxKSwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGlkICsgMTtcbiAgICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoIC0gaWQgLSAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgKyBjaGFuLmJ1ZmZlcl9jdXJyXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5idWZmZXJlZCA/IDEgOiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjaGFuaWQsdikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0uYnVmZmVyZWQgPSB2O1xuICBpZighdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2ModHJ1ZSk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlXG52YXIgYWxsX2ZpbmFsaXplcnMgPSBuZXcgZ2xvYmFsVGhpcy5TZXQoKVxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoY2IsIGEpIHtcbiAgaWYoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIHggPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoeCl7YWxsX2ZpbmFsaXplcnMuZGVsZXRlKHgpOyBjYigwKTsgcmV0dXJuO30pO1xuICAgIHgucmVnaXN0ZXIoYSx4KTtcbiAgICBhbGxfZmluYWxpemVycy5hZGQoeCk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3Jlc3VtZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3Jfc2xpY2VcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3Jfc2xpY2Uod29yaykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2J1Y2tldFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfYnVja2V0KG4pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikgeyByZXR1cm4gMDsgfVxuIiwiLy8vLy8vLy8vIENPUkVcblxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfaW50X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxudmFyIGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG4vL1Byb3ZpZGVzOiBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG5cbi8vUHJvdmlkZXM6IGNvcmVfdGltZV9uc19mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNvcmVfdGltZV9uc19mb3JtYXQodGltZSxmb3JtYXQpe1xuICB2YXIgZCA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgdmFyIGZvcm1hdGpzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmb3JtYXQpO1xuICB2YXIganN0cmluZyA9IGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lKGZvcm1hdGpzLCBkKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanN0cmluZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfY29tcGFjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfZ2NfY29tcGFjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX2hlYXBfY2h1bmtzXG5mdW5jdGlvbiBjb3JlX2djX2hlYXBfY2h1bmtzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX2hlYXBfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX21ham9yX2NvbGxlY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX3BsdXNfbWlub3Jfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX21ham9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19taW5vcl9jb2xsZWN0aW9uc1xuZnVuY3Rpb24gY29yZV9nY19taW5vcl9jb2xsZWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfZ2NfbWlub3Jfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX3Byb21vdGVkX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX3Byb21vdGVkX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY190b3BfaGVhcF93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY190b3BfaGVhcF93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfcnVuX21lbXByb2ZfY2FsbGJhY2tzXG5mdW5jdGlvbiBjb3JlX2djX3J1bl9tZW1wcm9mX2NhbGxiYWNrcyAoKSB7IHJldHVybiAwIH1cblxuLy9Qcm92aWRlczogY29yZV9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2tcbmZ1bmN0aW9uIGNvcmVfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrKHgpe1xuICByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb3JlX21kNV9mZFxuLy9SZXF1aXJlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4sIGNhbWxfbWQ1X2NoYW4sIGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuZnVuY3Rpb24gY29yZV9tZDVfZmQoZmQpe1xuICAgIHZhciBpYyA9IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luKGZkKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FtbF9tZDVfY2hhbihpYywgLTEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNhbWxfbWxfY2xvc2VfY2hhbm5lbChpYyk7XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjb3JlX21kNV9kaWdlc3Rfc3ViYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfYmxpdF9zdHJpbmcsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YiwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmcoYnVmLCBvZnMsIGxlbiwgcmVzKXtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViKGJ1Ziwgb2ZzLCBieXRlcywgMCwgbGVuKTtcbiAgICB2YXIgcmVzMiA9IGNhbWxfbWQ1X3N0cmluZyhjYW1sX3N0cmluZ19vZl9ieXRlcyhieXRlcyksIDAsIGxlbik7XG4gICAgY2FtbF9ibGl0X3N0cmluZyhyZXMyLCAwLCByZXMsIDAsIDE2KTtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9CaWdzdHJpbmdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBiaWdzdHJpbmdfZGVzdHJveV9zdHViKHZfYnN0cikge1xuICBpZiAodl9ic3RyLmhhc093blByb3BlcnR5KCdfX2lzX2RlYWxsb2NhdGVkJykpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfZGVzdHJveTogYmlnc3RyaW5nIGlzIGFscmVhZHkgZGVhbGxvY2F0ZWRcIik7XG4gIH1cbiAgLy8gTXV0YXRlIHRoZSBvcmlnaW5hbCBiaWdzdHJpbmcgaW4tcGxhY2UsIHRvIHNpbXVsYXRlIHdoYXQgdGhlIEMgdmVyc2lvbiBkb2VzXG4gIHZfYnN0ci5fX2lzX2RlYWxsb2NhdGVkID0gdHJ1ZTtcbiAgdl9ic3RyLmRhdGEgPSBuZXcgdl9ic3RyLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKDApO1xuICB2X2JzdHIuZGltcyA9IFsgMCBdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3JlYWxsb2Ncbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG5mdW5jdGlvbiBiaWdzdHJpbmdfcmVhbGxvYyhiaWdzdHJpbmcsIHNpemUpIHtcbiAgICBpZiAoYmlnc3RyaW5nLmhhc093blByb3BlcnR5KCdfX2lzX2RlYWxsb2NhdGVkJykpIHtcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX3JlYWxsb2M6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBuZXdfZGF0YSA9IG5ldyBiaWdzdHJpbmcuZGF0YS5fX3Byb3RvX18uY29uc3RydWN0b3Ioc2l6ZSk7XG4gICAgbmV3X2RhdGEuc2V0KGJpZ3N0cmluZy5kYXRhLnNsaWNlKDAsIHNpemUpKTtcbiAgICB2YXIgbmV3X2JpZ3N0cmluZyA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiaWdzdHJpbmcua2luZCwgYmlnc3RyaW5nLmxheW91dCwgW3NpemVdLCBuZXdfZGF0YSk7XG4gICAgYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YihiaWdzdHJpbmcpO1xuXG4gICAgcmV0dXJuIG5ld19iaWdzdHJpbmc7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IFVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBVaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZDtcbiAgaWYgICAgICAodGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZihjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodGFnX2EpKSB7XG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKHNyYyxzcmNfb2ZmLGRzdCxkc3Rfb2ZmLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXMoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmcoYmExLCBiYTFfb2ZmLCBiYTIsIGJhMl9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBjYW1sX2ludF9jb21wYXJlKGNhbWxfYmFfZ2V0XzEoYmExLCBiYTFfb2ZmICsgaSksIGNhbWxfYmFfZ2V0XzEoYmEyLCBiYTJfb2ZmICsgaSkpO1xuICAgIGlmIChjICE9IDApIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmcoYmEsIGJhX29mZiwgc3RyLCBzdHJfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gY2FtbF9pbnRfY29tcGFyZShjYW1sX2JhX2dldF8xKGJhLCBiYV9vZmYgKyBpKSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzdHIsIHN0cl9vZmYgKyBpKSk7XG4gICAgaWYgKGMgIT0gMCkgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfbWVtY2hyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jaHIoYmEsIGJhX29mZiwgY2hyLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYW1sX2JhX2dldF8xKGJhLCBiYV9vZmYgKyBpKSA9PSBjaHIpIHtcbiAgICAgIHJldHVybiAoYmFfb2ZmICsgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlciwgYmEuYnl0ZU9mZnNldCwgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19tZW1jbXBcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX21lbWNtcChzMSwgcG9zMSwgczIsIHBvczIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEscG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMixwb3MyICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKGJhMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsb2ZzMStsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UscG9zMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKGJhMSwgcG9zMSwgYnl0ZXMyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19hbGxvYyhfLHNpemUpe1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGUoMTIsIDAsIFswLHNpemVdKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1YlxuZnVuY3Rpb24gYmlnc3RyaW5nX2lzX21tYXBwZWRfc3R1Yih4KXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X3N0dWIoczEsIGkxLCBzMiwgaTIsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKHMxLGkxLHMyLGkyLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YihzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViKHNyYywgc3JjX3BvcywgZHN0LCBkc3RfcG9zLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWIoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtc2V0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tZW1zZXRfc3R1YihiaWdzdHJpbmcsIHZfcG9zLCB2X2xlbiwgdl9jaGFyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIGNhbWxfYmFfc2V0XzEoYmlnc3RyaW5nLCB2X3BvcyArIGksIHZfY2hhcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtY21wX3N0dWIodl9zMSwgdl9zMV9wb3MsIHZfczIsIHZfczJfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMSh2X3MxLHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHZfczIsdl9zMl9wb3MgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtY21wX2J5dGVzX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtY21wX2J5dGVzX3N0dWIodl9zMSwgdl9zMV9wb3MsIHZfczIsIHZfczJfcG9zLCB2X2xlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEodl9zMSwgdl9zMV9wb3MgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYnl0ZXNfZ2V0KHZfczIsIHZfczJfcG9zICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbnRlcm5hbGhhc2hfZm9sZF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG52YXIgaW50ZXJuYWxoYXNoX2ZvbGRfYmlnc3RyaW5nID0gY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2ZpbmRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19maW5kKGJzLCBjaHIsIHBvcywgbGVuKXtcbiAgd2hpbGUobGVuID4gMCl7XG4gICAgaWYoY2FtbF9iYV9nZXRfMShicyxwb3MpID09IGNocikgcmV0dXJuIHBvcztcbiAgICBwb3MrKztcbiAgICBsZW4tLTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFswXSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gICAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoLCBjYW1sX2NhbGxfZ2VuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfZnJlc2hfb29faWQsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfY2FsbGJhY2soZixhcmdzKSB7XG4gIGZ1bmN0aW9uIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyKGVmZixrLG1zKSB7XG4gICAgLy8gUmVzdW1lcyB0aGUgY29udGludWF0aW9uIGsgYnkgcmFpc2luZyBleGNlcHRpb24gVW5oYW5kbGVkLlxuICAgIGNhbWxfcmVzdW1lX3N0YWNrKGtbMV0sbXMpO1xuICAgIHZhciBleG4gPSBjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LlVuaGFuZGxlZFwiKTtcbiAgICBpZihleG4pIGNhbWxfcmFpc2Vfd2l0aF9hcmcoZXhuLCBlZmYpO1xuICAgIGVsc2Uge1xuICAgICAgZXhuID0gWzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSwgY2FtbF9mcmVzaF9vb19pZCgwKV07XG4gICAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGV4bik7XG4gICAgfVxuICB9XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFjaztcbiAgdmFyIHNhdmVkX2ZpYmVyX3N0YWNrID0gY2FtbF9maWJlcl9zdGFjaztcbiAgdHJ5IHtcbiAgICBjYW1sX2V4bl9zdGFjayA9IDA7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpbMCwgMCwgMCwgdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXJdLCByOntrOjAsIHg6MCwgZTowfX07XG4gICAgdmFyIHJlcyA9IHtqb29fdHJhbXA6IGYsXG4gICAgICAgICAgICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpe3JldHVybiB4O30pfTtcbiAgICBkbyB7XG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYW1sX2NhbGxfZ2VuKHJlcy5qb29fdHJhbXAsIHJlcy5qb29fYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIEhhbmRsZSBleGNlcHRpb24gY29taW5nIGZyb20gSmF2YVNjcmlwdCBvciBmcm9tIHRoZSBydW50aW1lLiAqL1xuICAgICAgICBpZiAoIWNhbWxfZXhuX3N0YWNrLmxlbmd0aCkgdGhyb3cgZTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgICAgICAgY2FtbF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFja1syXTtcbiAgICAgICAgcmVzID0ge2pvb190cmFtcDogaGFuZGxlcixcbiAgICAgICAgICAgICAgIGpvb19hcmdzOiBbY2FtbF93cmFwX2V4Y2VwdGlvbihlKV19O1xuICAgICAgfVxuICAgIH0gd2hpbGUocmVzICYmIHJlcy5qb29fYXJncylcbiAgfSBmaW5hbGx5IHtcbiAgICBjYW1sX3N0YWNrX2RlcHRoID0gc2F2ZWRfc3RhY2tfZGVwdGg7XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzYXZlZF9leG5fc3RhY2s7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9IHNhdmVkX2ZpYmVyX3N0YWNrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmcodW5pdCl7XG4gIHJldHVybiBGTEFHKFwidXNlLWpzLXN0cmluZ1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHModW5pdCl7XG4gIHJldHVybiBGTEFHKFwiZWZmZWN0c1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYgKEZMQUcoXCJleGN3cmFwXCIpKSB7XG4gICAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICAgIGlmKGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gICAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICAgIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gICAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICAgIGlmKGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAgIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICAgIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xuICB9IGVsc2VcbiAgICByZXR1cm4gZTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsYXJncyk7XG4gICAgcmV0dXJuIChyZXMgaW5zdGFuY2VvZiBGdW5jdGlvbik/Y2FtbF9qc193cmFwX2NhbGxiYWNrKHJlcyk6cmVzO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikgLSAxO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiAhZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIHJldHVybiBmLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgLy8gRnVuY3Rpb25zIGhhdmUgYW4gYWRkaXRpb25hbCBjb250aW51YXRpb24gcGFyYW1ldGVyLiBUaGlzIHNob3VsZFxuICAvLyBub3QgYmUgdmlzaWJsZSB3aGVuIGNhbGxpbmcgdGhlbSBmcm9tIEphdmFTY3JpcHRcbiAgcmV0dXJuIGYubGVuZ3RoIC0gMVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQob2JqKTtcbiAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBjb250ZW50LCBsID0gYi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IGNvbnRlbnQsIGwgPSBhLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNvbnRlbnQpXG4gIGVsc2UgLyogQVJSQVkgKi9cbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19oYXNoKGgsIHYpe1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQgPSBjYW1sX2hhc2hfbWl4X2ludDY0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQgPSBjYW1sX2hhc2hfbWl4X2ludDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0ID0gY2FtbF9oYXNoX21peF9mbG9hdDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nID0gY2FtbF9oYXNoX21peF9zdHJpbmc7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9maW5hbFxuZnVuY3Rpb24gQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWUoc2VlZCkge1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoc2VlZCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cblxuICBmdW5jdGlvbiBsb2coeCkge1xuICAgIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4ICsgXCJcXG5cIik7XG4gICAgY2FtbF9tbF9vdXRwdXQoMiwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuX25hbWUobmFtZXMsIG51bWJlcilcbiAge1xuICAgIHZhciBzdHIgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lcyk7XG4gICAgaWYgKHN0clswXSA9PSAnXFx4MDAnKVxuICAgICAgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFx4MDAnKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaylcbiAge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAodG9rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09IFwibnVtYmVyXCIpXG4gICAgICAgIGtpbmQgPSBcIlwiICsgdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHRva1sxXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICBraW5kID0gdG9rWzFdXG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgICAgICBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pXG4gICAgICBlbHNlXG4gICAgICAgIGtpbmQgPSBcIl9cIlxuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgbmV4dDpzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgcHJpbnRfdG9rZW4gKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICAgICAgbG9nKFwiUmVjb3ZlcmluZyBpbiBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhayBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgICAgbG9nKFwiTm8gbW9yZSBzdGF0ZXMgdG8gZGlzY2FyZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKVxuICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCxpLG9sZCxuKXtcbiAgaWYoeFtpKzFdID09IG9sZCkge1xuICAgIHhbaSsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoeCl7XG4gIHJldHVybiAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3Jhd19maWVsZChvLGkpIHsgcmV0dXJuIG9baSsxXSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF9yYXdfZmllbGQobyxpLHYpIHsgcmV0dXJuIG9baSsxXSA9IHYgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yZWFjaGFibGVfd29yZHNcbmZ1bmN0aW9uIGNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyhvKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2FkZF9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfb2JqX2FkZF9vZmZzZXQodixvZmZzZXQpIHtcbiAgY2FtbF9mYWlsd2l0aChcIk9iai5hZGRfb2Zmc2V0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3VwZGF0ZV90YWcoYixvLG4pIHtcbiAgICBpZihiWzBdPT1vKSB7IGJbMF0gPSBuOyByZXR1cm4gMSB9XG4gICAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nXG4vL1JlcXVpcmVzOiBjYW1sX29ial90YWcsIGNhbWxfb2JqX3VwZGF0ZV90YWcsIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlblxuZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nKG8pIHtcbiAgdmFyIHQgPSBjYW1sX29ial90YWcobyk7XG4gIGlmKHQgIT0gMjQ2ICYmIHQgIT0gMjUwICYmIHQgIT0gMjQ0KVxuICAgIHJldHVybiA0XG4gIGlmKGNhbWxfb2JqX3VwZGF0ZV90YWcobywgMjQ2LCAyNDQpKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmllbGQwID0gb1sxXTtcbiAgICB0ID0gb1swXVxuICAgIGlmKHQgPT0gMjQ0KSB7XG4gICAgICBpZihmaWVsZDAgPT0gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuKDApKVxuICAgICAgICByZXR1cm4gMVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMlxuICAgIH0gZWxzZSBpZiAodCA9PSAyNTApIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhc3NlcnQgdCA9IGxhenlfdGFnXG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkXG4vL1JlcXVpcmVzOiBjYW1sX29ial91cGRhdGVfdGFnXG4gIGZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZChvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywyNDQsMjUwKTtcbiAgcmV0dXJuIDA7IC8vIHVuaXRcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eVxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenkobykge1xuICBjYW1sX29ial91cGRhdGVfdGFnKG8sMjQ0LDI0Nik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVhZF9yZXN1bHRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3JlYWRfcmVzdWx0KG8pIHtcbiAgcmV0dXJuIChjYW1sX29ial90YWcobykgPT0gMjUwKT9vWzFdOm87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246IDwgNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKHQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gKHQgPT0gMjQ1KSA/IDEgOiAwO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzXG52YXIgY2FtbF9kb21haW5fZGxzID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19zZXQoYSkge1xuICBjYW1sX2RvbWFpbl9kbHMgPSBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19nZXQodW5pdCkge1xuICByZXR1cm4gY2FtbF9kb21haW5fZGxzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2xvYWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2xvYWQocmVmKXtcbiAgcmV0dXJuIHJlZlsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG5mdW5jdGlvbiBjYW1sX2F0b21pY19jYXMocmVmLG8sbikge1xuICBpZihyZWZbMV0gPT09IG8pe1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZmV0Y2hfYWRkKHJlZiwgaSkge1xuICB2YXIgb2xkID0gcmVmWzFdO1xuICByZWZbMV0gKz0gaTtcbiAgcmV0dXJuIG9sZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2VcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2V4Y2hhbmdlKHJlZiwgdikge1xuICB2YXIgciA9IHJlZlsxXTtcbiAgcmVmWzFdID0gdjtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlblxudmFyIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl8gPSBbMF1cbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbih1bml0KSB7XG4gIHJldHVybiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fc2V0X25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX3NldF9uYW1lKF9uYW1lKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudFxuZnVuY3Rpb24gY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQodW5pdCkgeyByZXR1cm4gMSB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5faWRcbnZhciBjYW1sX2RvbWFpbl9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX3NwYXduXG4vL1JlcXVpcmVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZixtdXRleCl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIGNhbWxfY2FsbGJhY2soZixbMF0pO1xuICAgIGNhbWxfZG9tYWluX2lkID0gb2xkO1xuICAgIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKG11dGV4KTtcbiAgICByZXR1cm4gaWQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9pZCh1bml0KXtcbiAgICByZXR1cm4gY2FtbF9kb21haW5faWQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4XG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgodW5pdCl7XG4gICAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvcj9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGNvbnNvbGU7XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy9Qcm92aWRlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dFxudmFyIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXQgXG4vL1Byb3ZpZGVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3RkZXJyXG52YXIgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyclxuXG4vL1Byb3ZpZGVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYmVmb3JlX3Rlc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnIsIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRvdXRcbmZ1bmN0aW9uIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9iZWZvcmVfdGVzdCAodm91dHB1dCwgdnN0ZG91dCwgdnN0ZGVycil7XG4gIGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnIgPSBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdO1xuICBleHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2F2ZWRfc3Rkb3V0ID0gY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XTtcbiAgdmFyIG91dHB1dCA9IGNhbWxfbWxfY2hhbm5lbHNbdm91dHB1dF07XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF0gPSBvdXRwdXQ7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl0gPSBvdXRwdXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBleHBlY3RfdGVzdF9jb2xsZWN0b3JfYWZ0ZXJfdGVzdFxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZGVyciwgZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dFxuZnVuY3Rpb24gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX2FmdGVyX3Rlc3QgKHZzdGRvdXQsIHZzdGRlcnIpe1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdID0gZXhwZWN0X3Rlc3RfY29sbGVjdG9yX3NhdmVkX3N0ZG91dDtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXSA9IGV4cGVjdF90ZXN0X2NvbGxlY3Rvcl9zYXZlZF9zdGRlcnI7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfb3V0X2NoYW5uZWxfcG9zX2ZkXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX291dF9jaGFubmVsX3Bvc19mZChjaGFuKXtcbiAgdmFyIGluZm8gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5dO1xuICByZXR1cm4gaW5mby5vZmZzZXRcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2NoZWNrX2JvdW5kIChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4+PiAwID49IGFycmF5Lmxlbmd0aCAtIDEpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfdmVjdCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vLy8vLy8vLyBCSU5fUFJPVFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoYmlnc3RyaW5nLCBpKXtcbiAgaWYgKGkgPj4+IDAgPj0gYmlnc3RyaW5nLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfY2hlY2tfYm91bmQsIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViKHNyY19wb3MsIHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGNhbWxfY2hlY2tfYm91bmQoZHN0LGRzdF9wb3MpOyAvLyBmaXJzdCBwb3NcbiAgY2FtbF9jaGVja19ib3VuZChkc3QsZHN0X3BvcytsZW4tMSk7IC8vIGxhc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKHNyYywgc3JjX3Bvcyk7ICAvKiBmaXJzdCBwb3MgKi9cbiAgY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoc3JjLCBzcmNfcG9zICsgbGVuICogOCAtIDEpOyAvKiBsYXN0IHBvcyAqL1xuICB2YXIgdmlldyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDY0QXJyYXkobGVuKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHZpZXcuYnVmZmVyKTtcbiAgYnVmZmVyLnNldChzcmMuZGF0YS5zdWJhcnJheShzcmNfcG9zLCBzcmNfcG9zICsgKGxlbiAqIDgpKSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgLy8gWysgMV0gYmVjYXVzZSB0aGUgdGFnIGlzIGF0IHBvcyAwIFxuICAgIGRzdFtkc3RfcG9zK2krMV0gPSB2aWV3W2ldO1xuICB9XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViKHNyY19wb3MsIHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfZmxvYXRfYXJyYXlfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfY2hlY2tfYm91bmQsIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViKHNyY19wb3Msc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMCBcbiAgY2FtbF9jaGVja19ib3VuZCAoc3JjLCBzcmNfcG9zKTsgLy8gZmlyc3QgcG9zIFxuICBjYW1sX2NoZWNrX2JvdW5kIChzcmMsIHNyY19wb3MgKyBsZW4gLSAxKTsgLy8gbGFzdCBwb3NcbiAgY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoZHN0LCBkc3RfcG9zKTsgLyogZmlyc3QgcG9zICovXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGRzdCwgZHN0X3BvcyArIGxlbiAqIDggLSAxKTsgLyogbGFzdCBwb3MgKi9cbiAgLy8gWysgMV0gYmVjYXVzZSB0aGUgdGFnIGlzIGF0IHBvcyAwXG4gIHNyY19wb3MgPSBzcmNfcG9zICsgMVxuICB2YXIgZmxvYXQ2NCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDY0QXJyYXkoc3JjLnNsaWNlKHNyY19wb3Msc3JjX3BvcyArIGxlbikpO1xuICB2YXIgZmxvYXQ2NF91aW50OCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGZsb2F0NjQuYnVmZmVyKTtcbiAgdmFyIHZpZXcgPSBkc3QuZGF0YS5zdWJhcnJheShkc3RfcG9zLCBkc3RfcG9zICsgKGxlbiAqIDgpKTtcbiAgdmlldy5zZXQoZmxvYXQ2NF91aW50OCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfc3RyaW5nX2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLCBkc3QsIGRzdF9wb3MsbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLCBkc3QsIGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSwgYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgLy8gW2Jpbl9wcm90X2JsaXRfYnVmX3N0dWJdIGlzIHVzZWQgd2l0aCBtaXhlZCBiaWdhcnJheSBraW5kcy5cbiAgLy8gQ29udmVydGVyIGV2ZXJ5dGhpbmcgdG8gYmlnYXJyYXkgb2YgY2hhciBiZWZvcmUgdGhlIGJsaXQuXG4gIGlmKHNyYy5raW5kICE9IDEyKSAvLyAxMiBpcyB0aGUgY2hhciBraW5kXG4gICAgc3JjID0gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KHNyYy5kYXRhKTtcbiAgaWYoZHN0LmtpbmQgIT0gMTIpIC8vIDEyIGlzIHRoZSBjaGFyIGtpbmRcbiAgICBkc3QgPSBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoZHN0LmRhdGEpO1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCx0b3JlYWQpe1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0MDk2KTtcbiAgaWYodG9yZWFkIDwgMCl7XG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYocmVhZCA9PSAwKSBicmVhaztcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCxidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSh0b3JlYWQgPiAwKSB7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLCAodG9yZWFkID4gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5sZW5ndGggOiB0b3JlYWQpKTtcbiAgICAgIGlmKHJlYWQgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgICB0b3JlYWQgLT0gcmVhZFxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG52YXIgY2FtbF9NRDVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh3LCBidWZmZXIpIHtcbiAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gIH19KSgpXG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1SW5pdFxuZnVuY3Rpb24gY2FtbF9NRDVJbml0KCkge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY0KTtcbiAgdmFyIGIzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB2YXIgYjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4ge2xlbjowLFxuICAgICAgICAgIHc6bmV3IFVpbnQzMkFycmF5KFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XSksXG4gICAgICAgICAgYjMyOmIzMixcbiAgICAgICAgICBiODpiOH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVVcGRhdGVcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENVVwZGF0ZShjdHgsIGlucHV0LCBpbnB1dF9sZW4pe1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIHZhciBpbnB1dF9wb3MgPSAwO1xuICBjdHgubGVuICs9IGlucHV0X2xlbjtcbiAgaWYoaW5fYnVmKXtcbiAgICB2YXIgbWlzc2luZyA9IDY0IC0gaW5fYnVmO1xuICAgIGlmKGlucHV0X2xlbiA8IG1pc3NpbmcpIHtcbiAgICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCxpbnB1dF9sZW4pLGluX2J1Zik7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLG1pc3NpbmcpLGluX2J1Zik7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSBtaXNzaW5nO1xuICAgIGlucHV0X3BvcyArPSBtaXNzaW5nO1xuICB9XG4gIHdoaWxlKGlucHV0X2xlbiA+PSA2NCl7XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgNjQpLCAwKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IDY0O1xuICAgIGlucHV0X3BvcyArPSA2NDtcbiAgfVxuICBpZihpbnB1dF9sZW4pXG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgaW5wdXRfbGVuKSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1RmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENUZpbmFsKGN0eCl7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgY3R4LmI4W2luX2J1Zl0gPSAweDgwO1xuICBpbl9idWYgKys7XG4gIGlmKGluX2J1ZiA+IDU2KSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNjQ7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDU2OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfVxuICBjdHguYjMyWzE0XSA9IGN0eC5sZW4gPDwgMztcbiAgY3R4LmIzMlsxNV0gPSAoY3R4LmxlbiA+PiAyOSkgJiAweDFGRkZGRkZGO1xuICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgIHRbaSAqIDQgKyBqXSA9IChjdHgud1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gIHJldHVybiB0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfYnl0ZXMocywgb2ZzLCBsZW4pIHtcbiAgdmFyIGN0eCA9IGNhbWxfTUQ1SW5pdCgpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyk7XG4gIGNhbWxfTUQ1VXBkYXRlKGN0eCxhLnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKSwgbGVuKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX2luaXRpYWxpemVcbmZ1bmN0aW9uIGNhbWxfc3RyX2luaXRpYWxpemUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQodikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvcyh4KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2NhbWxfZXhuX2lzX21vc3RfcmVjZW50X2V4biBjb25zdFxuZnVuY3Rpb24gQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG4oeCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHogY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpIHtcbiAgdmFyIG4gPSAzMjtcbiAgdmFyIHk7XG4gIHkgPSB4ID4+MTY7IGlmICh5ICE9IDApIHsgbiA9IG4gLTE2OyB4ID0geTsgfVxuICB5ID0geCA+PiA4OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gODsgeCA9IHk7IH1cbiAgeSA9IHggPj4gNDsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDQ7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDI7IGlmICh5ICE9IDApIHsgbiA9IG4gLSAyOyB4ID0geTsgfVxuICB5ID0geCA+PiAxOyBpZiAoeSAhPSAwKSByZXR1cm4gbiAtIDI7XG4gIHJldHVybiBuIC0geDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NselxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfY2x6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NseiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2Nseih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X2NseiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3RvX2ludDMyXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X2Nseih4KSB7XG4gIHZhciBuID0gNjQ7XG4gIHZhciB5O1xuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAzMik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0zMjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMTYpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtMTY7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDgpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDQpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDQ7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDEpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIGNhbWxfaW50NjRfdG9faW50MzIoeCk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KSB7XG4gIGlmICh4ID09PSAwKSB7IHJldHVybiAzMjsgfVxuICB2YXIgbiA9IDE7XG4gIGlmICggKHggJiAweDAwMDBGRkZGKSA9PT0gMCkgeyBuID0gbiArIDE2OyB4ID0geCA+PiAxNjsgfVxuICBpZiAoICh4ICYgMHgwMDAwMDBGRikgPT09IDApIHsgbiA9IG4gKyAgODsgeCA9IHggPj4gIDg7IH1cbiAgaWYgKCAoeCAmIDB4MDAwMDAwMEYpID09PSAwKSB7IG4gPSBuICsgIDQ7IHggPSB4ID4+ICA0OyB9XG4gIGlmICggKHggJiAweDAwMDAwMDAzKSA9PT0gMCkgeyBuID0gbiArICAyOyB4ID0geCA+PiAgMjsgfVxuICByZXR1cm4gbiAtICh4ICYgMSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2N0eiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2N0eih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hbmQsIGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X2N0eih4KSB7XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8oeCkpIHsgcmV0dXJuIDY0OyB9XG4gIHZhciBuID0gMTtcbiAgZnVuY3Rpb24gaXNfemVybyAoeCkgICAgeyByZXR1cm4gY2FtbF9pbnQ2NF9pc196ZXJvKHgpOyB9XG4gIGZ1bmN0aW9uIGxhbmQgKHgseSkgICAgIHsgcmV0dXJuIGNhbWxfaW50NjRfYW5kKHgsIHkpOyB9XG4gIGZ1bmN0aW9uIHNtYWxsX2ludDY0KHgpIHsgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHgsMCwwKTsgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4RkZGRkZGLCAweDAwMDBGRiwgMHgwMDAwKSkpKSB7XG4gICAgbiA9IG4gKyAzMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMEZGRkYpKSkpIHtcbiAgICBuID0gbiArIDE2OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDBGRikpKSkge1xuICAgIG4gPSBuICsgIDg7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDgpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMDAwMEYpKSkpIHtcbiAgICBuID0gbiArICA0OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDAzKSkpKSB7XG4gICAgbiA9IG4gKyAgMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMik7XG4gIH1cbiAgcmV0dXJuIG4gLSAoY2FtbF9pbnQ2NF90b19pbnQzMihjYW1sX2ludDY0X2FuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwMSkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gMTtcbiAgdmFyIG11bCA9IFtvbmUsIGJhc2UsIG9uZSwgb25lXTtcbiAgdmFyIHJlcyA9IG9uZTtcbiAgd2hpbGUgKCFleHBvbmVudD09MCkge1xuICAgIG11bFsxXSA9IChtdWxbMV0gKiBtdWxbM10pIHwgMDtcbiAgICBtdWxbMl0gPSAobXVsWzFdICogbXVsWzFdKSB8IDA7XG4gICAgbXVsWzNdID0gKG11bFsyXSAqIG11bFsxXSkgfCAwO1xuICAgIHJlcyA9IChyZXMgKiBtdWxbZXhwb25lbnQgJiAzXSkgfCAwO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgPj4gMjtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViKGJhc2UsIGV4cG9uZW50KSB7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSgxLDApO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWNhbWxfaW50NjRfaXNfemVybyhleHBvbmVudCkpIHtcbiAgICBtdWxbMV0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFszXSk7XG4gICAgbXVsWzJdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzFdLCBtdWxbMV0pO1xuICAgIG11bFszXSA9IGNhbWxfaW50NjRfbXVsKG11bFsyXSwgbXVsWzFdKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X211bChyZXMsIG11bFtjYW1sX2ludDY0X2xvMzIoZXhwb25lbnQpICYgM10pO1xuICAgIGV4cG9uZW50ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZChleHBvbmVudCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9oYXNoX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLHMpXG59XG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfZG91YmxlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9kb3VibGUoZCkge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLGQpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2FtX3Rlc3RpbmcgY29uc3Rcbi8vV2Vha2RlZlxuZnVuY3Rpb24gQmFzZV9hbV90ZXN0aW5nKHgpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCJcbi8vUHJvdmlkZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIE1sTXV0ZXgoKSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2Vcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF9uZXdcbi8vUmVxdWlyZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbmV3KHVuaXQpIHtcbiAgcmV0dXJuIG5ldyBNbE11dGV4KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbG9ja1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF9sb2NrKHQpIHtcbiAgaWYodC5sb2NrZWQpXG4gICAgY2FtbF9mYWlsd2l0aChcIk11dGV4LmxvY2s6IG11dGV4IGFscmVhZHkgbG9ja2VkLiBDYW5ub3Qgd2FpdC5cIik7XG4gIGVsc2UgdC5sb2NrZWQgPSB0cnVlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF90cnlfbG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF90cnlfbG9jayh0KSB7XG4gIGlmKCF0LmxvY2tlZCkge1xuICAgIHQubG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKHQpIHtcbiAgdC5sb2NrZWQgPSBmYWxzZTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUElcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZih4WzFdLnJlZ2lzdGVyKSB4WzFdLnJlZ2lzdGVyKHYsIHVuZGVmaW5lZCwgdik7XG4gICAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gbmV3IGdsb2JhbFRoaXMuV2Vha1JlZih2KTtcbiAgfVxuICBlbHNlIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbMV0udW5yZWdpc3Rlcikge1xuICAgIHZhciBvbGQgPSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0uZGVyZWYoKTtcbiAgICBpZihvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvdW50ID0gMFxuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZil7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKClcbiAgICAgICAgICBpZihrZXkgPT09IG9sZCkgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoY291bnQgPT0gMSkgeFsxXS51bnJlZ2lzdGVyKG9sZCk7XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDBcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlLCBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jcmVhdGUgKG4pIHtcbiAgdmFyIHggPSBjYW1sX3dlYWtfY3JlYXRlKG4pO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2tleSwgY2FtbF9lcGhlX3Vuc2V0X2tleVxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKHYgPT0gMCkgY2FtbF9lcGhlX3Vuc2V0X2tleSh4LGkpXG4gIGVsc2UgY2FtbF9lcGhlX3NldF9rZXkoeCxpLHZbMV0pXG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIHJldHVybiAod2Vhaz09PXVuZGVmaW5lZCk/MDpbMCwgd2Vha107XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2tleSxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRfY29weVxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9rZXlfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19jaGVja1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2tleSh4LCBpKSB7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgd2VhayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikgd2VhayA9IHdlYWsuZGVyZWYoKTtcbiAgaWYod2Vhaz09PXVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19ibGl0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9rZXkoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9zZXRfZGF0YSwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICB2YXIgbiA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICBpZihuID09PSB1bmRlZmluZWQpIGNhbWxfZXBoZV91bnNldF9kYXRhKGRzdCk7XG4gIGVsc2UgY2FtbF9lcGhlX3NldF9kYXRhKGRzdCwgbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKCEgKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KSkge1xuICAgICAgeFsxXSA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICgpIHsgY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCkgfSk7XG4gICAgICAvL3JlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnJlZ2lzdGVyKGtleSwgdW5kZWZpbmVkLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCl7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkpe1xuICAgICAgLy91bnJlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnVucmVnaXN0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8vUHJvdmlkZXM6IGpzX3BlcmZvcm1hbmNlXG52YXIganNfcGVyZm9ybWFuY2UgPSB7bWFyazogKGZ1bmN0aW9uICgpIHt9KSwgbWVhc3VyZTogKGZ1bmN0aW9uICgpIHt9KSB9O1xuaWYgKHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBqc19wZXJmb3JtYW5jZSA9IGpvb19nbG9iYWxfb2JqZWN0LnBlcmZvcm1hbmNlO1xufSBlbHNlIHtcbiAgdHJ5IHtcbiAgICBqc19wZXJmb3JtYW5jZSA9IHJlcXVpcmUoJ3BlcmZfaG9va3MnKS5wZXJmb3JtYW5jZTtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oXCJjb3VsZG4ndCBsb2FkIHBlcmZvcm1hbmNlIGhvb2tzXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGpzX3Byb2ZfbWFya1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyxqc19wZXJmb3JtYW5jZVxuZnVuY3Rpb24ganNfcHJvZl9tYXJrKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBqc19wZXJmb3JtYW5jZS5tYXJrKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczoganNfcHJvZl9tZWFzdXJlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLGpzX3BlcmZvcm1hbmNlXG5mdW5jdGlvbiBqc19wcm9mX21lYXN1cmUobmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGpzX3BlcmZvcm1hbmNlLm1lYXN1cmUoXG4gICAgICAgICAgICBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpLCBcbiAgICAgICAgICAgIGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RhcnQpLCBcbiAgICAgICAgICAgIGNhbWxfanNieXRlc19vZl9zdHJpbmcoZW5kKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcm9mX2NsZWFyX21hcmtzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLGpzX3BlcmZvcm1hbmNlXG5mdW5jdGlvbiBqc19wcm9mX2NsZWFyX21hcmtzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGpzX3BlcmZvcm1hbmNlLmNsZWFyTWFya3MoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihlKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzX3Byb2ZfY2xlYXJfbWVhc3VyZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsanNfcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIGpzX3Byb2ZfY2xlYXJfbWVhc3VyZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAganNfcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3hvcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBtdWwoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCxrKSxzaGlmdF9yICh4LCA2NCAtIGspKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoYSwgaSkge1xuICAgIHJldHVybiBjYW1sX2JhX2dldF8xKGEsIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChhLCBpLCB4KSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfc2V0XzEoYSwgaSwgeCk7XG4gIH1cbiAgdmFyIE0gPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGQxMzQyNTQzZGU4MmVmOTVcIikpO1xuICB2YXIgZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSk7XG4gIHZhciB6LCBxMCwgcTE7XG4gIHZhciBzdCA9IHY7XG4gIHZhciBhID0gZ2V0KHN0LDApO1xuICB2YXIgcyA9IGdldChzdCwxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LDIpO1xuICB2YXIgeDEgPSBnZXQoc3QsMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSB4b3IoeixzaGlmdF9yKHosMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZCAobXVsKHMsTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MFxuICB2YXIgcTEgPSB4MVxuICBxMSA9IHhvcihxMSxxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgKHNoaWZ0X2wocTEsMTYpKSk7XG4gIHExID0gcm90bChxMSwgMzcpO1xuICBzZXQoc3QsIDIsIHEwKTtcbiAgc2V0KHN0LCAzLCBxMSk7XG4gIC8qIFJldHVybiByZXN1bHQgKi9cbiAgcmV0dXJuIHo7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX29qc193cmFwX2Z1bl9hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9vanNfd3JhcF9mdW5fYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikoYXJndW1lbnRzKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29qc19pdGVyYXRlX3Byb3BlcnRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29qc19pdGVyYXRlX3Byb3BlcnRpZXMobywgZikge1xuICB2YXIgbmFtZTtcbiAgZm9yKG5hbWUgaW4gbykge1xuICAgIGlmKG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGYoY2FtbF9qc190b19zdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgfVxufVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiLy8vLy8vLy8vIFRJTUVfTk9XXG5cbi8vUHJvdmlkZXM6IHRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVyb1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbnZhciBtc190b19uYW5vID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxMDAwKjEwMDApO1xuZnVuY3Rpb24gdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvKCl7XG4gICAgdmFyIG1zID0gRGF0ZS5ub3coKTtcbiAgICAvLyBtdWx0aXBsZSBieSB0d28gLSBpbnQ2MyBpbnRlZ2VycyBhcmUgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgIHZhciBtc19pNjMgPSBjYW1sX2ludDY0X29mX2Zsb2F0KG1zKjIpO1xuICAgIHJldHVybiBjYW1sX2ludDY0X211bChtc19pNjMsbXNfdG9fbmFubyk7XG59XG4iXX0=
